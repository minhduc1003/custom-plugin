import {
  r
} from "./chunk-BKGZLFRE.js";
import {
  Mo,
  N,
  U8,
  d,
  d3,
  de,
  fqe,
  g2,
  h1,
  hc,
  p1,
  z3
} from "./chunk-C4ZQG65I.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/5230605f.js
var import_react = __toESM(require_react(), 1);
var P = Object.defineProperty;
var L = (e, t, i) => t in e ? P(e, t, { enumerable: true, configurable: true, writable: true, value: i }) : e[t] = i;
var x = (e, t, i) => (L(e, typeof t != "symbol" ? t + "" : t, i), i);
var Y = de.div`
  position: relative;
  ${(e) => e.$textOverflow == false && `
    div {
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      word-break: keep-all;
    }
    span {
      display: inline-block; /* Change display to inline-block for span */
      white-space: nowrap;
      text-overflow: ellipsis;
      word-break: keep-all;
    }
  `}
`;
var G = de.div`
  position: absolute;
  height: ${(e) => e.$adjustHeight ? `${e.$adjustHeight}px` : "max-content"};
  width: ${(e) => e.$adjustWidth ? `${e.$adjustWidth}px` : "max-content"};
  visibility: ${(e) => e.$visible ? "visible" : "hidden"};
  min-width: ${(e) => e.$minWidth ? `${e.$minWidth}px` : "unset"};
  max-height: 150px;
  max-width: 300px;
  overflow: auto;
  background: inherit;
  z-index: 3;
  padding: ${(e) => e.$padding};
  top: ${(e) => `${e.$adjustTop || 0}px`};
  left: ${(e) => `${e.$adjustLeft || 0}px`};

  &::-webkit-scrollbar {
    width: 16px;
  }

  &::-webkit-scrollbar-thumb {
    border: 5px solid transparent;
    background-clip: content-box;
    border-radius: 9999px;
    background-color: rgba(139, 143, 163, 0.2);
    min-height: 30px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background-color: rgba(139, 143, 163, 0.5);
  }
`;
function W(e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    return i.clientHeight < i.scrollHeight || i.clientWidth < i.scrollWidth ? true : W(i.children);
  }
  return false;
}
function Z(e) {
  var m;
  const t = (0, import_react.useRef)(null), i = (0, import_react.useRef)(null), [o, d2] = (0, import_react.useState)(false), [r2, c] = (0, import_react.useState)(false), [u, p] = (0, import_react.useState)({
    done: false
  }), [h, f] = (0, import_react.useState)(), g = (0, import_react.useMemo)(() => () => f(setTimeout(() => {
    d2(true);
  }, 300)), []);
  return (0, import_react.useEffect)(() => {
    const n = t.current;
    if (!o || !n)
      return;
    n.clientHeight < n.scrollHeight || n.clientWidth < n.scrollWidth || W(n.children) ? !r2 && c(true) : r2 && c(false);
  }, [o]), (0, import_react.useEffect)(() => {
    var E;
    const n = t.current, s = i.current;
    if (!o || !r2) {
      n != null && n.parentElement && (n.parentElement.style.zIndex = ""), p({
        done: false
      });
      return;
    }
    const a = (E = t.current) == null ? void 0 : E.closest(".ant-table-content");
    if (!s || !a || !n)
      return;
    n.parentElement && (n.parentElement.style.zIndex = "999");
    const w = Math.min(s.getBoundingClientRect().width, a.getBoundingClientRect().width), y = Math.min(s.getBoundingClientRect().height, a.getBoundingClientRect().height);
    let b;
    const V = a.getBoundingClientRect().x - s.getBoundingClientRect().x, F = a.getBoundingClientRect().x + a.offsetWidth - (s.getBoundingClientRect().x + w);
    V > 0 ? b = V : F < 0 && (b = F);
    const v = a.getBoundingClientRect().y + a.offsetHeight - (s.getBoundingClientRect().y + y);
    p({
      left: b,
      top: v < 0 ? v : void 0,
      height: y,
      width: w,
      done: true
    });
  }, [o, r2]), N(p1, {
    children: [d(Y, {
      ref: t,
      $textOverflow: e.textOverflow,
      onMouseEnter: () => {
        g();
      },
      onMouseLeave: () => {
        clearTimeout(h), d2(false);
      },
      children: e.children
    }), o && r2 && t.current && !e.textOverflow && d(G, {
      ref: i,
      $visible: u.done,
      $minWidth: (m = t.current.offsetParent) == null ? void 0 : m.clientWidth,
      $adjustWidth: u.width,
      $adjustHeight: u.height,
      $adjustLeft: u.left,
      $adjustTop: u.top,
      $padding: `${t.current.offsetTop}px ${t.current.offsetLeft}px`,
      onMouseEnter: () => {
        d2(true);
      },
      onMouseLeave: () => d2(false),
      children: e.children
    })]
  });
}
var K = import_react.default.createContext([]);
var Q = import_react.default.createContext([]);
var ee = de.div`
  position: absolute;
  top: 2px;
  right: 2px;
  z-index: 2;

  width: 0px;
  height: 0px;
  border: 4.5px solid transparent;
  border-radius: 2px;
  border-top-color: ${fqe[1].color};
  border-right-color: ${fqe[1].color};
`;
var te = de.div`
  position: absolute;
  border: 1.5px solid #315efb;
  height: 100%;
  width: 100%;
  top: 0;
  left: 0;
`;
var R = ({
  children: e,
  tooltipTitle: t
}) => t ? d(Mo, {
  title: t,
  placement: "topLeft",
  children: e
}) : d(p1, {
  children: e
});
function ie(e) {
  const {
    dispatch: t,
    normalView: i,
    editViewFn: o,
    changeValue: d2,
    baseValue: r2,
    candidateTags: c,
    // tagColors
    candidateStatus: u,
    editMode: p,
    onTableEvent: h
  } = e, f = h1.isNil(d2) ? "normal" : "toSave", g = o ? e.editable : false, {
    isEditing: m,
    setIsEditing: n
  } = (0, import_react.useContext)(r), s = d2 ?? r2, [a, w] = (0, import_react.useState)(s), y = p === "single";
  (0, import_react.useEffect)(() => {
    w(s);
  }, [JSON.stringify(s)]);
  const b = (0, import_react.useCallback)((E) => {
    w(E);
  }, [w]), V = (0, import_react.useCallback)(() => {
    n(false), t(U8("changeValue", h1.isNil(a) || h1.isEqual(a, r2) ? null : a, false)), h1.isEqual(a, s) || h == null || h("columnEdited");
  }, [t, JSON.stringify(r2), JSON.stringify(a)]), F = (0, import_react.useMemo)(() => (o == null ? void 0 : o({
    value: s,
    onChange: b,
    onChangeEnd: V
  })) ?? d(p1, {}), [o, JSON.stringify(s), b, V]), v = (0, import_react.useCallback)(() => {
    g && n(true);
  }, [g]);
  return m ? N(p1, {
    children: [d(te, {
      className: "editing-border"
    }), d(K.Provider, {
      value: c ?? [],
      children: d(Q.Provider, {
        value: u ?? [],
        children: d("div", {
          className: "editing-wrapper",
          children: F
        })
      })
    })]
  }) : N(Z, {
    textOverflow: e.textOverflow,
    children: [f === "toSave" && !m && d(ee, {}), d(R, {
      tooltipTitle: e.cellTooltip,
      children: d("div", {
        tabIndex: g ? 0 : -1,
        onFocus: v,
        children: i
      })
    }), g && d(R, {
      tooltipTitle: e.cellTooltip,
      children: d("div", {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%"
        },
        onDoubleClick: y ? void 0 : v,
        onClick: y ? v : void 0
      })
    })]
  });
}
var j = "__COLUMN_DISPLAY_VALUE_FN";
var ne = class {
  constructor(t, i, o, d2) {
    x(this, "childrenMap");
    x(this, "propertyViewFn");
    x(this, "stylePropertyViewFn");
    x(this, "editViewFn");
    this.viewFn = i, this.displayValueFn = o, this.baseValueFn = d2, this.childrenMap = {
      ...t,
      changeValue: z3(null)
    };
  }
  setEditViewFn(t) {
    return this.editViewFn = t, this;
  }
  setPropertyViewFn(t) {
    return this.propertyViewFn = t, this;
  }
  setStylePropertyViewFn(t) {
    return this.stylePropertyViewFn = t, this;
  }
  build() {
    if (!this.propertyViewFn)
      throw new Error("need property view fn");
    const t = (r2, c) => (u) => {
      var f;
      const p = (f = this.baseValueFn) == null ? void 0 : f.call(this, r2, c), h = this.viewFn(r2, c);
      return d(ie, {
        ...u,
        normalView: h,
        dispatch: c,
        baseValue: p,
        changeValue: r2.changeValue,
        editViewFn: this.editViewFn
      });
    }, i = new g2(this.childrenMap, t).setPropertyViewFn(this.propertyViewFn).build(), o = this.displayValueFn, d2 = this.editViewFn;
    return class extends i {
      constructor() {
        super(...arguments);
        x(this, "displayValue", null);
      }
      extraNode() {
        return {
          node: {
            [j]: hc(d3(this.childrenNode()), () => o)
          },
          updateNodeFields: (c) => {
            const u = c[j];
            return {
              displayValue: u(c)
            };
          }
        };
      }
      /**
       * Get the data actually displayed by the table cell
       */
      getDisplayValue() {
        return this.displayValue;
      }
      static canBeEditable() {
        return !h1.isNil(d2);
      }
    };
  }
};
var ae = Object.freeze(Object.defineProperty({
  __proto__: null,
  ColumnTypeCompBuilder: ne,
  __COLUMN_DISPLAY_VALUE_FN: j
}, Symbol.toStringTag, { value: "Module" }));

export {
  K,
  Q,
  j,
  ne,
  ae
};
//# sourceMappingURL=chunk-N55PIOUB.js.map
