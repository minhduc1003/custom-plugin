import {
  Q2,
  a5,
  is,
  sn
} from "./chunk-C4ZQG65I.js";
import "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/3072ddca.js
var import_react = __toESM(require_react(), 1);
function J(t, o) {
  for (var n = 0; n < o.length; n++) {
    const e = o[n];
    if (typeof e != "string" && !Array.isArray(e)) {
      for (const i in e)
        if (i !== "default" && !(i in t)) {
          const s = Object.getOwnPropertyDescriptor(e, i);
          s && Object.defineProperty(t, i, s.get ? s : {
            enumerable: true,
            get: () => e[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
var I = { exports: {} };
function T(t, o, n) {
  this.x = t, this.y = o, this.time = n || (/* @__PURE__ */ new Date()).getTime();
}
T.prototype.velocityFrom = function(t) {
  return this.time !== t.time ? this.distanceTo(t) / (this.time - t.time) : 1;
};
T.prototype.distanceTo = function(t) {
  return Math.sqrt(Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2));
};
T.prototype.equals = function(t) {
  return this.x === t.x && this.y === t.y && this.time === t.time;
};
function U(t, o, n, e) {
  this.startPoint = t, this.control1 = o, this.control2 = n, this.endPoint = e;
}
U.prototype.length = function() {
  for (var t = 10, o = 0, n = void 0, e = void 0, i = 0; i <= t; i += 1) {
    var s = i / t, a = this._point(s, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x), u = this._point(s, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
    if (i > 0) {
      var l = a - n, r = u - e;
      o += Math.sqrt(l * l + r * r);
    }
    n = a, e = u;
  }
  return o;
};
U.prototype._point = function(t, o, n, e, i) {
  return o * (1 - t) * (1 - t) * (1 - t) + 3 * n * (1 - t) * (1 - t) * t + 3 * e * (1 - t) * t * t + i * t * t * t;
};
function Q(t, o, n) {
  var e, i, s, a = null, u = 0;
  n || (n = {});
  var l = function() {
    u = n.leading === false ? 0 : Date.now(), a = null, s = t.apply(e, i), a || (e = i = null);
  };
  return function() {
    var r = Date.now();
    !u && n.leading === false && (u = r);
    var c = o - (r - u);
    return e = this, i = arguments, c <= 0 || c > o ? (a && (clearTimeout(a), a = null), u = r, s = t.apply(e, i), a || (e = i = null)) : !a && n.trailing !== false && (a = setTimeout(l, c)), s;
  };
}
function _(t, o) {
  var n = this, e = o || {};
  this.velocityFilterWeight = e.velocityFilterWeight || 0.7, this.minWidth = e.minWidth || 0.5, this.maxWidth = e.maxWidth || 2.5, this.throttle = "throttle" in e ? e.throttle : 16, this.minDistance = "minDistance" in e ? e.minDistance : 5, this.throttle ? this._strokeMoveUpdate = Q(_.prototype._strokeUpdate, this.throttle) : this._strokeMoveUpdate = _.prototype._strokeUpdate, this.dotSize = e.dotSize || function() {
    return (this.minWidth + this.maxWidth) / 2;
  }, this.penColor = e.penColor || "black", this.backgroundColor = e.backgroundColor || "rgba(0,0,0,0)", this.onBegin = e.onBegin, this.onEnd = e.onEnd, this._canvas = t, this._ctx = t.getContext("2d"), this.clear(), this._handleMouseDown = function(i) {
    i.which === 1 && (n._mouseButtonDown = true, n._strokeBegin(i));
  }, this._handleMouseMove = function(i) {
    n._mouseButtonDown && n._strokeMoveUpdate(i);
  }, this._handleMouseUp = function(i) {
    i.which === 1 && n._mouseButtonDown && (n._mouseButtonDown = false, n._strokeEnd(i));
  }, this._handleTouchStart = function(i) {
    if (i.targetTouches.length === 1) {
      var s = i.changedTouches[0];
      n._strokeBegin(s);
    }
  }, this._handleTouchMove = function(i) {
    i.preventDefault();
    var s = i.targetTouches[0];
    n._strokeMoveUpdate(s);
  }, this._handleTouchEnd = function(i) {
    var s = i.target === n._canvas;
    s && (i.preventDefault(), n._strokeEnd(i));
  }, this.on();
}
_.prototype.clear = function() {
  var t = this._ctx, o = this._canvas;
  t.fillStyle = this.backgroundColor, t.clearRect(0, 0, o.width, o.height), t.fillRect(0, 0, o.width, o.height), this._data = [], this._reset(), this._isEmpty = true;
};
_.prototype.fromDataURL = function(t) {
  var o = this, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, e = new Image(), i = n.ratio || window.devicePixelRatio || 1, s = n.width || this._canvas.width / i, a = n.height || this._canvas.height / i;
  this._reset(), e.src = t, e.onload = function() {
    o._ctx.drawImage(e, 0, 0, s, a);
  }, this._isEmpty = false;
};
_.prototype.toDataURL = function(t) {
  var o;
  switch (t) {
    case "image/svg+xml":
      return this._toSVG();
    default:
      for (var n = arguments.length, e = Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
        e[i - 1] = arguments[i];
      return (o = this._canvas).toDataURL.apply(o, [t].concat(e));
  }
};
_.prototype.on = function() {
  this._handleMouseEvents(), this._handleTouchEvents();
};
_.prototype.off = function() {
  this._canvas.removeEventListener("mousedown", this._handleMouseDown), this._canvas.removeEventListener("mousemove", this._handleMouseMove), document.removeEventListener("mouseup", this._handleMouseUp), this._canvas.removeEventListener("touchstart", this._handleTouchStart), this._canvas.removeEventListener("touchmove", this._handleTouchMove), this._canvas.removeEventListener("touchend", this._handleTouchEnd);
};
_.prototype.isEmpty = function() {
  return this._isEmpty;
};
_.prototype._strokeBegin = function(t) {
  this._data.push([]), this._reset(), this._strokeUpdate(t), typeof this.onBegin == "function" && this.onBegin(t);
};
_.prototype._strokeUpdate = function(t) {
  var o = t.clientX, n = t.clientY, e = this._createPoint(o, n), i = this._data[this._data.length - 1], s = i && i[i.length - 1], a = s && e.distanceTo(s) < this.minDistance;
  if (!(s && a)) {
    var u = this._addPoint(e), l = u.curve, r = u.widths;
    l && r && this._drawCurve(l, r.start, r.end), this._data[this._data.length - 1].push({
      x: e.x,
      y: e.y,
      time: e.time,
      color: this.penColor
    });
  }
};
_.prototype._strokeEnd = function(t) {
  var o = this.points.length > 2, n = this.points[0];
  if (!o && n && this._drawDot(n), n) {
    var e = this._data[this._data.length - 1], i = e[e.length - 1];
    n.equals(i) || e.push({
      x: n.x,
      y: n.y,
      time: n.time,
      color: this.penColor
    });
  }
  typeof this.onEnd == "function" && this.onEnd(t);
};
_.prototype._handleMouseEvents = function() {
  this._mouseButtonDown = false, this._canvas.addEventListener("mousedown", this._handleMouseDown), this._canvas.addEventListener("mousemove", this._handleMouseMove), document.addEventListener("mouseup", this._handleMouseUp);
};
_.prototype._handleTouchEvents = function() {
  this._canvas.style.msTouchAction = "none", this._canvas.style.touchAction = "none", this._canvas.addEventListener("touchstart", this._handleTouchStart), this._canvas.addEventListener("touchmove", this._handleTouchMove), this._canvas.addEventListener("touchend", this._handleTouchEnd);
};
_.prototype._reset = function() {
  this.points = [], this._lastVelocity = 0, this._lastWidth = (this.minWidth + this.maxWidth) / 2, this._ctx.fillStyle = this.penColor;
};
_.prototype._createPoint = function(t, o, n) {
  var e = this._canvas.getBoundingClientRect();
  return new T(t - e.left, o - e.top, n || (/* @__PURE__ */ new Date()).getTime());
};
_.prototype._addPoint = function(t) {
  var o = this.points, n = void 0;
  if (o.push(t), o.length > 2) {
    o.length === 3 && o.unshift(o[0]), n = this._calculateCurveControlPoints(o[0], o[1], o[2]);
    var e = n.c2;
    n = this._calculateCurveControlPoints(o[1], o[2], o[3]);
    var i = n.c1, s = new U(o[1], e, i, o[2]), a = this._calculateCurveWidths(s);
    return o.shift(), { curve: s, widths: a };
  }
  return {};
};
_.prototype._calculateCurveControlPoints = function(t, o, n) {
  var e = t.x - o.x, i = t.y - o.y, s = o.x - n.x, a = o.y - n.y, u = { x: (t.x + o.x) / 2, y: (t.y + o.y) / 2 }, l = { x: (o.x + n.x) / 2, y: (o.y + n.y) / 2 }, r = Math.sqrt(e * e + i * i), c = Math.sqrt(s * s + a * a), f = u.x - l.x, p = u.y - l.y, y = c / (r + c), x = { x: l.x + f * y, y: l.y + p * y }, g = o.x - x.x, P = o.y - x.y;
  return {
    c1: new T(u.x + g, u.y + P),
    c2: new T(l.x + g, l.y + P)
  };
};
_.prototype._calculateCurveWidths = function(t) {
  var o = t.startPoint, n = t.endPoint, e = { start: null, end: null }, i = this.velocityFilterWeight * n.velocityFrom(o) + (1 - this.velocityFilterWeight) * this._lastVelocity, s = this._strokeWidth(i);
  return e.start = this._lastWidth, e.end = s, this._lastVelocity = i, this._lastWidth = s, e;
};
_.prototype._strokeWidth = function(t) {
  return Math.max(this.maxWidth / (t + 1), this.minWidth);
};
_.prototype._drawPoint = function(t, o, n) {
  var e = this._ctx;
  e.moveTo(t, o), e.arc(t, o, n, 0, 2 * Math.PI, false), this._isEmpty = false;
};
_.prototype._drawCurve = function(t, o, n) {
  var e = this._ctx, i = n - o, s = Math.floor(t.length());
  e.beginPath();
  for (var a = 0; a < s; a += 1) {
    var u = a / s, l = u * u, r = l * u, c = 1 - u, f = c * c, p = f * c, y = p * t.startPoint.x;
    y += 3 * f * u * t.control1.x, y += 3 * c * l * t.control2.x, y += r * t.endPoint.x;
    var x = p * t.startPoint.y;
    x += 3 * f * u * t.control1.y, x += 3 * c * l * t.control2.y, x += r * t.endPoint.y;
    var g = o + r * i;
    this._drawPoint(y, x, g);
  }
  e.closePath(), e.fill();
};
_.prototype._drawDot = function(t) {
  var o = this._ctx, n = typeof this.dotSize == "function" ? this.dotSize() : this.dotSize;
  o.beginPath(), this._drawPoint(t.x, t.y, n), o.closePath(), o.fill();
};
_.prototype._fromData = function(t, o, n) {
  for (var e = 0; e < t.length; e += 1) {
    var i = t[e];
    if (i.length > 1)
      for (var s = 0; s < i.length; s += 1) {
        var a = i[s], u = new T(a.x, a.y, a.time), l = a.color;
        if (s === 0)
          this.penColor = l, this._reset(), this._addPoint(u);
        else if (s !== i.length - 1) {
          var r = this._addPoint(u), c = r.curve, f = r.widths;
          c && f && o(c, f, l);
        }
      }
    else {
      this._reset();
      var p = i[0];
      n(p);
    }
  }
};
_.prototype._toSVG = function() {
  var t = this, o = this._data, n = this._canvas, e = Math.max(window.devicePixelRatio || 1, 1), i = 0, s = 0, a = n.width / e, u = n.height / e, l = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  l.setAttributeNS(null, "width", n.width), l.setAttributeNS(null, "height", n.height), this._fromData(o, function(v, D, M) {
    var C = document.createElement("path");
    if (!isNaN(v.control1.x) && !isNaN(v.control1.y) && !isNaN(v.control2.x) && !isNaN(v.control2.y)) {
      var L = "M " + v.startPoint.x.toFixed(3) + "," + v.startPoint.y.toFixed(3) + " " + ("C " + v.control1.x.toFixed(3) + "," + v.control1.y.toFixed(3) + " ") + (v.control2.x.toFixed(3) + "," + v.control2.y.toFixed(3) + " ") + (v.endPoint.x.toFixed(3) + "," + v.endPoint.y.toFixed(3));
      C.setAttribute("d", L), C.setAttribute("stroke-width", (D.end * 2.25).toFixed(3)), C.setAttribute("stroke", M), C.setAttribute("fill", "none"), C.setAttribute("stroke-linecap", "round"), l.appendChild(C);
    }
  }, function(v) {
    var D = document.createElement("circle"), M = typeof t.dotSize == "function" ? t.dotSize() : t.dotSize;
    D.setAttribute("r", M), D.setAttribute("cx", v.x), D.setAttribute("cy", v.y), D.setAttribute("fill", v.color), l.appendChild(D);
  });
  var r = "data:image/svg+xml;base64,", c = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"' + (' viewBox="' + i + " " + s + " " + a + " " + u + '"') + (' width="' + a + '"') + (' height="' + u + '"') + ">", f = l.innerHTML;
  if (f === void 0) {
    var p = document.createElement("dummy"), y = l.childNodes;
    p.innerHTML = "";
    for (var x = 0; x < y.length; x += 1)
      p.appendChild(y[x].cloneNode(true));
    f = p.innerHTML;
  }
  var g = "</svg>", P = c + f + g;
  return r + btoa(P);
};
_.prototype.fromData = function(t) {
  var o = this;
  this.clear(), this._fromData(t, function(n, e) {
    return o._drawCurve(n, e.start, e.end);
  }, function(n) {
    return o._drawDot(n);
  }), this._data = t;
};
_.prototype.toData = function() {
  return this._data;
};
var Z = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: _
}, Symbol.toStringTag, { value: "Module" }));
var tt = a5(Z);
var R = { exports: {} };
var N;
function et() {
  return N || (N = 1, function(t, o) {
    (function(n, e) {
      t.exports = e();
    })(Q2, function() {
      return function(n) {
        function e(s) {
          if (i[s])
            return i[s].exports;
          var a = i[s] = { exports: {}, id: s, loaded: false };
          return n[s].call(a.exports, a, a.exports, e), a.loaded = true, a.exports;
        }
        var i = {};
        return e.m = n, e.c = i, e.p = "", e(0);
      }([function(n, e) {
        function i(r) {
          var c = r.getContext("2d"), f = r.width, p = r.height, y = c.getImageData(0, 0, f, p).data, x = u(true, f, p, y), g = u(false, f, p, y), P = l(true, f, p, y), v = l(false, f, p, y), D = v - P + 1, M = g - x + 1, C = c.getImageData(P, x, D, M);
          return r.width = D, r.height = M, c.clearRect(0, 0, D, M), c.putImageData(C, 0, 0), r;
        }
        function s(r, c, f, p) {
          return { red: p[4 * (f * c + r)], green: p[4 * (f * c + r) + 1], blue: p[4 * (f * c + r) + 2], alpha: p[4 * (f * c + r) + 3] };
        }
        function a(r, c, f, p) {
          return s(r, c, f, p).alpha;
        }
        function u(r, c, f, p) {
          for (var y = r ? 1 : -1, x = r ? 0 : f - 1, g = x; r ? g < f : g > -1; g += y)
            for (var P = 0; P < c; P++)
              if (a(P, g, c, p))
                return g;
          return null;
        }
        function l(r, c, f, p) {
          for (var y = r ? 1 : -1, x = r ? 0 : c - 1, g = x; r ? g < c : g > -1; g += y)
            for (var P = 0; P < f; P++)
              if (a(g, P, c, p))
                return g;
          return null;
        }
        Object.defineProperty(e, "__esModule", { value: true }), e.default = i;
      }]);
    });
  }(R)), R.exports;
}
(function(t, o) {
  (function(n, e) {
    t.exports = e(is, import_react.default, tt, et());
  })(Q2, function(n, e, i, s) {
    return function(a) {
      function u(r) {
        if (l[r])
          return l[r].exports;
        var c = l[r] = { exports: {}, id: r, loaded: false };
        return a[r].call(c.exports, c, c.exports, u), c.loaded = true, c.exports;
      }
      var l = {};
      return u.m = a, u.c = l, u.p = "", u(0);
    }([function(a, u, l) {
      function r(m) {
        return m && m.__esModule ? m : { default: m };
      }
      function c(m, d) {
        var b = {};
        for (var w in m)
          d.indexOf(w) >= 0 || Object.prototype.hasOwnProperty.call(m, w) && (b[w] = m[w]);
        return b;
      }
      function f(m, d) {
        if (!(m instanceof d))
          throw new TypeError("Cannot call a class as a function");
      }
      function p(m, d) {
        if (!m)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !d || typeof d != "object" && typeof d != "function" ? m : d;
      }
      function y(m, d) {
        if (typeof d != "function" && d !== null)
          throw new TypeError("Super expression must either be null or a function, not " + typeof d);
        m.prototype = Object.create(d && d.prototype, { constructor: { value: m, enumerable: false, writable: true, configurable: true } }), d && (Object.setPrototypeOf ? Object.setPrototypeOf(m, d) : m.__proto__ = d);
      }
      Object.defineProperty(u, "__esModule", { value: true });
      var x = Object.assign || function(m) {
        for (var d = 1; d < arguments.length; d++) {
          var b = arguments[d];
          for (var w in b)
            Object.prototype.hasOwnProperty.call(b, w) && (m[w] = b[w]);
        }
        return m;
      }, g = /* @__PURE__ */ function() {
        function m(d, b) {
          for (var w = 0; w < b.length; w++) {
            var h = b[w];
            h.enumerable = h.enumerable || false, h.configurable = true, "value" in h && (h.writable = true), Object.defineProperty(d, h.key, h);
          }
        }
        return function(d, b, w) {
          return b && m(d.prototype, b), w && m(d, w), d;
        };
      }(), P = l(1), v = r(P), D = l(2), M = r(D), C = l(3), L = r(C), H = l(4), $ = r(H), W = function(m) {
        function d() {
          var b, w, h, A;
          f(this, d);
          for (var B = arguments.length, j = Array(B), S = 0; S < B; S++)
            j[S] = arguments[S];
          return w = h = p(this, (b = d.__proto__ || Object.getPrototypeOf(d)).call.apply(b, [this].concat(j))), h._sigPad = null, h._excludeOurProps = function() {
            var E = h.props, O = (E.canvasProps, E.clearOnResize, c(E, ["canvasProps", "clearOnResize"]));
            return O;
          }, h.getCanvas = function() {
            return h._canvas;
          }, h.getTrimmedCanvas = function() {
            var E = document.createElement("canvas");
            return E.width = h._canvas.width, E.height = h._canvas.height, E.getContext("2d").drawImage(h._canvas, 0, 0), (0, $.default)(E);
          }, h.getSignaturePad = function() {
            return h._sigPad;
          }, h._checkClearOnResize = function() {
            h.props.clearOnResize && h._resizeCanvas();
          }, h._resizeCanvas = function() {
            var E = h.props.canvasProps || {}, O = E.width, F = E.height;
            if (!O || !F) {
              var k = h._canvas, z = Math.max(window.devicePixelRatio || 1, 1);
              O || (k.width = k.offsetWidth * z), F || (k.height = k.offsetHeight * z), k.getContext("2d").scale(z, z), h.clear();
            }
          }, h.on = function() {
            return window.addEventListener("resize", h._checkClearOnResize), h._sigPad.on();
          }, h.off = function() {
            return window.removeEventListener("resize", h._checkClearOnResize), h._sigPad.off();
          }, h.clear = function() {
            return h._sigPad.clear();
          }, h.isEmpty = function() {
            return h._sigPad.isEmpty();
          }, h.fromDataURL = function(E, O) {
            return h._sigPad.fromDataURL(E, O);
          }, h.toDataURL = function(E, O) {
            return h._sigPad.toDataURL(E, O);
          }, h.fromData = function(E) {
            return h._sigPad.fromData(E);
          }, h.toData = function() {
            return h._sigPad.toData();
          }, A = w, p(h, A);
        }
        return y(d, m), g(d, [{ key: "componentDidMount", value: function() {
          this._sigPad = new L.default(this._canvas, this._excludeOurProps()), this._resizeCanvas(), this.on();
        } }, { key: "componentWillUnmount", value: function() {
          this.off();
        } }, { key: "componentDidUpdate", value: function() {
          Object.assign(this._sigPad, this._excludeOurProps());
        } }, { key: "render", value: function() {
          var b = this, w = this.props.canvasProps;
          return M.default.createElement("canvas", x({ ref: function(h) {
            b._canvas = h;
          } }, w));
        } }]), d;
      }(D.Component);
      W.propTypes = { velocityFilterWeight: v.default.number, minWidth: v.default.number, maxWidth: v.default.number, minDistance: v.default.number, dotSize: v.default.oneOfType([v.default.number, v.default.func]), penColor: v.default.string, throttle: v.default.number, onEnd: v.default.func, onBegin: v.default.func, canvasProps: v.default.object, clearOnResize: v.default.bool }, W.defaultProps = { clearOnResize: true }, u.default = W;
    }, function(a, u) {
      a.exports = n;
    }, function(a, u) {
      a.exports = e;
    }, function(a, u) {
      a.exports = i;
    }, function(a, u) {
      a.exports = s;
    }]);
  });
})(I);
var V = I.exports;
var nt = sn(V);
var rt = J({
  __proto__: null,
  default: nt
}, [V]);
export {
  rt as i
};
/*! Bundled license information:

lowcoder-sdk/dist/3072ddca.js:
  (*!
   * Signature Pad v2.3.2
   * https://github.com/szimek/signature_pad
   *
   * Copyright 2017 Szymon Nowak
   * Released under the MIT license
   *
   * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:
   * http://corner.squareup.com/2012/07/smoother-signatures.html
   *
   * Implementation of interpolation using cubic Bézier curves is taken from:
   * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript
   *
   * Algorithm for approximated length of a Bézier curve is taken from:
   * http://www.lemoda.net/maths/bezier-length/index.html
   *
   *)
*/
//# sourceMappingURL=3072ddca-XSOCO4UX.js.map
