import {
  C
} from "./chunk-OK47LCRW.js";
import {
  IC,
  Jf,
  LH,
  N,
  Qf,
  T5n,
  Tx,
  Vr,
  YKe,
  d,
  de,
  dg,
  fe1,
  h1,
  hWe,
  il,
  jdn,
  zc,
  zf
} from "./chunk-C4ZQG65I.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/842a0c82.js
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var dt = de.div`
  height: 100%;
  border: 1px solid ${(e) => e.$style.border};
  border-radius: ${(e) => e.$style.radius};
  padding: 3px ${(e) => e.$paddingWidth};
  rotate: ${(e) => e.$style.rotation};
  background-color: ${(e) => e.$style.background};
  ${(e) => e.$animationStyle}
`;
var ct = de.div`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 3px;
`;
var ht = de.div`
  height: ${(e) => e.$autoHeight ? "100%" : "calc(100% - 32px)"};
`;
var gt = de.div` 
  height: 100%;
  display: flex;
  align-items: center;
  // justify-content: center;
`;
var mt = de.div`
  height: ${(e) => e.$autoHeight ? "auto" : "100%"};
  display: flex;
  flex-direction: ${(e) => e.$isHorizontal && !e.$isGrid ? "row" : "column"};
  height: 100%;
`;
var S = (0, import_react.createContext)({
  horizontalWidth: "100%",
  minHorizontalWidth: "100px"
});
var pt = (e) => {
  const {
    horizontalWidth: l,
    minHorizontalWidth: t
  } = (0, import_react.useContext)(S);
  return d("div", {
    style: {
      width: l,
      minWidth: t || "0px"
    },
    children: d(Jf, {
      ...e,
      emptyRows: 15,
      containerPadding: [4, 4],
      hintPlaceholder: LH
    })
  });
};
function ut({
  minHorizontalWidth: e,
  horizontalWidth: l,
  ...t
}) {
  const {
    itemIdx: d2,
    offset: a,
    containerProps: c,
    autoHeight: w,
    scrollContainerRef: y,
    minHeight: p,
    horizontalGridCells: z
  } = t;
  return d(S.Provider, {
    value: {
      horizontalWidth: l,
      minHorizontalWidth: e
    },
    children: d(pt, {
      layout: c.layout,
      items: IC(c.items),
      horizontalGridCells: z,
      positionParams: c.positionParams,
      dispatch: d2 === a ? c.dispatch : h1.noop,
      style: {
        height: "100%",
        // in case of horizontal mode, minHorizontalWidth is 0px
        width: e || "100%",
        backgroundColor: "transparent"
        // flex: "auto",
      },
      autoHeight: w,
      isDroppable: d2 === a,
      isDraggable: d2 === a,
      isResizable: d2 === a,
      isSelectable: d2 === a,
      scrollContainerRef: y,
      overflow: "hidden",
      minHeight: p,
      enableGridLines: true
    })
  });
}
function Ht(e) {
  const {
    comp: l
  } = e, t = l.children, d2 = (0, import_react.useRef)(null), a = (0, import_react.useContext)(Vr), c = a.isDragging, [w, y] = T5n(0, c), p = (0, import_react.useMemo)(() => t.dynamicHeight.getView(), [t.dynamicHeight]), z = (0, import_react.useMemo)(() => t.heightUnitOfRow.getView(), [t.heightUnitOfRow]), v = (0, import_react.useMemo)(() => t.container.getView(), [t.container]), P = (0, import_react.useMemo)(() => t.itemIndexName.getView(), [t.itemIndexName]), R = (0, import_react.useMemo)(() => t.itemDataName.getView(), [t.itemDataName]), {
    data: I,
    itemCount: C2
  } = (0, import_react.useMemo)(() => fe1(t.noOfRows.getView()), [t.noOfRows]), D = (0, import_react.useMemo)(() => t.horizontalGridCells.getView(), [t.horizontalGridCells]), u = (0, import_react.useMemo)(() => t.autoHeight.getView(), [t.autoHeight]), O = (0, import_react.useMemo)(() => t.scrollbars.getView(), [t.scrollbars]), b = (0, import_react.useMemo)(() => t.horizontal.getView(), [t.horizontal]), M = (0, import_react.useMemo)(() => t.minHorizontalWidth.getView(), [t.minHorizontalWidth]), g = (0, import_react.useMemo)(() => Math.max(1, t.noOfColumns.getView()), [t.noOfColumns]), r = (0, import_react.useMemo)(() => {
    const s = t.pagination.getView(), h = s.total || C2;
    let f = s.current, n = (f - 1) * s.pageSize;
    const $ = Math.max(0, Math.min(s.pageSize, h - n));
    return {
      pagination: {
        ...s,
        current: f,
        total: h
      },
      offset: n,
      currentPageSize: $,
      total: h
    };
  }, [t.pagination, C2]), V = t.style.getView(), G = t.animationStyle.getView(), L = l.realSimpleContainer().children.layout.getView(), H = r.currentPageSize > 0 && (h1.isEmpty(L) || a.isDragging), k = H ? 1 : Math.floor((r.currentPageSize + g - 1) / g), N2 = H ? "100%" : p ? "auto" : z * 44 + "px", F = c && u ? w + "px" : "100%", j = h1.range(0, k).map((s) => d("div", {
    style: {
      height: N2,
      width: "100%"
    },
    children: d(gt, {
      children: h1.range(0, g).map((f) => {
        const n = s * g + f + r.offset;
        if (n >= r.total || n >= r.offset + r.pagination.pageSize || H && n > r.offset)
          return d("div", {
            style: {
              flex: "auto"
            }
          }, n);
        const $ = v({
          [P]: n,
          [R]: jdn(I, n)
        }, String(n)).getView(), U = () => {
          l.children.container.dispatch(il(C.batchDeleteAction([String(n)])));
        };
        return d(ut, {
          itemIdx: n,
          offset: r.offset,
          containerProps: $,
          horizontalGridCells: D,
          autoHeight: c || p,
          scrollContainerRef: d2,
          minHeight: F,
          unMountFn: U,
          horizontalWidth: `${100 / g}%`,
          minHorizontalWidth: b ? M : void 0
        }, n);
      })
    })
  }, s)), B = a.getAppSettings().maxWidth, A = zf(B) ? "4px" : "16px";
  return dg(l.children), d(Qf.Provider, {
    value: V.background,
    children: N(dt, {
      $style: V,
      $paddingWidth: A,
      $animationStyle: G,
      children: [d(ht, {
        ref: d2,
        $autoHeight: u,
        children: d(zc, {
          style: {
            height: u ? "auto" : "100%",
            margin: "0px",
            padding: "0px"
          },
          hideScrollbar: !O,
          children: d(hWe, {
            onResize: (s, h) => {
              h && y(h);
            },
            observerOptions: {
              box: "border-box"
            },
            render: () => d(mt, {
              $isHorizontal: b,
              $isGrid: g > 1,
              $autoHeight: u,
              children: j
            })
          })
        })
      }), d(ct, {
        children: d(Tx, {
          size: "small",
          itemRender: YKe,
          ...r.pagination
        })
      })]
    })
  });
}

export {
  Ht
};
//# sourceMappingURL=chunk-LO3KA2SO.js.map
