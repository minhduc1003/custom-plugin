import {
  $,
  D,
  E,
  N,
  P,
  R,
  S,
  V,
  _,
  x,
  z
} from "./chunk-WDNBFYA3.js";
import {
  A
} from "./chunk-ANFJG6VM.js";
import {
  E as E2,
  S as S2
} from "./chunk-VMHS7O5Q.js";
import {
  v
} from "./chunk-6DTACY26.js";
import {
  N as N2,
  _e,
  d,
  p1,
  sn
} from "./chunk-C4ZQG65I.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/2242e3df.js
var Os = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var Ps = __toESM(require_react_dom(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var Ms = function(t) {
  return function(e, n) {
    var i = (0, import_react.useRef)(false);
    t(function() {
      return function() {
        i.current = false;
      };
    }, []), t(function() {
      if (!i.current)
        i.current = true;
      else
        return e();
    }, n);
  };
};
var Ns = Ms(import_react.useEffect);
function _i(t) {
  var e = (0, import_react.useRef)(t);
  return e.current = t, e;
}
var Ls = function(t) {
  S && (N(t) || console.error("useUnmount expected parameter is a function, got ".concat(typeof t)));
  var e = _i(t);
  (0, import_react.useEffect)(function() {
    return function() {
      e.current();
    };
  }, []);
};
var Vs = Ls;
var js = S2;
var Fs = function() {
  return js.Date.now();
};
var Us = Fs;
var Bs = E2;
var _t = Us;
var vn = A;
var qs = "Expected a function";
var Ws = Math.max;
var zs = Math.min;
function Ks(t, e, n) {
  var i, s, r, o, a, c, l = 0, u = false, d2 = false, f = true;
  if (typeof t != "function")
    throw new TypeError(qs);
  e = vn(e) || 0, Bs(n) && (u = !!n.leading, d2 = "maxWait" in n, r = d2 ? Ws(vn(n.maxWait) || 0, e) : r, f = "trailing" in n ? !!n.trailing : f);
  function m(x2) {
    var k = i, P2 = s;
    return i = s = void 0, l = x2, o = t.apply(P2, k), o;
  }
  function y(x2) {
    return l = x2, a = setTimeout(h, e), u ? m(x2) : o;
  }
  function w(x2) {
    var k = x2 - c, P2 = x2 - l, I = e - k;
    return d2 ? zs(I, r - P2) : I;
  }
  function v2(x2) {
    var k = x2 - c, P2 = x2 - l;
    return c === void 0 || k >= e || k < 0 || d2 && P2 >= r;
  }
  function h() {
    var x2 = _t();
    if (v2(x2))
      return _2(x2);
    a = setTimeout(h, w(x2));
  }
  function _2(x2) {
    return a = void 0, f && i ? m(x2) : (i = s = void 0, o);
  }
  function b() {
    a !== void 0 && clearTimeout(a), l = 0, i = c = s = a = void 0;
  }
  function g() {
    return a === void 0 ? o : _2(_t());
  }
  function S3() {
    var x2 = _t(), k = v2(x2);
    if (i = arguments, s = this, c = x2, k) {
      if (a === void 0)
        return y(c);
      if (d2)
        return clearTimeout(a), a = setTimeout(h, e), m(c);
    }
    return a === void 0 && (a = setTimeout(h, e)), o;
  }
  return S3.cancel = b, S3.flush = g, S3;
}
var Hs = Ks;
var Qs = sn(Hs);
var Gs = !!(typeof window < "u" && window.document && window.document.createElement);
var Ys = Gs;
function Xs() {
  var t = (typeof global > "u" ? "undefined" : typeof global) == "object" && global && global.Object === Object && global, e = typeof self == "object" && self && self.Object === Object && self;
  return t || e;
}
Xs() || (global.Date = Date);
function Zs(t, e) {
  var n;
  S && (N(t) || console.error("useDebounceFn expected parameter is a function, got ".concat(typeof t)));
  var i = _i(t), s = (n = e == null ? void 0 : e.wait) !== null && n !== void 0 ? n : 1e3, r = (0, import_react.useMemo)(function() {
    return Qs(function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      return i.current.apply(i, V([], x(o), false));
    }, s, e);
  }, []);
  return Vs(function() {
    r.cancel();
  }), {
    run: r,
    cancel: r.cancel,
    flush: r.flush
  };
}
function Js(t, e, n) {
  var i = x((0, import_react.useState)({}), 2), s = i[0], r = i[1], o = Zs(function() {
    r({});
  }, n).run;
  (0, import_react.useEffect)(function() {
    return o();
  }, e), Ns(t, [s]);
}
var er = Ys ? import_react.useLayoutEffect : import_react.useEffect;
var Ce = er;
var tr = function() {
  var t = (0, import_react.useRef)(false);
  return (0, import_react.useEffect)(function() {
    return t.current = false, function() {
      t.current = true;
    };
  }, []), t;
};
var wi = tr;
var yn = 10;
function nr(t, e) {
  return t > e && t > yn ? "horizontal" : e > t && e > yn ? "vertical" : "";
}
function ir() {
  const t = (0, import_react.useRef)(0), e = (0, import_react.useRef)(0), n = (0, import_react.useRef)(0), i = (0, import_react.useRef)(0), s = (0, import_react.useRef)(0), r = (0, import_react.useRef)(0), o = (0, import_react.useRef)(""), a = () => o.current === "vertical", c = () => o.current === "horizontal", l = () => {
    n.current = 0, i.current = 0, s.current = 0, r.current = 0, o.current = "";
  };
  return {
    move: (f) => {
      const m = f.touches[0];
      n.current = m.clientX < 0 ? 0 : m.clientX - t.current, i.current = m.clientY - e.current, s.current = Math.abs(n.current), r.current = Math.abs(i.current), o.current || (o.current = nr(s.current, r.current));
    },
    start: (f) => {
      l(), t.current = f.touches[0].clientX, e.current = f.touches[0].clientY;
    },
    reset: l,
    startX: t,
    startY: e,
    deltaX: n,
    deltaY: i,
    offsetX: s,
    offsetY: r,
    direction: o,
    isVertical: a,
    isHorizontal: c
  };
}
var Gt = !!(typeof window < "u" && typeof document < "u" && window.document && window.document.createElement);
var sr = Gt ? window : void 0;
var rr = ["scroll", "auto", "overlay"];
function or(t) {
  return t.nodeType === 1;
}
function ar(t, e = sr) {
  let n = t;
  for (; n && n !== e && or(n); ) {
    if (n === document.body)
      return e;
    const {
      overflowY: i
    } = window.getComputedStyle(n);
    if (rr.includes(i) && n.scrollHeight > n.clientHeight)
      return n;
    n = n.parentNode;
  }
  return e;
}
var Ze = false;
if (Gt)
  try {
    const t = {};
    Object.defineProperty(t, "passive", {
      get() {
        Ze = true;
      }
    }), window.addEventListener("test-passive", null, t);
  } catch {
  }
var we = 0;
var bn = "adm-overflow-hidden";
function cr(t) {
  let e = t == null ? void 0 : t.parentElement;
  for (; e; ) {
    if (e.clientHeight < e.scrollHeight)
      return e;
    e = e.parentElement;
  }
  return null;
}
function xi(t, e) {
  const n = ir(), i = (o) => {
    n.move(o);
    const a = n.deltaY.current > 0 ? "10" : "01", c = ar(o.target, t.current);
    if (!c)
      return;
    if (e === "strict") {
      const y = cr(o.target);
      if (y === document.body || y === document.documentElement) {
        o.preventDefault();
        return;
      }
    }
    const {
      scrollHeight: l,
      offsetHeight: u,
      scrollTop: d2
    } = c, {
      height: f
    } = c.getBoundingClientRect();
    let m = "11";
    d2 === 0 ? m = u >= l ? "00" : "01" : l <= Math.round(f + d2) && (m = "10"), m !== "11" && n.isVertical() && !(parseInt(m, 2) & parseInt(a, 2)) && o.cancelable && Ze && o.preventDefault();
  }, s = () => {
    document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", i, Ze ? {
      passive: false
    } : false), we || document.body.classList.add(bn), we++;
  }, r = () => {
    we && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", i), we--, we || document.body.classList.remove(bn));
  };
  (0, import_react.useEffect)(() => {
    if (e)
      return s(), () => {
        r();
      };
  }, [e]);
}
var Yt = qe();
var E3 = (t) => Be(t, Yt);
var Xt = qe();
E3.write = (t) => Be(t, Xt);
var ct = qe();
E3.onStart = (t) => Be(t, ct);
var Zt = qe();
E3.onFrame = (t) => Be(t, Zt);
var Jt = qe();
E3.onFinish = (t) => Be(t, Jt);
var pe = [];
E3.setTimeout = (t, e) => {
  let n = E3.now() + e, i = () => {
    let r = pe.findIndex((o) => o.cancel == i);
    ~r && pe.splice(r, 1), re -= ~r ? 1 : 0;
  }, s = {
    time: n,
    handler: t,
    cancel: i
  };
  return pe.splice(Si(n), 0, s), re += 1, Ei(), s;
};
var Si = (t) => ~(~pe.findIndex((e) => e.time > t) || ~pe.length);
E3.cancel = (t) => {
  ct.delete(t), Zt.delete(t), Jt.delete(t), Yt.delete(t), Xt.delete(t);
};
E3.sync = (t) => {
  Rt = true, E3.batchedUpdates(t), Rt = false;
};
E3.throttle = (t) => {
  let e;
  function n() {
    try {
      t(...e);
    } finally {
      e = null;
    }
  }
  function i(...s) {
    e = s, E3.onStart(n);
  }
  return i.handler = t, i.cancel = () => {
    ct.delete(n), e = null;
  }, i;
};
var en = typeof window < "u" ? window.requestAnimationFrame : () => {
};
E3.use = (t) => en = t;
E3.now = typeof performance < "u" ? () => performance.now() : Date.now;
E3.batchedUpdates = (t) => t();
E3.catch = console.error;
E3.frameLoop = "always";
E3.advance = () => {
  E3.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : Ci();
};
var se = -1;
var re = 0;
var Rt = false;
function Be(t, e) {
  Rt ? (e.delete(t), t(0)) : (e.add(t), Ei());
}
function Ei() {
  se < 0 && (se = 0, E3.frameLoop !== "demand" && en(Oi));
}
function ur() {
  se = -1;
}
function Oi() {
  ~se && (en(Oi), E3.batchedUpdates(Ci));
}
function Ci() {
  let t = se;
  se = E3.now();
  let e = Si(se);
  if (e && (ki(pe.splice(0, e), (n) => n.handler()), re -= e), !re) {
    ur();
    return;
  }
  ct.flush(), Yt.flush(t ? Math.min(64, se - t) : 16.667), Zt.flush(), Xt.flush(), Jt.flush();
}
function qe() {
  let t = /* @__PURE__ */ new Set(), e = t;
  return {
    add(n) {
      re += e == t && !t.has(n) ? 1 : 0, t.add(n);
    },
    delete(n) {
      return re -= e == t && t.has(n) ? 1 : 0, t.delete(n);
    },
    flush(n) {
      e.size && (t = /* @__PURE__ */ new Set(), re -= e.size, ki(e, (i) => i(n) && t.add(i)), re += t.size, e = t);
    }
  };
}
function ki(t, e) {
  t.forEach((n) => {
    try {
      e(n);
    } catch (i) {
      E3.catch(i);
    }
  });
}
function $t() {
}
var lr = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: true,
  configurable: true
});
var p = {
  arr: Array.isArray,
  obj: (t) => !!t && t.constructor.name === "Object",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  und: (t) => t === void 0
};
function Z(t, e) {
  if (p.arr(t)) {
    if (!p.arr(e) || t.length !== e.length)
      return false;
    for (let n = 0; n < t.length; n++)
      if (t[n] !== e[n])
        return false;
    return true;
  }
  return t === e;
}
var O = (t, e) => t.forEach(e);
function G(t, e, n) {
  if (p.arr(t)) {
    for (let i = 0; i < t.length; i++)
      e.call(n, t[i], `${i}`);
    return;
  }
  for (const i in t)
    t.hasOwnProperty(i) && e.call(n, t[i], i);
}
var F = (t) => p.und(t) ? [] : p.arr(t) ? t : [t];
function ke(t, e) {
  if (t.size) {
    const n = Array.from(t);
    t.clear(), O(n, e);
  }
}
var Oe = (t, ...e) => ke(t, (n) => n(...e));
var tn = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var nn;
var Pi;
var oe = null;
var Ti = false;
var sn2 = $t;
var fr = (t) => {
  t.to && (Pi = t.to), t.now && (E3.now = t.now), t.colors !== void 0 && (oe = t.colors), t.skipAnimation != null && (Ti = t.skipAnimation), t.createStringInterpolator && (nn = t.createStringInterpolator), t.requestAnimationFrame && E3.use(t.requestAnimationFrame), t.batchedUpdates && (E3.batchedUpdates = t.batchedUpdates), t.willAdvance && (sn2 = t.willAdvance), t.frameLoop && (E3.frameLoop = t.frameLoop);
};
var Y = Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return nn;
  },
  get to() {
    return Pi;
  },
  get colors() {
    return oe;
  },
  get skipAnimation() {
    return Ti;
  },
  get willAdvance() {
    return sn2;
  },
  assign: fr
});
var Pe = /* @__PURE__ */ new Set();
var W = [];
var wt = [];
var Je = 0;
var ut = {
  get idle() {
    return !Pe.size && !W.length;
  },
  start(t) {
    Je > t.priority ? (Pe.add(t), E3.onStart(dr)) : (Ii(t), E3(Dt));
  },
  advance: Dt,
  sort(t) {
    if (Je)
      E3.onFrame(() => ut.sort(t));
    else {
      const e = W.indexOf(t);
      ~e && (W.splice(e, 1), Ai(t));
    }
  },
  clear() {
    W = [], Pe.clear();
  }
};
function dr() {
  Pe.forEach(Ii), Pe.clear(), E3(Dt);
}
function Ii(t) {
  W.includes(t) || Ai(t);
}
function Ai(t) {
  W.splice(hr(W, (e) => e.priority > t.priority), 0, t);
}
function Dt(t) {
  const e = wt;
  for (let n = 0; n < W.length; n++) {
    const i = W[n];
    Je = i.priority, i.idle || (sn2(i), i.advance(t), i.idle || e.push(i));
  }
  return Je = 0, wt = W, wt.length = 0, W = e, W.length > 0;
}
function hr(t, e) {
  const n = t.findIndex(e);
  return n < 0 ? t.length : n;
}
var pr = (t, e, n) => Math.min(Math.max(n, t), e);
var mr = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var K = "[-+]?\\d*\\.?\\d+";
var et = K + "%";
function lt(...t) {
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var gr = new RegExp("rgb" + lt(K, K, K));
var vr = new RegExp("rgba" + lt(K, K, K, K));
var yr = new RegExp("hsl" + lt(K, et, et));
var br = new RegExp("hsla" + lt(K, et, et, K));
var _r = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var wr = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var xr = /^#([0-9a-fA-F]{6})$/;
var Sr = /^#([0-9a-fA-F]{8})$/;
function Er(t) {
  let e;
  return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = xr.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : oe && oe[t] !== void 0 ? oe[t] : (e = gr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | 255) >>> 0 : (e = vr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | xn(e[4])) >>> 0 : (e = _r.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = Sr.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = wr.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = yr.exec(t)) ? (_n(wn(e[1]), ze(e[2]), ze(e[3])) | 255) >>> 0 : (e = br.exec(t)) ? (_n(wn(e[1]), ze(e[2]), ze(e[3])) | xn(e[4])) >>> 0 : null;
}
function xt(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function _n(t, e, n) {
  const i = n < 0.5 ? n * (1 + e) : n + e - n * e, s = 2 * n - i, r = xt(s, i, t + 1 / 3), o = xt(s, i, t), a = xt(s, i, t - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(o * 255) << 16 | Math.round(a * 255) << 8;
}
function fe(t) {
  const e = parseInt(t, 10);
  return e < 0 ? 0 : e > 255 ? 255 : e;
}
function wn(t) {
  return (parseFloat(t) % 360 + 360) % 360 / 360;
}
function xn(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255);
}
function ze(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 100 ? 1 : e / 100;
}
function Sn(t) {
  let e = Er(t);
  if (e === null)
    return t;
  e = e || 0;
  let n = (e & 4278190080) >>> 24, i = (e & 16711680) >>> 16, s = (e & 65280) >>> 8, r = (e & 255) / 255;
  return `rgba(${n}, ${i}, ${s}, ${r})`;
}
var Re = (t, e, n) => {
  if (p.fun(t))
    return t;
  if (p.arr(t))
    return Re({
      range: t,
      output: e,
      extrapolate: n
    });
  if (p.str(t.output[0]))
    return nn(t);
  const i = t, s = i.output, r = i.range || [0, 1], o = i.extrapolateLeft || i.extrapolate || "extend", a = i.extrapolateRight || i.extrapolate || "extend", c = i.easing || ((l) => l);
  return (l) => {
    const u = Cr(l, r);
    return Or(l, r[u], r[u + 1], s[u], s[u + 1], c, o, a, i.map);
  };
};
function Or(t, e, n, i, s, r, o, a, c) {
  let l = c ? c(t) : t;
  if (l < e) {
    if (o === "identity")
      return l;
    o === "clamp" && (l = e);
  }
  if (l > n) {
    if (a === "identity")
      return l;
    a === "clamp" && (l = n);
  }
  return i === s ? i : e === n ? t <= e ? i : s : (e === -1 / 0 ? l = -l : n === 1 / 0 ? l = l - e : l = (l - e) / (n - e), l = r(l), i === -1 / 0 ? l = -l : s === 1 / 0 ? l = l + i : l = l * (s - i) + i, l);
}
function Cr(t, e) {
  for (var n = 1; n < e.length - 1 && !(e[n] >= t); ++n)
    ;
  return n - 1;
}
var kr = (t, e = "end") => (n) => {
  n = e === "end" ? Math.min(n, 0.999) : Math.max(n, 1e-3);
  const i = n * t, s = e === "end" ? Math.floor(i) : Math.ceil(i);
  return pr(0, 1, s / t);
};
var tt = 1.70158;
var Ke = tt * 1.525;
var En = tt + 1;
var On = 2 * Math.PI / 3;
var Cn = 2 * Math.PI / 4.5;
var He = (t) => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
var Pr = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  easeInBack: (t) => En * t * t * t - tt * t * t,
  easeOutBack: (t) => 1 + En * Math.pow(t - 1, 3) + tt * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((Ke + 1) * 2 * t - Ke) / 2 : (Math.pow(2 * t - 2, 2) * ((Ke + 1) * (t * 2 - 2) + Ke) + 2) / 2,
  easeInElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * On),
  easeOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * On) + 1,
  easeInOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * Cn)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * Cn) / 2 + 1,
  easeInBounce: (t) => 1 - He(1 - t),
  easeOutBounce: He,
  easeInOutBounce: (t) => t < 0.5 ? (1 - He(1 - 2 * t)) / 2 : (1 + He(2 * t - 1)) / 2,
  steps: kr
};
function Mt() {
  return Mt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Mt.apply(this, arguments);
}
var ge = Symbol.for("FluidValue.get");
var ue = Symbol.for("FluidValue.observers");
var B = (t) => !!(t && t[ge]);
var V2 = (t) => t && t[ge] ? t[ge]() : t;
var kn = (t) => t[ue] || null;
function Tr(t, e) {
  t.eventObserved ? t.eventObserved(e) : t(e);
}
function $e(t, e) {
  let n = t[ue];
  n && n.forEach((i) => {
    Tr(i, e);
  });
}
var Ri = class {
  constructor(e) {
    if (this[ge] = void 0, this[ue] = void 0, !e && !(e = this.get))
      throw Error("Unknown getter");
    Ir(this, e);
  }
};
var Ir = (t, e) => $i(t, ge, e);
function ye(t, e) {
  if (t[ge]) {
    let n = t[ue];
    n || $i(t, ue, n = /* @__PURE__ */ new Set()), n.has(e) || (n.add(e), t.observerAdded && t.observerAdded(n.size, e));
  }
  return e;
}
function De(t, e) {
  let n = t[ue];
  if (n && n.has(e)) {
    const i = n.size - 1;
    i ? n.delete(e) : t[ue] = null, t.observerRemoved && t.observerRemoved(i, e);
  }
}
var $i = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: true,
  configurable: true
});
var Ge = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var Ar = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var Pn = new RegExp(`(${Ge.source})(%|[a-z]+)`, "i");
var Rr = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var ft = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var Di = (t) => {
  const [e, n] = $r(t);
  if (!e || tn())
    return t;
  const i = window.getComputedStyle(document.documentElement).getPropertyValue(e);
  if (i)
    return i.trim();
  if (n && n.startsWith("--")) {
    const s = window.getComputedStyle(document.documentElement).getPropertyValue(n);
    return s || t;
  } else {
    if (n && ft.test(n))
      return Di(n);
    if (n)
      return n;
  }
  return t;
};
var $r = (t) => {
  const e = ft.exec(t);
  if (!e)
    return [,];
  const [, n, i] = e;
  return [n, i];
};
var St;
var Dr = (t, e, n, i, s) => `rgba(${Math.round(e)}, ${Math.round(n)}, ${Math.round(i)}, ${s})`;
var Mi = (t) => {
  St || (St = oe ? new RegExp(`(${Object.keys(oe).join("|")})(?!\\w)`, "g") : /^\b$/);
  const e = t.output.map((r) => V2(r).replace(ft, Di).replace(Ar, Sn).replace(St, Sn)), n = e.map((r) => r.match(Ge).map(Number)), s = n[0].map((r, o) => n.map((a) => {
    if (!(o in a))
      throw Error('The arity of each "output" value must be equal');
    return a[o];
  })).map((r) => Re(Mt({}, t, {
    output: r
  })));
  return (r) => {
    var o;
    const a = !Pn.test(e[0]) && ((o = e.find((l) => Pn.test(l))) == null ? void 0 : o.replace(Ge, ""));
    let c = 0;
    return e[0].replace(Ge, () => `${s[c++](r)}${a || ""}`).replace(Rr, Dr);
  };
};
var rn = "react-spring: ";
var Ni = (t) => {
  const e = t;
  let n = false;
  if (typeof e != "function")
    throw new TypeError(`${rn}once requires a function parameter`);
  return (...i) => {
    n || (e(...i), n = true);
  };
};
var Mr = Ni(console.warn);
function Nr() {
  Mr(`${rn}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
var Lr = Ni(console.warn);
function Vr() {
  Lr(`${rn}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function dt(t) {
  return p.str(t) && (t[0] == "#" || /\d/.test(t) || !tn() && ft.test(t) || t in (oe || {}));
}
var on = tn() ? import_react.useEffect : import_react.useLayoutEffect;
var jr = () => {
  const t = (0, import_react.useRef)(false);
  return on(() => (t.current = true, () => {
    t.current = false;
  }), []), t;
};
function Li() {
  const t = (0, import_react.useState)()[1], e = jr();
  return () => {
    e.current && t(Math.random());
  };
}
function Fr(t, e) {
  const [n] = (0, import_react.useState)(() => ({
    inputs: e,
    result: t()
  })), i = (0, import_react.useRef)(), s = i.current;
  let r = s;
  return r ? e && r.inputs && Ur(e, r.inputs) || (r = {
    inputs: e,
    result: t()
  }) : r = n, (0, import_react.useEffect)(() => {
    i.current = r, s == n && (n.inputs = n.result = void 0);
  }, [r]), r.result;
}
function Ur(t, e) {
  if (t.length !== e.length)
    return false;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return false;
  return true;
}
var Vi = (t) => (0, import_react.useEffect)(t, Br);
var Br = [];
function Tn(t) {
  const e = (0, import_react.useRef)();
  return (0, import_react.useEffect)(() => {
    e.current = t;
  }), e.current;
}
var Me = Symbol.for("Animated:node");
var qr = (t) => !!t && t[Me] === t;
var Q = (t) => t && t[Me];
var an = (t, e) => lr(t, Me, e);
var ht = (t) => t && t[Me] && t[Me].getPayload();
var ji = class {
  constructor() {
    this.payload = void 0, an(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
};
var be = class _be extends ji {
  constructor(e) {
    super(), this.done = true, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e, p.num(this._value) && (this.lastPosition = this._value);
  }
  static create(e) {
    return new _be(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, n) {
    return p.num(e) && (this.lastPosition = e, n && (e = Math.round(e / n) * n, this.done && (this.lastPosition = e))), this._value === e ? false : (this._value = e, true);
  }
  reset() {
    const {
      done: e
    } = this;
    this.done = false, p.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
};
var ve = class _ve extends be {
  constructor(e) {
    super(0), this._string = null, this._toString = void 0, this._toString = Re({
      output: [e, e]
    });
  }
  static create(e) {
    return new _ve(e);
  }
  getValue() {
    let e = this._string;
    return e ?? (this._string = this._toString(this._value));
  }
  setValue(e) {
    if (p.str(e)) {
      if (e == this._string)
        return false;
      this._string = e, this._value = 1;
    } else if (super.setValue(e))
      this._string = null;
    else
      return false;
    return true;
  }
  reset(e) {
    e && (this._toString = Re({
      output: [this.getValue(), e]
    })), this._value = 0, super.reset();
  }
};
var nt = {
  dependencies: null
};
var pt = class extends ji {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    const n = {};
    return G(this.source, (i, s) => {
      qr(i) ? n[s] = i.getValue(e) : B(i) ? n[s] = V2(i) : e || (n[s] = i);
    }), n;
  }
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && O(this.payload, (e) => e.reset());
  }
  _makePayload(e) {
    if (e) {
      const n = /* @__PURE__ */ new Set();
      return G(e, this._addToPayload, n), Array.from(n);
    }
  }
  _addToPayload(e) {
    nt.dependencies && B(e) && nt.dependencies.add(e);
    const n = ht(e);
    n && O(n, (i) => this.add(i));
  }
};
var cn = class _cn extends pt {
  constructor(e) {
    super(e);
  }
  static create(e) {
    return new _cn(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    const n = this.getPayload();
    return e.length == n.length ? n.map((i, s) => i.setValue(e[s])).some(Boolean) : (super.setValue(e.map(Wr)), true);
  }
};
function Wr(t) {
  return (dt(t) ? ve : be).create(t);
}
function Nt(t) {
  const e = Q(t);
  return e ? e.constructor : p.arr(t) ? cn : dt(t) ? ve : be;
}
function Lt() {
  return Lt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Lt.apply(this, arguments);
}
var In = (t, e) => {
  const n = !p.fun(t) || t.prototype && t.prototype.isReactComponent;
  return (0, import_react.forwardRef)((i, s) => {
    const r = (0, import_react.useRef)(null), o = n && (0, import_react.useCallback)((y) => {
      r.current = Hr(s, y);
    }, [s]), [a, c] = Kr(i, e), l = Li(), u = () => {
      const y = r.current;
      if (n && !y)
        return;
      (y ? e.applyAnimatedValues(y, a.getValue(true)) : false) === false && l();
    }, d2 = new zr(u, c), f = (0, import_react.useRef)();
    on(() => (f.current = d2, O(c, (y) => ye(y, d2)), () => {
      f.current && (O(f.current.deps, (y) => De(y, f.current)), E3.cancel(f.current.update));
    })), (0, import_react.useEffect)(u, []), Vi(() => () => {
      const y = f.current;
      O(y.deps, (w) => De(w, y));
    });
    const m = e.getComponentProps(a.getValue());
    return d(t, {
      ...m,
      ref: o
    });
  });
};
var zr = class {
  constructor(e, n) {
    this.update = e, this.deps = n;
  }
  eventObserved(e) {
    e.type == "change" && E3.write(this.update);
  }
};
function Kr(t, e) {
  const n = /* @__PURE__ */ new Set();
  return nt.dependencies = n, t.style && (t = Lt({}, t, {
    style: e.createAnimatedStyle(t.style)
  })), t = new pt(t), nt.dependencies = null, [t, n];
}
function Hr(t, e) {
  return t && (p.fun(t) ? t(e) : t.current = e), e;
}
var An = Symbol.for("AnimatedComponent");
var Qr = (t, {
  applyAnimatedValues: e = () => false,
  createAnimatedStyle: n = (s) => new pt(s),
  getComponentProps: i = (s) => s
} = {}) => {
  const s = {
    applyAnimatedValues: e,
    createAnimatedStyle: n,
    getComponentProps: i
  }, r = (o) => {
    const a = Rn(o) || "Anonymous";
    return p.str(o) ? o = r[o] || (r[o] = In(o, s)) : o = o[An] || (o[An] = In(o, s)), o.displayName = `Animated(${a})`, o;
  };
  return G(t, (o, a) => {
    p.arr(t) && (a = Rn(o)), r[a] = r(o);
  }), {
    animated: r
  };
};
var Rn = (t) => p.str(t) ? t : t && p.str(t.displayName) ? t.displayName : p.fun(t) && t.name || null;
function $2() {
  return $2 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, $2.apply(this, arguments);
}
function ae(t, ...e) {
  return p.fun(t) ? t(...e) : t;
}
var Te = (t, e) => t === true || !!(e && t && (p.fun(t) ? t(e) : F(t).includes(e)));
var Fi = (t, e) => p.obj(t) ? e && t[e] : t;
var Ui = (t, e) => t.default === true ? t[e] : t.default ? t.default[e] : void 0;
var Gr = (t) => t;
var un = (t, e = Gr) => {
  let n = Yr;
  t.default && t.default !== true && (t = t.default, n = Object.keys(t));
  const i = {};
  for (const s of n) {
    const r = e(t[s], s);
    p.und(r) || (i[s] = r);
  }
  return i;
};
var Yr = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
var Xr = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function Zr(t) {
  const e = {};
  let n = 0;
  if (G(t, (i, s) => {
    Xr[s] || (e[s] = i, n++);
  }), n)
    return e;
}
function Bi(t) {
  const e = Zr(t);
  if (e) {
    const n = {
      to: e
    };
    return G(t, (i, s) => s in e || (n[s] = i)), n;
  }
  return $2({}, t);
}
function Ne(t) {
  return t = V2(t), p.arr(t) ? t.map(Ne) : dt(t) ? Y.createStringInterpolator({
    range: [0, 1],
    output: [t, t]
  })(1) : t;
}
function Jr(t) {
  for (const e in t)
    return true;
  return false;
}
function Vt(t) {
  return p.fun(t) || p.arr(t) && p.obj(t[0]);
}
function eo(t, e) {
  var n;
  (n = t.ref) == null || n.delete(t), e == null || e.delete(t);
}
function to(t, e) {
  if (e && t.ref !== e) {
    var n;
    (n = t.ref) == null || n.delete(t), e.add(t), t.ref = e;
  }
}
var no = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};
var jt = $2({}, no.default, {
  mass: 1,
  damping: 1,
  easing: Pr.linear,
  clamp: false
});
var io = class {
  constructor() {
    this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, jt);
  }
};
function so(t, e, n) {
  n && (n = $2({}, n), $n(n, e), e = $2({}, n, e)), $n(t, e), Object.assign(t, e);
  for (const o in jt)
    t[o] == null && (t[o] = jt[o]);
  let {
    mass: i,
    frequency: s,
    damping: r
  } = t;
  return p.und(s) || (s < 0.01 && (s = 0.01), r < 0 && (r = 0), t.tension = Math.pow(2 * Math.PI / s, 2) * i, t.friction = 4 * Math.PI * r * i / s), t;
}
function $n(t, e) {
  if (!p.und(e.decay))
    t.duration = void 0;
  else {
    const n = !p.und(e.tension) || !p.und(e.friction);
    (n || !p.und(e.frequency) || !p.und(e.damping) || !p.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0);
  }
}
var Dn = [];
var ro = class {
  constructor() {
    this.changed = false, this.values = Dn, this.toValues = null, this.fromValues = Dn, this.to = void 0, this.from = void 0, this.config = new io(), this.immediate = false;
  }
};
function qi(t, {
  key: e,
  props: n,
  defaultProps: i,
  state: s,
  actions: r
}) {
  return new Promise((o, a) => {
    var c;
    let l, u, d2 = Te((c = n.cancel) != null ? c : i == null ? void 0 : i.cancel, e);
    if (d2)
      y();
    else {
      p.und(n.pause) || (s.paused = Te(n.pause, e));
      let w = i == null ? void 0 : i.pause;
      w !== true && (w = s.paused || Te(w, e)), l = ae(n.delay || 0, e), w ? (s.resumeQueue.add(m), r.pause()) : (r.resume(), m());
    }
    function f() {
      s.resumeQueue.add(m), s.timeouts.delete(u), u.cancel(), l = u.time - E3.now();
    }
    function m() {
      l > 0 && !Y.skipAnimation ? (s.delayed = true, u = E3.setTimeout(y, l), s.pauseQueue.add(f), s.timeouts.add(u)) : y();
    }
    function y() {
      s.delayed && (s.delayed = false), s.pauseQueue.delete(f), s.timeouts.delete(u), t <= (s.cancelId || 0) && (d2 = true);
      try {
        r.start($2({}, n, {
          callId: t,
          cancel: d2
        }), o);
      } catch (w) {
        a(w);
      }
    }
  });
}
var ln = (t, e) => e.length == 1 ? e[0] : e.some((n) => n.cancelled) ? me(t.get()) : e.every((n) => n.noop) ? Wi(t.get()) : z2(t.get(), e.every((n) => n.finished));
var Wi = (t) => ({
  value: t,
  noop: true,
  finished: true,
  cancelled: false
});
var z2 = (t, e, n = false) => ({
  value: t,
  finished: e,
  cancelled: n
});
var me = (t) => ({
  value: t,
  cancelled: true,
  finished: false
});
function zi(t, e, n, i) {
  const {
    callId: s,
    parentId: r,
    onRest: o
  } = e, {
    asyncTo: a,
    promise: c
  } = n;
  return !r && t === a && !e.reset ? c : n.promise = (async () => {
    n.asyncId = s, n.asyncTo = t;
    const l = un(e, (v2, h) => h === "onRest" ? void 0 : v2);
    let u, d2;
    const f = new Promise((v2, h) => (u = v2, d2 = h)), m = (v2) => {
      const h = s <= (n.cancelId || 0) && me(i) || s !== n.asyncId && z2(i, false);
      if (h)
        throw v2.result = h, d2(v2), v2;
    }, y = (v2, h) => {
      const _2 = new Mn(), b = new Nn();
      return (async () => {
        if (Y.skipAnimation)
          throw Le(n), b.result = z2(i, false), d2(b), b;
        m(_2);
        const g = p.obj(v2) ? $2({}, v2) : $2({}, h, {
          to: v2
        });
        g.parentId = s, G(l, (x2, k) => {
          p.und(g[k]) && (g[k] = x2);
        });
        const S3 = await i.start(g);
        return m(_2), n.paused && await new Promise((x2) => {
          n.resumeQueue.add(x2);
        }), S3;
      })();
    };
    let w;
    if (Y.skipAnimation)
      return Le(n), z2(i, false);
    try {
      let v2;
      p.arr(t) ? v2 = (async (h) => {
        for (const _2 of h)
          await y(_2);
      })(t) : v2 = Promise.resolve(t(y, i.stop.bind(i))), await Promise.all([v2.then(u), f]), w = z2(i.get(), true, false);
    } catch (v2) {
      if (v2 instanceof Mn)
        w = v2.result;
      else if (v2 instanceof Nn)
        w = v2.result;
      else
        throw v2;
    } finally {
      s == n.asyncId && (n.asyncId = r, n.asyncTo = r ? a : void 0, n.promise = r ? c : void 0);
    }
    return p.fun(o) && E3.batchedUpdates(() => {
      o(w, i, i.item);
    }), w;
  })();
}
function Le(t, e) {
  ke(t.timeouts, (n) => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e);
}
var Mn = class extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0;
  }
};
var Nn = class extends Error {
  constructor() {
    super("SkipAnimationSignal"), this.result = void 0;
  }
};
var Ft = (t) => t instanceof fn;
var oo = 1;
var fn = class extends Ri {
  constructor(...e) {
    super(...e), this.id = oo++, this.key = void 0, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  get() {
    const e = Q(this);
    return e && e.getValue();
  }
  to(...e) {
    return Y.to(this, e);
  }
  interpolate(...e) {
    return Nr(), Y.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(e, n = false) {
    $e(this, {
      type: "change",
      parent: this,
      value: e,
      idle: n
    });
  }
  _onPriorityChange(e) {
    this.idle || ut.sort(this), $e(this, {
      type: "priority",
      parent: this,
      priority: e
    });
  }
};
var le = Symbol.for("SpringPhase");
var Ki = 1;
var Ut = 2;
var Bt = 4;
var Et = (t) => (t[le] & Ki) > 0;
var te = (t) => (t[le] & Ut) > 0;
var xe = (t) => (t[le] & Bt) > 0;
var Ln = (t, e) => e ? t[le] |= Ut | Ki : t[le] &= ~Ut;
var Vn = (t, e) => e ? t[le] |= Bt : t[le] &= ~Bt;
var ao = class extends fn {
  constructor(e, n) {
    if (super(), this.key = void 0, this.animation = new ro(), this.queue = void 0, this.defaultProps = {}, this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !p.und(e) || !p.und(n)) {
      const i = p.obj(e) ? $2({}, e) : $2({}, n, {
        from: e
      });
      p.und(i.default) && (i.default = true), this.start(i);
    }
  }
  get idle() {
    return !(te(this) || this._state.asyncTo) || xe(this);
  }
  get goal() {
    return V2(this.animation.to);
  }
  get velocity() {
    const e = Q(this);
    return e instanceof be ? e.lastVelocity || 0 : e.getPayload().map((n) => n.lastVelocity || 0);
  }
  get hasAnimated() {
    return Et(this);
  }
  get isAnimating() {
    return te(this);
  }
  get isPaused() {
    return xe(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(e) {
    let n = true, i = false;
    const s = this.animation;
    let {
      config: r,
      toValues: o
    } = s;
    const a = ht(s.to);
    !a && B(s.to) && (o = F(V2(s.to))), s.values.forEach((u, d2) => {
      if (u.done)
        return;
      const f = u.constructor == ve ? 1 : a ? a[d2].lastPosition : o[d2];
      let m = s.immediate, y = f;
      if (!m) {
        if (y = u.lastPosition, r.tension <= 0) {
          u.done = true;
          return;
        }
        let w = u.elapsedTime += e;
        const v2 = s.fromValues[d2], h = u.v0 != null ? u.v0 : u.v0 = p.arr(r.velocity) ? r.velocity[d2] : r.velocity;
        let _2;
        const b = r.precision || (v2 == f ? 5e-3 : Math.min(1, Math.abs(f - v2) * 1e-3));
        if (p.und(r.duration))
          if (r.decay) {
            const g = r.decay === true ? 0.998 : r.decay, S3 = Math.exp(-(1 - g) * w);
            y = v2 + h / (1 - g) * (1 - S3), m = Math.abs(u.lastPosition - y) <= b, _2 = h * S3;
          } else {
            _2 = u.lastVelocity == null ? h : u.lastVelocity;
            const g = r.restVelocity || b / 10, S3 = r.clamp ? 0 : r.bounce, x2 = !p.und(S3), k = v2 == f ? u.v0 > 0 : v2 < f;
            let P2, I = false;
            const R2 = 1, X = Math.ceil(e / R2);
            for (let U = 0; U < X && (P2 = Math.abs(_2) > g, !(!P2 && (m = Math.abs(f - y) <= b, m))); ++U) {
              x2 && (I = y == f || y > f == k, I && (_2 = -_2 * S3, y = f));
              const ee = -r.tension * 1e-6 * (y - f), bt = -r.friction * 1e-3 * _2, bs = (ee + bt) / r.mass;
              _2 = _2 + bs * R2, y = y + _2 * R2;
            }
          }
        else {
          let g = 1;
          r.duration > 0 && (this._memoizedDuration !== r.duration && (this._memoizedDuration = r.duration, u.durationProgress > 0 && (u.elapsedTime = r.duration * u.durationProgress, w = u.elapsedTime += e)), g = (r.progress || 0) + w / this._memoizedDuration, g = g > 1 ? 1 : g < 0 ? 0 : g, u.durationProgress = g), y = v2 + r.easing(g) * (f - v2), _2 = (y - u.lastPosition) / e, m = g == 1;
        }
        u.lastVelocity = _2, Number.isNaN(y) && (console.warn("Got NaN while animating:", this), m = true);
      }
      a && !a[d2].done && (m = false), m ? u.done = true : n = false, u.setValue(y, r.round) && (i = true);
    });
    const c = Q(this), l = c.getValue();
    if (n) {
      const u = V2(s.to);
      (l !== u || i) && !r.decay ? (c.setValue(u), this._onChange(u)) : i && r.decay && this._onChange(l), this._stop();
    } else
      i && this._onChange(l);
  }
  set(e) {
    return E3.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  pause() {
    this._update({
      pause: true
    });
  }
  resume() {
    this._update({
      pause: false
    });
  }
  finish() {
    if (te(this)) {
      const {
        to: e,
        config: n
      } = this.animation;
      E3.batchedUpdates(() => {
        this._onStart(), n.decay || this._set(e, false), this._stop();
      });
    }
    return this;
  }
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, n) {
    let i;
    return p.und(e) ? (i = this.queue || [], this.queue = []) : i = [p.obj(e) ? e : $2({}, n, {
      to: e
    })], Promise.all(i.map((s) => this._update(s))).then((s) => ln(this, s));
  }
  stop(e) {
    const {
      to: n
    } = this.animation;
    return this._focus(this.get()), Le(this._state, e && this._lastCallId), E3.batchedUpdates(() => this._stop(n, e)), this;
  }
  reset() {
    this._update({
      reset: true
    });
  }
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  _prepareNode(e) {
    const n = this.key || "";
    let {
      to: i,
      from: s
    } = e;
    i = p.obj(i) ? i[n] : i, (i == null || Vt(i)) && (i = void 0), s = p.obj(s) ? s[n] : s, s == null && (s = void 0);
    const r = {
      to: i,
      from: s
    };
    return Et(this) || (e.reverse && ([i, s] = [s, i]), s = V2(s), p.und(s) ? Q(this) || this._set(i) : this._set(s)), r;
  }
  _update(e, n) {
    let i = $2({}, e);
    const {
      key: s,
      defaultProps: r
    } = this;
    i.default && Object.assign(r, un(i, (c, l) => /^on/.test(l) ? Fi(c, s) : c)), Fn(this, i, "onProps"), Ee(this, "onProps", i, this);
    const o = this._prepareNode(i);
    if (Object.isFrozen(this))
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    const a = this._state;
    return qi(++this._lastCallId, {
      key: s,
      props: i,
      defaultProps: r,
      state: a,
      actions: {
        pause: () => {
          xe(this) || (Vn(this, true), Oe(a.pauseQueue), Ee(this, "onPause", z2(this, Se(this, this.animation.to)), this));
        },
        resume: () => {
          xe(this) && (Vn(this, false), te(this) && this._resume(), Oe(a.resumeQueue), Ee(this, "onResume", z2(this, Se(this, this.animation.to)), this));
        },
        start: this._merge.bind(this, o)
      }
    }).then((c) => {
      if (i.loop && c.finished && !(n && c.noop)) {
        const l = Hi(i);
        if (l)
          return this._update(l, true);
      }
      return c;
    });
  }
  _merge(e, n, i) {
    if (n.cancel)
      return this.stop(true), i(me(this));
    const s = !p.und(e.to), r = !p.und(e.from);
    if (s || r)
      if (n.callId > this._lastToId)
        this._lastToId = n.callId;
      else
        return i(me(this));
    const {
      key: o,
      defaultProps: a,
      animation: c
    } = this, {
      to: l,
      from: u
    } = c;
    let {
      to: d2 = l,
      from: f = u
    } = e;
    r && !s && (!n.default || p.und(d2)) && (d2 = f), n.reverse && ([d2, f] = [f, d2]);
    const m = !Z(f, u);
    m && (c.from = f), f = V2(f);
    const y = !Z(d2, l);
    y && this._focus(d2);
    const w = Vt(n.to), {
      config: v2
    } = c, {
      decay: h,
      velocity: _2
    } = v2;
    (s || r) && (v2.velocity = 0), n.config && !w && so(v2, ae(n.config, o), n.config !== a.config ? ae(a.config, o) : void 0);
    let b = Q(this);
    if (!b || p.und(d2))
      return i(z2(this, true));
    const g = p.und(n.reset) ? r && !n.default : !p.und(f) && Te(n.reset, o), S3 = g ? f : this.get(), x2 = Ne(d2), k = p.num(x2) || p.arr(x2) || dt(x2), P2 = !w && (!k || Te(a.immediate || n.immediate, o));
    if (y) {
      const U = Nt(d2);
      if (U !== b.constructor)
        if (P2)
          b = this._set(x2);
        else
          throw Error(`Cannot animate between ${b.constructor.name} and ${U.name}, as the "to" prop suggests`);
    }
    const I = b.constructor;
    let R2 = B(d2), X = false;
    if (!R2) {
      const U = g || !Et(this) && m;
      (y || U) && (X = Z(Ne(S3), x2), R2 = !X), (!Z(c.immediate, P2) && !P2 || !Z(v2.decay, h) || !Z(v2.velocity, _2)) && (R2 = true);
    }
    if (X && te(this) && (c.changed && !g ? R2 = true : R2 || this._stop(l)), !w && ((R2 || B(l)) && (c.values = b.getPayload(), c.toValues = B(d2) ? null : I == ve ? [1] : F(x2)), c.immediate != P2 && (c.immediate = P2, !P2 && !g && this._set(l)), R2)) {
      const {
        onRest: U
      } = c;
      O(uo, (bt) => Fn(this, n, bt));
      const ee = z2(this, Se(this, l));
      Oe(this._pendingCalls, ee), this._pendingCalls.add(i), c.changed && E3.batchedUpdates(() => {
        c.changed = !g, U == null || U(ee, this), g ? ae(a.onRest, ee) : c.onStart == null || c.onStart(ee, this);
      });
    }
    g && this._set(S3), w ? i(zi(n.to, n, this._state, this)) : R2 ? this._start() : te(this) && !y ? this._pendingCalls.add(i) : i(Wi(S3));
  }
  _focus(e) {
    const n = this.animation;
    e !== n.to && (kn(this) && this._detach(), n.to = e, kn(this) && this._attach());
  }
  _attach() {
    let e = 0;
    const {
      to: n
    } = this.animation;
    B(n) && (ye(n, this), Ft(n) && (e = n.priority + 1)), this.priority = e;
  }
  _detach() {
    const {
      to: e
    } = this.animation;
    B(e) && De(e, this);
  }
  _set(e, n = true) {
    const i = V2(e);
    if (!p.und(i)) {
      const s = Q(this);
      if (!s || !Z(i, s.getValue())) {
        const r = Nt(i);
        !s || s.constructor != r ? an(this, r.create(i)) : s.setValue(i), s && E3.batchedUpdates(() => {
          this._onChange(i, n);
        });
      }
    }
    return Q(this);
  }
  _onStart() {
    const e = this.animation;
    e.changed || (e.changed = true, Ee(this, "onStart", z2(this, Se(this, e.to)), this));
  }
  _onChange(e, n) {
    n || (this._onStart(), ae(this.animation.onChange, e, this)), ae(this.defaultProps.onChange, e, this), super._onChange(e, n);
  }
  _start() {
    const e = this.animation;
    Q(this).reset(V2(e.to)), e.immediate || (e.fromValues = e.values.map((n) => n.lastPosition)), te(this) || (Ln(this, true), xe(this) || this._resume());
  }
  _resume() {
    Y.skipAnimation ? this.finish() : ut.start(this);
  }
  _stop(e, n) {
    if (te(this)) {
      Ln(this, false);
      const i = this.animation;
      O(i.values, (r) => {
        r.done = true;
      }), i.toValues && (i.onChange = i.onPause = i.onResume = void 0), $e(this, {
        type: "idle",
        parent: this
      });
      const s = n ? me(this.get()) : z2(this.get(), Se(this, e ?? i.to));
      Oe(this._pendingCalls, s), i.changed && (i.changed = false, Ee(this, "onRest", s, this));
    }
  }
};
function Se(t, e) {
  const n = Ne(e), i = Ne(t.get());
  return Z(i, n);
}
function Hi(t, e = t.loop, n = t.to) {
  let i = ae(e);
  if (i) {
    const s = i !== true && Bi(i), r = (s || t).reverse, o = !s || s.reset;
    return Ve($2({}, t, {
      loop: e,
      default: false,
      pause: void 0,
      to: !r || Vt(n) ? n : void 0,
      from: o ? t.from : void 0,
      reset: o
    }, s));
  }
}
function Ve(t) {
  const {
    to: e,
    from: n
  } = t = Bi(t), i = /* @__PURE__ */ new Set();
  return p.obj(e) && jn(e, i), p.obj(n) && jn(n, i), t.keys = i.size ? Array.from(i) : null, t;
}
function co(t) {
  const e = Ve(t);
  return p.und(e.default) && (e.default = un(e)), e;
}
function jn(t, e) {
  G(t, (n, i) => n != null && e.add(i));
}
var uo = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function Fn(t, e, n) {
  t.animation[n] = e[n] !== Ui(e, n) ? Fi(e[n], t.key) : void 0;
}
function Ee(t, e, ...n) {
  var i, s, r, o;
  (i = (s = t.animation)[e]) == null || i.call(s, ...n), (r = (o = t.defaultProps)[e]) == null || r.call(o, ...n);
}
var lo = ["onStart", "onChange", "onRest"];
var fo = 1;
var ho = class {
  constructor(e, n) {
    this.id = fo++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = false, this._item = void 0, this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    }, this._onFrame = this._onFrame.bind(this), n && (this._flush = n), e && this.start($2({
      default: true
    }, e));
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  get() {
    const e = {};
    return this.each((n, i) => e[i] = n.get()), e;
  }
  set(e) {
    for (const n in e) {
      const i = e[n];
      p.und(i) || this.springs[n].set(i);
    }
  }
  update(e) {
    return e && this.queue.push(Ve(e)), this;
  }
  start(e) {
    let {
      queue: n
    } = this;
    return e ? n = F(e).map(Ve) : this.queue = [], this._flush ? this._flush(this, n) : (Zi(this, n), qt(this, n));
  }
  stop(e, n) {
    if (e !== !!e && (n = e), n) {
      const i = this.springs;
      O(F(n), (s) => i[s].stop(!!e));
    } else
      Le(this._state, this._lastAsyncId), this.each((i) => i.stop(!!e));
    return this;
  }
  pause(e) {
    if (p.und(e))
      this.start({
        pause: true
      });
    else {
      const n = this.springs;
      O(F(e), (i) => n[i].pause());
    }
    return this;
  }
  resume(e) {
    if (p.und(e))
      this.start({
        pause: false
      });
    else {
      const n = this.springs;
      O(F(e), (i) => n[i].resume());
    }
    return this;
  }
  each(e) {
    G(this.springs, e);
  }
  _onFrame() {
    const {
      onStart: e,
      onChange: n,
      onRest: i
    } = this._events, s = this._active.size > 0, r = this._changed.size > 0;
    (s && !this._started || r && !this._started) && (this._started = true, ke(e, ([c, l]) => {
      l.value = this.get(), c(l, this, this._item);
    }));
    const o = !s && this._started, a = r || o && i.size ? this.get() : null;
    r && n.size && ke(n, ([c, l]) => {
      l.value = a, c(l, this, this._item);
    }), o && (this._started = false, ke(i, ([c, l]) => {
      l.value = a, c(l, this, this._item);
    }));
  }
  eventObserved(e) {
    if (e.type == "change")
      this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle")
      this._active.delete(e.parent);
    else
      return;
    E3.onFrame(this._onFrame);
  }
};
function qt(t, e) {
  return Promise.all(e.map((n) => Qi(t, n))).then((n) => ln(t, n));
}
async function Qi(t, e, n) {
  const {
    keys: i,
    to: s,
    from: r,
    loop: o,
    onRest: a,
    onResolve: c
  } = e, l = p.obj(e.default) && e.default;
  o && (e.loop = false), s === false && (e.to = null), r === false && (e.from = null);
  const u = p.arr(s) || p.fun(s) ? s : void 0;
  u ? (e.to = void 0, e.onRest = void 0, l && (l.onRest = void 0)) : O(lo, (w) => {
    const v2 = e[w];
    if (p.fun(v2)) {
      const h = t._events[w];
      e[w] = ({
        finished: _2,
        cancelled: b
      }) => {
        const g = h.get(v2);
        g ? (_2 || (g.finished = false), b && (g.cancelled = true)) : h.set(v2, {
          value: null,
          finished: _2 || false,
          cancelled: b || false
        });
      }, l && (l[w] = e[w]);
    }
  });
  const d2 = t._state;
  e.pause === !d2.paused ? (d2.paused = e.pause, Oe(e.pause ? d2.pauseQueue : d2.resumeQueue)) : d2.paused && (e.pause = true);
  const f = (i || Object.keys(t.springs)).map((w) => t.springs[w].start(e)), m = e.cancel === true || Ui(e, "cancel") === true;
  (u || m && d2.asyncId) && f.push(qi(++t._lastAsyncId, {
    props: e,
    state: d2,
    actions: {
      pause: $t,
      resume: $t,
      start(w, v2) {
        m ? (Le(d2, t._lastAsyncId), v2(me(t))) : (w.onRest = a, v2(zi(u, w, d2, t)));
      }
    }
  })), d2.paused && await new Promise((w) => {
    d2.resumeQueue.add(w);
  });
  const y = ln(t, await Promise.all(f));
  if (o && y.finished && !(n && y.noop)) {
    const w = Hi(e, o, s);
    if (w)
      return Zi(t, [w]), Qi(t, w, true);
  }
  return c && E3.batchedUpdates(() => c(y, t, t.item)), y;
}
function Un(t, e) {
  const n = $2({}, t.springs);
  return e && O(F(e), (i) => {
    p.und(i.keys) && (i = Ve(i)), p.obj(i.to) || (i = $2({}, i, {
      to: void 0
    })), Xi(n, i, (s) => Yi(s));
  }), Gi(t, n), n;
}
function Gi(t, e) {
  G(e, (n, i) => {
    t.springs[i] || (t.springs[i] = n, ye(n, t));
  });
}
function Yi(t, e) {
  const n = new ao();
  return n.key = t, e && ye(n, e), n;
}
function Xi(t, e, n) {
  e.keys && O(e.keys, (i) => {
    (t[i] || (t[i] = n(i)))._prepareNode(e);
  });
}
function Zi(t, e) {
  O(e, (n) => {
    Xi(t.springs, n, (i) => Yi(i, t));
  });
}
function po(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
var mo = ["children"];
var mt = (t) => {
  let {
    children: e
  } = t, n = po(t, mo);
  const i = (0, import_react.useContext)(it), s = n.pause || !!i.pause, r = n.immediate || !!i.immediate;
  n = Fr(() => ({
    pause: s,
    immediate: r
  }), [s, r]);
  const {
    Provider: o
  } = it;
  return d(o, {
    value: n,
    children: e
  });
};
var it = go(mt, {});
mt.Provider = it.Provider;
mt.Consumer = it.Consumer;
function go(t, e) {
  return Object.assign(t, Os.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t;
}
var vo = () => {
  const t = [], e = function(s) {
    Vr();
    const r = [];
    return O(t, (o, a) => {
      if (p.und(s))
        r.push(o.start());
      else {
        const c = n(s, o, a);
        c && r.push(o.start(c));
      }
    }), r;
  };
  e.current = t, e.add = function(i) {
    t.includes(i) || t.push(i);
  }, e.delete = function(i) {
    const s = t.indexOf(i);
    ~s && t.splice(s, 1);
  }, e.pause = function() {
    return O(t, (i) => i.pause(...arguments)), this;
  }, e.resume = function() {
    return O(t, (i) => i.resume(...arguments)), this;
  }, e.set = function(i) {
    O(t, (s) => s.set(i));
  }, e.start = function(i) {
    const s = [];
    return O(t, (r, o) => {
      if (p.und(i))
        s.push(r.start());
      else {
        const a = this._getProps(i, r, o);
        a && s.push(r.start(a));
      }
    }), s;
  }, e.stop = function() {
    return O(t, (i) => i.stop(...arguments)), this;
  }, e.update = function(i) {
    return O(t, (s, r) => s.update(this._getProps(i, s, r))), this;
  };
  const n = function(s, r, o) {
    return p.fun(s) ? s(o, r) : s;
  };
  return e._getProps = n, e;
};
function yo(t, e, n) {
  const i = p.fun(e) && e;
  i && !n && (n = []);
  const s = (0, import_react.useMemo)(() => i || arguments.length == 3 ? vo() : void 0, []), r = (0, import_react.useRef)(0), o = Li(), a = (0, import_react.useMemo)(() => ({
    ctrls: [],
    queue: [],
    flush(h, _2) {
      const b = Un(h, _2);
      return r.current > 0 && !a.queue.length && !Object.keys(b).some((S3) => !h.springs[S3]) ? qt(h, _2) : new Promise((S3) => {
        Gi(h, b), a.queue.push(() => {
          S3(qt(h, _2));
        }), o();
      });
    }
  }), []), c = (0, import_react.useRef)([...a.ctrls]), l = [], u = Tn(t) || 0;
  (0, import_react.useMemo)(() => {
    O(c.current.slice(t, u), (h) => {
      eo(h, s), h.stop(true);
    }), c.current.length = t, d2(u, t);
  }, [t]), (0, import_react.useMemo)(() => {
    d2(0, Math.min(u, t));
  }, n);
  function d2(h, _2) {
    for (let b = h; b < _2; b++) {
      const g = c.current[b] || (c.current[b] = new ho(null, a.flush)), S3 = i ? i(b, g) : e[b];
      S3 && (l[b] = co(S3));
    }
  }
  const f = c.current.map((h, _2) => Un(h, l[_2])), m = (0, import_react.useContext)(mt), y = Tn(m), w = m !== y && Jr(m);
  on(() => {
    r.current++, a.ctrls = c.current;
    const {
      queue: h
    } = a;
    h.length && (a.queue = [], O(h, (_2) => _2())), O(c.current, (_2, b) => {
      s == null || s.add(_2), w && _2.start({
        default: m
      });
      const g = l[b];
      g && (to(_2, g.ref), _2.ref ? _2.queue.push(g) : _2.start(g));
    });
  }), Vi(() => () => {
    O(a.ctrls, (h) => h.stop(true));
  });
  const v2 = f.map((h) => $2({}, h));
  return s ? [v2, s] : v2;
}
function gt(t, e) {
  const n = p.fun(t), [[i], s] = yo(1, n ? t : [t], n ? e || [] : e);
  return n || arguments.length == 2 ? [i, s] : i;
}
var Bn;
(function(t) {
  t.MOUNT = "mount", t.ENTER = "enter", t.UPDATE = "update", t.LEAVE = "leave";
})(Bn || (Bn = {}));
var bo = class extends fn {
  constructor(e, n) {
    super(), this.key = void 0, this.idle = true, this.calc = void 0, this._active = /* @__PURE__ */ new Set(), this.source = e, this.calc = Re(...n);
    const i = this._get(), s = Nt(i);
    an(this, s.create(i));
  }
  advance(e) {
    const n = this._get(), i = this.get();
    Z(n, i) || (Q(this).setValue(n), this._onChange(n, this.idle)), !this.idle && qn(this._active) && Ot(this);
  }
  _get() {
    const e = p.arr(this.source) ? this.source.map(V2) : F(V2(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !qn(this._active) && (this.idle = false, O(ht(this), (e) => {
      e.done = false;
    }), Y.skipAnimation ? (E3.batchedUpdates(() => this.advance()), Ot(this)) : ut.start(this));
  }
  _attach() {
    let e = 1;
    O(F(this.source), (n) => {
      B(n) && ye(n, this), Ft(n) && (n.idle || this._active.add(n), e = Math.max(e, n.priority + 1));
    }), this.priority = e, this._start();
  }
  _detach() {
    O(F(this.source), (e) => {
      B(e) && De(e, this);
    }), this._active.clear(), Ot(this);
  }
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = F(this.source).reduce((n, i) => Math.max(n, (Ft(i) ? i.priority : 0) + 1), 0));
  }
};
function _o(t) {
  return t.idle !== false;
}
function qn(t) {
  return !t.size || Array.from(t).every(_o);
}
function Ot(t) {
  t.idle || (t.idle = true, O(ht(t), (e) => {
    e.done = true;
  }), $e(t, {
    type: "idle",
    parent: t
  }));
}
Y.assign({
  createStringInterpolator: Mi,
  to: (t, e) => new bo(t, e)
});
function dn(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
var wo = ["style", "children", "scrollTop", "scrollLeft", "viewBox"];
var Ji = /^--/;
function xo(t, e) {
  return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !Ji.test(t) && !(Ie.hasOwnProperty(t) && Ie[t]) ? e + "px" : ("" + e).trim();
}
var Wn = {};
function So(t, e) {
  if (!t.nodeType || !t.setAttribute)
    return false;
  const n = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter", i = e, {
    style: s,
    children: r,
    scrollTop: o,
    scrollLeft: a,
    viewBox: c
  } = i, l = dn(i, wo), u = Object.values(l), d2 = Object.keys(l).map((f) => n || t.hasAttribute(f) ? f : Wn[f] || (Wn[f] = f.replace(/([A-Z])/g, (m) => "-" + m.toLowerCase())));
  r !== void 0 && (t.textContent = r);
  for (let f in s)
    if (s.hasOwnProperty(f)) {
      const m = xo(f, s[f]);
      Ji.test(f) ? t.style.setProperty(f, m) : t.style[f] = m;
    }
  d2.forEach((f, m) => {
    t.setAttribute(f, u[m]);
  }), o !== void 0 && (t.scrollTop = o), a !== void 0 && (t.scrollLeft = a), c !== void 0 && t.setAttribute("viewBox", c);
}
var Ie = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var Eo = (t, e) => t + e.charAt(0).toUpperCase() + e.substring(1);
var Oo = ["Webkit", "Ms", "Moz", "O"];
Ie = Object.keys(Ie).reduce((t, e) => (Oo.forEach((n) => t[Eo(n, e)] = t[e]), t), Ie);
var Co = ["x", "y", "z"];
var ko = /^(matrix|translate|scale|rotate|skew)/;
var Po = /^(translate)/;
var To = /^(rotate|skew)/;
var Ct = (t, e) => p.num(t) && t !== 0 ? t + e : t;
var Ye = (t, e) => p.arr(t) ? t.every((n) => Ye(n, e)) : p.num(t) ? t === e : parseFloat(t) === e;
var Io = class extends pt {
  constructor(e) {
    let {
      x: n,
      y: i,
      z: s
    } = e, r = dn(e, Co);
    const o = [], a = [];
    (n || i || s) && (o.push([n || 0, i || 0, s || 0]), a.push((c) => [`translate3d(${c.map((l) => Ct(l, "px")).join(",")})`, Ye(c, 0)])), G(r, (c, l) => {
      if (l === "transform")
        o.push([c || ""]), a.push((u) => [u, u === ""]);
      else if (ko.test(l)) {
        if (delete r[l], p.und(c))
          return;
        const u = Po.test(l) ? "px" : To.test(l) ? "deg" : "";
        o.push(F(c)), a.push(l === "rotate3d" ? ([d2, f, m, y]) => [`rotate3d(${d2},${f},${m},${Ct(y, u)})`, Ye(y, 0)] : (d2) => [`${l}(${d2.map((f) => Ct(f, u)).join(",")})`, Ye(d2, l.startsWith("scale") ? 1 : 0)]);
      }
    }), o.length && (r.transform = new Ao(o, a)), super(r);
  }
};
var Ao = class extends Ri {
  constructor(e, n) {
    super(), this._value = null, this.inputs = e, this.transforms = n;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let e = "", n = true;
    return O(this.inputs, (i, s) => {
      const r = V2(i[0]), [o, a] = this.transforms[s](p.arr(r) ? r : i.map(V2));
      e += " " + o, n = n && a;
    }), n ? "none" : e;
  }
  observerAdded(e) {
    e == 1 && O(this.inputs, (n) => O(n, (i) => B(i) && ye(i, this)));
  }
  observerRemoved(e) {
    e == 0 && O(this.inputs, (n) => O(n, (i) => B(i) && De(i, this)));
  }
  eventObserved(e) {
    e.type == "change" && (this._value = null), $e(this, e);
  }
};
var Ro = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
var $o = ["scrollTop", "scrollLeft"];
Y.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: Mi,
  colors: mr
});
var Do = Qr(Ro, {
  applyAnimatedValues: So,
  createAnimatedStyle: (t) => new Io(t),
  getComponentProps: (t) => dn(t, $o)
});
var je = Do.animated;
function Mo(t) {
  return (typeof t == "function" ? t() : t) || document.body;
}
function es(t, e) {
  if (Gt && t) {
    const n = Mo(t);
    return (0, import_react_dom.createPortal)(e, n);
  }
  return e;
}
var j = "${label}不是一个有效的${type}";
var No = {
  locale: "zh-CH",
  common: {
    confirm: "确定",
    cancel: "取消",
    loading: "加载中",
    close: "关闭"
  },
  Calendar: {
    title: "日期选择",
    confirm: "确认",
    start: "开始",
    end: "结束",
    today: "今日",
    markItems: ["一", "二", "三", "四", "五", "六", "日"],
    yearAndMonth: "${year}年${month}月"
  },
  Cascader: {
    placeholder: "请选择"
  },
  Dialog: {
    ok: "我知道了"
  },
  DatePicker: {
    tillNow: "至今"
  },
  ErrorBlock: {
    default: {
      title: "页面遇到一些小问题",
      description: "待会来试试"
    },
    busy: {
      title: "前方拥堵",
      description: "刷新试试"
    },
    disconnected: {
      title: "网络有点忙",
      description: "动动手指帮忙修复"
    },
    empty: {
      title: "没有找到你需要的东西",
      description: "找找其他的吧"
    }
  },
  Form: {
    required: "必填",
    optional: "选填",
    defaultValidateMessages: {
      default: "字段验证错误${label}",
      required: "请输入${label}",
      enum: "${label}必须是其中一个[${enum}]",
      whitespace: "${label}不能为空字符",
      date: {
        format: "${label}日期格式无效",
        parse: "${label}不能转换为日期",
        invalid: "${label}是一个无效日期"
      },
      types: {
        string: j,
        method: j,
        array: j,
        object: j,
        number: j,
        date: j,
        boolean: j,
        integer: j,
        float: j,
        regexp: j,
        email: j,
        url: j,
        hex: j
      },
      string: {
        len: "${label}须为${len}个字符",
        min: "${label}最少${min}个字符",
        max: "${label}最多${max}个字符",
        range: "${label}须在${min}-${max}字符之间"
      },
      number: {
        len: "${label}必须等于${len}",
        min: "${label}最小值为${min}",
        max: "${label}最大值为${max}",
        range: "${label}须在${min}-${max}之间"
      },
      array: {
        len: "须为${len}个${label}",
        min: "最少${min}个${label}",
        max: "最多${max}个${label}",
        range: "${label}数量须在${min}-${max}之间"
      },
      pattern: {
        mismatch: "${label}与模式不匹配${pattern}"
      }
    }
  },
  ImageUploader: {
    uploading: "上传中...",
    upload: "上传"
  },
  InfiniteScroll: {
    noMore: "没有更多了",
    failedToLoad: "加载失败",
    retry: "重新加载"
  },
  Input: {
    clear: "清除"
  },
  Mask: {
    name: "背景蒙层"
  },
  Modal: {
    ok: "我知道了"
  },
  PasscodeInput: {
    name: "密码输入框"
  },
  PullToRefresh: {
    pulling: "下拉刷新",
    canRelease: "释放立即刷新",
    complete: "刷新成功"
  },
  SearchBar: {
    name: "搜索框"
  },
  Slider: {
    name: "滑动输入条"
  },
  Stepper: {
    decrease: "减少",
    increase: "增加"
  },
  Switch: {
    name: "开关"
  },
  Selector: {
    name: "选择组"
  }
};
var Lo = No;
var Vo = {
  current: {
    locale: Lo
  }
};
function jo() {
  return Vo.current;
}
var Fo = import_react.default.createContext(null);
function hn() {
  var t;
  return (t = (0, import_react.useContext)(Fo)) !== null && t !== void 0 ? t : jo();
}
function Uo(t) {
  const e = (0, import_react.useRef)(t);
  return t && (e.current = true), !!e.current;
}
var ts = (t) => Bo(t.active, t.forceRender, t.destroyOnClose) ? t.children : null;
function Bo(t, e, n) {
  const i = Uo(t);
  return e || t ? true : i ? !n : false;
}
var qo = {
  click: "onClick",
  touchstart: "onTouchStart"
};
function ns(t, e) {
  const n = Object.assign({}, e.props);
  for (const i of t) {
    const s = qo[i];
    n[s] = function(r) {
      var o, a;
      r.stopPropagation(), (a = (o = e.props)[s]) === null || a === void 0 || a.call(o, r);
    };
  }
  return import_react.default.cloneElement(e, n);
}
var kt = "adm-mask";
var Wo = {
  default: 0.55,
  thin: 0.35,
  thick: 0.75
};
var zo = {
  black: "0, 0, 0",
  white: "255, 255, 255"
};
var Ko = {
  visible: true,
  destroyOnClose: false,
  forceRender: false,
  color: "black",
  opacity: "default",
  disableBodyScroll: true,
  getContainer: null,
  stopPropagation: ["click"]
};
var Ho = (t) => {
  const e = D(Ko, t), {
    locale: n
  } = hn(), i = (0, import_react.useRef)(null);
  xi(i, e.visible && e.disableBodyScroll);
  const s = (0, import_react.useMemo)(() => {
    var u;
    const d2 = (u = Wo[e.opacity]) !== null && u !== void 0 ? u : e.opacity, f = zo[e.color];
    return f ? `rgba(${f}, ${d2})` : e.color;
  }, [e.color, e.opacity]), [r, o] = (0, import_react.useState)(e.visible), a = wi(), {
    opacity: c
  } = gt({
    opacity: e.visible ? 1 : 0,
    config: {
      precision: 0.01,
      mass: 1,
      tension: 250,
      friction: 30,
      clamp: true
    },
    onStart: () => {
      o(true);
    },
    onRest: () => {
      var u, d2;
      a.current || (o(e.visible), e.visible ? (u = e.afterShow) === null || u === void 0 || u.call(e) : (d2 = e.afterClose) === null || d2 === void 0 || d2.call(e));
    }
  }), l = ns(e.stopPropagation, E(e, import_react.default.createElement(je.div, {
    className: kt,
    ref: i,
    "aria-hidden": true,
    style: Object.assign(Object.assign({}, e.style), {
      background: s,
      opacity: c,
      display: r ? void 0 : "none"
    }),
    onClick: (u) => {
      var d2;
      u.target === u.currentTarget && ((d2 = e.onMaskClick) === null || d2 === void 0 || d2.call(e, u));
    }
  }, e.onMaskClick && d("div", {
    className: `${kt}-aria-button`,
    role: "button",
    "aria-label": n.Mask.name,
    onClick: e.onMaskClick
  }), d("div", {
    className: `${kt}-content`,
    children: e.children
  }))));
  return d(ts, {
    active: r,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: es(e.getContainer, l)
  });
};
function Qo(t) {
  return d("svg", {
    ...Object.assign({
      width: "1em",
      height: "1em",
      viewBox: "0 0 48 48",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, t, {
      style: Object.assign({
        verticalAlign: "-0.125em"
      }, t.style),
      className: ["antd-mobile-icon", t.className].filter(Boolean).join(" ")
    }),
    children: d("g", {
      id: "CloseOutline-CloseOutline",
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd",
      children: N2("g", {
        id: "CloseOutline-编组",
        children: [d("rect", {
          id: "CloseOutline-矩形",
          fill: "#FFFFFF",
          opacity: 0,
          x: 0,
          y: 0,
          width: 48,
          height: 48
        }), d("path", {
          d: "M10.6085104,8.11754663 L24.1768397,21.8195031 L24.1768397,21.8195031 L37.7443031,8.1175556 C37.8194278,8.04168616 37.9217669,7.999 38.0285372,7.999 L41.1040268,7.999 C41.3249407,7.999 41.5040268,8.1780861 41.5040268,8.399 C41.5040268,8.50440471 41.4624226,8.60554929 41.3882578,8.68044752 L26.2773302,23.9408235 L26.2773302,23.9408235 L41.5021975,39.3175645 C41.65763,39.4745475 41.6563731,39.7278104 41.4993901,39.8832429 C41.4244929,39.9574004 41.3233534,39.999 41.2179546,39.999 L38.1434012,39.999 C38.0366291,39.999 37.9342885,39.9563124 37.8591634,39.8804408 L24.1768397,26.0621438 L24.1768397,26.0621438 L10.4936501,39.8804497 C10.4185257,39.9563159 10.3161889,39.999 10.2094212,39.999 L7.13584526,39.999 C6.91493136,39.999 6.73584526,39.8199139 6.73584526,39.599 C6.73584526,39.4936017 6.77744443,39.3924627 6.85160121,39.3175656 L22.0763492,23.9408235 L22.0763492,23.9408235 L6.96554081,8.68044639 C6.81010226,8.52346929 6.81134951,8.27020637 6.9683266,8.11476782 C7.04322474,8.04060377 7.14436883,7.999 7.24977299,7.999 L10.3242852,7.999 C10.4310511,7.999 10.5333863,8.04168267 10.6085104,8.11754663 Z",
          id: "CloseOutline-路径",
          fill: "currentColor",
          fillRule: "nonzero"
        })]
      })
    })
  });
}
var Go = {
  closeOnMaskClick: false,
  destroyOnClose: false,
  disableBodyScroll: true,
  forceRender: false,
  getContainer: () => document.body,
  mask: true,
  showCloseButton: false,
  stopPropagation: ["click"],
  visible: false
};
function Yo(t) {
  const [e, n] = (0, import_react.useState)(t);
  return Ce(() => {
    n(t);
  }, [t]), e;
}
function Xo(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
var D2 = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function zn(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function Kn(t, e, n, i = 0.15) {
  return i === 0 ? Xo(t, e, n) : t < e ? -zn(e - t, n - e, i) + e : t > n ? +zn(t - n, n - e, i) + n : t;
}
function Zo(t, [e, n], [i, s]) {
  const [[r, o], [a, c]] = t;
  return [Kn(e, r, o, i), Kn(n, a, c, s)];
}
function Jo(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t, e || "default");
    if (typeof i != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function ea(t) {
  var e = Jo(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function N3(t, e, n) {
  return e = ea(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t[e] = n, t;
}
function Hn(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function A2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Hn(Object(n), true).forEach(function(i) {
      N3(t, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Hn(Object(n)).forEach(function(i) {
      Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t;
}
var is = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Qn(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
var ta = ["enter", "leave"];
function na(t = false, e) {
  return t && !ta.includes(e);
}
function ia(t, e = "", n = false) {
  const i = is[t], s = i && i[e] || e;
  return "on" + Qn(t) + Qn(s) + (na(n, s) ? "Capture" : "");
}
var sa = ["gotpointercapture", "lostpointercapture"];
function ra(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const i = sa.includes(e) ? "capturecapture" : "capture", s = !!~e.indexOf(i);
  return s && (e = e.replace("capture", "")), {
    device: e,
    capture: s,
    passive: n
  };
}
function oa(t, e = "") {
  const n = is[t], i = n && n[e] || e;
  return t + i;
}
function vt(t) {
  return "touches" in t;
}
function ss(t) {
  return vt(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function aa(t) {
  return Array.from(t.touches).filter((e) => {
    var n, i;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (i = n.contains) === null || i === void 0 ? void 0 : i.call(n, e.target));
  });
}
function ca(t) {
  return t.type === "touchend" || t.type === "touchcancel" ? t.changedTouches : t.targetTouches;
}
function rs(t) {
  return vt(t) ? ca(t)[0] : t;
}
function ua(t) {
  return aa(t).map((e) => e.identifier);
}
function Pt(t) {
  const e = rs(t);
  return vt(t) ? e.identifier : e.pointerId;
}
function Gn(t) {
  const e = rs(t);
  return [e.clientX, e.clientY];
}
var Yn = 40;
var Xn = 800;
function la(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: i
  } = t;
  return i === 1 ? (e *= Yn, n *= Yn) : i === 2 && (e *= Xn, n *= Xn), [e, n];
}
function fa(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: i,
      metaKey: s,
      ctrlKey: r
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: i,
      metaKey: s,
      ctrlKey: r
    });
  }
  return e;
}
function st(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function da() {
}
function ha(...t) {
  return t.length === 0 ? da : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function Zn(t, e) {
  return Object.assign({}, e, t || {});
}
var pa = 32;
var ma = class {
  constructor(e, n, i) {
    this.ctrl = e, this.args = n, this.key = i, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: i,
      args: s
    } = this;
    n[i] = e._active = e.active = e._blocked = e._force = false, e._step = [false, false], e.intentional = false, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = s, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [false, false], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, i = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = true, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = i.from ? st(i.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: i,
      shared: s
    } = this;
    n.args = this.args;
    let r = 0;
    if (e && (n.event = e, i.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, s.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, s.locked = !!document.pointerLockElement, Object.assign(s, fa(e)), s.down = s.pressed = s.buttons % 2 === 1 || s.touches > 0, r = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const x2 = n._delta.map(Math.abs);
      D2.addTo(n._distance, x2);
    }
    this.axisIntent && this.axisIntent(e);
    const [o, a] = n._movement, [c, l] = i.threshold, {
      _step: u,
      values: d2
    } = n;
    if (i.hasCustomTransform ? (u[0] === false && (u[0] = Math.abs(o) >= c && d2[0]), u[1] === false && (u[1] = Math.abs(a) >= l && d2[1])) : (u[0] === false && (u[0] = Math.abs(o) >= c && Math.sign(o) * c), u[1] === false && (u[1] = Math.abs(a) >= l && Math.sign(a) * l)), n.intentional = u[0] !== false || u[1] !== false, !n.intentional)
      return;
    const f = [0, 0];
    if (i.hasCustomTransform) {
      const [x2, k] = d2;
      f[0] = u[0] !== false ? x2 - u[0] : 0, f[1] = u[1] !== false ? k - u[1] : 0;
    } else
      f[0] = u[0] !== false ? o - u[0] : 0, f[1] = u[1] !== false ? a - u[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(f);
    const m = n.offset, y = n._active && !n._blocked || n.active;
    y && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = s[this.ingKey] = n._active, e && (n.first && ("bounds" in i && (n._bounds = st(i.bounds, n)), this.setup && this.setup()), n.movement = f, this.computeOffset()));
    const [w, v2] = n.offset, [[h, _2], [b, g]] = n._bounds;
    n.overflow = [w < h ? -1 : w > _2 ? 1 : 0, v2 < b ? -1 : v2 > g ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === false ? n._movement[0] : n._movementBound[0] : false, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === false ? n._movement[1] : n._movementBound[1] : false;
    const S3 = n._active ? i.rubberband || [0, 0] : [0, 0];
    if (n.offset = Zo(n._bounds, n.offset, S3), n.delta = D2.sub(n.offset, m), this.computeMovement(), y && (!n.last || r > pa)) {
      n.delta = D2.sub(n.offset, m);
      const x2 = n.delta.map(Math.abs);
      D2.addTo(n.distance, x2), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && r > 0 && (n.velocity = [x2[0] / r, x2[1] / r], n.timeDelta = r);
    }
  }
  emit() {
    const e = this.state, n = this.shared, i = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !i.triggerAllEvents)
      return;
    const s = this.handler(A2(A2(A2({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    s !== void 0 && (e.memo = s);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
};
function ga([t, e], n) {
  const i = Math.abs(t), s = Math.abs(e);
  if (i > s && i > n)
    return "x";
  if (s > i && s > n)
    return "y";
}
var os = class extends ma {
  constructor(...e) {
    super(...e), N3(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = D2.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = D2.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, i = this.config;
    if (!n.axis && e) {
      const s = typeof i.axisThreshold == "object" ? i.axisThreshold[ss(e)] : i.axisThreshold;
      n.axis = ga(n._movement, s);
    }
    n._blocked = (i.lockDirection || !!i.axis) && !n.axis || !!i.axis && i.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
};
var Jn = (t) => t;
var ei = 0.15;
var pn = {
  enabled(t = true) {
    return t;
  },
  eventOptions(t, e, n) {
    return A2(A2({}, n.shared.eventOptions), t);
  },
  preventDefault(t = false) {
    return t;
  },
  triggerAllEvents(t = false) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case true:
        return [ei, ei];
      case false:
        return [0, 0];
      default:
        return D2.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function")
      return t;
    if (t != null)
      return D2.toVector(t);
  },
  transform(t, e, n) {
    const i = t || n.shared.transform;
    if (this.hasCustomTransform = !!i, true) {
      const s = i || Jn;
      return (r) => {
        const o = s(r);
        return (!isFinite(o[0]) || !isFinite(o[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${o[0]},${[1]}]`), o;
      };
    }
    return i || Jn;
  },
  threshold(t) {
    return D2.toVector(t, 0);
  }
};
Object.assign(pn, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
var va = 0;
var _e2 = A2(A2({}, pn), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection)
      return n;
  },
  axisThreshold(t = va) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (r) => _e2.bounds(t(r));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: i = -1 / 0,
      bottom: s = 1 / 0
    } = t;
    return [[e, n], [i, s]];
  }
});
var ti = {
  ArrowRight: (t, e = 1) => [t * e, 0],
  ArrowLeft: (t, e = 1) => [-1 * t * e, 0],
  ArrowUp: (t, e = 1) => [0, -1 * t * e],
  ArrowDown: (t, e = 1) => [0, t * e]
};
var ya = class extends os {
  constructor(...e) {
    super(...e), N3(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = false, e._keyboardActive = false, e._preventScroll = false, e._delayed = false, e.swipe = [0, 0], e.tap = false, e.canceled = false, e.cancel = this.cancel.bind(this);
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const n = e._bounds.getBoundingClientRect(), i = e.currentTarget.getBoundingClientRect(), s = {
        left: n.left - i.left + e.offset[0],
        right: n.right - i.right + e.offset[0],
        top: n.top - i.top + e.offset[1],
        bottom: n.bottom - i.bottom + e.offset[1]
      };
      e._bounds = _e2.bounds(s);
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = true, e._active = false, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = false, this.state._keyboardActive = false, super.clean();
  }
  pointerDown(e) {
    const n = this.config, i = this.state;
    if (e.buttons != null && (Array.isArray(n.pointerButtons) ? !n.pointerButtons.includes(e.buttons) : n.pointerButtons !== -1 && n.pointerButtons !== e.buttons))
      return;
    const s = this.ctrl.setEventIds(e);
    n.pointerCapture && e.target.setPointerCapture(e.pointerId), !(s && s.size > 1 && i._pointerActive) && (this.start(e), this.setupPointer(e), i._pointerId = Pt(e), i._pointerActive = true, this.computeValues(Gn(e)), this.computeInitial(), n.preventScrollAxis && ss(e) !== "mouse" ? (i._active = false, this.setupScrollPrevention(e)) : n.delay > 0 ? (this.setupDelayTrigger(e), n.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e));
  }
  startPointerDrag(e) {
    const n = this.state;
    n._active = true, n._preventScroll = true, n._delayed = false, this.compute(e), this.emit();
  }
  pointerMove(e) {
    const n = this.state, i = this.config;
    if (!n._pointerActive)
      return;
    const s = Pt(e);
    if (n._pointerId !== void 0 && s !== n._pointerId)
      return;
    const r = Gn(e);
    if (document.pointerLockElement === e.target ? n._delta = [e.movementX, e.movementY] : (n._delta = D2.sub(r, n._values), this.computeValues(r)), D2.addTo(n._movement, n._delta), this.compute(e), n._delayed && n.intentional) {
      this.timeoutStore.remove("dragDelay"), n.active = false, this.startPointerDrag(e);
      return;
    }
    if (i.preventScrollAxis && !n._preventScroll)
      if (n.axis)
        if (n.axis === i.preventScrollAxis || i.preventScrollAxis === "xy") {
          n._active = false, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId);
    } catch {
      console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const n = this.state, i = this.config;
    if (!n._active || !n._pointerActive)
      return;
    const s = Pt(e);
    if (n._pointerId !== void 0 && s !== n._pointerId)
      return;
    this.state._pointerActive = false, this.setActive(), this.compute(e);
    const [r, o] = n._distance;
    if (n.tap = r <= i.tapsThreshold && o <= i.tapsThreshold, n.tap && i.filterTaps)
      n._force = true;
    else {
      const [a, c] = n._delta, [l, u] = n._movement, [d2, f] = i.swipe.velocity, [m, y] = i.swipe.distance, w = i.swipe.duration;
      if (n.elapsedTime < w) {
        const v2 = Math.abs(a / n.timeDelta), h = Math.abs(c / n.timeDelta);
        v2 > d2 && Math.abs(l) > m && (n.swipe[0] = Math.sign(a)), h > f && Math.abs(u) > y && (n.swipe[1] = Math.sign(c));
      }
    }
    this.emit();
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation());
  }
  setupPointer(e) {
    const n = this.config, i = n.device;
    if (true)
      try {
        if (i === "pointer" && n.preventScrollDelay === void 0) {
          const s = "uv" in e ? e.sourceEvent.currentTarget : e.currentTarget;
          window.getComputedStyle(s).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", s);
        }
      } catch {
      }
    n.pointerLock && e.currentTarget.requestPointerLock(), n.pointerCapture || (this.eventStore.add(this.sharedConfig.window, i, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, i, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, i, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault();
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = false, ba(e);
    const n = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", n), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", n), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e);
  }
  setupDelayTrigger(e) {
    this.state._delayed = true, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e);
    }, this.config.delay);
  }
  keyDown(e) {
    const n = ti[e.key];
    if (n) {
      const i = this.state, s = e.shiftKey ? 10 : e.altKey ? 0.1 : 1;
      this.start(e), i._delta = n(this.config.keyboardDisplacement, s), i._keyboardActive = true, D2.addTo(i._movement, i._delta), this.compute(e), this.emit();
    }
  }
  keyUp(e) {
    e.key in ti && (this.state._keyboardActive = false, this.setActive(), this.compute(e), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    e(n, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(n, "change", this.pointerMove.bind(this)), e(n, "end", this.pointerUp.bind(this)), e(n, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: true,
      passive: false
    });
  }
};
function ba(t) {
  "persist" in t && typeof t.persist == "function" && t.persist();
}
var We = typeof window < "u" && window.document && window.document.createElement;
function as() {
  return We && "ontouchstart" in window;
}
function _a() {
  return as() || We && window.navigator.maxTouchPoints > 1;
}
function wa() {
  return We && "onpointerdown" in window;
}
function xa() {
  return We && "exitPointerLock" in window.document;
}
function Sa() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return false;
  }
}
var q = {
  isBrowser: We,
  gesture: Sa(),
  touch: as(),
  touchscreen: _a(),
  pointer: wa(),
  pointerLock: xa()
};
var Ea = 250;
var Oa = 180;
var Ca = 0.5;
var ka = 50;
var Pa = 250;
var Ta = 10;
var ni = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var cs = A2(A2({}, _e2), {}, {
  device(t, e, {
    pointer: {
      touch: n = false,
      lock: i = false,
      mouse: s = false
    } = {}
  }) {
    return this.pointerLock = i && q.pointerLock, q.touch && n ? "touch" : this.pointerLock ? "mouse" : q.pointer && !s ? "pointer" : q.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? Ea : void 0, !(!q.touchscreen || n === false))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = true,
      buttons: i = 1,
      keys: s = true
    } = {}
  }) {
    return this.pointerButtons = i, this.keys = s, !this.pointerLock && this.device === "pointer" && n;
  },
  threshold(t, e, {
    filterTaps: n = false,
    tapsThreshold: i = 3,
    axis: s = void 0
  }) {
    const r = D2.toVector(t, n ? i : s ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = i, r;
  },
  swipe({
    velocity: t = Ca,
    distance: e = ka,
    duration: n = Pa
  } = {}) {
    return {
      velocity: this.transform(D2.toVector(t)),
      distance: this.transform(D2.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case true:
        return Oa;
      case false:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? A2(A2({}, ni), t) : ni;
  },
  keyboardDisplacement(t = Ta) {
    return t;
  }
});
Object.assign(cs, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function Ia(t) {
  const [e, n] = t.overflow, [i, s] = t._delta, [r, o] = t._direction;
  (e < 0 && i > 0 && r < 0 || e > 0 && i < 0 && r > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && s > 0 && o < 0 || n > 0 && s < 0 && o > 0) && (t._movement[1] = t._movementBound[1]);
}
A2(A2({}, pn), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: i = false
    } = {}
  }) {
    if (n.target && !q.touch && q.gesture)
      return "gesture";
    if (q.touch && i)
      return "touch";
    if (q.touchscreen) {
      if (q.pointer)
        return "pointer";
      if (q.touch)
        return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: i = {}
  }) {
    const s = (o) => {
      const a = Zn(st(n, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    }, r = (o) => {
      const a = Zn(st(i, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    };
    return typeof n != "function" && typeof i != "function" ? [s(), r()] : (o) => [s(o), r(o)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", D2.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  },
  pinchOnWheel(t = true) {
    return t;
  }
});
A2(A2({}, _e2), {}, {
  mouseOnly: (t = true) => t
});
var Aa = class extends os {
  constructor(...e) {
    super(...e), N3(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = la(e), D2.addTo(n._movement, n._delta), Ia(n), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = false, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
};
var Ra = _e2;
A2(A2({}, _e2), {}, {
  mouseOnly: (t = true) => t
});
var us = /* @__PURE__ */ new Map();
var Wt = /* @__PURE__ */ new Map();
function ls(t) {
  us.set(t.key, t.engine), Wt.set(t.key, t.resolver);
}
var $a = {
  key: "drag",
  engine: ya,
  resolver: cs
};
var Da = {
  key: "wheel",
  engine: Aa,
  resolver: Ra
};
function Ma(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function Na(t, e) {
  if (t == null)
    return {};
  var n = Ma(t, e), i, s;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    for (s = 0; s < r.length; s++)
      i = r[s], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]);
  }
  return n;
}
var La = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = true) {
    return t;
  },
  window(t = q.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = true,
    capture: e = false
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
};
var Va = ["target", "eventOptions", "window", "enabled", "transform"];
function Xe(t = {}, e) {
  const n = {};
  for (const [i, s] of Object.entries(e))
    switch (typeof s) {
      case "function":
        if (true) {
          const r = s.call(n, t[i], i, t);
          Number.isNaN(r) || (n[i] = r);
        } else
          n[i] = s.call(n, t[i], i, t);
        break;
      case "object":
        n[i] = Xe(t[i], s);
        break;
      case "boolean":
        s && (n[i] = t[i]);
        break;
    }
  return n;
}
function ja(t, e, n = {}) {
  const i = t, {
    target: s,
    eventOptions: r,
    window: o,
    enabled: a,
    transform: c
  } = i, l = Na(i, Va);
  if (n.shared = Xe({
    target: s,
    eventOptions: r,
    window: o,
    enabled: a,
    transform: c
  }, La), e) {
    const u = Wt.get(e);
    n[e] = Xe(A2({
      shared: n.shared
    }, l), u);
  } else
    for (const u in l) {
      const d2 = Wt.get(u);
      if (d2)
        n[u] = Xe(A2({
          shared: n.shared
        }, l[u]), d2);
      else if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(u)) {
        if (u === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${u}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
var fs = class {
  constructor(e, n) {
    N3(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, i, s, r) {
    const o = this._listeners, a = oa(n, i), c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, l = A2(A2({}, c), r);
    e.addEventListener(a, s, l);
    const u = () => {
      e.removeEventListener(a, s, l), o.delete(u);
    };
    return o.add(u), u;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
};
var Fa = class {
  constructor() {
    N3(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, i = 140, ...s) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, i, ...s));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
};
var Ua = class {
  constructor(e) {
    N3(this, "gestures", /* @__PURE__ */ new Set()), N3(this, "_targetEventStore", new fs(this)), N3(this, "gestureEventStores", {}), N3(this, "gestureTimeoutStores", {}), N3(this, "handlers", {}), N3(this, "config", {}), N3(this, "pointerIds", /* @__PURE__ */ new Set()), N3(this, "touchIds", /* @__PURE__ */ new Set()), N3(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    }), Ba(this, e);
  }
  setEventIds(e) {
    if (vt(e))
      return this.touchIds = new Set(ua(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = ja(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, i = {};
    let s;
    if (!(n.target && (s = n.target(), !s))) {
      if (n.enabled) {
        for (const o of this.gestures) {
          const a = this.config[o], c = ii(i, a.eventOptions, !!s);
          if (a.enabled) {
            const l = us.get(o);
            new l(this, e, o).bind(c);
          }
        }
        const r = ii(i, n.eventOptions, !!s);
        for (const o in this.nativeHandlers)
          r(o, "", (a) => this.nativeHandlers[o](A2(A2({}, this.state.shared), {}, {
            event: a,
            args: e
          })), void 0, true);
      }
      for (const r in i)
        i[r] = ha(...i[r]);
      if (!s)
        return i;
      for (const r in i) {
        const {
          device: o,
          capture: a,
          passive: c
        } = ra(r);
        this._targetEventStore.add(s, o, "", i[r], {
          capture: a,
          passive: c
        });
      }
    }
  }
};
function de(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new fs(t, e), t.gestureTimeoutStores[e] = new Fa();
}
function Ba(t, e) {
  e.drag && de(t, "drag"), e.wheel && de(t, "wheel"), e.scroll && de(t, "scroll"), e.move && de(t, "move"), e.pinch && de(t, "pinch"), e.hover && de(t, "hover");
}
var ii = (t, e, n) => (i, s, r, o = {}, a = false) => {
  var c, l;
  const u = (c = o.capture) !== null && c !== void 0 ? c : e.capture, d2 = (l = o.passive) !== null && l !== void 0 ? l : e.passive;
  let f = a ? i : ia(i, s, u);
  n && d2 && (f += "Passive"), t[f] = t[f] || [], t[f].push(r);
};
function ds(t, e = {}, n, i) {
  const s = import_react.default.useMemo(() => new Ua(t), []);
  if (s.applyHandlers(t, i), s.applyConfig(e, n), import_react.default.useEffect(s.effect.bind(s)), import_react.default.useEffect(() => s.clean.bind(s), []), e.target === void 0)
    return s.bind.bind(s);
}
function hs(t, e) {
  return ls($a), ds({
    drag: t
  }, e || {}, "drag");
}
function qa(t, e) {
  return ls(Da), ds({
    wheel: t
  }, e || {}, "wheel");
}
var Qe = "adm-popup";
var Wa = Object.assign(Object.assign({}, Go), {
  closeOnSwipe: false,
  position: "bottom"
});
var za = (t) => {
  const e = D(Wa, t), n = _e(`${Qe}-body`, e.bodyClassName, `${Qe}-body-position-${e.position}`), {
    locale: i
  } = hn(), [s, r] = (0, import_react.useState)(e.visible), o = (0, import_react.useRef)(null);
  xi(o, e.disableBodyScroll && s ? "strict" : false), Ce(() => {
    e.visible && r(true);
  }, [e.visible]);
  const a = wi(), {
    percent: c
  } = gt({
    percent: e.visible ? 0 : 100,
    config: {
      precision: 0.1,
      mass: 0.4,
      tension: 300,
      friction: 30
    },
    onRest: () => {
      var f, m;
      a.current || (r(e.visible), e.visible ? (f = e.afterShow) === null || f === void 0 || f.call(e) : (m = e.afterClose) === null || m === void 0 || m.call(e));
    }
  }), l = hs(({
    swipe: [, f]
  }) => {
    var m;
    e.closeOnSwipe && (f === 1 && e.position === "bottom" || f === -1 && e.position === "top") && ((m = e.onClose) === null || m === void 0 || m.call(e));
  }, {
    axis: "y",
    enabled: ["top", "bottom"].includes(e.position)
  }), u = Yo(s && e.visible), d2 = ns(e.stopPropagation, E(e, import_react.default.createElement("div", Object.assign({
    className: Qe,
    onClick: e.onClick,
    style: {
      display: s ? void 0 : "none",
      touchAction: ["top", "bottom"].includes(e.position) ? "none" : "auto"
    }
  }, l()), e.mask && d(Ho, {
    visible: u,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    onMaskClick: (f) => {
      var m, y;
      (m = e.onMaskClick) === null || m === void 0 || m.call(e, f), e.closeOnMaskClick && ((y = e.onClose) === null || y === void 0 || y.call(e));
    },
    className: e.maskClassName,
    style: e.maskStyle,
    disableBodyScroll: false,
    stopPropagation: e.stopPropagation
  }), import_react.default.createElement(je.div, {
    className: n,
    style: Object.assign(Object.assign({}, e.bodyStyle), {
      pointerEvents: c.to((f) => f === 0 ? "unset" : "none"),
      transform: c.to((f) => e.position === "bottom" ? `translate(0, ${f}%)` : e.position === "top" ? `translate(0, -${f}%)` : e.position === "left" ? `translate(-${f}%, 0)` : e.position === "right" ? `translate(${f}%, 0)` : "none")
    }),
    ref: o
  }, e.showCloseButton && d("a", {
    className: _e(`${Qe}-close-icon`, "adm-plain-anchor"),
    onClick: () => {
      var f;
      (f = e.onClose) === null || f === void 0 || f.call(e);
    },
    role: "button",
    "aria-label": i.common.close,
    children: d(Qo, {})
  }), e.children))));
  return d(ts, {
    active: s,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: es(e.getContainer, d2)
  });
};
function zt(t, e, n) {
  let i = t;
  return e !== void 0 && (i = Math.max(t, e)), n !== void 0 && (i = Math.min(i, n)), i;
}
function si(t, e, n) {
  return t * e * n / (e + n * t);
}
function ri(t, e, n, i, s = 0.15) {
  return s === 0 ? zt(t, e, n) : t < e ? -si(e - t, i, s) + e : t > n ? +si(t - n, i, s) + n : t;
}
var Kt = true;
function oi(t, e) {
  Kt && console.error(`[antd-mobile: ${t}] ${e}`);
}
function Ka(t) {
  if (t == null || t === "")
    return Kt && oi("Global", "Something went wrong when calculating CSS length. Please report an issue at https://github.com/ant-design/ant-design-mobile/issues/new/choose"), 0;
  const e = t.trim();
  return e.endsWith("px") ? parseFloat(e) : e.endsWith("rem") ? parseFloat(e) * parseFloat(window.getComputedStyle(document.documentElement).fontSize) : e.endsWith("vw") ? parseFloat(e) * window.innerWidth / 100 : (Kt && oi("Global", `You are using a not supported CSS unit in \`${t}\`. Only \`px\` \`rem\` and \`vw\` are supported.`), 0);
}
var H = "adm-picker-view";
var ps = (0, import_react.memo)((t) => {
  const {
    value: e,
    column: n,
    renderLabel: i
  } = t;
  function s(h) {
    t.onSelect(h, t.index);
  }
  const [{
    y: r
  }, o] = gt(() => ({
    from: {
      y: 0
    },
    config: {
      tension: 400,
      mass: 0.8
    }
  })), a = (0, import_react.useRef)(false), c = (0, import_react.useRef)(null), l = (0, import_react.useRef)(null), u = (0, import_react.useRef)(34);
  Ce(() => {
    const h = l.current;
    h && (u.current = Ka(window.getComputedStyle(h).getPropertyValue("height")));
  }), Ce(() => {
    if (a.current || e === null)
      return;
    const h = n.findIndex((b) => b.value === e);
    if (h < 0)
      return;
    const _2 = h * -u.current;
    o.start({
      y: _2,
      immediate: r.goal !== _2
    });
  }, [e, n]), Ce(() => {
    if (n.length === 0)
      e !== null && s(null);
    else if (!n.some((h) => h.value === e)) {
      const h = n[0];
      s(h.value);
    }
  }, [n, e]);
  function d2(h) {
    const _2 = h * -u.current;
    o.start({
      y: _2
    });
    const b = n[h];
    b && s(b.value);
  }
  const f = (h) => {
    const {
      direction: [, _2],
      distance: [, b],
      velocity: [, g],
      offset: [, S3],
      last: x2
    } = h;
    return {
      direction: _2,
      distance: b,
      velocity: g,
      offset: S3,
      last: x2
    };
  }, m = (h) => {
    a.current = true;
    const _2 = -((n.length - 1) * u.current), b = 0, {
      direction: g,
      last: S3,
      velocity: x2,
      offset: k
    } = f(h);
    if (S3) {
      a.current = false;
      const P2 = k + x2 * g * 50, I = zt(P2, _2, b), R2 = -Math.round(I / u.current);
      d2(R2);
    } else {
      const P2 = k;
      o.start({
        y: ri(P2, _2, b, u.current * 50, 0.2)
      });
    }
  }, y = (h) => {
    a.current = true;
    const _2 = -((n.length - 1) * u.current), b = 0, {
      direction: g,
      last: S3,
      velocity: x2,
      distance: k
    } = f(h), P2 = -g, I = r.get();
    if (S3) {
      a.current = false;
      const R2 = x2 * P2 * 50, X = I + k * P2 + R2, U = zt(X, _2, b), ee = -Math.round(U / u.current);
      d2(ee);
    } else {
      const R2 = I + k * P2;
      o.start({
        y: ri(R2, _2, b, u.current * 50, 0.2)
      });
    }
  };
  hs((h) => {
    h.event.stopPropagation(), m(h);
  }, {
    axis: "y",
    from: () => [0, r.get()],
    filterTaps: true,
    pointer: {
      touch: true
    },
    target: c
  }), qa((h) => {
    h.event.stopPropagation(), y(h);
  }, {
    target: t.mouseWheel ? c : void 0,
    axis: "y",
    from: () => [0, r.get()],
    preventDefault: true,
    eventOptions: Ze ? {
      passive: false
    } : void 0
  });
  let w = null;
  function v2() {
    if (w === null)
      return null;
    const h = n[w], _2 = w - 1, b = w + 1, g = n[_2], S3 = n[b];
    return N2("div", {
      className: `${H}-column-accessible`,
      children: [d("div", {
        className: `${H}-column-accessible-current`,
        role: "button",
        "aria-label": h ? `当前选择的是：${h.label}` : "当前未选择",
        children: "-"
      }), d("div", {
        className: `${H}-column-accessible-button`,
        onClick: () => {
          g && d2(_2);
        },
        role: g ? "button" : "text",
        "aria-label": g ? `选择上一项：${g.label}` : "没有上一项",
        children: "-"
      }), d("div", {
        className: `${H}-column-accessible-button`,
        onClick: () => {
          S3 && d2(b);
        },
        role: S3 ? "button" : "text",
        "aria-label": S3 ? `选择下一项：${S3.label}` : "没有下一项",
        children: "-"
      })]
    });
  }
  return import_react.default.createElement("div", {
    className: `${H}-column`
  }, d("div", {
    className: `${H}-item-height-measure`,
    ref: l
  }), import_react.default.createElement(je.div, {
    ref: c,
    style: {
      translateY: r
    },
    className: `${H}-column-wheel`,
    "aria-hidden": true
  }, n.map((h, _2) => {
    var b;
    const g = t.value === h.value;
    g && (w = _2);
    function S3() {
      a.current = false, d2(_2);
    }
    return d("div", {
      "data-selected": g,
      className: _e(`${H}-column-item`, {
        [`${H}-column-item-active`]: g
      }),
      onClick: S3,
      "aria-hidden": !g,
      "aria-label": g ? "active" : "",
      children: d("div", {
        className: `${H}-column-item-label`,
        children: i(h)
      })
    }, (b = h.key) !== null && b !== void 0 ? b : h.value);
  })), v2());
}, (t, e) => !(t.index !== e.index || t.value !== e.value || t.onSelect !== e.onSelect || t.renderLabel !== e.renderLabel || t.mouseWheel !== e.mouseWheel || !v(t.column, e.column)));
ps.displayName = "Wheel";
function ai(t) {
  let e = null;
  return () => (e === null && (e = t()), e);
}
function ms(t, e) {
  const n = ai(() => (typeof t == "function" ? t(e) : t).map((o) => o.map((a) => typeof a == "string" ? {
    label: a,
    value: a
  } : a))), i = ai(() => e.map((r, o) => {
    var a;
    const c = n()[o];
    return c && (a = c.find((l) => l.value === r)) !== null && a !== void 0 ? a : null;
  }));
  return {
    get columns() {
      return n();
    },
    get items() {
      return i();
    }
  };
}
function gs(t, e) {
  return (0, import_react.useMemo)(() => ms(t, e), [t, e]);
}
var vs = (t) => t.label;
var Ht = { exports: {} };
var It = {};
var ui;
function Qa() {
  return ui || (ui = 1, function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = import_react.default, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(b) {
      {
        for (var g = arguments.length, S3 = new Array(g > 1 ? g - 1 : 0), x2 = 1; x2 < g; x2++)
          S3[x2 - 1] = arguments[x2];
        i("error", b, S3);
      }
    }
    function i(b, g, S3) {
      {
        var x2 = e.ReactDebugCurrentFrame, k = x2.getStackAddendum();
        k !== "" && (g += "%s", S3 = S3.concat([k]));
        var P2 = S3.map(function(I) {
          return String(I);
        });
        P2.unshift("Warning: " + g), Function.prototype.apply.call(console[b], console, P2);
      }
    }
    function s(b, g) {
      return b === g && (b !== 0 || 1 / b === 1 / g) || b !== b && g !== g;
    }
    var r = typeof Object.is == "function" ? Object.is : s, o = t.useState, a = t.useEffect, c = t.useLayoutEffect, l = t.useDebugValue, u = false, d2 = false;
    function f(b, g, S3) {
      u || t.startTransition !== void 0 && (u = true, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var x2 = g();
      if (!d2) {
        var k = g();
        r(x2, k) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d2 = true);
      }
      var P2 = o({
        inst: {
          value: x2,
          getSnapshot: g
        }
      }), I = P2[0].inst, R2 = P2[1];
      return c(function() {
        I.value = x2, I.getSnapshot = g, m(I) && R2({
          inst: I
        });
      }, [b, x2, g]), a(function() {
        m(I) && R2({
          inst: I
        });
        var X = function() {
          m(I) && R2({
            inst: I
          });
        };
        return b(X);
      }, [b]), l(x2), x2;
    }
    function m(b) {
      var g = b.getSnapshot, S3 = b.value;
      try {
        var x2 = g();
        return !r(S3, x2);
      } catch {
        return true;
      }
    }
    function y(b, g, S3) {
      return g();
    }
    var w = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", v2 = !w, h = v2 ? y : f, _2 = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : h;
    It.useSyncExternalStore = _2, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), It;
}
false ? Ht.exports = Ha() : Ht.exports = Qa();
var Ga = Ht.exports;
var Ya = false;
var li = /* @__PURE__ */ new Set();
function fi() {
  return Ya;
}
function Xa(t) {
  return li.add(t), () => {
    li.delete(t);
  };
}
function Za() {
  return Ga.useSyncExternalStore(Xa, fi, fi);
}
var At = "adm-spin-loading";
var Ja = {
  default: "var(--adm-color-weak)",
  primary: "var(--adm-color-primary)",
  white: "var(--adm-color-white)"
};
var ec = {
  color: "default"
};
var tc = 15 * 3.14159265358979 * 2;
var nc = (0, import_react.memo)((t) => {
  var e;
  const n = D(ec, t), i = Za(), {
    percent: s
  } = gt({
    cancel: i,
    loop: {
      reverse: true
    },
    from: {
      percent: 80
    },
    to: {
      percent: 30
    },
    config: {
      duration: 1200
    }
  });
  return E(n, import_react.default.createElement(je.div, {
    className: At,
    style: {
      "--color": (e = Ja[n.color]) !== null && e !== void 0 ? e : n.color,
      "--percent": s
    }
  }, import_react.default.createElement("svg", {
    className: `${At}-svg`,
    viewBox: "0 0 32 32"
  }, import_react.default.createElement(je.circle, {
    className: `${At}-fill`,
    fill: "transparent",
    strokeWidth: "2",
    strokeDasharray: tc,
    strokeDashoffset: s,
    strokeLinecap: "square",
    r: 15,
    cx: 16,
    cy: 16
  }))));
});
var he = "adm-picker-view";
var ic = {
  defaultValue: [],
  renderLabel: vs,
  mouseWheel: false,
  loadingContent: d("div", {
    className: `${he}-loading-content`,
    children: d(nc, {})
  })
};
var ys = (0, import_react.memo)((t) => {
  const e = D(ic, t), [n, i] = (0, import_react.useState)(e.value === void 0 ? e.defaultValue : e.value);
  (0, import_react.useEffect)(() => {
    e.value !== void 0 && e.value !== n && i(e.value);
  }, [e.value]), (0, import_react.useEffect)(() => {
    if (e.value === n)
      return;
    const a = window.setTimeout(() => {
      e.value !== void 0 && e.value !== n && i(e.value);
    }, 1e3);
    return () => {
      window.clearTimeout(a);
    };
  }, [e.value, n]);
  const s = gs(e.columns, n), r = s.columns;
  Js(() => {
    var a;
    e.value !== n && ((a = e.onChange) === null || a === void 0 || a.call(e, n, s));
  }, [n], {
    wait: 0,
    leading: false,
    trailing: true
  });
  const o = (0, import_react.useCallback)((a, c) => {
    i((l) => {
      const u = [...l];
      return u[c] = a, u;
    });
  }, []);
  return E(e, d("div", {
    className: `${he}`,
    children: e.loading ? e.loadingContent : N2(p1, {
      children: [r.map((a, c) => d(ps, {
        index: c,
        column: a,
        value: n[c],
        onSelect: o,
        renderLabel: e.renderLabel,
        mouseWheel: e.mouseWheel
      }, c)), N2("div", {
        className: `${he}-mask`,
        children: [d("div", {
          className: `${he}-mask-top`
        }), d("div", {
          className: `${he}-mask-middle`
        }), d("div", {
          className: `${he}-mask-bottom`
        })]
      })]
    })
  }));
});
ys.displayName = "PickerView";
var ne = "adm-picker";
var sc = {
  defaultValue: [],
  closeOnMaskClick: true,
  renderLabel: vs,
  destroyOnClose: false,
  forceRender: false
};
var mn = (0, import_react.memo)((0, import_react.forwardRef)((t, e) => {
  var n;
  const {
    locale: i
  } = hn(), s = D(sc, {
    confirmText: i.common.confirm,
    cancelText: i.common.cancel
  }, t), [r, o] = z({
    value: s.visible,
    defaultValue: false,
    onChange: (v2) => {
      var h;
      v2 === false && ((h = s.onClose) === null || h === void 0 || h.call(s));
    }
  }), a = {
    toggle: () => {
      o((v2) => !v2);
    },
    open: () => {
      o(true);
    },
    close: () => {
      o(false);
    }
  };
  (0, import_react.useImperativeHandle)(e, () => a);
  const [c, l] = z(Object.assign(Object.assign({}, s), {
    onChange: (v2) => {
      var h;
      const _2 = ms(s.columns, v2);
      (h = s.onConfirm) === null || h === void 0 || h.call(s, v2, _2);
    }
  })), u = gs(s.columns, c), [d2, f] = (0, import_react.useState)(c);
  (0, import_react.useEffect)(() => {
    d2 !== c && f(c);
  }, [r]), (0, import_react.useEffect)(() => {
    r || f(c);
  }, [c]);
  const m = _((v2, h) => {
    var _2;
    f(v2), r && ((_2 = s.onSelect) === null || _2 === void 0 || _2.call(s, v2, h));
  }), y = E(s, N2("div", {
    className: ne,
    children: [N2("div", {
      className: `${ne}-header`,
      children: [d("a", {
        role: "button",
        className: `${ne}-header-button`,
        onClick: () => {
          var v2;
          (v2 = s.onCancel) === null || v2 === void 0 || v2.call(s), o(false);
        },
        children: s.cancelText
      }), d("div", {
        className: `${ne}-header-title`,
        children: s.title
      }), d("a", {
        role: "button",
        className: _e(`${ne}-header-button`, s.loading && `${ne}-header-button-disabled`),
        onClick: () => {
          s.loading || (l(d2, true), o(false));
        },
        "aria-disabled": s.loading,
        children: s.confirmText
      })]
    }), d("div", {
      className: `${ne}-body`,
      children: d(ys, {
        loading: s.loading,
        loadingContent: s.loadingContent,
        columns: s.columns,
        renderLabel: s.renderLabel,
        value: d2,
        mouseWheel: s.mouseWheel,
        onChange: m
      })
    })]
  })), w = N2(za, {
    style: s.popupStyle,
    className: _e(`${ne}-popup`, s.popupClassName),
    visible: r,
    position: "bottom",
    onMaskClick: () => {
      var v2;
      s.closeOnMaskClick && ((v2 = s.onCancel) === null || v2 === void 0 || v2.call(s), o(false));
    },
    getContainer: s.getContainer,
    destroyOnClose: s.destroyOnClose,
    afterShow: s.afterShow,
    afterClose: s.afterClose,
    onClick: s.onClick,
    forceRender: s.forceRender,
    stopPropagation: s.stopPropagation,
    children: [y, d($, {
      position: "bottom"
    })]
  });
  return N2(p1, {
    children: [w, (n = s.children) === null || n === void 0 ? void 0 : n.call(s, u.items, a)]
  });
}));
mn.displayName = "Picker";
var rt = Object.assign({}, Ps);
var {
  version: rc,
  render: oc,
  unmountComponentAtNode: ac
} = rt;
var yt;
try {
  Number((rc || "").split(".")[0]) >= 18 && rt.createRoot && (yt = rt.createRoot);
} catch {
}
function di(t) {
  const {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: e
  } = rt;
  e && typeof e == "object" && (e.usingClientEntryPoint = t);
}
var ot = "__antd_mobile_root__";
function cc(t, e) {
  oc(t, e);
}
function uc(t, e) {
  di(true);
  const n = e[ot] || yt(e);
  di(false), n.render(t), e[ot] = n;
}
function lc(t, e) {
  if (yt) {
    uc(t, e);
    return;
  }
  cc(t, e);
}
function fc(t) {
  return ac(t);
}
function dc(t) {
  return P(this, void 0, void 0, function* () {
    return Promise.resolve().then(() => {
      var e;
      (e = t[ot]) === null || e === void 0 || e.unmount(), delete t[ot];
    });
  });
}
function hc(t) {
  return yt ? dc(t) : fc(t);
}
function pc(t) {
  const e = document.createElement("div");
  document.body.appendChild(e);
  function n() {
    hc(e) && e.parentNode && e.parentNode.removeChild(e);
  }
  return lc(t, e), n;
}
function mc(t) {
  return new Promise((e) => {
    const i = pc(d(() => {
      const [s, r] = (0, import_react.useState)(false);
      return (0, import_react.useEffect)(() => {
        r(true);
      }, []), d(mn, {
        ...Object.assign({}, t, {
          visible: s,
          onConfirm: (o, a) => {
            var c;
            (c = t.onConfirm) === null || c === void 0 || c.call(t, o, a), e(o);
          },
          onClose: () => {
            var o;
            (o = t.onClose) === null || o === void 0 || o.call(t), r(false), e(null);
          },
          afterClose: () => {
            var o;
            (o = t.afterClose) === null || o === void 0 || o.call(t), i();
          }
        })
      });
    }, {}));
  });
}
var gc = R(mn, {
  prompt: mc
});
var Oc = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: gc
}, Symbol.toStringTag, { value: "Module" }));

export {
  hn,
  zt,
  pc,
  gc,
  Oc
};
/*! Bundled license information:

lowcoder-sdk/dist/2242e3df.js:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lowcoder-sdk/dist/2242e3df.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-ZH6IUIJY.js.map
