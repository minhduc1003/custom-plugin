import {
  y
} from "./chunk-5UXNBVZK.js";
import {
  $2,
  A6,
  Ao,
  B6n,
  Be,
  Bw,
  C0,
  Clr,
  Ct,
  Da,
  Eg,
  Elr,
  Eo,
  Ff,
  GJ,
  GP1,
  Gt,
  Iee,
  It,
  J1,
  LA,
  Mlr,
  N,
  N8,
  PDe,
  Pa,
  Q2,
  RY,
  Slr,
  St,
  T0,
  T2,
  TS,
  Tn,
  UC,
  Ux,
  V6,
  Ye,
  Yh,
  ZXe,
  _,
  _E,
  _e,
  _f,
  a5,
  af2,
  am,
  b9,
  bg,
  blr,
  c1,
  cf2,
  ci,
  d,
  de,
  g4,
  glr,
  gs,
  h1,
  hlr,
  i3,
  i4,
  i8n,
  iB1,
  if2,
  k0,
  k8,
  kM,
  klr,
  lH,
  lir,
  mlr,
  nSe,
  nf2,
  o2,
  oF1,
  pee,
  plr,
  qXn,
  qbe,
  qr,
  rF1,
  t5,
  tu,
  ua,
  ulr,
  us,
  va,
  wlr,
  xlr,
  yK,
  ylr,
  zlr
} from "./chunk-2ZELARZW.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "node_modules/prettier/standalone.js"(exports, module) {
    (function(t) {
      function e() {
        var o = t();
        return o.default || o;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f.prettier = e();
      }
    })(function() {
      "use strict";
      var yu2 = Object.create;
      var He2 = Object.defineProperty;
      var Au = Object.getOwnPropertyDescriptor;
      var Bu2 = Object.getOwnPropertyNames;
      var wu2 = Object.getPrototypeOf, _u2 = Object.prototype.hasOwnProperty;
      var or2 = (e) => {
        throw TypeError(e);
      };
      var xu2 = (e, t) => () => (e && (t = e(e = 0)), t);
      var At = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), We = (e, t) => {
        for (var r in t) He2(e, r, { get: t[r], enumerable: true });
      }, sr2 = (e, t, r, n) => {
        if (t && typeof t == "object" || typeof t == "function") for (let i of Bu2(t)) !_u2.call(e, i) && i !== r && He2(e, i, { get: () => t[i], enumerable: !(n = Au(t, i)) || n.enumerable });
        return e;
      };
      var Me = (e, t, r) => (r = e != null ? yu2(wu2(e)) : {}, sr2(t || !e || !e.__esModule ? He2(r, "default", { value: e, enumerable: true }) : r, e)), ar2 = (e) => sr2(He2({}, "__esModule", { value: true }), e);
      var vu2 = (e, t, r) => t.has(e) || or2("Cannot " + r);
      var Dr2 = (e, t, r) => t.has(e) ? or2("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      var pe = (e, t, r) => (vu2(e, t, "access private method"), r);
      var ot = At((oa2, sn2) => {
        "use strict";
        var on2 = new Proxy(String, { get: () => on2 });
        sn2.exports = on2;
      });
      var Tn3 = {};
      We(Tn3, { default: () => wi2, shouldHighlight: () => Bi });
      var Bi, wi2, kn2 = xu2(() => {
        Bi = () => false, wi2 = String;
      });
      var Pn2 = At((bD, Xt2) => {
        var g = String, Ln = function() {
          return { isColorSupported: false, reset: g, bold: g, dim: g, italic: g, underline: g, inverse: g, hidden: g, strikethrough: g, black: g, red: g, green: g, yellow: g, blue: g, magenta: g, cyan: g, white: g, gray: g, bgBlack: g, bgRed: g, bgGreen: g, bgYellow: g, bgBlue: g, bgMagenta: g, bgCyan: g, bgWhite: g };
        };
        Xt2.exports = Ln();
        Xt2.exports.createColors = Ln;
      });
      var $n2 = At((Ct2) => {
        "use strict";
        Object.defineProperty(Ct2, "__esModule", { value: true });
        Ct2.codeFrameColumns = Mn2;
        Ct2.default = Si2;
        var In2 = (kn2(), ar2(Tn3)), Hn = _i2(Pn2(), true);
        function Wn2(e) {
          if (typeof WeakMap != "function") return null;
          var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
          return (Wn2 = function(n) {
            return n ? r : t;
          })(e);
        }
        function _i2(e, t) {
          if (!t && e && e.__esModule) return e;
          if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
          var r = Wn2(t);
          if (r && r.has(e)) return r.get(e);
          var n = { __proto__: null }, i = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var u in e) if (u !== "default" && {}.hasOwnProperty.call(e, u)) {
            var o = i ? Object.getOwnPropertyDescriptor(e, u) : null;
            o && (o.get || o.set) ? Object.defineProperty(n, u, o) : n[u] = e[u];
          }
          return n.default = e, r && r.set(e, n), n;
        }
        var xi2 = Hn.default, Rn = (e, t) => (r) => e(t(r)), Zt2;
        function vi2(e) {
          if (e) {
            var t;
            return (t = Zt2) != null || (Zt2 = (0, Hn.createColors)(true)), Zt2;
          }
          return xi2;
        }
        var Yn2 = false;
        function bi2(e) {
          return { gutter: e.gray, marker: Rn(e.red, e.bold), message: Rn(e.red, e.bold) };
        }
        var jn2 = /\r\n|[\n\r\u2028\u2029]/;
        function Oi2(e, t, r) {
          let n = Object.assign({ column: 0, line: -1 }, e.start), i = Object.assign({}, n, e.end), { linesAbove: u = 2, linesBelow: o = 3 } = r || {}, s = n.line, a = n.column, D = i.line, l = i.column, d2 = Math.max(s - (u + 1), 0), f = Math.min(t.length, D + o);
          s === -1 && (d2 = 0), D === -1 && (f = t.length);
          let p = D - s, c = {};
          if (p) for (let F = 0; F <= p; F++) {
            let m = F + s;
            if (!a) c[m] = true;
            else if (F === 0) {
              let E = t[m - 1].length;
              c[m] = [a, E - a + 1];
            } else if (F === p) c[m] = [0, l];
            else {
              let E = t[m - F].length;
              c[m] = [0, E];
            }
          }
          else a === l ? a ? c[s] = [a, 0] : c[s] = true : c[s] = [a, l - a];
          return { start: d2, end: f, markerLines: c };
        }
        function Mn2(e, t, r = {}) {
          let n = (r.highlightCode || r.forceColor) && (0, In2.shouldHighlight)(r), i = vi2(r.forceColor), u = bi2(i), o = (F, m) => n ? F(m) : m, s = e.split(jn2), { start: a, end: D, markerLines: l } = Oi2(t, s, r), d2 = t.start && typeof t.start.column == "number", f = String(D).length, c = (n ? (0, In2.default)(e, r) : e).split(jn2, D).slice(a, D).map((F, m) => {
            let E = a + 1 + m, w = ` ${` ${E}`.slice(-f)} |`, h = l[E], C = !l[E + 1];
            if (h) {
              let k = "";
              if (Array.isArray(h)) {
                let v2 = F.slice(0, Math.max(h[0] - 1, 0)).replace(/[^\t]/g, " "), $ = h[1] || 1;
                k = [`
 `, o(u.gutter, w.replace(/\d/g, " ")), " ", v2, o(u.marker, "^").repeat($)].join(""), C && r.message && (k += " " + o(u.message, r.message));
              }
              return [o(u.marker, ">"), o(u.gutter, w), F.length > 0 ? ` ${F}` : "", k].join("");
            } else return ` ${o(u.gutter, w)}${F.length > 0 ? ` ${F}` : ""}`;
          }).join(`
`);
          return r.message && !d2 && (c = `${" ".repeat(f + 1)}${r.message}
${c}`), n ? i.reset(c) : c;
        }
        function Si2(e, t, r, n = {}) {
          if (!Yn2) {
            Yn2 = true;
            let u = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
            {
              let o = new Error(u);
              o.name = "DeprecationWarning", console.warn(new Error(u));
            }
          }
          return r = Math.max(r, 0), Mn2(e, { start: { column: r, line: t } }, n);
        }
      });
      var po2 = {};
      We(po2, { __debug: () => fo2, check: () => lo2, doc: () => nr2, format: () => gu, formatWithCursor: () => Cu2, getSupportInfo: () => co2, util: () => ir2, version: () => fu });
      var bu2 = (e, t, r, n) => {
        if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
      }, ne = bu2;
      function Z() {
      }
      Z.prototype = { diff: function(t, r) {
        var n, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u = i.callback;
        typeof i == "function" && (u = i, i = {}), this.options = i;
        var o = this;
        function s(h) {
          return u ? (setTimeout(function() {
            u(void 0, h);
          }, 0), true) : h;
        }
        t = this.castInput(t), r = this.castInput(r), t = this.removeEmpty(this.tokenize(t)), r = this.removeEmpty(this.tokenize(r));
        var a = r.length, D = t.length, l = 1, d2 = a + D;
        i.maxEditLength && (d2 = Math.min(d2, i.maxEditLength));
        var f = (n = i.timeout) !== null && n !== void 0 ? n : 1 / 0, p = Date.now() + f, c = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c[0], r, t, 0);
        if (c[0].oldPos + 1 >= D && F + 1 >= a) return s([{ value: this.join(r), count: r.length }]);
        var m = -1 / 0, E = 1 / 0;
        function A() {
          for (var h = Math.max(m, -l); h <= Math.min(E, l); h += 2) {
            var C = void 0, k = c[h - 1], v2 = c[h + 1];
            k && (c[h - 1] = void 0);
            var $ = false;
            if (v2) {
              var ye = v2.oldPos - h;
              $ = v2 && 0 <= ye && ye < a;
            }
            var yt = k && k.oldPos + 1 < D;
            if (!$ && !yt) {
              c[h] = void 0;
              continue;
            }
            if (!yt || $ && k.oldPos + 1 < v2.oldPos ? C = o.addToPath(v2, true, void 0, 0) : C = o.addToPath(k, void 0, true, 1), F = o.extractCommon(C, r, t, h), C.oldPos + 1 >= D && F + 1 >= a) return s(Ou(o, C.lastComponent, r, t, o.useLongestToken));
            c[h] = C, C.oldPos + 1 >= D && (E = Math.min(E, h - 1)), F + 1 >= a && (m = Math.max(m, h + 1));
          }
          l++;
        }
        if (u) (function h() {
          setTimeout(function() {
            if (l > d2 || Date.now() > p) return u();
            A() || h();
          }, 0);
        })();
        else for (; l <= d2 && Date.now() <= p; ) {
          var w = A();
          if (w) return w;
        }
      }, addToPath: function(t, r, n, i) {
        var u = t.lastComponent;
        return u && u.added === r && u.removed === n ? { oldPos: t.oldPos + i, lastComponent: { count: u.count + 1, added: r, removed: n, previousComponent: u.previousComponent } } : { oldPos: t.oldPos + i, lastComponent: { count: 1, added: r, removed: n, previousComponent: u } };
      }, extractCommon: function(t, r, n, i) {
        for (var u = r.length, o = n.length, s = t.oldPos, a = s - i, D = 0; a + 1 < u && s + 1 < o && this.equals(r[a + 1], n[s + 1]); ) a++, s++, D++;
        return D && (t.lastComponent = { count: D, previousComponent: t.lastComponent }), t.oldPos = s, a;
      }, equals: function(t, r) {
        return this.options.comparator ? this.options.comparator(t, r) : t === r || this.options.ignoreCase && t.toLowerCase() === r.toLowerCase();
      }, removeEmpty: function(t) {
        for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n]);
        return r;
      }, castInput: function(t) {
        return t;
      }, tokenize: function(t) {
        return t.split("");
      }, join: function(t) {
        return t.join("");
      } };
      function Ou(e, t, r, n, i) {
        for (var u = [], o; t; ) u.push(t), o = t.previousComponent, delete t.previousComponent, t = o;
        u.reverse();
        for (var s = 0, a = u.length, D = 0, l = 0; s < a; s++) {
          var d2 = u[s];
          if (d2.removed) {
            if (d2.value = e.join(n.slice(l, l + d2.count)), l += d2.count, s && u[s - 1].added) {
              var p = u[s - 1];
              u[s - 1] = u[s], u[s] = p;
            }
          } else {
            if (!d2.added && i) {
              var f = r.slice(D, D + d2.count);
              f = f.map(function(F, m) {
                var E = n[l + m];
                return E.length > F.length ? E : F;
              }), d2.value = e.join(f);
            } else d2.value = e.join(r.slice(D, D + d2.count));
            D += d2.count, d2.added || (l += d2.count);
          }
        }
        var c = u[a - 1];
        return a > 1 && typeof c.value == "string" && (c.added || c.removed) && e.equals("", c.value) && (u[a - 2].value += c.value, u.pop()), u;
      }
      var ho2 = new Z();
      var lr = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, cr2 = /\S/, fr2 = new Z();
      fr2.equals = function(e, t) {
        return this.options.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e === t || this.options.ignoreWhitespace && !cr2.test(e) && !cr2.test(t);
      };
      fr2.tokenize = function(e) {
        for (var t = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), r = 0; r < t.length - 1; r++) !t[r + 1] && t[r + 2] && lr.test(t[r]) && lr.test(t[r + 2]) && (t[r] += t[r + 2], t.splice(r + 1, 2), r--);
        return t;
      };
      var pr2 = new Z();
      pr2.tokenize = function(e) {
        this.options.stripTrailingCr && (e = e.replace(/\r\n/g, `
`));
        var t = [], r = e.split(/(\n|\r\n)/);
        r[r.length - 1] || r.pop();
        for (var n = 0; n < r.length; n++) {
          var i = r[n];
          n % 2 && !this.options.newlineIsToken ? t[t.length - 1] += i : (this.options.ignoreWhitespace && (i = i.trim()), t.push(i));
        }
        return t;
      };
      var Su = new Z();
      Su.tokenize = function(e) {
        return e.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      var Nu2 = new Z();
      Nu2.tokenize = function(e) {
        return e.split(/([{}:;,]|\s+)/);
      };
      function $e(e) {
        "@babel/helpers - typeof";
        return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? $e = function(t) {
          return typeof t;
        } : $e = function(t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        }, $e(e);
      }
      var Tu = Object.prototype.toString, Ae = new Z();
      Ae.useLongestToken = true;
      Ae.tokenize = pr2.tokenize;
      Ae.castInput = function(e) {
        var t = this.options, r = t.undefinedReplacement, n = t.stringifyReplacer, i = n === void 0 ? function(u, o) {
          return typeof o > "u" ? r : o;
        } : n;
        return typeof e == "string" ? e : JSON.stringify(Bt2(e, null, null, i), i, "  ");
      };
      Ae.equals = function(e, t) {
        return Z.prototype.equals.call(Ae, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"));
      };
      function Bt2(e, t, r, n, i) {
        t = t || [], r = r || [], n && (e = n(i, e));
        var u;
        for (u = 0; u < t.length; u += 1) if (t[u] === e) return r[u];
        var o;
        if (Tu.call(e) === "[object Array]") {
          for (t.push(e), o = new Array(e.length), r.push(o), u = 0; u < e.length; u += 1) o[u] = Bt2(e[u], t, r, n, i);
          return t.pop(), r.pop(), o;
        }
        if (e && e.toJSON && (e = e.toJSON()), $e(e) === "object" && e !== null) {
          t.push(e), o = {}, r.push(o);
          var s = [], a;
          for (a in e) e.hasOwnProperty(a) && s.push(a);
          for (s.sort(), u = 0; u < s.length; u += 1) a = s[u], o[a] = Bt2(e[a], t, r, n, a);
          t.pop(), r.pop();
        } else o = e;
        return o;
      }
      var Ve2 = new Z();
      Ve2.tokenize = function(e) {
        return e.slice();
      };
      Ve2.join = Ve2.removeEmpty = function(e) {
        return e;
      };
      function dr(e, t, r) {
        return Ve2.diff(e, t, r);
      }
      function Fr2(e) {
        let t = e.indexOf("\r");
        return t >= 0 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
      }
      function Be3(e) {
        switch (e) {
          case "cr":
            return "\r";
          case "crlf":
            return `\r
`;
          default:
            return `
`;
        }
      }
      function wt(e, t) {
        let r;
        switch (t) {
          case `
`:
            r = /\n/gu;
            break;
          case "\r":
            r = /\r/gu;
            break;
          case `\r
`:
            r = /\r\n/gu;
            break;
          default:
            throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
        }
        let n = e.match(r);
        return n ? n.length : 0;
      }
      function mr2(e) {
        return ne(false, e, /\r\n?/gu, `
`);
      }
      var U = "string", W = "array", z = "cursor", L = "indent", P = "align", I = "trim", _2 = "group", S = "fill", x = "if-break", R = "indent-if-break", Y = "line-suffix", j = "line-suffix-boundary", B = "line", N2 = "label", b = "break-parent", Ue = /* @__PURE__ */ new Set([z, L, P, I, _2, S, x, R, Y, j, B, N2, b]);
      function ku2(e) {
        if (typeof e == "string") return U;
        if (Array.isArray(e)) return W;
        if (!e) return;
        let { type: t } = e;
        if (Ue.has(t)) return t;
      }
      var G = ku2;
      var Lu2 = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
      function Pu2(e) {
        let t = e === null ? "null" : typeof e;
        if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
        if (G(e)) throw new Error("doc is valid.");
        let r = Object.prototype.toString.call(e);
        if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
        let n = Lu2([...Ue].map((i) => `'${i}'`));
        return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
      }
      var _t2 = class extends Error {
        constructor(t) {
          super(Pu2(t));
          __publicField(this, "name", "InvalidDocError");
          this.doc = t;
        }
      }, Q3 = _t2;
      var Er2 = {};
      function Iu2(e, t, r, n) {
        let i = [e];
        for (; i.length > 0; ) {
          let u = i.pop();
          if (u === Er2) {
            r(i.pop());
            continue;
          }
          r && i.push(u, Er2);
          let o = G(u);
          if (!o) throw new Q3(u);
          if ((t == null ? void 0 : t(u)) !== false) switch (o) {
            case W:
            case S: {
              let s = o === W ? u : u.parts;
              for (let a = s.length, D = a - 1; D >= 0; --D) i.push(s[D]);
              break;
            }
            case x:
              i.push(u.flatContents, u.breakContents);
              break;
            case _2:
              if (n && u.expandedStates) for (let s = u.expandedStates.length, a = s - 1; a >= 0; --a) i.push(u.expandedStates[a]);
              else i.push(u.contents);
              break;
            case P:
            case L:
            case R:
            case N2:
            case Y:
              i.push(u.contents);
              break;
            case U:
            case z:
            case I:
            case j:
            case B:
            case b:
              break;
            default:
              throw new Q3(u);
          }
        }
      }
      var we = Iu2;
      var hr = () => {
      }, K = hr, ze2 = hr;
      function De(e) {
        return K(e), { type: L, contents: e };
      }
      function ae(e, t) {
        return K(t), { type: P, contents: t, n: e };
      }
      function xt(e, t = {}) {
        return K(e), ze2(t.expandedStates, true), { type: _2, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
      }
      function Cr2(e) {
        return ae(Number.NEGATIVE_INFINITY, e);
      }
      function gr2(e) {
        return ae({ type: "root" }, e);
      }
      function yr2(e) {
        return ae(-1, e);
      }
      function Ar2(e, t) {
        return xt(e[0], { ...t, expandedStates: e });
      }
      function Ge(e) {
        return ze2(e), { type: S, parts: e };
      }
      function Br2(e, t = "", r = {}) {
        return K(e), t !== "" && K(t), { type: x, breakContents: e, flatContents: t, groupId: r.groupId };
      }
      function wr2(e, t) {
        return K(e), { type: R, contents: e, groupId: t.groupId, negate: t.negate };
      }
      function _e3(e) {
        return K(e), { type: Y, contents: e };
      }
      var _r2 = { type: j }, de3 = { type: b }, xr = { type: I }, xe = { type: B, hard: true }, vt = { type: B, hard: true, literal: true }, Ke2 = { type: B }, vr2 = { type: B, soft: true }, q = [xe, de3], qe = [vt, de3], ve2 = { type: z };
      function be2(e, t) {
        K(e), ze2(t);
        let r = [];
        for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
        return r;
      }
      function Je(e, t, r) {
        K(e);
        let n = e;
        if (t > 0) {
          for (let i = 0; i < Math.floor(t / r); ++i) n = De(n);
          n = ae(t % r, n), n = ae(Number.NEGATIVE_INFINITY, n);
        }
        return n;
      }
      function br2(e, t) {
        return K(t), e ? { type: N2, label: e, contents: t } : t;
      }
      function ee(e) {
        var t;
        if (!e) return "";
        if (Array.isArray(e)) {
          let r = [];
          for (let n of e) if (Array.isArray(n)) r.push(...ee(n));
          else {
            let i = ee(n);
            i !== "" && r.push(i);
          }
          return r;
        }
        return e.type === x ? { ...e, breakContents: ee(e.breakContents), flatContents: ee(e.flatContents) } : e.type === _2 ? { ...e, contents: ee(e.contents), expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(ee) } : e.type === S ? { type: "fill", parts: e.parts.map(ee) } : e.contents ? { ...e, contents: ee(e.contents) } : e;
      }
      function Or2(e) {
        let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
        return n(ee(e));
        function n(u, o, s) {
          var a, D;
          if (typeof u == "string") return JSON.stringify(u);
          if (Array.isArray(u)) {
            let l = u.map(n).filter(Boolean);
            return l.length === 1 ? l[0] : `[${l.join(", ")}]`;
          }
          if (u.type === B) {
            let l = ((a = s == null ? void 0 : s[o + 1]) == null ? void 0 : a.type) === b;
            return u.literal ? l ? "literalline" : "literallineWithoutBreakParent" : u.hard ? l ? "hardline" : "hardlineWithoutBreakParent" : u.soft ? "softline" : "line";
          }
          if (u.type === b) return ((D = s == null ? void 0 : s[o - 1]) == null ? void 0 : D.type) === B && s[o - 1].hard ? void 0 : "breakParent";
          if (u.type === I) return "trim";
          if (u.type === L) return "indent(" + n(u.contents) + ")";
          if (u.type === P) return u.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(u.contents) + ")" : u.n < 0 ? "dedent(" + n(u.contents) + ")" : u.n.type === "root" ? "markAsRoot(" + n(u.contents) + ")" : "align(" + JSON.stringify(u.n) + ", " + n(u.contents) + ")";
          if (u.type === x) return "ifBreak(" + n(u.breakContents) + (u.flatContents ? ", " + n(u.flatContents) : "") + (u.groupId ? (u.flatContents ? "" : ', ""') + `, { groupId: ${i(u.groupId)} }` : "") + ")";
          if (u.type === R) {
            let l = [];
            u.negate && l.push("negate: true"), u.groupId && l.push(`groupId: ${i(u.groupId)}`);
            let d2 = l.length > 0 ? `, { ${l.join(", ")} }` : "";
            return `indentIfBreak(${n(u.contents)}${d2})`;
          }
          if (u.type === _2) {
            let l = [];
            u.break && u.break !== "propagated" && l.push("shouldBreak: true"), u.id && l.push(`id: ${i(u.id)}`);
            let d2 = l.length > 0 ? `, { ${l.join(", ")} }` : "";
            return u.expandedStates ? `conditionalGroup([${u.expandedStates.map((f) => n(f)).join(",")}]${d2})` : `group(${n(u.contents)}${d2})`;
          }
          if (u.type === S) return `fill([${u.parts.map((l) => n(l)).join(", ")}])`;
          if (u.type === Y) return "lineSuffix(" + n(u.contents) + ")";
          if (u.type === j) return "lineSuffixBoundary";
          if (u.type === N2) return `label(${JSON.stringify(u.label)}, ${n(u.contents)})`;
          throw new Error("Unknown doc type " + u.type);
        }
        function i(u) {
          if (typeof u != "symbol") return JSON.stringify(String(u));
          if (u in t) return t[u];
          let o = u.description || "symbol";
          for (let s = 0; ; s++) {
            let a = o + (s > 0 ? ` #${s}` : "");
            if (!r.has(a)) return r.add(a), t[u] = `Symbol.for(${JSON.stringify(a)})`;
          }
        }
      }
      var Ru = (e, t, r) => {
        if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
      }, y2 = Ru;
      var Sr2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      function Nr2(e) {
        return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
      }
      function Tr2(e) {
        return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9800 && e <= 9811 || e === 9855 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12771 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 19903 || e >= 19968 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101632 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129672 || e >= 129680 && e <= 129725 || e >= 129727 && e <= 129733 || e >= 129742 && e <= 129755 || e >= 129760 && e <= 129768 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
      }
      var kr2 = (e) => !(Nr2(e) || Tr2(e));
      var Yu2 = /[^\x20-\x7F]/u;
      function ju2(e) {
        if (!e) return 0;
        if (!Yu2.test(e)) return e.length;
        e = e.replace(Sr2(), "  ");
        let t = 0;
        for (let r of e) {
          let n = r.codePointAt(0);
          n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += kr2(n) ? 1 : 2);
        }
        return t;
      }
      var Oe2 = ju2;
      function Ne2(e, t) {
        if (typeof e == "string") return t(e);
        let r = /* @__PURE__ */ new Map();
        return n(e);
        function n(u) {
          if (r.has(u)) return r.get(u);
          let o = i(u);
          return r.set(u, o), o;
        }
        function i(u) {
          switch (G(u)) {
            case W:
              return t(u.map(n));
            case S:
              return t({ ...u, parts: u.parts.map(n) });
            case x:
              return t({ ...u, breakContents: n(u.breakContents), flatContents: n(u.flatContents) });
            case _2: {
              let { expandedStates: o, contents: s } = u;
              return o ? (o = o.map(n), s = o[0]) : s = n(s), t({ ...u, contents: s, expandedStates: o });
            }
            case P:
            case L:
            case R:
            case N2:
            case Y:
              return t({ ...u, contents: n(u.contents) });
            case U:
            case z:
            case I:
            case j:
            case B:
            case b:
              return t(u);
            default:
              throw new Q3(u);
          }
        }
      }
      function Xe2(e, t, r) {
        let n = r, i = false;
        function u(o) {
          if (i) return false;
          let s = t(o);
          s !== void 0 && (i = true, n = s);
        }
        return we(e, u), n;
      }
      function Hu2(e) {
        if (e.type === _2 && e.break || e.type === B && e.hard || e.type === b) return true;
      }
      function Ir2(e) {
        return Xe2(e, Hu2, false);
      }
      function Lr2(e) {
        if (e.length > 0) {
          let t = y2(false, e, -1);
          !t.expandedStates && !t.break && (t.break = "propagated");
        }
        return null;
      }
      function Rr2(e) {
        let t = /* @__PURE__ */ new Set(), r = [];
        function n(u) {
          if (u.type === b && Lr2(r), u.type === _2) {
            if (r.push(u), t.has(u)) return false;
            t.add(u);
          }
        }
        function i(u) {
          u.type === _2 && r.pop().break && Lr2(r);
        }
        we(e, n, i, true);
      }
      function Wu2(e) {
        return e.type === B && !e.hard ? e.soft ? "" : " " : e.type === x ? e.flatContents : e;
      }
      function Yr2(e) {
        return Ne2(e, Wu2);
      }
      function Pr2(e) {
        for (e = [...e]; e.length >= 2 && y2(false, e, -2).type === B && y2(false, e, -1).type === b; ) e.length -= 2;
        if (e.length > 0) {
          let t = Se(y2(false, e, -1));
          e[e.length - 1] = t;
        }
        return e;
      }
      function Se(e) {
        switch (G(e)) {
          case L:
          case R:
          case _2:
          case Y:
          case N2: {
            let t = Se(e.contents);
            return { ...e, contents: t };
          }
          case x:
            return { ...e, breakContents: Se(e.breakContents), flatContents: Se(e.flatContents) };
          case S:
            return { ...e, parts: Pr2(e.parts) };
          case W:
            return Pr2(e);
          case U:
            return e.replace(/[\n\r]*$/u, "");
          case P:
          case z:
          case I:
          case j:
          case B:
          case b:
            break;
          default:
            throw new Q3(e);
        }
        return e;
      }
      function Ze2(e) {
        return Se($u2(e));
      }
      function Mu2(e) {
        switch (G(e)) {
          case S:
            if (e.parts.every((t) => t === "")) return "";
            break;
          case _2:
            if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
            if (e.contents.type === _2 && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
            break;
          case P:
          case L:
          case R:
          case Y:
            if (!e.contents) return "";
            break;
          case x:
            if (!e.flatContents && !e.breakContents) return "";
            break;
          case W: {
            let t = [];
            for (let r of e) {
              if (!r) continue;
              let [n, ...i] = Array.isArray(r) ? r : [r];
              typeof n == "string" && typeof y2(false, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...i);
            }
            return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
          }
          case U:
          case z:
          case I:
          case j:
          case B:
          case N2:
          case b:
            break;
          default:
            throw new Q3(e);
        }
        return e;
      }
      function $u2(e) {
        return Ne2(e, (t) => Mu2(t));
      }
      function jr2(e, t = qe) {
        return Ne2(e, (r) => typeof r == "string" ? be2(t, r.split(`
`)) : r);
      }
      function Vu2(e) {
        if (e.type === B) return true;
      }
      function Hr2(e) {
        return Xe2(e, Vu2, false);
      }
      function Qe2(e, t) {
        return e.type === N2 ? { ...e, contents: t(e.contents) } : t(e);
      }
      var H = Symbol("MODE_BREAK"), J = Symbol("MODE_FLAT"), Te2 = Symbol("cursor");
      function Wr2() {
        return { value: "", length: 0, queue: [] };
      }
      function Uu2(e, t) {
        return bt2(e, { type: "indent" }, t);
      }
      function zu2(e, t, r) {
        return t === Number.NEGATIVE_INFINITY ? e.root || Wr2() : t < 0 ? bt2(e, { type: "dedent" }, r) : t ? t.type === "root" ? { ...e, root: e } : bt2(e, { type: typeof t == "string" ? "stringAlign" : "numberAlign", n: t }, r) : e;
      }
      function bt2(e, t, r) {
        let n = t.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t], i = "", u = 0, o = 0, s = 0;
        for (let c of n) switch (c.type) {
          case "indent":
            l(), r.useTabs ? a(1) : D(r.tabWidth);
            break;
          case "stringAlign":
            l(), i += c.n, u += c.n.length;
            break;
          case "numberAlign":
            o += 1, s += c.n;
            break;
          default:
            throw new Error(`Unexpected type '${c.type}'`);
        }
        return f(), { ...e, value: i, length: u, queue: n };
        function a(c) {
          i += "	".repeat(c), u += r.tabWidth * c;
        }
        function D(c) {
          i += " ".repeat(c), u += c;
        }
        function l() {
          r.useTabs ? d2() : f();
        }
        function d2() {
          o > 0 && a(o), p();
        }
        function f() {
          s > 0 && D(s), p();
        }
        function p() {
          o = 0, s = 0;
        }
      }
      function Ot2(e) {
        let t = 0, r = 0, n = e.length;
        e: for (; n--; ) {
          let i = e[n];
          if (i === Te2) {
            r++;
            continue;
          }
          for (let u = i.length - 1; u >= 0; u--) {
            let o = i[u];
            if (o === " " || o === "	") t++;
            else {
              e[n] = i.slice(0, u + 1);
              break e;
            }
          }
        }
        if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Te2);
        return t;
      }
      function et(e, t, r, n, i, u) {
        if (r === Number.POSITIVE_INFINITY) return true;
        let o = t.length, s = [e], a = [];
        for (; r >= 0; ) {
          if (s.length === 0) {
            if (o === 0) return true;
            s.push(t[--o]);
            continue;
          }
          let { mode: D, doc: l } = s.pop(), d2 = G(l);
          switch (d2) {
            case U:
              a.push(l), r -= Oe2(l);
              break;
            case W:
            case S: {
              let f = d2 === W ? l : l.parts;
              for (let p = f.length - 1; p >= 0; p--) s.push({ mode: D, doc: f[p] });
              break;
            }
            case L:
            case P:
            case R:
            case N2:
              s.push({ mode: D, doc: l.contents });
              break;
            case I:
              r += Ot2(a);
              break;
            case _2: {
              if (u && l.break) return false;
              let f = l.break ? H : D, p = l.expandedStates && f === H ? y2(false, l.expandedStates, -1) : l.contents;
              s.push({ mode: f, doc: p });
              break;
            }
            case x: {
              let p = (l.groupId ? i[l.groupId] || J : D) === H ? l.breakContents : l.flatContents;
              p && s.push({ mode: D, doc: p });
              break;
            }
            case B:
              if (D === H || l.hard) return true;
              l.soft || (a.push(" "), r--);
              break;
            case Y:
              n = true;
              break;
            case j:
              if (n) return false;
              break;
          }
        }
        return false;
      }
      function Fe2(e, t) {
        let r = {}, n = t.printWidth, i = Be3(t.endOfLine), u = 0, o = [{ ind: Wr2(), mode: H, doc: e }], s = [], a = false, D = [], l = 0;
        for (Rr2(e); o.length > 0; ) {
          let { ind: f, mode: p, doc: c } = o.pop();
          switch (G(c)) {
            case U: {
              let F = i !== `
` ? ne(false, c, `
`, i) : c;
              s.push(F), o.length > 0 && (u += Oe2(F));
              break;
            }
            case W:
              for (let F = c.length - 1; F >= 0; F--) o.push({ ind: f, mode: p, doc: c[F] });
              break;
            case z:
              if (l >= 2) throw new Error("There are too many 'cursor' in doc.");
              s.push(Te2), l++;
              break;
            case L:
              o.push({ ind: Uu2(f, t), mode: p, doc: c.contents });
              break;
            case P:
              o.push({ ind: zu2(f, c.n, t), mode: p, doc: c.contents });
              break;
            case I:
              u -= Ot2(s);
              break;
            case _2:
              switch (p) {
                case J:
                  if (!a) {
                    o.push({ ind: f, mode: c.break ? H : J, doc: c.contents });
                    break;
                  }
                case H: {
                  a = false;
                  let F = { ind: f, mode: J, doc: c.contents }, m = n - u, E = D.length > 0;
                  if (!c.break && et(F, o, m, E, r)) o.push(F);
                  else if (c.expandedStates) {
                    let A = y2(false, c.expandedStates, -1);
                    if (c.break) {
                      o.push({ ind: f, mode: H, doc: A });
                      break;
                    } else for (let w = 1; w < c.expandedStates.length + 1; w++) if (w >= c.expandedStates.length) {
                      o.push({ ind: f, mode: H, doc: A });
                      break;
                    } else {
                      let h = c.expandedStates[w], C = { ind: f, mode: J, doc: h };
                      if (et(C, o, m, E, r)) {
                        o.push(C);
                        break;
                      }
                    }
                  } else o.push({ ind: f, mode: H, doc: c.contents });
                  break;
                }
              }
              c.id && (r[c.id] = y2(false, o, -1).mode);
              break;
            case S: {
              let F = n - u, { parts: m } = c;
              if (m.length === 0) break;
              let [E, A] = m, w = { ind: f, mode: J, doc: E }, h = { ind: f, mode: H, doc: E }, C = et(w, [], F, D.length > 0, r, true);
              if (m.length === 1) {
                C ? o.push(w) : o.push(h);
                break;
              }
              let k = { ind: f, mode: J, doc: A }, v2 = { ind: f, mode: H, doc: A };
              if (m.length === 2) {
                C ? o.push(k, w) : o.push(v2, h);
                break;
              }
              m.splice(0, 2);
              let $ = { ind: f, mode: p, doc: Ge(m) }, ye = m[0];
              et({ ind: f, mode: J, doc: [E, A, ye] }, [], F, D.length > 0, r, true) ? o.push($, k, w) : C ? o.push($, v2, w) : o.push($, v2, h);
              break;
            }
            case x:
            case R: {
              let F = c.groupId ? r[c.groupId] : p;
              if (F === H) {
                let m = c.type === x ? c.breakContents : c.negate ? c.contents : De(c.contents);
                m && o.push({ ind: f, mode: p, doc: m });
              }
              if (F === J) {
                let m = c.type === x ? c.flatContents : c.negate ? De(c.contents) : c.contents;
                m && o.push({ ind: f, mode: p, doc: m });
              }
              break;
            }
            case Y:
              D.push({ ind: f, mode: p, doc: c.contents });
              break;
            case j:
              D.length > 0 && o.push({ ind: f, mode: p, doc: xe });
              break;
            case B:
              switch (p) {
                case J:
                  if (c.hard) a = true;
                  else {
                    c.soft || (s.push(" "), u += 1);
                    break;
                  }
                case H:
                  if (D.length > 0) {
                    o.push({ ind: f, mode: p, doc: c }, ...D.reverse()), D.length = 0;
                    break;
                  }
                  c.literal ? f.root ? (s.push(i, f.root.value), u = f.root.length) : (s.push(i), u = 0) : (u -= Ot2(s), s.push(i + f.value), u = f.length);
                  break;
              }
              break;
            case N2:
              o.push({ ind: f, mode: p, doc: c.contents });
              break;
            case b:
              break;
            default:
              throw new Q3(c);
          }
          o.length === 0 && D.length > 0 && (o.push(...D.reverse()), D.length = 0);
        }
        let d2 = s.indexOf(Te2);
        if (d2 !== -1) {
          let f = s.indexOf(Te2, d2 + 1), p = s.slice(0, d2).join(""), c = s.slice(d2 + 1, f).join(""), F = s.slice(f + 1).join("");
          return { formatted: p + c + F, cursorNodeStart: p.length, cursorNodeText: c };
        }
        return { formatted: s.join("") };
      }
      function Gu2(e, t, r = 0) {
        let n = 0;
        for (let i = r; i < e.length; ++i) e[i] === "	" ? n = n + t - n % t : n++;
        return n;
      }
      var me = Gu2;
      var te, Nt, tt, St2 = class {
        constructor(t) {
          Dr2(this, te);
          this.stack = [t];
        }
        get key() {
          let { stack: t, siblings: r } = this;
          return y2(false, t, r === null ? -2 : -4) ?? null;
        }
        get index() {
          return this.siblings === null ? null : y2(false, this.stack, -2);
        }
        get node() {
          return y2(false, this.stack, -1);
        }
        get parent() {
          return this.getNode(1);
        }
        get grandparent() {
          return this.getNode(2);
        }
        get isInArray() {
          return this.siblings !== null;
        }
        get siblings() {
          let { stack: t } = this, r = y2(false, t, -3);
          return Array.isArray(r) ? r : null;
        }
        get next() {
          let { siblings: t } = this;
          return t === null ? null : t[this.index + 1];
        }
        get previous() {
          let { siblings: t } = this;
          return t === null ? null : t[this.index - 1];
        }
        get isFirst() {
          return this.index === 0;
        }
        get isLast() {
          let { siblings: t, index: r } = this;
          return t !== null && r === t.length - 1;
        }
        get isRoot() {
          return this.stack.length === 1;
        }
        get root() {
          return this.stack[0];
        }
        get ancestors() {
          return [...pe(this, te, tt).call(this)];
        }
        getName() {
          let { stack: t } = this, { length: r } = t;
          return r > 1 ? y2(false, t, -2) : null;
        }
        getValue() {
          return y2(false, this.stack, -1);
        }
        getNode(t = 0) {
          let r = pe(this, te, Nt).call(this, t);
          return r === -1 ? null : this.stack[r];
        }
        getParentNode(t = 0) {
          return this.getNode(t + 1);
        }
        call(t, ...r) {
          let { stack: n } = this, { length: i } = n, u = y2(false, n, -1);
          for (let o of r) u = u[o], n.push(o, u);
          try {
            return t(this);
          } finally {
            n.length = i;
          }
        }
        callParent(t, r = 0) {
          let n = pe(this, te, Nt).call(this, r + 1), i = this.stack.splice(n + 1);
          try {
            return t(this);
          } finally {
            this.stack.push(...i);
          }
        }
        each(t, ...r) {
          let { stack: n } = this, { length: i } = n, u = y2(false, n, -1);
          for (let o of r) u = u[o], n.push(o, u);
          try {
            for (let o = 0; o < u.length; ++o) n.push(o, u[o]), t(this, o, u), n.length -= 2;
          } finally {
            n.length = i;
          }
        }
        map(t, ...r) {
          let n = [];
          return this.each((i, u, o) => {
            n[u] = t(i, u, o);
          }, ...r), n;
        }
        match(...t) {
          let r = this.stack.length - 1, n = null, i = this.stack[r--];
          for (let u of t) {
            if (i === void 0) return false;
            let o = null;
            if (typeof n == "number" && (o = n, n = this.stack[r--], i = this.stack[r--]), u && !u(i, n, o)) return false;
            n = this.stack[r--], i = this.stack[r--];
          }
          return true;
        }
        findAncestor(t) {
          for (let r of pe(this, te, tt).call(this)) if (t(r)) return r;
        }
        hasAncestor(t) {
          for (let r of pe(this, te, tt).call(this)) if (t(r)) return true;
          return false;
        }
      };
      te = /* @__PURE__ */ new WeakSet(), Nt = function(t) {
        let { stack: r } = this;
        for (let n = r.length - 1; n >= 0; n -= 2) if (!Array.isArray(r[n]) && --t < 0) return n;
        return -1;
      }, tt = function* () {
        let { stack: t } = this;
        for (let r = t.length - 3; r >= 0; r -= 2) {
          let n = t[r];
          Array.isArray(n) || (yield n);
        }
      };
      var Mr2 = St2;
      var $r2 = new Proxy(() => {
      }, { get: () => $r2 }), ke2 = $r2;
      function Ku2(e) {
        return e !== null && typeof e == "object";
      }
      var Vr2 = Ku2;
      function* Tt(e, t) {
        let { getVisitorKeys: r, filter: n = () => true } = t, i = (u) => Vr2(u) && n(u);
        for (let u of r(e)) {
          let o = e[u];
          if (Array.isArray(o)) for (let s of o) i(s) && (yield s);
          else i(o) && (yield o);
        }
      }
      function* Ur2(e, t) {
        let r = [e];
        for (let n = 0; n < r.length; n++) {
          let i = r[n];
          for (let u of Tt(i, t)) yield u, r.push(u);
        }
      }
      function Ee(e) {
        return (t, r, n) => {
          let i = !!(n != null && n.backwards);
          if (r === false) return false;
          let { length: u } = t, o = r;
          for (; o >= 0 && o < u; ) {
            let s = t.charAt(o);
            if (e instanceof RegExp) {
              if (!e.test(s)) return o;
            } else if (!e.includes(s)) return o;
            i ? o-- : o++;
          }
          return o === -1 || o === u ? o : false;
        };
      }
      var zr2 = Ee(/\s/u), T3 = Ee(" 	"), rt = Ee(",; 	"), nt2 = Ee(/[^\n\r]/u);
      function qu2(e, t, r) {
        let n = !!(r != null && r.backwards);
        if (t === false) return false;
        let i = e.charAt(t);
        if (n) {
          if (e.charAt(t - 1) === "\r" && i === `
`) return t - 2;
          if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return t - 1;
        } else {
          if (i === "\r" && e.charAt(t + 1) === `
`) return t + 2;
          if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return t + 1;
        }
        return t;
      }
      var M = qu2;
      function Ju2(e, t, r = {}) {
        let n = T3(e, r.backwards ? t - 1 : t, r), i = M(e, n, r);
        return n !== i;
      }
      var V = Ju2;
      function Xu2(e) {
        return Array.isArray(e) && e.length > 0;
      }
      var kt2 = Xu2;
      var Gr2 = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), Zu2 = (e) => Object.keys(e).filter((t) => !Gr2.has(t));
      function Qu2(e) {
        return e ? (t) => e(t, Gr2) : Zu2;
      }
      var X = Qu2;
      function ei2(e) {
        let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
        return r.length > 20 && (r = r.slice(0, 19) + ""), t + (r ? " " + r : "");
      }
      function Lt2(e, t) {
        (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = ei2(e);
      }
      function ue2(e, t) {
        t.leading = true, t.trailing = false, Lt2(e, t);
      }
      function re(e, t, r) {
        t.leading = false, t.trailing = false, r && (t.marker = r), Lt2(e, t);
      }
      function ie(e, t) {
        t.leading = false, t.trailing = true, Lt2(e, t);
      }
      var Pt2 = /* @__PURE__ */ new WeakMap();
      function ut(e, t) {
        if (Pt2.has(e)) return Pt2.get(e);
        let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: i }, locStart: u, locEnd: o } = t;
        if (!n) return [];
        let s = ((r == null ? void 0 : r(e, t)) ?? [...Tt(e, { getVisitorKeys: X(i) })]).flatMap((a) => n(a) ? [a] : ut(a, t));
        return s.sort((a, D) => u(a) - u(D) || o(a) - o(D)), Pt2.set(e, s), s;
      }
      function qr2(e, t, r, n) {
        let { locStart: i, locEnd: u } = r, o = i(t), s = u(t), a = ut(e, r), D, l, d2 = 0, f = a.length;
        for (; d2 < f; ) {
          let p = d2 + f >> 1, c = a[p], F = i(c), m = u(c);
          if (F <= o && s <= m) return qr2(c, t, r, c);
          if (m <= o) {
            D = c, d2 = p + 1;
            continue;
          }
          if (s <= F) {
            l = c, f = p;
            continue;
          }
          throw new Error("Comment location overlaps with node location");
        }
        if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
          let { quasis: p } = n, c = Rt(p, t, r);
          D && Rt(p, D, r) !== c && (D = null), l && Rt(p, l, r) !== c && (l = null);
        }
        return { enclosingNode: n, precedingNode: D, followingNode: l };
      }
      var It2 = () => false;
      function Jr2(e, t) {
        let { comments: r } = e;
        if (delete e.comments, !kt2(r) || !t.printer.canAttachComment) return;
        let n = [], { locStart: i, locEnd: u, printer: { experimentalFeatures: { avoidAstMutation: o = false } = {}, handleComments: s = {} }, originalText: a } = t, { ownLine: D = It2, endOfLine: l = It2, remaining: d2 = It2 } = s, f = r.map((p, c) => ({ ...qr2(e, p, t), comment: p, text: a, options: t, ast: e, isLastComment: r.length - 1 === c }));
        for (let [p, c] of f.entries()) {
          let { comment: F, precedingNode: m, enclosingNode: E, followingNode: A, text: w, options: h, ast: C, isLastComment: k } = c;
          if (h.parser === "json" || h.parser === "json5" || h.parser === "jsonc" || h.parser === "__js_expression" || h.parser === "__ts_expression" || h.parser === "__vue_expression" || h.parser === "__vue_ts_expression") {
            if (i(F) - i(C) <= 0) {
              ue2(C, F);
              continue;
            }
            if (u(F) - u(C) >= 0) {
              ie(C, F);
              continue;
            }
          }
          let v2;
          if (o ? v2 = [c] : (F.enclosingNode = E, F.precedingNode = m, F.followingNode = A, v2 = [F, w, h, C, k]), ti2(w, h, f, p)) F.placement = "ownLine", D(...v2) || (A ? ue2(A, F) : m ? ie(m, F) : E ? re(E, F) : re(C, F));
          else if (ri2(w, h, f, p)) F.placement = "endOfLine", l(...v2) || (m ? ie(m, F) : A ? ue2(A, F) : E ? re(E, F) : re(C, F));
          else if (F.placement = "remaining", !d2(...v2)) if (m && A) {
            let $ = n.length;
            $ > 0 && n[$ - 1].followingNode !== A && Kr2(n, h), n.push(c);
          } else m ? ie(m, F) : A ? ue2(A, F) : E ? re(E, F) : re(C, F);
        }
        if (Kr2(n, t), !o) for (let p of r) delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
      }
      var Xr = (e) => !/[\S\n\u2028\u2029]/u.test(e);
      function ti2(e, t, r, n) {
        let { comment: i, precedingNode: u } = r[n], { locStart: o, locEnd: s } = t, a = o(i);
        if (u) for (let D = n - 1; D >= 0; D--) {
          let { comment: l, precedingNode: d2 } = r[D];
          if (d2 !== u || !Xr(e.slice(s(l), a))) break;
          a = o(l);
        }
        return V(e, a, { backwards: true });
      }
      function ri2(e, t, r, n) {
        let { comment: i, followingNode: u } = r[n], { locStart: o, locEnd: s } = t, a = s(i);
        if (u) for (let D = n + 1; D < r.length; D++) {
          let { comment: l, followingNode: d2 } = r[D];
          if (d2 !== u || !Xr(e.slice(a, o(l)))) break;
          a = s(l);
        }
        return V(e, a);
      }
      function Kr2(e, t) {
        var s, a;
        let r = e.length;
        if (r === 0) return;
        let { precedingNode: n, followingNode: i } = e[0], u = t.locStart(i), o;
        for (o = r; o > 0; --o) {
          let { comment: D, precedingNode: l, followingNode: d2 } = e[o - 1];
          ke2.strictEqual(l, n), ke2.strictEqual(d2, i);
          let f = t.originalText.slice(t.locEnd(D), u);
          if (((a = (s = t.printer).isGap) == null ? void 0 : a.call(s, f, t)) ?? /^[\s(]*$/u.test(f)) u = t.locStart(D);
          else break;
        }
        for (let [D, { comment: l }] of e.entries()) D < o ? ie(n, l) : ue2(i, l);
        for (let D of [n, i]) D.comments && D.comments.length > 1 && D.comments.sort((l, d2) => t.locStart(l) - t.locStart(d2));
        e.length = 0;
      }
      function Rt(e, t, r) {
        let n = r.locStart(t) - 1;
        for (let i = 1; i < e.length; ++i) if (n < r.locStart(e[i])) return i - 1;
        return 0;
      }
      function ni2(e, t) {
        let r = t - 1;
        r = T3(e, r, { backwards: true }), r = M(e, r, { backwards: true }), r = T3(e, r, { backwards: true });
        let n = M(e, r, { backwards: true });
        return r !== n;
      }
      var Le2 = ni2;
      function Zr2(e, t) {
        let r = e.node;
        return r.printed = true, t.printer.printComment(e, t);
      }
      function ui(e, t) {
        var l;
        let r = e.node, n = [Zr2(e, t)], { printer: i, originalText: u, locStart: o, locEnd: s } = t;
        if ((l = i.isBlockComment) == null ? void 0 : l.call(i, r)) {
          let d2 = V(u, s(r)) ? V(u, o(r), { backwards: true }) ? q : Ke2 : " ";
          n.push(d2);
        } else n.push(q);
        let D = M(u, T3(u, s(r)));
        return D !== false && V(u, D) && n.push(q), n;
      }
      function ii2(e, t, r) {
        var D;
        let n = e.node, i = Zr2(e, t), { printer: u, originalText: o, locStart: s } = t, a = (D = u.isBlockComment) == null ? void 0 : D.call(u, n);
        if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || V(o, s(n), { backwards: true })) {
          let l = Le2(o, s(n));
          return { doc: _e3([q, l ? q : "", i]), isBlock: a, hasLineSuffix: true };
        }
        return !a || r != null && r.hasLineSuffix ? { doc: [_e3([" ", i]), de3], isBlock: a, hasLineSuffix: true } : { doc: [" ", i], isBlock: a, hasLineSuffix: false };
      }
      function oi2(e, t) {
        let r = e.node;
        if (!r) return {};
        let n = t[Symbol.for("printedComments")];
        if ((r.comments || []).filter((a) => !n.has(a)).length === 0) return { leading: "", trailing: "" };
        let u = [], o = [], s;
        return e.each(() => {
          let a = e.node;
          if (n != null && n.has(a)) return;
          let { leading: D, trailing: l } = a;
          D ? u.push(ui(e, t)) : l && (s = ii2(e, t, s), o.push(s.doc));
        }, "comments"), { leading: u, trailing: o };
      }
      function Qr2(e, t, r) {
        let { leading: n, trailing: i } = oi2(e, r);
        return !n && !i ? t : Qe2(t, (u) => [n, u, i]);
      }
      function en2(e) {
        let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
        for (let n of t) {
          if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
          delete n.printed;
        }
      }
      function si2(e) {
        return () => {
        };
      }
      var tn2 = si2;
      var Pe = class extends Error {
        constructor() {
          super(...arguments);
          __publicField(this, "name", "ConfigError");
        }
      }, Ie = class extends Error {
        constructor() {
          super(...arguments);
          __publicField(this, "name", "UndefinedParserError");
        }
      };
      var rn2 = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
      function it2({ plugins: e = [], showDeprecated: t = false } = {}) {
        let r = e.flatMap((i) => i.languages ?? []), n = [];
        for (let i of Di2(Object.assign({}, ...e.map(({ options: u }) => u), rn2))) !t && i.deprecated || (Array.isArray(i.choices) && (t || (i.choices = i.choices.filter((u) => !u.deprecated)), i.name === "parser" && (i.choices = [...i.choices, ...ai2(i.choices, r, e)])), i.pluginDefaults = Object.fromEntries(e.filter((u) => {
          var o;
          return ((o = u.defaultOptions) == null ? void 0 : o[i.name]) !== void 0;
        }).map((u) => [u.name, u.defaultOptions[i.name]])), n.push(i));
        return { languages: r, options: n };
      }
      function* ai2(e, t, r) {
        let n = new Set(e.map((i) => i.value));
        for (let i of t) if (i.parsers) {
          for (let u of i.parsers) if (!n.has(u)) {
            n.add(u);
            let o = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, u)), s = i.name;
            o != null && o.name && (s += ` (plugin: ${o.name})`), yield { value: u, description: s };
          }
        }
      }
      function Di2(e) {
        let t = [];
        for (let [r, n] of Object.entries(e)) {
          let i = { name: r, ...n };
          Array.isArray(i.default) && (i.default = y2(false, i.default, -1).value), t.push(i);
        }
        return t;
      }
      var li = (e) => String(e).split(/[/\\]/u).pop();
      function nn2(e, t) {
        if (!t) return;
        let r = li(t).toLowerCase();
        return e.find(({ filenames: n }) => n == null ? void 0 : n.some((i) => i.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? void 0 : n.some((i) => r.endsWith(i)));
      }
      function ci3(e, t) {
        if (t) return e.find(({ name: r }) => r.toLowerCase() === t) ?? e.find(({ aliases: r }) => r == null ? void 0 : r.includes(t)) ?? e.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${t}`));
      }
      function fi2(e, t) {
        let r = e.plugins.flatMap((i) => i.languages ?? []), n = ci3(r, t.language) ?? nn2(r, t.physicalFile) ?? nn2(r, t.file) ?? (t.physicalFile, void 0);
        return n == null ? void 0 : n.parsers[0];
      }
      var un2 = fi2;
      var oe = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
        if (e === null || typeof e != "object") return JSON.stringify(e);
        if (Array.isArray(e)) return `[${e.map((r) => oe.value(r)).join(", ")}]`;
        let t = Object.keys(e);
        return t.length === 0 ? "{}" : `{ ${t.map((r) => `${oe.key(r)}: ${oe.value(e[r])}`).join(", ")} }`;
      }, pair: ({ key: e, value: t }) => oe.value({ [e]: t }) };
      var Yt = Me(ot(), 1), an2 = (e, t, { descriptor: r }) => {
        let n = [`${Yt.default.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
        return t && n.push(`we now treat it as ${Yt.default.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
      };
      var le2 = Me(ot(), 1);
      var st2 = Symbol.for("vnopts.VALUE_NOT_EXIST"), he = Symbol.for("vnopts.VALUE_UNCHANGED");
      var Dn2 = " ".repeat(2), cn2 = (e, t, r) => {
        let { text: n, list: i } = r.normalizeExpectedResult(r.schemas[e].expected(r)), u = [];
        return n && u.push(ln2(e, t, n, r.descriptor)), i && u.push([ln2(e, t, i.title, r.descriptor)].concat(i.values.map((o) => fn2(o, r.loggerPrintWidth))).join(`
`)), pn2(u, r.loggerPrintWidth);
      };
      function ln2(e, t, r, n) {
        return [`Invalid ${le2.default.red(n.key(e))} value.`, `Expected ${le2.default.blue(r)},`, `but received ${t === st2 ? le2.default.gray("nothing") : le2.default.red(n.value(t))}.`].join(" ");
      }
      function fn2({ text: e, list: t }, r) {
        let n = [];
        return e && n.push(`- ${le2.default.blue(e)}`), t && n.push([`- ${le2.default.blue(t.title)}:`].concat(t.values.map((i) => fn2(i, r - Dn2.length).replace(/^|\n/g, `$&${Dn2}`))).join(`
`)), pn2(n, r);
      }
      function pn2(e, t) {
        if (e.length === 1) return e[0];
        let [r, n] = e, [i, u] = e.map((o) => o.split(`
`, 1)[0].length);
        return i > t && i > u ? n : r;
      }
      var Wt = Me(ot(), 1);
      var jt = [], dn2 = [];
      function Ht2(e, t) {
        if (e === t) return 0;
        let r = e;
        e.length > t.length && (e = t, t = r);
        let n = e.length, i = t.length;
        for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-i); ) n--, i--;
        let u = 0;
        for (; u < n && e.charCodeAt(u) === t.charCodeAt(u); ) u++;
        if (n -= u, i -= u, n === 0) return i;
        let o, s, a, D, l = 0, d2 = 0;
        for (; l < n; ) dn2[l] = e.charCodeAt(u + l), jt[l] = ++l;
        for (; d2 < i; ) for (o = t.charCodeAt(u + d2), a = d2++, s = d2, l = 0; l < n; l++) D = o === dn2[l] ? a : a + 1, a = jt[l], s = jt[l] = a > s ? D > s ? s + 1 : D : D > a ? a + 1 : D;
        return s;
      }
      var at2 = (e, t, { descriptor: r, logger: n, schemas: i }) => {
        let u = [`Ignored unknown option ${Wt.default.yellow(r.pair({ key: e, value: t }))}.`], o = Object.keys(i).sort().find((s) => Ht2(e, s) < 3);
        o && u.push(`Did you mean ${Wt.default.blue(r.key(o))}?`), n.warn(u.join(" "));
      };
      var pi = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
      function di(e, t) {
        let r = new e(t), n = Object.create(r);
        for (let i of pi) i in t && (n[i] = Fi2(t[i], r, O.prototype[i].length));
        return n;
      }
      var O = class {
        static create(t) {
          return di(this, t);
        }
        constructor(t) {
          this.name = t.name;
        }
        default(t) {
        }
        expected(t) {
          return "nothing";
        }
        validate(t, r) {
          return false;
        }
        deprecated(t, r) {
          return false;
        }
        forward(t, r) {
        }
        redirect(t, r) {
        }
        overlap(t, r, n) {
          return t;
        }
        preprocess(t, r) {
          return t;
        }
        postprocess(t, r) {
          return he;
        }
      };
      function Fi2(e, t, r) {
        return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
      }
      var Dt = class extends O {
        constructor(t) {
          super(t), this._sourceName = t.sourceName;
        }
        expected(t) {
          return t.schemas[this._sourceName].expected(t);
        }
        validate(t, r) {
          return r.schemas[this._sourceName].validate(t, r);
        }
        redirect(t, r) {
          return this._sourceName;
        }
      };
      var lt = class extends O {
        expected() {
          return "anything";
        }
        validate() {
          return true;
        }
      };
      var ct = class extends O {
        constructor({ valueSchema: t, name: r = t.name, ...n }) {
          super({ ...n, name: r }), this._valueSchema = t;
        }
        expected(t) {
          let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
          return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
        }
        validate(t, r) {
          if (!Array.isArray(t)) return false;
          let n = [];
          for (let i of t) {
            let u = r.normalizeValidateResult(this._valueSchema.validate(i, r), i);
            u !== true && n.push(u.value);
          }
          return n.length === 0 ? true : { value: n };
        }
        deprecated(t, r) {
          let n = [];
          for (let i of t) {
            let u = r.normalizeDeprecatedResult(this._valueSchema.deprecated(i, r), i);
            u !== false && n.push(...u.map(({ value: o }) => ({ value: [o] })));
          }
          return n;
        }
        forward(t, r) {
          let n = [];
          for (let i of t) {
            let u = r.normalizeForwardResult(this._valueSchema.forward(i, r), i);
            n.push(...u.map(Fn));
          }
          return n;
        }
        redirect(t, r) {
          let n = [], i = [];
          for (let u of t) {
            let o = r.normalizeRedirectResult(this._valueSchema.redirect(u, r), u);
            "remain" in o && n.push(o.remain), i.push(...o.redirect.map(Fn));
          }
          return n.length === 0 ? { redirect: i } : { redirect: i, remain: n };
        }
        overlap(t, r) {
          return t.concat(r);
        }
      };
      function Fn({ from: e, to: t }) {
        return { from: [e], to: t };
      }
      var ft2 = class extends O {
        expected() {
          return "true or false";
        }
        validate(t) {
          return typeof t == "boolean";
        }
      };
      function En2(e, t) {
        let r = /* @__PURE__ */ Object.create(null);
        for (let n of e) {
          let i = n[t];
          if (r[i]) throw new Error(`Duplicate ${t} ${JSON.stringify(i)}`);
          r[i] = n;
        }
        return r;
      }
      function hn2(e, t) {
        let r = /* @__PURE__ */ new Map();
        for (let n of e) {
          let i = n[t];
          if (r.has(i)) throw new Error(`Duplicate ${t} ${JSON.stringify(i)}`);
          r.set(i, n);
        }
        return r;
      }
      function Cn() {
        let e = /* @__PURE__ */ Object.create(null);
        return (t) => {
          let r = JSON.stringify(t);
          return e[r] ? true : (e[r] = true, false);
        };
      }
      function gn2(e, t) {
        let r = [], n = [];
        for (let i of e) t(i) ? r.push(i) : n.push(i);
        return [r, n];
      }
      function yn2(e) {
        return e === Math.floor(e);
      }
      function An2(e, t) {
        if (e === t) return 0;
        let r = typeof e, n = typeof t, i = ["undefined", "object", "boolean", "number", "string"];
        return r !== n ? i.indexOf(r) - i.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
      }
      function Bn2(e) {
        return (...t) => {
          let r = e(...t);
          return typeof r == "string" ? new Error(r) : r;
        };
      }
      function Mt(e) {
        return e === void 0 ? {} : e;
      }
      function $t(e) {
        if (typeof e == "string") return { text: e };
        let { text: t, list: r } = e;
        return mi2((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: t, list: { title: r.title, values: r.values.map($t) } } : { text: t };
      }
      function Vt2(e, t) {
        return e === true ? true : e === false ? { value: t } : e;
      }
      function Ut(e, t, r = false) {
        return e === false ? false : e === true ? r ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
      }
      function mn(e, t) {
        return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
      }
      function pt2(e, t) {
        return e === void 0 ? [] : Array.isArray(e) ? e.map((r) => mn(r, t)) : [mn(e, t)];
      }
      function zt(e, t) {
        let r = pt2(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
        return r.length === 0 ? { remain: t, redirect: r } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
      }
      function mi2(e, t) {
        if (!e) throw new Error(t);
      }
      var dt2 = class extends O {
        constructor(t) {
          super(t), this._choices = hn2(t.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
        }
        expected({ descriptor: t }) {
          let r = Array.from(this._choices.keys()).map((o) => this._choices.get(o)).filter(({ hidden: o }) => !o).map((o) => o.value).sort(An2).map(t.value), n = r.slice(0, -2), i = r.slice(-2);
          return { text: n.concat(i.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
        }
        validate(t) {
          return this._choices.has(t);
        }
        deprecated(t) {
          let r = this._choices.get(t);
          return r && r.deprecated ? { value: t } : false;
        }
        forward(t) {
          let r = this._choices.get(t);
          return r ? r.forward : void 0;
        }
        redirect(t) {
          let r = this._choices.get(t);
          return r ? r.redirect : void 0;
        }
      };
      var Ft2 = class extends O {
        expected() {
          return "a number";
        }
        validate(t, r) {
          return typeof t == "number";
        }
      };
      var mt = class extends Ft2 {
        expected() {
          return "an integer";
        }
        validate(t, r) {
          return r.normalizeValidateResult(super.validate(t, r), t) === true && yn2(t);
        }
      };
      var Re = class extends O {
        expected() {
          return "a string";
        }
        validate(t) {
          return typeof t == "string";
        }
      };
      var wn2 = oe, _n2 = at2, xn2 = cn2, vn = an2;
      var Et2 = class {
        constructor(t, r) {
          let { logger: n = console, loggerPrintWidth: i = 80, descriptor: u = wn2, unknown: o = _n2, invalid: s = xn2, deprecated: a = vn, missing: D = () => false, required: l = () => false, preprocess: d2 = (p) => p, postprocess: f = () => he } = r || {};
          this._utils = { descriptor: u, logger: n || { warn: () => {
          } }, loggerPrintWidth: i, schemas: En2(t, "name"), normalizeDefaultResult: Mt, normalizeExpectedResult: $t, normalizeDeprecatedResult: Ut, normalizeForwardResult: pt2, normalizeRedirectResult: zt, normalizeValidateResult: Vt2 }, this._unknownHandler = o, this._invalidHandler = Bn2(s), this._deprecatedHandler = a, this._identifyMissing = (p, c) => !(p in c) || D(p, c), this._identifyRequired = l, this._preprocess = d2, this._postprocess = f, this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = Cn();
        }
        normalize(t) {
          let r = {}, i = [this._preprocess(t, this._utils)], u = () => {
            for (; i.length !== 0; ) {
              let o = i.shift(), s = this._applyNormalization(o, r);
              i.push(...s);
            }
          };
          u();
          for (let o of Object.keys(this._utils.schemas)) {
            let s = this._utils.schemas[o];
            if (!(o in r)) {
              let a = Mt(s.default(this._utils));
              "value" in a && i.push({ [o]: a.value });
            }
          }
          u();
          for (let o of Object.keys(this._utils.schemas)) {
            if (!(o in r)) continue;
            let s = this._utils.schemas[o], a = r[o], D = s.postprocess(a, this._utils);
            D !== he && (this._applyValidation(D, o, s), r[o] = D);
          }
          return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
        }
        _applyNormalization(t, r) {
          let n = [], { knownKeys: i, unknownKeys: u } = this._partitionOptionKeys(t);
          for (let o of i) {
            let s = this._utils.schemas[o], a = s.preprocess(t[o], this._utils);
            this._applyValidation(a, o, s);
            let D = ({ from: p, to: c }) => {
              n.push(typeof c == "string" ? { [c]: p } : { [c.key]: c.value });
            }, l = ({ value: p, redirectTo: c }) => {
              let F = Ut(s.deprecated(p, this._utils), a, true);
              if (F !== false) if (F === true) this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, c, this._utils));
              else for (let { value: m } of F) {
                let E = { key: o, value: m };
                if (!this._hasDeprecationWarned(E)) {
                  let A = typeof c == "string" ? { key: c, value: m } : c;
                  this._utils.logger.warn(this._deprecatedHandler(E, A, this._utils));
                }
              }
            };
            pt2(s.forward(a, this._utils), a).forEach(D);
            let f = zt(s.redirect(a, this._utils), a);
            if (f.redirect.forEach(D), "remain" in f) {
              let p = f.remain;
              r[o] = o in r ? s.overlap(r[o], p, this._utils) : p, l({ value: p });
            }
            for (let { from: p, to: c } of f.redirect) l({ value: p, redirectTo: c });
          }
          for (let o of u) {
            let s = t[o];
            this._applyUnknownHandler(o, s, r, (a, D) => {
              n.push({ [a]: D });
            });
          }
          return n;
        }
        _applyRequiredCheck(t) {
          for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, st2, this._utils);
        }
        _partitionOptionKeys(t) {
          let [r, n] = gn2(Object.keys(t).filter((i) => !this._identifyMissing(i, t)), (i) => i in this._utils.schemas);
          return { knownKeys: r, unknownKeys: n };
        }
        _applyValidation(t, r, n) {
          let i = Vt2(n.validate(t, this._utils), t);
          if (i !== true) throw this._invalidHandler(r, i.value, this._utils);
        }
        _applyUnknownHandler(t, r, n, i) {
          let u = this._unknownHandler(t, r, this._utils);
          if (u) for (let o of Object.keys(u)) {
            if (this._identifyMissing(o, u)) continue;
            let s = u[o];
            o in this._utils.schemas ? i(o, s) : n[o] = s;
          }
        }
        _applyPostprocess(t) {
          let r = this._postprocess(t, this._utils);
          if (r !== he) {
            if (r.delete) for (let n of r.delete) delete t[n];
            if (r.override) {
              let { knownKeys: n, unknownKeys: i } = this._partitionOptionKeys(r.override);
              for (let u of n) {
                let o = r.override[u];
                this._applyValidation(o, u, this._utils.schemas[u]), t[u] = o;
              }
              for (let u of i) {
                let o = r.override[u];
                this._applyUnknownHandler(u, o, t, (s, a) => {
                  let D = this._utils.schemas[s];
                  this._applyValidation(a, s, D), t[s] = a;
                });
              }
            }
          }
        }
      };
      var Gt3;
      function hi2(e, t, { logger: r = false, isCLI: n = false, passThrough: i = false, FlagSchema: u, descriptor: o } = {}) {
        if (n) {
          if (!u) throw new Error("'FlagSchema' option is required.");
          if (!o) throw new Error("'descriptor' option is required.");
        } else o = oe;
        let s = i ? Array.isArray(i) ? (f, p) => i.includes(f) ? { [f]: p } : void 0 : (f, p) => ({ [f]: p }) : (f, p, c) => {
          let { _: F, ...m } = c.schemas;
          return at2(f, p, { ...c, schemas: m });
        }, a = Ci2(t, { isCLI: n, FlagSchema: u }), D = new Et2(a, { logger: r, unknown: s, descriptor: o }), l = r !== false;
        l && Gt3 && (D._hasDeprecationWarned = Gt3);
        let d2 = D.normalize(e);
        return l && (Gt3 = D._hasDeprecationWarned), d2;
      }
      function Ci2(e, { isCLI: t, FlagSchema: r }) {
        let n = [];
        t && n.push(lt.create({ name: "_" }));
        for (let i of e) n.push(gi(i, { isCLI: t, optionInfos: e, FlagSchema: r })), i.alias && t && n.push(Dt.create({ name: i.alias, sourceName: i.name }));
        return n;
      }
      function gi(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
        let { name: i } = e, u = { name: i }, o, s = {};
        switch (e.type) {
          case "int":
            o = mt, t && (u.preprocess = Number);
            break;
          case "string":
            o = Re;
            break;
          case "choice":
            o = dt2, u.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
            break;
          case "boolean":
            o = ft2;
            break;
          case "flag":
            o = n, u.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
            break;
          case "path":
            o = Re;
            break;
          default:
            throw new Error(`Unexpected type ${e.type}`);
        }
        if (e.exception ? u.validate = (a, D, l) => e.exception(a) || D.validate(a, l) : u.validate = (a, D, l) => a === void 0 || D.validate(a, l), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
          let a = u.preprocess || ((D) => D);
          u.preprocess = (D, l, d2) => l.preprocess(a(Array.isArray(D) ? y2(false, D, -1) : D), d2);
        }
        return e.array ? ct.create({ ...t ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: o.create(u) }) : o.create({ ...u, ...s });
      }
      var bn2 = hi2;
      var yi2 = (e, t, r) => {
        if (!(e && t == null)) {
          if (t.findLast) return t.findLast(r);
          for (let n = t.length - 1; n >= 0; n--) {
            let i = t[n];
            if (r(i, n, t)) return i;
          }
        }
      }, Kt2 = yi2;
      function qt2(e, t) {
        if (!t) throw new Error("parserName is required.");
        let r = Kt2(false, e, (i) => i.parsers && Object.prototype.hasOwnProperty.call(i.parsers, t));
        if (r) return r;
        let n = `Couldn't resolve parser "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new Pe(n);
      }
      function On2(e, t) {
        if (!t) throw new Error("astFormat is required.");
        let r = Kt2(false, e, (i) => i.printers && Object.prototype.hasOwnProperty.call(i.printers, t));
        if (r) return r;
        let n = `Couldn't find plugin for AST format "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new Pe(n);
      }
      function ht2({ plugins: e, parser: t }) {
        let r = qt2(e, t);
        return Jt2(r, t);
      }
      function Jt2(e, t) {
        let r = e.parsers[t];
        return typeof r == "function" ? r() : r;
      }
      function Sn2(e, t) {
        let r = e.printers[t];
        return typeof r == "function" ? r() : r;
      }
      var Nn2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
      async function Ai2(e, t = {}) {
        var d2;
        let r = { ...e };
        if (!r.parser) if (r.filepath) {
          if (r.parser = un2(r, { physicalFile: r.filepath }), !r.parser) throw new Ie(`No parser could be inferred for file "${r.filepath}".`);
        } else throw new Ie("No parser and no file path given, couldn't infer a parser.");
        let n = it2({ plugins: e.plugins, showDeprecated: true }).options, i = { ...Nn2, ...Object.fromEntries(n.filter((f) => f.default !== void 0).map((f) => [f.name, f.default])) }, u = qt2(r.plugins, r.parser), o = await Jt2(u, r.parser);
        r.astFormat = o.astFormat, r.locEnd = o.locEnd, r.locStart = o.locStart;
        let s = (d2 = u.printers) != null && d2[o.astFormat] ? u : On2(r.plugins, o.astFormat), a = await Sn2(s, o.astFormat);
        r.printer = a;
        let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, f]) => f !== void 0)) : {}, l = { ...i, ...D };
        for (let [f, p] of Object.entries(l)) (r[f] === null || r[f] === void 0) && (r[f] = p);
        return r.parser === "json" && (r.trailingComma = "none"), bn2(r, n, { passThrough: Object.keys(Nn2), ...t });
      }
      var se = Ai2;
      var Vn2 = Me($n2(), 1);
      async function Ni2(e, t) {
        let r = await ht2(t), n = r.preprocess ? r.preprocess(e, t) : e;
        t.originalText = n;
        let i;
        try {
          i = await r.parse(n, t, t);
        } catch (u) {
          Ti2(u, e);
        }
        return { text: n, ast: i };
      }
      function Ti2(e, t) {
        let { loc: r } = e;
        if (r) {
          let n = (0, Vn2.codeFrameColumns)(t, r, { highlightCode: true });
          throw e.message += `
` + n, e.codeFrame = n, e;
        }
        throw e;
      }
      var ce = Ni2;
      async function Un2(e, t, r, n, i) {
        let { embeddedLanguageFormatting: u, printer: { embed: o, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
        if (!o || u !== "auto") return;
        if (o.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
        let D = X(o.getVisitorKeys ?? a), l = [];
        p();
        let d2 = e.stack;
        for (let { print: c, node: F, pathStack: m } of l) try {
          e.stack = m;
          let E = await c(f, t, e, r);
          E && i.set(F, E);
        } catch (E) {
          if (globalThis.PRETTIER_DEBUG) throw E;
        }
        e.stack = d2;
        function f(c, F) {
          return ki2(c, F, r, n);
        }
        function p() {
          let { node: c } = e;
          if (c === null || typeof c != "object" || s(e)) return;
          for (let m of D(c)) Array.isArray(c[m]) ? e.each(p, m) : e.call(p, m);
          let F = o(e, r);
          if (F) {
            if (typeof F == "function") {
              l.push({ print: F, node: c, pathStack: [...e.stack] });
              return;
            }
            i.set(c, F);
          }
        }
      }
      async function ki2(e, t, r, n) {
        let i = await se({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: true }), { ast: u } = await ce(e, i), o = await n(u, i);
        return Ze2(o);
      }
      function Li2(e, t) {
        let { originalText: r, [Symbol.for("comments")]: n, locStart: i, locEnd: u, [Symbol.for("printedComments")]: o } = t, { node: s } = e, a = i(s), D = u(s);
        for (let l of n) i(l) >= a && u(l) <= D && o.add(l);
        return r.slice(a, D);
      }
      var zn = Li2;
      async function Ye3(e, t) {
        ({ ast: e } = await Qt2(e, t));
        let r = /* @__PURE__ */ new Map(), n = new Mr2(e), i = tn2(t), u = /* @__PURE__ */ new Map();
        await Un2(n, s, t, Ye3, u);
        let o = await Gn2(n, t, s, void 0, u);
        return en2(t), o;
        function s(D, l) {
          return D === void 0 || D === n ? a(l) : Array.isArray(D) ? n.call(() => a(l), ...D) : n.call(() => a(l), D);
        }
        function a(D) {
          i(n);
          let l = n.node;
          if (l == null) return "";
          let d2 = l && typeof l == "object" && D === void 0;
          if (d2 && r.has(l)) return r.get(l);
          let f = Gn2(n, t, s, D, u);
          return d2 && r.set(l, f), f;
        }
      }
      function Gn2(e, t, r, n, i) {
        var a;
        let { node: u } = e, { printer: o } = t, s;
        return (a = o.hasPrettierIgnore) != null && a.call(o, e) ? s = zn(e, t) : i.has(u) ? s = i.get(u) : s = o.print(e, t, r, n), u === t.cursorNode && (s = Qe2(s, (D) => [ve2, D, ve2])), o.printComment && (!o.willPrintOwnComments || !o.willPrintOwnComments(e, t)) && (s = Qr2(e, s, t)), s;
      }
      async function Qt2(e, t) {
        let r = e.comments ?? [];
        t[Symbol.for("comments")] = r, t[Symbol.for("tokens")] = e.tokens ?? [], t[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Jr2(e, t);
        let { printer: { preprocess: n } } = t;
        return e = n ? await n(e, t) : e, { ast: e, comments: r };
      }
      function Pi2(e, t) {
        let { cursorOffset: r, locStart: n, locEnd: i } = t, u = X(t.printer.getVisitorKeys), o = (a) => n(a) <= r && i(a) >= r, s = e;
        for (let a of Ur2(e, { getVisitorKeys: u, filter: o })) s = a;
        return s;
      }
      var Kn2 = Pi2;
      function Ii2(e, t) {
        let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
        if (!r) return e;
        let i = X(n), u = r.ignoredProperties ?? /* @__PURE__ */ new Set();
        return o(e);
        function o(s, a) {
          if (!(s !== null && typeof s == "object")) return s;
          if (Array.isArray(s)) return s.map((f) => o(f, a)).filter(Boolean);
          let D = {}, l = new Set(i(s));
          for (let f in s) !Object.prototype.hasOwnProperty.call(s, f) || u.has(f) || (l.has(f) ? D[f] = o(s[f], s) : D[f] = s[f]);
          let d2 = r(s, D, a);
          if (d2 !== null) return d2 ?? D;
        }
      }
      var qn2 = Ii2;
      var Ri2 = (e, t, r) => {
        if (!(e && t == null)) {
          if (t.findLastIndex) return t.findLastIndex(r);
          for (let n = t.length - 1; n >= 0; n--) {
            let i = t[n];
            if (r(i, n, t)) return n;
          }
          return -1;
        }
      }, Jn2 = Ri2;
      var Yi2 = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
      function ji(e, t) {
        let r = [e.node, ...e.parentNodes], n = /* @__PURE__ */ new Set([t.node, ...t.parentNodes]);
        return r.find((i) => Qn2.has(i.type) && n.has(i));
      }
      function Xn2(e) {
        let t = Jn2(false, e, (r) => r.type !== "Program" && r.type !== "File");
        return t === -1 ? e : e.slice(0, t + 1);
      }
      function Hi2(e, t, { locStart: r, locEnd: n }) {
        let i = e.node, u = t.node;
        if (i === u) return { startNode: i, endNode: u };
        let o = r(e.node);
        for (let a of Xn2(t.parentNodes)) if (r(a) >= o) u = a;
        else break;
        let s = n(t.node);
        for (let a of Xn2(e.parentNodes)) {
          if (n(a) <= s) i = a;
          else break;
          if (i === u) break;
        }
        return { startNode: i, endNode: u };
      }
      function er(e, t, r, n, i = [], u) {
        let { locStart: o, locEnd: s } = r, a = o(e), D = s(e);
        if (!(t > D || t < a || u === "rangeEnd" && t === a || u === "rangeStart" && t === D)) {
          for (let l of ut(e, r)) {
            let d2 = er(l, t, r, n, [e, ...i], u);
            if (d2) return d2;
          }
          if (!n || n(e, i[0])) return { node: e, parentNodes: i };
        }
      }
      function Wi2(e, t) {
        return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
      }
      var Qn2 = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), Mi2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      function Zn(e, t, r) {
        if (!t) return false;
        switch (e.parser) {
          case "flow":
          case "babel":
          case "babel-flow":
          case "babel-ts":
          case "typescript":
          case "acorn":
          case "espree":
          case "meriyah":
          case "__babel_estree":
            return Wi2(t.type, r == null ? void 0 : r.type);
          case "json":
          case "json5":
          case "jsonc":
          case "json-stringify":
            return Qn2.has(t.type);
          case "graphql":
            return Mi2.has(t.kind);
          case "vue":
            return t.tag !== "root";
        }
        return false;
      }
      function eu2(e, t, r) {
        let { rangeStart: n, rangeEnd: i, locStart: u, locEnd: o } = t;
        ke2.ok(i > n);
        let s = e.slice(n, i).search(/\S/u), a = s === -1;
        if (!a) for (n += s; i > n && !/\S/u.test(e[i - 1]); --i) ;
        let D = er(r, n, t, (p, c) => Zn(t, p, c), [], "rangeStart"), l = a ? D : er(r, i, t, (p) => Zn(t, p), [], "rangeEnd");
        if (!D || !l) return { rangeStart: 0, rangeEnd: 0 };
        let d2, f;
        if (Yi2(t)) {
          let p = ji(D, l);
          d2 = p, f = p;
        } else ({ startNode: d2, endNode: f } = Hi2(D, l, t));
        return { rangeStart: Math.min(u(d2), u(f)), rangeEnd: Math.max(o(d2), o(f)) };
      }
      var uu2 = "\uFEFF", tu3 = Symbol("cursor");
      async function iu2(e, t, r = 0) {
        if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
        let { ast: n, text: i } = await ce(e, t);
        t.cursorOffset >= 0 && (t.cursorNode = Kn2(n, t));
        let u = await Ye3(n, t, r);
        r > 0 && (u = Je([q, u], r, t.tabWidth));
        let o = Fe2(u, t);
        if (r > 0) {
          let a = o.formatted.trim();
          o.cursorNodeStart !== void 0 && (o.cursorNodeStart -= o.formatted.indexOf(a)), o.formatted = a + Be3(t.endOfLine);
        }
        let s = t[Symbol.for("comments")];
        if (t.cursorOffset >= 0) {
          let a, D, l, d2, f;
          if (t.cursorNode && o.cursorNodeText ? (a = t.locStart(t.cursorNode), D = i.slice(a, t.locEnd(t.cursorNode)), l = t.cursorOffset - a, d2 = o.cursorNodeStart, f = o.cursorNodeText) : (a = 0, D = i, l = t.cursorOffset, d2 = 0, f = o.formatted), D === f) return { formatted: o.formatted, cursorOffset: d2 + l, comments: s };
          let p = D.split("");
          p.splice(l, 0, tu3);
          let c = f.split(""), F = dr(p, c), m = d2;
          for (let E of F) if (E.removed) {
            if (E.value.includes(tu3)) break;
          } else m += E.count;
          return { formatted: o.formatted, cursorOffset: m, comments: s };
        }
        return { formatted: o.formatted, cursorOffset: -1, comments: s };
      }
      async function $i2(e, t) {
        let { ast: r, text: n } = await ce(e, t), { rangeStart: i, rangeEnd: u } = eu2(n, t, r), o = n.slice(i, u), s = Math.min(i, n.lastIndexOf(`
`, i) + 1), a = n.slice(s, i).match(/^\s*/u)[0], D = me(a, t.tabWidth), l = await iu2(o, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > i && t.cursorOffset <= u ? t.cursorOffset - i : -1, endOfLine: "lf" }, D), d2 = l.formatted.trimEnd(), { cursorOffset: f } = t;
        f > u ? f += d2.length - o.length : l.cursorOffset >= 0 && (f = l.cursorOffset + i);
        let p = n.slice(0, i) + d2 + n.slice(u);
        if (t.endOfLine !== "lf") {
          let c = Be3(t.endOfLine);
          f >= 0 && c === `\r
` && (f += wt(p.slice(0, f), `
`)), p = ne(false, p, `
`, c);
        }
        return { formatted: p, cursorOffset: f, comments: l.comments };
      }
      function tr2(e, t, r) {
        return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
      }
      function ru2(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: i } = t;
        return r = tr2(e, r, -1), n = tr2(e, n, 0), i = tr2(e, i, e.length), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: i };
      }
      function ou2(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: u } = ru2(e, t), o = e.charAt(0) === uu2;
        if (o && (e = e.slice(1), r--, n--, i--), u === "auto" && (u = Fr2(e)), e.includes("\r")) {
          let s = (a) => wt(e.slice(0, Math.max(a, 0)), `\r
`);
          r -= s(r), n -= s(n), i -= s(i), e = mr2(e);
        }
        return { hasBOM: o, text: e, options: ru2(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: i, endOfLine: u }) };
      }
      async function nu2(e, t) {
        let r = await ht2(t);
        return !r.hasPragma || r.hasPragma(e);
      }
      async function rr2(e, t) {
        let { hasBOM: r, text: n, options: i } = ou2(e, await se(t));
        if (i.rangeStart >= i.rangeEnd && n !== "" || i.requirePragma && !await nu2(n, i)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
        let u;
        return i.rangeStart > 0 || i.rangeEnd < n.length ? u = await $i2(n, i) : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !await nu2(n, i) && (n = i.printer.insertPragma(n)), u = await iu2(n, i)), r && (u.formatted = uu2 + u.formatted, u.cursorOffset >= 0 && u.cursorOffset++), u;
      }
      async function su2(e, t, r) {
        let { text: n, options: i } = ou2(e, await se(t)), u = await ce(n, i);
        return r && (r.preprocessForPrint && (u.ast = await Qt2(u.ast, i)), r.massage && (u.ast = qn2(u.ast, i))), u;
      }
      async function au2(e, t) {
        t = await se(t);
        let r = await Ye3(e, t);
        return Fe2(r, t);
      }
      async function Du2(e, t) {
        let r = Or2(e), { formatted: n } = await rr2(r, { ...t, parser: "__js_expression" });
        return n;
      }
      async function lu2(e, t) {
        t = await se(t);
        let { ast: r } = await ce(e, t);
        return Ye3(r, t);
      }
      async function cu2(e, t) {
        return Fe2(e, await se(t));
      }
      var nr2 = {};
      We(nr2, { builders: () => Ui2, printer: () => zi2, utils: () => Gi2 });
      var Ui2 = { join: be2, line: Ke2, softline: vr2, hardline: q, literalline: qe, group: xt, conditionalGroup: Ar2, fill: Ge, lineSuffix: _e3, lineSuffixBoundary: _r2, cursor: ve2, breakParent: de3, ifBreak: Br2, trim: xr, indent: De, indentIfBreak: wr2, align: ae, addAlignmentToDoc: Je, markAsRoot: gr2, dedentToRoot: Cr2, dedent: yr2, hardlineWithoutBreakParent: xe, literallineWithoutBreakParent: vt, label: br2, concat: (e) => e }, zi2 = { printDocToString: Fe2 }, Gi2 = { willBreak: Ir2, traverseDoc: we, findInDoc: Xe2, mapDoc: Ne2, removeLines: Yr2, stripTrailingHardline: Ze2, replaceEndOfLine: jr2, canBreak: Hr2 };
      var fu = "3.3.3";
      var ir2 = {};
      We(ir2, { addDanglingComment: () => re, addLeadingComment: () => ue2, addTrailingComment: () => ie, getAlignmentSize: () => me, getIndentSize: () => pu, getMaxContinuousCount: () => du, getNextNonSpaceNonCommentCharacter: () => Fu2, getNextNonSpaceNonCommentCharacterIndex: () => io2, getStringWidth: () => Oe2, hasNewline: () => V, hasNewlineInRange: () => mu, hasSpaces: () => Eu, isNextLineEmpty: () => Do2, isNextLineEmptyAfterIndex: () => gt2, isPreviousLineEmpty: () => so2, makeString: () => hu, skip: () => Ee, skipEverythingButNewLine: () => nt2, skipInlineComment: () => Ce, skipNewline: () => M, skipSpaces: () => T3, skipToLineEnd: () => rt, skipTrailingComment: () => ge, skipWhitespace: () => zr2 });
      function Ki2(e, t) {
        if (t === false) return false;
        if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
          for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
        }
        return t;
      }
      var Ce = Ki2;
      function qi(e, t) {
        return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? nt2(e, t) : t;
      }
      var ge = qi;
      function Ji(e, t) {
        let r = null, n = t;
        for (; n !== r; ) r = n, n = T3(e, n), n = Ce(e, n), n = ge(e, n), n = M(e, n);
        return n;
      }
      var je = Ji;
      function Xi2(e, t) {
        let r = null, n = t;
        for (; n !== r; ) r = n, n = rt(e, n), n = Ce(e, n), n = T3(e, n);
        return n = ge(e, n), n = M(e, n), n !== false && V(e, n);
      }
      var gt2 = Xi2;
      function Zi2(e, t) {
        let r = e.lastIndexOf(`
`);
        return r === -1 ? 0 : me(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
      }
      var pu = Zi2;
      function ur2(e) {
        if (typeof e != "string") throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }
      function Qi(e, t) {
        let r = e.match(new RegExp(`(${ur2(t)})+`, "gu"));
        return r === null ? 0 : r.reduce((n, i) => Math.max(n, i.length / t.length), 0);
      }
      var du = Qi;
      function eo2(e, t) {
        let r = je(e, t);
        return r === false ? "" : e.charAt(r);
      }
      var Fu2 = eo2;
      function to2(e, t, r) {
        for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
        return false;
      }
      var mu = to2;
      function ro2(e, t, r = {}) {
        return T3(e, r.backwards ? t - 1 : t, r) !== t;
      }
      var Eu = ro2;
      function no2(e, t, r) {
        let n = t === '"' ? "'" : '"', u = ne(false, e, /\\(.)|(["'])/gsu, (o, s, a) => s === n ? s : a === t ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
        return t + u + t;
      }
      var hu = no2;
      function uo2(e, t, r) {
        return je(e, r(t));
      }
      function io2(e, t) {
        return arguments.length === 2 || typeof t == "number" ? je(e, t) : uo2(...arguments);
      }
      function oo2(e, t, r) {
        return Le2(e, r(t));
      }
      function so2(e, t) {
        return arguments.length === 2 || typeof t == "number" ? Le2(e, t) : oo2(...arguments);
      }
      function ao2(e, t, r) {
        return gt2(e, r(t));
      }
      function Do2(e, t) {
        return arguments.length === 2 || typeof t == "number" ? gt2(e, t) : ao2(...arguments);
      }
      function fe(e, t = 1) {
        return async (...r) => {
          let n = r[t] ?? {}, i = n.plugins ?? [];
          return r[t] = { ...n, plugins: Array.isArray(i) ? i : Object.values(i) }, e(...r);
        };
      }
      var Cu2 = fe(rr2);
      async function gu(e, t) {
        let { formatted: r } = await Cu2(e, { ...t, cursorOffset: -1 });
        return r;
      }
      async function lo2(e, t) {
        return await gu(e, t) === e;
      }
      var co2 = fe(it2, 0), fo2 = { parse: fe(su2), formatAST: fe(au2), formatDoc: fe(Du2), printToDoc: fe(lu2), printDocToString: fe(cu2) };
      return ar2(po2);
    });
  }
});

// node_modules/prettier/plugins/postcss.js
var require_postcss = __commonJS({
  "node_modules/prettier/plugins/postcss.js"(exports, module) {
    (function(f) {
      function e() {
        var i = f();
        return i.default || i;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var t = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.postcss = e();
      }
    })(function() {
      "use strict";
      var al2 = Object.create;
      var bt2 = Object.defineProperty;
      var ul2 = Object.getOwnPropertyDescriptor;
      var ll2 = Object.getOwnPropertyNames;
      var cl2 = Object.getPrototypeOf, fl2 = Object.prototype.hasOwnProperty;
      var y2 = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Js2 = (t, e) => {
        for (var s in e) bt2(t, s, { get: e[s], enumerable: true });
      }, Xs2 = (t, e, s, r) => {
        if (e && typeof e == "object" || typeof e == "function") for (let n of ll2(e)) !fl2.call(t, n) && n !== s && bt2(t, n, { get: () => e[n], enumerable: !(r = ul2(e, n)) || r.enumerable });
        return t;
      };
      var ye = (t, e, s) => (s = t != null ? al2(cl2(t)) : {}, Xs2(e || !t || !t.__esModule ? bt2(s, "default", { value: t, enumerable: true }) : s, t)), pl2 = (t) => Xs2(bt2({}, "__esModule", { value: true }), t);
      var Ft2 = y2((rv2, ts2) => {
        "use strict";
        ts2.exports.isClean = Symbol("isClean");
        ts2.exports.my = Symbol("my");
      });
      var yi2 = y2((sv2, rs2) => {
        var S = String, mi2 = function() {
          return { isColorSupported: false, reset: S, bold: S, dim: S, italic: S, underline: S, inverse: S, hidden: S, strikethrough: S, black: S, red: S, green: S, yellow: S, blue: S, magenta: S, cyan: S, white: S, gray: S, bgBlack: S, bgRed: S, bgGreen: S, bgYellow: S, bgBlue: S, bgMagenta: S, bgCyan: S, bgWhite: S };
        };
        rs2.exports = mi2();
        rs2.exports.createColors = mi2;
      });
      var ss2 = y2(() => {
      });
      var $t = y2((ov2, vi2) => {
        "use strict";
        var wi2 = yi2(), gi = ss2(), st2 = class t extends Error {
          constructor(e, s, r, n, i, o) {
            super(e), this.name = "CssSyntaxError", this.reason = e, i && (this.file = i), n && (this.source = n), o && (this.plugin = o), typeof s < "u" && typeof r < "u" && (typeof s == "number" ? (this.line = s, this.column = r) : (this.line = s.line, this.column = s.column, this.endLine = r.line, this.endColumn = r.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, t);
          }
          setMessage() {
            this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
          }
          showSourceCode(e) {
            if (!this.source) return "";
            let s = this.source;
            e == null && (e = wi2.isColorSupported), gi && e && (s = gi(s));
            let r = s.split(/\r?\n/), n = Math.max(this.line - 3, 0), i = Math.min(this.line + 2, r.length), o = String(i).length, a, u;
            if (e) {
              let { bold: c, gray: f, red: p } = wi2.createColors(true);
              a = (l) => c(p(l)), u = (l) => f(l);
            } else a = u = (c) => c;
            return r.slice(n, i).map((c, f) => {
              let p = n + 1 + f, l = " " + (" " + p).slice(-o) + " | ";
              if (p === this.line) {
                let w = u(l.replace(/\d/g, " ")) + c.slice(0, this.column - 1).replace(/[^\t]/g, " ");
                return a(">") + u(l) + c + `
 ` + w + a("^");
              }
              return " " + u(l) + c;
            }).join(`
`);
          }
          toString() {
            let e = this.showSourceCode();
            return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
          }
        };
        vi2.exports = st2;
        st2.default = st2;
      });
      var Wt = y2((av2, bi2) => {
        "use strict";
        var xi2 = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
        function lc2(t) {
          return t[0].toUpperCase() + t.slice(1);
        }
        var nt2 = class {
          constructor(e) {
            this.builder = e;
          }
          atrule(e, s) {
            let r = "@" + e.name, n = e.params ? this.rawValue(e, "params") : "";
            if (typeof e.raws.afterName < "u" ? r += e.raws.afterName : n && (r += " "), e.nodes) this.block(e, r + n);
            else {
              let i = (e.raws.between || "") + (s ? ";" : "");
              this.builder(r + n + i, e);
            }
          }
          beforeAfter(e, s) {
            let r;
            e.type === "decl" ? r = this.raw(e, null, "beforeDecl") : e.type === "comment" ? r = this.raw(e, null, "beforeComment") : s === "before" ? r = this.raw(e, null, "beforeRule") : r = this.raw(e, null, "beforeClose");
            let n = e.parent, i = 0;
            for (; n && n.type !== "root"; ) i += 1, n = n.parent;
            if (r.includes(`
`)) {
              let o = this.raw(e, null, "indent");
              if (o.length) for (let a = 0; a < i; a++) r += o;
            }
            return r;
          }
          block(e, s) {
            let r = this.raw(e, "between", "beforeOpen");
            this.builder(s + r + "{", e, "start");
            let n;
            e.nodes && e.nodes.length ? (this.body(e), n = this.raw(e, "after")) : n = this.raw(e, "after", "emptyBody"), n && this.builder(n), this.builder("}", e, "end");
          }
          body(e) {
            let s = e.nodes.length - 1;
            for (; s > 0 && e.nodes[s].type === "comment"; ) s -= 1;
            let r = this.raw(e, "semicolon");
            for (let n = 0; n < e.nodes.length; n++) {
              let i = e.nodes[n], o = this.raw(i, "before");
              o && this.builder(o), this.stringify(i, s !== n || r);
            }
          }
          comment(e) {
            let s = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
            this.builder("/*" + s + e.text + r + "*/", e);
          }
          decl(e, s) {
            let r = this.raw(e, "between", "colon"), n = e.prop + r + this.rawValue(e, "value");
            e.important && (n += e.raws.important || " !important"), s && (n += ";"), this.builder(n, e);
          }
          document(e) {
            this.body(e);
          }
          raw(e, s, r) {
            let n;
            if (r || (r = s), s && (n = e.raws[s], typeof n < "u")) return n;
            let i = e.parent;
            if (r === "before" && (!i || i.type === "root" && i.first === e || i && i.type === "document")) return "";
            if (!i) return xi2[r];
            let o = e.root();
            if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[r] < "u") return o.rawCache[r];
            if (r === "before" || r === "after") return this.beforeAfter(e, r);
            {
              let a = "raw" + lc2(r);
              this[a] ? n = this[a](o, e) : o.walk((u) => {
                if (n = u.raws[s], typeof n < "u") return false;
              });
            }
            return typeof n > "u" && (n = xi2[r]), o.rawCache[r] = n, n;
          }
          rawBeforeClose(e) {
            let s;
            return e.walk((r) => {
              if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u") return s = r.raws.after, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), false;
            }), s && (s = s.replace(/\S/g, "")), s;
          }
          rawBeforeComment(e, s) {
            let r;
            return e.walkComments((n) => {
              if (typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
            }), typeof r > "u" ? r = this.raw(s, null, "beforeDecl") : r && (r = r.replace(/\S/g, "")), r;
          }
          rawBeforeDecl(e, s) {
            let r;
            return e.walkDecls((n) => {
              if (typeof n.raws.before < "u") return r = n.raws.before, r.includes(`
`) && (r = r.replace(/[^\n]+$/, "")), false;
            }), typeof r > "u" ? r = this.raw(s, null, "beforeRule") : r && (r = r.replace(/\S/g, "")), r;
          }
          rawBeforeOpen(e) {
            let s;
            return e.walk((r) => {
              if (r.type !== "decl" && (s = r.raws.between, typeof s < "u")) return false;
            }), s;
          }
          rawBeforeRule(e) {
            let s;
            return e.walk((r) => {
              if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < "u") return s = r.raws.before, s.includes(`
`) && (s = s.replace(/[^\n]+$/, "")), false;
            }), s && (s = s.replace(/\S/g, "")), s;
          }
          rawColon(e) {
            let s;
            return e.walkDecls((r) => {
              if (typeof r.raws.between < "u") return s = r.raws.between.replace(/[^\s:]/g, ""), false;
            }), s;
          }
          rawEmptyBody(e) {
            let s;
            return e.walk((r) => {
              if (r.nodes && r.nodes.length === 0 && (s = r.raws.after, typeof s < "u")) return false;
            }), s;
          }
          rawIndent(e) {
            if (e.raws.indent) return e.raws.indent;
            let s;
            return e.walk((r) => {
              let n = r.parent;
              if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < "u") {
                let i = r.raws.before.split(`
`);
                return s = i[i.length - 1], s = s.replace(/\S/g, ""), false;
              }
            }), s;
          }
          rawSemicolon(e) {
            let s;
            return e.walk((r) => {
              if (r.nodes && r.nodes.length && r.last.type === "decl" && (s = r.raws.semicolon, typeof s < "u")) return false;
            }), s;
          }
          rawValue(e, s) {
            let r = e[s], n = e.raws[s];
            return n && n.value === r ? n.raw : r;
          }
          root(e) {
            this.body(e), e.raws.after && this.builder(e.raws.after);
          }
          rule(e) {
            this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
          }
          stringify(e, s) {
            if (!this[e.type]) throw new Error("Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier.");
            this[e.type](e, s);
          }
        };
        bi2.exports = nt2;
        nt2.default = nt2;
      });
      var it2 = y2((uv2, _i2) => {
        "use strict";
        var cc2 = Wt();
        function ns2(t, e) {
          new cc2(e).stringify(t);
        }
        _i2.exports = ns2;
        ns2.default = ns2;
      });
      var at2 = y2((lv2, ki2) => {
        "use strict";
        var { isClean: Yt, my: fc2 } = Ft2(), pc2 = $t(), hc2 = Wt(), dc2 = it2();
        function is2(t, e) {
          let s = new t.constructor();
          for (let r in t) {
            if (!Object.prototype.hasOwnProperty.call(t, r) || r === "proxyCache") continue;
            let n = t[r], i = typeof n;
            r === "parent" && i === "object" ? e && (s[r] = e) : r === "source" ? s[r] = n : Array.isArray(n) ? s[r] = n.map((o) => is2(o, s)) : (i === "object" && n !== null && (n = is2(n)), s[r] = n);
          }
          return s;
        }
        var ot = class {
          constructor(e = {}) {
            this.raws = {}, this[Yt] = false, this[fc2] = true;
            for (let s in e) if (s === "nodes") {
              this.nodes = [];
              for (let r of e[s]) typeof r.clone == "function" ? this.append(r.clone()) : this.append(r);
            } else this[s] = e[s];
          }
          addToError(e) {
            if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
              let s = this.source;
              e.stack = e.stack.replace(/\n\s{4}at /, `$&${s.input.from}:${s.start.line}:${s.start.column}$&`);
            }
            return e;
          }
          after(e) {
            return this.parent.insertAfter(this, e), this;
          }
          assign(e = {}) {
            for (let s in e) this[s] = e[s];
            return this;
          }
          before(e) {
            return this.parent.insertBefore(this, e), this;
          }
          cleanRaws(e) {
            delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
          }
          clone(e = {}) {
            let s = is2(this);
            for (let r in e) s[r] = e[r];
            return s;
          }
          cloneAfter(e = {}) {
            let s = this.clone(e);
            return this.parent.insertAfter(this, s), s;
          }
          cloneBefore(e = {}) {
            let s = this.clone(e);
            return this.parent.insertBefore(this, s), s;
          }
          error(e, s = {}) {
            if (this.source) {
              let { end: r, start: n } = this.rangeBy(s);
              return this.source.input.error(e, { column: n.column, line: n.line }, { column: r.column, line: r.line }, s);
            }
            return new pc2(e);
          }
          getProxyProcessor() {
            return { get(e, s) {
              return s === "proxyOf" ? e : s === "root" ? () => e.root().toProxy() : e[s];
            }, set(e, s, r) {
              return e[s] === r || (e[s] = r, (s === "prop" || s === "value" || s === "name" || s === "params" || s === "important" || s === "text") && e.markDirty()), true;
            } };
          }
          markDirty() {
            if (this[Yt]) {
              this[Yt] = false;
              let e = this;
              for (; e = e.parent; ) e[Yt] = false;
            }
          }
          next() {
            if (!this.parent) return;
            let e = this.parent.index(this);
            return this.parent.nodes[e + 1];
          }
          positionBy(e, s) {
            let r = this.source.start;
            if (e.index) r = this.positionInside(e.index, s);
            else if (e.word) {
              s = this.toString();
              let n = s.indexOf(e.word);
              n !== -1 && (r = this.positionInside(n, s));
            }
            return r;
          }
          positionInside(e, s) {
            let r = s || this.toString(), n = this.source.start.column, i = this.source.start.line;
            for (let o = 0; o < e; o++) r[o] === `
` ? (n = 1, i += 1) : n += 1;
            return { column: n, line: i };
          }
          prev() {
            if (!this.parent) return;
            let e = this.parent.index(this);
            return this.parent.nodes[e - 1];
          }
          rangeBy(e) {
            let s = { column: this.source.start.column, line: this.source.start.line }, r = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: s.column + 1, line: s.line };
            if (e.word) {
              let n = this.toString(), i = n.indexOf(e.word);
              i !== -1 && (s = this.positionInside(i, n), r = this.positionInside(i + e.word.length, n));
            } else e.start ? s = { column: e.start.column, line: e.start.line } : e.index && (s = this.positionInside(e.index)), e.end ? r = { column: e.end.column, line: e.end.line } : typeof e.endIndex == "number" ? r = this.positionInside(e.endIndex) : e.index && (r = this.positionInside(e.index + 1));
            return (r.line < s.line || r.line === s.line && r.column <= s.column) && (r = { column: s.column + 1, line: s.line }), { end: r, start: s };
          }
          raw(e, s) {
            return new hc2().raw(this, e, s);
          }
          remove() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }
          replaceWith(...e) {
            if (this.parent) {
              let s = this, r = false;
              for (let n of e) n === this ? r = true : r ? (this.parent.insertAfter(s, n), s = n) : this.parent.insertBefore(s, n);
              r || this.remove();
            }
            return this;
          }
          root() {
            let e = this;
            for (; e.parent && e.parent.type !== "document"; ) e = e.parent;
            return e;
          }
          toJSON(e, s) {
            let r = {}, n = s == null;
            s = s || /* @__PURE__ */ new Map();
            let i = 0;
            for (let o in this) {
              if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
              let a = this[o];
              if (Array.isArray(a)) r[o] = a.map((u) => typeof u == "object" && u.toJSON ? u.toJSON(null, s) : u);
              else if (typeof a == "object" && a.toJSON) r[o] = a.toJSON(null, s);
              else if (o === "source") {
                let u = s.get(a.input);
                u == null && (u = i, s.set(a.input, i), i++), r[o] = { end: a.end, inputId: u, start: a.start };
              } else r[o] = a;
            }
            return n && (r.inputs = [...s.keys()].map((o) => o.toJSON())), r;
          }
          toProxy() {
            return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
          }
          toString(e = dc2) {
            e.stringify && (e = e.stringify);
            let s = "";
            return e(this, (r) => {
              s += r;
            }), s;
          }
          warn(e, s, r) {
            let n = { node: this };
            for (let i in r) n[i] = r[i];
            return e.warn(s, n);
          }
          get proxyOf() {
            return this;
          }
        };
        ki2.exports = ot;
        ot.default = ot;
      });
      var lt = y2((cv, Ei2) => {
        "use strict";
        var mc2 = at2(), ut = class extends mc2 {
          constructor(e) {
            e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
          }
          get variable() {
            return this.prop.startsWith("--") || this.prop[0] === "$";
          }
        };
        Ei2.exports = ut;
        ut.default = ut;
      });
      var Oe2 = y2((fv2, Si2) => {
        "use strict";
        var yc2 = at2(), ct = class extends yc2 {
          constructor(e) {
            super(e), this.type = "comment";
          }
        };
        Si2.exports = ct;
        ct.default = ct;
      });
      var re = y2((pv2, qi) => {
        "use strict";
        var { isClean: Ti2, my: Oi2 } = Ft2(), Ci2 = lt(), Ai2 = Oe2(), wc = at2(), Ni2, os2, as, Pi2;
        function Ri2(t) {
          return t.map((e) => (e.nodes && (e.nodes = Ri2(e.nodes)), delete e.source, e));
        }
        function Ii2(t) {
          if (t[Ti2] = false, t.proxyOf.nodes) for (let e of t.proxyOf.nodes) Ii2(e);
        }
        var Y = class t extends wc {
          append(...e) {
            for (let s of e) {
              let r = this.normalize(s, this.last);
              for (let n of r) this.proxyOf.nodes.push(n);
            }
            return this.markDirty(), this;
          }
          cleanRaws(e) {
            if (super.cleanRaws(e), this.nodes) for (let s of this.nodes) s.cleanRaws(e);
          }
          each(e) {
            if (!this.proxyOf.nodes) return;
            let s = this.getIterator(), r, n;
            for (; this.indexes[s] < this.proxyOf.nodes.length && (r = this.indexes[s], n = e(this.proxyOf.nodes[r], r), n !== false); ) this.indexes[s] += 1;
            return delete this.indexes[s], n;
          }
          every(e) {
            return this.nodes.every(e);
          }
          getIterator() {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            let e = this.lastEach;
            return this.indexes[e] = 0, e;
          }
          getProxyProcessor() {
            return { get(e, s) {
              return s === "proxyOf" ? e : e[s] ? s === "each" || typeof s == "string" && s.startsWith("walk") ? (...r) => e[s](...r.map((n) => typeof n == "function" ? (i, o) => n(i.toProxy(), o) : n)) : s === "every" || s === "some" ? (r) => e[s]((n, ...i) => r(n.toProxy(), ...i)) : s === "root" ? () => e.root().toProxy() : s === "nodes" ? e.nodes.map((r) => r.toProxy()) : s === "first" || s === "last" ? e[s].toProxy() : e[s] : e[s];
            }, set(e, s, r) {
              return e[s] === r || (e[s] = r, (s === "name" || s === "params" || s === "selector") && e.markDirty()), true;
            } };
          }
          index(e) {
            return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
          }
          insertAfter(e, s) {
            let r = this.index(e), n = this.normalize(s, this.proxyOf.nodes[r]).reverse();
            r = this.index(e);
            for (let o of n) this.proxyOf.nodes.splice(r + 1, 0, o);
            let i;
            for (let o in this.indexes) i = this.indexes[o], r < i && (this.indexes[o] = i + n.length);
            return this.markDirty(), this;
          }
          insertBefore(e, s) {
            let r = this.index(e), n = r === 0 ? "prepend" : false, i = this.normalize(s, this.proxyOf.nodes[r], n).reverse();
            r = this.index(e);
            for (let a of i) this.proxyOf.nodes.splice(r, 0, a);
            let o;
            for (let a in this.indexes) o = this.indexes[a], r <= o && (this.indexes[a] = o + i.length);
            return this.markDirty(), this;
          }
          normalize(e, s) {
            if (typeof e == "string") e = Ri2(Ni2(e).nodes);
            else if (typeof e > "u") e = [];
            else if (Array.isArray(e)) {
              e = e.slice(0);
              for (let n of e) n.parent && n.parent.removeChild(n, "ignore");
            } else if (e.type === "root" && this.type !== "document") {
              e = e.nodes.slice(0);
              for (let n of e) n.parent && n.parent.removeChild(n, "ignore");
            } else if (e.type) e = [e];
            else if (e.prop) {
              if (typeof e.value > "u") throw new Error("Value field is missed in node creation");
              typeof e.value != "string" && (e.value = String(e.value)), e = [new Ci2(e)];
            } else if (e.selector) e = [new os2(e)];
            else if (e.name) e = [new as(e)];
            else if (e.text) e = [new Ai2(e)];
            else throw new Error("Unknown node type in node creation");
            return e.map((n) => (n[Oi2] || t.rebuild(n), n = n.proxyOf, n.parent && n.parent.removeChild(n), n[Ti2] && Ii2(n), typeof n.raws.before > "u" && s && typeof s.raws.before < "u" && (n.raws.before = s.raws.before.replace(/\S/g, "")), n.parent = this.proxyOf, n));
          }
          prepend(...e) {
            e = e.reverse();
            for (let s of e) {
              let r = this.normalize(s, this.first, "prepend").reverse();
              for (let n of r) this.proxyOf.nodes.unshift(n);
              for (let n in this.indexes) this.indexes[n] = this.indexes[n] + r.length;
            }
            return this.markDirty(), this;
          }
          push(e) {
            return e.parent = this, this.proxyOf.nodes.push(e), this;
          }
          removeAll() {
            for (let e of this.proxyOf.nodes) e.parent = void 0;
            return this.proxyOf.nodes = [], this.markDirty(), this;
          }
          removeChild(e) {
            e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
            let s;
            for (let r in this.indexes) s = this.indexes[r], s >= e && (this.indexes[r] = s - 1);
            return this.markDirty(), this;
          }
          replaceValues(e, s, r) {
            return r || (r = s, s = {}), this.walkDecls((n) => {
              s.props && !s.props.includes(n.prop) || s.fast && !n.value.includes(s.fast) || (n.value = n.value.replace(e, r));
            }), this.markDirty(), this;
          }
          some(e) {
            return this.nodes.some(e);
          }
          walk(e) {
            return this.each((s, r) => {
              let n;
              try {
                n = e(s, r);
              } catch (i) {
                throw s.addToError(i);
              }
              return n !== false && s.walk && (n = s.walk(e)), n;
            });
          }
          walkAtRules(e, s) {
            return s ? e instanceof RegExp ? this.walk((r, n) => {
              if (r.type === "atrule" && e.test(r.name)) return s(r, n);
            }) : this.walk((r, n) => {
              if (r.type === "atrule" && r.name === e) return s(r, n);
            }) : (s = e, this.walk((r, n) => {
              if (r.type === "atrule") return s(r, n);
            }));
          }
          walkComments(e) {
            return this.walk((s, r) => {
              if (s.type === "comment") return e(s, r);
            });
          }
          walkDecls(e, s) {
            return s ? e instanceof RegExp ? this.walk((r, n) => {
              if (r.type === "decl" && e.test(r.prop)) return s(r, n);
            }) : this.walk((r, n) => {
              if (r.type === "decl" && r.prop === e) return s(r, n);
            }) : (s = e, this.walk((r, n) => {
              if (r.type === "decl") return s(r, n);
            }));
          }
          walkRules(e, s) {
            return s ? e instanceof RegExp ? this.walk((r, n) => {
              if (r.type === "rule" && e.test(r.selector)) return s(r, n);
            }) : this.walk((r, n) => {
              if (r.type === "rule" && r.selector === e) return s(r, n);
            }) : (s = e, this.walk((r, n) => {
              if (r.type === "rule") return s(r, n);
            }));
          }
          get first() {
            if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
          }
          get last() {
            if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
          }
        };
        Y.registerParse = (t) => {
          Ni2 = t;
        };
        Y.registerRule = (t) => {
          os2 = t;
        };
        Y.registerAtRule = (t) => {
          as = t;
        };
        Y.registerRoot = (t) => {
          Pi2 = t;
        };
        qi.exports = Y;
        Y.default = Y;
        Y.rebuild = (t) => {
          t.type === "atrule" ? Object.setPrototypeOf(t, as.prototype) : t.type === "rule" ? Object.setPrototypeOf(t, os2.prototype) : t.type === "decl" ? Object.setPrototypeOf(t, Ci2.prototype) : t.type === "comment" ? Object.setPrototypeOf(t, Ai2.prototype) : t.type === "root" && Object.setPrototypeOf(t, Pi2.prototype), t[Oi2] = true, t.nodes && t.nodes.forEach((e) => {
            Y.rebuild(e);
          });
        };
      });
      var Gt3 = y2((hv2, Di2) => {
        "use strict";
        var zt = /[\t\n\f\r "#'()/;[\\\]{}]/g, Vt2 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, gc2 = /.[\r\n"'(/\\]/, Li2 = /[\da-f]/i;
        Di2.exports = function(e, s = {}) {
          let r = e.css.valueOf(), n = s.ignoreErrors, i, o, a, u, c, f, p, l, w, x, h = r.length, d2 = 0, m = [], b = [];
          function g() {
            return d2;
          }
          function v2($) {
            throw e.error("Unclosed " + $, d2);
          }
          function R() {
            return b.length === 0 && d2 >= h;
          }
          function F($) {
            if (b.length) return b.pop();
            if (d2 >= h) return;
            let T3 = $ ? $.ignoreUnclosed : false;
            switch (i = r.charCodeAt(d2), i) {
              case 10:
              case 32:
              case 9:
              case 13:
              case 12: {
                o = d2;
                do
                  o += 1, i = r.charCodeAt(o);
                while (i === 32 || i === 10 || i === 9 || i === 13 || i === 12);
                x = ["space", r.slice(d2, o)], d2 = o - 1;
                break;
              }
              case 91:
              case 93:
              case 123:
              case 125:
              case 58:
              case 59:
              case 41: {
                let O = String.fromCharCode(i);
                x = [O, O, d2];
                break;
              }
              case 40: {
                if (l = m.length ? m.pop()[1] : "", w = r.charCodeAt(d2 + 1), l === "url" && w !== 39 && w !== 34 && w !== 32 && w !== 10 && w !== 9 && w !== 12 && w !== 13) {
                  o = d2;
                  do {
                    if (f = false, o = r.indexOf(")", o + 1), o === -1) if (n || T3) {
                      o = d2;
                      break;
                    } else v2("bracket");
                    for (p = o; r.charCodeAt(p - 1) === 92; ) p -= 1, f = !f;
                  } while (f);
                  x = ["brackets", r.slice(d2, o + 1), d2, o], d2 = o;
                } else o = r.indexOf(")", d2 + 1), u = r.slice(d2, o + 1), o === -1 || gc2.test(u) ? x = ["(", "(", d2] : (x = ["brackets", u, d2, o], d2 = o);
                break;
              }
              case 39:
              case 34: {
                a = i === 39 ? "'" : '"', o = d2;
                do {
                  if (f = false, o = r.indexOf(a, o + 1), o === -1) if (n || T3) {
                    o = d2 + 1;
                    break;
                  } else v2("string");
                  for (p = o; r.charCodeAt(p - 1) === 92; ) p -= 1, f = !f;
                } while (f);
                x = ["string", r.slice(d2, o + 1), d2, o], d2 = o;
                break;
              }
              case 64: {
                zt.lastIndex = d2 + 1, zt.test(r), zt.lastIndex === 0 ? o = r.length - 1 : o = zt.lastIndex - 2, x = ["at-word", r.slice(d2, o + 1), d2, o], d2 = o;
                break;
              }
              case 92: {
                for (o = d2, c = true; r.charCodeAt(o + 1) === 92; ) o += 1, c = !c;
                if (i = r.charCodeAt(o + 1), c && i !== 47 && i !== 32 && i !== 10 && i !== 9 && i !== 13 && i !== 12 && (o += 1, Li2.test(r.charAt(o)))) {
                  for (; Li2.test(r.charAt(o + 1)); ) o += 1;
                  r.charCodeAt(o + 1) === 32 && (o += 1);
                }
                x = ["word", r.slice(d2, o + 1), d2, o], d2 = o;
                break;
              }
              default: {
                i === 47 && r.charCodeAt(d2 + 1) === 42 ? (o = r.indexOf("*/", d2 + 2) + 1, o === 0 && (n || T3 ? o = r.length : v2("comment")), x = ["comment", r.slice(d2, o + 1), d2, o], d2 = o) : (Vt2.lastIndex = d2 + 1, Vt2.test(r), Vt2.lastIndex === 0 ? o = r.length - 1 : o = Vt2.lastIndex - 2, x = ["word", r.slice(d2, o + 1), d2, o], m.push(x), d2 = o);
                break;
              }
            }
            return d2++, x;
          }
          function H($) {
            b.push($);
          }
          return { back: H, endOfFile: R, nextToken: F, position: g };
        };
      });
      var jt = y2((dv2, Bi) => {
        "use strict";
        var Mi2 = re(), Ce = class extends Mi2 {
          constructor(e) {
            super(e), this.type = "atrule";
          }
          append(...e) {
            return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
          }
          prepend(...e) {
            return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
          }
        };
        Bi.exports = Ce;
        Ce.default = Ce;
        Mi2.registerAtRule(Ce);
      });
      var Ae = y2((mv2, Wi2) => {
        "use strict";
        var Ui2 = re(), Fi2, $i2, se = class extends Ui2 {
          constructor(e) {
            super(e), this.type = "root", this.nodes || (this.nodes = []);
          }
          normalize(e, s, r) {
            let n = super.normalize(e);
            if (s) {
              if (r === "prepend") this.nodes.length > 1 ? s.raws.before = this.nodes[1].raws.before : delete s.raws.before;
              else if (this.first !== s) for (let i of n) i.raws.before = s.raws.before;
            }
            return n;
          }
          removeChild(e, s) {
            let r = this.index(e);
            return !s && r === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
          }
          toResult(e = {}) {
            return new Fi2(new $i2(), this, e).stringify();
          }
        };
        se.registerLazyResult = (t) => {
          Fi2 = t;
        };
        se.registerProcessor = (t) => {
          $i2 = t;
        };
        Wi2.exports = se;
        se.default = se;
        Ui2.registerRoot(se);
      });
      var us3 = y2((yv2, Yi2) => {
        "use strict";
        var ft2 = { comma(t) {
          return ft2.split(t, [","], true);
        }, space(t) {
          let e = [" ", `
`, "	"];
          return ft2.split(t, e);
        }, split(t, e, s) {
          let r = [], n = "", i = false, o = 0, a = false, u = "", c = false;
          for (let f of t) c ? c = false : f === "\\" ? c = true : a ? f === u && (a = false) : f === '"' || f === "'" ? (a = true, u = f) : f === "(" ? o += 1 : f === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(f) && (i = true), i ? (n !== "" && r.push(n.trim()), n = "", i = false) : n += f;
          return (s || n !== "") && r.push(n.trim()), r;
        } };
        Yi2.exports = ft2;
        ft2.default = ft2;
      });
      var Ht2 = y2((wv2, Vi) => {
        "use strict";
        var zi2 = re(), vc2 = us3(), Ne2 = class extends zi2 {
          constructor(e) {
            super(e), this.type = "rule", this.nodes || (this.nodes = []);
          }
          get selectors() {
            return vc2.comma(this.selector);
          }
          set selectors(e) {
            let s = this.selector ? this.selector.match(/,\s*/) : null, r = s ? s[0] : "," + this.raw("between", "beforeOpen");
            this.selector = e.join(r);
          }
        };
        Vi.exports = Ne2;
        Ne2.default = Ne2;
        zi2.registerRule(Ne2);
      });
      var Kt2 = y2((gv2, Hi2) => {
        "use strict";
        var xc2 = lt(), bc2 = Gt3(), _c2 = Oe2(), kc = jt(), Ec2 = Ae(), Gi2 = Ht2(), ji = { empty: true, space: true };
        function Sc2(t) {
          for (let e = t.length - 1; e >= 0; e--) {
            let s = t[e], r = s[3] || s[2];
            if (r) return r;
          }
        }
        var ls2 = class {
          constructor(e) {
            this.input = e, this.root = new Ec2(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } };
          }
          atrule(e) {
            let s = new kc();
            s.name = e[1].slice(1), s.name === "" && this.unnamedAtrule(s, e), this.init(s, e[2]);
            let r, n, i, o = false, a = false, u = [], c = [];
            for (; !this.tokenizer.endOfFile(); ) {
              if (e = this.tokenizer.nextToken(), r = e[0], r === "(" || r === "[" ? c.push(r === "(" ? ")" : "]") : r === "{" && c.length > 0 ? c.push("}") : r === c[c.length - 1] && c.pop(), c.length === 0) if (r === ";") {
                s.source.end = this.getPosition(e[2]), s.source.end.offset++, this.semicolon = true;
                break;
              } else if (r === "{") {
                a = true;
                break;
              } else if (r === "}") {
                if (u.length > 0) {
                  for (i = u.length - 1, n = u[i]; n && n[0] === "space"; ) n = u[--i];
                  n && (s.source.end = this.getPosition(n[3] || n[2]), s.source.end.offset++);
                }
                this.end(e);
                break;
              } else u.push(e);
              else u.push(e);
              if (this.tokenizer.endOfFile()) {
                o = true;
                break;
              }
            }
            s.raws.between = this.spacesAndCommentsFromEnd(u), u.length ? (s.raws.afterName = this.spacesAndCommentsFromStart(u), this.raw(s, "params", u), o && (e = u[u.length - 1], s.source.end = this.getPosition(e[3] || e[2]), s.source.end.offset++, this.spaces = s.raws.between, s.raws.between = "")) : (s.raws.afterName = "", s.params = ""), a && (s.nodes = [], this.current = s);
          }
          checkMissedSemicolon(e) {
            let s = this.colon(e);
            if (s === false) return;
            let r = 0, n;
            for (let i = s - 1; i >= 0 && (n = e[i], !(n[0] !== "space" && (r += 1, r === 2))); i--) ;
            throw this.input.error("Missed semicolon", n[0] === "word" ? n[3] + 1 : n[2]);
          }
          colon(e) {
            let s = 0, r, n, i;
            for (let [o, a] of e.entries()) {
              if (r = a, n = r[0], n === "(" && (s += 1), n === ")" && (s -= 1), s === 0 && n === ":") if (!i) this.doubleColon(r);
              else {
                if (i[0] === "word" && i[1] === "progid") continue;
                return o;
              }
              i = r;
            }
            return false;
          }
          comment(e) {
            let s = new _c2();
            this.init(s, e[2]), s.source.end = this.getPosition(e[3] || e[2]), s.source.end.offset++;
            let r = e[1].slice(2, -2);
            if (/^\s*$/.test(r)) s.text = "", s.raws.left = r, s.raws.right = "";
            else {
              let n = r.match(/^(\s*)([^]*\S)(\s*)$/);
              s.text = n[2], s.raws.left = n[1], s.raws.right = n[3];
            }
          }
          createTokenizer() {
            this.tokenizer = bc2(this.input);
          }
          decl(e, s) {
            let r = new xc2();
            this.init(r, e[0][2]);
            let n = e[e.length - 1];
            for (n[0] === ";" && (this.semicolon = true, e.pop()), r.source.end = this.getPosition(n[3] || n[2] || Sc2(e)), r.source.end.offset++; e[0][0] !== "word"; ) e.length === 1 && this.unknownWord(e), r.raws.before += e.shift()[1];
            for (r.source.start = this.getPosition(e[0][2]), r.prop = ""; e.length; ) {
              let c = e[0][0];
              if (c === ":" || c === "space" || c === "comment") break;
              r.prop += e.shift()[1];
            }
            r.raws.between = "";
            let i;
            for (; e.length; ) if (i = e.shift(), i[0] === ":") {
              r.raws.between += i[1];
              break;
            } else i[0] === "word" && /\w/.test(i[1]) && this.unknownWord([i]), r.raws.between += i[1];
            (r.prop[0] === "_" || r.prop[0] === "*") && (r.raws.before += r.prop[0], r.prop = r.prop.slice(1));
            let o = [], a;
            for (; e.length && (a = e[0][0], !(a !== "space" && a !== "comment")); ) o.push(e.shift());
            this.precheckMissedSemicolon(e);
            for (let c = e.length - 1; c >= 0; c--) {
              if (i = e[c], i[1].toLowerCase() === "!important") {
                r.important = true;
                let f = this.stringFrom(e, c);
                f = this.spacesFromEnd(e) + f, f !== " !important" && (r.raws.important = f);
                break;
              } else if (i[1].toLowerCase() === "important") {
                let f = e.slice(0), p = "";
                for (let l = c; l > 0; l--) {
                  let w = f[l][0];
                  if (p.trim().indexOf("!") === 0 && w !== "space") break;
                  p = f.pop()[1] + p;
                }
                p.trim().indexOf("!") === 0 && (r.important = true, r.raws.important = p, e = f);
              }
              if (i[0] !== "space" && i[0] !== "comment") break;
            }
            e.some((c) => c[0] !== "space" && c[0] !== "comment") && (r.raws.between += o.map((c) => c[1]).join(""), o = []), this.raw(r, "value", o.concat(e), s), r.value.includes(":") && !s && this.checkMissedSemicolon(e);
          }
          doubleColon(e) {
            throw this.input.error("Double colon", { offset: e[2] }, { offset: e[2] + e[1].length });
          }
          emptyRule(e) {
            let s = new Gi2();
            this.init(s, e[2]), s.selector = "", s.raws.between = "", this.current = s;
          }
          end(e) {
            this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e);
          }
          endFile() {
            this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
          }
          freeSemicolon(e) {
            if (this.spaces += e[1], this.current.nodes) {
              let s = this.current.nodes[this.current.nodes.length - 1];
              s && s.type === "rule" && !s.raws.ownSemicolon && (s.raws.ownSemicolon = this.spaces, this.spaces = "");
            }
          }
          getPosition(e) {
            let s = this.input.fromOffset(e);
            return { column: s.col, line: s.line, offset: e };
          }
          init(e, s) {
            this.current.push(e), e.source = { input: this.input, start: this.getPosition(s) }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = false);
          }
          other(e) {
            let s = false, r = null, n = false, i = null, o = [], a = e[1].startsWith("--"), u = [], c = e;
            for (; c; ) {
              if (r = c[0], u.push(c), r === "(" || r === "[") i || (i = c), o.push(r === "(" ? ")" : "]");
              else if (a && n && r === "{") i || (i = c), o.push("}");
              else if (o.length === 0) if (r === ";") if (n) {
                this.decl(u, a);
                return;
              } else break;
              else if (r === "{") {
                this.rule(u);
                return;
              } else if (r === "}") {
                this.tokenizer.back(u.pop()), s = true;
                break;
              } else r === ":" && (n = true);
              else r === o[o.length - 1] && (o.pop(), o.length === 0 && (i = null));
              c = this.tokenizer.nextToken();
            }
            if (this.tokenizer.endOfFile() && (s = true), o.length > 0 && this.unclosedBracket(i), s && n) {
              if (!a) for (; u.length && (c = u[u.length - 1][0], !(c !== "space" && c !== "comment")); ) this.tokenizer.back(u.pop());
              this.decl(u, a);
            } else this.unknownWord(u);
          }
          parse() {
            let e;
            for (; !this.tokenizer.endOfFile(); ) switch (e = this.tokenizer.nextToken(), e[0]) {
              case "space":
                this.spaces += e[1];
                break;
              case ";":
                this.freeSemicolon(e);
                break;
              case "}":
                this.end(e);
                break;
              case "comment":
                this.comment(e);
                break;
              case "at-word":
                this.atrule(e);
                break;
              case "{":
                this.emptyRule(e);
                break;
              default:
                this.other(e);
                break;
            }
            this.endFile();
          }
          precheckMissedSemicolon() {
          }
          raw(e, s, r, n) {
            let i, o, a = r.length, u = "", c = true, f, p;
            for (let l = 0; l < a; l += 1) i = r[l], o = i[0], o === "space" && l === a - 1 && !n ? c = false : o === "comment" ? (p = r[l - 1] ? r[l - 1][0] : "empty", f = r[l + 1] ? r[l + 1][0] : "empty", !ji[p] && !ji[f] ? u.slice(-1) === "," ? c = false : u += i[1] : c = false) : u += i[1];
            if (!c) {
              let l = r.reduce((w, x) => w + x[1], "");
              e.raws[s] = { raw: l, value: u };
            }
            e[s] = u;
          }
          rule(e) {
            e.pop();
            let s = new Gi2();
            this.init(s, e[0][2]), s.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(s, "selector", e), this.current = s;
          }
          spacesAndCommentsFromEnd(e) {
            let s, r = "";
            for (; e.length && (s = e[e.length - 1][0], !(s !== "space" && s !== "comment")); ) r = e.pop()[1] + r;
            return r;
          }
          spacesAndCommentsFromStart(e) {
            let s, r = "";
            for (; e.length && (s = e[0][0], !(s !== "space" && s !== "comment")); ) r += e.shift()[1];
            return r;
          }
          spacesFromEnd(e) {
            let s, r = "";
            for (; e.length && (s = e[e.length - 1][0], s === "space"); ) r = e.pop()[1] + r;
            return r;
          }
          stringFrom(e, s) {
            let r = "";
            for (let n = s; n < e.length; n++) r += e[n][1];
            return e.splice(s, e.length - s), r;
          }
          unclosedBlock() {
            let e = this.current.source.start;
            throw this.input.error("Unclosed block", e.line, e.column);
          }
          unclosedBracket(e) {
            throw this.input.error("Unclosed bracket", { offset: e[2] }, { offset: e[2] + 1 });
          }
          unexpectedClose(e) {
            throw this.input.error("Unexpected }", { offset: e[2] }, { offset: e[2] + 1 });
          }
          unknownWord(e) {
            throw this.input.error("Unknown word", { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
          }
          unnamedAtrule(e, s) {
            throw this.input.error("At-rule without name", { offset: s[2] }, { offset: s[2] + s[1].length });
          }
        };
        Hi2.exports = ls2;
      });
      var Ki2 = y2(() => {
      });
      var Ji = y2((bv2, Qi) => {
        var Tc2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Oc2 = (t, e = 21) => (s = e) => {
          let r = "", n = s;
          for (; n--; ) r += t[Math.random() * t.length | 0];
          return r;
        }, Cc2 = (t = 21) => {
          let e = "", s = t;
          for (; s--; ) e += Tc2[Math.random() * 64 | 0];
          return e;
        };
        Qi.exports = { nanoid: Cc2, customAlphabet: Oc2 };
      });
      var cs2 = y2((_v2, Xi2) => {
        Xi2.exports = class {
        };
      });
      var Re = y2((Ev2, ro2) => {
        "use strict";
        var { SourceMapConsumer: Ac2, SourceMapGenerator: Nc2 } = Ki2(), { fileURLToPath: Zi2, pathToFileURL: Qt2 } = {}, { isAbsolute: hs2, resolve: ds2 } = {}, { nanoid: Pc2 } = Ji(), fs2 = ss2(), eo2 = $t(), Rc2 = cs2(), ps2 = Symbol("fromOffsetCache"), Ic2 = !!(Ac2 && Nc2), to2 = !!(ds2 && hs2), Pe = class {
          constructor(e, s = {}) {
            if (e === null || typeof e > "u" || typeof e == "object" && !e.toString) throw new Error(`PostCSS received ${e} instead of CSS string`);
            if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, s.from && (!to2 || /^\w+:\/\//.test(s.from) || hs2(s.from) ? this.file = s.from : this.file = ds2(s.from)), to2 && Ic2) {
              let r = new Rc2(this.css, s);
              if (r.text) {
                this.map = r;
                let n = r.consumer().file;
                !this.file && n && (this.file = this.mapResolve(n));
              }
            }
            this.file || (this.id = "<input css " + Pc2(6) + ">"), this.map && (this.map.file = this.from);
          }
          error(e, s, r, n = {}) {
            let i, o, a;
            if (s && typeof s == "object") {
              let c = s, f = r;
              if (typeof c.offset == "number") {
                let p = this.fromOffset(c.offset);
                s = p.line, r = p.col;
              } else s = c.line, r = c.column;
              if (typeof f.offset == "number") {
                let p = this.fromOffset(f.offset);
                o = p.line, a = p.col;
              } else o = f.line, a = f.column;
            } else if (!r) {
              let c = this.fromOffset(s);
              s = c.line, r = c.col;
            }
            let u = this.origin(s, r, o, a);
            return u ? i = new eo2(e, u.endLine === void 0 ? u.line : { column: u.column, line: u.line }, u.endLine === void 0 ? u.column : { column: u.endColumn, line: u.endLine }, u.source, u.file, n.plugin) : i = new eo2(e, o === void 0 ? s : { column: r, line: s }, o === void 0 ? r : { column: a, line: o }, this.css, this.file, n.plugin), i.input = { column: r, endColumn: a, endLine: o, line: s, source: this.css }, this.file && (Qt2 && (i.input.url = Qt2(this.file).toString()), i.input.file = this.file), i;
          }
          fromOffset(e) {
            let s, r;
            if (this[ps2]) r = this[ps2];
            else {
              let i = this.css.split(`
`);
              r = new Array(i.length);
              let o = 0;
              for (let a = 0, u = i.length; a < u; a++) r[a] = o, o += i[a].length + 1;
              this[ps2] = r;
            }
            s = r[r.length - 1];
            let n = 0;
            if (e >= s) n = r.length - 1;
            else {
              let i = r.length - 2, o;
              for (; n < i; ) if (o = n + (i - n >> 1), e < r[o]) i = o - 1;
              else if (e >= r[o + 1]) n = o + 1;
              else {
                n = o;
                break;
              }
            }
            return { col: e - r[n] + 1, line: n + 1 };
          }
          mapResolve(e) {
            return /^\w+:\/\//.test(e) ? e : ds2(this.map.consumer().sourceRoot || this.map.root || ".", e);
          }
          origin(e, s, r, n) {
            if (!this.map) return false;
            let i = this.map.consumer(), o = i.originalPositionFor({ column: s, line: e });
            if (!o.source) return false;
            let a;
            typeof r == "number" && (a = i.originalPositionFor({ column: n, line: r }));
            let u;
            hs2(o.source) ? u = Qt2(o.source) : u = new URL(o.source, this.map.consumer().sourceRoot || Qt2(this.map.mapFile));
            let c = { column: o.column, endColumn: a && a.column, endLine: a && a.line, line: o.line, url: u.toString() };
            if (u.protocol === "file:") if (Zi2) c.file = Zi2(u);
            else throw new Error("file: protocol is not available in this PostCSS build");
            let f = i.sourceContentFor(o.source);
            return f && (c.source = f), c;
          }
          toJSON() {
            let e = {};
            for (let s of ["hasBOM", "css", "file", "id"]) this[s] != null && (e[s] = this[s]);
            return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
          }
          get from() {
            return this.file || this.id;
          }
        };
        ro2.exports = Pe;
        Pe.default = Pe;
        fs2 && fs2.registerInput && fs2.registerInput(Pe);
      });
      var pt2 = y2((Sv2, so2) => {
        "use strict";
        var qc2 = re(), Lc2 = Kt2(), Dc2 = Re();
        function Jt2(t, e) {
          let s = new Dc2(t, e), r = new Lc2(s);
          try {
            r.parse();
          } catch (n) {
            throw n;
          }
          return r.root;
        }
        so2.exports = Jt2;
        Jt2.default = Jt2;
        qc2.registerParse(Jt2);
      });
      var no2 = y2((Tv2, ms2) => {
        var Mc = Gt3(), Bc = Re();
        ms2.exports = { isInlineComment(t) {
          if (t[0] === "word" && t[1].slice(0, 2) === "//") {
            let e = t, s = [], r, n;
            for (; t; ) {
              if (/\r?\n/.test(t[1])) {
                if (/['"].*\r?\n/.test(t[1])) {
                  s.push(t[1].substring(0, t[1].indexOf(`
`))), n = t[1].substring(t[1].indexOf(`
`));
                  let o = this.input.css.valueOf().substring(this.tokenizer.position());
                  n += o, r = t[3] + o.length - n.length;
                } else this.tokenizer.back(t);
                break;
              }
              s.push(t[1]), r = t[2], t = this.tokenizer.nextToken({ ignoreUnclosed: true });
            }
            let i = ["comment", s.join(""), e[2], r];
            return this.inlineComment(i), n && (this.input = new Bc(n), this.tokenizer = Mc(this.input)), true;
          } else if (t[1] === "/") {
            let e = this.tokenizer.nextToken({ ignoreUnclosed: true });
            if (e[0] === "comment" && /^\/\*/.test(e[1])) return e[0] = "word", e[1] = e[1].slice(1), t[1] = "//", this.tokenizer.back(e), ms2.exports.isInlineComment.bind(this)(t);
          }
          return false;
        } };
      });
      var oo2 = y2((Ov2, io2) => {
        io2.exports = { interpolation(t) {
          let e = [t, this.tokenizer.nextToken()], s = ["word", "}"];
          if (e[0][1].length > 1 || e[1][0] !== "{") return this.tokenizer.back(e[1]), false;
          for (t = this.tokenizer.nextToken(); t && s.includes(t[0]); ) e.push(t), t = this.tokenizer.nextToken();
          let r = e.map((a) => a[1]), [n] = e, i = e.pop(), o = ["word", r.join(""), n[2], i[2]];
          return this.tokenizer.back(t), this.tokenizer.back(o), true;
        } };
      });
      var uo2 = y2((Cv2, ao2) => {
        var Uc = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, Fc2 = /\.[0-9]/, $c2 = (t) => {
          let [, e] = t, [s] = e;
          return (s === "." || s === "#") && Uc.test(e) === false && Fc2.test(e) === false;
        };
        ao2.exports = { isMixinToken: $c2 };
      });
      var co2 = y2((Av2, lo2) => {
        var Wc2 = Gt3(), Yc2 = /^url\((.+)\)/;
        lo2.exports = (t) => {
          let { name: e, params: s = "" } = t;
          if (e === "import" && s.length) {
            t.import = true;
            let r = Wc2({ css: s });
            for (t.filename = s.replace(Yc2, "$1"); !r.endOfFile(); ) {
              let [n, i] = r.nextToken();
              if (n === "word" && i === "url") return;
              if (n === "brackets") {
                t.options = i, t.filename = s.replace(i, "").trim();
                break;
              }
            }
          }
        };
      });
      var mo2 = y2((Nv2, ho2) => {
        var fo2 = /:$/, po2 = /^:(\s+)?/;
        ho2.exports = (t) => {
          let { name: e, params: s = "" } = t;
          if (t.name.slice(-1) === ":") {
            if (fo2.test(e)) {
              let [r] = e.match(fo2);
              t.name = e.replace(r, ""), t.raws.afterName = r + (t.raws.afterName || ""), t.variable = true, t.value = t.params;
            }
            if (po2.test(s)) {
              let [r] = s.match(po2);
              t.value = s.replace(r, ""), t.raws.afterName = (t.raws.afterName || "") + r, t.variable = true;
            }
          }
        };
      });
      var go2 = y2((Rv2, wo2) => {
        var zc2 = Oe2(), Vc = Kt2(), { isInlineComment: Gc } = no2(), { interpolation: yo2 } = oo2(), { isMixinToken: jc2 } = uo2(), Hc2 = co2(), Kc2 = mo2(), Qc = /(!\s*important)$/i;
        wo2.exports = class extends Vc {
          constructor(...e) {
            super(...e), this.lastNode = null;
          }
          atrule(e) {
            yo2.bind(this)(e) || (super.atrule(e), Hc2(this.lastNode), Kc2(this.lastNode));
          }
          decl(...e) {
            super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
          }
          each(e) {
            e[0][1] = ` ${e[0][1]}`;
            let s = e.findIndex((a) => a[0] === "("), r = e.reverse().find((a) => a[0] === ")"), n = e.reverse().indexOf(r), o = e.splice(s, n).map((a) => a[1]).join("");
            for (let a of e.reverse()) this.tokenizer.back(a);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = o;
          }
          init(e, s, r) {
            super.init(e, s, r), this.lastNode = e;
          }
          inlineComment(e) {
            let s = new zc2(), r = e[1].slice(2);
            if (this.init(s, e[2]), s.source.end = this.getPosition(e[3] || e[2]), s.inline = true, s.raws.begin = "//", /^\s*$/.test(r)) s.text = "", s.raws.left = r, s.raws.right = "";
            else {
              let n = r.match(/^(\s*)([^]*[^\s])(\s*)$/);
              [, s.raws.left, s.text, s.raws.right] = n;
            }
          }
          mixin(e) {
            let [s] = e, r = s[1].slice(0, 1), n = e.findIndex((c) => c[0] === "brackets"), i = e.findIndex((c) => c[0] === "("), o = "";
            if ((n < 0 || n > 3) && i > 0) {
              let c = e.reduce((g, v2, R) => v2[0] === ")" ? R : g), p = e.slice(i, c + i).map((g) => g[1]).join(""), [l] = e.slice(i), w = [l[2], l[3]], [x] = e.slice(c, c + 1), h = [x[2], x[3]], d2 = ["brackets", p].concat(w, h), m = e.slice(0, i), b = e.slice(c + 1);
              e = m, e.push(d2), e = e.concat(b);
            }
            let a = [];
            for (let c of e) if ((c[1] === "!" || a.length) && a.push(c), c[1] === "important") break;
            if (a.length) {
              let [c] = a, f = e.indexOf(c), p = a[a.length - 1], l = [c[2], c[3]], w = [p[4], p[5]], h = ["word", a.map((d2) => d2[1]).join("")].concat(l, w);
              e.splice(f, a.length, h);
            }
            let u = e.findIndex((c) => Qc.test(c[1]));
            u > 0 && ([, o] = e[u], e.splice(u, 1));
            for (let c of e.reverse()) this.tokenizer.back(c);
            this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = r, o && (this.lastNode.important = true, this.lastNode.raws.important = o);
          }
          other(e) {
            Gc.bind(this)(e) || super.other(e);
          }
          rule(e) {
            let s = e[e.length - 1], r = e[e.length - 2];
            if (r[0] === "at-word" && s[0] === "{" && (this.tokenizer.back(s), yo2.bind(this)(r))) {
              let i = this.tokenizer.nextToken();
              e = e.slice(0, e.length - 2).concat([i]);
              for (let o of e.reverse()) this.tokenizer.back(o);
              return;
            }
            super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
          }
          unknownWord(e) {
            let [s] = e;
            if (e[0][1] === "each" && e[1][0] === "(") {
              this.each(e);
              return;
            }
            if (jc2(s)) {
              this.mixin(e);
              return;
            }
            super.unknownWord(e);
          }
        };
      });
      var xo2 = y2((qv2, vo2) => {
        var Jc2 = Wt();
        vo2.exports = class extends Jc2 {
          atrule(e, s) {
            if (!e.mixin && !e.variable && !e.function) {
              super.atrule(e, s);
              return;
            }
            let n = `${e.function ? "" : e.raws.identifier || "@"}${e.name}`, i = e.params ? this.rawValue(e, "params") : "", o = e.raws.important || "";
            if (e.variable && (i = e.value), typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes) this.block(e, n + i + o);
            else {
              let a = (e.raws.between || "") + o + (s ? ";" : "");
              this.builder(n + i + a, e);
            }
          }
          comment(e) {
            if (e.inline) {
              let s = this.raw(e, "left", "commentLeft"), r = this.raw(e, "right", "commentRight");
              this.builder(`//${s}${e.text}${r}`, e);
            } else super.comment(e);
          }
        };
      });
      var bo2 = y2((Lv2, ys2) => {
        var Xc2 = Re(), Zc2 = go2(), ef2 = xo2();
        ys2.exports = { parse(t, e) {
          let s = new Xc2(t, e), r = new Zc2(s);
          return r.parse(), r.root.walk((n) => {
            let i = s.css.lastIndexOf(n.source.input.css);
            if (i === 0) return;
            if (i + n.source.input.css.length !== s.css.length) throw new Error("Invalid state detected in postcss-less");
            let o = i + n.source.start.offset, a = s.fromOffset(i + n.source.start.offset);
            if (n.source.start = { offset: o, line: a.line, column: a.col }, n.source.end) {
              let u = i + n.source.end.offset, c = s.fromOffset(i + n.source.end.offset);
              n.source.end = { offset: u, line: c.line, column: c.col };
            }
          }), r.root;
        }, stringify(t, e) {
          new ef2(e).stringify(t);
        }, nodeToString(t) {
          let e = "";
          return ys2.exports.stringify(t, (s) => {
            e += s;
          }), e;
        } };
      });
      var ws2 = y2((Dv2, _o2) => {
        _o2.exports = class {
          generate() {
          }
        };
      });
      var Xt2 = y2((Bv2, So2) => {
        "use strict";
        var tf2 = re(), ko2, Eo2, pe = class extends tf2 {
          constructor(e) {
            super({ type: "document", ...e }), this.nodes || (this.nodes = []);
          }
          toResult(e = {}) {
            return new ko2(new Eo2(), this, e).stringify();
          }
        };
        pe.registerLazyResult = (t) => {
          ko2 = t;
        };
        pe.registerProcessor = (t) => {
          Eo2 = t;
        };
        So2.exports = pe;
        pe.default = pe;
      });
      var gs3 = y2((Uv2, Oo) => {
        "use strict";
        var To = {};
        Oo.exports = function(e) {
          To[e] || (To[e] = true, typeof console < "u" && console.warn && console.warn(e));
        };
      });
      var vs2 = y2((Fv2, Co2) => {
        "use strict";
        var ht2 = class {
          constructor(e, s = {}) {
            if (this.type = "warning", this.text = e, s.node && s.node.source) {
              let r = s.node.rangeBy(s);
              this.line = r.start.line, this.column = r.start.column, this.endLine = r.end.line, this.endColumn = r.end.column;
            }
            for (let r in s) this[r] = s[r];
          }
          toString() {
            return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
          }
        };
        Co2.exports = ht2;
        ht2.default = ht2;
      });
      var Zt2 = y2(($v2, Ao3) => {
        "use strict";
        var rf2 = vs2(), dt2 = class {
          constructor(e, s, r) {
            this.processor = e, this.messages = [], this.root = s, this.opts = r, this.css = void 0, this.map = void 0;
          }
          toString() {
            return this.css;
          }
          warn(e, s = {}) {
            s.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (s.plugin = this.lastPlugin.postcssPlugin);
            let r = new rf2(e, s);
            return this.messages.push(r), r;
          }
          warnings() {
            return this.messages.filter((e) => e.type === "warning");
          }
          get content() {
            return this.css;
          }
        };
        Ao3.exports = dt2;
        dt2.default = dt2;
      });
      var _s2 = y2((Yv2, Io2) => {
        "use strict";
        var { isClean: j, my: sf2 } = Ft2(), nf3 = ws2(), of2 = it2(), af3 = re(), uf2 = Xt2(), Wv2 = gs3(), No2 = Zt2(), lf2 = pt2(), cf3 = Ae(), ff2 = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, pf2 = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, hf2 = { Once: true, postcssPlugin: true, prepare: true }, Ie = 0;
        function mt(t) {
          return typeof t == "object" && typeof t.then == "function";
        }
        function Ro2(t) {
          let e = false, s = ff2[t.type];
          return t.type === "decl" ? e = t.prop.toLowerCase() : t.type === "atrule" && (e = t.name.toLowerCase()), e && t.append ? [s, s + "-" + e, Ie, s + "Exit", s + "Exit-" + e] : e ? [s, s + "-" + e, s + "Exit", s + "Exit-" + e] : t.append ? [s, Ie, s + "Exit"] : [s, s + "Exit"];
        }
        function Po2(t) {
          let e;
          return t.type === "document" ? e = ["Document", Ie, "DocumentExit"] : t.type === "root" ? e = ["Root", Ie, "RootExit"] : e = Ro2(t), { eventIndex: 0, events: e, iterator: 0, node: t, visitorIndex: 0, visitors: [] };
        }
        function xs2(t) {
          return t[j] = false, t.nodes && t.nodes.forEach((e) => xs2(e)), t;
        }
        var bs2 = {}, ne = class t {
          constructor(e, s, r) {
            this.stringified = false, this.processed = false;
            let n;
            if (typeof s == "object" && s !== null && (s.type === "root" || s.type === "document")) n = xs2(s);
            else if (s instanceof t || s instanceof No2) n = xs2(s.root), s.map && (typeof r.map > "u" && (r.map = {}), r.map.inline || (r.map.inline = false), r.map.prev = s.map);
            else {
              let i = lf2;
              r.syntax && (i = r.syntax.parse), r.parser && (i = r.parser), i.parse && (i = i.parse);
              try {
                n = i(s, r);
              } catch (o) {
                this.processed = true, this.error = o;
              }
              n && !n[sf2] && af3.rebuild(n);
            }
            this.result = new No2(e, n, r), this.helpers = { ...bs2, postcss: bs2, result: this.result }, this.plugins = this.processor.plugins.map((i) => typeof i == "object" && i.prepare ? { ...i, ...i.prepare(this.result) } : i);
          }
          async() {
            return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
          }
          catch(e) {
            return this.async().catch(e);
          }
          finally(e) {
            return this.async().then(e, e);
          }
          getAsyncError() {
            throw new Error("Use process(css).then(cb) to work with async plugins");
          }
          handleError(e, s) {
            let r = this.result.lastPlugin;
            try {
              s && s.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin ? (e.plugin = r.postcssPlugin, e.setMessage()) : r.postcssVersion;
            } catch (n) {
              console && console.error && console.error(n);
            }
            return e;
          }
          prepareVisitors() {
            this.listeners = {};
            let e = (s, r, n) => {
              this.listeners[r] || (this.listeners[r] = []), this.listeners[r].push([s, n]);
            };
            for (let s of this.plugins) if (typeof s == "object") for (let r in s) {
              if (!pf2[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${s.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
              if (!hf2[r]) if (typeof s[r] == "object") for (let n in s[r]) n === "*" ? e(s, r, s[r][n]) : e(s, r + "-" + n.toLowerCase(), s[r][n]);
              else typeof s[r] == "function" && e(s, r, s[r]);
            }
            this.hasListener = Object.keys(this.listeners).length > 0;
          }
          async runAsync() {
            this.plugin = 0;
            for (let e = 0; e < this.plugins.length; e++) {
              let s = this.plugins[e], r = this.runOnRoot(s);
              if (mt(r)) try {
                await r;
              } catch (n) {
                throw this.handleError(n);
              }
            }
            if (this.prepareVisitors(), this.hasListener) {
              let e = this.result.root;
              for (; !e[j]; ) {
                e[j] = true;
                let s = [Po2(e)];
                for (; s.length > 0; ) {
                  let r = this.visitTick(s);
                  if (mt(r)) try {
                    await r;
                  } catch (n) {
                    let i = s[s.length - 1].node;
                    throw this.handleError(n, i);
                  }
                }
              }
              if (this.listeners.OnceExit) for (let [s, r] of this.listeners.OnceExit) {
                this.result.lastPlugin = s;
                try {
                  if (e.type === "document") {
                    let n = e.nodes.map((i) => r(i, this.helpers));
                    await Promise.all(n);
                  } else await r(e, this.helpers);
                } catch (n) {
                  throw this.handleError(n);
                }
              }
            }
            return this.processed = true, this.stringify();
          }
          runOnRoot(e) {
            this.result.lastPlugin = e;
            try {
              if (typeof e == "object" && e.Once) {
                if (this.result.root.type === "document") {
                  let s = this.result.root.nodes.map((r) => e.Once(r, this.helpers));
                  return mt(s[0]) ? Promise.all(s) : s;
                }
                return e.Once(this.result.root, this.helpers);
              } else if (typeof e == "function") return e(this.result.root, this.result);
            } catch (s) {
              throw this.handleError(s);
            }
          }
          stringify() {
            if (this.error) throw this.error;
            if (this.stringified) return this.result;
            this.stringified = true, this.sync();
            let e = this.result.opts, s = of2;
            e.syntax && (s = e.syntax.stringify), e.stringifier && (s = e.stringifier), s.stringify && (s = s.stringify);
            let n = new nf3(s, this.result.root, this.result.opts).generate();
            return this.result.css = n[0], this.result.map = n[1], this.result;
          }
          sync() {
            if (this.error) throw this.error;
            if (this.processed) return this.result;
            if (this.processed = true, this.processing) throw this.getAsyncError();
            for (let e of this.plugins) {
              let s = this.runOnRoot(e);
              if (mt(s)) throw this.getAsyncError();
            }
            if (this.prepareVisitors(), this.hasListener) {
              let e = this.result.root;
              for (; !e[j]; ) e[j] = true, this.walkSync(e);
              if (this.listeners.OnceExit) if (e.type === "document") for (let s of e.nodes) this.visitSync(this.listeners.OnceExit, s);
              else this.visitSync(this.listeners.OnceExit, e);
            }
            return this.result;
          }
          then(e, s) {
            return this.async().then(e, s);
          }
          toString() {
            return this.css;
          }
          visitSync(e, s) {
            for (let [r, n] of e) {
              this.result.lastPlugin = r;
              let i;
              try {
                i = n(s, this.helpers);
              } catch (o) {
                throw this.handleError(o, s.proxyOf);
              }
              if (s.type !== "root" && s.type !== "document" && !s.parent) return true;
              if (mt(i)) throw this.getAsyncError();
            }
          }
          visitTick(e) {
            let s = e[e.length - 1], { node: r, visitors: n } = s;
            if (r.type !== "root" && r.type !== "document" && !r.parent) {
              e.pop();
              return;
            }
            if (n.length > 0 && s.visitorIndex < n.length) {
              let [o, a] = n[s.visitorIndex];
              s.visitorIndex += 1, s.visitorIndex === n.length && (s.visitors = [], s.visitorIndex = 0), this.result.lastPlugin = o;
              try {
                return a(r.toProxy(), this.helpers);
              } catch (u) {
                throw this.handleError(u, r);
              }
            }
            if (s.iterator !== 0) {
              let o = s.iterator, a;
              for (; a = r.nodes[r.indexes[o]]; ) if (r.indexes[o] += 1, !a[j]) {
                a[j] = true, e.push(Po2(a));
                return;
              }
              s.iterator = 0, delete r.indexes[o];
            }
            let i = s.events;
            for (; s.eventIndex < i.length; ) {
              let o = i[s.eventIndex];
              if (s.eventIndex += 1, o === Ie) {
                r.nodes && r.nodes.length && (r[j] = true, s.iterator = r.getIterator());
                return;
              } else if (this.listeners[o]) {
                s.visitors = this.listeners[o];
                return;
              }
            }
            e.pop();
          }
          walkSync(e) {
            e[j] = true;
            let s = Ro2(e);
            for (let r of s) if (r === Ie) e.nodes && e.each((n) => {
              n[j] || this.walkSync(n);
            });
            else {
              let n = this.listeners[r];
              if (n && this.visitSync(n, e.toProxy())) return;
            }
          }
          warnings() {
            return this.sync().warnings();
          }
          get content() {
            return this.stringify().content;
          }
          get css() {
            return this.stringify().css;
          }
          get map() {
            return this.stringify().map;
          }
          get messages() {
            return this.sync().messages;
          }
          get opts() {
            return this.result.opts;
          }
          get processor() {
            return this.result.processor;
          }
          get root() {
            return this.sync().root;
          }
          get [Symbol.toStringTag]() {
            return "LazyResult";
          }
        };
        ne.registerPostcss = (t) => {
          bs2 = t;
        };
        Io2.exports = ne;
        ne.default = ne;
        cf3.registerLazyResult(ne);
        uf2.registerLazyResult(ne);
      });
      var Lo2 = y2((Vv2, qo2) => {
        "use strict";
        var df2 = ws2(), mf2 = it2(), zv2 = gs3(), yf2 = pt2(), wf2 = Zt2(), yt = class {
          constructor(e, s, r) {
            s = s.toString(), this.stringified = false, this._processor = e, this._css = s, this._opts = r, this._map = void 0;
            let n, i = mf2;
            this.result = new wf2(this._processor, n, this._opts), this.result.css = s;
            let o = this;
            Object.defineProperty(this.result, "root", { get() {
              return o.root;
            } });
            let a = new df2(i, n, this._opts, s);
            if (a.isMap()) {
              let [u, c] = a.generate();
              u && (this.result.css = u), c && (this.result.map = c);
            } else a.clearAnnotation(), this.result.css = a.css;
          }
          async() {
            return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
          }
          catch(e) {
            return this.async().catch(e);
          }
          finally(e) {
            return this.async().then(e, e);
          }
          sync() {
            if (this.error) throw this.error;
            return this.result;
          }
          then(e, s) {
            return this.async().then(e, s);
          }
          toString() {
            return this._css;
          }
          warnings() {
            return [];
          }
          get content() {
            return this.result.css;
          }
          get css() {
            return this.result.css;
          }
          get map() {
            return this.result.map;
          }
          get messages() {
            return [];
          }
          get opts() {
            return this.result.opts;
          }
          get processor() {
            return this.result.processor;
          }
          get root() {
            if (this._root) return this._root;
            let e, s = yf2;
            try {
              e = s(this._css, this._opts);
            } catch (r) {
              this.error = r;
            }
            if (this.error) throw this.error;
            return this._root = e, e;
          }
          get [Symbol.toStringTag]() {
            return "NoWorkResult";
          }
        };
        qo2.exports = yt;
        yt.default = yt;
      });
      var Mo2 = y2((Gv2, Do2) => {
        "use strict";
        var gf2 = Lo2(), vf2 = _s2(), xf2 = Xt2(), bf2 = Ae(), he = class {
          constructor(e = []) {
            this.version = "8.4.39", this.plugins = this.normalize(e);
          }
          normalize(e) {
            let s = [];
            for (let r of e) if (r.postcss === true ? r = r() : r.postcss && (r = r.postcss), typeof r == "object" && Array.isArray(r.plugins)) s = s.concat(r.plugins);
            else if (typeof r == "object" && r.postcssPlugin) s.push(r);
            else if (typeof r == "function") s.push(r);
            else if (!(typeof r == "object" && (r.parse || r.stringify))) throw new Error(r + " is not a PostCSS plugin");
            return s;
          }
          process(e, s = {}) {
            return !this.plugins.length && !s.parser && !s.stringifier && !s.syntax ? new gf2(this, e, s) : new vf2(this, e, s);
          }
          use(e) {
            return this.plugins = this.plugins.concat(this.normalize([e])), this;
          }
        };
        Do2.exports = he;
        he.default = he;
        bf2.registerProcessor(he);
        xf2.registerProcessor(he);
      });
      var Uo2 = y2((jv2, Bo2) => {
        "use strict";
        var _f3 = lt(), kf2 = cs2(), Ef2 = Oe2(), Sf2 = jt(), Tf2 = Re(), Of2 = Ae(), Cf2 = Ht2();
        function wt(t, e) {
          if (Array.isArray(t)) return t.map((n) => wt(n));
          let { inputs: s, ...r } = t;
          if (s) {
            e = [];
            for (let n of s) {
              let i = { ...n, __proto__: Tf2.prototype };
              i.map && (i.map = { ...i.map, __proto__: kf2.prototype }), e.push(i);
            }
          }
          if (r.nodes && (r.nodes = t.nodes.map((n) => wt(n, e))), r.source) {
            let { inputId: n, ...i } = r.source;
            r.source = i, n != null && (r.source.input = e[n]);
          }
          if (r.type === "root") return new Of2(r);
          if (r.type === "decl") return new _f3(r);
          if (r.type === "rule") return new Cf2(r);
          if (r.type === "comment") return new Ef2(r);
          if (r.type === "atrule") return new Sf2(r);
          throw new Error("Unknown node type: " + t.type);
        }
        Bo2.exports = wt;
        wt.default = wt;
      });
      var er = y2((Hv2, Go2) => {
        "use strict";
        var Af2 = $t(), Fo2 = lt(), Nf2 = _s2(), Pf2 = re(), ks2 = Mo2(), Rf2 = it2(), If2 = Uo2(), $o2 = Xt2(), qf2 = vs2(), Wo2 = Oe2(), Yo2 = jt(), Lf2 = Zt2(), Df2 = Re(), Mf2 = pt2(), Bf2 = us3(), zo2 = Ht2(), Vo2 = Ae(), Uf2 = at2();
        function k(...t) {
          return t.length === 1 && Array.isArray(t[0]) && (t = t[0]), new ks2(t);
        }
        k.plugin = function(e, s) {
          let r = false;
          function n(...o) {
            console && console.warn && !r && (r = true, console.warn(e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`));
            let a = s(...o);
            return a.postcssPlugin = e, a.postcssVersion = new ks2().version, a;
          }
          let i;
          return Object.defineProperty(n, "postcss", { get() {
            return i || (i = n()), i;
          } }), n.process = function(o, a, u) {
            return k([n(u)]).process(o, a);
          }, n;
        };
        k.stringify = Rf2;
        k.parse = Mf2;
        k.fromJSON = If2;
        k.list = Bf2;
        k.comment = (t) => new Wo2(t);
        k.atRule = (t) => new Yo2(t);
        k.decl = (t) => new Fo2(t);
        k.rule = (t) => new zo2(t);
        k.root = (t) => new Vo2(t);
        k.document = (t) => new $o2(t);
        k.CssSyntaxError = Af2;
        k.Declaration = Fo2;
        k.Container = Pf2;
        k.Processor = ks2;
        k.Document = $o2;
        k.Comment = Wo2;
        k.Warning = qf2;
        k.AtRule = Yo2;
        k.Result = Lf2;
        k.Input = Df2;
        k.Rule = zo2;
        k.Root = Vo2;
        k.Node = Uf2;
        Nf2.registerPostcss(k);
        Go2.exports = k;
        k.default = k;
      });
      var Ho2 = y2((Kv2, jo2) => {
        var { Container: Ff3 } = er(), Es2 = class extends Ff3 {
          constructor(e) {
            super(e), this.type = "decl", this.isNested = true, this.nodes || (this.nodes = []);
          }
        };
        jo2.exports = Es2;
      });
      var Jo2 = y2((Qv2, Qo2) => {
        "use strict";
        var tr2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, rr2 = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, $f2 = /.[\r\n"'(/\\]/, Ko = /[\da-f]/i, sr2 = /[\n\f\r]/g;
        Qo2.exports = function(e, s = {}) {
          let r = e.css.valueOf(), n = s.ignoreErrors, i, o, a, u, c, f, p, l, w, x = r.length, h = 0, d2 = [], m = [], b;
          function g() {
            return h;
          }
          function v2(T3) {
            throw e.error("Unclosed " + T3, h);
          }
          function R() {
            return m.length === 0 && h >= x;
          }
          function F() {
            let T3 = 1, O = false, C = false;
            for (; T3 > 0; ) o += 1, r.length <= o && v2("interpolation"), i = r.charCodeAt(o), l = r.charCodeAt(o + 1), O ? !C && i === O ? (O = false, C = false) : i === 92 ? C = !C : C && (C = false) : i === 39 || i === 34 ? O = i : i === 125 ? T3 -= 1 : i === 35 && l === 123 && (T3 += 1);
          }
          function H(T3) {
            if (m.length) return m.pop();
            if (h >= x) return;
            let O = T3 ? T3.ignoreUnclosed : false;
            switch (i = r.charCodeAt(h), i) {
              case 10:
              case 32:
              case 9:
              case 13:
              case 12: {
                o = h;
                do
                  o += 1, i = r.charCodeAt(o);
                while (i === 32 || i === 10 || i === 9 || i === 13 || i === 12);
                w = ["space", r.slice(h, o)], h = o - 1;
                break;
              }
              case 91:
              case 93:
              case 123:
              case 125:
              case 58:
              case 59:
              case 41: {
                let C = String.fromCharCode(i);
                w = [C, C, h];
                break;
              }
              case 44: {
                w = ["word", ",", h, h + 1];
                break;
              }
              case 40: {
                if (p = d2.length ? d2.pop()[1] : "", l = r.charCodeAt(h + 1), p === "url" && l !== 39 && l !== 34) {
                  for (b = 1, f = false, o = h + 1; o <= r.length - 1; ) {
                    if (l = r.charCodeAt(o), l === 92) f = !f;
                    else if (l === 40) b += 1;
                    else if (l === 41 && (b -= 1, b === 0)) break;
                    o += 1;
                  }
                  u = r.slice(h, o + 1), w = ["brackets", u, h, o], h = o;
                } else o = r.indexOf(")", h + 1), u = r.slice(h, o + 1), o === -1 || $f2.test(u) ? w = ["(", "(", h] : (w = ["brackets", u, h, o], h = o);
                break;
              }
              case 39:
              case 34: {
                for (a = i, o = h, f = false; o < x && (o++, o === x && v2("string"), i = r.charCodeAt(o), l = r.charCodeAt(o + 1), !(!f && i === a)); ) i === 92 ? f = !f : f ? f = false : i === 35 && l === 123 && F();
                w = ["string", r.slice(h, o + 1), h, o], h = o;
                break;
              }
              case 64: {
                tr2.lastIndex = h + 1, tr2.test(r), tr2.lastIndex === 0 ? o = r.length - 1 : o = tr2.lastIndex - 2, w = ["at-word", r.slice(h, o + 1), h, o], h = o;
                break;
              }
              case 92: {
                for (o = h, c = true; r.charCodeAt(o + 1) === 92; ) o += 1, c = !c;
                if (i = r.charCodeAt(o + 1), c && i !== 47 && i !== 32 && i !== 10 && i !== 9 && i !== 13 && i !== 12 && (o += 1, Ko.test(r.charAt(o)))) {
                  for (; Ko.test(r.charAt(o + 1)); ) o += 1;
                  r.charCodeAt(o + 1) === 32 && (o += 1);
                }
                w = ["word", r.slice(h, o + 1), h, o], h = o;
                break;
              }
              default:
                l = r.charCodeAt(h + 1), i === 35 && l === 123 ? (o = h, F(), u = r.slice(h, o + 1), w = ["word", u, h, o], h = o) : i === 47 && l === 42 ? (o = r.indexOf("*/", h + 2) + 1, o === 0 && (n || O ? o = r.length : v2("comment")), w = ["comment", r.slice(h, o + 1), h, o], h = o) : i === 47 && l === 47 ? (sr2.lastIndex = h + 1, sr2.test(r), sr2.lastIndex === 0 ? o = r.length - 1 : o = sr2.lastIndex - 2, u = r.slice(h, o + 1), w = ["comment", u, h, o, "inline"], h = o) : (rr2.lastIndex = h + 1, rr2.test(r), rr2.lastIndex === 0 ? o = r.length - 1 : o = rr2.lastIndex - 2, w = ["word", r.slice(h, o + 1), h, o], d2.push(w), h = o);
                break;
            }
            return h++, w;
          }
          function $(T3) {
            m.push(T3);
          }
          return { back: $, endOfFile: R, nextToken: H, position: g };
        };
      });
      var Zo2 = y2((Jv2, Xo2) => {
        var { Comment: Wf2 } = er(), Yf2 = Kt2(), zf2 = Ho2(), Vf2 = Jo2(), Ss2 = class extends Yf2 {
          atrule(e) {
            let s = e[1], r = e;
            for (; !this.tokenizer.endOfFile(); ) {
              let n = this.tokenizer.nextToken();
              if (n[0] === "word" && n[2] === r[3] + 1) s += n[1], r = n;
              else {
                this.tokenizer.back(n);
                break;
              }
            }
            super.atrule(["at-word", s, e[2], r[3]]);
          }
          comment(e) {
            if (e[4] === "inline") {
              let s = new Wf2();
              this.init(s, e[2]), s.raws.inline = true;
              let r = this.input.fromOffset(e[3]);
              s.source.end = { column: r.col, line: r.line, offset: e[3] + 1 };
              let n = e[1].slice(2);
              if (/^\s*$/.test(n)) s.text = "", s.raws.left = n, s.raws.right = "";
              else {
                let i = n.match(/^(\s*)([^]*\S)(\s*)$/), o = i[2].replace(/(\*\/|\/\*)/g, "*//*");
                s.text = o, s.raws.left = i[1], s.raws.right = i[3], s.raws.text = i[2];
              }
            } else super.comment(e);
          }
          createTokenizer() {
            this.tokenizer = Vf2(this.input);
          }
          raw(e, s, r, n) {
            if (super.raw(e, s, r, n), e.raws[s]) {
              let i = e.raws[s].raw;
              e.raws[s].raw = r.reduce((o, a) => {
                if (a[0] === "comment" && a[4] === "inline") {
                  let u = a[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
                  return o + "/*" + u + "*/";
                } else return o + a[1];
              }, ""), i !== e.raws[s].raw && (e.raws[s].scss = i);
            }
          }
          rule(e) {
            let s = false, r = 0, n = "";
            for (let i of e) if (s) i[0] !== "comment" && i[0] !== "{" && (n += i[1]);
            else {
              if (i[0] === "space" && i[1].includes(`
`)) break;
              i[0] === "(" ? r += 1 : i[0] === ")" ? r -= 1 : r === 0 && i[0] === ":" && (s = true);
            }
            if (!s || n.trim() === "" || /^[#:A-Za-z-]/.test(n)) super.rule(e);
            else {
              e.pop();
              let i = new zf2();
              this.init(i, e[0][2]);
              let o;
              for (let u = e.length - 1; u >= 0; u--) if (e[u][0] !== "space") {
                o = e[u];
                break;
              }
              if (o[3]) {
                let u = this.input.fromOffset(o[3]);
                i.source.end = { column: u.col, line: u.line, offset: o[3] + 1 };
              } else {
                let u = this.input.fromOffset(o[2]);
                i.source.end = { column: u.col, line: u.line, offset: o[2] + 1 };
              }
              for (; e[0][0] !== "word"; ) i.raws.before += e.shift()[1];
              if (e[0][2]) {
                let u = this.input.fromOffset(e[0][2]);
                i.source.start = { column: u.col, line: u.line, offset: e[0][2] };
              }
              for (i.prop = ""; e.length; ) {
                let u = e[0][0];
                if (u === ":" || u === "space" || u === "comment") break;
                i.prop += e.shift()[1];
              }
              i.raws.between = "";
              let a;
              for (; e.length; ) if (a = e.shift(), a[0] === ":") {
                i.raws.between += a[1];
                break;
              } else i.raws.between += a[1];
              (i.prop[0] === "_" || i.prop[0] === "*") && (i.raws.before += i.prop[0], i.prop = i.prop.slice(1)), i.raws.between += this.spacesAndCommentsFromStart(e), this.precheckMissedSemicolon(e);
              for (let u = e.length - 1; u > 0; u--) {
                if (a = e[u], a[1] === "!important") {
                  i.important = true;
                  let c = this.stringFrom(e, u);
                  c = this.spacesFromEnd(e) + c, c !== " !important" && (i.raws.important = c);
                  break;
                } else if (a[1] === "important") {
                  let c = e.slice(0), f = "";
                  for (let p = u; p > 0; p--) {
                    let l = c[p][0];
                    if (f.trim().indexOf("!") === 0 && l !== "space") break;
                    f = c.pop()[1] + f;
                  }
                  f.trim().indexOf("!") === 0 && (i.important = true, i.raws.important = f, e = c);
                }
                if (a[0] !== "space" && a[0] !== "comment") break;
              }
              this.raw(i, "value", e), i.value.includes(":") && this.checkMissedSemicolon(e), this.current = i;
            }
          }
        };
        Xo2.exports = Ss2;
      });
      var ta2 = y2((Xv2, ea2) => {
        var { Input: Gf2 } = er(), jf2 = Zo2();
        ea2.exports = function(e, s) {
          let r = new Gf2(e, s), n = new jf2(r);
          return n.parse(), n.root;
        };
      });
      var Os2 = y2((Ts2) => {
        "use strict";
        Object.defineProperty(Ts2, "__esModule", { value: true });
        function Kf2(t) {
          this.after = t.after, this.before = t.before, this.type = t.type, this.value = t.value, this.sourceIndex = t.sourceIndex;
        }
        Ts2.default = Kf2;
      });
      var As2 = y2((Cs2) => {
        "use strict";
        Object.defineProperty(Cs2, "__esModule", { value: true });
        var Qf2 = Os2(), sa2 = Jf2(Qf2);
        function Jf2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function gt2(t) {
          var e = this;
          this.constructor(t), this.nodes = t.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(s) {
            s.parent = e;
          });
        }
        gt2.prototype = Object.create(sa2.default.prototype);
        gt2.constructor = sa2.default;
        gt2.prototype.walk = function(e, s) {
          for (var r = typeof e == "string" || e instanceof RegExp, n = r ? s : e, i = typeof e == "string" ? new RegExp(e) : e, o = 0; o < this.nodes.length; o++) {
            var a = this.nodes[o], u = r ? i.test(a.type) : true;
            if (u && n && n(a, o, this.nodes) === false || a.nodes && a.walk(e, s) === false) return false;
          }
          return true;
        };
        gt2.prototype.each = function() {
          for (var e = arguments.length <= 0 || arguments[0] === void 0 ? function() {
          } : arguments[0], s = 0; s < this.nodes.length; s++) {
            var r = this.nodes[s];
            if (e(r, s, this.nodes) === false) return false;
          }
          return true;
        };
        Cs2.default = gt2;
      });
      var aa2 = y2((vt) => {
        "use strict";
        Object.defineProperty(vt, "__esModule", { value: true });
        vt.parseMediaFeature = oa2;
        vt.parseMediaQuery = Ps2;
        vt.parseMediaList = ep2;
        var Xf2 = Os2(), na2 = ia2(Xf2), Zf2 = As2(), Ns2 = ia2(Zf2);
        function ia2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function oa2(t) {
          var e = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], s = [{ mode: "normal", character: null }], r = [], n = 0, i = "", o = null, a = null, u = e, c = t;
          t[0] === "(" && t[t.length - 1] === ")" && (c = t.substring(1, t.length - 1), u++);
          for (var f = 0; f < c.length; f++) {
            var p = c[f];
            if ((p === "'" || p === '"') && (s[n].isCalculationEnabled === true ? (s.push({ mode: "string", isCalculationEnabled: false, character: p }), n++) : s[n].mode === "string" && s[n].character === p && c[f - 1] !== "\\" && (s.pop(), n--)), p === "{" ? (s.push({ mode: "interpolation", isCalculationEnabled: true }), n++) : p === "}" && (s.pop(), n--), s[n].mode === "normal" && p === ":") {
              var l = c.substring(f + 1);
              a = { type: "value", before: /^(\s*)/.exec(l)[1], after: /(\s*)$/.exec(l)[1], value: l.trim() }, a.sourceIndex = a.before.length + f + 1 + u, o = { type: "colon", sourceIndex: f + u, after: a.before, value: ":" };
              break;
            }
            i += p;
          }
          return i = { type: "media-feature", before: /^(\s*)/.exec(i)[1], after: /(\s*)$/.exec(i)[1], value: i.trim() }, i.sourceIndex = i.before.length + u, r.push(i), o !== null && (o.before = i.after, r.push(o)), a !== null && r.push(a), r;
        }
        function Ps2(t) {
          var e = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], s = [], r = 0, n = false, i = void 0;
          function o() {
            return { before: "", after: "", value: "" };
          }
          i = o();
          for (var a = 0; a < t.length; a++) {
            var u = t[a];
            n ? (i.value += u, (u === "{" || u === "(") && r++, (u === ")" || u === "}") && r--) : u.search(/\s/) !== -1 ? i.before += u : (u === "(" && (i.type = "media-feature-expression", r++), i.value = u, i.sourceIndex = e + a, n = true), n && r === 0 && (u === ")" || a === t.length - 1 || t[a + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(i.value) !== -1 && (i.type = "keyword"), i.type === "media-feature-expression" && (i.nodes = oa2(i.value, i.sourceIndex)), s.push(Array.isArray(i.nodes) ? new Ns2.default(i) : new na2.default(i)), i = o(), n = false);
          }
          for (var c = 0; c < s.length; c++) if (i = s[c], c > 0 && (s[c - 1].after = i.before), i.type === void 0) {
            if (c > 0) {
              if (s[c - 1].type === "media-feature-expression") {
                i.type = "keyword";
                continue;
              }
              if (s[c - 1].value === "not" || s[c - 1].value === "only") {
                i.type = "media-type";
                continue;
              }
              if (s[c - 1].value === "and") {
                i.type = "media-feature-expression";
                continue;
              }
              s[c - 1].type === "media-type" && (s[c + 1] ? i.type = s[c + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : i.type = "media-feature-expression");
            }
            if (c === 0) {
              if (!s[c + 1]) {
                i.type = "media-type";
                continue;
              }
              if (s[c + 1] && (s[c + 1].type === "media-feature-expression" || s[c + 1].type === "keyword")) {
                i.type = "media-type";
                continue;
              }
              if (s[c + 2]) {
                if (s[c + 2].type === "media-feature-expression") {
                  i.type = "media-type", s[c + 1].type = "keyword";
                  continue;
                }
                if (s[c + 2].type === "keyword") {
                  i.type = "keyword", s[c + 1].type = "media-type";
                  continue;
                }
              }
              if (s[c + 3] && s[c + 3].type === "media-feature-expression") {
                i.type = "keyword", s[c + 1].type = "media-type", s[c + 2].type = "keyword";
                continue;
              }
            }
          }
          return s;
        }
        function ep2(t) {
          var e = [], s = 0, r = 0, n = /^(\s*)url\s*\(/.exec(t);
          if (n !== null) {
            for (var i = n[0].length, o = 1; o > 0; ) {
              var a = t[i];
              a === "(" && o++, a === ")" && o--, i++;
            }
            e.unshift(new na2.default({ type: "url", value: t.substring(0, i).trim(), sourceIndex: n[1].length, before: n[1], after: /^(\s*)/.exec(t.substring(i))[1] })), s = i;
          }
          for (var u = s; u < t.length; u++) {
            var c = t[u];
            if (c === "(" && r++, c === ")" && r--, r === 0 && c === ",") {
              var f = t.substring(s, u), p = /^(\s*)/.exec(f)[1];
              e.push(new Ns2.default({ type: "media-query", value: f.trim(), sourceIndex: s + p.length, nodes: Ps2(f, s), before: p, after: /(\s*)$/.exec(f)[1] })), s = u + 1;
            }
          }
          var l = t.substring(s), w = /^(\s*)/.exec(l)[1];
          return e.push(new Ns2.default({ type: "media-query", value: l.trim(), sourceIndex: s + w.length, nodes: Ps2(l, s), before: w, after: /(\s*)$/.exec(l)[1] })), e;
        }
      });
      var ua3 = y2((Rs2) => {
        "use strict";
        Object.defineProperty(Rs2, "__esModule", { value: true });
        Rs2.default = ip;
        var tp = As2(), rp = np(tp), sp2 = aa2();
        function np(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function ip(t) {
          return new rp.default({ nodes: (0, sp2.parseMediaList)(t), type: "media-query-list", value: t.trim() });
        }
      });
      var qs2 = y2((ax, fa2) => {
        fa2.exports = function(e, s) {
          if (s = typeof s == "number" ? s : 1 / 0, !s) return Array.isArray(e) ? e.map(function(n) {
            return n;
          }) : e;
          return r(e, 1);
          function r(n, i) {
            return n.reduce(function(o, a) {
              return Array.isArray(a) && i < s ? o.concat(r(a, i + 1)) : o.concat(a);
            }, []);
          }
        };
      });
      var Ls2 = y2((ux, pa2) => {
        pa2.exports = function(t, e) {
          for (var s = -1, r = []; (s = t.indexOf(e, s + 1)) !== -1; ) r.push(s);
          return r;
        };
      });
      var Ds2 = y2((lx, ha2) => {
        "use strict";
        function up2(t, e) {
          for (var s = 1, r = t.length, n = t[0], i = t[0], o = 1; o < r; ++o) if (i = n, n = t[o], e(n, i)) {
            if (o === s) {
              s++;
              continue;
            }
            t[s++] = n;
          }
          return t.length = s, t;
        }
        function lp2(t) {
          for (var e = 1, s = t.length, r = t[0], n = t[0], i = 1; i < s; ++i, n = r) if (n = r, r = t[i], r !== n) {
            if (i === e) {
              e++;
              continue;
            }
            t[e++] = r;
          }
          return t.length = e, t;
        }
        function cp2(t, e, s) {
          return t.length === 0 ? t : e ? (s || t.sort(e), up2(t, e)) : (s || t.sort(), lp2(t));
        }
        ha2.exports = cp2;
      });
      var de3 = y2((nr2, ma2) => {
        "use strict";
        nr2.__esModule = true;
        var da = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
          return typeof t;
        } : function(t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        };
        function fp2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        var pp2 = function t(e, s) {
          if ((typeof e > "u" ? "undefined" : da(e)) !== "object") return e;
          var r = new e.constructor();
          for (var n in e) if (e.hasOwnProperty(n)) {
            var i = e[n], o = typeof i > "u" ? "undefined" : da(i);
            n === "parent" && o === "object" ? s && (r[n] = s) : i instanceof Array ? r[n] = i.map(function(a) {
              return t(a, r);
            }) : r[n] = t(i, r);
          }
          return r;
        }, hp2 = function() {
          function t() {
            var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            fp2(this, t);
            for (var s in e) this[s] = e[s];
            var r = e.spaces;
            r = r === void 0 ? {} : r;
            var n = r.before, i = n === void 0 ? "" : n, o = r.after, a = o === void 0 ? "" : o;
            this.spaces = { before: i, after: a };
          }
          return t.prototype.remove = function() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }, t.prototype.replaceWith = function() {
            if (this.parent) {
              for (var s in arguments) this.parent.insertBefore(this, arguments[s]);
              this.remove();
            }
            return this;
          }, t.prototype.next = function() {
            return this.parent.at(this.parent.index(this) + 1);
          }, t.prototype.prev = function() {
            return this.parent.at(this.parent.index(this) - 1);
          }, t.prototype.clone = function() {
            var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = pp2(this);
            for (var n in s) r[n] = s[n];
            return r;
          }, t.prototype.toString = function() {
            return [this.spaces.before, String(this.value), this.spaces.after].join("");
          }, t;
        }();
        nr2.default = hp2;
        ma2.exports = nr2.default;
      });
      var D = y2((B) => {
        "use strict";
        B.__esModule = true;
        var cx = B.TAG = "tag", fx = B.STRING = "string", px = B.SELECTOR = "selector", hx = B.ROOT = "root", dx = B.PSEUDO = "pseudo", mx = B.NESTING = "nesting", yx = B.ID = "id", wx = B.COMMENT = "comment", gx = B.COMBINATOR = "combinator", vx = B.CLASS = "class", xx = B.ATTRIBUTE = "attribute", bx = B.UNIVERSAL = "universal";
      });
      var or2 = y2((ir2, ya2) => {
        "use strict";
        ir2.__esModule = true;
        var dp2 = /* @__PURE__ */ function() {
          function t(e, s) {
            for (var r = 0; r < s.length; r++) {
              var n = s[r];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
            }
          }
          return function(e, s, r) {
            return s && t(e.prototype, s), r && t(e, r), e;
          };
        }(), mp2 = de3(), yp2 = vp2(mp2), wp2 = D(), X = gp2(wp2);
        function gp2(t) {
          if (t && t.__esModule) return t;
          var e = {};
          if (t != null) for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
          return e.default = t, e;
        }
        function vp2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function xp2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function bp2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function _p2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var kp2 = function(t) {
          _p2(e, t);
          function e(s) {
            xp2(this, e);
            var r = bp2(this, t.call(this, s));
            return r.nodes || (r.nodes = []), r;
          }
          return e.prototype.append = function(r) {
            return r.parent = this, this.nodes.push(r), this;
          }, e.prototype.prepend = function(r) {
            return r.parent = this, this.nodes.unshift(r), this;
          }, e.prototype.at = function(r) {
            return this.nodes[r];
          }, e.prototype.index = function(r) {
            return typeof r == "number" ? r : this.nodes.indexOf(r);
          }, e.prototype.removeChild = function(r) {
            r = this.index(r), this.at(r).parent = void 0, this.nodes.splice(r, 1);
            var n = void 0;
            for (var i in this.indexes) n = this.indexes[i], n >= r && (this.indexes[i] = n - 1);
            return this;
          }, e.prototype.removeAll = function() {
            for (var i = this.nodes, r = Array.isArray(i), n = 0, i = r ? i : i[Symbol.iterator](); ; ) {
              var o;
              if (r) {
                if (n >= i.length) break;
                o = i[n++];
              } else {
                if (n = i.next(), n.done) break;
                o = n.value;
              }
              var a = o;
              a.parent = void 0;
            }
            return this.nodes = [], this;
          }, e.prototype.empty = function() {
            return this.removeAll();
          }, e.prototype.insertAfter = function(r, n) {
            var i = this.index(r);
            this.nodes.splice(i + 1, 0, n);
            var o = void 0;
            for (var a in this.indexes) o = this.indexes[a], i <= o && (this.indexes[a] = o + this.nodes.length);
            return this;
          }, e.prototype.insertBefore = function(r, n) {
            var i = this.index(r);
            this.nodes.splice(i, 0, n);
            var o = void 0;
            for (var a in this.indexes) o = this.indexes[a], i <= o && (this.indexes[a] = o + this.nodes.length);
            return this;
          }, e.prototype.each = function(r) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
            var n = this.lastEach;
            if (this.indexes[n] = 0, !!this.length) {
              for (var i = void 0, o = void 0; this.indexes[n] < this.length && (i = this.indexes[n], o = r(this.at(i), i), o !== false); ) this.indexes[n] += 1;
              if (delete this.indexes[n], o === false) return false;
            }
          }, e.prototype.walk = function(r) {
            return this.each(function(n, i) {
              var o = r(n, i);
              if (o !== false && n.length && (o = n.walk(r)), o === false) return false;
            });
          }, e.prototype.walkAttributes = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.ATTRIBUTE) return r.call(n, i);
            });
          }, e.prototype.walkClasses = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.CLASS) return r.call(n, i);
            });
          }, e.prototype.walkCombinators = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.COMBINATOR) return r.call(n, i);
            });
          }, e.prototype.walkComments = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.COMMENT) return r.call(n, i);
            });
          }, e.prototype.walkIds = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.ID) return r.call(n, i);
            });
          }, e.prototype.walkNesting = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.NESTING) return r.call(n, i);
            });
          }, e.prototype.walkPseudos = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.PSEUDO) return r.call(n, i);
            });
          }, e.prototype.walkTags = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.TAG) return r.call(n, i);
            });
          }, e.prototype.walkUniversals = function(r) {
            var n = this;
            return this.walk(function(i) {
              if (i.type === X.UNIVERSAL) return r.call(n, i);
            });
          }, e.prototype.split = function(r) {
            var n = this, i = [];
            return this.reduce(function(o, a, u) {
              var c = r.call(n, a);
              return i.push(a), c ? (o.push(i), i = []) : u === n.length - 1 && o.push(i), o;
            }, []);
          }, e.prototype.map = function(r) {
            return this.nodes.map(r);
          }, e.prototype.reduce = function(r, n) {
            return this.nodes.reduce(r, n);
          }, e.prototype.every = function(r) {
            return this.nodes.every(r);
          }, e.prototype.some = function(r) {
            return this.nodes.some(r);
          }, e.prototype.filter = function(r) {
            return this.nodes.filter(r);
          }, e.prototype.sort = function(r) {
            return this.nodes.sort(r);
          }, e.prototype.toString = function() {
            return this.map(String).join("");
          }, dp2(e, [{ key: "first", get: function() {
            return this.at(0);
          } }, { key: "last", get: function() {
            return this.at(this.length - 1);
          } }, { key: "length", get: function() {
            return this.nodes.length;
          } }]), e;
        }(yp2.default);
        ir2.default = kp2;
        ya2.exports = ir2.default;
      });
      var ga2 = y2((ar2, wa2) => {
        "use strict";
        ar2.__esModule = true;
        var Ep2 = or2(), Sp2 = Op2(Ep2), Tp2 = D();
        function Op2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function Cp2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Ap2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Np2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var Pp2 = function(t) {
          Np2(e, t);
          function e(s) {
            Cp2(this, e);
            var r = Ap2(this, t.call(this, s));
            return r.type = Tp2.ROOT, r;
          }
          return e.prototype.toString = function() {
            var r = this.reduce(function(n, i) {
              var o = String(i);
              return o ? n + o + "," : "";
            }, "").slice(0, -1);
            return this.trailingComma ? r + "," : r;
          }, e;
        }(Sp2.default);
        ar2.default = Pp2;
        wa2.exports = ar2.default;
      });
      var xa = y2((ur2, va2) => {
        "use strict";
        ur2.__esModule = true;
        var Rp2 = or2(), Ip2 = Lp2(Rp2), qp2 = D();
        function Lp2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function Dp2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Mp2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Bp2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var Up2 = function(t) {
          Bp2(e, t);
          function e(s) {
            Dp2(this, e);
            var r = Mp2(this, t.call(this, s));
            return r.type = qp2.SELECTOR, r;
          }
          return e;
        }(Ip2.default);
        ur2.default = Up2;
        va2.exports = ur2.default;
      });
      var qe = y2((lr, ba) => {
        "use strict";
        lr.__esModule = true;
        var Fp2 = /* @__PURE__ */ function() {
          function t(e, s) {
            for (var r = 0; r < s.length; r++) {
              var n = s[r];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
            }
          }
          return function(e, s, r) {
            return s && t(e.prototype, s), r && t(e, r), e;
          };
        }(), $p2 = de3(), Wp2 = Yp2($p2);
        function Yp2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function zp2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Vp2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Gp2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var jp2 = function(t) {
          Gp2(e, t);
          function e() {
            return zp2(this, e), Vp2(this, t.apply(this, arguments));
          }
          return e.prototype.toString = function() {
            return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
          }, Fp2(e, [{ key: "ns", get: function() {
            var r = this.namespace;
            return r ? (typeof r == "string" ? r : "") + "|" : "";
          } }]), e;
        }(Wp2.default);
        lr.default = jp2;
        ba.exports = lr.default;
      });
      var ka2 = y2((cr2, _a2) => {
        "use strict";
        cr2.__esModule = true;
        var Hp2 = qe(), Kp2 = Jp2(Hp2), Qp2 = D();
        function Jp2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function Xp2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Zp2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function eh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var th2 = function(t) {
          eh2(e, t);
          function e(s) {
            Xp2(this, e);
            var r = Zp2(this, t.call(this, s));
            return r.type = Qp2.CLASS, r;
          }
          return e.prototype.toString = function() {
            return [this.spaces.before, this.ns, "." + this.value, this.spaces.after].join("");
          }, e;
        }(Kp2.default);
        cr2.default = th2;
        _a2.exports = cr2.default;
      });
      var Sa2 = y2((fr2, Ea) => {
        "use strict";
        fr2.__esModule = true;
        var rh2 = de3(), sh2 = ih2(rh2), nh2 = D();
        function ih2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function oh2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function ah2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function uh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var lh2 = function(t) {
          uh2(e, t);
          function e(s) {
            oh2(this, e);
            var r = ah2(this, t.call(this, s));
            return r.type = nh2.COMMENT, r;
          }
          return e;
        }(sh2.default);
        fr2.default = lh2;
        Ea.exports = fr2.default;
      });
      var Oa2 = y2((pr2, Ta2) => {
        "use strict";
        pr2.__esModule = true;
        var ch2 = qe(), fh2 = hh2(ch2), ph2 = D();
        function hh2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function dh2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function mh2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function yh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var wh2 = function(t) {
          yh2(e, t);
          function e(s) {
            dh2(this, e);
            var r = mh2(this, t.call(this, s));
            return r.type = ph2.ID, r;
          }
          return e.prototype.toString = function() {
            return [this.spaces.before, this.ns, "#" + this.value, this.spaces.after].join("");
          }, e;
        }(fh2.default);
        pr2.default = wh2;
        Ta2.exports = pr2.default;
      });
      var Aa2 = y2((hr, Ca) => {
        "use strict";
        hr.__esModule = true;
        var gh2 = qe(), vh2 = bh2(gh2), xh2 = D();
        function bh2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function _h2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function kh2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Eh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var Sh2 = function(t) {
          Eh2(e, t);
          function e(s) {
            _h2(this, e);
            var r = kh2(this, t.call(this, s));
            return r.type = xh2.TAG, r;
          }
          return e;
        }(vh2.default);
        hr.default = Sh2;
        Ca.exports = hr.default;
      });
      var Pa3 = y2((dr, Na2) => {
        "use strict";
        dr.__esModule = true;
        var Th2 = de3(), Oh2 = Ah2(Th2), Ch2 = D();
        function Ah2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function Nh2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Ph2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Rh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var Ih2 = function(t) {
          Rh2(e, t);
          function e(s) {
            Nh2(this, e);
            var r = Ph2(this, t.call(this, s));
            return r.type = Ch2.STRING, r;
          }
          return e;
        }(Oh2.default);
        dr.default = Ih2;
        Na2.exports = dr.default;
      });
      var Ia2 = y2((mr2, Ra2) => {
        "use strict";
        mr2.__esModule = true;
        var qh2 = or2(), Lh2 = Mh2(qh2), Dh2 = D();
        function Mh2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function Bh2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function Uh2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Fh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var $h2 = function(t) {
          Fh2(e, t);
          function e(s) {
            Bh2(this, e);
            var r = Uh2(this, t.call(this, s));
            return r.type = Dh2.PSEUDO, r;
          }
          return e.prototype.toString = function() {
            var r = this.length ? "(" + this.map(String).join(",") + ")" : "";
            return [this.spaces.before, String(this.value), r, this.spaces.after].join("");
          }, e;
        }(Lh2.default);
        mr2.default = $h2;
        Ra2.exports = mr2.default;
      });
      var La = y2((yr2, qa2) => {
        "use strict";
        yr2.__esModule = true;
        var Wh2 = qe(), Yh3 = Vh2(Wh2), zh2 = D();
        function Vh2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function Gh2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function jh2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function Hh2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var Kh2 = function(t) {
          Hh2(e, t);
          function e(s) {
            Gh2(this, e);
            var r = jh2(this, t.call(this, s));
            return r.type = zh2.ATTRIBUTE, r.raws = {}, r;
          }
          return e.prototype.toString = function() {
            var r = [this.spaces.before, "[", this.ns, this.attribute];
            return this.operator && r.push(this.operator), this.value && r.push(this.value), this.raws.insensitive ? r.push(this.raws.insensitive) : this.insensitive && r.push(" i"), r.push("]"), r.concat(this.spaces.after).join("");
          }, e;
        }(Yh3.default);
        yr2.default = Kh2;
        qa2.exports = yr2.default;
      });
      var Ma2 = y2((wr2, Da3) => {
        "use strict";
        wr2.__esModule = true;
        var Qh2 = qe(), Jh2 = Zh2(Qh2), Xh2 = D();
        function Zh2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function ed2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function td2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function rd2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var sd2 = function(t) {
          rd2(e, t);
          function e(s) {
            ed2(this, e);
            var r = td2(this, t.call(this, s));
            return r.type = Xh2.UNIVERSAL, r.value = "*", r;
          }
          return e;
        }(Jh2.default);
        wr2.default = sd2;
        Da3.exports = wr2.default;
      });
      var Ua2 = y2((gr2, Ba2) => {
        "use strict";
        gr2.__esModule = true;
        var nd2 = de3(), id2 = ad2(nd2), od2 = D();
        function ad2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function ud2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function ld2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function cd2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var fd2 = function(t) {
          cd2(e, t);
          function e(s) {
            ud2(this, e);
            var r = ld2(this, t.call(this, s));
            return r.type = od2.COMBINATOR, r;
          }
          return e;
        }(id2.default);
        gr2.default = fd2;
        Ba2.exports = gr2.default;
      });
      var $a2 = y2((vr2, Fa2) => {
        "use strict";
        vr2.__esModule = true;
        var pd2 = de3(), hd2 = md2(pd2), dd2 = D();
        function md2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function yd2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        function wd2(t, e) {
          if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e && (typeof e == "object" || typeof e == "function") ? e : t;
        }
        function gd2(t, e) {
          if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
          t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
        }
        var vd2 = function(t) {
          gd2(e, t);
          function e(s) {
            yd2(this, e);
            var r = wd2(this, t.call(this, s));
            return r.type = dd2.NESTING, r.value = "&", r;
          }
          return e;
        }(hd2.default);
        vr2.default = vd2;
        Fa2.exports = vr2.default;
      });
      var Ya2 = y2((xr, Wa2) => {
        "use strict";
        xr.__esModule = true;
        xr.default = xd2;
        function xd2(t) {
          return t.sort(function(e, s) {
            return e - s;
          });
        }
        Wa2.exports = xr.default;
      });
      var Xa2 = y2((kr2, Ja2) => {
        "use strict";
        kr2.__esModule = true;
        kr2.default = Pd2;
        var za2 = 39, bd2 = 34, Ms2 = 92, Va2 = 47, xt = 10, Bs2 = 32, Us2 = 12, Fs2 = 9, $s2 = 13, Ga2 = 43, ja2 = 62, Ha2 = 126, Ka = 124, _d2 = 44, kd2 = 40, Ed2 = 41, Sd2 = 91, Td2 = 93, Od2 = 59, Qa2 = 42, Cd2 = 58, Ad2 = 38, Nd2 = 64, br2 = /[ \n\t\r\{\(\)'"\\;/]/g, _r2 = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
        function Pd2(t) {
          for (var e = [], s = t.css.valueOf(), r = void 0, n = void 0, i = void 0, o = void 0, a = void 0, u = void 0, c = void 0, f = void 0, p = void 0, l = void 0, w = void 0, x = s.length, h = -1, d2 = 1, m = 0, b = function(v2, R) {
            if (t.safe) s += R, n = s.length - 1;
            else throw t.error("Unclosed " + v2, d2, m - h, m);
          }; m < x; ) {
            switch (r = s.charCodeAt(m), r === xt && (h = m, d2 += 1), r) {
              case xt:
              case Bs2:
              case Fs2:
              case $s2:
              case Us2:
                n = m;
                do
                  n += 1, r = s.charCodeAt(n), r === xt && (h = n, d2 += 1);
                while (r === Bs2 || r === xt || r === Fs2 || r === $s2 || r === Us2);
                e.push(["space", s.slice(m, n), d2, m - h, m]), m = n - 1;
                break;
              case Ga2:
              case ja2:
              case Ha2:
              case Ka:
                n = m;
                do
                  n += 1, r = s.charCodeAt(n);
                while (r === Ga2 || r === ja2 || r === Ha2 || r === Ka);
                e.push(["combinator", s.slice(m, n), d2, m - h, m]), m = n - 1;
                break;
              case Qa2:
                e.push(["*", "*", d2, m - h, m]);
                break;
              case Ad2:
                e.push(["&", "&", d2, m - h, m]);
                break;
              case _d2:
                e.push([",", ",", d2, m - h, m]);
                break;
              case Sd2:
                e.push(["[", "[", d2, m - h, m]);
                break;
              case Td2:
                e.push(["]", "]", d2, m - h, m]);
                break;
              case Cd2:
                e.push([":", ":", d2, m - h, m]);
                break;
              case Od2:
                e.push([";", ";", d2, m - h, m]);
                break;
              case kd2:
                e.push(["(", "(", d2, m - h, m]);
                break;
              case Ed2:
                e.push([")", ")", d2, m - h, m]);
                break;
              case za2:
              case bd2:
                i = r === za2 ? "'" : '"', n = m;
                do
                  for (l = false, n = s.indexOf(i, n + 1), n === -1 && b("quote", i), w = n; s.charCodeAt(w - 1) === Ms2; ) w -= 1, l = !l;
                while (l);
                e.push(["string", s.slice(m, n + 1), d2, m - h, d2, n - h, m]), m = n;
                break;
              case Nd2:
                br2.lastIndex = m + 1, br2.test(s), br2.lastIndex === 0 ? n = s.length - 1 : n = br2.lastIndex - 2, e.push(["at-word", s.slice(m, n + 1), d2, m - h, d2, n - h, m]), m = n;
                break;
              case Ms2:
                for (n = m, c = true; s.charCodeAt(n + 1) === Ms2; ) n += 1, c = !c;
                r = s.charCodeAt(n + 1), c && r !== Va2 && r !== Bs2 && r !== xt && r !== Fs2 && r !== $s2 && r !== Us2 && (n += 1), e.push(["word", s.slice(m, n + 1), d2, m - h, d2, n - h, m]), m = n;
                break;
              default:
                r === Va2 && s.charCodeAt(m + 1) === Qa2 ? (n = s.indexOf("*/", m + 2) + 1, n === 0 && b("comment", "*/"), u = s.slice(m, n + 1), o = u.split(`
`), a = o.length - 1, a > 0 ? (f = d2 + a, p = n - o[a].length) : (f = d2, p = h), e.push(["comment", u, d2, m - h, f, n - p, m]), h = p, d2 = f, m = n) : (_r2.lastIndex = m + 1, _r2.test(s), _r2.lastIndex === 0 ? n = s.length - 1 : n = _r2.lastIndex - 2, e.push(["word", s.slice(m, n + 1), d2, m - h, d2, n - h, m]), m = n);
                break;
            }
            m++;
          }
          return e;
        }
        Ja2.exports = kr2.default;
      });
      var tu3 = y2((Er2, eu2) => {
        "use strict";
        Er2.__esModule = true;
        var Rd2 = /* @__PURE__ */ function() {
          function t(e, s) {
            for (var r = 0; r < s.length; r++) {
              var n = s[r];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
            }
          }
          return function(e, s, r) {
            return s && t(e.prototype, s), r && t(e, r), e;
          };
        }(), Id2 = qs2(), qd2 = I(Id2), Ld2 = Ls2(), Ws2 = I(Ld2), Dd2 = Ds2(), Md2 = I(Dd2), Bd2 = ga2(), Ud2 = I(Bd2), Fd2 = xa(), Ys2 = I(Fd2), $d2 = ka2(), Wd2 = I($d2), Yd2 = Sa2(), zd2 = I(Yd2), Vd2 = Oa2(), Gd2 = I(Vd2), jd2 = Aa2(), Hd2 = I(jd2), Kd2 = Pa3(), Qd2 = I(Kd2), Jd2 = Ia2(), Xd2 = I(Jd2), Zd2 = La(), em2 = I(Zd2), tm2 = Ma2(), rm2 = I(tm2), sm2 = Ua2(), nm2 = I(sm2), im2 = $a2(), om2 = I(im2), am3 = Ya2(), um2 = I(am3), lm2 = Xa2(), Za2 = I(lm2), cm2 = D(), fm2 = pm2(cm2);
        function pm2(t) {
          if (t && t.__esModule) return t;
          var e = {};
          if (t != null) for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
          return e.default = t, e;
        }
        function I(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function hm2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        var dm2 = function() {
          function t(e) {
            hm2(this, t), this.input = e, this.lossy = e.options.lossless === false, this.position = 0, this.root = new Ud2.default();
            var s = new Ys2.default();
            return this.root.append(s), this.current = s, this.lossy ? this.tokens = (0, Za2.default)({ safe: e.safe, css: e.css.trim() }) : this.tokens = (0, Za2.default)(e), this.loop();
          }
          return t.prototype.attribute = function() {
            var s = "", r = void 0, n = this.currToken;
            for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; ) s += this.tokens[this.position][1], this.position++;
            this.position === this.tokens.length && !~s.indexOf("]") && this.error("Expected a closing square bracket.");
            var i = s.split(/((?:[*~^$|]?=))([^]*)/), o = i[0].split(/(\|)/g), a = { operator: i[1], value: i[2], source: { start: { line: n[2], column: n[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: n[4] };
            if (o.length > 1 ? (o[0] === "" && (o[0] = true), a.attribute = this.parseValue(o[2]), a.namespace = this.parseNamespace(o[0])) : a.attribute = this.parseValue(i[0]), r = new em2.default(a), i[2]) {
              var u = i[2].split(/(\s+i\s*?)$/), c = u[0].trim();
              r.value = this.lossy ? c : u[0], u[1] && (r.insensitive = true, this.lossy || (r.raws.insensitive = u[1])), r.quoted = c[0] === "'" || c[0] === '"', r.raws.unquoted = r.quoted ? c.slice(1, -1) : c;
            }
            this.newNode(r), this.position++;
          }, t.prototype.combinator = function() {
            if (this.currToken[1] === "|") return this.namespace();
            for (var s = new nm2.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); ) this.nextToken && this.nextToken[0] === "combinator" ? (s.spaces.before = this.parseSpace(this.currToken[1]), s.source.start.line = this.nextToken[2], s.source.start.column = this.nextToken[3], s.source.end.column = this.nextToken[3], s.source.end.line = this.nextToken[2], s.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? s.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? s.value = this.currToken[1] : this.currToken[0] === "space" && (s.value = this.parseSpace(this.currToken[1], " ")), this.position++;
            return this.newNode(s);
          }, t.prototype.comma = function() {
            if (this.position === this.tokens.length - 1) {
              this.root.trailingComma = true, this.position++;
              return;
            }
            var s = new Ys2.default();
            this.current.parent.append(s), this.current = s, this.position++;
          }, t.prototype.comment = function() {
            var s = new zd2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
            this.newNode(s), this.position++;
          }, t.prototype.error = function(s) {
            throw new this.input.error(s);
          }, t.prototype.missingBackslash = function() {
            return this.error("Expected a backslash preceding the semicolon.");
          }, t.prototype.missingParenthesis = function() {
            return this.error("Expected opening parenthesis.");
          }, t.prototype.missingSquareBracket = function() {
            return this.error("Expected opening square bracket.");
          }, t.prototype.namespace = function() {
            var s = this.prevToken && this.prevToken[1] || true;
            if (this.nextToken[0] === "word") return this.position++, this.word(s);
            if (this.nextToken[0] === "*") return this.position++, this.universal(s);
          }, t.prototype.nesting = function() {
            this.newNode(new om2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
          }, t.prototype.parentheses = function() {
            var s = this.current.last;
            if (s && s.type === fm2.PSEUDO) {
              var r = new Ys2.default(), n = this.current;
              s.append(r), this.current = r;
              var i = 1;
              for (this.position++; this.position < this.tokens.length && i; ) this.currToken[0] === "(" && i++, this.currToken[0] === ")" && i--, i ? this.parse() : (r.parent.source.end.line = this.currToken[2], r.parent.source.end.column = this.currToken[3], this.position++);
              i && this.error("Expected closing parenthesis."), this.current = n;
            } else {
              var o = 1;
              for (this.position++, s.value += "("; this.position < this.tokens.length && o; ) this.currToken[0] === "(" && o++, this.currToken[0] === ")" && o--, s.value += this.parseParenthesisToken(this.currToken), this.position++;
              o && this.error("Expected closing parenthesis.");
            }
          }, t.prototype.pseudo = function() {
            for (var s = this, r = "", n = this.currToken; this.currToken && this.currToken[0] === ":"; ) r += this.currToken[1], this.position++;
            if (!this.currToken) return this.error("Expected pseudo-class or pseudo-element");
            if (this.currToken[0] === "word") {
              var i = void 0;
              this.splitWord(false, function(o, a) {
                r += o, i = new Xd2.default({ value: r, source: { start: { line: n[2], column: n[3] }, end: { line: s.currToken[4], column: s.currToken[5] } }, sourceIndex: n[4] }), s.newNode(i), a > 1 && s.nextToken && s.nextToken[0] === "(" && s.error("Misplaced parenthesis.");
              });
            } else this.error('Unexpected "' + this.currToken[0] + '" found.');
          }, t.prototype.space = function() {
            var s = this.currToken;
            this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(s[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(s[1]), this.position++) : this.combinator();
          }, t.prototype.string = function() {
            var s = this.currToken;
            this.newNode(new Qd2.default({ value: this.currToken[1], source: { start: { line: s[2], column: s[3] }, end: { line: s[4], column: s[5] } }, sourceIndex: s[6] })), this.position++;
          }, t.prototype.universal = function(s) {
            var r = this.nextToken;
            if (r && r[1] === "|") return this.position++, this.namespace();
            this.newNode(new rm2.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), s), this.position++;
          }, t.prototype.splitWord = function(s, r) {
            for (var n = this, i = this.nextToken, o = this.currToken[1]; i && i[0] === "word"; ) {
              this.position++;
              var a = this.currToken[1];
              if (o += a, a.lastIndexOf("\\") === a.length - 1) {
                var u = this.nextToken;
                u && u[0] === "space" && (o += this.parseSpace(u[1], " "), this.position++);
              }
              i = this.nextToken;
            }
            var c = (0, Ws2.default)(o, "."), f = (0, Ws2.default)(o, "#"), p = (0, Ws2.default)(o, "#{");
            p.length && (f = f.filter(function(w) {
              return !~p.indexOf(w);
            }));
            var l = (0, um2.default)((0, Md2.default)((0, qd2.default)([[0], c, f])));
            l.forEach(function(w, x) {
              var h = l[x + 1] || o.length, d2 = o.slice(w, h);
              if (x === 0 && r) return r.call(n, d2, l.length);
              var m = void 0;
              ~c.indexOf(w) ? m = new Wd2.default({ value: d2.slice(1), source: { start: { line: n.currToken[2], column: n.currToken[3] + w }, end: { line: n.currToken[4], column: n.currToken[3] + (h - 1) } }, sourceIndex: n.currToken[6] + l[x] }) : ~f.indexOf(w) ? m = new Gd2.default({ value: d2.slice(1), source: { start: { line: n.currToken[2], column: n.currToken[3] + w }, end: { line: n.currToken[4], column: n.currToken[3] + (h - 1) } }, sourceIndex: n.currToken[6] + l[x] }) : m = new Hd2.default({ value: d2, source: { start: { line: n.currToken[2], column: n.currToken[3] + w }, end: { line: n.currToken[4], column: n.currToken[3] + (h - 1) } }, sourceIndex: n.currToken[6] + l[x] }), n.newNode(m, s);
            }), this.position++;
          }, t.prototype.word = function(s) {
            var r = this.nextToken;
            return r && r[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(s);
          }, t.prototype.loop = function() {
            for (; this.position < this.tokens.length; ) this.parse(true);
            return this.root;
          }, t.prototype.parse = function(s) {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parentheses();
                break;
              case ")":
                s && this.missingParenthesis();
                break;
              case "[":
                this.attribute();
                break;
              case "]":
                this.missingSquareBracket();
                break;
              case "at-word":
              case "word":
                this.word();
                break;
              case ":":
                this.pseudo();
                break;
              case ";":
                this.missingBackslash();
                break;
              case ",":
                this.comma();
                break;
              case "*":
                this.universal();
                break;
              case "&":
                this.nesting();
                break;
              case "combinator":
                this.combinator();
                break;
              case "string":
                this.string();
                break;
            }
          }, t.prototype.parseNamespace = function(s) {
            if (this.lossy && typeof s == "string") {
              var r = s.trim();
              return r.length ? r : true;
            }
            return s;
          }, t.prototype.parseSpace = function(s, r) {
            return this.lossy ? r || "" : s;
          }, t.prototype.parseValue = function(s) {
            return this.lossy && s && typeof s == "string" ? s.trim() : s;
          }, t.prototype.parseParenthesisToken = function(s) {
            return this.lossy ? s[0] === "space" ? this.parseSpace(s[1], " ") : this.parseValue(s[1]) : s[1];
          }, t.prototype.newNode = function(s, r) {
            return r && (s.namespace = this.parseNamespace(r)), this.spaces && (s.spaces.before = this.spaces, this.spaces = ""), this.current.append(s);
          }, Rd2(t, [{ key: "currToken", get: function() {
            return this.tokens[this.position];
          } }, { key: "nextToken", get: function() {
            return this.tokens[this.position + 1];
          } }, { key: "prevToken", get: function() {
            return this.tokens[this.position - 1];
          } }]), t;
        }();
        Er2.default = dm2;
        eu2.exports = Er2.default;
      });
      var su2 = y2((Sr2, ru2) => {
        "use strict";
        Sr2.__esModule = true;
        var mm2 = /* @__PURE__ */ function() {
          function t(e, s) {
            for (var r = 0; r < s.length; r++) {
              var n = s[r];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
            }
          }
          return function(e, s, r) {
            return s && t(e.prototype, s), r && t(e, r), e;
          };
        }(), ym2 = tu3(), wm2 = gm2(ym2);
        function gm2(t) {
          return t && t.__esModule ? t : { default: t };
        }
        function vm2(t, e) {
          if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
        }
        var xm2 = function() {
          function t(e) {
            return vm2(this, t), this.func = e || function() {
            }, this;
          }
          return t.prototype.process = function(s) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = new wm2.default({ css: s, error: function(o) {
              throw new Error(o);
            }, options: r });
            return this.res = n, this.func(n), this;
          }, mm2(t, [{ key: "result", get: function() {
            return String(this.res);
          } }]), t;
        }();
        Sr2.default = xm2;
        ru2.exports = Sr2.default;
      });
      var z = y2((Tx, iu2) => {
        "use strict";
        var zs2 = function(t, e) {
          let s = new t.constructor();
          for (let r in t) {
            if (!t.hasOwnProperty(r)) continue;
            let n = t[r], i = typeof n;
            r === "parent" && i === "object" ? e && (s[r] = e) : r === "source" ? s[r] = n : n instanceof Array ? s[r] = n.map((o) => zs2(o, s)) : r !== "before" && r !== "after" && r !== "between" && r !== "semicolon" && (i === "object" && n !== null && (n = zs2(n)), s[r] = n);
          }
          return s;
        };
        iu2.exports = class {
          constructor(e) {
            e = e || {}, this.raws = { before: "", after: "" };
            for (let s in e) this[s] = e[s];
          }
          remove() {
            return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
          }
          toString() {
            return [this.raws.before, String(this.value), this.raws.after].join("");
          }
          clone(e) {
            e = e || {};
            let s = zs2(this);
            for (let r in e) s[r] = e[r];
            return s;
          }
          cloneBefore(e) {
            e = e || {};
            let s = this.clone(e);
            return this.parent.insertBefore(this, s), s;
          }
          cloneAfter(e) {
            e = e || {};
            let s = this.clone(e);
            return this.parent.insertAfter(this, s), s;
          }
          replaceWith() {
            let e = Array.prototype.slice.call(arguments);
            if (this.parent) {
              for (let s of e) this.parent.insertBefore(this, s);
              this.remove();
            }
            return this;
          }
          moveTo(e) {
            return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
          }
          moveBefore(e) {
            return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
          }
          moveAfter(e) {
            return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
          }
          next() {
            let e = this.parent.index(this);
            return this.parent.nodes[e + 1];
          }
          prev() {
            let e = this.parent.index(this);
            return this.parent.nodes[e - 1];
          }
          toJSON() {
            let e = {};
            for (let s in this) {
              if (!this.hasOwnProperty(s) || s === "parent") continue;
              let r = this[s];
              r instanceof Array ? e[s] = r.map((n) => typeof n == "object" && n.toJSON ? n.toJSON() : n) : typeof r == "object" && r.toJSON ? e[s] = r.toJSON() : e[s] = r;
            }
            return e;
          }
          root() {
            let e = this;
            for (; e.parent; ) e = e.parent;
            return e;
          }
          cleanRaws(e) {
            delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
          }
          positionInside(e) {
            let s = this.toString(), r = this.source.start.column, n = this.source.start.line;
            for (let i = 0; i < e; i++) s[i] === `
` ? (r = 1, n += 1) : r += 1;
            return { line: n, column: r };
          }
          positionBy(e) {
            let s = this.source.start;
            if (Object(e).index) s = this.positionInside(e.index);
            else if (Object(e).word) {
              let r = this.toString().indexOf(e.word);
              r !== -1 && (s = this.positionInside(r));
            }
            return s;
          }
        };
      });
      var U = y2((Ox, ou2) => {
        "use strict";
        var _m2 = z(), Le2 = class extends _m2 {
          constructor(e) {
            super(e), this.nodes || (this.nodes = []);
          }
          push(e) {
            return e.parent = this, this.nodes.push(e), this;
          }
          each(e) {
            this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
            let s = this.lastEach, r, n;
            if (this.indexes[s] = 0, !!this.nodes) {
              for (; this.indexes[s] < this.nodes.length && (r = this.indexes[s], n = e(this.nodes[r], r), n !== false); ) this.indexes[s] += 1;
              return delete this.indexes[s], n;
            }
          }
          walk(e) {
            return this.each((s, r) => {
              let n = e(s, r);
              return n !== false && s.walk && (n = s.walk(e)), n;
            });
          }
          walkType(e, s) {
            if (!e || !s) throw new Error("Parameters {type} and {callback} are required.");
            let r = typeof e == "function";
            return this.walk((n, i) => {
              if (r && n instanceof e || !r && n.type === e) return s.call(this, n, i);
            });
          }
          append(e) {
            return e.parent = this, this.nodes.push(e), this;
          }
          prepend(e) {
            return e.parent = this, this.nodes.unshift(e), this;
          }
          cleanRaws(e) {
            if (super.cleanRaws(e), this.nodes) for (let s of this.nodes) s.cleanRaws(e);
          }
          insertAfter(e, s) {
            let r = this.index(e), n;
            this.nodes.splice(r + 1, 0, s);
            for (let i in this.indexes) n = this.indexes[i], r <= n && (this.indexes[i] = n + this.nodes.length);
            return this;
          }
          insertBefore(e, s) {
            let r = this.index(e), n;
            this.nodes.splice(r, 0, s);
            for (let i in this.indexes) n = this.indexes[i], r <= n && (this.indexes[i] = n + this.nodes.length);
            return this;
          }
          removeChild(e) {
            e = this.index(e), this.nodes[e].parent = void 0, this.nodes.splice(e, 1);
            let s;
            for (let r in this.indexes) s = this.indexes[r], s >= e && (this.indexes[r] = s - 1);
            return this;
          }
          removeAll() {
            for (let e of this.nodes) e.parent = void 0;
            return this.nodes = [], this;
          }
          every(e) {
            return this.nodes.every(e);
          }
          some(e) {
            return this.nodes.some(e);
          }
          index(e) {
            return typeof e == "number" ? e : this.nodes.indexOf(e);
          }
          get first() {
            if (this.nodes) return this.nodes[0];
          }
          get last() {
            if (this.nodes) return this.nodes[this.nodes.length - 1];
          }
          toString() {
            let e = this.nodes.map(String).join("");
            return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
          }
        };
        Le2.registerWalker = (t) => {
          let e = "walk" + t.name;
          e.lastIndexOf("s") !== e.length - 1 && (e += "s"), !Le2.prototype[e] && (Le2.prototype[e] = function(s) {
            return this.walkType(t, s);
          });
        };
        ou2.exports = Le2;
      });
      var uu2 = y2((Ax, au2) => {
        "use strict";
        var km2 = U();
        au2.exports = class extends km2 {
          constructor(e) {
            super(e), this.type = "root";
          }
        };
      });
      var cu2 = y2((Px, lu2) => {
        "use strict";
        var Em2 = U();
        lu2.exports = class extends Em2 {
          constructor(e) {
            super(e), this.type = "value", this.unbalanced = 0;
          }
        };
      });
      var hu = y2((Rx, pu) => {
        "use strict";
        var fu = U(), Tr2 = class extends fu {
          constructor(e) {
            super(e), this.type = "atword";
          }
          toString() {
            let e = this.quoted ? this.raws.quote : "";
            return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
          }
        };
        fu.registerWalker(Tr2);
        pu.exports = Tr2;
      });
      var mu = y2((Ix, du) => {
        "use strict";
        var Sm2 = U(), Tm2 = z(), Or2 = class extends Tm2 {
          constructor(e) {
            super(e), this.type = "colon";
          }
        };
        Sm2.registerWalker(Or2);
        du.exports = Or2;
      });
      var wu2 = y2((qx, yu2) => {
        "use strict";
        var Om2 = U(), Cm2 = z(), Cr2 = class extends Cm2 {
          constructor(e) {
            super(e), this.type = "comma";
          }
        };
        Om2.registerWalker(Cr2);
        yu2.exports = Cr2;
      });
      var vu2 = y2((Lx, gu) => {
        "use strict";
        var Am2 = U(), Nm2 = z(), Ar2 = class extends Nm2 {
          constructor(e) {
            super(e), this.type = "comment", this.inline = Object(e).inline || false;
          }
          toString() {
            return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
          }
        };
        Am2.registerWalker(Ar2);
        gu.exports = Ar2;
      });
      var _u2 = y2((Dx, bu2) => {
        "use strict";
        var xu2 = U(), Nr2 = class extends xu2 {
          constructor(e) {
            super(e), this.type = "func", this.unbalanced = -1;
          }
        };
        xu2.registerWalker(Nr2);
        bu2.exports = Nr2;
      });
      var Eu = y2((Mx, ku2) => {
        "use strict";
        var Pm2 = U(), Rm2 = z(), Pr2 = class extends Rm2 {
          constructor(e) {
            super(e), this.type = "number", this.unit = Object(e).unit || "";
          }
          toString() {
            return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
          }
        };
        Pm2.registerWalker(Pr2);
        ku2.exports = Pr2;
      });
      var Tu = y2((Bx, Su) => {
        "use strict";
        var Im2 = U(), qm2 = z(), Rr2 = class extends qm2 {
          constructor(e) {
            super(e), this.type = "operator";
          }
        };
        Im2.registerWalker(Rr2);
        Su.exports = Rr2;
      });
      var Cu2 = y2((Ux2, Ou) => {
        "use strict";
        var Lm2 = U(), Dm2 = z(), Ir2 = class extends Dm2 {
          constructor(e) {
            super(e), this.type = "paren", this.parenType = "";
          }
        };
        Lm2.registerWalker(Ir2);
        Ou.exports = Ir2;
      });
      var Nu2 = y2((Fx, Au) => {
        "use strict";
        var Mm2 = U(), Bm2 = z(), qr2 = class extends Bm2 {
          constructor(e) {
            super(e), this.type = "string";
          }
          toString() {
            let e = this.quoted ? this.raws.quote : "";
            return [this.raws.before, e, this.value + "", e, this.raws.after].join("");
          }
        };
        Mm2.registerWalker(qr2);
        Au.exports = qr2;
      });
      var Ru = y2(($x, Pu2) => {
        "use strict";
        var Um2 = U(), Fm2 = z(), Lr2 = class extends Fm2 {
          constructor(e) {
            super(e), this.type = "word";
          }
        };
        Um2.registerWalker(Lr2);
        Pu2.exports = Lr2;
      });
      var qu2 = y2((Wx, Iu2) => {
        "use strict";
        var $m2 = U(), Wm2 = z(), Dr2 = class extends Wm2 {
          constructor(e) {
            super(e), this.type = "unicode-range";
          }
        };
        $m2.registerWalker(Dr2);
        Iu2.exports = Dr2;
      });
      var Du2 = y2((Yx, Lu2) => {
        "use strict";
        var Vs2 = class extends Error {
          constructor(e) {
            super(e), this.name = this.constructor.name, this.message = e || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack;
          }
        };
        Lu2.exports = Vs2;
      });
      var Uu2 = y2((zx, Bu2) => {
        "use strict";
        var Mr2 = /[ \n\t\r\{\(\)'"\\;,/]/g, Ym2 = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, De = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, zm2 = /^[a-z0-9]/i, Vm2 = /^[a-f0-9?\-]/i, Mu2 = Du2();
        Bu2.exports = function(e, s) {
          s = s || {};
          let r = [], n = e.valueOf(), i = n.length, o = -1, a = 1, u = 0, c = 0, f = null, p, l, w, x, h, d2, m, b, g, v2, R, F;
          function H(T3) {
            let O = `Unclosed ${T3} at line: ${a}, column: ${u - o}, token: ${u}`;
            throw new Mu2(O);
          }
          function $() {
            let T3 = `Syntax error at line: ${a}, column: ${u - o}, token: ${u}`;
            throw new Mu2(T3);
          }
          for (; u < i; ) {
            switch (p = n.charCodeAt(u), p === 10 && (o = u, a += 1), p) {
              case 10:
              case 32:
              case 9:
              case 13:
              case 12:
                l = u;
                do
                  l += 1, p = n.charCodeAt(l), p === 10 && (o = l, a += 1);
                while (p === 32 || p === 10 || p === 9 || p === 13 || p === 12);
                r.push(["space", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                break;
              case 58:
                l = u + 1, r.push(["colon", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                break;
              case 44:
                l = u + 1, r.push(["comma", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                break;
              case 123:
                r.push(["{", "{", a, u - o, a, l - o, u]);
                break;
              case 125:
                r.push(["}", "}", a, u - o, a, l - o, u]);
                break;
              case 40:
                c++, f = !f && c === 1 && r.length > 0 && r[r.length - 1][0] === "word" && r[r.length - 1][1] === "url", r.push(["(", "(", a, u - o, a, l - o, u]);
                break;
              case 41:
                c--, f = f && c > 0, r.push([")", ")", a, u - o, a, l - o, u]);
                break;
              case 39:
              case 34:
                w = p === 39 ? "'" : '"', l = u;
                do
                  for (v2 = false, l = n.indexOf(w, l + 1), l === -1 && H("quote", w), R = l; n.charCodeAt(R - 1) === 92; ) R -= 1, v2 = !v2;
                while (v2);
                r.push(["string", n.slice(u, l + 1), a, u - o, a, l - o, u]), u = l;
                break;
              case 64:
                Mr2.lastIndex = u + 1, Mr2.test(n), Mr2.lastIndex === 0 ? l = n.length - 1 : l = Mr2.lastIndex - 2, r.push(["atword", n.slice(u, l + 1), a, u - o, a, l - o, u]), u = l;
                break;
              case 92:
                l = u, p = n.charCodeAt(l + 1), m && p !== 47 && p !== 32 && p !== 10 && p !== 9 && p !== 13 && p !== 12 && (l += 1), r.push(["word", n.slice(u, l + 1), a, u - o, a, l - o, u]), u = l;
                break;
              case 43:
              case 45:
              case 42:
                l = u + 1, F = n.slice(u + 1, l + 1);
                let T3 = n.slice(u - 1, u);
                if (p === 45 && F.charCodeAt(0) === 45) {
                  l++, r.push(["word", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                  break;
                }
                r.push(["operator", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                break;
              default:
                if (p === 47 && (n.charCodeAt(u + 1) === 42 || s.loose && !f && n.charCodeAt(u + 1) === 47)) {
                  if (n.charCodeAt(u + 1) === 42) l = n.indexOf("*/", u + 2) + 1, l === 0 && H("comment", "*/");
                  else {
                    let C = n.indexOf(`
`, u + 2);
                    l = C !== -1 ? C - 1 : i;
                  }
                  d2 = n.slice(u, l + 1), x = d2.split(`
`), h = x.length - 1, h > 0 ? (b = a + h, g = l - x[h].length) : (b = a, g = o), r.push(["comment", d2, a, u - o, b, l - g, u]), o = g, a = b, u = l;
                } else if (p === 35 && !zm2.test(n.slice(u + 1, u + 2))) l = u + 1, r.push(["#", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                else if ((p === 117 || p === 85) && n.charCodeAt(u + 1) === 43) {
                  l = u + 2;
                  do
                    l += 1, p = n.charCodeAt(l);
                  while (l < i && Vm2.test(n.slice(l, l + 1)));
                  r.push(["unicoderange", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                } else if (p === 47) l = u + 1, r.push(["operator", n.slice(u, l), a, u - o, a, l - o, u]), u = l - 1;
                else {
                  let O = Ym2;
                  if (p >= 48 && p <= 57 && (O = De), O.lastIndex = u + 1, O.test(n), O.lastIndex === 0 ? l = n.length - 1 : l = O.lastIndex - 2, O === De || p === 46) {
                    let C = n.charCodeAt(l), me = n.charCodeAt(l + 1), Qs = n.charCodeAt(l + 2);
                    (C === 101 || C === 69) && (me === 45 || me === 43) && Qs >= 48 && Qs <= 57 && (De.lastIndex = l + 2, De.test(n), De.lastIndex === 0 ? l = n.length - 1 : l = De.lastIndex - 2);
                  }
                  r.push(["word", n.slice(u, l + 1), a, u - o, a, l - o, u]), u = l;
                }
                break;
            }
            u++;
          }
          return r;
        };
      });
      var $u2 = y2((Vx, Fu2) => {
        "use strict";
        var Gs = class extends Error {
          constructor(e) {
            super(e), this.name = this.constructor.name, this.message = e || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(e).stack;
          }
        };
        Fu2.exports = Gs;
      });
      var Vu2 = y2((jx, zu2) => {
        "use strict";
        var Gm2 = uu2(), jm2 = cu2(), Hm2 = hu(), Km2 = mu(), Qm2 = wu2(), Jm2 = vu2(), Xm2 = _u2(), Zm2 = Eu(), ey2 = Tu(), Wu2 = Cu2(), ty2 = Nu2(), Yu2 = Ru(), ry2 = qu2(), sy2 = Uu2(), ny2 = qs2(), iy2 = Ls2(), oy2 = Ds2(), ay2 = $u2();
        function uy2(t) {
          return t.sort((e, s) => e - s);
        }
        zu2.exports = class {
          constructor(e, s) {
            let r = { loose: false };
            this.cache = [], this.input = e, this.options = Object.assign({}, r, s), this.position = 0, this.unbalanced = 0, this.root = new Gm2();
            let n = new jm2();
            this.root.append(n), this.current = n, this.tokens = sy2(e, this.options);
          }
          parse() {
            return this.loop();
          }
          colon() {
            let e = this.currToken;
            this.newNode(new Km2({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
          }
          comma() {
            let e = this.currToken;
            this.newNode(new Qm2({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
          }
          comment() {
            let e = false, s = this.currToken[1].replace(/\/\*|\*\//g, ""), r;
            this.options.loose && s.startsWith("//") && (s = s.substring(2), e = true), r = new Jm2({ value: s, inline: e, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(r), this.position++;
          }
          error(e, s) {
            throw new ay2(e + ` at line: ${s[2]}, column ${s[3]}`);
          }
          loop() {
            for (; this.position < this.tokens.length; ) this.parseTokens();
            return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
          }
          operator() {
            let e = this.currToken[1], s;
            if (e === "+" || e === "-") {
              if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
                if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word") return this.word();
              } else if (this.nextToken[0] === "word") return this.word();
            }
            return s = new ey2({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(s);
          }
          parseTokens() {
            switch (this.currToken[0]) {
              case "space":
                this.space();
                break;
              case "colon":
                this.colon();
                break;
              case "comma":
                this.comma();
                break;
              case "comment":
                this.comment();
                break;
              case "(":
                this.parenOpen();
                break;
              case ")":
                this.parenClose();
                break;
              case "atword":
              case "word":
                this.word();
                break;
              case "operator":
                this.operator();
                break;
              case "string":
                this.string();
                break;
              case "unicoderange":
                this.unicodeRange();
                break;
              default:
                this.word();
                break;
            }
          }
          parenOpen() {
            let e = 1, s = this.position + 1, r = this.currToken, n;
            for (; s < this.tokens.length && e; ) {
              let i = this.tokens[s];
              i[0] === "(" && e++, i[0] === ")" && e--, s++;
            }
            if (e && this.error("Expected closing parenthesis", r), n = this.current.last, n && n.type === "func" && n.unbalanced < 0 && (n.unbalanced = 0, this.current = n), this.current.unbalanced++, this.newNode(new Wu2({ value: r[1], source: { start: { line: r[2], column: r[3] }, end: { line: r[4], column: r[5] } }, sourceIndex: r[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
              let i = this.nextToken, o = this.currToken[1], a = { line: this.currToken[2], column: this.currToken[3] };
              for (; i && i[0] !== ")" && this.current.unbalanced; ) this.position++, o += this.currToken[1], i = this.nextToken;
              this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new Yu2({ value: o, source: { start: a, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
            }
          }
          parenClose() {
            let e = this.currToken;
            this.newNode(new Wu2({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
          }
          space() {
            let e = this.currToken;
            this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += e[1], this.position++) : (this.spaces = e[1], this.position++);
          }
          unicodeRange() {
            let e = this.currToken;
            this.newNode(new ry2({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
          }
          splitWord() {
            let e = this.nextToken, s = this.currToken[1], r = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, n = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, i, o;
            if (!n.test(s)) for (; e && e[0] === "word"; ) {
              this.position++;
              let a = this.currToken[1];
              s += a, e = this.nextToken;
            }
            i = iy2(s, "@"), o = uy2(oy2(ny2([[0], i]))), o.forEach((a, u) => {
              let c = o[u + 1] || s.length, f = s.slice(a, c), p;
              if (~i.indexOf(a)) p = new Hm2({ value: f.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + o[u] });
              else if (r.test(this.currToken[1])) {
                let l = f.replace(r, "");
                p = new Zm2({ value: f.replace(l, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + o[u], unit: l });
              } else p = new (e && e[0] === "(" ? Xm2 : Yu2)({ value: f, source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + o[u] }), p.type === "word" ? (p.isHex = /^#(.+)/.test(f), p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(f)) : this.cache.push(this.current);
              this.newNode(p);
            }), this.position++;
          }
          string() {
            let e = this.currToken, s = this.currToken[1], r = /^(\"|\')/, n = r.test(s), i = "", o;
            n && (i = s.match(r)[0], s = s.slice(1, s.length - 1)), o = new ty2({ value: s, source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6], quoted: n }), o.raws.quote = i, this.newNode(o), this.position++;
          }
          word() {
            return this.splitWord();
          }
          newNode(e) {
            return this.spaces && (e.raws.before += this.spaces, this.spaces = ""), this.current.append(e);
          }
          get currToken() {
            return this.tokens[this.position];
          }
          get nextToken() {
            return this.tokens[this.position + 1];
          }
          get prevToken() {
            return this.tokens[this.position - 1];
          }
        };
      });
      var Sy2 = {};
      Js2(Sy2, { languages: () => pi, options: () => di, parsers: () => Ks2, printers: () => Ey2 });
      var hl2 = (t, e, s, r) => {
        if (!(t && e == null)) return e.replaceAll ? e.replaceAll(s, r) : s.global ? e.replace(s, r) : e.split(s).join(r);
      }, _2 = hl2;
      var Me = "string", Be3 = "array", Ue = "cursor", we = "indent", ge = "align", Fe2 = "trim", ve2 = "group", xe = "fill", oe = "if-break", $e = "indent-if-break", We = "line-suffix", Ye3 = "line-suffix-boundary", K = "line", ze2 = "label", be2 = "break-parent", _t2 = /* @__PURE__ */ new Set([Ue, we, ge, Fe2, ve2, xe, oe, $e, We, Ye3, K, ze2, be2]);
      function dl2(t) {
        if (typeof t == "string") return Me;
        if (Array.isArray(t)) return Be3;
        if (!t) return;
        let { type: e } = t;
        if (_t2.has(e)) return e;
      }
      var Ve2 = dl2;
      var ml2 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
      function yl2(t) {
        let e = t === null ? "null" : typeof t;
        if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
        if (Ve2(t)) throw new Error("doc is valid.");
        let s = Object.prototype.toString.call(t);
        if (s !== "[object Object]") return `Unexpected doc '${s}'.`;
        let r = ml2([..._t2].map((n) => `'${n}'`));
        return `Unexpected doc.type '${t.type}'.
Expected it to be ${r}.`;
      }
      var Fr2 = class extends Error {
        constructor(e) {
          super(yl2(e));
          __publicField(this, "name", "InvalidDocError");
          this.doc = e;
        }
      }, $r2 = Fr2;
      var Zs2 = () => {
      }, ae = Zs2, kt2 = Zs2;
      function q(t) {
        return ae(t), { type: we, contents: t };
      }
      function en2(t, e) {
        return ae(e), { type: ge, contents: e, n: t };
      }
      function L(t, e = {}) {
        return ae(t), kt2(e.expandedStates, true), { type: ve2, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
      }
      function tn2(t) {
        return en2({ type: "root" }, t);
      }
      function ue2(t) {
        return en2(-1, t);
      }
      function Ge(t) {
        return kt2(t), { type: xe, parts: t };
      }
      function Et2(t, e = "", s = {}) {
        return ae(t), e !== "" && ae(e), { type: oe, breakContents: t, flatContents: e, groupId: s.groupId };
      }
      var je = { type: be2 };
      var wl2 = { type: K, hard: true };
      var A = { type: K }, M = { type: K, soft: true }, E = [wl2, je];
      function V(t, e) {
        ae(t), kt2(e);
        let s = [];
        for (let r = 0; r < e.length; r++) r !== 0 && s.push(t), s.push(e[r]);
        return s;
      }
      var gl2 = (t, e, s) => {
        if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[s < 0 ? e.length + s : s] : e.at(s);
      }, G = gl2;
      function vl2(t, e) {
        if (typeof t == "string") return e(t);
        let s = /* @__PURE__ */ new Map();
        return r(t);
        function r(i) {
          if (s.has(i)) return s.get(i);
          let o = n(i);
          return s.set(i, o), o;
        }
        function n(i) {
          switch (Ve2(i)) {
            case Be3:
              return e(i.map(r));
            case xe:
              return e({ ...i, parts: i.parts.map(r) });
            case oe:
              return e({ ...i, breakContents: r(i.breakContents), flatContents: r(i.flatContents) });
            case ve2: {
              let { expandedStates: o, contents: a } = i;
              return o ? (o = o.map(r), a = o[0]) : a = r(a), e({ ...i, contents: a, expandedStates: o });
            }
            case ge:
            case we:
            case $e:
            case ze2:
            case We:
              return e({ ...i, contents: r(i.contents) });
            case Me:
            case Ue:
            case Fe2:
            case Ye3:
            case K:
            case be2:
              return e(i);
            default:
              throw new $r2(i);
          }
        }
      }
      function xl2(t) {
        return t.type === K && !t.hard ? t.soft ? "" : " " : t.type === oe ? t.flatContents : t;
      }
      function rn2(t) {
        return vl2(t, xl2);
      }
      function bl2(t) {
        return Array.isArray(t) && t.length > 0;
      }
      var ee = bl2;
      var St2 = "'", sn2 = '"';
      function _l2(t, e) {
        let s = e === true || e === St2 ? St2 : sn2, r = s === St2 ? sn2 : St2, n = 0, i = 0;
        for (let o of t) o === s ? n++ : o === r && i++;
        return n > i ? r : s;
      }
      var nn2 = _l2;
      function kl2(t, e, s) {
        let r = e === '"' ? "'" : '"', i = _2(false, t, /\\(.)|(["'])/gsu, (o, a, u) => a === r ? a : u === e ? "\\" + u : u || (s && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(a) ? a : "\\" + a));
        return e + i + e;
      }
      var on2 = kl2;
      function El2(t, e) {
        let s = t.slice(1, -1), r = e.parser === "json" || e.parser === "jsonc" || e.parser === "json5" && e.quoteProps === "preserve" && !e.singleQuote ? '"' : e.__isInHtmlAttribute ? "'" : nn2(s, e.singleQuote);
        return on2(s, r, !(e.parser === "css" || e.parser === "less" || e.parser === "scss" || e.__embeddedInHtml));
      }
      var Tt = El2;
      var Wr2 = class extends Error {
        constructor(e, s, r = "type") {
          super(`Unexpected ${s} node ${r}: ${JSON.stringify(e[r])}.`);
          __publicField(this, "name", "UnexpectedNodeError");
          this.node = e;
        }
      }, an2 = Wr2;
      function Sl2(t) {
        return (t == null ? void 0 : t.type) === "front-matter";
      }
      var _e3 = Sl2;
      var Tl2 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma", "spaces"]);
      function un2(t, e, s) {
        if (_e3(t) && t.language === "yaml" && delete e.value, t.type === "css-comment" && s.type === "css-root" && s.nodes.length > 0 && ((s.nodes[0] === t || _e3(s.nodes[0]) && s.nodes[1] === t) && (delete e.text, /^\*\s*@(?:format|prettier)\s*$/u.test(t.text)) || s.type === "css-root" && G(false, s.nodes, -1) === t)) return null;
        if (t.type === "value-root" && delete e.text, (t.type === "media-query" || t.type === "media-query-list" || t.type === "media-feature-expression") && delete e.value, t.type === "css-rule" && delete e.params, (t.type === "media-feature" || t.type === "media-keyword" || t.type === "media-type" || t.type === "media-unknown" || t.type === "media-url" || t.type === "media-value" || t.type === "selector-attribute" || t.type === "selector-string" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "value-string") && t.value && (e.value = Ol2(t.value)), t.type === "selector-combinator" && (e.value = _2(false, e.value, /\s+/gu, " ")), t.type === "media-feature" && (e.value = _2(false, e.value, " ", "")), (t.type === "value-word" && (t.isColor && t.isHex || ["initial", "inherit", "unset", "revert"].includes(t.value.toLowerCase())) || t.type === "media-feature" || t.type === "selector-root-invalid" || t.type === "selector-pseudo") && (e.value = e.value.toLowerCase()), t.type === "css-decl" && (e.prop = t.prop.toLowerCase()), (t.type === "css-atrule" || t.type === "css-import") && (e.name = t.name.toLowerCase()), t.type === "value-number" && (e.unit = t.unit.toLowerCase()), t.type === "value-unknown" && (e.value = _2(false, e.value, /;$/gu, "")), t.type === "selector-attribute" && (e.attribute = t.attribute.trim(), t.namespace && typeof t.namespace == "string" && (e.namespace = t.namespace.trim() || true), t.value && (e.value = _2(false, e.value.trim(), /^["']|["']$/gu, ""), delete e.quoted)), (t.type === "media-value" || t.type === "media-type" || t.type === "value-number" || t.type === "selector-root-invalid" || t.type === "selector-class" || t.type === "selector-combinator" || t.type === "selector-tag") && t.value && (e.value = _2(false, e.value, /([\d+.e-]+)([a-z]*)/giu, (r, n, i) => {
          let o = Number(n);
          return Number.isNaN(o) ? r : o + i.toLowerCase();
        })), t.type === "selector-tag") {
          let r = e.value.toLowerCase();
          ["from", "to"].includes(r) && (e.value = r);
        }
        if (t.type === "css-atrule" && t.name.toLowerCase() === "supports" && delete e.value, t.type === "selector-unknown" && delete e.value, t.type === "value-comma_group") {
          let r = t.groups.findIndex((n) => n.type === "value-number" && n.unit === "...");
          r !== -1 && (e.groups[r].unit = "", e.groups.splice(r + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
        }
        if (t.type === "value-comma_group" && t.groups.some((r) => r.type === "value-atword" && r.value.endsWith("[") || r.type === "value-word" && r.value.startsWith("]"))) return { type: "value-atword", value: t.groups.map((r) => r.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
      }
      un2.ignoredProperties = Tl2;
      function Ol2(t) {
        return _2(false, _2(false, t, "'", '"'), /\\([^\da-f])/giu, "$1");
      }
      var ln2 = un2;
      async function Cl2(t, e) {
        if (t.language === "yaml") {
          let s = t.value.trim(), r = s ? await e(s, { parser: "yaml" }) : "";
          return tn2([t.startDelimiter, t.explicitLanguage, E, r, r ? E : "", t.endDelimiter]);
        }
      }
      var cn2 = Cl2;
      function fn2(t) {
        let { node: e } = t;
        if (e.type === "front-matter") return async (s) => {
          let r = await cn2(e, s);
          return r ? [r, E] : void 0;
        };
      }
      fn2.getVisitorKeys = (t) => t.type === "css-root" ? ["frontMatter"] : [];
      var pn2 = fn2;
      var He2 = null;
      function Ke2(t) {
        if (He2 !== null && typeof He2.property) {
          let e = He2;
          return He2 = Ke2.prototype = null, e;
        }
        return He2 = Ke2.prototype = t ?? /* @__PURE__ */ Object.create(null), new Ke2();
      }
      var Al2 = 10;
      for (let t = 0; t <= Al2; t++) Ke2();
      function Yr2(t) {
        return Ke2(t);
      }
      function Nl2(t, e = "type") {
        Yr2(t);
        function s(r) {
          let n = r[e], i = t[n];
          if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
          return i;
        }
        return s;
      }
      var hn2 = Nl2;
      var Pl2 = { "front-matter": [], "css-root": ["frontMatter", "nodes"], "css-comment": [], "css-rule": ["selector", "nodes"], "css-decl": ["value", "selector", "nodes"], "css-atrule": ["selector", "params", "value", "nodes"], "media-query-list": ["nodes"], "media-query": ["nodes"], "media-type": [], "media-feature-expression": ["nodes"], "media-feature": [], "media-colon": [], "media-value": [], "media-keyword": [], "media-url": [], "media-unknown": [], "selector-root": ["nodes"], "selector-selector": ["nodes"], "selector-comment": [], "selector-string": [], "selector-tag": [], "selector-id": [], "selector-class": [], "selector-attribute": [], "selector-combinator": ["nodes"], "selector-universal": [], "selector-pseudo": ["nodes"], "selector-nesting": [], "selector-unknown": [], "value-value": ["group"], "value-root": ["group"], "value-comment": [], "value-comma_group": ["groups"], "value-paren_group": ["open", "groups", "close"], "value-func": ["group"], "value-paren": [], "value-number": [], "value-operator": [], "value-word": [], "value-colon": [], "value-comma": [], "value-string": [], "value-atword": [], "value-unicode-range": [], "value-unknown": [] }, dn2 = Pl2;
      var Rl2 = hn2(dn2), mn = Rl2;
      function Il2(t, e) {
        let s = 0;
        for (let r = 0; r < t.line - 1; ++r) s = e.indexOf(`
`, s) + 1;
        return s + t.column;
      }
      var zr2 = Il2;
      function Ot2(t) {
        return (e, s, r) => {
          let n = !!(r != null && r.backwards);
          if (s === false) return false;
          let { length: i } = e, o = s;
          for (; o >= 0 && o < i; ) {
            let a = e.charAt(o);
            if (t instanceof RegExp) {
              if (!t.test(a)) return o;
            } else if (!t.includes(a)) return o;
            n ? o-- : o++;
          }
          return o === -1 || o === i ? o : false;
        };
      }
      var Tw = Ot2(/\s/u), Ct2 = Ot2(" 	"), yn2 = Ot2(",; 	"), At = Ot2(/[^\n\r]/u);
      function wn2(t, e) {
        var s, r, n;
        if (typeof ((r = (s = t.source) == null ? void 0 : s.start) == null ? void 0 : r.offset) == "number") return t.source.start.offset;
        if (typeof t.sourceIndex == "number") return t.sourceIndex;
        if ((n = t.source) != null && n.start) return zr2(t.source.start, e);
        throw Object.assign(new Error("Can not locate node."), { node: t });
      }
      function Vr2(t, e) {
        var s, r;
        if (t.type === "css-comment" && t.inline) return At(e, t.source.startOffset);
        if (typeof ((r = (s = t.source) == null ? void 0 : s.end) == null ? void 0 : r.offset) == "number") return t.source.end.offset;
        if (t.source) {
          if (t.source.end) return zr2(t.source.end, e);
          if (ee(t.nodes)) return Vr2(G(false, t.nodes, -1), e);
        }
        return null;
      }
      function Gr2(t, e) {
        t.source && (t.source.startOffset = wn2(t, e), t.source.endOffset = Vr2(t, e));
        for (let s in t) {
          let r = t[s];
          s === "source" || !r || typeof r != "object" || (r.type === "value-root" || r.type === "value-unknown" ? gn2(r, ql2(t), r.text || r.value) : Gr2(r, e));
        }
      }
      function gn2(t, e, s) {
        t.source && (t.source.startOffset = wn2(t, s) + e, t.source.endOffset = Vr2(t, s) + e);
        for (let r in t) {
          let n = t[r];
          r === "source" || !n || typeof n != "object" || gn2(n, e, s);
        }
      }
      function ql2(t) {
        var s;
        let e = t.source.startOffset;
        return typeof t.prop == "string" && (e += t.prop.length), t.type === "css-atrule" && typeof t.name == "string" && (e += 1 + t.name.length + t.raws.afterName.match(/^\s*:?\s*/u)[0].length), t.type !== "css-atrule" && typeof ((s = t.raws) == null ? void 0 : s.between) == "string" && (e += t.raws.between.length), e;
      }
      function vn(t) {
        let e = "initial", s = "initial", r, n = false, i = [];
        for (let o = 0; o < t.length; o++) {
          let a = t[o];
          switch (e) {
            case "initial":
              if (a === "'") {
                e = "single-quotes";
                continue;
              }
              if (a === '"') {
                e = "double-quotes";
                continue;
              }
              if ((a === "u" || a === "U") && t.slice(o, o + 4).toLowerCase() === "url(") {
                e = "url", o += 3;
                continue;
              }
              if (a === "*" && t[o - 1] === "/") {
                e = "comment-block";
                continue;
              }
              if (a === "/" && t[o - 1] === "/") {
                e = "comment-inline", r = o - 1;
                continue;
              }
              continue;
            case "single-quotes":
              if (a === "'" && t[o - 1] !== "\\" && (e = s, s = "initial"), a === `
` || a === "\r") return t;
              continue;
            case "double-quotes":
              if (a === '"' && t[o - 1] !== "\\" && (e = s, s = "initial"), a === `
` || a === "\r") return t;
              continue;
            case "url":
              if (a === ")" && (e = "initial"), a === `
` || a === "\r") return t;
              if (a === "'") {
                e = "single-quotes", s = "url";
                continue;
              }
              if (a === '"') {
                e = "double-quotes", s = "url";
                continue;
              }
              continue;
            case "comment-block":
              a === "/" && t[o - 1] === "*" && (e = "initial");
              continue;
            case "comment-inline":
              (a === '"' || a === "'" || a === "*") && (n = true), (a === `
` || a === "\r") && (n && i.push([r, o]), e = "initial", n = false);
              continue;
          }
        }
        for (let [o, a] of i) t = t.slice(0, o) + _2(false, t.slice(o, a), /["'*]/gu, " ") + t.slice(a);
        return t;
      }
      function N2(t) {
        var e;
        return (e = t.source) == null ? void 0 : e.startOffset;
      }
      function P(t) {
        var e;
        return (e = t.source) == null ? void 0 : e.endOffset;
      }
      var Ll2 = /\*\/$/, Dl2 = /^\/\*\*?/, kn2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Ml2 = /(^|\s+)\/\/([^\n\r]*)/g, xn2 = /^(\r?\n)+/, Bl2 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, bn2 = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Ul2 = /(\r?\n|^) *\* ?/g, En2 = [];
      function Sn2(t) {
        let e = t.match(kn2);
        return e ? e[0].trimStart() : "";
      }
      function Tn3(t) {
        let e = t.match(kn2), s = e == null ? void 0 : e[0];
        return s == null ? t : t.slice(s.length);
      }
      function On2(t) {
        let e = `
`;
        t = _2(false, t.replace(Dl2, "").replace(Ll2, ""), Ul2, "$1");
        let s = "";
        for (; s !== t; ) s = t, t = _2(false, t, Bl2, `${e}$1 $2${e}`);
        t = t.replace(xn2, "").trimEnd();
        let r = /* @__PURE__ */ Object.create(null), n = _2(false, t, bn2, "").replace(xn2, "").trimEnd(), i;
        for (; i = bn2.exec(t); ) {
          let o = _2(false, i[2], Ml2, "");
          if (typeof r[i[1]] == "string" || Array.isArray(r[i[1]])) {
            let a = r[i[1]];
            r[i[1]] = [...En2, ...Array.isArray(a) ? a : [a], o];
          } else r[i[1]] = o;
        }
        return { comments: n, pragmas: r };
      }
      function Cn({ comments: t = "", pragmas: e = {} }) {
        let s = `
`, r = "/**", n = " *", i = " */", o = Object.keys(e), a = o.flatMap((c) => _n2(c, e[c])).map((c) => `${n} ${c}${s}`).join("");
        if (!t) {
          if (o.length === 0) return "";
          if (o.length === 1 && !Array.isArray(e[o[0]])) {
            let c = e[o[0]];
            return `${r} ${_n2(o[0], c)[0]}${i}`;
          }
        }
        let u = t.split(s).map((c) => `${n} ${c}`).join(s) + s;
        return r + s + (t ? u : "") + (t && o.length > 0 ? n + s : "") + a + i;
      }
      function _n2(t, e) {
        return [...En2, ...Array.isArray(e) ? e : [e]].map((s) => `@${t} ${s}`.trim());
      }
      function Fl2(t) {
        if (!t.startsWith("#!")) return "";
        let e = t.indexOf(`
`);
        return e === -1 ? t : t.slice(0, e);
      }
      var An2 = Fl2;
      function Nn2(t) {
        let e = An2(t);
        e && (t = t.slice(e.length + 1));
        let s = Sn2(t), { pragmas: r, comments: n } = On2(s);
        return { shebang: e, text: t, pragmas: r, comments: n };
      }
      function Pn2(t) {
        let { pragmas: e } = Nn2(t);
        return Object.prototype.hasOwnProperty.call(e, "prettier") || Object.prototype.hasOwnProperty.call(e, "format");
      }
      function Rn(t) {
        let { shebang: e, text: s, pragmas: r, comments: n } = Nn2(t), i = Tn3(s), o = Cn({ pragmas: { format: "", ...r }, comments: n.trimStart() });
        return (e ? `${e}
` : "") + o + (i.startsWith(`
`) ? `
` : `

`) + i;
      }
      var Qe2 = 3;
      function $l2(t) {
        let e = t.slice(0, Qe2);
        if (e !== "---" && e !== "+++") return;
        let s = t.indexOf(`
`, Qe2);
        if (s === -1) return;
        let r = t.slice(Qe2, s).trim(), n = t.indexOf(`
${e}`, s), i = r;
        if (i || (i = e === "+++" ? "toml" : "yaml"), n === -1 && e === "---" && i === "yaml" && (n = t.indexOf(`
...`, s)), n === -1) return;
        let o = n + 1 + Qe2, a = t.charAt(o + 1);
        if (!/\s?/u.test(a)) return;
        let u = t.slice(0, o);
        return { type: "front-matter", language: i, explicitLanguage: r, value: t.slice(s + 1, n), startDelimiter: e, endDelimiter: u.slice(-Qe2), raw: u };
      }
      function Wl2(t) {
        let e = $l2(t);
        if (!e) return { content: t };
        let { raw: s } = e;
        return { frontMatter: e, content: _2(false, s, /[^\n]/gu, " ") + t.slice(s.length) };
      }
      var Je = Wl2;
      function In2(t) {
        return Pn2(Je(t).content);
      }
      function qn2(t) {
        let { frontMatter: e, content: s } = Je(t);
        return (e ? e.raw + `

` : "") + Rn(s);
      }
      var Yl2 = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
      function Ln(t) {
        var e, s;
        return (s = (e = t.findAncestor((r) => r.type === "css-decl")) == null ? void 0 : e.prop) == null ? void 0 : s.toLowerCase();
      }
      var zl2 = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
      function Dn2(t) {
        return zl2.has(t.toLowerCase());
      }
      function Mn2(t, e) {
        var r;
        let s = t.findAncestor((n) => n.type === "css-atrule");
        return ((r = s == null ? void 0 : s.name) == null ? void 0 : r.toLowerCase().endsWith("keyframes")) && ["from", "to"].includes(e.toLowerCase());
      }
      function te(t) {
        return t.includes("$") || t.includes("@") || t.includes("#") || t.startsWith("%") || t.startsWith("--") || t.startsWith(":--") || t.includes("(") && t.includes(")") ? t : t.toLowerCase();
      }
      function ke2(t, e) {
        var r;
        let s = t.findAncestor((n) => n.type === "value-func");
        return ((r = s == null ? void 0 : s.value) == null ? void 0 : r.toLowerCase()) === e;
      }
      function Bn2(t) {
        var r;
        let e = t.findAncestor((n) => n.type === "css-rule"), s = (r = e == null ? void 0 : e.raws) == null ? void 0 : r.selector;
        return s && (s.startsWith(":import") || s.startsWith(":export"));
      }
      function Ee(t, e) {
        let s = Array.isArray(e) ? e : [e], r = t.findAncestor((n) => n.type === "css-atrule");
        return r && s.includes(r.name.toLowerCase());
      }
      function Un2(t) {
        var s;
        let { node: e } = t;
        return e.groups[0].value === "url" && e.groups.length === 2 && ((s = t.findAncestor((r) => r.type === "css-atrule")) == null ? void 0 : s.name) === "import";
      }
      function Fn(t) {
        return t.type === "value-func" && t.value.toLowerCase() === "url";
      }
      function $n2(t) {
        return t.type === "value-func" && t.value.toLowerCase() === "var";
      }
      function Wn2(t) {
        let { selector: e } = t;
        return e ? typeof e == "string" && /^@.+:.*$/u.test(e) || e.value && /^@.+:.*$/u.test(e.value) : false;
      }
      function Yn2(t) {
        return t.type === "value-word" && ["from", "through", "end"].includes(t.value);
      }
      function zn(t) {
        return t.type === "value-word" && ["and", "or", "not"].includes(t.value);
      }
      function Vn2(t) {
        return t.type === "value-word" && t.value === "in";
      }
      function Nt(t) {
        return t.type === "value-operator" && t.value === "*";
      }
      function Xe2(t) {
        return t.type === "value-operator" && t.value === "/";
      }
      function Q3(t) {
        return t.type === "value-operator" && t.value === "+";
      }
      function le2(t) {
        return t.type === "value-operator" && t.value === "-";
      }
      function Vl2(t) {
        return t.type === "value-operator" && t.value === "%";
      }
      function Pt2(t) {
        return Nt(t) || Xe2(t) || Q3(t) || le2(t) || Vl2(t);
      }
      function Gn2(t) {
        return t.type === "value-word" && ["==", "!="].includes(t.value);
      }
      function jn2(t) {
        return t.type === "value-word" && ["<", ">", "<=", ">="].includes(t.value);
      }
      function Ze2(t, e) {
        return e.parser === "scss" && t.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(t.name);
      }
      function Hr2(t) {
        var e;
        return ((e = t.raws) == null ? void 0 : e.params) && /^\(\s*\)$/u.test(t.raws.params);
      }
      function Rt(t) {
        return t.name.startsWith("prettier-placeholder");
      }
      function Hn(t) {
        return t.prop.startsWith("@prettier-placeholder");
      }
      function Kn2(t, e) {
        return t.value === "$$" && t.type === "value-func" && (e == null ? void 0 : e.type) === "value-word" && !e.raws.before;
      }
      function Qn2(t) {
        var e, s;
        return ((e = t.value) == null ? void 0 : e.type) === "value-root" && ((s = t.value.group) == null ? void 0 : s.type) === "value-value" && t.prop.toLowerCase() === "composes";
      }
      function Jn2(t) {
        var e, s, r;
        return ((r = (s = (e = t.value) == null ? void 0 : e.group) == null ? void 0 : s.group) == null ? void 0 : r.type) === "value-paren_group" && t.value.group.group.open !== null && t.value.group.group.close !== null;
      }
      function ce(t) {
        var e;
        return ((e = t.raws) == null ? void 0 : e.before) === "";
      }
      function It2(t) {
        var e, s;
        return t.type === "value-comma_group" && ((s = (e = t.groups) == null ? void 0 : e[1]) == null ? void 0 : s.type) === "value-colon";
      }
      function jr2(t) {
        var e;
        return t.type === "value-paren_group" && ((e = t.groups) == null ? void 0 : e[0]) && It2(t.groups[0]);
      }
      function Kr2(t, e) {
        var i;
        if (e.parser !== "scss") return false;
        let { node: s } = t;
        if (s.groups.length === 0) return false;
        let r = t.grandparent;
        if (!jr2(s) && !(r && jr2(r))) return false;
        let n = t.findAncestor((o) => o.type === "css-decl");
        return !!((i = n == null ? void 0 : n.prop) != null && i.startsWith("$") || jr2(r) || r.type === "value-func");
      }
      function Qr2(t) {
        return t.type === "value-comment" && t.inline;
      }
      function qt2(t) {
        return t.type === "value-word" && t.value === "#";
      }
      function Jr2(t) {
        return t.type === "value-word" && t.value === "{";
      }
      function Lt2(t) {
        return t.type === "value-word" && t.value === "}";
      }
      function et(t) {
        return ["value-word", "value-atword"].includes(t.type);
      }
      function Dt(t) {
        return (t == null ? void 0 : t.type) === "value-colon";
      }
      function Xn2(t, e) {
        if (!It2(e)) return false;
        let { groups: s } = e, r = s.indexOf(t);
        return r === -1 ? false : Dt(s[r + 1]);
      }
      function Zn(t) {
        return t.value && ["not", "and", "or"].includes(t.value.toLowerCase());
      }
      function ei2(t) {
        return t.type !== "value-func" ? false : Yl2.has(t.value.toLowerCase());
      }
      function Se(t) {
        return /\/\//u.test(t.split(/[\n\r]/u).pop());
      }
      function tt(t) {
        return (t == null ? void 0 : t.type) === "value-atword" && t.value.startsWith("prettier-placeholder-");
      }
      function ti2(t, e) {
        var s, r;
        if (((s = t.open) == null ? void 0 : s.value) !== "(" || ((r = t.close) == null ? void 0 : r.value) !== ")" || t.groups.some((n) => n.type !== "value-comma_group")) return false;
        if (e.type === "value-comma_group") {
          let n = e.groups.indexOf(t) - 1, i = e.groups[n];
          if ((i == null ? void 0 : i.type) === "value-word" && i.value === "with") return true;
        }
        return false;
      }
      function rt(t) {
        var e, s;
        return t.type === "value-paren_group" && ((e = t.open) == null ? void 0 : e.value) === "(" && ((s = t.close) == null ? void 0 : s.value) === ")";
      }
      function Gl2(t, e, s) {
        var d2;
        let { node: r } = t, n = t.parent, i = t.grandparent, o = Ln(t), a = o && n.type === "value-value" && (o === "grid" || o.startsWith("grid-template")), u = t.findAncestor((m) => m.type === "css-atrule"), c = u && Ze2(u, e), f = r.groups.some((m) => Qr2(m)), p = t.map(s, "groups"), l = [], w = ke2(t, "url"), x = false, h = false;
        for (let m = 0; m < r.groups.length; ++m) {
          l.push(p[m]);
          let b = r.groups[m - 1], g = r.groups[m], v2 = r.groups[m + 1], R = r.groups[m + 2];
          if (w) {
            (v2 && Q3(v2) || Q3(g)) && l.push(" ");
            continue;
          }
          if (Ee(t, "forward") && g.type === "value-word" && g.value && b !== void 0 && b.type === "value-word" && b.value === "as" && v2.type === "value-operator" && v2.value === "*" || !v2 || g.type === "value-word" && g.value.endsWith("-") && tt(v2)) continue;
          if (g.type === "value-string" && g.quoted) {
            let C = g.value.lastIndexOf("#{"), me = g.value.lastIndexOf("}");
            C !== -1 && me !== -1 ? x = C > me : C !== -1 ? x = true : me !== -1 && (x = false);
          }
          if (x || Dt(g) || Dt(v2) || g.type === "value-atword" && (g.value === "" || g.value.endsWith("[")) || v2.type === "value-word" && v2.value.startsWith("]") || g.value === "~" || g.type !== "value-string" && g.value && g.value.includes("\\") && v2 && v2.type !== "value-comment" || b != null && b.value && b.value.indexOf("\\") === b.value.length - 1 && g.type === "value-operator" && g.value === "/" || g.value === "\\" || Kn2(g, v2) || qt2(g) || Jr2(g) || Lt2(v2) || Jr2(v2) && ce(v2) || Lt2(g) && ce(v2) || g.value === "--" && qt2(v2)) continue;
          let F = Pt2(g), H = Pt2(v2);
          if ((F && qt2(v2) || H && Lt2(g)) && ce(v2) || !b && Xe2(g) || ke2(t, "calc") && (Q3(g) || Q3(v2) || le2(g) || le2(v2)) && ce(v2)) continue;
          let $ = (Q3(g) || le2(g)) && m === 0 && (v2.type === "value-number" || v2.isHex) && i && ei2(i) && !ce(v2), T3 = (R == null ? void 0 : R.type) === "value-func" || R && et(R) || g.type === "value-func" || et(g), O = v2.type === "value-func" || et(v2) || (b == null ? void 0 : b.type) === "value-func" || b && et(b);
          if (e.parser === "scss" && F && g.value === "-" && v2.type === "value-func" && P(g) !== N2(v2)) {
            l.push(" ");
            continue;
          }
          if (!(!(Nt(v2) || Nt(g)) && !ke2(t, "calc") && !$ && (Xe2(v2) && !T3 || Xe2(g) && !O || Q3(v2) && !T3 || Q3(g) && !O || le2(v2) || le2(g)) && (ce(v2) || F && (!b || b && Pt2(b)))) && !((e.parser === "scss" || e.parser === "less") && F && g.value === "-" && rt(v2) && P(g) === N2(v2.open) && v2.open.value === "(")) {
            if (Qr2(g)) {
              if (n.type === "value-paren_group") {
                l.push(ue2(E));
                continue;
              }
              l.push(E);
              continue;
            }
            if (c && (Gn2(v2) || jn2(v2) || zn(v2) || Vn2(g) || Yn2(g))) {
              l.push(" ");
              continue;
            }
            if (u && u.name.toLowerCase() === "namespace") {
              l.push(" ");
              continue;
            }
            if (a) {
              g.source && v2.source && g.source.start.line !== v2.source.start.line ? (l.push(E), h = true) : l.push(" ");
              continue;
            }
            if (H) {
              l.push(" ");
              continue;
            }
            if ((v2 == null ? void 0 : v2.value) !== "..." && !(tt(g) && tt(v2) && P(g) === N2(v2))) {
              if (tt(g) && rt(v2) && P(g) === N2(v2.open)) {
                l.push(M);
                continue;
              }
              if (g.value === "with" && rt(v2)) {
                l.push(" ");
                continue;
              }
              (d2 = g.value) != null && d2.endsWith("#") && v2.value === "{" && rt(v2.group) || l.push(A);
            }
          }
        }
        return f && l.push(je), h && l.unshift(E), c ? L(q(l)) : Un2(t) ? L(Ge(l)) : L(q(Ge(l)));
      }
      var ri2 = Gl2;
      function jl2(t) {
        return t.length === 1 ? t : t.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
      }
      var si2 = jl2;
      var Xr = /* @__PURE__ */ new Map([["em", "em"], ["rem", "rem"], ["ex", "ex"], ["rex", "rex"], ["cap", "cap"], ["rcap", "rcap"], ["ch", "ch"], ["rch", "rch"], ["ic", "ic"], ["ric", "ric"], ["lh", "lh"], ["rlh", "rlh"], ["vw", "vw"], ["svw", "svw"], ["lvw", "lvw"], ["dvw", "dvw"], ["vh", "vh"], ["svh", "svh"], ["lvh", "lvh"], ["dvh", "dvh"], ["vi", "vi"], ["svi", "svi"], ["lvi", "lvi"], ["dvi", "dvi"], ["vb", "vb"], ["svb", "svb"], ["lvb", "lvb"], ["dvb", "dvb"], ["vmin", "vmin"], ["svmin", "svmin"], ["lvmin", "lvmin"], ["dvmin", "dvmin"], ["vmax", "vmax"], ["svmax", "svmax"], ["lvmax", "lvmax"], ["dvmax", "dvmax"], ["cm", "cm"], ["mm", "mm"], ["q", "Q"], ["in", "in"], ["pt", "pt"], ["pc", "pc"], ["px", "px"], ["deg", "deg"], ["grad", "grad"], ["rad", "rad"], ["turn", "turn"], ["s", "s"], ["ms", "ms"], ["hz", "Hz"], ["khz", "kHz"], ["dpi", "dpi"], ["dpcm", "dpcm"], ["dppx", "dppx"], ["x", "x"], ["cqw", "cqw"], ["cqh", "cqh"], ["cqi", "cqi"], ["cqb", "cqb"], ["cqmin", "cqmin"], ["cqmax", "cqmax"]]);
      function ni2(t) {
        let e = t.toLowerCase();
        return Xr.has(e) ? Xr.get(e) : t;
      }
      var ii2 = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gsu, Hl2 = /(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/giu, Kl2 = /[a-z]+/giu, Ql2 = /[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/giu, Jl2 = new RegExp(ii2.source + `|(${Ql2.source})?(${Hl2.source})(${Kl2.source})?`, "giu");
      function W(t, e) {
        return _2(false, t, ii2, (s) => Tt(s, e));
      }
      function oi2(t, e) {
        let s = e.singleQuote ? "'" : '"';
        return t.includes('"') || t.includes("'") ? t : s + t + s;
      }
      function fe(t) {
        return _2(false, t, Jl2, (e, s, r, n, i) => !r && n ? Zr2(n) + te(i || "") : e);
      }
      function Zr2(t) {
        return si2(t).replace(/\.0(?=$|e)/u, "");
      }
      function ai2(t) {
        return t.trailingComma === "es5" || t.trailingComma === "all";
      }
      function Xl2(t, e, s) {
        let r = !!(s != null && s.backwards);
        if (e === false) return false;
        let n = t.charAt(e);
        if (r) {
          if (t.charAt(e - 1) === "\r" && n === `
`) return e - 2;
          if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029") return e - 1;
        } else {
          if (n === "\r" && t.charAt(e + 1) === `
`) return e + 2;
          if (n === `
` || n === "\r" || n === "\u2028" || n === "\u2029") return e + 1;
        }
        return e;
      }
      var Mt = Xl2;
      function Zl2(t, e, s = {}) {
        let r = Ct2(t, s.backwards ? e - 1 : e, s), n = Mt(t, r, s);
        return r !== n;
      }
      var Bt2 = Zl2;
      function ec2(t, e) {
        if (e === false) return false;
        if (t.charAt(e) === "/" && t.charAt(e + 1) === "*") {
          for (let s = e + 2; s < t.length; ++s) if (t.charAt(s) === "*" && t.charAt(s + 1) === "/") return s + 2;
        }
        return e;
      }
      var ui = ec2;
      function tc2(t, e) {
        return e === false ? false : t.charAt(e) === "/" && t.charAt(e + 1) === "/" ? At(t, e) : e;
      }
      var li = tc2;
      function rc2(t, e) {
        let s = null, r = e;
        for (; r !== s; ) s = r, r = yn2(t, r), r = ui(t, r), r = Ct2(t, r);
        return r = li(t, r), r = Mt(t, r), r !== false && Bt2(t, r);
      }
      var Ut = rc2;
      function sc2({ node: t, parent: e }, s) {
        return !!(t.source && s.originalText.slice(N2(t), N2(e.close)).trimEnd().endsWith(","));
      }
      function nc2(t, e) {
        return $n2(t.grandparent) && sc2(t, e) ? "," : t.node.type !== "value-comment" && !(t.node.type === "value-comma_group" && t.node.groups.every((s) => s.type === "value-comment")) && ai2(e) && t.callParent(() => Kr2(t, e)) ? Et2(",") : "";
      }
      function ci3(t, e, s) {
        let { node: r, parent: n } = t, i = t.map(({ node: w }) => typeof w == "string" ? w : s(), "groups");
        if (n && Fn(n) && (r.groups.length === 1 || r.groups.length > 0 && r.groups[0].type === "value-comma_group" && r.groups[0].groups.length > 0 && r.groups[0].groups[0].type === "value-word" && r.groups[0].groups[0].value.startsWith("data:"))) return [r.open ? s("open") : "", V(",", i), r.close ? s("close") : ""];
        if (!r.open) {
          let w = es2(t), x = V([",", w ? E : A], i);
          return q(w ? [E, x] : L(Ge(x)));
        }
        let o = t.map(({ node: w, isLast: x, index: h }) => {
          var b;
          let d2 = i[h];
          if (It2(w) && w.type === "value-comma_group" && w.groups && w.groups[0].type !== "value-paren_group" && ((b = w.groups[2]) == null ? void 0 : b.type) === "value-paren_group") {
            let { parts: g } = d2.contents.contents;
            g[1] = L(g[1]), d2 = L(ue2(d2));
          }
          let m = [d2, x ? nc2(t, e) : ","];
          if (!x && w.type === "value-comma_group" && ee(w.groups)) {
            let g = G(false, w.groups, -1);
            !g.source && g.close && (g = g.close), g.source && Ut(e.originalText, P(g)) && m.push(E);
          }
          return m;
        }, "groups"), a = Xn2(r, n), u = ti2(r, n), c = Kr2(t, e), f = u || c && !a, p = u || a, l = L([r.open ? s("open") : "", q([M, V(A, o)]), M, r.close ? s("close") : ""], { shouldBreak: f });
        return p ? ue2(l) : l;
      }
      function es2(t) {
        return t.match((e) => e.type === "value-paren_group" && !e.open && e.groups.some((s) => s.type === "value-comma_group"), (e, s) => s === "group" && e.type === "value-value", (e, s) => s === "group" && e.type === "value-root", (e, s) => s === "value" && (e.type === "css-decl" && !e.prop.startsWith("--") || e.type === "css-atrule" && e.variable));
      }
      function ic2(t, e, s) {
        let r = [];
        return t.each(() => {
          let { node: n, previous: i } = t;
          if ((i == null ? void 0 : i.type) === "css-comment" && i.text.trim() === "prettier-ignore" ? r.push(e.originalText.slice(N2(n), P(n))) : r.push(s()), t.isLast) return;
          let { next: o } = t;
          o.type === "css-comment" && !Bt2(e.originalText, N2(o), { backwards: true }) && !_e3(n) || o.type === "css-atrule" && o.name === "else" && n.type !== "css-comment" ? r.push(" ") : (r.push(e.__isHTMLStyleAttribute ? A : E), Ut(e.originalText, P(n)) && !_e3(n) && r.push(E));
        }, "nodes"), r;
      }
      var Te2 = ic2;
      function oc2(t, e, s) {
        var n, i, o, a, u, c;
        let { node: r } = t;
        switch (r.type) {
          case "front-matter":
            return [r.raw, E];
          case "css-root": {
            let f = Te2(t, e, s), p = r.raws.after.trim();
            return p.startsWith(";") && (p = p.slice(1).trim()), [r.frontMatter ? [s("frontMatter"), E] : "", f, p ? ` ${p}` : "", r.nodes.length > 0 ? E : ""];
          }
          case "css-comment": {
            let f = r.inline || r.raws.inline, p = e.originalText.slice(N2(r), P(r));
            return f ? p.trimEnd() : p;
          }
          case "css-rule":
            return [s("selector"), r.important ? " !important" : "", r.nodes ? [((n = r.selector) == null ? void 0 : n.type) === "selector-unknown" && Se(r.selector.value) ? A : r.selector ? " " : "", "{", r.nodes.length > 0 ? q([E, Te2(t, e, s)]) : "", E, "}", Wn2(r) ? ";" : ""] : ";"];
          case "css-decl": {
            let f = t.parent, { between: p } = r.raws, l = p.trim(), w = l === ":", x = typeof r.value == "string" && /^ *$/u.test(r.value), h = typeof r.value == "string" ? r.value : s("value");
            return h = Qn2(r) ? rn2(h) : h, !w && Se(l) && !((o = (i = r.value) == null ? void 0 : i.group) != null && o.group && t.call(() => es2(t), "value", "group", "group")) && (h = q([E, ue2(h)])), [_2(false, r.raws.before, /[\s;]/gu, ""), f.type === "css-atrule" && f.variable || Bn2(t) ? r.prop : te(r.prop), l.startsWith("//") ? " " : "", l, r.extend || x ? "" : " ", e.parser === "less" && r.extend && r.selector ? ["extend(", s("selector"), ")"] : "", h, r.raws.important ? r.raws.important.replace(/\s*!\s*important/iu, " !important") : r.important ? " !important" : "", r.raws.scssDefault ? r.raws.scssDefault.replace(/\s*!default/iu, " !default") : r.scssDefault ? " !default" : "", r.raws.scssGlobal ? r.raws.scssGlobal.replace(/\s*!global/iu, " !global") : r.scssGlobal ? " !global" : "", r.nodes ? [" {", q([M, Te2(t, e, s)]), M, "}"] : Hn(r) && !f.raws.semicolon && e.originalText[P(r) - 1] !== ";" ? "" : e.__isHTMLStyleAttribute && t.isLast ? Et2(";") : ";"];
          }
          case "css-atrule": {
            let f = t.parent, p = Rt(r) && !f.raws.semicolon && e.originalText[P(r) - 1] !== ";";
            if (e.parser === "less") {
              if (r.mixin) return [s("selector"), r.important ? " !important" : "", p ? "" : ";"];
              if (r.function) return [r.name, typeof r.params == "string" ? r.params : s("params"), p ? "" : ";"];
              if (r.variable) return ["@", r.name, ": ", r.value ? s("value") : "", r.raws.between.trim() ? r.raws.between.trim() + " " : "", r.nodes ? ["{", q([r.nodes.length > 0 ? M : "", Te2(t, e, s)]), M, "}"] : "", p ? "" : ";"];
            }
            let l = r.name === "import" && ((a = r.params) == null ? void 0 : a.type) === "value-unknown" && r.params.value.endsWith(";");
            return ["@", Hr2(r) || r.name.endsWith(":") || Rt(r) ? r.name : te(r.name), r.params ? [Hr2(r) ? "" : Rt(r) ? r.raws.afterName === "" ? "" : r.name.endsWith(":") ? " " : /^\s*\n\s*\n/u.test(r.raws.afterName) ? [E, E] : /^\s*\n/u.test(r.raws.afterName) ? E : " " : " ", typeof r.params == "string" ? r.params : s("params")] : "", r.selector ? q([" ", s("selector")]) : "", r.value ? L([" ", s("value"), Ze2(r, e) ? Jn2(r) ? " " : A : ""]) : r.name === "else" ? " " : "", r.nodes ? [Ze2(r, e) ? "" : r.selector && !r.selector.nodes && typeof r.selector.value == "string" && Se(r.selector.value) || !r.selector && typeof r.params == "string" && Se(r.params) ? A : " ", "{", q([r.nodes.length > 0 ? M : "", Te2(t, e, s)]), M, "}"] : p || l ? "" : ";"];
          }
          case "media-query-list": {
            let f = [];
            return t.each(({ node: p }) => {
              p.type === "media-query" && p.value === "" || f.push(s());
            }, "nodes"), L(q(V(A, f)));
          }
          case "media-query":
            return [V(" ", t.map(s, "nodes")), t.isLast ? "" : ","];
          case "media-type":
            return fe(W(r.value, e));
          case "media-feature-expression":
            return r.nodes ? ["(", ...t.map(s, "nodes"), ")"] : r.value;
          case "media-feature":
            return te(W(_2(false, r.value, / +/gu, " "), e));
          case "media-colon":
            return [r.value, " "];
          case "media-value":
            return fe(W(r.value, e));
          case "media-keyword":
            return W(r.value, e);
          case "media-url":
            return W(_2(false, _2(false, r.value, /^url\(\s+/giu, "url("), /\s+\)$/gu, ")"), e);
          case "media-unknown":
            return r.value;
          case "selector-root":
            return L([Ee(t, "custom-selector") ? [t.findAncestor((f) => f.type === "css-atrule").customSelector, A] : "", V([",", Ee(t, ["extend", "custom-selector", "nest"]) ? A : E], t.map(s, "nodes"))]);
          case "selector-selector":
            return L(q(t.map(s, "nodes")));
          case "selector-comment":
            return r.value;
          case "selector-string":
            return W(r.value, e);
          case "selector-tag":
            return [r.namespace ? [r.namespace === true ? "" : r.namespace.trim(), "|"] : "", ((u = t.previous) == null ? void 0 : u.type) === "selector-nesting" ? r.value : fe(Mn2(t, r.value) ? r.value.toLowerCase() : r.value)];
          case "selector-id":
            return ["#", r.value];
          case "selector-class":
            return [".", fe(W(r.value, e))];
          case "selector-attribute":
            return ["[", r.namespace ? [r.namespace === true ? "" : r.namespace.trim(), "|"] : "", r.attribute.trim(), r.operator ?? "", r.value ? oi2(W(r.value.trim(), e), e) : "", r.insensitive ? " i" : "", "]"];
          case "selector-combinator": {
            if (r.value === "+" || r.value === ">" || r.value === "~" || r.value === ">>>") {
              let l = t.parent;
              return [l.type === "selector-selector" && l.nodes[0] === r ? "" : A, r.value, t.isLast ? "" : " "];
            }
            let f = r.value.trim().startsWith("(") ? A : "", p = fe(W(r.value.trim(), e)) || A;
            return [f, p];
          }
          case "selector-universal":
            return [r.namespace ? [r.namespace === true ? "" : r.namespace.trim(), "|"] : "", r.value];
          case "selector-pseudo":
            return [te(r.value), ee(r.nodes) ? L(["(", q([M, V([",", A], t.map(s, "nodes"))]), M, ")"]) : ""];
          case "selector-nesting":
            return r.value;
          case "selector-unknown": {
            let f = t.findAncestor((w) => w.type === "css-rule");
            if (f != null && f.isSCSSNesterProperty) return fe(W(te(r.value), e));
            let p = t.parent;
            if ((c = p.raws) != null && c.selector) {
              let w = N2(p), x = w + p.raws.selector.length;
              return e.originalText.slice(w, x).trim();
            }
            let l = t.grandparent;
            if (p.type === "value-paren_group" && (l == null ? void 0 : l.type) === "value-func" && l.value === "selector") {
              let w = P(p.open) + 1, x = N2(p.close), h = e.originalText.slice(w, x).trim();
              return Se(h) ? [je, h] : h;
            }
            return r.value;
          }
          case "value-value":
          case "value-root":
            return s("group");
          case "value-comment":
            return e.originalText.slice(N2(r), P(r));
          case "value-comma_group":
            return ri2(t, e, s);
          case "value-paren_group":
            return ci3(t, e, s);
          case "value-func":
            return [r.value, Ee(t, "supports") && Zn(r) ? " " : "", s("group")];
          case "value-paren":
            return r.value;
          case "value-number":
            return [Zr2(r.value), ni2(r.unit)];
          case "value-operator":
            return r.value;
          case "value-word":
            return r.isColor && r.isHex || Dn2(r.value) ? r.value.toLowerCase() : r.value;
          case "value-colon": {
            let { previous: f } = t;
            return [r.value, typeof (f == null ? void 0 : f.value) == "string" && f.value.endsWith("\\") || ke2(t, "url") ? "" : A];
          }
          case "value-string":
            return Tt(r.raws.quote + r.value + r.raws.quote, e);
          case "value-atword":
            return ["@", r.value];
          case "value-unicode-range":
            return r.value;
          case "value-unknown":
            return r.value;
          case "value-comma":
          default:
            throw new an2(r, "PostCSS");
        }
      }
      var ac2 = { print: oc2, embed: pn2, insertPragma: qn2, massageAstNode: ln2, getVisitorKeys: mn }, fi2 = ac2;
      var pi = [{ linguistLanguageId: 50, name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css", ".wxss"], parsers: ["css"], vscodeLanguageIds: ["css"] }, { linguistLanguageId: 262764437, name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", parsers: ["css"], vscodeLanguageIds: ["postcss"] }, { linguistLanguageId: 198, name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", parsers: ["less"], vscodeLanguageIds: ["less"] }, { linguistLanguageId: 329, name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], parsers: ["scss"], vscodeLanguageIds: ["scss"] }];
      var hi2 = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
      var uc2 = { singleQuote: hi2.singleQuote }, di = uc2;
      var Ks2 = {};
      Js2(Ks2, { css: () => by2, less: () => _y2, scss: () => ky2 });
      var el = ye(pt2(), 1), tl2 = ye(bo2(), 1), rl2 = ye(ta2(), 1);
      function Hf2(t, e) {
        let s = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
        return Object.assign(s, e);
      }
      var ra2 = Hf2;
      var la2 = ye(ua3(), 1);
      function J(t, e, s) {
        if (t && typeof t == "object") {
          delete t.parent;
          for (let r in t) J(t[r], e, s), r === "type" && typeof t[r] == "string" && !t[r].startsWith(e) && (!s || !s.test(t[r])) && (t[r] = e + t[r]);
        }
        return t;
      }
      function Is2(t) {
        if (t && typeof t == "object") {
          delete t.parent;
          for (let e in t) Is2(t[e]);
          !Array.isArray(t) && t.value && !t.type && (t.type = "unknown");
        }
        return t;
      }
      var op2 = la2.default.default;
      function ap2(t) {
        let e;
        try {
          e = op2(t);
        } catch {
          return { type: "selector-unknown", value: t };
        }
        return J(Is2(e), "media-");
      }
      var ca2 = ap2;
      var nu2 = ye(su2(), 1);
      function bm2(t) {
        if (/\/\/|\/\*/u.test(t)) return { type: "selector-unknown", value: t.trim() };
        let e;
        try {
          new nu2.default((s) => {
            e = s;
          }).process(t);
        } catch {
          return { type: "selector-unknown", value: t };
        }
        return J(e, "selector-");
      }
      var Z = bm2;
      var Qu2 = ye(Vu2(), 1);
      var ly2 = (t) => {
        for (; t.parent; ) t = t.parent;
        return t;
      }, Br2 = ly2;
      function cy2(t) {
        return Br2(t).text.slice(t.group.open.sourceIndex + 1, t.group.close.sourceIndex).trim();
      }
      var Gu2 = cy2;
      function fy2(t) {
        if (ee(t)) {
          for (let e = t.length - 1; e > 0; e--) if (t[e].type === "word" && t[e].value === "{" && t[e - 1].type === "word" && t[e - 1].value.endsWith("#")) return true;
        }
        return false;
      }
      var ju2 = fy2;
      function py2(t) {
        return t.some((e) => e.type === "string" || e.type === "func" && !e.value.endsWith("\\"));
      }
      var Hu2 = py2;
      function hy2(t, e) {
        return !!(e.parser === "scss" && (t == null ? void 0 : t.type) === "word" && t.value.startsWith("$"));
      }
      var Ku2 = hy2;
      function dy2(t, e) {
        var u;
        let { nodes: s } = t, r = { open: null, close: null, groups: [], type: "paren_group" }, n = [r], i = r, o = { groups: [], type: "comma_group" }, a = [o];
        for (let c = 0; c < s.length; ++c) {
          let f = s[c];
          if (e.parser === "scss" && f.type === "number" && f.unit === ".." && f.value.endsWith(".") && (f.value = f.value.slice(0, -1), f.unit = "..."), f.type === "func" && f.value === "selector" && (f.group.groups = [Z(Br2(t).text.slice(f.group.open.sourceIndex + 1, f.group.close.sourceIndex))]), f.type === "func" && f.value === "url") {
            let p = ((u = f.group) == null ? void 0 : u.groups) ?? [], l = [];
            for (let w = 0; w < p.length; w++) {
              let x = p[w];
              x.type === "comma_group" ? l = [...l, ...x.groups] : l.push(x);
            }
            (ju2(l) || !Hu2(l) && !Ku2(l[0], e)) && (f.group.groups = [Gu2(f)]);
          }
          if (f.type === "paren" && f.value === "(") r = { open: f, close: null, groups: [], type: "paren_group" }, n.push(r), o = { groups: [], type: "comma_group" }, a.push(o);
          else if (f.type === "paren" && f.value === ")") {
            if (o.groups.length > 0 && r.groups.push(o), r.close = f, a.length === 1) throw new Error("Unbalanced parenthesis");
            a.pop(), o = G(false, a, -1), o.groups.push(r), n.pop(), r = G(false, n, -1);
          } else f.type === "comma" ? (r.groups.push(o), o = { groups: [], type: "comma_group" }, a[a.length - 1] = o) : o.groups.push(f);
        }
        return o.groups.length > 0 && r.groups.push(o), i;
      }
      function Ur2(t) {
        return t.type === "paren_group" && !t.open && !t.close && t.groups.length === 1 || t.type === "comma_group" && t.groups.length === 1 ? Ur2(t.groups[0]) : t.type === "paren_group" || t.type === "comma_group" ? { ...t, groups: t.groups.map(Ur2) } : t;
      }
      function Ju2(t, e) {
        if (t && typeof t == "object") for (let s in t) s !== "parent" && (Ju2(t[s], e), s === "nodes" && (t.group = Ur2(dy2(t, e)), delete t[s]));
        return t;
      }
      function my2(t, e) {
        if (e.parser === "less" && t.startsWith("~`")) return { type: "value-unknown", value: t };
        let s = null;
        try {
          s = new Qu2.default(t, { loose: true }).parse();
        } catch {
          return { type: "value-unknown", value: t };
        }
        s.text = t;
        let r = Ju2(s, e);
        return J(r, "value-", /^selector-/u);
      }
      var ie = my2;
      var yy2 = /* @__PURE__ */ new Set(["import", "use", "forward"]);
      function wy2(t) {
        return yy2.has(t);
      }
      var Xu2 = wy2;
      function gy2(t, e) {
        return e.parser !== "scss" || !t.selector ? false : t.selector.replace(/\/\*.*?\*\//u, "").replace(/\/\/.*\n/u, "").trim().endsWith(":");
      }
      var Zu2 = gy2;
      var vy2 = /(\s*)(!default).*$/u, xy2 = /(\s*)(!global).*$/u;
      function sl2(t, e) {
        var s, r;
        if (t && typeof t == "object") {
          delete t.parent;
          for (let a in t) sl2(t[a], e);
          if (!t.type) return t;
          if (t.raws ?? (t.raws = {}), t.type === "css-decl" && typeof t.prop == "string" && t.prop.startsWith("--") && typeof t.value == "string" && t.value.startsWith("{")) {
            let a;
            if (t.value.trimEnd().endsWith("}")) {
              let u = e.originalText.slice(0, t.source.start.offset), c = "a".repeat(t.prop.length) + e.originalText.slice(t.source.start.offset + t.prop.length, t.source.end.offset), f = _2(false, u, /[^\n]/gu, " ") + c, p;
              e.parser === "scss" ? p = ol2 : e.parser === "less" ? p = il2 : p = nl2;
              let l;
              try {
                l = p(f, { ...e });
              } catch {
              }
              ((s = l == null ? void 0 : l.nodes) == null ? void 0 : s.length) === 1 && l.nodes[0].type === "css-rule" && (a = l.nodes[0].nodes);
            }
            return a ? t.value = { type: "css-rule", nodes: a } : t.value = { type: "value-unknown", value: t.raws.value.raw }, t;
          }
          let n = "";
          typeof t.selector == "string" && (n = t.raws.selector ? t.raws.selector.scss ?? t.raws.selector.raw : t.selector, t.raws.between && t.raws.between.trim().length > 0 && (n += t.raws.between), t.raws.selector = n);
          let i = "";
          typeof t.value == "string" && (i = t.raws.value ? t.raws.value.scss ?? t.raws.value.raw : t.value, i = i.trim(), t.raws.value = i);
          let o = "";
          if (typeof t.params == "string" && (o = t.raws.params ? t.raws.params.scss ?? t.raws.params.raw : t.params, t.raws.afterName && t.raws.afterName.trim().length > 0 && (o = t.raws.afterName + o), t.raws.between && t.raws.between.trim().length > 0 && (o = o + t.raws.between), o = o.trim(), t.raws.params = o), n.trim().length > 0) return n.startsWith("@") && n.endsWith(":") ? t : t.mixin ? (t.selector = ie(n, e), t) : (Zu2(t, e) && (t.isSCSSNesterProperty = true), t.selector = Z(n), t);
          if (i.length > 0) {
            let a = i.match(vy2);
            a && (i = i.slice(0, a.index), t.scssDefault = true, a[0].trim() !== "!default" && (t.raws.scssDefault = a[0]));
            let u = i.match(xy2);
            if (u && (i = i.slice(0, u.index), t.scssGlobal = true, u[0].trim() !== "!global" && (t.raws.scssGlobal = u[0])), i.startsWith("progid:")) return { type: "value-unknown", value: i };
            t.value = ie(i, e);
          }
          if (e.parser === "less" && t.type === "css-decl" && i.startsWith("extend(") && (t.extend || (t.extend = t.raws.between === ":"), t.extend && !t.selector && (delete t.value, t.selector = Z(i.slice(7, -1)))), t.type === "css-atrule") {
            if (e.parser === "less") {
              if (t.mixin) {
                let a = t.raws.identifier + t.name + t.raws.afterName + t.raws.params;
                return t.selector = Z(a), delete t.params, t;
              }
              if (t.function) return t;
            }
            if (e.parser === "css" && t.name === "custom-selector") {
              let a = t.params.match(/:--\S+\s+/u)[0].trim();
              return t.customSelector = a, t.selector = Z(t.params.slice(a.length).trim()), delete t.params, t;
            }
            if (e.parser === "less") {
              if (t.name.includes(":") && !t.params) {
                t.variable = true;
                let a = t.name.split(":");
                t.name = a[0], t.value = ie(a.slice(1).join(":"), e);
              }
              if (!["page", "nest", "keyframes"].includes(t.name) && ((r = t.params) == null ? void 0 : r[0]) === ":") {
                t.variable = true;
                let a = t.params.slice(1);
                a && (t.value = ie(a, e)), t.raws.afterName += ":";
              }
              if (t.variable) return delete t.params, t.value || delete t.value, t;
            }
          }
          if (t.type === "css-atrule" && o.length > 0) {
            let { name: a } = t, u = t.name.toLowerCase();
            return a === "warn" || a === "error" ? (t.params = { type: "media-unknown", value: o }, t) : a === "extend" || a === "nest" ? (t.selector = Z(o), delete t.params, t) : a === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/su.test(o) ? t.params = ie(o, e) : (t.selector = Z(o), delete t.params), t) : Xu2(u) ? (t.import = true, delete t.filename, t.params = ie(o, e), t) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(a) ? (o = o.replace(/(\$\S+?)(\s+)?\.{3}/u, "$1...$2"), o = o.replace(/^(?!if)(\S+)(\s+)\(/u, "$1($2"), t.value = ie(o, e), delete t.params, t) : ["media", "custom-media"].includes(u) ? o.includes("#{") ? { type: "media-unknown", value: o } : (t.params = ca2(o), t) : (t.params = o, t);
          }
        }
        return t;
      }
      function js2(t, e, s) {
        let r = Je(e), { frontMatter: n } = r;
        e = r.content;
        let i;
        try {
          i = t(e, { map: false });
        } catch (o) {
          let { name: a, reason: u, line: c, column: f } = o;
          throw typeof c != "number" ? o : ra2(`${a}: ${u}`, { loc: { start: { line: c, column: f } }, cause: o });
        }
        return s.originalText = e, i = sl2(J(i, "css-"), s), Gr2(i, e), n && (n.source = { startOffset: 0, endOffset: n.raw.length }, i.frontMatter = n), i;
      }
      function nl2(t, e = {}) {
        return js2(el.default.default, t, e);
      }
      function il2(t, e = {}) {
        return js2((s) => tl2.default.parse(vn(s)), t, e);
      }
      function ol2(t, e = {}) {
        return js2(rl2.default, t, e);
      }
      var Hs2 = { astFormat: "postcss", hasPragma: In2, locStart: N2, locEnd: P }, by2 = { ...Hs2, parse: nl2 }, _y2 = { ...Hs2, parse: il2 }, ky2 = { ...Hs2, parse: ol2 };
      var Ey2 = { postcss: fi2 };
      return pl2(Sy2);
    });
  }
});

// node_modules/prettier/plugins/html.js
var require_html = __commonJS({
  "node_modules/prettier/plugins/html.js"(exports, module) {
    (function(f) {
      function e() {
        var i = f();
        return i.default || i;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var t = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.html = e();
      }
    })(function() {
      "use strict";
      var lr = Object.defineProperty;
      var ni2 = Object.getOwnPropertyDescriptor;
      var si2 = Object.getOwnPropertyNames;
      var ii2 = Object.prototype.hasOwnProperty;
      var Xr = (t) => {
        throw TypeError(t);
      };
      var Jr2 = (t, e) => {
        for (var r in e) lr(t, r, { get: e[r], enumerable: true });
      }, ai2 = (t, e, r, n) => {
        if (e && typeof e == "object" || typeof e == "function") for (let s of si2(e)) !ii2.call(t, s) && s !== r && lr(t, s, { get: () => e[s], enumerable: !(n = ni2(e, s)) || n.enumerable });
        return t;
      };
      var oi2 = (t) => ai2(lr({}, "__esModule", { value: true }), t);
      var Zr2 = (t, e, r) => e.has(t) || Xr("Cannot " + r);
      var Q3 = (t, e, r) => (Zr2(t, e, "read from private field"), r ? r.call(t) : e.get(t)), en2 = (t, e, r) => e.has(t) ? Xr("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), tn2 = (t, e, r, n) => (Zr2(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
      var Vo2 = {};
      Jr2(Vo2, { languages: () => Ds2, options: () => ys2, parsers: () => Yr2, printers: () => Ho2 });
      var ui = (t, e, r, n) => {
        if (!(t && e == null)) return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
      }, w = ui;
      var ke2 = "string", Be3 = "array", Le2 = "cursor", ce = "indent", pe = "align", Fe2 = "trim", te = "group", he = "fill", me = "if-break", fe = "indent-if-break", Ne2 = "line-suffix", Pe = "line-suffix-boundary", Y = "line", Ie = "label", de3 = "break-parent", St2 = /* @__PURE__ */ new Set([Le2, ce, pe, Fe2, te, he, me, fe, Ne2, Pe, Y, Ie, de3]);
      function li(t) {
        if (typeof t == "string") return ke2;
        if (Array.isArray(t)) return Be3;
        if (!t) return;
        let { type: e } = t;
        if (St2.has(e)) return e;
      }
      var Re = li;
      var ci3 = (t) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t);
      function pi(t) {
        let e = t === null ? "null" : typeof t;
        if (e !== "string" && e !== "object") return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
        if (Re(t)) throw new Error("doc is valid.");
        let r = Object.prototype.toString.call(t);
        if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
        let n = ci3([...St2].map((s) => `'${s}'`));
        return `Unexpected doc.type '${t.type}'.
Expected it to be ${n}.`;
      }
      var cr2 = class extends Error {
        constructor(e) {
          super(pi(e));
          __publicField(this, "name", "InvalidDocError");
          this.doc = e;
        }
      }, _t2 = cr2;
      var rn2 = () => {
      }, re = rn2, Et2 = rn2;
      function k(t) {
        return re(t), { type: ce, contents: t };
      }
      function nn2(t, e) {
        return re(e), { type: pe, contents: e, n: t };
      }
      function _2(t, e = {}) {
        return re(t), Et2(e.expandedStates, true), { type: te, id: e.id, contents: t, break: !!e.shouldBreak, expandedStates: e.expandedStates };
      }
      function sn2(t) {
        return nn2(Number.NEGATIVE_INFINITY, t);
      }
      function an2(t) {
        return nn2({ type: "root" }, t);
      }
      function At(t) {
        return Et2(t), { type: he, parts: t };
      }
      function ge(t, e = "", r = {}) {
        return re(t), e !== "" && re(e), { type: me, breakContents: t, flatContents: e, groupId: r.groupId };
      }
      function on2(t, e) {
        return re(t), { type: fe, contents: t, groupId: e.groupId, negate: e.negate };
      }
      var ne = { type: de3 };
      var hi2 = { type: Y, hard: true }, mi2 = { type: Y, hard: true, literal: true }, E = { type: Y }, v2 = { type: Y, soft: true }, S = [hi2, ne], un2 = [mi2, ne];
      function q(t, e) {
        re(t), Et2(e);
        let r = [];
        for (let n = 0; n < e.length; n++) n !== 0 && r.push(t), r.push(e[n]);
        return r;
      }
      var fi2 = (t, e, r) => {
        if (!(t && e == null)) return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
      }, X = fi2;
      function Dt(t, e) {
        if (typeof t == "string") return e(t);
        let r = /* @__PURE__ */ new Map();
        return n(t);
        function n(i) {
          if (r.has(i)) return r.get(i);
          let a = s(i);
          return r.set(i, a), a;
        }
        function s(i) {
          switch (Re(i)) {
            case Be3:
              return e(i.map(n));
            case he:
              return e({ ...i, parts: i.parts.map(n) });
            case me:
              return e({ ...i, breakContents: n(i.breakContents), flatContents: n(i.flatContents) });
            case te: {
              let { expandedStates: a, contents: o } = i;
              return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...i, contents: o, expandedStates: a });
            }
            case pe:
            case ce:
            case fe:
            case Ie:
            case Ne2:
              return e({ ...i, contents: n(i.contents) });
            case ke2:
            case Le2:
            case Fe2:
            case Pe:
            case Y:
            case de3:
              return e(i);
            default:
              throw new _t2(i);
          }
        }
      }
      function di(t) {
        switch (Re(t)) {
          case he:
            if (t.parts.every((e) => e === "")) return "";
            break;
          case te:
            if (!t.contents && !t.id && !t.break && !t.expandedStates) return "";
            if (t.contents.type === te && t.contents.id === t.id && t.contents.break === t.break && t.contents.expandedStates === t.expandedStates) return t.contents;
            break;
          case pe:
          case ce:
          case fe:
          case Ne2:
            if (!t.contents) return "";
            break;
          case me:
            if (!t.flatContents && !t.breakContents) return "";
            break;
          case Be3: {
            let e = [];
            for (let r of t) {
              if (!r) continue;
              let [n, ...s] = Array.isArray(r) ? r : [r];
              typeof n == "string" && typeof X(false, e, -1) == "string" ? e[e.length - 1] += n : e.push(n), e.push(...s);
            }
            return e.length === 0 ? "" : e.length === 1 ? e[0] : e;
          }
          case ke2:
          case Le2:
          case Fe2:
          case Pe:
          case Y:
          case Ie:
          case de3:
            break;
          default:
            throw new _t2(t);
        }
        return t;
      }
      function ln2(t) {
        return Dt(t, (e) => di(e));
      }
      function B(t, e = un2) {
        return Dt(t, (r) => typeof r == "string" ? q(e, r.split(`
`)) : r);
      }
      var vt = "'", cn2 = '"';
      function gi(t, e) {
        let r = e === true || e === vt ? vt : cn2, n = r === vt ? cn2 : vt, s = 0, i = 0;
        for (let a of t) a === r ? s++ : a === n && i++;
        return s > i ? n : r;
      }
      var pn2 = gi;
      function pr2(t) {
        if (typeof t != "string") throw new TypeError("Expected a string");
        return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }
      var H, hr = class {
        constructor(e) {
          en2(this, H);
          tn2(this, H, new Set(e));
        }
        getLeadingWhitespaceCount(e) {
          let r = Q3(this, H), n = 0;
          for (let s = 0; s < e.length && r.has(e.charAt(s)); s++) n++;
          return n;
        }
        getTrailingWhitespaceCount(e) {
          let r = Q3(this, H), n = 0;
          for (let s = e.length - 1; s >= 0 && r.has(e.charAt(s)); s--) n++;
          return n;
        }
        getLeadingWhitespace(e) {
          let r = this.getLeadingWhitespaceCount(e);
          return e.slice(0, r);
        }
        getTrailingWhitespace(e) {
          let r = this.getTrailingWhitespaceCount(e);
          return e.slice(e.length - r);
        }
        hasLeadingWhitespace(e) {
          return Q3(this, H).has(e.charAt(0));
        }
        hasTrailingWhitespace(e) {
          return Q3(this, H).has(X(false, e, -1));
        }
        trimStart(e) {
          let r = this.getLeadingWhitespaceCount(e);
          return e.slice(r);
        }
        trimEnd(e) {
          let r = this.getTrailingWhitespaceCount(e);
          return e.slice(0, e.length - r);
        }
        trim(e) {
          return this.trimEnd(this.trimStart(e));
        }
        split(e, r = false) {
          let n = `[${pr2([...Q3(this, H)].join(""))}]+`, s = new RegExp(r ? `(${n})` : n, "u");
          return e.split(s);
        }
        hasWhitespaceCharacter(e) {
          let r = Q3(this, H);
          return Array.prototype.some.call(e, (n) => r.has(n));
        }
        hasNonWhitespaceCharacter(e) {
          let r = Q3(this, H);
          return Array.prototype.some.call(e, (n) => !r.has(n));
        }
        isWhitespaceOnly(e) {
          let r = Q3(this, H);
          return Array.prototype.every.call(e, (n) => r.has(n));
        }
      };
      H = /* @__PURE__ */ new WeakMap();
      var hn2 = hr;
      var Ci2 = ["	", `
`, "\f", "\r", " "], Si2 = new hn2(Ci2), N2 = Si2;
      var mr2 = class extends Error {
        constructor(e, r, n = "type") {
          super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`);
          __publicField(this, "name", "UnexpectedNodeError");
          this.node = e;
        }
      }, mn = mr2;
      function _i2(t) {
        return (t == null ? void 0 : t.type) === "front-matter";
      }
      var $e = _i2;
      var Ei2 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]), Ai2 = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
      function fn2(t, e) {
        var r;
        if (t.type === "text" || t.type === "comment" || $e(t) || t.type === "yaml" || t.type === "toml") return null;
        if (t.type === "attribute" && delete e.value, t.type === "docType" && delete e.value, t.type === "angularControlFlowBlock" && ((r = t.parameters) != null && r.children)) for (let n of e.parameters.children) Ai2.has(t.name) ? delete n.expression : n.expression = n.expression.trim();
        t.type === "angularIcuExpression" && (e.switchValue = t.switchValue.trim()), t.type === "angularLetDeclarationInitializer" && delete e.value;
      }
      fn2.ignoredProperties = Ei2;
      var dn2 = fn2;
      async function Di2(t, e) {
        if (t.language === "yaml") {
          let r = t.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
          return an2([t.startDelimiter, t.explicitLanguage, S, n, n ? S : "", t.endDelimiter]);
        }
      }
      var gn2 = Di2;
      function Ce(t, e = true) {
        return [k([v2, t]), e ? v2 : ""];
      }
      function j(t, e) {
        let r = t.type === "NGRoot" ? t.node.type === "NGMicrosyntax" && t.node.body.length === 1 && t.node.body[0].type === "NGMicrosyntaxExpression" ? t.node.body[0].expression : t.node : t.type === "JsExpressionRoot" ? t.node : t;
        return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
      }
      async function T3(t, e, r, n) {
        r = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r };
        let s = true;
        n && (r.__onHtmlBindingRoot = (a, o) => {
          s = n(a, o);
        });
        let i = await e(t, r, e);
        return s ? _2(i) : Ce(i);
      }
      function vi2(t, e, r, n) {
        let { node: s } = r, i = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
        return /^\s*$/u.test(i) ? "" : T3(i, t, { parser: "__ng_directive", __isInHtmlAttribute: false }, j);
      }
      var Cn = vi2;
      var yi2 = (t) => String(t).split(/[/\\]/u).pop();
      function Sn2(t, e) {
        if (!e) return;
        let r = yi2(e).toLowerCase();
        return t.find(({ filenames: n }) => n == null ? void 0 : n.some((s) => s.toLowerCase() === r)) ?? t.find(({ extensions: n }) => n == null ? void 0 : n.some((s) => r.endsWith(s)));
      }
      function wi2(t, e) {
        if (e) return t.find(({ name: r }) => r.toLowerCase() === e) ?? t.find(({ aliases: r }) => r == null ? void 0 : r.includes(e)) ?? t.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${e}`));
      }
      function bi2(t, e) {
        let r = t.plugins.flatMap((s) => s.languages ?? []), n = wi2(r, e.language) ?? Sn2(r, e.physicalFile) ?? Sn2(r, e.file) ?? (e.physicalFile, void 0);
        return n == null ? void 0 : n.parsers[0];
      }
      var Oe2 = bi2;
      var _n2 = "inline", En2 = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", marquee: "inline-block", source: "block", track: "block", details: "block", summary: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, An2 = "normal", Dn2 = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
      function Ti2(t) {
        return t.type === "element" && !t.hasExplicitNamespace && !["html", "svg"].includes(t.namespace);
      }
      var Se = Ti2;
      var xi2 = (t) => w(false, t, /^[\t\f\r ]*\n/gu, ""), fr2 = (t) => xi2(N2.trimEnd(t)), vn = (t) => {
        let e = t, r = N2.getLeadingWhitespace(e);
        r && (e = e.slice(r.length));
        let n = N2.getTrailingWhitespace(e);
        return n && (e = e.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: e };
      };
      function yt(t, e) {
        return !!(t.type === "ieConditionalComment" && t.lastChild && !t.lastChild.isSelfClosing && !t.lastChild.endSourceSpan || t.type === "ieConditionalComment" && !t.complete || _e3(t) && t.children.some((r) => r.type !== "text" && r.type !== "interpolation") || Tt(t, e) && !U(t) && t.type !== "interpolation");
      }
      function Ee(t) {
        return t.type === "attribute" || !t.parent || !t.prev ? false : ki2(t.prev);
      }
      function ki2(t) {
        return t.type === "comment" && t.value.trim() === "prettier-ignore";
      }
      function $(t) {
        return t.type === "text" || t.type === "comment";
      }
      function U(t) {
        return t.type === "element" && (t.fullName === "script" || t.fullName === "style" || t.fullName === "svg:style" || t.fullName === "svg:script" || Se(t) && (t.name === "script" || t.name === "style"));
      }
      function yn2(t) {
        return t.children && !U(t);
      }
      function wn2(t) {
        return U(t) || t.type === "interpolation" || dr(t);
      }
      function dr(t) {
        return Rn(t).startsWith("pre");
      }
      function bn2(t, e) {
        var s, i;
        let r = n();
        if (r && !t.prev && ((i = (s = t.parent) == null ? void 0 : s.tagDefinition) != null && i.ignoreFirstLf)) return t.type === "interpolation";
        return r;
        function n() {
          return $e(t) || t.type === "angularControlFlowBlock" ? false : (t.type === "text" || t.type === "interpolation") && t.prev && (t.prev.type === "text" || t.prev.type === "interpolation") ? true : !t.parent || t.parent.cssDisplay === "none" ? false : _e3(t.parent) ? true : !(!t.prev && (t.parent.type === "root" || _e3(t) && t.parent || U(t.parent) || Je(t.parent, e) || !Ii2(t.parent.cssDisplay)) || t.prev && !Oi2(t.prev.cssDisplay));
        }
      }
      function Tn3(t, e) {
        return $e(t) || t.type === "angularControlFlowBlock" ? false : (t.type === "text" || t.type === "interpolation") && t.next && (t.next.type === "text" || t.next.type === "interpolation") ? true : !t.parent || t.parent.cssDisplay === "none" ? false : _e3(t.parent) ? true : !(!t.next && (t.parent.type === "root" || _e3(t) && t.parent || U(t.parent) || Je(t.parent, e) || !Ri2(t.parent.cssDisplay)) || t.next && !$i2(t.next.cssDisplay));
      }
      function xn2(t) {
        return Mi2(t.cssDisplay) && !U(t);
      }
      function Qe2(t) {
        return $e(t) || t.next && t.sourceSpan.end && t.sourceSpan.end.line + 1 < t.next.sourceSpan.start.line;
      }
      function kn2(t) {
        return gr2(t) || t.type === "element" && t.children.length > 0 && (["body", "script", "style"].includes(t.name) || t.children.some((e) => Li2(e))) || t.firstChild && t.firstChild === t.lastChild && t.firstChild.type !== "text" && Ln(t.firstChild) && (!t.lastChild.isTrailingSpaceSensitive || Fn(t.lastChild));
      }
      function gr2(t) {
        return t.type === "element" && t.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t.name) || t.cssDisplay.startsWith("table") && t.cssDisplay !== "table-cell");
      }
      function wt(t) {
        return Nn2(t) || t.prev && Bi(t.prev) || Bn2(t);
      }
      function Bi(t) {
        return Nn2(t) || t.type === "element" && t.fullName === "br" || Bn2(t);
      }
      function Bn2(t) {
        return Ln(t) && Fn(t);
      }
      function Ln(t) {
        return t.hasLeadingSpaces && (t.prev ? t.prev.sourceSpan.end.line < t.sourceSpan.start.line : t.parent.type === "root" || t.parent.startSourceSpan.end.line < t.sourceSpan.start.line);
      }
      function Fn(t) {
        return t.hasTrailingSpaces && (t.next ? t.next.sourceSpan.start.line > t.sourceSpan.end.line : t.parent.type === "root" || t.parent.endSourceSpan && t.parent.endSourceSpan.start.line > t.sourceSpan.end.line);
      }
      function Nn2(t) {
        switch (t.type) {
          case "ieConditionalComment":
          case "comment":
          case "directive":
            return true;
          case "element":
            return ["script", "select"].includes(t.name);
        }
        return false;
      }
      function bt2(t) {
        return t.lastChild ? bt2(t.lastChild) : t;
      }
      function Li2(t) {
        var e;
        return (e = t.children) == null ? void 0 : e.some((r) => r.type !== "text");
      }
      function Pn2(t) {
        if (t) switch (t) {
          case "module":
          case "text/javascript":
          case "text/babel":
          case "application/javascript":
            return "babel";
          case "application/x-typescript":
            return "typescript";
          case "text/markdown":
            return "markdown";
          case "text/html":
            return "html";
          case "text/x-handlebars-template":
            return "glimmer";
          default:
            if (t.endsWith("json") || t.endsWith("importmap") || t === "speculationrules") return "json";
        }
      }
      function Fi2(t, e) {
        let { name: r, attrMap: n } = t;
        if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src")) return;
        let { type: s, lang: i } = t.attrMap;
        return !i && !s ? "babel" : Oe2(e, { language: i }) ?? Pn2(s);
      }
      function Ni2(t, e) {
        if (!Tt(t, e)) return;
        let { attrMap: r } = t;
        if (Object.prototype.hasOwnProperty.call(r, "src")) return;
        let { type: n, lang: s } = r;
        return Oe2(e, { language: s }) ?? Pn2(n);
      }
      function Pi2(t, e) {
        if (t.name !== "style") return;
        let { lang: r } = t.attrMap;
        return r ? Oe2(e, { language: r }) : "css";
      }
      function Cr2(t, e) {
        return Fi2(t, e) ?? Pi2(t, e) ?? Ni2(t, e);
      }
      function Xe2(t) {
        return t === "block" || t === "list-item" || t.startsWith("table");
      }
      function Ii2(t) {
        return !Xe2(t) && t !== "inline-block";
      }
      function Ri2(t) {
        return !Xe2(t) && t !== "inline-block";
      }
      function $i2(t) {
        return !Xe2(t);
      }
      function Oi2(t) {
        return !Xe2(t);
      }
      function Mi2(t) {
        return !Xe2(t) && t !== "inline-block";
      }
      function _e3(t) {
        return Rn(t).startsWith("pre");
      }
      function qi(t, e) {
        let r = t;
        for (; r; ) {
          if (e(r)) return true;
          r = r.parent;
        }
        return false;
      }
      function In2(t, e) {
        var n;
        if (Ae(t, e)) return "block";
        if (((n = t.prev) == null ? void 0 : n.type) === "comment") {
          let s = t.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
          if (s) return s[1];
        }
        let r = false;
        if (t.type === "element" && t.namespace === "svg") if (qi(t, (s) => s.fullName === "svg:foreignObject")) r = true;
        else return t.name === "svg" ? "inline-block" : "block";
        switch (e.htmlWhitespaceSensitivity) {
          case "strict":
            return "inline";
          case "ignore":
            return "block";
          default:
            return t.type === "element" && (!t.namespace || r || Se(t)) && En2[t.name] || _n2;
        }
      }
      function Rn(t) {
        return t.type === "element" && (!t.namespace || Se(t)) && Dn2[t.name] || An2;
      }
      function Hi2(t) {
        let e = Number.POSITIVE_INFINITY;
        for (let r of t.split(`
`)) {
          if (r.length === 0) continue;
          let n = N2.getLeadingWhitespaceCount(r);
          if (n === 0) return 0;
          r.length !== n && n < e && (e = n);
        }
        return e === Number.POSITIVE_INFINITY ? 0 : e;
      }
      function Sr2(t, e = Hi2(t)) {
        return e === 0 ? t : t.split(`
`).map((r) => r.slice(e)).join(`
`);
      }
      function _r2(t) {
        return w(false, w(false, t, "&apos;", "'"), "&quot;", '"');
      }
      function P(t) {
        return _r2(t.value);
      }
      var Vi = /* @__PURE__ */ new Set(["template", "style", "script"]);
      function Je(t, e) {
        return Ae(t, e) && !Vi.has(t.fullName);
      }
      function Ae(t, e) {
        return e.parser === "vue" && t.type === "element" && t.parent.type === "root" && t.fullName.toLowerCase() !== "html";
      }
      function Tt(t, e) {
        return Ae(t, e) && (Je(t, e) || t.attrMap.lang && t.attrMap.lang !== "html");
      }
      function $n2(t) {
        let e = t.fullName;
        return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
      }
      function On2(t, e) {
        let r = t.parent;
        if (!Ae(r, e)) return false;
        let n = r.fullName, s = t.fullName;
        return n === "script" && s === "setup" || n === "style" && s === "vars";
      }
      function xt(t, e = t.value) {
        return t.parent.isWhitespaceSensitive ? t.parent.isIndentationSensitive ? B(e) : B(Sr2(fr2(e)), S) : q(E, N2.split(e));
      }
      function kt2(t, e) {
        return Ae(t, e) && t.name === "script";
      }
      var Er2 = /\{\{(.+?)\}\}/su;
      async function Mn2(t, e) {
        let r = [];
        for (let [n, s] of t.split(Er2).entries()) if (n % 2 === 0) r.push(B(s));
        else try {
          r.push(_2(["{{", k([E, await T3(s, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), E, "}}"]));
        } catch {
          r.push("{{", B(s), "}}");
        }
        return r;
      }
      function Ar2({ parser: t }) {
        return (e, r, n) => T3(P(n.node), e, { parser: t }, j);
      }
      var Ui2 = Ar2({ parser: "__ng_action" }), Wi2 = Ar2({ parser: "__ng_binding" }), zi2 = Ar2({ parser: "__ng_directive" });
      function Gi2(t, e) {
        if (e.parser !== "angular") return;
        let { node: r } = t, n = r.fullName;
        if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-")) return Ui2;
        if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/u.test(n) || /^ng-(?:if|show|hide|class|style)$/u.test(n)) return Wi2;
        if (n.startsWith("*")) return zi2;
        let s = P(r);
        if (/^i18n(?:-.+)?$/u.test(n)) return () => Ce(At(xt(r, s.trim())), !s.includes("@@"));
        if (Er2.test(s)) return (i) => Mn2(s, i);
      }
      var qn2 = Gi2;
      function Yi2(t, e) {
        let { node: r } = t, n = P(r);
        if (r.fullName === "class" && !e.parentParser && !n.includes("{{")) return () => n.trim().split(/\s+/u).join(" ");
      }
      var Hn = Yi2;
      function Vn2(t) {
        return t === "	" || t === `
` || t === "\f" || t === "\r" || t === " ";
      }
      var ji = /^[ \t\n\r\u000c]+/, Ki2 = /^[, \t\n\r\u000c]+/, Qi = /^[^ \t\n\r\u000c]+/, Xi2 = /[,]+$/, Un2 = /^\d+$/, Ji = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
      function Zi2(t) {
        let e = t.length, r, n, s, i, a, o = 0, u;
        function p(C) {
          let A, D = C.exec(t.substring(o));
          if (D) return [A] = D, o += A.length, A;
        }
        let l = [];
        for (; ; ) {
          if (p(Ki2), o >= e) {
            if (l.length === 0) throw new Error("Must contain one or more image candidate strings.");
            return l;
          }
          u = o, r = p(Qi), n = [], r.slice(-1) === "," ? (r = r.replace(Xi2, ""), d2()) : f();
        }
        function f() {
          for (p(ji), s = "", i = "in descriptor"; ; ) {
            if (a = t.charAt(o), i === "in descriptor") if (Vn2(a)) s && (n.push(s), s = "", i = "after descriptor");
            else if (a === ",") {
              o += 1, s && n.push(s), d2();
              return;
            } else if (a === "(") s += a, i = "in parens";
            else if (a === "") {
              s && n.push(s), d2();
              return;
            } else s += a;
            else if (i === "in parens") if (a === ")") s += a, i = "in descriptor";
            else if (a === "") {
              n.push(s), d2();
              return;
            } else s += a;
            else if (i === "after descriptor" && !Vn2(a)) if (a === "") {
              d2();
              return;
            } else i = "in descriptor", o -= 1;
            o += 1;
          }
        }
        function d2() {
          let C = false, A, D, R, F, c = {}, g, y2, M, x, V;
          for (F = 0; F < n.length; F++) g = n[F], y2 = g[g.length - 1], M = g.substring(0, g.length - 1), x = parseInt(M, 10), V = parseFloat(M), Un2.test(M) && y2 === "w" ? ((A || D) && (C = true), x === 0 ? C = true : A = x) : Ji.test(M) && y2 === "x" ? ((A || D || R) && (C = true), V < 0 ? C = true : D = V) : Un2.test(M) && y2 === "h" ? ((R || D) && (C = true), x === 0 ? C = true : R = x) : C = true;
          if (!C) c.source = { value: r, startOffset: u }, A && (c.width = { value: A }), D && (c.density = { value: D }), R && (c.height = { value: R }), l.push(c);
          else throw new Error(`Invalid srcset descriptor found in "${t}" at "${g}".`);
        }
      }
      var Wn2 = Zi2;
      function ea2(t) {
        if (t.node.fullName === "srcset" && (t.parent.fullName === "img" || t.parent.fullName === "source")) return () => ra2(P(t.node));
      }
      var zn = { width: "w", height: "h", density: "x" }, ta2 = Object.keys(zn);
      function ra2(t) {
        let e = Wn2(t), r = ta2.filter((l) => e.some((f) => Object.prototype.hasOwnProperty.call(f, l)));
        if (r.length > 1) throw new Error("Mixed descriptor in srcset is not supported");
        let [n] = r, s = zn[n], i = e.map((l) => l.source.value), a = Math.max(...i.map((l) => l.length)), o = e.map((l) => l[n] ? String(l[n].value) : ""), u = o.map((l) => {
          let f = l.indexOf(".");
          return f === -1 ? l.length : f;
        }), p = Math.max(...u);
        return Ce(q([",", E], i.map((l, f) => {
          let d2 = [l], C = o[f];
          if (C) {
            let A = a - l.length + 1, D = p - u[f], R = " ".repeat(A + D);
            d2.push(ge(R, " "), C + s);
          }
          return d2;
        })));
      }
      var Gn2 = ea2;
      function Yn2(t, e) {
        let { node: r } = t, n = P(t.node).trim();
        if (r.fullName === "style" && !e.parentParser && !n.includes("{{")) return async (s) => Ce(await s(n, { parser: "css", __isHTMLStyleAttribute: true }));
      }
      var Dr2 = /* @__PURE__ */ new WeakMap();
      function na2(t, e) {
        let { root: r } = t;
        return Dr2.has(r) || Dr2.set(r, r.children.some((n) => kt2(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), Dr2.get(r);
      }
      var Me = na2;
      function jn2(t, e, r) {
        let { node: n } = r, s = P(n);
        return T3(`type T<${s}> = any`, t, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, j);
      }
      function Kn2(t, e, { parseWithTs: r }) {
        return T3(`function _(${t}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: true });
      }
      function Qn2(t) {
        let e = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/u, r = /^[$_a-z][\w$]*(?:\.[$_a-z][\w$]*|\['[^']*'\]|\["[^"]*"\]|\[\d+\]|\[[$_a-z][\w$]*\])*$/iu, n = t.trim();
        return e.test(n) || r.test(n);
      }
      async function Xn2(t, e, r, n) {
        let s = P(r.node), { left: i, operator: a, right: o } = sa2(s), u = Me(r, n);
        return [_2(await T3(`function _(${i}) {}`, t, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await T3(o, t, { parser: u ? "__ts_expression" : "__js_expression" })];
      }
      function sa2(t) {
        let e = /(.*?)\s+(in|of)\s+(.*)/su, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n = /^\(|\)$/gu, s = t.match(e);
        if (!s) return;
        let i = {};
        if (i.for = s[3].trim(), !i.for) return;
        let a = w(false, s[1].trim(), n, ""), o = a.match(r);
        o ? (i.alias = a.replace(r, ""), i.iterator1 = o[1].trim(), o[2] && (i.iterator2 = o[2].trim())) : i.alias = a;
        let u = [i.alias, i.iterator1, i.iterator2];
        if (!u.some((p, l) => !p && (l === 0 || u.slice(l + 1).some(Boolean)))) return { left: u.filter(Boolean).join(","), operator: s[2], right: i.for };
      }
      function ia2(t, e) {
        if (e.parser !== "vue") return;
        let { node: r } = t, n = r.fullName;
        if (n === "v-for") return Xn2;
        if (n === "generic" && kt2(r.parent, e)) return jn2;
        let s = P(r), i = Me(t, e);
        if ($n2(r) || On2(r, e)) return (a) => Kn2(s, a, { parseWithTs: i });
        if (n.startsWith("@") || n.startsWith("v-on:")) return (a) => aa2(s, a, { parseWithTs: i });
        if (n.startsWith(":") || n.startsWith("v-bind:")) return (a) => oa2(s, a, { parseWithTs: i });
        if (n.startsWith("v-")) return (a) => Jn2(s, a, { parseWithTs: i });
      }
      function aa2(t, e, { parseWithTs: r }) {
        return Qn2(t) ? Jn2(t, e, { parseWithTs: r }) : T3(t, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, j);
      }
      function oa2(t, e, { parseWithTs: r }) {
        return T3(t, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, j);
      }
      function Jn2(t, e, { parseWithTs: r }) {
        return T3(t, e, { parser: r ? "__ts_expression" : "__js_expression" }, j);
      }
      var Zn = ia2;
      function ua3(t, e) {
        let { node: r } = t;
        if (r.value) {
          if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}")) return [r.rawName, "=", r.value];
          for (let n of [Gn2, Yn2, Hn, Zn, qn2]) {
            let s = n(t, e);
            if (s) return la2(s);
          }
        }
      }
      function la2(t) {
        return async (e, r, n, s) => {
          let i = await t(e, r, n, s);
          if (i) return i = Dt(i, (a) => typeof a == "string" ? w(false, a, '"', "&quot;") : a), [n.node.rawName, '="', _2(i), '"'];
        };
      }
      var es2 = ua3;
      var ts2 = new Proxy(() => {
      }, { get: () => ts2 }), vr2 = ts2;
      function ca2(t) {
        return Array.isArray(t) && t.length > 0;
      }
      var qe = ca2;
      function se(t) {
        return t.sourceSpan.start.offset;
      }
      function ie(t) {
        return t.sourceSpan.end.offset;
      }
      function Ze2(t, e) {
        return [t.isSelfClosing ? "" : pa2(t, e), De(t, e)];
      }
      function pa2(t, e) {
        return t.lastChild && we(t.lastChild) ? "" : [ha2(t, e), Bt2(t, e)];
      }
      function De(t, e) {
        return (t.next ? K(t.next) : ye(t.parent)) ? "" : [ve2(t, e), W(t, e)];
      }
      function ha2(t, e) {
        return ye(t) ? ve2(t.lastChild, e) : "";
      }
      function W(t, e) {
        return we(t) ? Bt2(t.parent, e) : et(t) ? Lt2(t.next) : "";
      }
      function Bt2(t, e) {
        if (vr2(!t.isSelfClosing), rs2(t, e)) return "";
        switch (t.type) {
          case "ieConditionalComment":
            return "<!";
          case "element":
            if (t.hasHtmComponentClosingTag) return "<//";
          default:
            return `</${t.rawName}`;
        }
      }
      function ve2(t, e) {
        if (rs2(t, e)) return "";
        switch (t.type) {
          case "ieConditionalComment":
          case "ieConditionalEndComment":
            return "[endif]-->";
          case "ieConditionalStartComment":
            return "]><!-->";
          case "interpolation":
            return "}}";
          case "angularIcuExpression":
            return "}";
          case "element":
            if (t.isSelfClosing) return "/>";
          default:
            return ">";
        }
      }
      function rs2(t, e) {
        return !t.isSelfClosing && !t.endSourceSpan && (Ee(t) || yt(t.parent, e));
      }
      function K(t) {
        return t.prev && t.prev.type !== "docType" && t.type !== "angularControlFlowBlock" && !$(t.prev) && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
      }
      function ye(t) {
        var e;
        return ((e = t.lastChild) == null ? void 0 : e.isTrailingSpaceSensitive) && !t.lastChild.hasTrailingSpaces && !$(bt2(t.lastChild)) && !_e3(t);
      }
      function we(t) {
        return !t.next && !t.hasTrailingSpaces && t.isTrailingSpaceSensitive && $(bt2(t));
      }
      function et(t) {
        return t.next && !$(t.next) && $(t) && t.isTrailingSpaceSensitive && !t.hasTrailingSpaces;
      }
      function ma2(t) {
        let e = t.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
        return e ? e[1] ? e[1].split(/\s+/u) : true : false;
      }
      function tt(t) {
        return !t.prev && t.isLeadingSpaceSensitive && !t.hasLeadingSpaces;
      }
      function fa2(t, e, r) {
        var f;
        let { node: n } = t;
        if (!qe(n.attrs)) return n.isSelfClosing ? " " : "";
        let s = ((f = n.prev) == null ? void 0 : f.type) === "comment" && ma2(n.prev.value), i = typeof s == "boolean" ? () => s : Array.isArray(s) ? (d2) => s.includes(d2.rawName) : () => false, a = t.map(({ node: d2 }) => i(d2) ? B(e.originalText.slice(se(d2), ie(d2))) : r(), "attrs"), o = n.type === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, p = e.singleAttributePerLine && n.attrs.length > 1 && !Ae(n, e) ? S : E, l = [k([o ? " " : E, q(p, a)])];
        return n.firstChild && tt(n.firstChild) || n.isSelfClosing && ye(n.parent) || o ? l.push(n.isSelfClosing ? " " : "") : l.push(e.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? E : v2), l;
      }
      function da(t) {
        return t.firstChild && tt(t.firstChild) ? "" : Ft2(t);
      }
      function rt(t, e, r) {
        let { node: n } = t;
        return [be2(n, e), fa2(t, e, r), n.isSelfClosing ? "" : da(n)];
      }
      function be2(t, e) {
        return t.prev && et(t.prev) ? "" : [z(t, e), Lt2(t)];
      }
      function z(t, e) {
        return tt(t) ? Ft2(t.parent) : K(t) ? ve2(t.prev, e) : "";
      }
      function Lt2(t) {
        switch (t.type) {
          case "ieConditionalComment":
          case "ieConditionalStartComment":
            return `<!--[if ${t.condition}`;
          case "ieConditionalEndComment":
            return "<!--<!";
          case "interpolation":
            return "{{";
          case "docType":
            return t.value === "html" ? "<!doctype" : "<!DOCTYPE";
          case "angularIcuExpression":
            return "{";
          case "element":
            if (t.condition) return `<!--[if ${t.condition}]><!--><${t.rawName}`;
          default:
            return `<${t.rawName}`;
        }
      }
      function Ft2(t) {
        switch (vr2(!t.isSelfClosing), t.type) {
          case "ieConditionalComment":
            return "]>";
          case "element":
            if (t.condition) return "><!--<![endif]-->";
          default:
            return ">";
        }
      }
      function ga2(t, e) {
        if (!t.endSourceSpan) return "";
        let r = t.startSourceSpan.end.offset;
        t.firstChild && tt(t.firstChild) && (r -= Ft2(t).length);
        let n = t.endSourceSpan.start.offset;
        return t.lastChild && we(t.lastChild) ? n += Bt2(t, e).length : ye(t) && (n -= ve2(t.lastChild, e).length), e.originalText.slice(r, n);
      }
      var Nt = ga2;
      var Ca = /* @__PURE__ */ new Set(["if", "else if", "for", "switch", "case"]);
      function Sa2(t, e) {
        let { node: r } = t;
        switch (r.type) {
          case "element":
            if (U(r) || r.type === "interpolation") return;
            if (!r.isSelfClosing && Tt(r, e)) {
              let n = Cr2(r, e);
              return n ? async (s, i) => {
                let a = Nt(r, e), o = /^\s*$/u.test(a), u = "";
                return o || (u = await s(fr2(a), { parser: n, __embeddedInHtml: true }), o = u === ""), [z(r, e), _2(rt(t, e, i)), o ? "" : S, u, o ? "" : S, Ze2(r, e), W(r, e)];
              } : void 0;
            }
            break;
          case "text":
            if (U(r.parent)) {
              let n = Cr2(r.parent, e);
              if (n) return async (s) => {
                let i = n === "markdown" ? Sr2(r.value.replace(/^[^\S\n]*\n/u, "")) : r.value, a = { parser: n, __embeddedInHtml: true };
                if (e.parser === "html" && n === "babel") {
                  let o = "script", { attrMap: u } = r.parent;
                  u && (u.type === "module" || u.type === "text/babel" && u["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
                }
                return [ne, z(r, e), await s(i, a), W(r, e)];
              };
            } else if (r.parent.type === "interpolation") return async (n) => {
              let s = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
              return e.parser === "angular" ? s.parser = "__ng_interpolation" : e.parser === "vue" ? s.parser = Me(t, e) ? "__vue_ts_expression" : "__vue_expression" : s.parser = "__js_expression", [k([E, await n(r.value, s)]), r.parent.next && K(r.parent.next) ? " " : E];
            };
            break;
          case "attribute":
            return es2(t, e);
          case "front-matter":
            return (n) => gn2(r, n);
          case "angularControlFlowBlockParameters":
            return Ca.has(t.parent.name) ? Cn : void 0;
          case "angularLetDeclarationInitializer":
            return (n) => T3(r.value, n, { parser: "__ng_binding", __isInHtmlAttribute: false });
        }
      }
      var ns2 = Sa2;
      var nt2 = null;
      function st2(t) {
        if (nt2 !== null && typeof nt2.property) {
          let e = nt2;
          return nt2 = st2.prototype = null, e;
        }
        return nt2 = st2.prototype = t ?? /* @__PURE__ */ Object.create(null), new st2();
      }
      var _a2 = 10;
      for (let t = 0; t <= _a2; t++) st2();
      function yr2(t) {
        return st2(t);
      }
      function Ea(t, e = "type") {
        yr2(t);
        function r(n) {
          let s = n[e], i = t[s];
          if (!Array.isArray(i)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: n });
          return i;
        }
        return r;
      }
      var ss2 = Ea;
      var Aa2 = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] }, is2 = Aa2;
      var Da3 = ss2(is2), as = Da3;
      function os2(t) {
        return /^\s*<!--\s*@(?:format|prettier)\s*-->/u.test(t);
      }
      function us3(t) {
        return `<!-- @format -->

` + t;
      }
      var ls2 = /* @__PURE__ */ new Map([["if", /* @__PURE__ */ new Set(["else if", "else"])], ["else if", /* @__PURE__ */ new Set(["else if", "else"])], ["for", /* @__PURE__ */ new Set(["empty"])], ["defer", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["placeholder", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["error", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])], ["loading", /* @__PURE__ */ new Set(["placeholder", "error", "loading"])]]);
      function cs2(t) {
        let e = ie(t);
        return t.type === "element" && !t.endSourceSpan && qe(t.children) ? Math.max(e, cs2(X(false, t.children, -1))) : e;
      }
      function it2(t, e, r) {
        let n = t.node;
        if (Ee(n)) {
          let s = cs2(n);
          return [z(n, e), B(N2.trimEnd(e.originalText.slice(se(n) + (n.prev && et(n.prev) ? Lt2(n).length : 0), s - (n.next && K(n.next) ? ve2(n, e).length : 0)))), W(n, e)];
        }
        return r();
      }
      function Pt2(t, e) {
        return $(t) && $(e) ? t.isTrailingSpaceSensitive ? t.hasTrailingSpaces ? wt(e) ? S : E : "" : wt(e) ? S : v2 : et(t) && (Ee(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t.type === "element" && t.isSelfClosing && K(e) ? "" : !e.isLeadingSpaceSensitive || wt(e) || K(e) && t.lastChild && we(t.lastChild) && t.lastChild.lastChild && we(t.lastChild.lastChild) ? S : e.hasLeadingSpaces ? E : v2;
      }
      function He2(t, e, r) {
        let { node: n } = t;
        if (gr2(n)) return [ne, ...t.map((i) => {
          let a = i.node, o = a.prev ? Pt2(a.prev, a) : "";
          return [o ? [o, Qe2(a.prev) ? S : ""] : "", it2(i, e, r)];
        }, "children")];
        let s = n.children.map(() => Symbol(""));
        return t.map((i, a) => {
          let o = i.node;
          if ($(o)) {
            if (o.prev && $(o.prev)) {
              let A = Pt2(o.prev, o);
              if (A) return Qe2(o.prev) ? [S, S, it2(i, e, r)] : [A, it2(i, e, r)];
            }
            return it2(i, e, r);
          }
          let u = [], p = [], l = [], f = [], d2 = o.prev ? Pt2(o.prev, o) : "", C = o.next ? Pt2(o, o.next) : "";
          return d2 && (Qe2(o.prev) ? u.push(S, S) : d2 === S ? u.push(S) : $(o.prev) ? p.push(d2) : p.push(ge("", v2, { groupId: s[a - 1] }))), C && (Qe2(o) ? $(o.next) && f.push(S, S) : C === S ? $(o.next) && f.push(S) : l.push(C)), [...u, _2([...p, _2([it2(i, e, r), ...l], { id: s[a] })]), ...f];
        }, "children");
      }
      function ps2(t, e, r) {
        let { node: n } = t, s = [];
        va2(t) && s.push("} "), s.push("@", n.name), n.parameters && s.push(" (", _2(r("parameters")), ")"), s.push(" {");
        let i = hs2(n);
        return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = true, n.lastChild.hasTrailingSpaces = true, s.push(k([S, He2(t, e, r)])), i && s.push(S, "}")) : i && s.push("}"), _2(s, { shouldBreak: true });
      }
      function hs2(t) {
        var e, r;
        return !(((e = t.next) == null ? void 0 : e.type) === "angularControlFlowBlock" && ((r = ls2.get(t.name)) != null && r.has(t.next.name)));
      }
      function va2(t) {
        let { previous: e } = t;
        return (e == null ? void 0 : e.type) === "angularControlFlowBlock" && !Ee(e) && !hs2(e);
      }
      function ms2(t, e, r) {
        return [k([v2, q([";", E], t.map(r, "children"))]), v2];
      }
      function fs2(t, e, r) {
        let { node: n } = t;
        return [be2(n, e), _2([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", k([E, q(E, t.map(r, "cases"))])] : "", v2]), De(n, e)];
      }
      function ds2(t, e, r) {
        let { node: n } = t;
        return [n.value, " {", _2([k([v2, t.map(({ node: s }) => s.type === "text" && !N2.trim(s.value) ? "" : r(), "expression")]), v2]), "}"];
      }
      function gs3(t, e, r) {
        let { node: n } = t;
        if (yt(n, e)) return [z(n, e), _2(rt(t, e, r)), B(Nt(n, e)), ...Ze2(n, e), W(n, e)];
        let s = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, i = Symbol("element-attr-group-id"), a = (l) => _2([_2(rt(t, e, r), { id: i }), l, Ze2(n, e)]), o = (l) => s ? on2(l, { groupId: i }) : (U(n) || Je(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? l : k(l), u = () => s ? ge(v2, "", { groupId: i }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? E : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? sn2(v2) : v2, p = () => (n.next ? K(n.next) : ye(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : s ? ge(v2, "", { groupId: i }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? E : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t.ancestors.length - 1)}}$`, "u").test(n.lastChild.value) ? "" : v2;
        return n.children.length === 0 ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? E : "") : a([kn2(n) ? ne : "", o([u(), He2(t, e, r)]), p()]);
      }
      function at2(t) {
        return t >= 9 && t <= 32 || t == 160;
      }
      function It2(t) {
        return 48 <= t && t <= 57;
      }
      function ot(t) {
        return t >= 97 && t <= 122 || t >= 65 && t <= 90;
      }
      function Cs2(t) {
        return t >= 97 && t <= 102 || t >= 65 && t <= 70 || It2(t);
      }
      function Rt(t) {
        return t === 10 || t === 13;
      }
      function wr2(t) {
        return 48 <= t && t <= 55;
      }
      function $t(t) {
        return t === 39 || t === 34 || t === 96;
      }
      var ya2 = /-+([a-z0-9])/g;
      function _s2(t) {
        return t.replace(ya2, (...e) => e[1].toUpperCase());
      }
      var ae = class t {
        constructor(e, r, n, s) {
          this.file = e, this.offset = r, this.line = n, this.col = s;
        }
        toString() {
          return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
        }
        moveBy(e) {
          let r = this.file.content, n = r.length, s = this.offset, i = this.line, a = this.col;
          for (; s > 0 && e < 0; ) if (s--, e++, r.charCodeAt(s) == 10) {
            i--;
            let u = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
            a = u > 0 ? s - u : s;
          } else a--;
          for (; s < n && e > 0; ) {
            let o = r.charCodeAt(s);
            s++, e--, o == 10 ? (i++, a = 0) : a++;
          }
          return new t(this.file, s, i, a);
        }
        getContext(e, r) {
          let n = this.file.content, s = this.offset;
          if (s != null) {
            s > n.length - 1 && (s = n.length - 1);
            let i = s, a = 0, o = 0;
            for (; a < e && s > 0 && (s--, a++, !(n[s] == `
` && ++o == r)); ) ;
            for (a = 0, o = 0; a < e && i < n.length - 1 && (i++, a++, !(n[i] == `
` && ++o == r)); ) ;
            return { before: n.substring(s, this.offset), after: n.substring(this.offset, i + 1) };
          }
          return null;
        }
      }, Te2 = class {
        constructor(e, r) {
          this.content = e, this.url = r;
        }
      }, h = class {
        constructor(e, r, n = e, s = null) {
          this.start = e, this.end = r, this.fullStart = n, this.details = s;
        }
        toString() {
          return this.start.file.content.substring(this.start.offset, this.end.offset);
        }
      }, Ot2;
      (function(t) {
        t[t.WARNING = 0] = "WARNING", t[t.ERROR = 1] = "ERROR";
      })(Ot2 || (Ot2 = {}));
      var Ue = class {
        constructor(e, r, n = Ot2.ERROR) {
          this.span = e, this.msg = r, this.level = n;
        }
        contextualMessage() {
          let e = this.span.start.getContext(100, 3);
          return e ? `${this.msg} ("${e.before}[${Ot2[this.level]} ->]${e.after}")` : this.msg;
        }
        toString() {
          let e = this.span.details ? `, ${this.span.details}` : "";
          return `${this.contextualMessage()}: ${this.span.start}${e}`;
        }
      };
      var wa2 = [Ta2, xa, Ba2, Fa2, Na2, Ra2, Pa3, Ia2, $a2, La];
      function ba(t, e) {
        for (let r of wa2) r(t, e);
        return t;
      }
      function Ta2(t) {
        t.walk((e) => {
          if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
            let r = e.children[0];
            r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
          }
        });
      }
      function xa(t) {
        let e = (r) => {
          var n, s;
          return r.type === "element" && ((n = r.prev) == null ? void 0 : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((s = r.firstChild) == null ? void 0 : s.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
        };
        t.walk((r) => {
          if (r.children) for (let n = 0; n < r.children.length; n++) {
            let s = r.children[n];
            if (!e(s)) continue;
            let i = s.prev, a = s.firstChild;
            r.removeChild(i), n--;
            let o = new h(i.sourceSpan.start, a.sourceSpan.end), u = new h(o.start, s.sourceSpan.end);
            s.condition = i.condition, s.sourceSpan = u, s.startSourceSpan = o, s.removeChild(a);
          }
        });
      }
      function ka2(t, e, r) {
        t.walk((n) => {
          if (n.children) for (let s = 0; s < n.children.length; s++) {
            let i = n.children[s];
            if (i.type !== "text" && !e(i)) continue;
            i.type !== "text" && (i.type = "text", i.value = r(i));
            let a = i.prev;
            !a || a.type !== "text" || (a.value += i.value, a.sourceSpan = new h(a.sourceSpan.start, i.sourceSpan.end), n.removeChild(i), s--);
          }
        });
      }
      function Ba2(t) {
        return ka2(t, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
      }
      function La(t) {
        let e = (r) => {
          var n, s;
          return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !N2.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? void 0 : n.type) === "text" && ((s = r.next) == null ? void 0 : s.type) === "text";
        };
        t.walk((r) => {
          if (r.children) for (let n = 0; n < r.children.length; n++) {
            let s = r.children[n];
            if (!e(s)) continue;
            let i = s.prev, a = s.next;
            i.value += `<${s.rawName}>` + s.firstChild.value + `</${s.rawName}>` + a.value, i.sourceSpan = new h(i.sourceSpan.start, a.sourceSpan.end), i.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(s), n--, r.removeChild(a);
          }
        });
      }
      function Fa2(t, e) {
        if (e.parser === "html") return;
        let r = /\{\{(.+?)\}\}/su;
        t.walk((n) => {
          if (yn2(n)) for (let s of n.children) {
            if (s.type !== "text") continue;
            let i = s.sourceSpan.start, a = null, o = s.value.split(r);
            for (let u = 0; u < o.length; u++, i = a) {
              let p = o[u];
              if (u % 2 === 0) {
                a = i.moveBy(p.length), p.length > 0 && n.insertChildBefore(s, { type: "text", value: p, sourceSpan: new h(i, a) });
                continue;
              }
              a = i.moveBy(p.length + 4), n.insertChildBefore(s, { type: "interpolation", sourceSpan: new h(i, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new h(i.moveBy(2), a.moveBy(-2)) }] });
            }
            n.removeChild(s);
          }
        });
      }
      function Na2(t) {
        t.walk((e) => {
          if (!e.children) return;
          if (e.children.length === 0 || e.children.length === 1 && e.children[0].type === "text" && N2.trim(e.children[0].value).length === 0) {
            e.hasDanglingSpaces = e.children.length > 0, e.children = [];
            return;
          }
          let r = wn2(e), n = dr(e);
          if (!r) for (let s = 0; s < e.children.length; s++) {
            let i = e.children[s];
            if (i.type !== "text") continue;
            let { leadingWhitespace: a, text: o, trailingWhitespace: u } = vn(i.value), p = i.prev, l = i.next;
            o ? (i.value = o, i.sourceSpan = new h(i.sourceSpan.start.moveBy(a.length), i.sourceSpan.end.moveBy(-u.length)), a && (p && (p.hasTrailingSpaces = true), i.hasLeadingSpaces = true), u && (i.hasTrailingSpaces = true, l && (l.hasLeadingSpaces = true))) : (e.removeChild(i), s--, (a || u) && (p && (p.hasTrailingSpaces = true), l && (l.hasLeadingSpaces = true)));
          }
          e.isWhitespaceSensitive = r, e.isIndentationSensitive = n;
        });
      }
      function Pa3(t) {
        t.walk((e) => {
          e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
        });
      }
      function Ia2(t, e) {
        t.walk((r) => {
          r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
        });
      }
      function Ra2(t, e) {
        t.walk((r) => {
          r.cssDisplay = In2(r, e);
        });
      }
      function $a2(t, e) {
        t.walk((r) => {
          let { children: n } = r;
          if (n) {
            if (n.length === 0) {
              r.isDanglingSpaceSensitive = xn2(r);
              return;
            }
            for (let s of n) s.isLeadingSpaceSensitive = bn2(s, e), s.isTrailingSpaceSensitive = Tn3(s, e);
            for (let s = 0; s < n.length; s++) {
              let i = n[s];
              i.isLeadingSpaceSensitive = (s === 0 || i.prev.isTrailingSpaceSensitive) && i.isLeadingSpaceSensitive, i.isTrailingSpaceSensitive = (s === n.length - 1 || i.next.isLeadingSpaceSensitive) && i.isTrailingSpaceSensitive;
            }
          }
        });
      }
      var Es2 = ba;
      function Oa2(t, e, r) {
        let { node: n } = t;
        switch (n.type) {
          case "front-matter":
            return B(n.raw);
          case "root":
            return e.__onHtmlRoot && e.__onHtmlRoot(n), [_2(He2(t, e, r)), S];
          case "element":
          case "ieConditionalComment":
            return gs3(t, e, r);
          case "angularControlFlowBlock":
            return ps2(t, e, r);
          case "angularControlFlowBlockParameters":
            return ms2(t, e, r);
          case "angularControlFlowBlockParameter":
            return N2.trim(n.expression);
          case "angularLetDeclaration":
            return _2(["@let ", _2([n.id, " =", _2(k([E, r("init")]))]), ";"]);
          case "angularLetDeclarationInitializer":
            return n.value;
          case "angularIcuExpression":
            return fs2(t, e, r);
          case "angularIcuCase":
            return ds2(t, e, r);
          case "ieConditionalStartComment":
          case "ieConditionalEndComment":
            return [be2(n), De(n)];
          case "interpolation":
            return [be2(n, e), ...t.map(r, "children"), De(n, e)];
          case "text": {
            if (n.parent.type === "interpolation") {
              let i = /\n[^\S\n]*$/u, a = i.test(n.value), o = a ? n.value.replace(i, "") : n.value;
              return [B(o), a ? S : ""];
            }
            let s = ln2([z(n, e), ...xt(n), W(n, e)]);
            return Array.isArray(s) ? At(s) : s;
          }
          case "docType":
            return [_2([be2(n, e), " ", w(false, n.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), De(n, e)];
          case "comment":
            return [z(n, e), B(e.originalText.slice(se(n), ie(n))), W(n, e)];
          case "attribute": {
            if (n.value === null) return n.rawName;
            let s = _r2(n.value), i = pn2(s, '"');
            return [n.rawName, "=", i, B(i === '"' ? w(false, s, '"', "&quot;") : w(false, s, "'", "&apos;")), i];
          }
          case "cdata":
          default:
            throw new mn(n, "HTML");
        }
      }
      var Ma2 = { preprocess: Es2, print: Oa2, insertPragma: us3, massageAstNode: dn2, embed: ns2, getVisitorKeys: as }, As2 = Ma2;
      var Ds2 = [{ linguistLanguageId: 146, name: "Angular", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".component.html"], parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 146, name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml", ".mjml"], parsers: ["html"], vscodeLanguageIds: ["html"] }, { linguistLanguageId: 146, name: "Lightning Web Components", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [], parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [] }, { linguistLanguageId: 391, name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"] }];
      var br2 = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
      var vs2 = "HTML", qa2 = { bracketSameLine: br2.bracketSameLine, htmlWhitespaceSensitivity: { category: vs2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: br2.singleAttributePerLine, vueIndentScriptAndStyle: { category: vs2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, ys2 = qa2;
      var Yr2 = {};
      Jr2(Yr2, { angular: () => Oo, html: () => $o2, lwc: () => qo2, vue: () => Mo2 });
      var yp2 = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
      var ws2;
      (function(t) {
        t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom";
      })(ws2 || (ws2 = {}));
      var bs2;
      (function(t) {
        t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default";
      })(bs2 || (bs2 = {}));
      var Ts2;
      (function(t) {
        t[t.None = 0] = "None", t[t.SignalBased = 1] = "SignalBased", t[t.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
      })(Ts2 || (Ts2 = {}));
      var Tr2 = { name: "custom-elements" }, xr = { name: "no-errors-schema" };
      var J;
      (function(t) {
        t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL";
      })(J || (J = {}));
      var xs2;
      (function(t) {
        t[t.Error = 0] = "Error", t[t.Warning = 1] = "Warning", t[t.Ignore = 2] = "Ignore";
      })(xs2 || (xs2 = {}));
      var I;
      (function(t) {
        t[t.RAW_TEXT = 0] = "RAW_TEXT", t[t.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t[t.PARSABLE_DATA = 2] = "PARSABLE_DATA";
      })(I || (I = {}));
      function ut(t, e = true) {
        if (t[0] != ":") return [null, t];
        let r = t.indexOf(":", 1);
        if (r === -1) {
          if (e) throw new Error(`Unsupported format "${t}" expecting ":namespace:name"`);
          return [null, t];
        }
        return [t.slice(1, r), t.slice(r + 1)];
      }
      function kr2(t) {
        return ut(t)[1] === "ng-container";
      }
      function Br2(t) {
        return ut(t)[1] === "ng-content";
      }
      function We(t) {
        return t === null ? null : ut(t)[0];
      }
      function ze2(t, e) {
        return t ? `:${t}:${e}` : e;
      }
      var qt2;
      function Lr2() {
        return qt2 || (qt2 = {}, Mt(J.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), Mt(J.STYLE, ["*|style"]), Mt(J.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), Mt(J.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), qt2;
      }
      function Mt(t, e) {
        for (let r of e) qt2[r.toLowerCase()] = t;
      }
      var Ht2 = class {
      };
      var Ha2 = "boolean", Va2 = "number", Ua2 = "string", Wa2 = "object", za2 = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"], ks2 = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" })), Ga2 = Array.from(ks2).reduce((t, [e, r]) => (t.set(e, r), t), /* @__PURE__ */ new Map()), Vt2 = class extends Ht2 {
        constructor() {
          super(), this._schema = /* @__PURE__ */ new Map(), this._eventSchema = /* @__PURE__ */ new Map(), za2.forEach((e) => {
            let r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), [s, i] = e.split("|"), a = i.split(","), [o, u] = s.split("^");
            o.split(",").forEach((l) => {
              this._schema.set(l.toLowerCase(), r), this._eventSchema.set(l.toLowerCase(), n);
            });
            let p = u && this._schema.get(u.toLowerCase());
            if (p) {
              for (let [l, f] of p) r.set(l, f);
              for (let l of this._eventSchema.get(u.toLowerCase())) n.add(l);
            }
            a.forEach((l) => {
              if (l.length > 0) switch (l[0]) {
                case "*":
                  n.add(l.substring(1));
                  break;
                case "!":
                  r.set(l.substring(1), Ha2);
                  break;
                case "#":
                  r.set(l.substring(1), Va2);
                  break;
                case "%":
                  r.set(l.substring(1), Wa2);
                  break;
                default:
                  r.set(l, Ua2);
              }
            });
          });
        }
        hasProperty(e, r, n) {
          if (n.some((i) => i.name === xr.name)) return true;
          if (e.indexOf("-") > -1) {
            if (kr2(e) || Br2(e)) return false;
            if (n.some((i) => i.name === Tr2.name)) return true;
          }
          return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
        }
        hasElement(e, r) {
          return r.some((n) => n.name === xr.name) || e.indexOf("-") > -1 && (kr2(e) || Br2(e) || r.some((n) => n.name === Tr2.name)) ? true : this._schema.has(e.toLowerCase());
        }
        securityContext(e, r, n) {
          n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
          let s = Lr2()[e + "|" + r];
          return s || (s = Lr2()["*|" + r], s || J.NONE);
        }
        getMappedPropName(e) {
          return ks2.get(e) ?? e;
        }
        getDefaultComponentElementName() {
          return "ng-component";
        }
        validateProperty(e) {
          return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
        }
        validateAttribute(e) {
          return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: false };
        }
        allKnownElementNames() {
          return Array.from(this._schema.keys());
        }
        allKnownAttributesOfElement(e) {
          let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
          return Array.from(r.keys()).map((n) => Ga2.get(n) ?? n);
        }
        allKnownEventsOfElement(e) {
          return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
        }
        normalizeAnimationStyleProperty(e) {
          return _s2(e);
        }
        normalizeAnimationStyleValue(e, r, n) {
          let s = "", i = n.toString().trim(), a = null;
          if (Ya2(e) && n !== 0 && n !== "0") if (typeof n == "number") s = "px";
          else {
            let o = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
            o && o[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${n}`);
          }
          return { error: a, value: i + s };
        }
      };
      function Ya2(t) {
        switch (t) {
          case "width":
          case "height":
          case "minWidth":
          case "minHeight":
          case "maxWidth":
          case "maxHeight":
          case "left":
          case "top":
          case "bottom":
          case "right":
          case "fontSize":
          case "outlineWidth":
          case "outlineOffset":
          case "paddingTop":
          case "paddingLeft":
          case "paddingBottom":
          case "paddingRight":
          case "marginTop":
          case "marginLeft":
          case "marginBottom":
          case "marginRight":
          case "borderRadius":
          case "borderWidth":
          case "borderTopWidth":
          case "borderLeftWidth":
          case "borderRightWidth":
          case "borderBottomWidth":
          case "textIndent":
            return true;
          default:
            return false;
        }
      }
      var m = class {
        constructor({ closedByChildren: e, implicitNamespacePrefix: r, contentType: n = I.PARSABLE_DATA, closedByParent: s = false, isVoid: i = false, ignoreFirstLf: a = false, preventNamespaceInheritance: o = false, canSelfClose: u = false } = {}) {
          this.closedByChildren = {}, this.closedByParent = false, e && e.length > 0 && e.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i, this.closedByParent = s || i, this.implicitNamespacePrefix = r || null, this.contentType = n, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o, this.canSelfClose = u ?? i;
        }
        isClosedByChild(e) {
          return this.isVoid || e.toLowerCase() in this.closedByChildren;
        }
        getContentType(e) {
          return typeof this.contentType == "object" ? (e === void 0 ? void 0 : this.contentType[e]) ?? this.contentType.default : this.contentType;
        }
      }, Bs2, lt;
      function Ge(t) {
        return lt || (Bs2 = new m({ canSelfClose: true }), lt = Object.assign(/* @__PURE__ */ Object.create(null), { base: new m({ isVoid: true }), meta: new m({ isVoid: true }), area: new m({ isVoid: true }), embed: new m({ isVoid: true }), link: new m({ isVoid: true }), img: new m({ isVoid: true }), input: new m({ isVoid: true }), param: new m({ isVoid: true }), hr: new m({ isVoid: true }), br: new m({ isVoid: true }), source: new m({ isVoid: true }), track: new m({ isVoid: true }), wbr: new m({ isVoid: true }), p: new m({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new m({ closedByChildren: ["tbody", "tfoot"] }), tbody: new m({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new m({ closedByChildren: ["tbody"], closedByParent: true }), tr: new m({ closedByChildren: ["tr"], closedByParent: true }), td: new m({ closedByChildren: ["td", "th"], closedByParent: true }), th: new m({ closedByChildren: ["td", "th"], closedByParent: true }), col: new m({ isVoid: true }), svg: new m({ implicitNamespacePrefix: "svg" }), foreignObject: new m({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new m({ implicitNamespacePrefix: "math" }), li: new m({ closedByChildren: ["li"], closedByParent: true }), dt: new m({ closedByChildren: ["dt", "dd"] }), dd: new m({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new m({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new m({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new m({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new m({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new m({ closedByChildren: ["optgroup"], closedByParent: true }), option: new m({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new m({ ignoreFirstLf: true }), listing: new m({ ignoreFirstLf: true }), style: new m({ contentType: I.RAW_TEXT }), script: new m({ contentType: I.RAW_TEXT }), title: new m({ contentType: { default: I.ESCAPABLE_RAW_TEXT, svg: I.PARSABLE_DATA } }), textarea: new m({ contentType: I.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Vt2().allKnownElementNames().forEach((e) => {
          !lt[e] && We(e) === null && (lt[e] = new m({ canSelfClose: false }));
        })), lt[t] ?? Bs2;
      }
      var oe = class {
        constructor(e, r) {
          this.sourceSpan = e, this.i18n = r;
        }
      }, Ut = class extends oe {
        constructor(e, r, n, s) {
          super(r, s), this.value = e, this.tokens = n, this.type = "text";
        }
        visit(e, r) {
          return e.visitText(this, r);
        }
      }, Wt = class extends oe {
        constructor(e, r, n, s) {
          super(r, s), this.value = e, this.tokens = n, this.type = "cdata";
        }
        visit(e, r) {
          return e.visitCdata(this, r);
        }
      }, zt = class extends oe {
        constructor(e, r, n, s, i, a) {
          super(s, a), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = i;
        }
        visit(e, r) {
          return e.visitExpansion(this, r);
        }
      }, Gt3 = class {
        constructor(e, r, n, s, i) {
          this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = s, this.expSourceSpan = i, this.type = "expansionCase";
        }
        visit(e, r) {
          return e.visitExpansionCase(this, r);
        }
      }, Yt = class extends oe {
        constructor(e, r, n, s, i, a, o) {
          super(n, o), this.name = e, this.value = r, this.keySpan = s, this.valueSpan = i, this.valueTokens = a, this.type = "attribute";
        }
        visit(e, r) {
          return e.visitAttribute(this, r);
        }
        get nameSpan() {
          return this.keySpan;
        }
      }, G = class extends oe {
        constructor(e, r, n, s, i, a = null, o = null, u) {
          super(s, u), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = i, this.endSourceSpan = a, this.nameSpan = o, this.type = "element";
        }
        visit(e, r) {
          return e.visitElement(this, r);
        }
      }, jt = class {
        constructor(e, r) {
          this.value = e, this.sourceSpan = r, this.type = "comment";
        }
        visit(e, r) {
          return e.visitComment(this, r);
        }
      }, Kt2 = class {
        constructor(e, r) {
          this.value = e, this.sourceSpan = r, this.type = "docType";
        }
        visit(e, r) {
          return e.visitDocType(this, r);
        }
      }, Z = class extends oe {
        constructor(e, r, n, s, i, a, o = null, u) {
          super(s, u), this.name = e, this.parameters = r, this.children = n, this.nameSpan = i, this.startSourceSpan = a, this.endSourceSpan = o, this.type = "block";
        }
        visit(e, r) {
          return e.visitBlock(this, r);
        }
      }, ct = class {
        constructor(e, r) {
          this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
        }
        visit(e, r) {
          return e.visitBlockParameter(this, r);
        }
      }, pt2 = class {
        constructor(e, r, n, s, i) {
          this.name = e, this.value = r, this.sourceSpan = n, this.nameSpan = s, this.valueSpan = i, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
        }
        visit(e, r) {
          return e.visitLetDeclaration(this, r);
        }
      };
      function Qt2(t, e, r = null) {
        let n = [], s = t.visit ? (i) => t.visit(i, r) || i.visit(t, r) : (i) => i.visit(t, r);
        return e.forEach((i) => {
          let a = s(i);
          a && n.push(a);
        }), n;
      }
      var ht2 = class {
        constructor() {
        }
        visitElement(e, r) {
          this.visitChildren(r, (n) => {
            n(e.attrs), n(e.children);
          });
        }
        visitAttribute(e, r) {
        }
        visitText(e, r) {
        }
        visitCdata(e, r) {
        }
        visitComment(e, r) {
        }
        visitDocType(e, r) {
        }
        visitExpansion(e, r) {
          return this.visitChildren(r, (n) => {
            n(e.cases);
          });
        }
        visitExpansionCase(e, r) {
        }
        visitBlock(e, r) {
          this.visitChildren(r, (n) => {
            n(e.parameters), n(e.children);
          });
        }
        visitBlockParameter(e, r) {
        }
        visitLetDeclaration(e, r) {
        }
        visitChildren(e, r) {
          let n = [], s = this;
          function i(a) {
            a && n.push(Qt2(s, a, e));
          }
          return r(i), Array.prototype.concat.apply([], n);
        }
      };
      var Ye3 = { AElig: "", AMP: "&", amp: "&", Aacute: "", Abreve: "", Acirc: "", Acy: "", Afr: "", Agrave: "", Alpha: "", Amacr: "", And: "", Aogon: "", Aopf: "", ApplyFunction: "", af: "", Aring: "", angst: "", Ascr: "", Assign: "", colone: "", coloneq: "", Atilde: "", Auml: "", Backslash: "", setminus: "", setmn: "", smallsetminus: "", ssetmn: "", Barv: "", Barwed: "", doublebarwedge: "", Bcy: "", Because: "", becaus: "", because: "", Bernoullis: "", Bscr: "", bernou: "", Beta: "", Bfr: "", Bopf: "", Breve: "", breve: "", Bumpeq: "", HumpDownHump: "", bump: "", CHcy: "", COPY: "", copy: "", Cacute: "", Cap: "", CapitalDifferentialD: "", DD: "", Cayleys: "", Cfr: "", Ccaron: "", Ccedil: "", Ccirc: "", Cconint: "", Cdot: "", Cedilla: "", cedil: "", CenterDot: "", centerdot: "", middot: "", Chi: "", CircleDot: "", odot: "", CircleMinus: "", ominus: "", CirclePlus: "", oplus: "", CircleTimes: "", otimes: "", ClockwiseContourIntegral: "", cwconint: "", CloseCurlyDoubleQuote: "", rdquo: "", rdquor: "", CloseCurlyQuote: "", rsquo: "", rsquor: "", Colon: "", Proportion: "", Colone: "", Congruent: "", equiv: "", Conint: "", DoubleContourIntegral: "", ContourIntegral: "", conint: "", oint: "", Copf: "", complexes: "", Coproduct: "", coprod: "", CounterClockwiseContourIntegral: "", awconint: "", Cross: "", Cscr: "", Cup: "", CupCap: "", asympeq: "", DDotrahd: "", DJcy: "", DScy: "", DZcy: "", Dagger: "", ddagger: "", Darr: "", Dashv: "", DoubleLeftTee: "", Dcaron: "", Dcy: "", Del: "", nabla: "", Delta: "", Dfr: "", DiacriticalAcute: "", acute: "", DiacriticalDot: "", dot: "", DiacriticalDoubleAcute: "", dblac: "", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "", tilde: "", Diamond: "", diam: "", diamond: "", DifferentialD: "", dd: "", Dopf: "", Dot: "", DoubleDot: "", die: "", uml: "", DotDot: "", DotEqual: "", doteq: "", esdot: "", DoubleDownArrow: "", Downarrow: "", dArr: "", DoubleLeftArrow: "", Leftarrow: "", lArr: "", DoubleLeftRightArrow: "", Leftrightarrow: "", hArr: "", iff: "", DoubleLongLeftArrow: "", Longleftarrow: "", xlArr: "", DoubleLongLeftRightArrow: "", Longleftrightarrow: "", xhArr: "", DoubleLongRightArrow: "", Longrightarrow: "", xrArr: "", DoubleRightArrow: "", Implies: "", Rightarrow: "", rArr: "", DoubleRightTee: "", vDash: "", DoubleUpArrow: "", Uparrow: "", uArr: "", DoubleUpDownArrow: "", Updownarrow: "", vArr: "", DoubleVerticalBar: "", par: "", parallel: "", shortparallel: "", spar: "", DownArrow: "", ShortDownArrow: "", darr: "", downarrow: "", DownArrowBar: "", DownArrowUpArrow: "", duarr: "", DownBreve: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", leftharpoondown: "", lhard: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", rhard: "", rightharpoondown: "", DownRightVectorBar: "", DownTee: "", top: "", DownTeeArrow: "", mapstodown: "", Dscr: "", Dstrok: "", ENG: "", ETH: "", Eacute: "", Ecaron: "", Ecirc: "", Ecy: "", Edot: "", Efr: "", Egrave: "", Element: "", in: "", isin: "", isinv: "", Emacr: "", EmptySmallSquare: "", EmptyVerySmallSquare: "", Eogon: "", Eopf: "", Epsilon: "", Equal: "", EqualTilde: "", eqsim: "", esim: "", Equilibrium: "", rightleftharpoons: "", rlhar: "", Escr: "", expectation: "", Esim: "", Eta: "", Euml: "", Exists: "", exist: "", ExponentialE: "", ee: "", exponentiale: "", Fcy: "", Ffr: "", FilledSmallSquare: "", FilledVerySmallSquare: "", blacksquare: "", squarf: "", squf: "", Fopf: "", ForAll: "", forall: "", Fouriertrf: "", Fscr: "", GJcy: "", GT: ">", gt: ">", Gamma: "", Gammad: "", Gbreve: "", Gcedil: "", Gcirc: "", Gcy: "", Gdot: "", Gfr: "", Gg: "", ggg: "", Gopf: "", GreaterEqual: "", ge: "", geq: "", GreaterEqualLess: "", gel: "", gtreqless: "", GreaterFullEqual: "", gE: "", geqq: "", GreaterGreater: "", GreaterLess: "", gl: "", gtrless: "", GreaterSlantEqual: "", geqslant: "", ges: "", GreaterTilde: "", gsim: "", gtrsim: "", Gscr: "", Gt: "", NestedGreaterGreater: "", gg: "", HARDcy: "", Hacek: "", caron: "", Hat: "^", Hcirc: "", Hfr: "", Poincareplane: "", HilbertSpace: "", Hscr: "", hamilt: "", Hopf: "", quaternions: "", HorizontalLine: "", boxh: "", Hstrok: "", HumpEqual: "", bumpe: "", bumpeq: "", IEcy: "", IJlig: "", IOcy: "", Iacute: "", Icirc: "", Icy: "", Idot: "", Ifr: "", Im: "", image: "", imagpart: "", Igrave: "", Imacr: "", ImaginaryI: "", ii: "", Int: "", Integral: "", int: "", Intersection: "", bigcap: "", xcap: "", InvisibleComma: "", ic: "", InvisibleTimes: "", it: "", Iogon: "", Iopf: "", Iota: "", Iscr: "", imagline: "", Itilde: "", Iukcy: "", Iuml: "", Jcirc: "", Jcy: "", Jfr: "", Jopf: "", Jscr: "", Jsercy: "", Jukcy: "", KHcy: "", KJcy: "", Kappa: "", Kcedil: "", Kcy: "", Kfr: "", Kopf: "", Kscr: "", LJcy: "", LT: "<", lt: "<", Lacute: "", Lambda: "", Lang: "", Laplacetrf: "", Lscr: "", lagran: "", Larr: "", twoheadleftarrow: "", Lcaron: "", Lcedil: "", Lcy: "", LeftAngleBracket: "", lang: "", langle: "", LeftArrow: "", ShortLeftArrow: "", larr: "", leftarrow: "", slarr: "", LeftArrowBar: "", larrb: "", LeftArrowRightArrow: "", leftrightarrows: "", lrarr: "", LeftCeiling: "", lceil: "", LeftDoubleBracket: "", lobrk: "", LeftDownTeeVector: "", LeftDownVector: "", dharl: "", downharpoonleft: "", LeftDownVectorBar: "", LeftFloor: "", lfloor: "", LeftRightArrow: "", harr: "", leftrightarrow: "", LeftRightVector: "", LeftTee: "", dashv: "", LeftTeeArrow: "", mapstoleft: "", LeftTeeVector: "", LeftTriangle: "", vartriangleleft: "", vltri: "", LeftTriangleBar: "", LeftTriangleEqual: "", ltrie: "", trianglelefteq: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", uharl: "", upharpoonleft: "", LeftUpVectorBar: "", LeftVector: "", leftharpoonup: "", lharu: "", LeftVectorBar: "", LessEqualGreater: "", leg: "", lesseqgtr: "", LessFullEqual: "", lE: "", leqq: "", LessGreater: "", lessgtr: "", lg: "", LessLess: "", LessSlantEqual: "", leqslant: "", les: "", LessTilde: "", lesssim: "", lsim: "", Lfr: "", Ll: "", Lleftarrow: "", lAarr: "", Lmidot: "", LongLeftArrow: "", longleftarrow: "", xlarr: "", LongLeftRightArrow: "", longleftrightarrow: "", xharr: "", LongRightArrow: "", longrightarrow: "", xrarr: "", Lopf: "", LowerLeftArrow: "", swarr: "", swarrow: "", LowerRightArrow: "", searr: "", searrow: "", Lsh: "", lsh: "", Lstrok: "", Lt: "", NestedLessLess: "", ll: "", Map: "", Mcy: "", MediumSpace: "", Mellintrf: "", Mscr: "", phmmat: "", Mfr: "", MinusPlus: "", mnplus: "", mp: "", Mopf: "", Mu: "", NJcy: "", Nacute: "", Ncaron: "", Ncedil: "", Ncy: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", ZeroWidthSpace: "", NewLine: `
`, Nfr: "", NoBreak: "", NonBreakingSpace: "", nbsp: "", Nopf: "", naturals: "", Not: "", NotCongruent: "", nequiv: "", NotCupCap: "", NotDoubleVerticalBar: "", npar: "", nparallel: "", nshortparallel: "", nspar: "", NotElement: "", notin: "", notinva: "", NotEqual: "", ne: "", NotEqualTilde: "", nesim: "", NotExists: "", nexist: "", nexists: "", NotGreater: "", ngt: "", ngtr: "", NotGreaterEqual: "", nge: "", ngeq: "", NotGreaterFullEqual: "", ngE: "", ngeqq: "", NotGreaterGreater: "", nGtv: "", NotGreaterLess: "", ntgl: "", NotGreaterSlantEqual: "", ngeqslant: "", nges: "", NotGreaterTilde: "", ngsim: "", NotHumpDownHump: "", nbump: "", NotHumpEqual: "", nbumpe: "", NotLeftTriangle: "", nltri: "", ntriangleleft: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", nltrie: "", ntrianglelefteq: "", NotLess: "", nless: "", nlt: "", NotLessEqual: "", nle: "", nleq: "", NotLessGreater: "", ntlg: "", NotLessLess: "", nLtv: "", NotLessSlantEqual: "", nleqslant: "", nles: "", NotLessTilde: "", nlsim: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", NotPrecedes: "", npr: "", nprec: "", NotPrecedesEqual: "", npre: "", npreceq: "", NotPrecedesSlantEqual: "", nprcue: "", NotReverseElement: "", notni: "", notniva: "", NotRightTriangle: "", nrtri: "", ntriangleright: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", nrtrie: "", ntrianglerighteq: "", NotSquareSubset: "", NotSquareSubsetEqual: "", nsqsube: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", nsqsupe: "", NotSubset: "", nsubset: "", vnsub: "", NotSubsetEqual: "", nsube: "", nsubseteq: "", NotSucceeds: "", nsc: "", nsucc: "", NotSucceedsEqual: "", nsce: "", nsucceq: "", NotSucceedsSlantEqual: "", nsccue: "", NotSucceedsTilde: "", NotSuperset: "", nsupset: "", vnsup: "", NotSupersetEqual: "", nsupe: "", nsupseteq: "", NotTilde: "", nsim: "", NotTildeEqual: "", nsime: "", nsimeq: "", NotTildeFullEqual: "", ncong: "", NotTildeTilde: "", nap: "", napprox: "", NotVerticalBar: "", nmid: "", nshortmid: "", nsmid: "", Nscr: "", Ntilde: "", Nu: "", OElig: "", Oacute: "", Ocirc: "", Ocy: "", Odblac: "", Ofr: "", Ograve: "", Omacr: "", Omega: "", ohm: "", Omicron: "", Oopf: "", OpenCurlyDoubleQuote: "", ldquo: "", OpenCurlyQuote: "", lsquo: "", Or: "", Oscr: "", Oslash: "", Otilde: "", Otimes: "", Ouml: "", OverBar: "", oline: "", OverBrace: "", OverBracket: "", tbrk: "", OverParenthesis: "", PartialD: "", part: "", Pcy: "", Pfr: "", Phi: "", Pi: "", PlusMinus: "", plusmn: "", pm: "", Popf: "", primes: "", Pr: "", Precedes: "", pr: "", prec: "", PrecedesEqual: "", pre: "", preceq: "", PrecedesSlantEqual: "", prcue: "", preccurlyeq: "", PrecedesTilde: "", precsim: "", prsim: "", Prime: "", Product: "", prod: "", Proportional: "", prop: "", propto: "", varpropto: "", vprop: "", Pscr: "", Psi: "", QUOT: '"', quot: '"', Qfr: "", Qopf: "", rationals: "", Qscr: "", RBarr: "", drbkarow: "", REG: "", circledR: "", reg: "", Racute: "", Rang: "", Rarr: "", twoheadrightarrow: "", Rarrtl: "", Rcaron: "", Rcedil: "", Rcy: "", Re: "", Rfr: "", real: "", realpart: "", ReverseElement: "", SuchThat: "", ni: "", niv: "", ReverseEquilibrium: "", leftrightharpoons: "", lrhar: "", ReverseUpEquilibrium: "", duhar: "", Rho: "", RightAngleBracket: "", rang: "", rangle: "", RightArrow: "", ShortRightArrow: "", rarr: "", rightarrow: "", srarr: "", RightArrowBar: "", rarrb: "", RightArrowLeftArrow: "", rightleftarrows: "", rlarr: "", RightCeiling: "", rceil: "", RightDoubleBracket: "", robrk: "", RightDownTeeVector: "", RightDownVector: "", dharr: "", downharpoonright: "", RightDownVectorBar: "", RightFloor: "", rfloor: "", RightTee: "", vdash: "", RightTeeArrow: "", map: "", mapsto: "", RightTeeVector: "", RightTriangle: "", vartriangleright: "", vrtri: "", RightTriangleBar: "", RightTriangleEqual: "", rtrie: "", trianglerighteq: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", uharr: "", upharpoonright: "", RightUpVectorBar: "", RightVector: "", rharu: "", rightharpoonup: "", RightVectorBar: "", Ropf: "", reals: "", RoundImplies: "", Rrightarrow: "", rAarr: "", Rscr: "", realine: "", Rsh: "", rsh: "", RuleDelayed: "", SHCHcy: "", SHcy: "", SOFTcy: "", Sacute: "", Sc: "", Scaron: "", Scedil: "", Scirc: "", Scy: "", Sfr: "", ShortUpArrow: "", UpArrow: "", uarr: "", uparrow: "", Sigma: "", SmallCircle: "", compfn: "", Sopf: "", Sqrt: "", radic: "", Square: "", squ: "", square: "", SquareIntersection: "", sqcap: "", SquareSubset: "", sqsub: "", sqsubset: "", SquareSubsetEqual: "", sqsube: "", sqsubseteq: "", SquareSuperset: "", sqsup: "", sqsupset: "", SquareSupersetEqual: "", sqsupe: "", sqsupseteq: "", SquareUnion: "", sqcup: "", Sscr: "", Star: "", sstarf: "", Sub: "", Subset: "", SubsetEqual: "", sube: "", subseteq: "", Succeeds: "", sc: "", succ: "", SucceedsEqual: "", sce: "", succeq: "", SucceedsSlantEqual: "", sccue: "", succcurlyeq: "", SucceedsTilde: "", scsim: "", succsim: "", Sum: "", sum: "", Sup: "", Supset: "", Superset: "", sup: "", supset: "", SupersetEqual: "", supe: "", supseteq: "", THORN: "", TRADE: "", trade: "", TSHcy: "", TScy: "", Tab: "	", Tau: "", Tcaron: "", Tcedil: "", Tcy: "", Tfr: "", Therefore: "", there4: "", therefore: "", Theta: "", ThickSpace: "", ThinSpace: "", thinsp: "", Tilde: "", sim: "", thicksim: "", thksim: "", TildeEqual: "", sime: "", simeq: "", TildeFullEqual: "", cong: "", TildeTilde: "", ap: "", approx: "", asymp: "", thickapprox: "", thkap: "", Topf: "", TripleDot: "", tdot: "", Tscr: "", Tstrok: "", Uacute: "", Uarr: "", Uarrocir: "", Ubrcy: "", Ubreve: "", Ucirc: "", Ucy: "", Udblac: "", Ufr: "", Ugrave: "", Umacr: "", UnderBar: "_", lowbar: "_", UnderBrace: "", UnderBracket: "", bbrk: "", UnderParenthesis: "", Union: "", bigcup: "", xcup: "", UnionPlus: "", uplus: "", Uogon: "", Uopf: "", UpArrowBar: "", UpArrowDownArrow: "", udarr: "", UpDownArrow: "", updownarrow: "", varr: "", UpEquilibrium: "", udhar: "", UpTee: "", bot: "", bottom: "", perp: "", UpTeeArrow: "", mapstoup: "", UpperLeftArrow: "", nwarr: "", nwarrow: "", UpperRightArrow: "", nearr: "", nearrow: "", Upsi: "", upsih: "", Upsilon: "", Uring: "", Uscr: "", Utilde: "", Uuml: "", VDash: "", Vbar: "", Vcy: "", Vdash: "", Vdashl: "", Vee: "", bigvee: "", xvee: "", Verbar: "", Vert: "", VerticalBar: "", mid: "", shortmid: "", smid: "", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "", VerticalTilde: "", wr: "", wreath: "", VeryThinSpace: "", hairsp: "", Vfr: "", Vopf: "", Vscr: "", Vvdash: "", Wcirc: "", Wedge: "", bigwedge: "", xwedge: "", Wfr: "", Wopf: "", Wscr: "", Xfr: "", Xi: "", Xopf: "", Xscr: "", YAcy: "", YIcy: "", YUcy: "", Yacute: "", Ycirc: "", Ycy: "", Yfr: "", Yopf: "", Yscr: "", Yuml: "", ZHcy: "", Zacute: "", Zcaron: "", Zcy: "", Zdot: "", Zeta: "", Zfr: "", zeetrf: "", Zopf: "", integers: "", Zscr: "", aacute: "", abreve: "", ac: "", mstpos: "", acE: "", acd: "", acirc: "", acy: "", aelig: "", afr: "", agrave: "", alefsym: "", aleph: "", alpha: "", amacr: "", amalg: "", and: "", wedge: "", andand: "", andd: "", andslope: "", andv: "", ang: "", angle: "", ange: "", angmsd: "", measuredangle: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angzarr: "", aogon: "", aopf: "", apE: "", apacir: "", ape: "", approxeq: "", apid: "", apos: "'", aring: "", ascr: "", ast: "*", midast: "*", atilde: "", auml: "", awint: "", bNot: "", backcong: "", bcong: "", backepsilon: "", bepsi: "", backprime: "", bprime: "", backsim: "", bsim: "", backsimeq: "", bsime: "", barvee: "", barwed: "", barwedge: "", bbrktbrk: "", bcy: "", bdquo: "", ldquor: "", bemptyv: "", beta: "", beth: "", between: "", twixt: "", bfr: "", bigcirc: "", xcirc: "", bigodot: "", xodot: "", bigoplus: "", xoplus: "", bigotimes: "", xotime: "", bigsqcup: "", xsqcup: "", bigstar: "", starf: "", bigtriangledown: "", xdtri: "", bigtriangleup: "", xutri: "", biguplus: "", xuplus: "", bkarow: "", rbarr: "", blacklozenge: "", lozf: "", blacktriangle: "", utrif: "", blacktriangledown: "", dtrif: "", blacktriangleleft: "", ltrif: "", blacktriangleright: "", rtrif: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bopf: "", bowtie: "", boxDL: "", boxDR: "", boxDl: "", boxDr: "", boxH: "", boxHD: "", boxHU: "", boxHd: "", boxHu: "", boxUL: "", boxUR: "", boxUl: "", boxUr: "", boxV: "", boxVH: "", boxVL: "", boxVR: "", boxVh: "", boxVl: "", boxVr: "", boxbox: "", boxdL: "", boxdR: "", boxdl: "", boxdr: "", boxhD: "", boxhU: "", boxhd: "", boxhu: "", boxminus: "", minusb: "", boxplus: "", plusb: "", boxtimes: "", timesb: "", boxuL: "", boxuR: "", boxul: "", boxur: "", boxv: "", boxvH: "", boxvL: "", boxvR: "", boxvh: "", boxvl: "", boxvr: "", brvbar: "", bscr: "", bsemi: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bumpE: "", cacute: "", cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", caps: "", caret: "", ccaps: "", ccaron: "", ccedil: "", ccirc: "", ccups: "", ccupssm: "", cdot: "", cemptyv: "", cent: "", cfr: "", chcy: "", check: "", checkmark: "", chi: "", cir: "", cirE: "", circ: "", circeq: "", cire: "", circlearrowleft: "", olarr: "", circlearrowright: "", orarr: "", circledS: "", oS: "", circledast: "", oast: "", circledcirc: "", ocir: "", circleddash: "", odash: "", cirfnint: "", cirmid: "", cirscir: "", clubs: "", clubsuit: "", colon: ":", comma: ",", commat: "@", comp: "", complement: "", congdot: "", copf: "", copysr: "", crarr: "", cross: "", cscr: "", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", curlyeqprec: "", cuesc: "", curlyeqsucc: "", cularr: "", curvearrowleft: "", cularrp: "", cup: "", cupbrcap: "", cupcap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curvearrowright: "", curarrm: "", curlyvee: "", cuvee: "", curlywedge: "", cuwed: "", curren: "", cwint: "", cylcty: "", dHar: "", dagger: "", daleth: "", dash: "", hyphen: "", dbkarow: "", rBarr: "", dcaron: "", dcy: "", ddarr: "", downdownarrows: "", ddotseq: "", eDDot: "", deg: "", delta: "", demptyv: "", dfisht: "", dfr: "", diamondsuit: "", diams: "", digamma: "", gammad: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", dlcorn: "", llcorner: "", dlcrop: "", dollar: "$", dopf: "", doteqdot: "", eDot: "", dotminus: "", minusd: "", dotplus: "", plusdo: "", dotsquare: "", sdotb: "", drcorn: "", lrcorner: "", drcrop: "", dscr: "", dscy: "", dsol: "", dstrok: "", dtdot: "", dtri: "", triangledown: "", dwangle: "", dzcy: "", dzigrarr: "", eacute: "", easter: "", ecaron: "", ecir: "", eqcirc: "", ecirc: "", ecolon: "", eqcolon: "", ecy: "", edot: "", efDot: "", fallingdotseq: "", efr: "", eg: "", egrave: "", egs: "", eqslantgtr: "", egsdot: "", el: "", elinters: "", ell: "", els: "", eqslantless: "", elsdot: "", emacr: "", empty: "", emptyset: "", emptyv: "", varnothing: "", emsp13: "", emsp14: "", emsp: "", eng: "", ensp: "", eogon: "", eopf: "", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", epsiv: "", straightepsilon: "", varepsilon: "", equals: "=", equest: "", questeq: "", equivDD: "", eqvparsl: "", erDot: "", risingdotseq: "", erarr: "", escr: "", eta: "", eth: "", euml: "", euro: "", excl: "!", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "", filig: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "", fork: "", pitchfork: "", forkv: "", fpartint: "", frac12: "", half: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", sfrown: "", fscr: "", gEl: "", gtreqqless: "", gacute: "", gamma: "", gap: "", gtrapprox: "", gbreve: "", gcirc: "", gcy: "", gdot: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "", gimel: "", gjcy: "", glE: "", gla: "", glj: "", gnE: "", gneqq: "", gnap: "", gnapprox: "", gne: "", gneq: "", gnsim: "", gopf: "", gscr: "", gsime: "", gsiml: "", gtcc: "", gtcir: "", gtdot: "", gtrdot: "", gtlPar: "", gtquest: "", gtrarr: "", gvertneqq: "", gvnE: "", hardcy: "", harrcir: "", harrw: "", leftrightsquigarrow: "", hbar: "", hslash: "", planck: "", plankv: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", mldr: "", hercon: "", hfr: "", hksearow: "", searhk: "", hkswarow: "", swarhk: "", hoarr: "", homtht: "", hookleftarrow: "", larrhk: "", hookrightarrow: "", rarrhk: "", hopf: "", horbar: "", hscr: "", hstrok: "", hybull: "", iacute: "", icirc: "", icy: "", iecy: "", iexcl: "", ifr: "", igrave: "", iiiint: "", qint: "", iiint: "", tint: "", iinfin: "", iiota: "", ijlig: "", imacr: "", imath: "", inodot: "", imof: "", imped: "", incare: "", infin: "", infintie: "", intcal: "", intercal: "", intlarhk: "", intprod: "", iprod: "", iocy: "", iogon: "", iopf: "", iota: "", iquest: "", iscr: "", isinE: "", isindot: "", isins: "", isinsv: "", itilde: "", iukcy: "", iuml: "", jcirc: "", jcy: "", jfr: "", jmath: "", jopf: "", jscr: "", jsercy: "", jukcy: "", kappa: "", kappav: "", varkappa: "", kcedil: "", kcy: "", kfr: "", kgreen: "", khcy: "", kjcy: "", kopf: "", kscr: "", lAtail: "", lBarr: "", lEg: "", lesseqqgtr: "", lHar: "", lacute: "", laemptyv: "", lambda: "", langd: "", lap: "", lessapprox: "", laquo: "", larrbfs: "", larrfs: "", larrlp: "", looparrowleft: "", larrpl: "", larrsim: "", larrtl: "", leftarrowtail: "", lat: "", latail: "", late: "", lates: "", lbarr: "", lbbrk: "", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", lcedil: "", lcy: "", ldca: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", leq: "", leftleftarrows: "", llarr: "", leftthreetimes: "", lthree: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessdot: "", ltdot: "", lfisht: "", lfr: "", lgE: "", lharul: "", lhblk: "", ljcy: "", llhard: "", lltri: "", lmidot: "", lmoust: "", lmoustache: "", lnE: "", lneqq: "", lnap: "", lnapprox: "", lne: "", lneq: "", lnsim: "", loang: "", loarr: "", longmapsto: "", xmap: "", looparrowright: "", rarrlp: "", lopar: "", lopf: "", loplus: "", lotimes: "", lowast: "", loz: "", lozenge: "", lpar: "(", lparlt: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "", lsime: "", lsimg: "", lsquor: "", sbquo: "", lstrok: "", ltcc: "", ltcir: "", ltimes: "", ltlarr: "", ltquest: "", ltrPar: "", ltri: "", triangleleft: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", mDDot: "", macr: "", strns: "", male: "", malt: "", maltese: "", marker: "", mcomma: "", mcy: "", mdash: "", mfr: "", mho: "", micro: "", midcir: "", minus: "", minusdu: "", mlcp: "", models: "", mopf: "", mscr: "", mu: "", multimap: "", mumap: "", nGg: "", nGt: "", nLeftarrow: "", nlArr: "", nLeftrightarrow: "", nhArr: "", nLl: "", nLt: "", nRightarrow: "", nrArr: "", nVDash: "", nVdash: "", nacute: "", nang: "", napE: "", napid: "", napos: "", natur: "", natural: "", ncap: "", ncaron: "", ncedil: "", ncongdot: "", ncup: "", ncy: "", ndash: "", neArr: "", nearhk: "", nedot: "", nesear: "", toea: "", nfr: "", nharr: "", nleftrightarrow: "", nhpar: "", nis: "", nisd: "", njcy: "", nlE: "", nleqq: "", nlarr: "", nleftarrow: "", nldr: "", nopf: "", not: "", notinE: "", notindot: "", notinvb: "", notinvc: "", notnivb: "", notnivc: "", nparsl: "", npart: "", npolint: "", nrarr: "", nrightarrow: "", nrarrc: "", nrarrw: "", nscr: "", nsub: "", nsubE: "", nsubseteqq: "", nsup: "", nsupE: "", nsupseteqq: "", ntilde: "", nu: "", num: "#", numero: "", numsp: "", nvDash: "", nvHarr: "", nvap: "", nvdash: "", nvge: "", nvgt: ">", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwArr: "", nwarhk: "", nwnear: "", oacute: "", ocirc: "", ocy: "", odblac: "", odiv: "", odsold: "", oelig: "", ofcir: "", ofr: "", ogon: "", ograve: "", ogt: "", ohbar: "", olcir: "", olcross: "", olt: "", omacr: "", omega: "", omicron: "", omid: "", oopf: "", opar: "", operp: "", or: "", vee: "", ord: "", order: "", orderof: "", oscr: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oslash: "", osol: "", otilde: "", otimesas: "", ouml: "", ovbar: "", para: "", parsim: "", parsl: "", pcy: "", percnt: "%", period: ".", permil: "", pertenk: "", pfr: "", phi: "", phiv: "", straightphi: "", varphi: "", phone: "", pi: "", piv: "", varpi: "", planckh: "", plus: "+", plusacir: "", pluscir: "", plusdu: "", pluse: "", plussim: "", plustwo: "", pointint: "", popf: "", pound: "", prE: "", prap: "", precapprox: "", precnapprox: "", prnap: "", precneqq: "", prnE: "", precnsim: "", prnsim: "", prime: "", profalar: "", profline: "", profsurf: "", prurel: "", pscr: "", psi: "", puncsp: "", qfr: "", qopf: "", qprime: "", qscr: "", quatint: "", quest: "?", rAtail: "", rHar: "", race: "", racute: "", raemptyv: "", rangd: "", range: "", raquo: "", rarrap: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrpl: "", rarrsim: "", rarrtl: "", rightarrowtail: "", rarrw: "", rightsquigarrow: "", ratail: "", ratio: "", rbbrk: "", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", rcedil: "", rcy: "", rdca: "", rdldhar: "", rdsh: "", rect: "", rfisht: "", rfr: "", rharul: "", rho: "", rhov: "", varrho: "", rightrightarrows: "", rrarr: "", rightthreetimes: "", rthree: "", ring: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", ropar: "", ropf: "", roplus: "", rotimes: "", rpar: ")", rpargt: "", rppolint: "", rsaquo: "", rscr: "", rtimes: "", rtri: "", triangleright: "", rtriltri: "", ruluhar: "", rx: "", sacute: "", scE: "", scap: "", succapprox: "", scaron: "", scedil: "", scirc: "", scnE: "", succneqq: "", scnap: "", succnapprox: "", scnsim: "", succnsim: "", scpolint: "", scy: "", sdot: "", sdote: "", seArr: "", sect: "", semi: ";", seswar: "", tosa: "", sext: "", sfr: "", sharp: "", shchcy: "", shcy: "", shy: "", sigma: "", sigmaf: "", sigmav: "", varsigma: "", simdot: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", smashp: "", smeparsl: "", smile: "", ssmile: "", smt: "", smte: "", smtes: "", softcy: "", sol: "/", solb: "", solbar: "", sopf: "", spades: "", spadesuit: "", sqcaps: "", sqcups: "", sscr: "", star: "", sub: "", subset: "", subE: "", subseteqq: "", subdot: "", subedot: "", submult: "", subnE: "", subsetneqq: "", subne: "", subsetneq: "", subplus: "", subrarr: "", subsim: "", subsub: "", subsup: "", sung: "", sup1: "", sup2: "", sup3: "", supE: "", supseteqq: "", supdot: "", supdsub: "", supedot: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supsetneqq: "", supne: "", supsetneq: "", supplus: "", supsim: "", supsub: "", supsup: "", swArr: "", swnwar: "", szlig: "", target: "", tau: "", tcaron: "", tcedil: "", tcy: "", telrec: "", tfr: "", theta: "", thetasym: "", thetav: "", vartheta: "", thorn: "", times: "", timesbar: "", timesd: "", topbot: "", topcir: "", topf: "", topfork: "", tprime: "", triangle: "", utri: "", triangleq: "", trie: "", tridot: "", triminus: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "", tscy: "", tshcy: "", tstrok: "", uHar: "", uacute: "", ubrcy: "", ubreve: "", ucirc: "", ucy: "", udblac: "", ufisht: "", ufr: "", ugrave: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", uogon: "", uopf: "", upsi: "", upsilon: "", upuparrows: "", uuarr: "", urcorn: "", urcorner: "", urcrop: "", uring: "", urtri: "", uscr: "", utdot: "", utilde: "", uuml: "", uwangle: "", vBar: "", vBarv: "", vangrt: "", varsubsetneq: "", vsubne: "", varsubsetneqq: "", vsubnE: "", varsupsetneq: "", vsupne: "", varsupsetneqq: "", vsupnE: "", vcy: "", veebar: "", veeeq: "", vellip: "", vfr: "", vopf: "", vscr: "", vzigzag: "", wcirc: "", wedbar: "", wedgeq: "", weierp: "", wp: "", wfr: "", wopf: "", wscr: "", xfr: "", xi: "", xnis: "", xopf: "", xscr: "", yacute: "", yacy: "", ycirc: "", ycy: "", yen: "", yfr: "", yicy: "", yopf: "", yscr: "", yucy: "", yuml: "", zacute: "", zcaron: "", zcy: "", zdot: "", zeta: "", zfr: "", zhcy: "", zigrarr: "", zopf: "", zscr: "", zwj: "", zwnj: "" }, Ka = "";
      Ye3.ngsp = Ka;
      var Qa2 = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
      function Ls2(t, e) {
        if (e != null && !(Array.isArray(e) && e.length == 2)) throw new Error(`Expected '${t}' to be an array, [start, end].`);
        if (e != null) {
          let r = e[0], n = e[1];
          Qa2.forEach((s) => {
            if (s.test(r) || s.test(n)) throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
          });
        }
      }
      var Fr2 = class t {
        static fromArray(e) {
          return e ? (Ls2("interpolation", e), new t(e[0], e[1])) : Nr2;
        }
        constructor(e, r) {
          this.start = e, this.end = r;
        }
      }, Nr2 = new Fr2("{{", "}}");
      var ft2 = class extends Ue {
        constructor(e, r, n) {
          super(n, e), this.tokenType = r;
        }
      }, Or2 = class {
        constructor(e, r, n) {
          this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = n;
        }
      };
      function Ws2(t, e, r, n = {}) {
        let s = new Mr2(new Te2(t, e), r, n);
        return s.tokenize(), new Or2(vo2(s.tokens), s.errors, s.nonNormalizedIcuExpressions);
      }
      var go2 = /\r\n?/g;
      function je(t) {
        return `Unexpected character "${t === 0 ? "EOF" : String.fromCharCode(t)}"`;
      }
      function Rs2(t) {
        return `Unknown entity "${t}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
      }
      function Co2(t, e) {
        return `Unable to parse entity "${e}" - ${t} character reference entities must end with ";"`;
      }
      var tr2;
      (function(t) {
        t.HEX = "hexadecimal", t.DEC = "decimal";
      })(tr2 || (tr2 = {}));
      var dt2 = class {
        constructor(e) {
          this.error = e;
        }
      }, Mr2 = class {
        constructor(e, r, n) {
          this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || false, this._interpolationConfig = n.interpolationConfig || Nr2, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map((i) => i.codePointAt(0) || 0), this._canSelfClose = n.canSelfClose || false, this._allowHtmComponentClosingTags = n.allowHtmComponentClosingTags || false;
          let s = n.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
          this._cursor = n.escapedString ? new qr2(e, s) : new rr2(e, s), this._preserveLineEndings = n.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = n.tokenizeBlocks ?? true, this._tokenizeLet = n.tokenizeLet ?? true;
          try {
            this._cursor.init();
          } catch (i) {
            this.handleError(i);
          }
        }
        _processCarriageReturns(e) {
          return this._preserveLineEndings ? e : e.replace(go2, `
`);
        }
        tokenize() {
          for (; this._cursor.peek() !== 0; ) {
            let e = this._cursor.clone();
            try {
              if (this._attemptCharCode(60)) if (this._attemptCharCode(33)) this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
              else if (this._attemptCharCode(47)) this._consumeTagClose(e);
              else {
                let r = this._cursor.clone();
                this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
              }
              else this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
            } catch (r) {
              this.handleError(r);
            }
          }
          this._beginToken(34), this._endToken([]);
        }
        _getBlockName() {
          let e = false, r = this._cursor.clone();
          return this._attemptCharCodeUntilFn((n) => at2(n) ? !e : Ms2(n) ? (e = true, false) : true), this._cursor.getChars(r).trim();
        }
        _consumeBlockStart(e) {
          this._beginToken(25, e);
          let r = this._endToken([this._getBlockName()]);
          if (this._cursor.peek() === 40) if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b), this._attemptCharCode(41)) this._attemptCharCodeUntilFn(b);
          else {
            r.type = 29;
            return;
          }
          this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
        }
        _consumeBlockEnd(e) {
          this._beginToken(27, e), this._endToken([]);
        }
        _consumeBlockParameters() {
          for (this._attemptCharCodeUntilFn(qs2); this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
            this._beginToken(28);
            let e = this._cursor.clone(), r = null, n = 0;
            for (; this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
              let s = this._cursor.peek();
              if (s === 92) this._cursor.advance();
              else if (s === r) r = null;
              else if (r === null && $t(s)) r = s;
              else if (s === 40 && r === null) n++;
              else if (s === 41 && r === null) {
                if (n === 0) break;
                n > 0 && n--;
              }
              this._cursor.advance();
            }
            this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(qs2);
          }
        }
        _consumeLetDeclaration(e) {
          if (this._beginToken(30, e), at2(this._cursor.peek())) this._attemptCharCodeUntilFn(b);
          else {
            let s = this._endToken([this._cursor.getChars(e)]);
            s.type = 33;
            return;
          }
          let r = this._endToken([this._getLetDeclarationName()]);
          if (this._attemptCharCodeUntilFn(b), !this._attemptCharCode(61)) {
            r.type = 33;
            return;
          }
          this._attemptCharCodeUntilFn((s) => b(s) && !Rt(s)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r.type = 33, r.sourceSpan = this._cursor.getSpan(e));
        }
        _getLetDeclarationName() {
          let e = this._cursor.clone(), r = false;
          return this._attemptCharCodeUntilFn((n) => ot(n) || n == 36 || n === 95 || r && It2(n) ? (r = true, false) : true), this._cursor.getChars(e).trim();
        }
        _consumeLetDeclarationValue() {
          let e = this._cursor.clone();
          for (this._beginToken(31, e); this._cursor.peek() !== 0; ) {
            let r = this._cursor.peek();
            if (r === 59) break;
            $t(r) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n) => n === 92 ? (this._cursor.advance(), false) : n === r)), this._cursor.advance();
          }
          this._endToken([this._cursor.getChars(e)]);
        }
        _tokenizeExpansionForm() {
          if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), true;
          if (Ao3(this._cursor.peek()) && this._isInExpansionForm()) return this._consumeExpansionCaseStart(), true;
          if (this._cursor.peek() === 125) {
            if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), true;
            if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), true;
          }
          return false;
        }
        _beginToken(e, r = this._cursor.clone()) {
          this._currentTokenStart = r, this._currentTokenType = e;
        }
        _endToken(e, r) {
          if (this._currentTokenStart === null) throw new ft2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
          if (this._currentTokenType === null) throw new ft2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
          let n = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
          return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n;
        }
        _createError(e, r) {
          this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
          let n = new ft2(e, this._currentTokenType, r);
          return this._currentTokenStart = null, this._currentTokenType = null, new dt2(n);
        }
        handleError(e) {
          if (e instanceof gt2 && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof dt2) this.errors.push(e.error);
          else throw e;
        }
        _attemptCharCode(e) {
          return this._cursor.peek() === e ? (this._cursor.advance(), true) : false;
        }
        _attemptCharCodeCaseInsensitive(e) {
          return Do2(this._cursor.peek(), e) ? (this._cursor.advance(), true) : false;
        }
        _requireCharCode(e) {
          let r = this._cursor.clone();
          if (!this._attemptCharCode(e)) throw this._createError(je(this._cursor.peek()), this._cursor.getSpan(r));
        }
        _attemptStr(e) {
          let r = e.length;
          if (this._cursor.charsLeft() < r) return false;
          let n = this._cursor.clone();
          for (let s = 0; s < r; s++) if (!this._attemptCharCode(e.charCodeAt(s))) return this._cursor = n, false;
          return true;
        }
        _attemptStrCaseInsensitive(e) {
          for (let r = 0; r < e.length; r++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r))) return false;
          return true;
        }
        _requireStr(e) {
          let r = this._cursor.clone();
          if (!this._attemptStr(e)) throw this._createError(je(this._cursor.peek()), this._cursor.getSpan(r));
        }
        _requireStrCaseInsensitive(e) {
          let r = this._cursor.clone();
          if (!this._attemptStrCaseInsensitive(e)) throw this._createError(je(this._cursor.peek()), this._cursor.getSpan(r));
        }
        _attemptCharCodeUntilFn(e) {
          for (; !e(this._cursor.peek()); ) this._cursor.advance();
        }
        _requireCharCodeUntilFn(e, r) {
          let n = this._cursor.clone();
          if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < r) throw this._createError(je(this._cursor.peek()), this._cursor.getSpan(n));
        }
        _attemptUntilChar(e) {
          for (; this._cursor.peek() !== e; ) this._cursor.advance();
        }
        _readChar() {
          let e = String.fromCodePoint(this._cursor.peek());
          return this._cursor.advance(), e;
        }
        _consumeEntity(e) {
          this._beginToken(9);
          let r = this._cursor.clone();
          if (this._cursor.advance(), this._attemptCharCode(35)) {
            let n = this._attemptCharCode(120) || this._attemptCharCode(88), s = this._cursor.clone();
            if (this._attemptCharCodeUntilFn(_o2), this._cursor.peek() != 59) {
              this._cursor.advance();
              let a = n ? tr2.HEX : tr2.DEC;
              throw this._createError(Co2(a, this._cursor.getChars(r)), this._cursor.getSpan());
            }
            let i = this._cursor.getChars(s);
            this._cursor.advance();
            try {
              let a = parseInt(i, n ? 16 : 10);
              this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
            } catch {
              throw this._createError(Rs2(this._cursor.getChars(r)), this._cursor.getSpan());
            }
          } else {
            let n = this._cursor.clone();
            if (this._attemptCharCodeUntilFn(Eo2), this._cursor.peek() != 59) this._beginToken(e, r), this._cursor = n, this._endToken(["&"]);
            else {
              let s = this._cursor.getChars(n);
              this._cursor.advance();
              let i = Ye3[s];
              if (!i) throw this._createError(Rs2(s), this._cursor.getSpan(r));
              this._endToken([i, `&${s};`]);
            }
          }
        }
        _consumeRawText(e, r) {
          this._beginToken(e ? 6 : 7);
          let n = [];
          for (; ; ) {
            let s = this._cursor.clone(), i = r();
            if (this._cursor = s, i) break;
            e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(6), this._beginToken(6)) : n.push(this._readChar());
          }
          this._endToken([this._processCarriageReturns(n.join(""))]);
        }
        _consumeComment(e) {
          this._beginToken(10, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
        }
        _consumeBogusComment(e) {
          this._beginToken(10, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
        }
        _consumeCdata(e) {
          this._beginToken(12, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
        }
        _consumeDocType(e) {
          this._beginToken(18, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
        }
        _consumePrefixAndName() {
          let e = this._cursor.clone(), r = "";
          for (; this._cursor.peek() !== 58 && !So2(this._cursor.peek()); ) this._cursor.advance();
          let n;
          this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), n = this._cursor.clone()) : n = e, this._requireCharCodeUntilFn($s2, r === "" ? 0 : 1);
          let s = this._cursor.getChars(n);
          return [r, s];
        }
        _consumeTagOpen(e) {
          let r, n, s, i = [];
          try {
            if (!ot(this._cursor.peek())) throw this._createError(je(this._cursor.peek()), this._cursor.getSpan(e));
            for (s = this._consumeTagOpenStart(e), n = s.parts[0], r = s.parts[1], this._attemptCharCodeUntilFn(b); this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
              let [o, u] = this._consumeAttributeName();
              if (this._attemptCharCodeUntilFn(b), this._attemptCharCode(61)) {
                this._attemptCharCodeUntilFn(b);
                let p = this._consumeAttributeValue();
                i.push({ prefix: o, name: u, value: p });
              } else i.push({ prefix: o, name: u });
              this._attemptCharCodeUntilFn(b);
            }
            this._consumeTagOpenEnd();
          } catch (o) {
            if (o instanceof dt2) {
              s ? s.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
              return;
            }
            throw o;
          }
          if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2) return;
          let a = this._getTagContentType(r, n, this._fullNameStack.length > 0, i);
          this._handleFullNameStackForTagOpen(n, r), a === I.RAW_TEXT ? this._consumeRawTextWithTagClose(n, r, false) : a === I.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, r, true);
        }
        _consumeRawTextWithTagClose(e, r, n) {
          this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? false : (this._attemptCharCodeUntilFn(b), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s) => s === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
        }
        _consumeTagOpenStart(e) {
          this._beginToken(0, e);
          let r = this._consumePrefixAndName();
          return this._endToken(r);
        }
        _consumeAttributeName() {
          let e = this._cursor.peek();
          if (e === 39 || e === 34) throw this._createError(je(e), this._cursor.getSpan());
          this._beginToken(14);
          let r = this._consumePrefixAndName();
          return this._endToken(r), r;
        }
        _consumeAttributeValue() {
          let e;
          if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
            let r = this._cursor.peek();
            this._consumeQuote(r);
            let n = () => this._cursor.peek() === r;
            e = this._consumeWithInterpolation(16, 17, n, n), this._consumeQuote(r);
          } else {
            let r = () => $s2(this._cursor.peek());
            e = this._consumeWithInterpolation(16, 17, r, r);
          }
          return e;
        }
        _consumeQuote(e) {
          this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
        }
        _consumeTagOpenEnd() {
          let e = this._attemptCharCode(47) ? 2 : 1;
          this._beginToken(e), this._requireCharCode(62), this._endToken([]);
        }
        _consumeTagClose(e) {
          if (this._beginToken(3, e), this._attemptCharCodeUntilFn(b), this._allowHtmComponentClosingTags && this._attemptCharCode(47)) this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([]);
          else {
            let [r, n] = this._consumePrefixAndName();
            this._attemptCharCodeUntilFn(b), this._requireCharCode(62), this._endToken([r, n]), this._handleFullNameStackForTagClose(r, n);
          }
        }
        _consumeExpansionFormStart() {
          this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
          let e = this._readUntil(44), r = this._processCarriageReturns(e);
          if (this._i18nNormalizeLineEndingsInICUs) this._endToken([r]);
          else {
            let s = this._endToken([e]);
            r !== e && this.nonNormalizedIcuExpressions.push(s);
          }
          this._requireCharCode(44), this._attemptCharCodeUntilFn(b), this._beginToken(7);
          let n = this._readUntil(44);
          this._endToken([n]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b);
        }
        _consumeExpansionCaseStart() {
          this._beginToken(21);
          let e = this._readUntil(123).trim();
          this._endToken([e]), this._attemptCharCodeUntilFn(b), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.push(22);
        }
        _consumeExpansionCaseEnd() {
          this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b), this._expansionCaseStack.pop();
        }
        _consumeExpansionFormEnd() {
          this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
        }
        _consumeWithInterpolation(e, r, n, s) {
          this._beginToken(e);
          let i = [];
          for (; !n(); ) {
            let o = this._cursor.clone();
            this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i.join(""))], o), i.length = 0, this._consumeInterpolation(r, o, s), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i.join(""))]), i.length = 0, this._consumeEntity(e), this._beginToken(e)) : i.push(this._readChar());
          }
          this._inInterpolation = false;
          let a = this._processCarriageReturns(i.join(""));
          return this._endToken([a]), a;
        }
        _consumeInterpolation(e, r, n) {
          let s = [];
          this._beginToken(e, r), s.push(this._interpolationConfig.start);
          let i = this._cursor.clone(), a = null, o = false;
          for (; this._cursor.peek() !== 0 && (n === null || !n()); ) {
            let u = this._cursor.clone();
            if (this._isTagStart()) {
              this._cursor = u, s.push(this._getProcessedChars(i, u)), this._endToken(s);
              return;
            }
            if (a === null) if (this._attemptStr(this._interpolationConfig.end)) {
              s.push(this._getProcessedChars(i, u)), s.push(this._interpolationConfig.end), this._endToken(s);
              return;
            } else this._attemptStr("//") && (o = true);
            let p = this._cursor.peek();
            this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o && a === null && $t(p) && (a = p);
          }
          s.push(this._getProcessedChars(i, this._cursor)), this._endToken(s);
        }
        _getProcessedChars(e, r) {
          return this._processCarriageReturns(r.getChars(e));
        }
        _isTextEnd() {
          return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
        }
        _isTagStart() {
          if (this._cursor.peek() === 60) {
            let e = this._cursor.clone();
            e.advance();
            let r = e.peek();
            if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33) return true;
          }
          return false;
        }
        _isBlockStart() {
          if (this._tokenizeBlocks && this._cursor.peek() === 64) {
            let e = this._cursor.clone();
            if (e.advance(), Ms2(e.peek())) return true;
          }
          return false;
        }
        _readUntil(e) {
          let r = this._cursor.clone();
          return this._attemptUntilChar(e), this._cursor.getChars(r);
        }
        _isInExpansion() {
          return this._isInExpansionCase() || this._isInExpansionForm();
        }
        _isInExpansionCase() {
          return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
        }
        _isInExpansionForm() {
          return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
        }
        isExpansionFormStart() {
          if (this._cursor.peek() !== 123) return false;
          if (this._interpolationConfig) {
            let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
            return this._cursor = e, !r;
          }
          return true;
        }
        _handleFullNameStackForTagOpen(e, r) {
          let n = ze2(e, r);
          (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n) && this._fullNameStack.push(n);
        }
        _handleFullNameStackForTagClose(e, r) {
          let n = ze2(e, r);
          this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n && this._fullNameStack.pop();
        }
      };
      function b(t) {
        return !at2(t) || t === 0;
      }
      function $s2(t) {
        return at2(t) || t === 62 || t === 60 || t === 47 || t === 39 || t === 34 || t === 61 || t === 0;
      }
      function So2(t) {
        return (t < 97 || 122 < t) && (t < 65 || 90 < t) && (t < 48 || t > 57);
      }
      function _o2(t) {
        return t === 59 || t === 0 || !Cs2(t);
      }
      function Eo2(t) {
        return t === 59 || t === 0 || !ot(t);
      }
      function Ao3(t) {
        return t !== 125;
      }
      function Do2(t, e) {
        return Os2(t) === Os2(e);
      }
      function Os2(t) {
        return t >= 97 && t <= 122 ? t - 97 + 65 : t;
      }
      function Ms2(t) {
        return ot(t) || It2(t) || t === 95;
      }
      function qs2(t) {
        return t !== 59 && b(t);
      }
      function vo2(t) {
        let e = [], r;
        for (let n = 0; n < t.length; n++) {
          let s = t[n];
          r && r.type === 5 && s.type === 5 || r && r.type === 16 && s.type === 16 ? (r.parts[0] += s.parts[0], r.sourceSpan.end = s.sourceSpan.end) : (r = s, e.push(r));
        }
        return e;
      }
      var rr2 = class t {
        constructor(e, r) {
          if (e instanceof t) {
            this.file = e.file, this.input = e.input, this.end = e.end;
            let n = e.state;
            this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
          } else {
            if (!r) throw new Error("Programming error: the range argument must be provided with a file argument.");
            this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
          }
        }
        clone() {
          return new t(this);
        }
        peek() {
          return this.state.peek;
        }
        charsLeft() {
          return this.end - this.state.offset;
        }
        diff(e) {
          return this.state.offset - e.state.offset;
        }
        advance() {
          this.advanceState(this.state);
        }
        init() {
          this.updatePeek(this.state);
        }
        getSpan(e, r) {
          e = e || this;
          let n = e;
          if (r) for (; this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; ) n === e && (e = e.clone()), e.advance();
          let s = this.locationFromCursor(e), i = this.locationFromCursor(this), a = n !== e ? this.locationFromCursor(n) : s;
          return new h(s, i, a);
        }
        getChars(e) {
          return this.input.substring(e.state.offset, this.state.offset);
        }
        charAt(e) {
          return this.input.charCodeAt(e);
        }
        advanceState(e) {
          if (e.offset >= this.end) throw this.state = e, new gt2('Unexpected character "EOF"', this);
          let r = this.charAt(e.offset);
          r === 10 ? (e.line++, e.column = 0) : Rt(r) || e.column++, e.offset++, this.updatePeek(e);
        }
        updatePeek(e) {
          e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
        }
        locationFromCursor(e) {
          return new ae(e.file, e.state.offset, e.state.line, e.state.column);
        }
      }, qr2 = class t extends rr2 {
        constructor(e, r) {
          e instanceof t ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
        }
        advance() {
          this.state = this.internalState, super.advance(), this.processEscapeSequence();
        }
        init() {
          super.init(), this.processEscapeSequence();
        }
        clone() {
          return new t(this);
        }
        getChars(e) {
          let r = e.clone(), n = "";
          for (; r.internalState.offset < this.internalState.offset; ) n += String.fromCodePoint(r.peek()), r.advance();
          return n;
        }
        processEscapeSequence() {
          let e = () => this.internalState.peek;
          if (e() === 92) if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110) this.state.peek = 10;
          else if (e() === 114) this.state.peek = 13;
          else if (e() === 118) this.state.peek = 11;
          else if (e() === 116) this.state.peek = 9;
          else if (e() === 98) this.state.peek = 8;
          else if (e() === 102) this.state.peek = 12;
          else if (e() === 117) if (this.advanceState(this.internalState), e() === 123) {
            this.advanceState(this.internalState);
            let r = this.clone(), n = 0;
            for (; e() !== 125; ) this.advanceState(this.internalState), n++;
            this.state.peek = this.decodeHexDigits(r, n);
          } else {
            let r = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
          }
          else if (e() === 120) {
            this.advanceState(this.internalState);
            let r = this.clone();
            this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
          } else if (wr2(e())) {
            let r = "", n = 0, s = this.clone();
            for (; wr2(e()) && n < 3; ) s = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
            this.state.peek = parseInt(r, 8), this.internalState = s.internalState;
          } else Rt(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
        }
        decodeHexDigits(e, r) {
          let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), s = parseInt(n, 16);
          if (isNaN(s)) throw e.state = e.internalState, new gt2("Invalid hexadecimal escape sequence", e);
          return s;
        }
      }, gt2 = class {
        constructor(e, r) {
          this.msg = e, this.cursor = r;
        }
      };
      var L = class t extends Ue {
        static create(e, r, n) {
          return new t(e, r, n);
        }
        constructor(e, r, n) {
          super(r, n), this.elementName = e;
        }
      }, Ur2 = class {
        constructor(e, r) {
          this.rootNodes = e, this.errors = r;
        }
      }, nr2 = class {
        constructor(e) {
          this.getTagDefinition = e;
        }
        parse(e, r, n, s = false, i) {
          let a = (D) => (R, ...F) => D(R.toLowerCase(), ...F), o = s ? this.getTagDefinition : a(this.getTagDefinition), u = (D) => o(D).getContentType(), p = s ? i : a(i), f = Ws2(e, r, i ? (D, R, F, c) => {
            let g = p(D, R, F, c);
            return g !== void 0 ? g : u(D);
          } : u, n), d2 = n && n.canSelfClose || false, C = n && n.allowHtmComponentClosingTags || false, A = new Wr2(f.tokens, o, d2, C, s);
          return A.build(), new Ur2(A.rootNodes, f.errors.concat(A.errors));
        }
      }, Wr2 = class t {
        constructor(e, r, n, s, i) {
          this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = s, this.isTagNameCaseSensitive = i, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
        }
        build() {
          for (; this._peek.type !== 34; ) this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
          for (let e of this._containerStack) e instanceof Z && this.errors.push(L.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
        }
        _advance() {
          let e = this._peek;
          return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
        }
        _advanceIf(e) {
          return this._peek.type === e ? this._advance() : null;
        }
        _consumeCdata(e) {
          let r = this._advance(), n = this._getText(r), s = this._advanceIf(13);
          this._addToParent(new Wt(n, new h(e.sourceSpan.start, (s || r).sourceSpan.end), [r]));
        }
        _consumeComment(e) {
          let r = this._advanceIf(7), n = this._advanceIf(11), s = r != null ? r.parts[0].trim() : null, i = n == null ? e.sourceSpan : new h(e.sourceSpan.start, n.sourceSpan.end, e.sourceSpan.fullStart);
          this._addToParent(new jt(s, i));
        }
        _consumeDocType(e) {
          let r = this._advanceIf(7), n = this._advanceIf(19), s = r != null ? r.parts[0].trim() : null, i = new h(e.sourceSpan.start, (n || r || e).sourceSpan.end);
          this._addToParent(new Kt2(s, i));
        }
        _consumeExpansion(e) {
          let r = this._advance(), n = this._advance(), s = [];
          for (; this._peek.type === 21; ) {
            let a = this._parseExpansionCase();
            if (!a) return;
            s.push(a);
          }
          if (this._peek.type !== 24) {
            this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
            return;
          }
          let i = new h(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
          this._addToParent(new zt(r.parts[0], n.parts[0], s, i, r.sourceSpan)), this._advance();
        }
        _parseExpansionCase() {
          let e = this._advance();
          if (this._peek.type !== 22) return this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
          let r = this._advance(), n = this._collectExpansionExpTokens(r);
          if (!n) return null;
          let s = this._advance();
          n.push({ type: 34, parts: [], sourceSpan: s.sourceSpan });
          let i = new t(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
          if (i.build(), i.errors.length > 0) return this.errors = this.errors.concat(i.errors), null;
          let a = new h(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart), o = new h(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
          return new Gt3(e.parts[0], i.rootNodes, a, e.sourceSpan, o);
        }
        _collectExpansionExpTokens(e) {
          let r = [], n = [22];
          for (; ; ) {
            if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23) if (zs2(n, 22)) {
              if (n.pop(), n.length === 0) return r;
            } else return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
            if (this._peek.type === 24) if (zs2(n, 20)) n.pop();
            else return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
            if (this._peek.type === 34) return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
            r.push(this._advance());
          }
        }
        _getText(e) {
          let r = e.parts[0];
          if (r.length > 0 && r[0] == `
`) {
            let n = this._getClosestParentElement();
            n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
          }
          return r;
        }
        _consumeText(e) {
          let r = [e], n = e.sourceSpan, s = e.parts[0];
          if (s.length > 0 && s[0] === `
`) {
            let i = this._getContainer();
            i != null && i.children.length === 0 && this.getTagDefinition(i.name).ignoreFirstLf && (s = s.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [s] });
          }
          for (; this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; ) e = this._advance(), r.push(e), e.type === 8 ? s += e.parts.join("").replace(/&([^;]+);/g, Gs) : e.type === 9 ? s += e.parts[0] : s += e.parts.join("");
          if (s.length > 0) {
            let i = e.sourceSpan;
            this._addToParent(new Ut(s, new h(n.start, i.end, n.fullStart, n.details), r));
          }
        }
        _closeVoidElement() {
          let e = this._getContainer();
          e instanceof G && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
        }
        _consumeStartTag(e) {
          let [r, n] = e.parts, s = [];
          for (; this._peek.type === 14; ) s.push(this._consumeAttr(this._advance()));
          let i = this._getElementFullName(r, n, this._getClosestParentElement()), a = false;
          if (this._peek.type === 2) {
            this._advance(), a = true;
            let C = this.getTagDefinition(i);
            this.canSelfClose || C.canSelfClose || We(i) !== null || C.isVoid || this.errors.push(L.create(i, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
          } else this._peek.type === 1 && (this._advance(), a = false);
          let o = this._peek.sourceSpan.fullStart, u = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), p = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), l = new h(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), f = new G(i, s, [], u, p, void 0, l), d2 = this._getContainer();
          this._pushContainer(f, d2 instanceof G && this.getTagDefinition(d2.name).isClosedByChild(f.name)), a ? this._popContainer(i, G, u) : e.type === 4 && (this._popContainer(i, G, null), this.errors.push(L.create(i, u, `Opening tag "${i}" not terminated.`)));
        }
        _pushContainer(e, r) {
          r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
        }
        _consumeEndTag(e) {
          let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
          if (r && this.getTagDefinition(r).isVoid) this.errors.push(L.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
          else if (!this._popContainer(r, G, e.sourceSpan)) {
            let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
            this.errors.push(L.create(r, e.sourceSpan, n));
          }
        }
        _popContainer(e, r, n) {
          let s = false;
          for (let i = this._containerStack.length - 1; i >= 0; i--) {
            let a = this._containerStack[i];
            if (We(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r) return a.endSourceSpan = n, a.sourceSpan.end = n !== null ? n.end : a.sourceSpan.end, this._containerStack.splice(i, this._containerStack.length - i), !s;
            (a instanceof Z || a instanceof G && !this.getTagDefinition(a.name).closedByParent) && (s = true);
          }
          return false;
        }
        _consumeAttr(e) {
          let r = ze2(e.parts[0], e.parts[1]), n = e.sourceSpan.end, s;
          this._peek.type === 15 && (s = this._advance());
          let i = "", a = [], o, u;
          if (this._peek.type === 16) for (o = this._peek.sourceSpan, u = this._peek.sourceSpan.end; this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
            let f = this._advance();
            a.push(f), f.type === 17 ? i += f.parts.join("").replace(/&([^;]+);/g, Gs) : f.type === 9 ? i += f.parts[0] : i += f.parts.join(""), u = n = f.sourceSpan.end;
          }
          this._peek.type === 15 && (u = n = this._advance().sourceSpan.end);
          let l = o && u && new h((s == null ? void 0 : s.sourceSpan.start) ?? o.start, u, (s == null ? void 0 : s.sourceSpan.fullStart) ?? o.fullStart);
          return new Yt(r, i, new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, l, a.length > 0 ? a : void 0, void 0);
        }
        _consumeBlockOpen(e) {
          let r = [];
          for (; this._peek.type === 28; ) {
            let o = this._advance();
            r.push(new ct(o.parts[0], o.sourceSpan));
          }
          this._peek.type === 26 && this._advance();
          let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new Z(e.parts[0], r, [], s, e.sourceSpan, i);
          this._pushContainer(a, false);
        }
        _consumeBlockClose(e) {
          this._popContainer(null, Z, e.sourceSpan) || this.errors.push(L.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
        }
        _consumeIncompleteBlock(e) {
          let r = [];
          for (; this._peek.type === 28; ) {
            let o = this._advance();
            r.push(new ct(o.parts[0], o.sourceSpan));
          }
          let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new Z(e.parts[0], r, [], s, e.sourceSpan, i);
          this._pushContainer(a, false), this._popContainer(null, Z, null), this.errors.push(L.create(e.parts[0], s, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
        }
        _consumeLet(e) {
          let r = e.parts[0], n, s;
          if (this._peek.type !== 31) {
            this.errors.push(L.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${r}". Declaration must have a value.`));
            return;
          } else n = this._advance();
          if (this._peek.type !== 32) {
            this.errors.push(L.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));
            return;
          } else s = this._advance();
          let i = s.sourceSpan.fullStart, a = new h(e.sourceSpan.start, i, e.sourceSpan.fullStart), o = e.sourceSpan.toString().lastIndexOf(r), u = e.sourceSpan.start.moveBy(o), p = new h(u, e.sourceSpan.end), l = new pt2(r, n.parts[0], a, p, n.sourceSpan);
          this._addToParent(l);
        }
        _consumeIncompleteLet(e) {
          let r = e.parts[0] ?? "", n = r ? ` "${r}"` : "";
          if (r.length > 0) {
            let s = e.sourceSpan.toString().lastIndexOf(r), i = e.sourceSpan.start.moveBy(s), a = new h(i, e.sourceSpan.end), o = new h(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)), u = new pt2(r, "", e.sourceSpan, a, o);
            this._addToParent(u);
          }
          this.errors.push(L.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${n}. @let declarations must be written as \`@let <name> = <value>;\``));
        }
        _getContainer() {
          return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
        }
        _getClosestParentElement() {
          for (let e = this._containerStack.length - 1; e > -1; e--) if (this._containerStack[e] instanceof G) return this._containerStack[e];
          return null;
        }
        _addToParent(e) {
          let r = this._getContainer();
          r === null ? this.rootNodes.push(e) : r.children.push(e);
        }
        _getElementFullName(e, r, n) {
          if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
            let s = ut(n.name)[1];
            this.getTagDefinition(s).preventNamespaceInheritance || (e = We(n.name));
          }
          return ze2(e, r);
        }
      };
      function zs2(t, e) {
        return t.length > 0 && t[t.length - 1] === e;
      }
      function Gs(t, e) {
        return Ye3[e] !== void 0 ? Ye3[e] || t : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t;
      }
      var sr2 = class extends nr2 {
        constructor() {
          super(Ge);
        }
        parse(e, r, n, s = false, i) {
          return super.parse(e, r, n, s, i);
        }
      };
      var zr2 = null, yo2 = () => (zr2 || (zr2 = new sr2()), zr2);
      function Gr2(t, e = {}) {
        let { canSelfClose: r = false, allowHtmComponentClosingTags: n = false, isTagNameCaseSensitive: s = false, getTagContentType: i, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o = false } = e;
        return yo2().parse(t, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a, tokenizeLet: o }, s, i);
      }
      function wo2(t, e) {
        let r = new SyntaxError(t + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
        return Object.assign(r, e);
      }
      var Ys2 = wo2;
      var Ct2 = 3;
      function bo2(t) {
        let e = t.slice(0, Ct2);
        if (e !== "---" && e !== "+++") return;
        let r = t.indexOf(`
`, Ct2);
        if (r === -1) return;
        let n = t.slice(Ct2, r).trim(), s = t.indexOf(`
${e}`, r), i = n;
        if (i || (i = e === "+++" ? "toml" : "yaml"), s === -1 && e === "---" && i === "yaml" && (s = t.indexOf(`
...`, r)), s === -1) return;
        let a = s + 1 + Ct2, o = t.charAt(a + 1);
        if (!/\s?/u.test(o)) return;
        let u = t.slice(0, a);
        return { type: "front-matter", language: i, explicitLanguage: n, value: t.slice(r + 1, s), startDelimiter: e, endDelimiter: u.slice(-Ct2), raw: u };
      }
      function To(t) {
        let e = bo2(t);
        if (!e) return { content: t };
        let { raw: r } = e;
        return { frontMatter: e, content: w(false, r, /[^\n]/gu, " ") + t.slice(r.length) };
      }
      var js2 = To;
      var ir2 = { attrs: true, children: true, cases: true, expression: true }, Ks2 = /* @__PURE__ */ new Set(["parent"]), ar2 = class t {
        constructor(e = {}) {
          for (let r of /* @__PURE__ */ new Set([...Ks2, ...Object.keys(e)])) this.setProperty(r, e[r]);
        }
        setProperty(e, r) {
          if (this[e] !== r) {
            if (e in ir2 && (r = r.map((n) => this.createChild(n))), !Ks2.has(e)) {
              this[e] = r;
              return;
            }
            Object.defineProperty(this, e, { value: r, enumerable: false, configurable: true });
          }
        }
        map(e) {
          let r;
          for (let n in ir2) {
            let s = this[n];
            if (s) {
              let i = xo2(s, (a) => a.map(e));
              r !== s && (r || (r = new t({ parent: this.parent })), r.setProperty(n, i));
            }
          }
          if (r) for (let n in this) n in ir2 || (r[n] = this[n]);
          return e(r || this);
        }
        walk(e) {
          for (let r in ir2) {
            let n = this[r];
            if (n) for (let s = 0; s < n.length; s++) n[s].walk(e);
          }
          e(this);
        }
        createChild(e) {
          let r = e instanceof t ? e.clone() : new t(e);
          return r.setProperty("parent", this), r;
        }
        insertChildBefore(e, r) {
          this.children.splice(this.children.indexOf(e), 0, this.createChild(r));
        }
        removeChild(e) {
          this.children.splice(this.children.indexOf(e), 1);
        }
        replaceChild(e, r) {
          this.children[this.children.indexOf(e)] = this.createChild(r);
        }
        clone() {
          return new t(this);
        }
        get firstChild() {
          var e;
          return (e = this.children) == null ? void 0 : e[0];
        }
        get lastChild() {
          var e;
          return (e = this.children) == null ? void 0 : e[this.children.length - 1];
        }
        get prev() {
          var e, r;
          return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) - 1];
        }
        get next() {
          var e, r;
          return (r = (e = this.parent) == null ? void 0 : e.children) == null ? void 0 : r[this.parent.children.indexOf(this) + 1];
        }
        get rawName() {
          return this.hasExplicitNamespace ? this.fullName : this.name;
        }
        get fullName() {
          return this.namespace ? this.namespace + ":" + this.name : this.name;
        }
        get attrMap() {
          return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
        }
      };
      function xo2(t, e) {
        let r = t.map(e);
        return r.some((n, s) => n !== t[s]) ? r : t;
      }
      var ko2 = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: Bo2 }, { regex: /^\[if([^\]]*)\]><!$/u, parse: Lo2 }, { regex: /^<!\s*\[endif\]$/u, parse: Fo2 }];
      function Qs(t, e) {
        if (t.value) for (let { regex: r, parse: n } of ko2) {
          let s = t.value.match(r);
          if (s) return n(t, e, s);
        }
        return null;
      }
      function Bo2(t, e, r) {
        let [, n, s, i] = r, a = 4 + n.length, o = t.sourceSpan.start.moveBy(a), u = o.moveBy(i.length), [p, l] = (() => {
          try {
            return [true, e(i, o).children];
          } catch {
            return [false, [{ type: "text", value: i, sourceSpan: new h(o, u) }]];
          }
        })();
        return { type: "ieConditionalComment", complete: p, children: l, condition: w(false, s.trim(), /\s+/gu, " "), sourceSpan: t.sourceSpan, startSourceSpan: new h(t.sourceSpan.start, o), endSourceSpan: new h(u, t.sourceSpan.end) };
      }
      function Lo2(t, e, r) {
        let [, n] = r;
        return { type: "ieConditionalStartComment", condition: w(false, n.trim(), /\s+/gu, " "), sourceSpan: t.sourceSpan };
      }
      function Fo2(t) {
        return { type: "ieConditionalEndComment", sourceSpan: t.sourceSpan };
      }
      var or2 = /* @__PURE__ */ new Map([["*", /* @__PURE__ */ new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", /* @__PURE__ */ new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", /* @__PURE__ */ new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", /* @__PURE__ */ new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", /* @__PURE__ */ new Set(["href", "target"])], ["basefont", /* @__PURE__ */ new Set(["color", "face", "size"])], ["blockquote", /* @__PURE__ */ new Set(["cite"])], ["body", /* @__PURE__ */ new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", /* @__PURE__ */ new Set(["clear"])], ["button", /* @__PURE__ */ new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", /* @__PURE__ */ new Set(["height", "width"])], ["caption", /* @__PURE__ */ new Set(["align"])], ["col", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", /* @__PURE__ */ new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", /* @__PURE__ */ new Set(["value"])], ["del", /* @__PURE__ */ new Set(["cite", "datetime"])], ["details", /* @__PURE__ */ new Set(["name", "open"])], ["dialog", /* @__PURE__ */ new Set(["open"])], ["dir", /* @__PURE__ */ new Set(["compact"])], ["div", /* @__PURE__ */ new Set(["align"])], ["dl", /* @__PURE__ */ new Set(["compact"])], ["embed", /* @__PURE__ */ new Set(["height", "src", "type", "width"])], ["fieldset", /* @__PURE__ */ new Set(["disabled", "form", "name"])], ["font", /* @__PURE__ */ new Set(["color", "face", "size"])], ["form", /* @__PURE__ */ new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", /* @__PURE__ */ new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", /* @__PURE__ */ new Set(["cols", "rows"])], ["h1", /* @__PURE__ */ new Set(["align"])], ["h2", /* @__PURE__ */ new Set(["align"])], ["h3", /* @__PURE__ */ new Set(["align"])], ["h4", /* @__PURE__ */ new Set(["align"])], ["h5", /* @__PURE__ */ new Set(["align"])], ["h6", /* @__PURE__ */ new Set(["align"])], ["head", /* @__PURE__ */ new Set(["profile"])], ["hr", /* @__PURE__ */ new Set(["align", "noshade", "size", "width"])], ["html", /* @__PURE__ */ new Set(["manifest", "version"])], ["iframe", /* @__PURE__ */ new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", /* @__PURE__ */ new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", /* @__PURE__ */ new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", /* @__PURE__ */ new Set(["cite", "datetime"])], ["isindex", /* @__PURE__ */ new Set(["prompt"])], ["label", /* @__PURE__ */ new Set(["for", "form"])], ["legend", /* @__PURE__ */ new Set(["align"])], ["li", /* @__PURE__ */ new Set(["type", "value"])], ["link", /* @__PURE__ */ new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", /* @__PURE__ */ new Set(["name"])], ["menu", /* @__PURE__ */ new Set(["compact"])], ["meta", /* @__PURE__ */ new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", /* @__PURE__ */ new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", /* @__PURE__ */ new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", /* @__PURE__ */ new Set(["compact", "reversed", "start", "type"])], ["optgroup", /* @__PURE__ */ new Set(["disabled", "label"])], ["option", /* @__PURE__ */ new Set(["disabled", "label", "selected", "value"])], ["output", /* @__PURE__ */ new Set(["for", "form", "name"])], ["p", /* @__PURE__ */ new Set(["align"])], ["param", /* @__PURE__ */ new Set(["name", "type", "value", "valuetype"])], ["pre", /* @__PURE__ */ new Set(["width"])], ["progress", /* @__PURE__ */ new Set(["max", "value"])], ["q", /* @__PURE__ */ new Set(["cite"])], ["script", /* @__PURE__ */ new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", /* @__PURE__ */ new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", /* @__PURE__ */ new Set(["name"])], ["source", /* @__PURE__ */ new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", /* @__PURE__ */ new Set(["blocking", "media", "type"])], ["table", /* @__PURE__ */ new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["td", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", /* @__PURE__ */ new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", /* @__PURE__ */ new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["th", /* @__PURE__ */ new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", /* @__PURE__ */ new Set(["align", "char", "charoff", "valign"])], ["time", /* @__PURE__ */ new Set(["datetime"])], ["tr", /* @__PURE__ */ new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", /* @__PURE__ */ new Set(["default", "kind", "label", "src", "srclang"])], ["ul", /* @__PURE__ */ new Set(["compact", "type"])], ["video", /* @__PURE__ */ new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
      var Xs2 = /* @__PURE__ */ new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
      function No2(t) {
        if (t.type === "block") {
          if (t.name = w(false, t.name.toLowerCase(), /\s+/gu, " ").trim(), t.type = "angularControlFlowBlock", !qe(t.parameters)) {
            delete t.parameters;
            return;
          }
          for (let e of t.parameters) e.type = "angularControlFlowBlockParameter";
          t.parameters = { type: "angularControlFlowBlockParameters", children: t.parameters, sourceSpan: new h(t.parameters[0].sourceSpan.start, X(false, t.parameters, -1).sourceSpan.end) };
        }
      }
      function Po2(t) {
        t.type === "letDeclaration" && (t.type = "angularLetDeclaration", t.id = t.name, t.init = { type: "angularLetDeclarationInitializer", sourceSpan: new h(t.valueSpan.start, t.valueSpan.end), value: t.value }, delete t.name, delete t.value);
      }
      function Io2(t) {
        (t.type === "plural" || t.type === "select") && (t.clause = t.type, t.type = "angularIcuExpression"), t.type === "expansionCase" && (t.type = "angularIcuCase");
      }
      function Zs2(t, e, r) {
        let { name: n, canSelfClose: s = true, normalizeTagName: i = false, normalizeAttributeName: a = false, allowHtmComponentClosingTags: o = false, isTagNameCaseSensitive: u = false, shouldParseAsRawText: p } = e, { rootNodes: l, errors: f } = Gr2(t, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: p ? (...c) => p(...c) ? I.RAW_TEXT : void 0 : void 0, tokenizeAngularBlocks: n === "angular" ? true : void 0, tokenizeAngularLetDeclaration: n === "angular" ? true : void 0 });
        if (n === "vue") {
          if (l.some((x) => x.type === "docType" && x.value === "html" || x.type === "element" && x.name.toLowerCase() === "html")) return Zs2(t, ti2, r);
          let g, y2 = () => g ?? (g = Gr2(t, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })), M = (x) => y2().rootNodes.find(({ startSourceSpan: V }) => V && V.start.offset === x.startSourceSpan.start.offset) ?? x;
          for (let [x, V] of l.entries()) {
            let { endSourceSpan: jr2, startSourceSpan: ri2 } = V;
            if (jr2 === null) f = y2().errors, l[x] = M(V);
            else if (Ro2(V, r)) {
              let Kr2 = y2().errors.find((Qr2) => Qr2.span.start.offset > ri2.start.offset && Qr2.span.start.offset < jr2.end.offset);
              Kr2 && Js2(Kr2), l[x] = M(V);
            }
          }
        }
        f.length > 0 && Js2(f[0]);
        let d2 = (c) => {
          let g = c.name.startsWith(":") ? c.name.slice(1).split(":")[0] : null, y2 = c.nameSpan.toString(), M = g !== null && y2.startsWith(`${g}:`), x = M ? y2.slice(g.length + 1) : y2;
          c.name = x, c.namespace = g, c.hasExplicitNamespace = M;
        }, C = (c) => {
          switch (c.type) {
            case "element":
              d2(c);
              for (let g of c.attrs) d2(g), g.valueSpan ? (g.value = g.valueSpan.toString(), /["']/u.test(g.value[0]) && (g.value = g.value.slice(1, -1))) : g.value = null;
              break;
            case "comment":
              c.value = c.sourceSpan.toString().slice(4, -3);
              break;
            case "text":
              c.value = c.sourceSpan.toString();
              break;
          }
        }, A = (c, g) => {
          let y2 = c.toLowerCase();
          return g(y2) ? y2 : c;
        }, D = (c) => {
          if (c.type === "element" && (i && (!c.namespace || c.namespace === c.tagDefinition.implicitNamespacePrefix || Se(c)) && (c.name = A(c.name, (g) => Xs2.has(g))), a)) for (let g of c.attrs) g.namespace || (g.name = A(g.name, (y2) => or2.has(c.name) && (or2.get("*").has(y2) || or2.get(c.name).has(y2))));
        }, R = (c) => {
          c.sourceSpan && c.endSourceSpan && (c.sourceSpan = new h(c.sourceSpan.start, c.endSourceSpan.end));
        }, F = (c) => {
          if (c.type === "element") {
            let g = Ge(u ? c.name : c.name.toLowerCase());
            !c.namespace || c.namespace === g.implicitNamespacePrefix || Se(c) ? c.tagDefinition = g : c.tagDefinition = Ge("");
          }
        };
        return Qt2(new class extends ht2 {
          visitExpansionCase(c, g) {
            n === "angular" && this.visitChildren(g, (y2) => {
              y2(c.expression);
            });
          }
          visit(c) {
            C(c), F(c), D(c), R(c);
          }
        }(), l), l;
      }
      function Ro2(t, e) {
        var n;
        if (t.type !== "element" || t.name !== "template") return false;
        let r = (n = t.attrs.find((s) => s.name === "lang")) == null ? void 0 : n.value;
        return !r || Oe2(e, { language: r }) === "html";
      }
      function Js2(t) {
        let { msg: e, span: { start: r, end: n } } = t;
        throw Ys2(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: t });
      }
      function ei2(t, e, r = {}, n = true) {
        let { frontMatter: s, content: i } = n ? js2(t) : { frontMatter: null, content: t }, a = new Te2(t, r.filepath), o = new ae(a, 0, 0, 0), u = o.moveBy(t.length), p = { type: "root", sourceSpan: new h(o, u), children: Zs2(i, e, r) };
        if (s) {
          let d2 = new ae(a, 0, 0, 0), C = d2.moveBy(s.raw.length);
          s.sourceSpan = new h(d2, C), p.children.unshift(s);
        }
        let l = new ar2(p), f = (d2, C) => {
          let { offset: A } = C, D = w(false, t.slice(0, A), /[^\n\r]/gu, " "), F = ei2(D + d2, e, r, false);
          F.sourceSpan = new h(C, X(false, F.children, -1).sourceSpan.end);
          let c = F.children[0];
          return c.length === A ? F.children.shift() : (c.sourceSpan = new h(c.sourceSpan.start.moveBy(A), c.sourceSpan.end), c.value = c.value.slice(A)), F;
        };
        return l.walk((d2) => {
          if (d2.type === "comment") {
            let C = Qs(d2, f);
            C && d2.parent.replaceChild(d2, C);
          }
          No2(d2), Po2(d2), Io2(d2);
        }), l;
      }
      function ur2(t) {
        return { parse: (e, r) => ei2(e, t, r), hasPragma: os2, astFormat: "html", locStart: se, locEnd: ie };
      }
      var ti2 = { name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }, $o2 = ur2(ti2), Oo = ur2({ name: "angular" }), Mo2 = ur2({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(t, e, r, n) {
        return t.toLowerCase() !== "html" && !r && (t !== "template" || n.some(({ name: s, value: i }) => s === "lang" && i !== "html" && i !== "" && i !== void 0));
      } }), qo2 = ur2({ name: "lwc", canSelfClose: false });
      var Ho2 = { html: As2 };
      return oi2(Vo2);
    });
  }
});

// node_modules/prettier/plugins/babel.js
var require_babel = __commonJS({
  "node_modules/prettier/plugins/babel.js"(exports, module) {
    (function(f) {
      function e() {
        var i = f();
        return i.default || i;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var t = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babel = e();
      }
    })(function() {
      "use strict";
      var $s2 = Object.create;
      var Se = Object.defineProperty;
      var Vs2 = Object.getOwnPropertyDescriptor;
      var qs2 = Object.getOwnPropertyNames;
      var zs2 = Object.getPrototypeOf, Ks2 = Object.prototype.hasOwnProperty;
      var Hs2 = (a, t) => () => (t || a((t = { exports: {} }).exports, t), t.exports), Ws2 = (a, t) => {
        for (var e in t) Se(a, e, { get: t[e], enumerable: true });
      }, kt2 = (a, t, e, s) => {
        if (t && typeof t == "object" || typeof t == "function") for (let i of qs2(t)) !Ks2.call(a, i) && i !== e && Se(a, i, { get: () => t[i], enumerable: !(s = Vs2(t, i)) || s.enumerable });
        return a;
      };
      var vt = (a, t, e) => (e = a != null ? $s2(zs2(a)) : {}, kt2(t || !a || !a.__esModule ? Se(e, "default", { value: a, enumerable: true }) : e, a)), Js2 = (a) => kt2(Se({}, "__esModule", { value: true }), a);
      var At = Hs2((xe) => {
        "use strict";
        Object.defineProperty(xe, "__esModule", { value: true });
        function Ht2(a, t) {
          if (a == null) return {};
          var e = {}, s = Object.keys(a), i, r;
          for (r = 0; r < s.length; r++) i = s[r], !(t.indexOf(i) >= 0) && (e[i] = a[i]);
          return e;
        }
        var F = class {
          constructor(t, e, s) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = e, this.index = s;
          }
        }, ee = class {
          constructor(t, e) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = e;
          }
        };
        function v2(a, t) {
          let { line: e, column: s, index: i } = a;
          return new F(e, s + t, i + t);
        }
        var Lt2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Xs2 = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Lt2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Lt2 } }, Dt = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, Ee = (a) => a.type === "UpdateExpression" ? Dt.UpdateExpression[`${a.prefix}`] : Dt[a.type], Gs = { AccessorIsGenerator: ({ kind: a }) => `A ${a}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: a }) => `Missing initializer in ${a} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: a }) => `\`${a}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: a }) => `'import.${a}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: a, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${a}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: a }) => `'${a === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: a }) => `Unsyntactic ${a === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: a }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${a}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: a }) => `\`import()\` requires exactly ${a === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: a }) => `Expected number in radix ${a}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: a }) => `Escape sequence in keyword ${a}.`, InvalidIdentifier: ({ identifierName: a }) => `Invalid identifier ${a}.`, InvalidLhs: ({ ancestor: a }) => `Invalid left-hand side in ${Ee(a)}.`, InvalidLhsBinding: ({ ancestor: a }) => `Binding invalid left-hand side in ${Ee(a)}.`, InvalidLhsOptionalChaining: ({ ancestor: a }) => `Invalid optional chaining in the left-hand side of ${Ee(a)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: a }) => `Unexpected character '${a}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: a }) => `Private name #${a} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: a }) => `Label '${a}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: a }) => `This experimental syntax requires enabling the parser plugin: ${a.map((t) => JSON.stringify(t)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: a }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${a.map((t) => JSON.stringify(t)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: a }) => `Duplicate key "${a}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: a }) => `An export name cannot include a lone surrogate, found '\\u${a.toString(16)}'.`, ModuleExportUndefined: ({ localName: a }) => `Export '${a}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: a }) => `Private names are only allowed in property accesses (\`obj.#${a}\`) or in \`in\` expressions (\`#${a} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: a }) => `Duplicate private name #${a}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: a }) => `Unexpected keyword '${a}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: a }) => `Unexpected reserved word '${a}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: a, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ""}${a ? `, expected "${a}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: a, onlyValidPropertyName: t }) => `The only valid meta property for ${a} is ${a}.${t}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: a }) => `Identifier '${a}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Ys2 = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: a }) => `Assigning to '${a}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: a }) => `Binding '${a}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Qs = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Zs2 = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: a }) => `Invalid topic token ${a}. In order to use ${a} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${a}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: a }) => `Hack-style pipe body cannot be an unparenthesized ${Ee({ type: a })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, ei2 = ["toMessage"], ti2 = ["message"];
        function Mt(a, t, e) {
          Object.defineProperty(a, t, { enumerable: false, configurable: true, value: e });
        }
        function si2(a) {
          let { toMessage: t } = a, e = Ht2(a, ei2);
          return function s(i, r) {
            let n = new SyntaxError();
            return Object.assign(n, e, { loc: i, pos: i.index }), "missingPlugin" in r && Object.assign(n, { missingPlugin: r.missingPlugin }), Mt(n, "clone", function(h = {}) {
              var c;
              let { line: l, column: u, index: f } = (c = h.loc) != null ? c : i;
              return s(new F(l, u, f), Object.assign({}, r, h.details));
            }), Mt(n, "details", r), Object.defineProperty(n, "message", { configurable: true, get() {
              let o = `${t(r)} (${i.line}:${i.column})`;
              return this.message = o, o;
            }, set(o) {
              Object.defineProperty(this, "message", { value: o, writable: true });
            } }), n;
          };
        }
        function j(a, t) {
          if (Array.isArray(a)) return (s) => j(s, a[0]);
          let e = {};
          for (let s of Object.keys(a)) {
            let i = a[s], r = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = r, o = Ht2(r, ti2), h = typeof n == "string" ? () => n : n;
            e[s] = si2(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s, toMessage: h }, t ? { syntaxPlugin: t } : {}, o));
          }
          return e;
        }
        var p = Object.assign({}, j(Xs2), j(Gs), j(Ys2), j`pipelineOperator`(Zs2)), { defineProperty: ii2 } = Object, Ot2 = (a, t) => {
          a && ii2(a, t, { enumerable: false, value: a[t] });
        };
        function oe(a) {
          return Ot2(a.loc.start, "index"), Ot2(a.loc.end, "index"), a;
        }
        var ri2 = (a) => class extends a {
          parse() {
            let e = oe(super.parse());
            return this.options.tokens && (e.tokens = e.tokens.map(oe)), e;
          }
          parseRegExpLiteral({ pattern: e, flags: s }) {
            let i = null;
            try {
              i = new RegExp(e, s);
            } catch {
            }
            let r = this.estreeParseLiteral(i);
            return r.regex = { pattern: e, flags: s }, r;
          }
          parseBigIntLiteral(e) {
            let s;
            try {
              s = BigInt(e);
            } catch {
              s = null;
            }
            let i = this.estreeParseLiteral(s);
            return i.bigint = String(i.value || e), i;
          }
          parseDecimalLiteral(e) {
            let i = this.estreeParseLiteral(null);
            return i.decimal = String(i.value || e), i;
          }
          estreeParseLiteral(e) {
            return this.parseLiteral(e, "Literal");
          }
          parseStringLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          parseNumericLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          directiveToStmt(e) {
            let s = e.value;
            delete e.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
            let i = e;
            return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
          }
          initFunction(e, s) {
            super.initFunction(e, s), e.expression = false;
          }
          checkDeclaration(e) {
            e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
          }
          getObjectOrClassMethodParams(e) {
            return e.value.params;
          }
          isValidDirective(e) {
            var s;
            return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s = e.expression.extra) != null && s.parenthesized);
          }
          parseBlockBody(e, s, i, r, n) {
            super.parseBlockBody(e, s, i, r, n);
            let o = e.directives.map((h) => this.directiveToStmt(h));
            e.body = o.concat(e.body), delete e.directives;
          }
          pushClassMethod(e, s, i, r, n, o) {
            this.parseMethod(s, i, r, n, o, "ClassMethod", true), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), e.body.push(s);
          }
          parsePrivateName() {
            let e = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
          }
          convertPrivateNameToPrivateIdentifier(e) {
            let s = super.getPrivateNameSV(e);
            return e = e, delete e.id, e.name = s, e.type = "PrivateIdentifier", e;
          }
          isPrivateName(e) {
            return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
          }
          getPrivateNameSV(e) {
            return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
          }
          parseLiteral(e, s) {
            let i = super.parseLiteral(e, s);
            return i.raw = i.extra.raw, delete i.extra, i;
          }
          parseFunctionBody(e, s, i = false) {
            super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
          }
          parseMethod(e, s, i, r, n, o, h = false) {
            let c = this.startNode();
            return c.kind = e.kind, c = super.parseMethod(c, s, i, r, n, o, h), c.type = "FunctionExpression", delete c.kind, e.value = c, o === "ClassPrivateMethod" && (e.computed = false), this.finishNode(e, "MethodDefinition");
          }
          nameIsConstructor(e) {
            return e.type === "Literal" ? e.value === "constructor" : super.nameIsConstructor(e);
          }
          parseClassProperty(...e) {
            let s = super.parseClassProperty(...e);
            return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
          }
          parseClassPrivateProperty(...e) {
            let s = super.parseClassPrivateProperty(...e);
            return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = false), s;
          }
          parseObjectMethod(e, s, i, r, n) {
            let o = super.parseObjectMethod(e, s, i, r, n);
            return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = false), o;
          }
          parseObjectProperty(e, s, i, r) {
            let n = super.parseObjectProperty(e, s, i, r);
            return n && (n.kind = "init", n.type = "Property"), n;
          }
          isValidLVal(e, s, i) {
            return e === "Property" ? "value" : super.isValidLVal(e, s, i);
          }
          isAssignable(e, s) {
            return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
          }
          toAssignable(e, s = false) {
            if (e != null && this.isObjectProperty(e)) {
              let { key: i, value: r } = e;
              this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(r, s);
            } else super.toAssignable(e, s);
          }
          toAssignableObjectExpressionProp(e, s, i) {
            e.type === "Property" && (e.kind === "get" || e.kind === "set") ? this.raise(p.PatternHasAccessor, e.key) : e.type === "Property" && e.method ? this.raise(p.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, s, i);
          }
          finishCallExpression(e, s) {
            let i = super.finishCallExpression(e, s);
            if (i.callee.type === "Import") {
              if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                var r, n;
                i.options = (r = i.arguments[1]) != null ? r : null, i.attributes = (n = i.arguments[1]) != null ? n : null;
              }
              delete i.arguments, delete i.callee;
            }
            return i;
          }
          toReferencedArguments(e) {
            e.type !== "ImportExpression" && super.toReferencedArguments(e);
          }
          parseExport(e, s) {
            let i = this.state.lastTokStartLoc, r = super.parseExport(e, s);
            switch (r.type) {
              case "ExportAllDeclaration":
                r.exported = null;
                break;
              case "ExportNamedDeclaration":
                r.specifiers.length === 1 && r.specifiers[0].type === "ExportNamespaceSpecifier" && (r.type = "ExportAllDeclaration", r.exported = r.specifiers[0].exported, delete r.specifiers);
              case "ExportDefaultDeclaration":
                {
                  var n;
                  let { declaration: o } = r;
                  (o == null ? void 0 : o.type) === "ClassDeclaration" && ((n = o.decorators) == null ? void 0 : n.length) > 0 && o.start === r.start && this.resetStartLocation(r, i);
                }
                break;
            }
            return r;
          }
          parseSubscript(e, s, i, r) {
            let n = super.parseSubscript(e, s, i, r);
            if (r.optionalChainMember) {
              if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), r.stop) {
                let o = this.startNodeAtNode(n);
                return o.expression = n, this.finishNode(o, "ChainExpression");
              }
            } else (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
            return n;
          }
          isOptionalMemberExpression(e) {
            return e.type === "ChainExpression" ? e.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e);
          }
          hasPropertyAsPrivateName(e) {
            return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
          }
          isObjectProperty(e) {
            return e.type === "Property" && e.kind === "init" && !e.method;
          }
          isObjectMethod(e) {
            return e.type === "Property" && (e.method || e.kind === "get" || e.kind === "set");
          }
          finishNodeAt(e, s, i) {
            return oe(super.finishNodeAt(e, s, i));
          }
          resetStartLocation(e, s) {
            super.resetStartLocation(e, s), oe(e);
          }
          resetEndLocation(e, s = this.state.lastTokEndLoc) {
            super.resetEndLocation(e, s), oe(e);
          }
        }, X = class {
          constructor(t, e) {
            this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!e;
          }
        }, C = { brace: new X("{"), j_oTag: new X("<tag"), j_cTag: new X("</tag"), j_expr: new X("<tag>...</tag>", true) };
        C.template = new X("`", true);
        var b = true, m = true, $e = true, he = true, q = true, ai2 = true, ve2 = class {
          constructor(t, e = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null, this.updateContext = null;
          }
        }, ut = /* @__PURE__ */ new Map();
        function A(a, t = {}) {
          t.keyword = a;
          let e = P(a, t);
          return ut.set(a, e), e;
        }
        function k(a, t) {
          return P(a, { beforeExpr: b, binop: t });
        }
        var ue2 = -1, U = [], ft2 = [], dt2 = [], mt = [], yt = [], xt = [];
        function P(a, t = {}) {
          var e, s, i, r;
          return ++ue2, ft2.push(a), dt2.push((e = t.binop) != null ? e : -1), mt.push((s = t.beforeExpr) != null ? s : false), yt.push((i = t.startsExpr) != null ? i : false), xt.push((r = t.prefix) != null ? r : false), U.push(new ve2(a, t)), ue2;
        }
        function T3(a, t = {}) {
          var e, s, i, r;
          return ++ue2, ut.set(a, ue2), ft2.push(a), dt2.push((e = t.binop) != null ? e : -1), mt.push((s = t.beforeExpr) != null ? s : false), yt.push((i = t.startsExpr) != null ? i : false), xt.push((r = t.prefix) != null ? r : false), U.push(new ve2("name", t)), ue2;
        }
        var ni2 = { bracketL: P("[", { beforeExpr: b, startsExpr: m }), bracketHashL: P("#[", { beforeExpr: b, startsExpr: m }), bracketBarL: P("[|", { beforeExpr: b, startsExpr: m }), bracketR: P("]"), bracketBarR: P("|]"), braceL: P("{", { beforeExpr: b, startsExpr: m }), braceBarL: P("{|", { beforeExpr: b, startsExpr: m }), braceHashL: P("#{", { beforeExpr: b, startsExpr: m }), braceR: P("}"), braceBarR: P("|}"), parenL: P("(", { beforeExpr: b, startsExpr: m }), parenR: P(")"), comma: P(",", { beforeExpr: b }), semi: P(";", { beforeExpr: b }), colon: P(":", { beforeExpr: b }), doubleColon: P("::", { beforeExpr: b }), dot: P("."), question: P("?", { beforeExpr: b }), questionDot: P("?."), arrow: P("=>", { beforeExpr: b }), template: P("template"), ellipsis: P("...", { beforeExpr: b }), backQuote: P("`", { startsExpr: m }), dollarBraceL: P("${", { beforeExpr: b, startsExpr: m }), templateTail: P("...`", { startsExpr: m }), templateNonTail: P("...${", { beforeExpr: b, startsExpr: m }), at: P("@"), hash: P("#", { startsExpr: m }), interpreterDirective: P("#!..."), eq: P("=", { beforeExpr: b, isAssign: he }), assign: P("_=", { beforeExpr: b, isAssign: he }), slashAssign: P("_=", { beforeExpr: b, isAssign: he }), xorAssign: P("_=", { beforeExpr: b, isAssign: he }), moduloAssign: P("_=", { beforeExpr: b, isAssign: he }), incDec: P("++/--", { prefix: q, postfix: ai2, startsExpr: m }), bang: P("!", { beforeExpr: b, prefix: q, startsExpr: m }), tilde: P("~", { beforeExpr: b, prefix: q, startsExpr: m }), doubleCaret: P("^^", { startsExpr: m }), doubleAt: P("@@", { startsExpr: m }), pipeline: k("|>", 0), nullishCoalescing: k("??", 1), logicalOR: k("||", 1), logicalAND: k("&&", 2), bitwiseOR: k("|", 3), bitwiseXOR: k("^", 4), bitwiseAND: k("&", 5), equality: k("==/!=/===/!==", 6), lt: k("</>/<=/>=", 7), gt: k("</>/<=/>=", 7), relational: k("</>/<=/>=", 7), bitShift: k("<</>>/>>>", 8), bitShiftL: k("<</>>/>>>", 8), bitShiftR: k("<</>>/>>>", 8), plusMin: P("+/-", { beforeExpr: b, binop: 9, prefix: q, startsExpr: m }), modulo: P("%", { binop: 10, startsExpr: m }), star: P("*", { binop: 10 }), slash: k("/", 10), exponent: P("**", { beforeExpr: b, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: b, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: b, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: b }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: b }), _else: A("else", { beforeExpr: b }), _finally: A("finally"), _function: A("function", { startsExpr: m }), _if: A("if"), _return: A("return", { beforeExpr: b }), _switch: A("switch"), _throw: A("throw", { beforeExpr: b, prefix: q, startsExpr: m }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: b, startsExpr: m }), _this: A("this", { startsExpr: m }), _super: A("super", { startsExpr: m }), _class: A("class", { startsExpr: m }), _extends: A("extends", { beforeExpr: b }), _export: A("export"), _import: A("import", { startsExpr: m }), _null: A("null", { startsExpr: m }), _true: A("true", { startsExpr: m }), _false: A("false", { startsExpr: m }), _typeof: A("typeof", { beforeExpr: b, prefix: q, startsExpr: m }), _void: A("void", { beforeExpr: b, prefix: q, startsExpr: m }), _delete: A("delete", { beforeExpr: b, prefix: q, startsExpr: m }), _do: A("do", { isLoop: $e, beforeExpr: b }), _for: A("for", { isLoop: $e }), _while: A("while", { isLoop: $e }), _as: T3("as", { startsExpr: m }), _assert: T3("assert", { startsExpr: m }), _async: T3("async", { startsExpr: m }), _await: T3("await", { startsExpr: m }), _defer: T3("defer", { startsExpr: m }), _from: T3("from", { startsExpr: m }), _get: T3("get", { startsExpr: m }), _let: T3("let", { startsExpr: m }), _meta: T3("meta", { startsExpr: m }), _of: T3("of", { startsExpr: m }), _sent: T3("sent", { startsExpr: m }), _set: T3("set", { startsExpr: m }), _source: T3("source", { startsExpr: m }), _static: T3("static", { startsExpr: m }), _using: T3("using", { startsExpr: m }), _yield: T3("yield", { startsExpr: m }), _asserts: T3("asserts", { startsExpr: m }), _checks: T3("checks", { startsExpr: m }), _exports: T3("exports", { startsExpr: m }), _global: T3("global", { startsExpr: m }), _implements: T3("implements", { startsExpr: m }), _intrinsic: T3("intrinsic", { startsExpr: m }), _infer: T3("infer", { startsExpr: m }), _is: T3("is", { startsExpr: m }), _mixins: T3("mixins", { startsExpr: m }), _proto: T3("proto", { startsExpr: m }), _require: T3("require", { startsExpr: m }), _satisfies: T3("satisfies", { startsExpr: m }), _keyof: T3("keyof", { startsExpr: m }), _readonly: T3("readonly", { startsExpr: m }), _unique: T3("unique", { startsExpr: m }), _abstract: T3("abstract", { startsExpr: m }), _declare: T3("declare", { startsExpr: m }), _enum: T3("enum", { startsExpr: m }), _module: T3("module", { startsExpr: m }), _namespace: T3("namespace", { startsExpr: m }), _interface: T3("interface", { startsExpr: m }), _type: T3("type", { startsExpr: m }), _opaque: T3("opaque", { startsExpr: m }), name: P("name", { startsExpr: m }), string: P("string", { startsExpr: m }), num: P("num", { startsExpr: m }), bigint: P("bigint", { startsExpr: m }), decimal: P("decimal", { startsExpr: m }), regexp: P("regexp", { startsExpr: m }), privateName: P("#name", { startsExpr: m }), eof: P("eof"), jsxName: P("jsxName"), jsxText: P("jsxText", { beforeExpr: true }), jsxTagStart: P("jsxTagStart", { startsExpr: true }), jsxTagEnd: P("jsxTagEnd"), placeholder: P("%%", { startsExpr: true }) };
        function w(a) {
          return a >= 93 && a <= 132;
        }
        function oi2(a) {
          return a <= 92;
        }
        function M(a) {
          return a >= 58 && a <= 132;
        }
        function Wt(a) {
          return a >= 58 && a <= 136;
        }
        function hi2(a) {
          return mt[a];
        }
        function He2(a) {
          return yt[a];
        }
        function li(a) {
          return a >= 29 && a <= 33;
        }
        function Ft2(a) {
          return a >= 129 && a <= 131;
        }
        function ci3(a) {
          return a >= 90 && a <= 92;
        }
        function Pt2(a) {
          return a >= 58 && a <= 92;
        }
        function pi(a) {
          return a >= 39 && a <= 59;
        }
        function ui(a) {
          return a === 34;
        }
        function fi2(a) {
          return xt[a];
        }
        function di(a) {
          return a >= 121 && a <= 123;
        }
        function mi2(a) {
          return a >= 124 && a <= 130;
        }
        function K(a) {
          return ft2[a];
        }
        function Ie(a) {
          return dt2[a];
        }
        function yi2(a) {
          return a === 57;
        }
        function Le2(a) {
          return a >= 24 && a <= 25;
        }
        function R(a) {
          return U[a];
        }
        U[8].updateContext = (a) => {
          a.pop();
        }, U[5].updateContext = U[7].updateContext = U[23].updateContext = (a) => {
          a.push(C.brace);
        }, U[22].updateContext = (a) => {
          a[a.length - 1] === C.template ? a.pop() : a.push(C.template);
        }, U[142].updateContext = (a) => {
          a.push(C.j_expr, C.j_oTag);
        };
        var gt2 = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Jt2 = "-----------------------------------------------------------------------------------------------------------------------------------------------------", xi2 = new RegExp("[" + gt2 + "]"), Pi2 = new RegExp("[" + gt2 + Jt2 + "]");
        gt2 = Jt2 = null;
        var Xt2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], gi = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function We(a, t) {
          let e = 65536;
          for (let s = 0, i = t.length; s < i; s += 2) {
            if (e += t[s], e > a) return false;
            if (e += t[s + 1], e >= a) return true;
          }
          return false;
        }
        function _2(a) {
          return a < 65 ? a === 36 : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && xi2.test(String.fromCharCode(a)) : We(a, Xt2);
        }
        function Q3(a) {
          return a < 48 ? a === 36 : a < 58 ? true : a < 65 ? false : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && Pi2.test(String.fromCharCode(a)) : We(a, Xt2) || We(a, gi);
        }
        var Tt = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Ti2 = new Set(Tt.keyword), bi2 = new Set(Tt.strict), Ai2 = new Set(Tt.strictBind);
        function Gt3(a, t) {
          return t && a === "await" || a === "enum";
        }
        function Yt(a, t) {
          return Gt3(a, t) || bi2.has(a);
        }
        function Qt2(a) {
          return Ai2.has(a);
        }
        function Zt2(a, t) {
          return Yt(a, t) || Qt2(a);
        }
        function Si2(a) {
          return Ti2.has(a);
        }
        function wi2(a, t, e) {
          return a === 64 && t === 64 && _2(e);
        }
        var Ci2 = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        function Ei2(a) {
          return Ci2.has(a);
        }
        var de3 = class {
          constructor(t) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
          }
        }, me = class {
          constructor(t, e) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = e;
          }
          get inTopLevel() {
            return (this.currentScope().flags & 1) > 0;
          }
          get inFunction() {
            return (this.currentVarScopeFlags() & 2) > 0;
          }
          get allowSuper() {
            return (this.currentThisScopeFlags() & 16) > 0;
          }
          get allowDirectSuper() {
            return (this.currentThisScopeFlags() & 32) > 0;
          }
          get inClass() {
            return (this.currentThisScopeFlags() & 64) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            let t = this.currentThisScopeFlags();
            return (t & 64) > 0 && (t & 2) === 0;
          }
          get inStaticBlock() {
            for (let t = this.scopeStack.length - 1; ; t--) {
              let { flags: e } = this.scopeStack[t];
              if (e & 128) return true;
              if (e & 451) return false;
            }
          }
          get inNonArrowFunction() {
            return (this.currentThisScopeFlags() & 2) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(t) {
            return new de3(t);
          }
          enter(t) {
            this.scopeStack.push(this.createScope(t));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(t) {
            return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
          }
          declareName(t, e, s) {
            let i = this.currentScope();
            if (e & 8 || e & 16) {
              this.checkRedeclarationInScope(i, t, e, s);
              let r = i.names.get(t) || 0;
              e & 16 ? r = r | 4 : (i.firstLexicalName || (i.firstLexicalName = t), r = r | 2), i.names.set(t, r), e & 8 && this.maybeExportDefined(i, t);
            } else if (e & 4) for (let r = this.scopeStack.length - 1; r >= 0 && (i = this.scopeStack[r], this.checkRedeclarationInScope(i, t, e, s), i.names.set(t, (i.names.get(t) || 0) | 1), this.maybeExportDefined(i, t), !(i.flags & 387)); --r) ;
            this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(t);
          }
          maybeExportDefined(t, e) {
            this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(e);
          }
          checkRedeclarationInScope(t, e, s, i) {
            this.isRedeclaredInScope(t, e, s) && this.parser.raise(p.VarRedeclaration, i, { identifierName: e });
          }
          isRedeclaredInScope(t, e, s) {
            if (!(s & 1)) return false;
            if (s & 8) return t.names.has(e);
            let i = t.names.get(e);
            return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (i & 1) > 0 : (i & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === e) || !this.treatFunctionsAsVarInScope(t) && (i & 4) > 0;
          }
          checkLocalExport(t) {
            let { name: e } = t;
            this.scopeStack[0].names.has(e) || this.undefinedExports.set(e, t.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let t = this.scopeStack.length - 1; ; t--) {
              let { flags: e } = this.scopeStack[t];
              if (e & 387) return e;
            }
          }
          currentThisScopeFlags() {
            for (let t = this.scopeStack.length - 1; ; t--) {
              let { flags: e } = this.scopeStack[t];
              if (e & 451 && !(e & 4)) return e;
            }
          }
        }, Je = class extends de3 {
          constructor(...t) {
            super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }, Xe2 = class extends me {
          createScope(t) {
            return new Je(t);
          }
          declareName(t, e, s) {
            let i = this.currentScope();
            if (e & 2048) {
              this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t), i.declareFunctions.add(t);
              return;
            }
            super.declareName(t, e, s);
          }
          isRedeclaredInScope(t, e, s) {
            if (super.isRedeclaredInScope(t, e, s)) return true;
            if (s & 2048 && !t.declareFunctions.has(e)) {
              let i = t.names.get(e);
              return (i & 4) > 0 || (i & 2) > 0;
            }
            return false;
          }
          checkLocalExport(t) {
            this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
          }
        }, Ge = class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(t) {
            if (typeof t == "string") return this.plugins.has(t);
            {
              let [e, s] = t;
              if (!this.hasPlugin(e)) return false;
              let i = this.plugins.get(e);
              for (let r of Object.keys(s)) if ((i == null ? void 0 : i[r]) !== s[r]) return false;
              return true;
            }
          }
          getPluginOption(t, e) {
            var s;
            return (s = this.plugins.get(t)) == null ? void 0 : s[e];
          }
        };
        function es2(a, t) {
          a.trailingComments === void 0 ? a.trailingComments = t : a.trailingComments.unshift(...t);
        }
        function Ii2(a, t) {
          a.leadingComments === void 0 ? a.leadingComments = t : a.leadingComments.unshift(...t);
        }
        function ye(a, t) {
          a.innerComments === void 0 ? a.innerComments = t : a.innerComments.unshift(...t);
        }
        function le2(a, t, e) {
          let s = null, i = t.length;
          for (; s === null && i > 0; ) s = t[--i];
          s === null || s.start > e.start ? ye(a, e.comments) : es2(s, e.comments);
        }
        var Ye3 = class extends Ge {
          addComment(t) {
            this.filename && (t.loc.filename = this.filename);
            let { commentsLen: e } = this.state;
            this.comments.length !== e && (this.comments.length = e), this.comments.push(t), this.state.commentsLen++;
          }
          processComment(t) {
            let { commentStack: e } = this.state, s = e.length;
            if (s === 0) return;
            let i = s - 1, r = e[i];
            r.start === t.end && (r.leadingNode = t, i--);
            let { start: n } = t;
            for (; i >= 0; i--) {
              let o = e[i], h = o.end;
              if (h > n) o.containingNode = t, this.finalizeComment(o), e.splice(i, 1);
              else {
                h === n && (o.trailingNode = t);
                break;
              }
            }
          }
          finalizeComment(t) {
            let { comments: e } = t;
            if (t.leadingNode !== null || t.trailingNode !== null) t.leadingNode !== null && es2(t.leadingNode, e), t.trailingNode !== null && Ii2(t.trailingNode, e);
            else {
              let { containingNode: s, start: i } = t;
              if (this.input.charCodeAt(i - 1) === 44) switch (s.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  le2(s, s.properties, t);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  le2(s, s.arguments, t);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  le2(s, s.params, t);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  le2(s, s.elements, t);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  le2(s, s.specifiers, t);
                  break;
                default:
                  ye(s, e);
              }
              else ye(s, e);
            }
          }
          finalizeRemainingComments() {
            let { commentStack: t } = this.state;
            for (let e = t.length - 1; e >= 0; e--) this.finalizeComment(t[e]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(t) {
            let { commentStack: e } = this.state, { length: s } = e;
            if (s === 0) return;
            let i = e[s - 1];
            i.leadingNode === t && (i.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(t) {
            let { commentStack: e } = this.state, { length: s } = e;
            s !== 0 && (e[s - 1].trailingNode === t ? e[s - 1].trailingNode = null : s >= 2 && e[s - 2].trailingNode === t && (e[s - 2].trailingNode = null));
          }
          takeSurroundingComments(t, e, s) {
            let { commentStack: i } = this.state, r = i.length;
            if (r === 0) return;
            let n = r - 1;
            for (; n >= 0; n--) {
              let o = i[n], h = o.end;
              if (o.start === s) o.leadingNode = t;
              else if (h === e) o.trailingNode = t;
              else if (h < e) break;
            }
          }
        }, ts2 = /\r\n?|[\n\u2028\u2029]/, we = new RegExp(ts2.source, "g");
        function fe(a) {
          switch (a) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        var Ve2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ne2 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Bt2 = new RegExp("(?=(" + Ne2.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function Ni2(a) {
          switch (a) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        var Qe2 = class a {
          constructor() {
            this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [C.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (this.flags & 1) > 0;
          }
          set strict(t) {
            t ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: t, sourceType: e, startLine: s, startColumn: i }) {
            this.strict = t === false ? false : t === true ? true : e === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new F(s, i, 0);
          }
          get maybeInArrowParameters() {
            return (this.flags & 2) > 0;
          }
          set maybeInArrowParameters(t) {
            t ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (this.flags & 4) > 0;
          }
          set inType(t) {
            t ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (this.flags & 8) > 0;
          }
          set noAnonFunctionType(t) {
            t ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (this.flags & 16) > 0;
          }
          set hasFlowComment(t) {
            t ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (this.flags & 32) > 0;
          }
          set isAmbientContext(t) {
            t ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (this.flags & 64) > 0;
          }
          set inAbstractClass(t) {
            t ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (this.flags & 128) > 0;
          }
          set inDisallowConditionalTypesContext(t) {
            t ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (this.flags & 256) > 0;
          }
          set soloAwait(t) {
            t ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (this.flags & 512) > 0;
          }
          set inFSharpPipelineDirectBody(t) {
            t ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (this.flags & 1024) > 0;
          }
          set canStartJSXElement(t) {
            t ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (this.flags & 2048) > 0;
          }
          set containsEsc(t) {
            t ? this.flags |= 2048 : this.flags &= -2049;
          }
          curPosition() {
            return new F(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone() {
            let t = new a();
            return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
          }
        }, ki2 = function(t) {
          return t >= 48 && t <= 57;
        }, Rt = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ce = { bin: (a) => a === 48 || a === 49, oct: (a) => a >= 48 && a <= 55, dec: (a) => a >= 48 && a <= 57, hex: (a) => a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102 };
        function Ut(a, t, e, s, i, r) {
          let n = e, o = s, h = i, c = "", l = null, u = e, { length: f } = t;
          for (; ; ) {
            if (e >= f) {
              r.unterminated(n, o, h), c += t.slice(u, e);
              break;
            }
            let d2 = t.charCodeAt(e);
            if (vi2(a, d2, t, e)) {
              c += t.slice(u, e);
              break;
            }
            if (d2 === 92) {
              c += t.slice(u, e);
              let y2 = Li2(t, e, s, i, a === "template", r);
              y2.ch === null && !l ? l = { pos: e, lineStart: s, curLine: i } : c += y2.ch, { pos: e, lineStart: s, curLine: i } = y2, u = e;
            } else d2 === 8232 || d2 === 8233 ? (++e, ++i, s = e) : d2 === 10 || d2 === 13 ? a === "template" ? (c += t.slice(u, e) + `
`, ++e, d2 === 13 && t.charCodeAt(e) === 10 && ++e, ++i, u = s = e) : r.unterminated(n, o, h) : ++e;
          }
          return { pos: e, str: c, firstInvalidLoc: l, lineStart: s, curLine: i, containsInvalid: !!l };
        }
        function vi2(a, t, e, s) {
          return a === "template" ? t === 96 || t === 36 && e.charCodeAt(s + 1) === 123 : t === (a === "double" ? 34 : 39);
        }
        function Li2(a, t, e, s, i, r) {
          let n = !i;
          t++;
          let o = (c) => ({ pos: t, ch: c, lineStart: e, curLine: s }), h = a.charCodeAt(t++);
          switch (h) {
            case 110:
              return o(`
`);
            case 114:
              return o("\r");
            case 120: {
              let c;
              return { code: c, pos: t } = Ze2(a, t, e, s, 2, false, n, r), o(c === null ? null : String.fromCharCode(c));
            }
            case 117: {
              let c;
              return { code: c, pos: t } = is2(a, t, e, s, n, r), o(c === null ? null : String.fromCodePoint(c));
            }
            case 116:
              return o("	");
            case 98:
              return o("\b");
            case 118:
              return o("\v");
            case 102:
              return o("\f");
            case 13:
              a.charCodeAt(t) === 10 && ++t;
            case 10:
              e = t, ++s;
            case 8232:
            case 8233:
              return o("");
            case 56:
            case 57:
              if (i) return o(null);
              r.strictNumericEscape(t - 1, e, s);
            default:
              if (h >= 48 && h <= 55) {
                let c = t - 1, u = /^[0-7]+/.exec(a.slice(c, t + 2))[0], f = parseInt(u, 8);
                f > 255 && (u = u.slice(0, -1), f = parseInt(u, 8)), t += u.length - 1;
                let d2 = a.charCodeAt(t);
                if (u !== "0" || d2 === 56 || d2 === 57) {
                  if (i) return o(null);
                  r.strictNumericEscape(c, e, s);
                }
                return o(String.fromCharCode(f));
              }
              return o(String.fromCharCode(h));
          }
        }
        function Ze2(a, t, e, s, i, r, n, o) {
          let h = t, c;
          return { n: c, pos: t } = ss2(a, t, e, s, 16, i, r, false, o, !n), c === null && (n ? o.invalidEscapeSequence(h, e, s) : t = h - 1), { code: c, pos: t };
        }
        function ss2(a, t, e, s, i, r, n, o, h, c) {
          let l = t, u = i === 16 ? Rt.hex : Rt.decBinOct, f = i === 16 ? Ce.hex : i === 10 ? Ce.dec : i === 8 ? Ce.oct : Ce.bin, d2 = false, y2 = 0;
          for (let E = 0, L = r ?? 1 / 0; E < L; ++E) {
            let S = a.charCodeAt(t), I;
            if (S === 95 && o !== "bail") {
              let Ae = a.charCodeAt(t - 1), ne = a.charCodeAt(t + 1);
              if (o) {
                if (Number.isNaN(ne) || !f(ne) || u.has(Ae) || u.has(ne)) {
                  if (c) return { n: null, pos: t };
                  h.unexpectedNumericSeparator(t, e, s);
                }
              } else {
                if (c) return { n: null, pos: t };
                h.numericSeparatorInEscapeSequence(t, e, s);
              }
              ++t;
              continue;
            }
            if (S >= 97 ? I = S - 97 + 10 : S >= 65 ? I = S - 65 + 10 : ki2(S) ? I = S - 48 : I = 1 / 0, I >= i) {
              if (I <= 9 && c) return { n: null, pos: t };
              if (I <= 9 && h.invalidDigit(t, e, s, i)) I = 0;
              else if (n) I = 0, d2 = true;
              else break;
            }
            ++t, y2 = y2 * i + I;
          }
          return t === l || r != null && t - l !== r || d2 ? { n: null, pos: t } : { n: y2, pos: t };
        }
        function is2(a, t, e, s, i, r) {
          let n = a.charCodeAt(t), o;
          if (n === 123) {
            if (++t, { code: o, pos: t } = Ze2(a, t, e, s, a.indexOf("}", t) - t, true, i, r), ++t, o !== null && o > 1114111) if (i) r.invalidCodePoint(t, e, s);
            else return { code: null, pos: t };
          } else ({ code: o, pos: t } = Ze2(a, t, e, s, 4, false, i, r));
          return { code: o, pos: t };
        }
        function ce(a, t, e) {
          return new F(e, a - t, a);
        }
        var Di2 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), O = class {
          constructor(t) {
            this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new ee(t.startLoc, t.endLoc);
          }
        }, et = class extends Ye3 {
          constructor(t, e) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (s, i, r, n) => this.options.errorRecovery ? (this.raise(p.InvalidDigit, ce(s, i, r), { radix: n }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(p.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(p.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(p.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(p.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (s, i, r) => {
              this.recordStrictModeErrors(p.StrictNumericEscape, ce(s, i, r));
            }, unterminated: (s, i, r) => {
              throw this.raise(p.UnterminatedString, ce(s - 1, i, r));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(p.StrictNumericEscape), unterminated: (s, i, r) => {
              throw this.raise(p.UnterminatedTemplate, ce(s, i, r));
            } }), this.state = new Qe2(), this.state.init(t), this.input = e, this.length = e.length, this.comments = [], this.isLookahead = false;
          }
          pushToken(t) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new O(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(t) {
            return this.match(t) ? (this.next(), true) : false;
          }
          match(t) {
            return this.state.type === t;
          }
          createLookaheadState(t) {
            return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
          }
          lookahead() {
            let t = this.state;
            this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            let e = this.state;
            return this.state = t, e;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(t) {
            return Ve2.lastIndex = t, Ve2.test(this.input) ? Ve2.lastIndex : t;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(t) {
            return Ne2.lastIndex = t, Ne2.test(this.input) ? Ne2.lastIndex : t;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(t) {
            let e = this.input.charCodeAt(t);
            if ((e & 64512) === 55296 && ++t < this.input.length) {
              let s = this.input.charCodeAt(t);
              (s & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (s & 1023));
            }
            return e;
          }
          setStrict(t) {
            this.state.strict = t, t && (this.state.strictErrors.forEach(([e, s]) => this.raise(e, s)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
              this.finishToken(139);
              return;
            }
            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(t) {
            let e;
            this.isLookahead || (e = this.state.curPosition());
            let s = this.state.pos, i = this.input.indexOf(t, s + 2);
            if (i === -1) throw this.raise(p.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = i + t.length, we.lastIndex = s + 2; we.test(this.input) && we.lastIndex <= i; ) ++this.state.curLine, this.state.lineStart = we.lastIndex;
            if (this.isLookahead) return;
            let r = { type: "CommentBlock", value: this.input.slice(s + 2, i), start: s, end: i + t.length, loc: new ee(e, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(r), r;
          }
          skipLineComment(t) {
            let e = this.state.pos, s;
            this.isLookahead || (s = this.state.curPosition());
            let i = this.input.charCodeAt(this.state.pos += t);
            if (this.state.pos < this.length) for (; !fe(i) && ++this.state.pos < this.length; ) i = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            let r = this.state.pos, o = { type: "CommentLine", value: this.input.slice(e + t, r), start: e, end: r, loc: new ee(s, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(o), o;
          }
          skipSpace() {
            let t = this.state.pos, e = [];
            e: for (; this.state.pos < this.length; ) {
              let s = this.input.charCodeAt(this.state.pos);
              switch (s) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      let i = this.skipBlockComment("*/");
                      i !== void 0 && (this.addComment(i), this.options.attachComment && e.push(i));
                      break;
                    }
                    case 47: {
                      let i = this.skipLineComment(2);
                      i !== void 0 && (this.addComment(i), this.options.attachComment && e.push(i));
                      break;
                    }
                    default:
                      break e;
                  }
                  break;
                default:
                  if (Ni2(s)) ++this.state.pos;
                  else if (s === 45 && !this.inModule && this.options.annexB) {
                    let i = this.state.pos;
                    if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                      let r = this.skipLineComment(3);
                      r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                    } else break e;
                  } else if (s === 60 && !this.inModule && this.options.annexB) {
                    let i = this.state.pos;
                    if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                      let r = this.skipLineComment(4);
                      r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                    } else break e;
                  } else break e;
              }
            }
            if (e.length > 0) {
              let s = this.state.pos, i = { start: t, end: s, comments: e, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(i);
            }
          }
          finishToken(t, e) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            let s = this.state.type;
            this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s);
          }
          replaceToken(t) {
            this.state.type = t, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) return;
            let t = this.state.pos + 1, e = this.codePointAtPos(t);
            if (e >= 48 && e <= 57) throw this.raise(p.UnexpectedDigitAfterHash, this.state.curPosition());
            if (e === 123 || e === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(e === 123 ? p.RecordExpressionHashIncorrectStartSyntaxType : p.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, e === 123 ? this.finishToken(7) : this.finishToken(1);
            } else _2(e) ? (++this.state.pos, this.finishToken(138, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            let t = this.input.charCodeAt(this.state.pos + 1);
            if (t >= 48 && t <= 57) {
              this.readNumber(true);
              return;
            }
            t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2) return false;
            let t = this.input.charCodeAt(this.state.pos + 1);
            if (t !== 33) return false;
            let e = this.state.pos;
            for (this.state.pos += 1; !fe(t) && ++this.state.pos < this.length; ) t = this.input.charCodeAt(this.state.pos);
            let s = this.input.slice(e + 2, this.state.pos);
            return this.finishToken(28, s), true;
          }
          readToken_mult_modulo(t) {
            let e = t === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
            t === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = 57), i === 61 && !this.state.inType && (s++, e = t === 37 ? 33 : 30), this.finishOp(e, s);
          }
          readToken_pipe_amp(t) {
            let e = this.input.charCodeAt(this.state.pos + 1);
            if (e === t) {
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
              return;
            }
            if (t === 124) {
              if (e === 62) {
                this.finishOp(39, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(9);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(4);
                return;
              }
            }
            if (e === 61) {
              this.finishOp(30, 2);
              return;
            }
            this.finishOp(t === 124 ? 43 : 45, 1);
          }
          readToken_caret() {
            let t = this.input.charCodeAt(this.state.pos + 1);
            t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(t) {
            let e = this.input.charCodeAt(this.state.pos + 1);
            if (e === t) {
              this.finishOp(34, 2);
              return;
            }
            e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
          }
          readToken_lt() {
            let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
            if (e === 60) {
              if (this.input.charCodeAt(t + 2) === 61) {
                this.finishOp(30, 3);
                return;
              }
              this.finishOp(51, 2);
              return;
            }
            if (e === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(47, 1);
          }
          readToken_gt() {
            let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
            if (e === 62) {
              let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
              if (this.input.charCodeAt(t + s) === 61) {
                this.finishOp(30, s + 1);
                return;
              }
              this.finishOp(52, s);
              return;
            }
            if (e === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(48, 1);
          }
          readToken_eq_excl(t) {
            let e = this.input.charCodeAt(this.state.pos + 1);
            if (e === 61) {
              this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              return;
            }
            if (t === 61 && e === 62) {
              this.state.pos += 2, this.finishToken(19);
              return;
            }
            this.finishOp(t === 61 ? 29 : 35, 1);
          }
          readToken_question() {
            let t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
            t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
          }
          getTokenFromCode(t) {
            switch (t) {
              case 46:
                this.readToken_dot();
                return;
              case 40:
                ++this.state.pos, this.finishToken(10);
                return;
              case 41:
                ++this.state.pos, this.finishToken(11);
                return;
              case 59:
                ++this.state.pos, this.finishToken(13);
                return;
              case 44:
                ++this.state.pos, this.finishToken(12);
                return;
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                ++this.state.pos, this.finishToken(3);
                return;
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                ++this.state.pos, this.finishToken(8);
                return;
              case 58:
                this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                return;
              case 63:
                this.readToken_question();
                return;
              case 96:
                this.readTemplateToken();
                return;
              case 48: {
                let e = this.input.charCodeAt(this.state.pos + 1);
                if (e === 120 || e === 88) {
                  this.readRadixNumber(16);
                  return;
                }
                if (e === 111 || e === 79) {
                  this.readRadixNumber(8);
                  return;
                }
                if (e === 98 || e === 66) {
                  this.readRadixNumber(2);
                  return;
                }
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                this.readNumber(false);
                return;
              case 34:
              case 39:
                this.readString(t);
                return;
              case 47:
                this.readToken_slash();
                return;
              case 37:
              case 42:
                this.readToken_mult_modulo(t);
                return;
              case 124:
              case 38:
                this.readToken_pipe_amp(t);
                return;
              case 94:
                this.readToken_caret();
                return;
              case 43:
              case 45:
                this.readToken_plus_min(t);
                return;
              case 60:
                this.readToken_lt();
                return;
              case 62:
                this.readToken_gt();
                return;
              case 61:
              case 33:
                this.readToken_eq_excl(t);
                return;
              case 126:
                this.finishOp(36, 1);
                return;
              case 64:
                this.readToken_atSign();
                return;
              case 35:
                this.readToken_numberSign();
                return;
              case 92:
                this.readWord();
                return;
              default:
                if (_2(t)) {
                  this.readWord(t);
                  return;
                }
            }
            throw this.raise(p.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(t) });
          }
          finishOp(t, e) {
            let s = this.input.slice(this.state.pos, this.state.pos + e);
            this.state.pos += e, this.finishToken(t, s);
          }
          readRegexp() {
            let t = this.state.startLoc, e = this.state.start + 1, s, i, { pos: r } = this.state;
            for (; ; ++r) {
              if (r >= this.length) throw this.raise(p.UnterminatedRegExp, v2(t, 1));
              let c = this.input.charCodeAt(r);
              if (fe(c)) throw this.raise(p.UnterminatedRegExp, v2(t, 1));
              if (s) s = false;
              else {
                if (c === 91) i = true;
                else if (c === 93 && i) i = false;
                else if (c === 47 && !i) break;
                s = c === 92;
              }
            }
            let n = this.input.slice(e, r);
            ++r;
            let o = "", h = () => v2(t, r + 2 - e);
            for (; r < this.length; ) {
              let c = this.codePointAtPos(r), l = String.fromCharCode(c);
              if (Di2.has(c)) c === 118 ? o.includes("u") && this.raise(p.IncompatibleRegExpUVFlags, h()) : c === 117 && o.includes("v") && this.raise(p.IncompatibleRegExpUVFlags, h()), o.includes(l) && this.raise(p.DuplicateRegExpFlags, h());
              else if (Q3(c) || c === 92) this.raise(p.MalformedRegExpFlags, h());
              else break;
              ++r, o += l;
            }
            this.state.pos = r, this.finishToken(137, { pattern: n, flags: o });
          }
          readInt(t, e, s = false, i = true) {
            let { n: r, pos: n } = ss2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, e, s, i, this.errorHandlers_readInt, false);
            return this.state.pos = n, r;
          }
          readRadixNumber(t) {
            let e = this.state.curPosition(), s = false;
            this.state.pos += 2;
            let i = this.readInt(t);
            i == null && this.raise(p.InvalidDigit, v2(e, 2), { radix: t });
            let r = this.input.charCodeAt(this.state.pos);
            if (r === 110) ++this.state.pos, s = true;
            else if (r === 109) throw this.raise(p.InvalidDecimal, e);
            if (_2(this.codePointAtPos(this.state.pos))) throw this.raise(p.NumberIdentifier, this.state.curPosition());
            if (s) {
              let n = this.input.slice(e.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(135, n);
              return;
            }
            this.finishToken(134, i);
          }
          readNumber(t) {
            let e = this.state.pos, s = this.state.curPosition(), i = false, r = false, n = false, o = false, h = false;
            !t && this.readInt(10) === null && this.raise(p.InvalidNumber, this.state.curPosition());
            let c = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
            if (c) {
              let d2 = this.input.slice(e, this.state.pos);
              if (this.recordStrictModeErrors(p.StrictOctalLiteral, s), !this.state.strict) {
                let y2 = d2.indexOf("_");
                y2 > 0 && this.raise(p.ZeroDigitNumericSeparator, v2(s, y2));
              }
              h = c && !/[89]/.test(d2);
            }
            let l = this.input.charCodeAt(this.state.pos);
            if (l === 46 && !h && (++this.state.pos, this.readInt(10), i = true, l = this.input.charCodeAt(this.state.pos)), (l === 69 || l === 101) && !h && (l = this.input.charCodeAt(++this.state.pos), (l === 43 || l === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(p.InvalidOrMissingExponent, s), i = true, o = true, l = this.input.charCodeAt(this.state.pos)), l === 110 && ((i || c) && this.raise(p.InvalidBigIntLiteral, s), ++this.state.pos, r = true), l === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || c) && this.raise(p.InvalidDecimal, s), ++this.state.pos, n = true), _2(this.codePointAtPos(this.state.pos))) throw this.raise(p.NumberIdentifier, this.state.curPosition());
            let u = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
            if (r) {
              this.finishToken(135, u);
              return;
            }
            if (n) {
              this.finishToken(136, u);
              return;
            }
            let f = h ? parseInt(u, 8) : parseFloat(u);
            this.finishToken(134, f);
          }
          readCodePoint(t) {
            let { code: e, pos: s } = is2(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
            return this.state.pos = s, e;
          }
          readString(t) {
            let { str: e, pos: s, curLine: i, lineStart: r } = Ut(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = s + 1, this.state.lineStart = r, this.state.curLine = i, this.finishToken(133, e);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            let t = this.input[this.state.pos], { str: e, firstInvalidLoc: s, pos: i, curLine: r, lineStart: n } = Ut("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = r, s && (this.state.firstInvalidTemplateEscapePos = new F(s.curLine, s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : t + e + "`") : (this.state.pos++, this.finishToken(25, s ? null : t + e + "${"));
          }
          recordStrictModeErrors(t, e) {
            let s = e.index;
            this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, e) : this.state.strictErrors.set(s, [t, e]);
          }
          readWord1(t) {
            this.state.containsEsc = false;
            let e = "", s = this.state.pos, i = this.state.pos;
            for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              let r = this.codePointAtPos(this.state.pos);
              if (Q3(r)) this.state.pos += r <= 65535 ? 1 : 2;
              else if (r === 92) {
                this.state.containsEsc = true, e += this.input.slice(i, this.state.pos);
                let n = this.state.curPosition(), o = this.state.pos === s ? _2 : Q3;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                  this.raise(p.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
                  continue;
                }
                ++this.state.pos;
                let h = this.readCodePoint(true);
                h !== null && (o(h) || this.raise(p.EscapedCharNotAnIdentifier, n), e += String.fromCodePoint(h)), i = this.state.pos;
              } else break;
            }
            return e + this.input.slice(i, this.state.pos);
          }
          readWord(t) {
            let e = this.readWord1(t), s = ut.get(e);
            s !== void 0 ? this.finishToken(s, K(s)) : this.finishToken(132, e);
          }
          checkKeywordEscapes() {
            let { type: t } = this.state;
            Pt2(t) && this.state.containsEsc && this.raise(p.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: K(t) });
          }
          raise(t, e, s = {}) {
            let i = e instanceof F ? e : e.loc.start, r = t(i, s);
            if (!this.options.errorRecovery) throw r;
            return this.isLookahead || this.state.errors.push(r), r;
          }
          raiseOverwrite(t, e, s = {}) {
            let i = e instanceof F ? e : e.loc.start, r = i.index, n = this.state.errors;
            for (let o = n.length - 1; o >= 0; o--) {
              let h = n[o];
              if (h.loc.index === r) return n[o] = t(i, s);
              if (h.loc.index < r) break;
            }
            return this.raise(t, e, s);
          }
          updateContext(t) {
          }
          unexpected(t, e) {
            throw this.raise(p.UnexpectedToken, t ?? this.state.startLoc, { expected: e ? K(e) : null });
          }
          expectPlugin(t, e) {
            if (this.hasPlugin(t)) return true;
            throw this.raise(p.MissingPlugin, e ?? this.state.startLoc, { missingPlugin: [t] });
          }
          expectOnePlugin(t) {
            if (!t.some((e) => this.hasPlugin(e))) throw this.raise(p.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: t });
          }
          errorBuilder(t) {
            return (e, s, i) => {
              this.raise(t, ce(e, s, i));
            };
          }
        }, tt = class {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }, st2 = class {
          constructor(t) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new tt());
          }
          exit() {
            let t = this.stack.pop(), e = this.current();
            for (let [s, i] of Array.from(t.undefinedPrivateNames)) e ? e.undefinedPrivateNames.has(s) || e.undefinedPrivateNames.set(s, i) : this.parser.raise(p.InvalidPrivateFieldResolution, i, { identifierName: s });
          }
          declarePrivateName(t, e, s) {
            let { privateNames: i, loneAccessors: r, undefinedPrivateNames: n } = this.current(), o = i.has(t);
            if (e & 3) {
              let h = o && r.get(t);
              if (h) {
                let c = h & 4, l = e & 4, u = h & 3, f = e & 3;
                o = u === f || c !== l, o || r.delete(t);
              } else o || r.set(t, e);
            }
            o && this.parser.raise(p.PrivateNameRedeclaration, s, { identifierName: t }), i.add(t), n.delete(t);
          }
          usePrivateName(t, e) {
            let s;
            for (s of this.stack) if (s.privateNames.has(t)) return;
            s ? s.undefinedPrivateNames.set(t, e) : this.parser.raise(p.InvalidPrivateFieldResolution, e, { identifierName: t });
          }
        }, te = class {
          constructor(t = 0) {
            this.type = t;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }, De = class extends te {
          constructor(t) {
            super(t), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(t, e) {
            let s = e.index;
            this.declarationErrors.set(s, [t, e]);
          }
          clearDeclarationError(t) {
            this.declarationErrors.delete(t);
          }
          iterateErrors(t) {
            this.declarationErrors.forEach(t);
          }
        }, it2 = class {
          constructor(t) {
            this.parser = void 0, this.stack = [new te()], this.parser = t;
          }
          enter(t) {
            this.stack.push(t);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(t, e) {
            let s = e.loc.start, { stack: i } = this, r = i.length - 1, n = i[r];
            for (; !n.isCertainlyParameterDeclaration(); ) {
              if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(t, s);
              else return;
              n = i[--r];
            }
            this.parser.raise(t, s);
          }
          recordArrowParameterBindingError(t, e) {
            let { stack: s } = this, i = s[s.length - 1], r = e.loc.start;
            if (i.isCertainlyParameterDeclaration()) this.parser.raise(t, r);
            else if (i.canBeArrowParameterDeclaration()) i.recordDeclarationError(t, r);
            else return;
          }
          recordAsyncArrowParametersError(t) {
            let { stack: e } = this, s = e.length - 1, i = e[s];
            for (; i.canBeArrowParameterDeclaration(); ) i.type === 2 && i.recordDeclarationError(p.AwaitBindingIdentifier, t), i = e[--s];
          }
          validateAsPattern() {
            let { stack: t } = this, e = t[t.length - 1];
            e.canBeArrowParameterDeclaration() && e.iterateErrors(([s, i]) => {
              this.parser.raise(s, i);
              let r = t.length - 2, n = t[r];
              for (; n.canBeArrowParameterDeclaration(); ) n.clearDeclarationError(i.index), n = t[--r];
            });
          }
        };
        function Mi2() {
          return new te(3);
        }
        function Oi2() {
          return new De(1);
        }
        function Fi2() {
          return new De(2);
        }
        function rs2() {
          return new te();
        }
        var rt = class {
          constructor() {
            this.stacks = [];
          }
          enter(t) {
            this.stacks.push(t);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (this.currentFlags() & 2) > 0;
          }
          get hasYield() {
            return (this.currentFlags() & 1) > 0;
          }
          get hasReturn() {
            return (this.currentFlags() & 4) > 0;
          }
          get hasIn() {
            return (this.currentFlags() & 8) > 0;
          }
        };
        function ke2(a, t) {
          return (a ? 2 : 0) | (t ? 1 : 0);
        }
        var at2 = class extends et {
          addExtra(t, e, s, i = true) {
            if (!t) return;
            let r = t.extra = t.extra || {};
            i ? r[e] = s : Object.defineProperty(r, e, { enumerable: i, value: s });
          }
          isContextual(t) {
            return this.state.type === t && !this.state.containsEsc;
          }
          isUnparsedContextual(t, e) {
            let s = t + e.length;
            if (this.input.slice(t, s) === e) {
              let i = this.input.charCodeAt(s);
              return !(Q3(i) || (i & 64512) === 55296);
            }
            return false;
          }
          isLookaheadContextual(t) {
            let e = this.nextTokenStart();
            return this.isUnparsedContextual(e, t);
          }
          eatContextual(t) {
            return this.isContextual(t) ? (this.next(), true) : false;
          }
          expectContextual(t, e) {
            if (!this.eatContextual(t)) {
              if (e != null) throw this.raise(e, this.state.startLoc);
              this.unexpected(null, t);
            }
          }
          canInsertSemicolon() {
            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return ts2.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return Bt2.lastIndex = this.state.end, Bt2.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(t = true) {
            (t ? this.isLineTerminator() : this.eat(13)) || this.raise(p.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(t, e) {
            this.eat(t) || this.unexpected(e, t);
          }
          tryParse(t, e = this.state.clone()) {
            let s = { node: null };
            try {
              let i = t((r = null) => {
                throw s.node = r, s;
              });
              if (this.state.errors.length > e.errors.length) {
                let r = this.state;
                return this.state = e, this.state.tokensLength = r.tokensLength, { node: i, error: r.errors[e.errors.length], thrown: false, aborted: false, failState: r };
              }
              return { node: i, error: null, thrown: false, aborted: false, failState: null };
            } catch (i) {
              let r = this.state;
              if (this.state = e, i instanceof SyntaxError) return { node: null, error: i, thrown: true, aborted: false, failState: r };
              if (i === s) return { node: s.node, error: null, thrown: false, aborted: true, failState: r };
              throw i;
            }
          }
          checkExpressionErrors(t, e) {
            if (!t) return false;
            let { shorthandAssignLoc: s, doubleProtoLoc: i, privateKeyLoc: r, optionalParametersLoc: n } = t, o = !!s || !!i || !!n || !!r;
            if (!e) return o;
            s != null && this.raise(p.InvalidCoverInitializedName, s), i != null && this.raise(p.DuplicateProto, i), r != null && this.raise(p.UnexpectedPrivateField, r), n != null && this.unexpected(n);
          }
          isLiteralPropertyName() {
            return Wt(this.state.type);
          }
          isPrivateName(t) {
            return t.type === "PrivateName";
          }
          getPrivateNameSV(t) {
            return t.id.name;
          }
          hasPropertyAsPrivateName(t) {
            return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
          }
          isObjectProperty(t) {
            return t.type === "ObjectProperty";
          }
          isObjectMethod(t) {
            return t.type === "ObjectMethod";
          }
          initializeScopes(t = this.options.sourceType === "module") {
            let e = this.state.labels;
            this.state.labels = [];
            let s = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            let i = this.inModule;
            this.inModule = t;
            let r = this.scope, n = this.getScopeHandler();
            this.scope = new n(this, t);
            let o = this.prodParam;
            this.prodParam = new rt();
            let h = this.classScope;
            this.classScope = new st2(this);
            let c = this.expressionScope;
            return this.expressionScope = new it2(this), () => {
              this.state.labels = e, this.exportedIdentifiers = s, this.inModule = i, this.scope = r, this.prodParam = o, this.classScope = h, this.expressionScope = c;
            };
          }
          enterInitialScopes() {
            let t = 0;
            this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
          }
          checkDestructuringPrivate(t) {
            let { privateKeyLoc: e } = t;
            e !== null && this.expectPlugin("destructuringPrivate", e);
          }
        }, Z = class {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }, se = class {
          constructor(t, e, s) {
            this.type = "", this.start = e, this.end = 0, this.loc = new ee(s), t != null && t.options.ranges && (this.range = [e, 0]), t != null && t.filename && (this.loc.filename = t.filename);
          }
        }, bt2 = se.prototype;
        bt2.__clone = function() {
          let a = new se(void 0, this.start, this.loc.start), t = Object.keys(this);
          for (let e = 0, s = t.length; e < s; e++) {
            let i = t[e];
            i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (a[i] = this[i]);
          }
          return a;
        };
        function Bi(a) {
          return $(a);
        }
        function $(a) {
          let { type: t, start: e, end: s, loc: i, range: r, extra: n, name: o } = a, h = Object.create(bt2);
          return h.type = t, h.start = e, h.end = s, h.loc = i, h.range = r, h.extra = n, h.name = o, t === "Placeholder" && (h.expectedNode = a.expectedNode), h;
        }
        function Ri2(a) {
          let { type: t, start: e, end: s, loc: i, range: r, extra: n } = a;
          if (t === "Placeholder") return Bi(a);
          let o = Object.create(bt2);
          return o.type = t, o.start = e, o.end = s, o.loc = i, o.range = r, a.raw !== void 0 ? o.raw = a.raw : o.extra = n, o.value = a.value, o;
        }
        var nt2 = class extends at2 {
          startNode() {
            let t = this.state.startLoc;
            return new se(this, t.index, t);
          }
          startNodeAt(t) {
            return new se(this, t.index, t);
          }
          startNodeAtNode(t) {
            return this.startNodeAt(t.loc.start);
          }
          finishNode(t, e) {
            return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
          }
          finishNodeAt(t, e, s) {
            return t.type = e, t.end = s.index, t.loc.end = s, this.options.ranges && (t.range[1] = s.index), this.options.attachComment && this.processComment(t), t;
          }
          resetStartLocation(t, e) {
            t.start = e.index, t.loc.start = e, this.options.ranges && (t.range[0] = e.index);
          }
          resetEndLocation(t, e = this.state.lastTokEndLoc) {
            t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index);
          }
          resetStartLocationFromNode(t, e) {
            this.resetStartLocation(t, e.loc.start);
          }
        }, Ui2 = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), g = j`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: a }) => `Cannot overwrite reserved type ${a}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: a, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${a} = true,\` or \`${a} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: a, enumName: t }) => `Enum member names need to be unique, but the name \`${a}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: a }) => `Enum \`${a}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: a, enumName: t }) => `Enum type \`${a}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: a }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: a, memberName: t, explicitType: e }) => `Enum \`${a}\` has type \`${e}\`, so the initializer of \`${t}\` needs to be a ${e} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: a, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${a}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: a, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${a}\`.`, EnumInvalidMemberName: ({ enumName: a, memberName: t, suggestion: e }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${e}\`, in enum \`${a}\`.`, EnumNumberMemberNotInitialized: ({ enumName: a, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${a}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: a }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${a}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: a }) => `Unexpected reserved type ${a}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: a, suggestion: t }) => `\`declare export ${a}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function _i2(a) {
          return a.type === "DeclareExportAllDeclaration" || a.type === "DeclareExportDeclaration" && (!a.declaration || a.declaration.type !== "TypeAlias" && a.declaration.type !== "InterfaceDeclaration");
        }
        function _t2(a) {
          return a.importKind === "type" || a.importKind === "typeof";
        }
        var ji = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        function $i2(a, t) {
          let e = [], s = [];
          for (let i = 0; i < a.length; i++) (t(a[i], i, a) ? e : s).push(a[i]);
          return [e, s];
        }
        var Vi = /\*?\s*@((?:no)?flow)\b/, qi = (a) => class extends a {
          constructor(...e) {
            super(...e), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return Xe2;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(e, s) {
            e !== 133 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
          }
          addComment(e) {
            if (this.flowPragma === void 0) {
              let s = Vi.exec(e.value);
              if (s) if (s[1] === "flow") this.flowPragma = "flow";
              else if (s[1] === "noflow") this.flowPragma = "noflow";
              else throw new Error("Unexpected flow pragma");
            }
            super.addComment(e);
          }
          flowParseTypeInitialiser(e) {
            let s = this.state.inType;
            this.state.inType = true, this.expect(e || 14);
            let i = this.flowParseType();
            return this.state.inType = s, i;
          }
          flowParsePredicate() {
            let e = this.startNode(), s = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(g.UnexpectedSpaceBetweenModuloChecks, s), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            let e = this.state.inType;
            this.state.inType = true, this.expect(14);
            let s = null, i = null;
            return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
          }
          flowParseDeclareClass(e) {
            return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
          }
          flowParseDeclareFunction(e) {
            this.next();
            let s = e.id = this.parseIdentifier(), i = this.startNode(), r = this.startNode();
            this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
            let n = this.flowParseFunctionTypeParams();
            return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(r, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, "DeclareFunction");
          }
          flowParseDeclare(e, s) {
            if (this.match(80)) return this.flowParseDeclareClass(e);
            if (this.match(68)) return this.flowParseDeclareFunction(e);
            if (this.match(74)) return this.flowParseDeclareVariable(e);
            if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(g.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e));
            if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(e);
            if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(e);
            if (this.isContextual(129)) return this.flowParseDeclareInterface(e);
            if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, s);
            this.unexpected();
          }
          flowParseDeclareVariable(e) {
            return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
          }
          flowParseDeclareModule(e) {
            this.scope.enter(0), this.match(133) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
            let s = e.body = this.startNode(), i = s.body = [];
            for (this.expect(5); !this.match(8); ) {
              let o = this.startNode();
              this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(g.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, g.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, true)), i.push(o);
            }
            this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
            let r = null, n = false;
            return i.forEach((o) => {
              _i2(o) ? (r === "CommonJS" && this.raise(g.AmbiguousDeclareModuleKind, o), r = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(g.DuplicateDeclareModuleExports, o), r === "ES" && this.raise(g.AmbiguousDeclareModuleKind, o), r = "CommonJS", n = true);
            }), e.kind = r || "CommonJS", this.finishNode(e, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(e, s) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
              let i = this.state.value;
              throw this.raise(g.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: i, suggestion: ji[i] });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
            if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
            this.unexpected();
          }
          flowParseDeclareModuleExports(e) {
            return this.next(), this.expectContextual(111), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(e) {
            this.next();
            let s = this.flowParseTypeAlias(e);
            return s.type = "DeclareTypeAlias", s;
          }
          flowParseDeclareOpaqueType(e) {
            this.next();
            let s = this.flowParseOpaqueType(e, true);
            return s.type = "DeclareOpaqueType", s;
          }
          flowParseDeclareInterface(e) {
            return this.next(), this.flowParseInterfaceish(e, false), this.finishNode(e, "DeclareInterface");
          }
          flowParseInterfaceish(e, s) {
            if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? 17 : 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], this.eat(81)) do
              e.extends.push(this.flowParseInterfaceExtends());
            while (!s && this.eat(12));
            if (s) {
              if (e.implements = [], e.mixins = [], this.eatContextual(117)) do
                e.mixins.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
              if (this.eatContextual(113)) do
                e.implements.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            }
            e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            let e = this.startNode();
            return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
          }
          flowParseInterface(e) {
            return this.flowParseInterfaceish(e, false), this.finishNode(e, "InterfaceDeclaration");
          }
          checkNotUnderscore(e) {
            e === "_" && this.raise(g.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e, s, i) {
            Ui2.has(e) && this.raise(i ? g.AssignReservedType : g.UnexpectedReservedType, s, { reservedType: e });
          }
          flowParseRestrictedIdentifier(e, s) {
            return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
          }
          flowParseTypeAlias(e) {
            return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
          }
          flowParseOpaqueType(e, s) {
            return this.expectContextual(130), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
          }
          flowParseTypeParameter(e = false) {
            let s = this.state.startLoc, i = this.startNode(), r = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
            return i.name = n.name, i.variance = r, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(g.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            let e = this.state.inType, s = this.startNode();
            s.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i = false;
            do {
              let r = this.flowParseTypeParameter(i);
              s.params.push(r), r.default && (i = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            let e = this.startNode(), s = this.state.inType;
            e.params = [], this.state.inType = true, this.expect(47);
            let i = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let e = this.startNode(), s = this.state.inType;
            for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            let e = this.startNode();
            if (this.expectContextual(129), e.extends = [], this.eat(81)) do
              e.extends.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
            return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e, s, i) {
            return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(e, s) {
            return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(e) {
            for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(e, s) {
            let i = this.startNode();
            return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: e, allowExact: s, allowSpread: i, allowProto: r, allowInexact: n }) {
            let o = this.state.inType;
            this.state.inType = true;
            let h = this.startNode();
            h.callProperties = [], h.properties = [], h.indexers = [], h.internalSlots = [];
            let c, l, u = false;
            for (s && this.match(6) ? (this.expect(6), c = 9, l = true) : (this.expect(5), c = 8, l = false), h.exact = l; !this.match(c); ) {
              let d2 = false, y2 = null, E = null, L = this.startNode();
              if (r && this.isContextual(118)) {
                let I = this.lookahead();
                I.type !== 14 && I.type !== 17 && (this.next(), y2 = this.state.startLoc, e = false);
              }
              if (e && this.isContextual(106)) {
                let I = this.lookahead();
                I.type !== 14 && I.type !== 17 && (this.next(), d2 = true);
              }
              let S = this.flowParseVariance();
              if (this.eat(0)) y2 != null && this.unexpected(y2), this.eat(0) ? (S && this.unexpected(S.loc.start), h.internalSlots.push(this.flowParseObjectTypeInternalSlot(L, d2))) : h.indexers.push(this.flowParseObjectTypeIndexer(L, d2, S));
              else if (this.match(10) || this.match(47)) y2 != null && this.unexpected(y2), S && this.unexpected(S.loc.start), h.callProperties.push(this.flowParseObjectTypeCallProperty(L, d2));
              else {
                let I = "init";
                if (this.isContextual(99) || this.isContextual(104)) {
                  let ne = this.lookahead();
                  Wt(ne.type) && (I = this.state.value, this.next());
                }
                let Ae = this.flowParseObjectTypeProperty(L, d2, y2, S, I, i, n ?? !l);
                Ae === null ? (u = true, E = this.state.lastTokStartLoc) : h.properties.push(Ae);
              }
              this.flowObjectTypeSemicolon(), E && !this.match(8) && !this.match(9) && this.raise(g.UnexpectedExplicitInexactInObject, E);
            }
            this.expect(c), i && (h.inexact = u);
            let f = this.finishNode(h, "ObjectTypeAnnotation");
            return this.state.inType = o, f;
          }
          flowParseObjectTypeProperty(e, s, i, r, n, o, h) {
            if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? h || this.raise(g.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(g.InexactInsideNonObject, this.state.lastTokStartLoc), r && this.raise(g.InexactVariance, r), null) : (o || this.raise(g.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), r && this.raise(g.SpreadVariance, r), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
            {
              e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
              let c = false;
              return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), r && this.unexpected(r.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(g.ThisParamBannedInConstructor, e.value.this)) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c = true), e.value = this.flowParseTypeInitialiser(), e.variance = r), e.optional = c, this.finishNode(e, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(e) {
            let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
            e.value.this && this.raise(e.kind === "get" ? g.GetterMayNotHaveThisParam : g.SetterMayNotHaveThisParam, e.value.this), i !== s && this.raise(e.kind === "get" ? p.BadGetterArity : p.BadSetterArity, e), e.kind === "set" && e.value.rest && this.raise(p.BadSetterRestParameter, e);
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e, s) {
            var i;
            (i = e) != null || (e = this.state.startLoc);
            let r = s || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              let n = this.startNodeAt(e);
              n.qualification = r, n.id = this.flowParseRestrictedIdentifier(true), r = this.finishNode(n, "QualifiedTypeIdentifier");
            }
            return r;
          }
          flowParseGenericType(e, s) {
            let i = this.startNodeAt(e);
            return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            let e = this.startNode();
            return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            let e = this.startNode();
            for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(e) {
            let s = null, i = false, r = null, n = this.startNode(), o = this.lookahead(), h = this.state.type === 78;
            return o.type === 14 || o.type === 17 ? (h && !e && this.raise(g.ThisParamMustBeFirst, n), s = this.parseIdentifier(h), this.eat(17) && (i = true, h && this.raise(g.ThisParamMayNotBeOptional, n)), r = this.flowParseTypeInitialiser()) : r = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = r, this.finishNode(n, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(e) {
            let s = this.startNodeAt(e.loc.start);
            return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(e = []) {
            let s = null, i = null;
            for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: i };
          }
          flowIdentToTypeAnnotation(e, s, i) {
            switch (i.name) {
              case "any":
                return this.finishNode(s, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
            }
          }
          flowParsePrimaryType() {
            let e = this.state.startLoc, s = this.startNode(), i, r, n = false, o = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, r = this.flowParseTupleType(), this.state.noAnonFunctionType = o, r;
              case 47: {
                let h = this.startNode();
                return h.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), this.finishNode(h, "FunctionTypeAnnotation");
              }
              case 10: {
                let h = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21)) if (w(this.state.type) || this.match(78)) {
                  let c = this.lookahead().type;
                  n = c !== 17 && c !== 14;
                } else n = true;
                if (n) {
                  if (this.state.noAnonFunctionType = false, r = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), r;
                  this.eat(12);
                }
                return r ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]) : i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), h.typeParameters = null, this.finishNode(h, "FunctionTypeAnnotation");
              }
              case 133:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(134)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
                  if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
                  throw this.raise(g.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                this.unexpected();
                return;
              case 134:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 135:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(s, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(s, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (Pt2(this.state.type)) {
                  let h = K(this.state.type);
                  return this.next(), super.createIdentifier(s, h);
                } else if (w(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              let r = this.startNodeAt(e), n = this.eat(18);
              i = i || n, this.expect(0), !n && this.match(3) ? (r.elementType = s, this.next(), s = this.finishNode(r, "ArrayTypeAnnotation")) : (r.objectType = s, r.indexType = this.flowParseType(), this.expect(3), i ? (r.optional = n, s = this.finishNode(r, "OptionalIndexedAccessType")) : s = this.finishNode(r, "IndexedAccessType"));
            }
            return s;
          }
          flowParsePrefixType() {
            let e = this.startNode();
            return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let e = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let s = this.startNodeAt(e.loc.start);
              return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
            }
            return e;
          }
          flowParseIntersectionType() {
            let e = this.startNode();
            this.eat(45);
            let s = this.flowParseAnonFunctionWithoutParens();
            for (e.types = [s]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
            return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            let e = this.startNode();
            this.eat(43);
            let s = this.flowParseIntersectionType();
            for (e.types = [s]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
            return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
          }
          flowParseType() {
            let e = this.state.inType;
            this.state.inType = true;
            let s = this.flowParseUnionType();
            return this.state.inType = e, s;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
              let e = this.state.startLoc, s = this.parseIdentifier();
              return this.flowParseGenericType(e, s);
            } else return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let e = this.startNode();
            return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(e) {
            let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
          }
          typeCastToParameter(e) {
            return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          flowParseVariance() {
            let e = null;
            return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
          }
          parseFunctionBody(e, s, i = false) {
            if (s) {
              this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i));
              return;
            }
            super.parseFunctionBody(e, false, i);
          }
          parseFunctionBodyAndFinish(e, s, i = false) {
            if (this.match(14)) {
              let r = this.startNode();
              [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = r.typeAnnotation ? this.finishNode(r, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(e, s, i);
          }
          parseStatementLike(e) {
            if (this.state.strict && this.isContextual(129)) {
              let i = this.lookahead();
              if (M(i.type)) {
                let r = this.startNode();
                return this.next(), this.flowParseInterface(r);
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              let i = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(i);
            }
            let s = super.parseStatementLike(e);
            return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
          }
          parseExpressionStatement(e, s, i) {
            if (s.type === "Identifier") {
              if (s.name === "declare") {
                if (this.match(80) || w(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
              } else if (w(this.state.type)) {
                if (s.name === "interface") return this.flowParseInterface(e);
                if (s.name === "type") return this.flowParseTypeAlias(e);
                if (s.name === "opaque") return this.flowParseOpaqueType(e, false);
              }
            }
            return super.parseExpressionStatement(e, s, i);
          }
          shouldParseExportDeclaration() {
            let { type: e } = this.state;
            return Ft2(e) || this.shouldParseEnums() && e === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: e } = this.state;
            return Ft2(e) || this.shouldParseEnums() && e === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              let e = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e, s, i) {
            if (!this.match(17)) return e;
            if (this.state.maybeInArrowParameters) {
              let f = this.lookaheadCharCode();
              if (f === 44 || f === 61 || f === 58 || f === 41) return this.setOptionalParametersError(i), e;
            }
            this.expect(17);
            let r = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: h, failed: c } = this.tryParseConditionalConsequent(), [l, u] = this.getArrowLikeExpressions(h);
            if (c || u.length > 0) {
              let f = [...n];
              if (u.length > 0) {
                this.state = r, this.state.noArrowAt = f;
                for (let d2 = 0; d2 < u.length; d2++) f.push(u[d2].start);
                ({ consequent: h, failed: c } = this.tryParseConditionalConsequent()), [l, u] = this.getArrowLikeExpressions(h);
              }
              c && l.length > 1 && this.raise(g.AmbiguousConditionalArrow, r.startLoc), c && l.length === 1 && (this.state = r, f.push(l[0].start), this.state.noArrowAt = f, { consequent: h, failed: c } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(h, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = h, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
          }
          getArrowLikeExpressions(e, s) {
            let i = [e], r = [];
            for (; i.length !== 0; ) {
              let n = i.pop();
              n.type === "ArrowFunctionExpression" && n.body.type !== "BlockStatement" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : r.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
            }
            return s ? (r.forEach((n) => this.finishArrowValidation(n)), [r, []]) : $i2(r, (n) => n.params.every((o) => this.isAssignable(o, true)));
          }
          finishArrowValidation(e) {
            var s;
            this.toAssignableList(e.params, (s = e.extra) == null ? void 0 : s.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e, s) {
            let i;
            return this.state.noArrowParamsConversionAt.includes(e.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
          }
          parseParenItem(e, s) {
            let i = super.parseParenItem(e, s);
            if (this.eat(17) && (i.optional = true, this.resetEndLocation(e)), this.match(14)) {
              let r = this.startNodeAt(s);
              return r.expression = i, r.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r, "TypeCastExpression");
            }
            return i;
          }
          assertModuleNodeAllowed(e) {
            e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
          }
          parseExportDeclaration(e) {
            if (this.isContextual(130)) {
              e.exportKind = "type";
              let s = this.startNode();
              return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
            } else if (this.isContextual(131)) {
              e.exportKind = "type";
              let s = this.startNode();
              return this.next(), this.flowParseOpaqueType(s, false);
            } else if (this.isContextual(129)) {
              e.exportKind = "type";
              let s = this.startNode();
              return this.next(), this.flowParseInterface(s);
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              e.exportKind = "value";
              let s = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(s);
            } else return super.parseExportDeclaration(e);
          }
          eatExportStar(e) {
            return super.eatExportStar(e) ? true : this.isContextual(130) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
          }
          maybeParseExportNamespaceSpecifier(e) {
            let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
            return i && e.exportKind === "type" && this.unexpected(s), i;
          }
          parseClassId(e, s, i) {
            super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e, s, i) {
            let { startLoc: r } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(e, s)) return;
              s.declare = true;
            }
            super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(g.DeclareClassElement, r) : s.value && this.raise(g.DeclareClassFieldInitializer, s.value));
          }
          isIterator(e) {
            return e === "iterator" || e === "asyncIterator";
          }
          readIterator() {
            let e = super.readWord1(), s = "@@" + e;
            (!this.isIterator(e) || !this.state.inType) && this.raise(p.InvalidIdentifier, this.state.curPosition(), { identifierName: s }), this.finishToken(132, s);
          }
          getTokenFromCode(e) {
            let s = this.input.charCodeAt(this.state.pos + 1);
            e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : wi2(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
          }
          isAssignable(e, s) {
            return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
          }
          toAssignable(e, s = false) {
            !s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
          }
          toAssignableList(e, s, i) {
            for (let r = 0; r < e.length; r++) {
              let n = e[r];
              (n == null ? void 0 : n.type) === "TypeCastExpression" && (e[r] = this.typeCastToParameter(n));
            }
            super.toAssignableList(e, s, i);
          }
          toReferencedList(e, s) {
            for (let r = 0; r < e.length; r++) {
              var i;
              let n = e[r];
              n && n.type === "TypeCastExpression" && !((i = n.extra) != null && i.parenthesized) && (e.length > 1 || !s) && this.raise(g.TypeCastInPattern, n.typeAnnotation);
            }
            return e;
          }
          parseArrayLike(e, s, i, r) {
            let n = super.parseArrayLike(e, s, i, r);
            return s && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
          }
          isValidLVal(e, s, i) {
            return e === "TypeCastExpression" || super.isValidLVal(e, s, i);
          }
          parseClassProperty(e) {
            return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
            return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e) {
            return !this.match(14) && super.isNonstaticConstructor(e);
          }
          pushClassMethod(e, s, i, r, n, o) {
            if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, r, n, o), s.params && n) {
              let h = s.params;
              h.length > 0 && this.isThisParam(h[0]) && this.raise(g.ThisParamBannedInConstructor, s);
            } else if (s.type === "MethodDefinition" && n && s.value.params) {
              let h = s.value.params;
              h.length > 0 && this.isThisParam(h[0]) && this.raise(g.ThisParamBannedInConstructor, s);
            }
          }
          pushClassPrivateMethod(e, s, i, r) {
            s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, r);
          }
          parseClassSuper(e) {
            if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
              this.next();
              let s = e.implements = [];
              do {
                let i = this.startNode();
                i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e) {
            super.checkGetterSetterParams(e);
            let s = this.getObjectOrClassMethodParams(e);
            if (s.length > 0) {
              let i = s[0];
              this.isThisParam(i) && e.kind === "get" ? this.raise(g.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(g.SetterMayNotHaveThisParam, i);
            }
          }
          parsePropertyNamePrefixOperator(e) {
            e.variance = this.flowParseVariance();
          }
          parseObjPropValue(e, s, i, r, n, o, h) {
            e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
            let c;
            this.match(47) && !o && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            let l = super.parseObjPropValue(e, s, i, r, n, o, h);
            return c && ((l.value || l).typeParameters = c), l;
          }
          parseAssignableListItemTypes(e) {
            return this.eat(17) && (e.type !== "Identifier" && this.raise(g.PatternIsOptional, e), this.isThisParam(e) && this.raise(g.ThisParamMayNotBeOptional, e), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(g.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(g.ThisParamNoDefault, e), this.resetEndLocation(e), e;
          }
          parseMaybeDefault(e, s) {
            let i = super.parseMaybeDefault(e, s);
            return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(g.TypeBeforeInitializer, i.typeAnnotation), i;
          }
          checkImportReflection(e) {
            super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(g.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e, s, i) {
            s.local = _t2(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
          }
          isPotentialImportPhase(e) {
            if (super.isPotentialImportPhase(e)) return true;
            if (this.isContextual(130)) {
              if (!e) return true;
              let s = this.lookaheadCharCode();
              return s === 123 || s === 42;
            }
            return !e && this.isContextual(87);
          }
          applyImportPhase(e, s, i, r) {
            if (super.applyImportPhase(e, s, i, r), s) {
              if (!i && this.match(65)) return;
              e.exportKind = i === "type" ? i : "value";
            } else i === "type" && this.match(55) && this.unexpected(), e.importKind = i === "type" || i === "typeof" ? i : "value";
          }
          parseImportSpecifier(e, s, i, r, n) {
            let o = e.imported, h = null;
            o.type === "Identifier" && (o.name === "type" ? h = "type" : o.name === "typeof" && (h = "typeof"));
            let c = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              let u = this.parseIdentifier(true);
              h !== null && !M(this.state.type) ? (e.imported = u, e.importKind = h, e.local = $(u)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
            } else {
              if (h !== null && M(this.state.type)) e.imported = this.parseIdentifier(true), e.importKind = h;
              else {
                if (s) throw this.raise(p.ImportBindingIsString, e, { importName: o.value });
                e.imported = o, e.importKind = null;
              }
              this.eatContextual(93) ? e.local = this.parseIdentifier() : (c = true, e.local = $(e.imported));
            }
            let l = _t2(e);
            return i && l && this.raise(g.ImportTypeShorthandOnlyInPureImport, e), (i || l) && this.checkReservedType(e.local.name, e.local.loc.start, true), c && !i && !l && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(e, s) {
            let i = e.kind;
            i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
          }
          parseVarId(e, s) {
            super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, s) {
            if (this.match(14)) {
              let i = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
            }
            return super.parseAsyncArrowFromCallExpression(e, s);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e, s) {
            var i;
            let r = null, n;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (r = this.state.clone(), n = this.tryParse(() => super.parseMaybeAssign(e, s), r), !n.error) return n.node;
              let { context: c } = this.state, l = c[c.length - 1];
              (l === C.j_oTag || l === C.j_expr) && c.pop();
            }
            if ((i = n) != null && i.error || this.match(47)) {
              var o, h;
              r = r || this.state.clone();
              let c, l = this.tryParse((f) => {
                var d2;
                c = this.flowParseTypeParameterDeclaration();
                let y2 = this.forwardNoArrowParamsConversionAt(c, () => {
                  let L = super.parseMaybeAssign(e, s);
                  return this.resetStartLocationFromNode(L, c), L;
                });
                (d2 = y2.extra) != null && d2.parenthesized && f();
                let E = this.maybeUnwrapTypeCastExpression(y2);
                return E.type !== "ArrowFunctionExpression" && f(), E.typeParameters = c, this.resetStartLocationFromNode(E, c), y2;
              }, r), u = null;
              if (l.node && this.maybeUnwrapTypeCastExpression(l.node).type === "ArrowFunctionExpression") {
                if (!l.error && !l.aborted) return l.node.async && this.raise(g.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), l.node;
                u = l.node;
              }
              if ((o = n) != null && o.node) return this.state = n.failState, n.node;
              if (u) return this.state = l.failState, u;
              throw (h = n) != null && h.thrown ? n.error : l.thrown ? l.error : this.raise(g.UnexpectedTokenAfterTypeParameter, c);
            }
            return super.parseMaybeAssign(e, s);
          }
          parseArrow(e) {
            if (this.match(14)) {
              let s = this.tryParse(() => {
                let i = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                let r = this.startNode();
                return [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
              });
              if (s.thrown) return null;
              s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(e);
          }
          shouldParseArrow(e) {
            return this.match(14) || super.shouldParseArrow(e);
          }
          setArrowFunctionParameters(e, s) {
            this.state.noArrowParamsConversionAt.includes(e.start) ? e.params = s : super.setArrowFunctionParameters(e, s);
          }
          checkParams(e, s, i, r = true) {
            if (!(i && this.state.noArrowParamsConversionAt.includes(e.start))) {
              for (let n = 0; n < e.params.length; n++) this.isThisParam(e.params[n]) && n > 0 && this.raise(g.ThisParamMustBeFirst, e.params[n]);
              super.checkParams(e, s, i, r);
            }
          }
          parseParenAndDistinguishExpression(e) {
            return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.state.start));
          }
          parseSubscripts(e, s, i) {
            if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.includes(s.index)) {
              this.next();
              let r = this.startNodeAt(s);
              r.callee = e, r.arguments = super.parseCallExpressionArguments(11, false), e = this.finishNode(r, "CallExpression");
            } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
              let r = this.state.clone(), n = this.tryParse((h) => this.parseAsyncArrowWithTypeParameters(s) || h(), r);
              if (!n.error && !n.aborted) return n.node;
              let o = this.tryParse(() => super.parseSubscripts(e, s, i), r);
              if (o.node && !o.error) return o.node;
              if (n.node) return this.state = n.failState, n.node;
              if (o.node) return this.state = o.failState, o.node;
              throw n.error || o.error;
            }
            return super.parseSubscripts(e, s, i);
          }
          parseSubscript(e, s, i, r) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (r.optionalChainMember = true, i) return r.stop = true, e;
              this.next();
              let n = this.startNodeAt(s);
              return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
            } else if (!i && this.shouldParseTypes() && this.match(47)) {
              let n = this.startNodeAt(s);
              n.callee = e;
              let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, false), r.optionalChainMember && (n.optional = false), this.finishCallExpression(n, r.optionalChainMember)));
              if (o.node) return o.error && (this.state = o.failState), o.node;
            }
            return super.parseSubscript(e, s, i, r);
          }
          parseNewCallee(e) {
            super.parseNewCallee(e);
            let s = null;
            this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
          }
          parseAsyncArrowWithTypeParameters(e) {
            let s = this.startNodeAt(e);
            if (this.parseFunctionParams(s, false), !!this.parseArrow(s)) return super.parseArrowExpression(s, void 0, true);
          }
          readToken_mult_modulo(e) {
            let s = this.input.charCodeAt(this.state.pos + 1);
            if (e === 42 && s === 47 && this.state.hasFlowComment) {
              this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
              return;
            }
            super.readToken_mult_modulo(e);
          }
          readToken_pipe_amp(e) {
            let s = this.input.charCodeAt(this.state.pos + 1);
            if (e === 124 && s === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(e);
          }
          parseTopLevel(e, s) {
            let i = super.parseTopLevel(e, s);
            return this.state.hasFlowComment && this.raise(g.UnterminatedFlowComment, this.state.curPosition()), i;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment) throw this.raise(g.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              let e = this.skipFlowComment();
              e && (this.state.pos += e, this.state.hasFlowComment = true);
              return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
          }
          skipFlowComment() {
            let { pos: e } = this.state, s = 2;
            for (; [32, 9].includes(this.input.charCodeAt(e + s)); ) s++;
            let i = this.input.charCodeAt(s + e), r = this.input.charCodeAt(s + e + 1);
            return i === 58 && r === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && r !== 58 ? s : false;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(p.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e, { enumName: s, memberName: i }) {
            this.raise(g.EnumBooleanMemberNotInitialized, e, { memberName: i, enumName: s });
          }
          flowEnumErrorInvalidMemberInitializer(e, s) {
            return this.raise(s.explicitType ? s.explicitType === "symbol" ? g.EnumInvalidMemberInitializerSymbolType : g.EnumInvalidMemberInitializerPrimaryType : g.EnumInvalidMemberInitializerUnknownType, e, s);
          }
          flowEnumErrorNumberMemberNotInitialized(e, s) {
            this.raise(g.EnumNumberMemberNotInitialized, e, s);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e, s) {
            this.raise(g.EnumStringMemberInconsistentlyInitialized, e, s);
          }
          flowEnumMemberInit() {
            let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 134: {
                let i = this.parseNumericLiteral(this.state.value);
                return s() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
              }
              case 133: {
                let i = this.parseStringLiteral(this.state.value);
                return s() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
              }
              case 85:
              case 86: {
                let i = this.parseBooleanLiteral(this.match(85));
                return s() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
              }
              default:
                return { type: "invalid", loc: e };
            }
          }
          flowEnumMemberRaw() {
            let e = this.state.startLoc, s = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
            return { id: s, init: i };
          }
          flowEnumCheckExplicitTypeMismatch(e, s, i) {
            let { explicitType: r } = s;
            r !== null && r !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
          }
          flowEnumMembers({ enumName: e, explicitType: s }) {
            let i = /* @__PURE__ */ new Set(), r = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                n = true;
                break;
              }
              let o = this.startNode(), { id: h, init: c } = this.flowEnumMemberRaw(), l = h.name;
              if (l === "") continue;
              /^[a-z]/.test(l) && this.raise(g.EnumInvalidMemberName, h, { memberName: l, suggestion: l[0].toUpperCase() + l.slice(1), enumName: e }), i.has(l) && this.raise(g.EnumDuplicateMemberName, h, { memberName: l, enumName: e }), i.add(l);
              let u = { enumName: e, explicitType: s, memberName: l };
              switch (o.id = h, c.type) {
                case "boolean": {
                  this.flowEnumCheckExplicitTypeMismatch(c.loc, u, "boolean"), o.init = c.value, r.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
                  break;
                }
                case "number": {
                  this.flowEnumCheckExplicitTypeMismatch(c.loc, u, "number"), o.init = c.value, r.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
                  break;
                }
                case "string": {
                  this.flowEnumCheckExplicitTypeMismatch(c.loc, u, "string"), o.init = c.value, r.stringMembers.push(this.finishNode(o, "EnumStringMember"));
                  break;
                }
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(c.loc, u);
                case "none":
                  switch (s) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(c.loc, u);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(c.loc, u);
                      break;
                    default:
                      r.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: r, hasUnknownMembers: n };
          }
          flowEnumStringMembers(e, s, { enumName: i }) {
            if (e.length === 0) return s;
            if (s.length === 0) return e;
            if (s.length > e.length) {
              for (let r of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
              return s;
            } else {
              for (let r of s) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
              return e;
            }
          }
          flowEnumParseExplicitType({ enumName: e }) {
            if (!this.eatContextual(102)) return null;
            if (!w(this.state.type)) throw this.raise(g.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
            let { value: s } = this.state;
            return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(g.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: s }), s;
          }
          flowEnumBody(e, s) {
            let i = s.name, r = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
            this.expect(5);
            let { members: o, hasUnknownMembers: h } = this.flowEnumMembers({ enumName: i, explicitType: n });
            switch (e.hasUnknownMembers = h, n) {
              case "boolean":
                return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
              case "number":
                return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
              case "string":
                return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
              case "symbol":
                return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
              default: {
                let c = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
                e.explicitType = false;
                let l = o.booleanMembers.length, u = o.numberMembers.length, f = o.stringMembers.length, d2 = o.defaultedMembers.length;
                if (!l && !u && !f && !d2) return c();
                if (!l && !u) return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                if (!u && !f && l >= d2) {
                  for (let y2 of o.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(y2.loc.start, { enumName: i, memberName: y2.id.name });
                  return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                } else if (!l && !f && u >= d2) {
                  for (let y2 of o.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(y2.loc.start, { enumName: i, memberName: y2.id.name });
                  return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                } else return this.raise(g.EnumInconsistentMemberValues, r, { enumName: i }), c();
              }
            }
          }
          flowParseEnumDeclaration(e) {
            let s = this.parseIdentifier();
            return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            let e = this.nextTokenStart();
            if (this.input.charCodeAt(e) === 60) {
              let s = this.input.charCodeAt(e + 1);
              return s !== 60 && s !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(e) {
            return e.type === "TypeCastExpression" ? e.expression : e;
          }
        }, W = j`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: a }) => `Expected corresponding JSX closing tag for <${a}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: a, HTMLEntity: t }) => `Unexpected token \`${a}\`. Did you mean \`${t}\` or \`{'${a}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function z(a) {
          return a ? a.type === "JSXOpeningFragment" || a.type === "JSXClosingFragment" : false;
        }
        function Y(a) {
          if (a.type === "JSXIdentifier") return a.name;
          if (a.type === "JSXNamespacedName") return a.namespace.name + ":" + a.name.name;
          if (a.type === "JSXMemberExpression") return Y(a.object) + "." + Y(a.property);
          throw new Error("Node had unexpected type: " + a.type);
        }
        var zi2 = (a) => class extends a {
          jsxReadToken() {
            let e = "", s = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(W.UnterminatedJsxContent, this.state.startLoc);
              let i = this.input.charCodeAt(this.state.pos);
              switch (i) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
                    return;
                  }
                  e += this.input.slice(s, this.state.pos), this.finishToken(141, e);
                  return;
                case 38:
                  e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  fe(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(e) {
            let s = this.input.charCodeAt(this.state.pos), i;
            return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
          }
          jsxReadString(e) {
            let s = "", i = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(p.UnterminatedString, this.state.startLoc);
              let r = this.input.charCodeAt(this.state.pos);
              if (r === e) break;
              r === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : fe(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
            }
            s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
          }
          jsxReadEntity() {
            let e = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let s = 10;
              this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
              let i = this.readInt(s, void 0, false, "bail");
              if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i);
            } else {
              let s = 0, i = false;
              for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
              if (i) {
                let r = this.input.slice(e, this.state.pos), n = void 0;
                if (++this.state.pos, n) return n;
              }
            }
            return this.state.pos = e, "&";
          }
          jsxReadWord() {
            let e, s = this.state.pos;
            do
              e = this.input.charCodeAt(++this.state.pos);
            while (Q3(e) || e === 45);
            this.finishToken(140, this.input.slice(s, this.state.pos));
          }
          jsxParseIdentifier() {
            let e = this.startNode();
            return this.match(140) ? e.name = this.state.value : Pt2(this.state.type) ? e.name = K(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            let e = this.state.startLoc, s = this.jsxParseIdentifier();
            if (!this.eat(14)) return s;
            let i = this.startNodeAt(e);
            return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
          }
          jsxParseElementName() {
            let e = this.state.startLoc, s = this.jsxParseNamespacedName();
            if (s.type === "JSXNamespacedName") return s;
            for (; this.eat(16); ) {
              let i = this.startNodeAt(e);
              i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
            }
            return s;
          }
          jsxParseAttributeValue() {
            let e;
            switch (this.state.type) {
              case 5:
                return e = this.startNode(), this.setContext(C.brace), this.next(), e = this.jsxParseExpressionContainer(e, C.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(W.AttributeIsEmpty, e), e;
              case 142:
              case 133:
                return this.parseExprAtom();
              default:
                throw this.raise(W.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            let e = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(e) {
            return this.next(), e.expression = this.parseExpression(), this.setContext(C.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(e, s) {
            if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
            else {
              let i = this.parseExpression();
              e.expression = i;
            }
            return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            let e = this.startNode();
            return this.match(5) ? (this.setContext(C.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(C.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(e) {
            let s = this.startNodeAt(e);
            return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
          }
          jsxParseOpeningElementAfterName(e) {
            let s = [];
            for (; !this.match(56) && !this.match(143); ) s.push(this.jsxParseAttribute());
            return e.attributes = s, e.selfClosing = this.eat(56), this.expect(143), this.finishNode(e, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(e) {
            let s = this.startNodeAt(e);
            return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(s, "JSXClosingElement"));
          }
          jsxParseElementAt(e) {
            let s = this.startNodeAt(e), i = [], r = this.jsxParseOpeningElementAt(e), n = null;
            if (!r.selfClosing) {
              e: for (; ; ) switch (this.state.type) {
                case 142:
                  if (e = this.state.startLoc, this.next(), this.eat(56)) {
                    n = this.jsxParseClosingElementAt(e);
                    break e;
                  }
                  i.push(this.jsxParseElementAt(e));
                  break;
                case 141:
                  i.push(this.parseLiteral(this.state.value, "JSXText"));
                  break;
                case 5: {
                  let o = this.startNode();
                  this.setContext(C.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, C.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
              z(r) && !z(n) && n !== null ? this.raise(W.MissingClosingTagFragment, n) : !z(r) && z(n) ? this.raise(W.MissingClosingTagElement, n, { openingTagName: Y(r.name) }) : !z(r) && !z(n) && Y(n.name) !== Y(r.name) && this.raise(W.MissingClosingTagElement, n, { openingTagName: Y(r.name) });
            }
            if (z(r) ? (s.openingFragment = r, s.closingFragment = n) : (s.openingElement = r, s.closingElement = n), s.children = i, this.match(47)) throw this.raise(W.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return z(r) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
          }
          jsxParseElement() {
            let e = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(e);
          }
          setContext(e) {
            let { context: s } = this.state;
            s[s.length - 1] = e;
          }
          parseExprAtom(e) {
            return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e) {
            let s = this.curContext();
            if (s === C.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (s === C.j_oTag || s === C.j_cTag) {
              if (_2(e)) {
                this.jsxReadWord();
                return;
              }
              if (e === 62) {
                ++this.state.pos, this.finishToken(143);
                return;
              }
              if ((e === 34 || e === 39) && s === C.j_oTag) {
                this.jsxReadString(e);
                return;
              }
            }
            if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos, this.finishToken(142);
              return;
            }
            super.getTokenFromCode(e);
          }
          updateContext(e) {
            let { context: s, type: i } = this.state;
            if (i === 56 && e === 142) s.splice(-2, 2, C.j_cTag), this.state.canStartJSXElement = false;
            else if (i === 142) s.push(C.j_oTag);
            else if (i === 143) {
              let r = s[s.length - 1];
              r === C.j_oTag && e === 56 || r === C.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === C.j_expr) : (this.setContext(C.j_expr), this.state.canStartJSXElement = true);
            } else this.state.canStartJSXElement = hi2(i);
          }
        }, ot = class extends de3 {
          constructor(...t) {
            super(...t), this.tsNames = /* @__PURE__ */ new Map();
          }
        }, ht2 = class extends me {
          constructor(...t) {
            super(...t), this.importsStack = [];
          }
          createScope(t) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new ot(t);
          }
          enter(t) {
            t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
          }
          exit() {
            let t = super.exit();
            return t === 256 && this.importsStack.pop(), t;
          }
          hasImport(t, e) {
            let s = this.importsStack.length;
            if (this.importsStack[s - 1].has(t)) return true;
            if (!e && s > 1) {
              for (let i = 0; i < s - 1; i++) if (this.importsStack[i].has(t)) return true;
            }
            return false;
          }
          declareName(t, e, s) {
            if (e & 4096) {
              this.hasImport(t, true) && this.parser.raise(p.VarRedeclaration, s, { identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
              return;
            }
            let i = this.currentScope(), r = i.tsNames.get(t) || 0;
            if (e & 1024) {
              this.maybeExportDefined(i, t), i.tsNames.set(t, r | 16);
              return;
            }
            super.declareName(t, e, s), e & 2 && (e & 1 || (this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t)), r = r | 1), e & 256 && (r = r | 2), e & 512 && (r = r | 4), e & 128 && (r = r | 8), r && i.tsNames.set(t, r);
          }
          isRedeclaredInScope(t, e, s) {
            let i = t.tsNames.get(e);
            if ((i & 2) > 0) {
              if (s & 256) {
                let r = !!(s & 512), n = (i & 4) > 0;
                return r !== n;
              }
              return true;
            }
            return s & 128 && (i & 8) > 0 ? t.names.get(e) & 2 ? !!(s & 1) : false : s & 2 && (i & 1) > 0 ? true : super.isRedeclaredInScope(t, e, s);
          }
          checkLocalExport(t) {
            let { name: e } = t;
            if (this.hasImport(e)) return;
            let s = this.scopeStack.length;
            for (let i = s - 1; i >= 0; i--) {
              let n = this.scopeStack[i].tsNames.get(e);
              if ((n & 1) > 0 || (n & 16) > 0) return;
            }
            super.checkLocalExport(t);
          }
        }, Ki2 = (a, t) => hasOwnProperty.call(a, t) && a[t], as = (a) => a.type === "ParenthesizedExpression" ? as(a.expression) : a, lt = class extends nt2 {
          toAssignable(t, e = false) {
            var s, i;
            let r;
            switch ((t.type === "ParenthesizedExpression" || (s = t.extra) != null && s.parenthesized) && (r = as(t), e ? r.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(p.InvalidParenthesizedAssignment, t) : r.type !== "MemberExpression" && !this.isOptionalMemberExpression(r) && this.raise(p.InvalidParenthesizedAssignment, t) : this.raise(p.InvalidParenthesizedAssignment, t)), t.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                t.type = "ObjectPattern";
                for (let o = 0, h = t.properties.length, c = h - 1; o < h; o++) {
                  var n;
                  let l = t.properties[o], u = o === c;
                  this.toAssignableObjectExpressionProp(l, u, e), u && l.type === "RestElement" && (n = t.extra) != null && n.trailingCommaLoc && this.raise(p.RestTrailingComma, t.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                let { key: o, value: h } = t;
                this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(h, e);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                t.type = "ArrayPattern", this.toAssignableList(t.elements, (i = t.extra) == null ? void 0 : i.trailingCommaLoc, e);
                break;
              case "AssignmentExpression":
                t.operator !== "=" && this.raise(p.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(r, e);
                break;
            }
          }
          toAssignableObjectExpressionProp(t, e, s) {
            if (t.type === "ObjectMethod") this.raise(t.kind === "get" || t.kind === "set" ? p.PatternHasAccessor : p.PatternHasMethod, t.key);
            else if (t.type === "SpreadElement") {
              t.type = "RestElement";
              let i = t.argument;
              this.checkToRestConversion(i, false), this.toAssignable(i, s), e || this.raise(p.RestTrailingComma, t);
            } else this.toAssignable(t, s);
          }
          toAssignableList(t, e, s) {
            let i = t.length - 1;
            for (let r = 0; r <= i; r++) {
              let n = t[r];
              if (n) {
                if (n.type === "SpreadElement") {
                  n.type = "RestElement";
                  let o = n.argument;
                  this.checkToRestConversion(o, true), this.toAssignable(o, s);
                } else this.toAssignable(n, s);
                n.type === "RestElement" && (r < i ? this.raise(p.RestTrailingComma, n) : e && this.raise(p.RestTrailingComma, e));
              }
            }
          }
          isAssignable(t, e) {
            switch (t.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                let s = t.properties.length - 1;
                return t.properties.every((i, r) => i.type !== "ObjectMethod" && (r === s || i.type !== "SpreadElement") && this.isAssignable(i));
              }
              case "ObjectProperty":
                return this.isAssignable(t.value);
              case "SpreadElement":
                return this.isAssignable(t.argument);
              case "ArrayExpression":
                return t.elements.every((s) => s === null || this.isAssignable(s));
              case "AssignmentExpression":
                return t.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(t.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e;
              default:
                return false;
            }
          }
          toReferencedList(t, e) {
            return t;
          }
          toReferencedListDeep(t, e) {
            this.toReferencedList(t, e);
            for (let s of t) (s == null ? void 0 : s.type) === "ArrayExpression" && this.toReferencedListDeep(s.elements);
          }
          parseSpread(t) {
            let e = this.startNode();
            return this.next(), e.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(e, "SpreadElement");
          }
          parseRestBinding() {
            let t = this.startNode();
            return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                let t = this.startNode();
                return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(t, e, s) {
            let i = s & 1, r = [], n = true;
            for (; !this.eat(t); ) if (n ? n = false : this.expect(12), i && this.match(12)) r.push(null);
            else {
              if (this.eat(t)) break;
              if (this.match(21)) {
                if (r.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(e)) {
                  this.expect(t);
                  break;
                }
              } else {
                let o = [];
                for (this.match(26) && this.hasPlugin("decorators") && this.raise(p.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) o.push(this.parseDecorator());
                r.push(this.parseAssignableListItem(s, o));
              }
            }
            return r;
          }
          parseBindingRestProperty(t) {
            return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
          }
          parseBindingProperty() {
            let { type: t, startLoc: e } = this.state;
            if (t === 21) return this.parseBindingRestProperty(this.startNode());
            let s = this.startNode();
            return t === 138 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), s.key = this.parsePrivateName()) : this.parsePropertyName(s), s.method = false, this.parseObjPropValue(s, e, false, false, true, false);
          }
          parseAssignableListItem(t, e) {
            let s = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s, t);
            let i = this.parseMaybeDefault(s.loc.start, s);
            return e.length && (s.decorators = e), i;
          }
          parseAssignableListItemTypes(t, e) {
            return t;
          }
          parseMaybeDefault(t, e) {
            var s, i;
            if ((s = t) != null || (t = this.state.startLoc), e = (i = e) != null ? i : this.parseBindingAtom(), !this.eat(29)) return e;
            let r = this.startNodeAt(t);
            return r.left = e, r.right = this.parseMaybeAssignAllowIn(), this.finishNode(r, "AssignmentPattern");
          }
          isValidLVal(t, e, s) {
            return Ki2({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
          }
          isOptionalMemberExpression(t) {
            return t.type === "OptionalMemberExpression";
          }
          checkLVal(t, { in: e, binding: s = 64, checkClashes: i = false, strictModeChanged: r = false, hasParenthesizedAncestor: n = false }) {
            var o;
            let h = t.type;
            if (this.isObjectMethod(t)) return;
            let c = this.isOptionalMemberExpression(t);
            if (c || h === "MemberExpression") {
              c && (this.expectPlugin("optionalChainingAssign", t.loc.start), e.type !== "AssignmentExpression" && this.raise(p.InvalidLhsOptionalChaining, t, { ancestor: e })), s !== 64 && this.raise(p.InvalidPropertyBindingPattern, t);
              return;
            }
            if (h === "Identifier") {
              this.checkIdentifier(t, s, r);
              let { name: y2 } = t;
              i && (i.has(y2) ? this.raise(p.ParamDupe, t) : i.add(y2));
              return;
            }
            let l = this.isValidLVal(h, !(n || (o = t.extra) != null && o.parenthesized) && e.type === "AssignmentExpression", s);
            if (l === true) return;
            if (l === false) {
              let y2 = s === 64 ? p.InvalidLhs : p.InvalidLhsBinding;
              this.raise(y2, t, { ancestor: e });
              return;
            }
            let [u, f] = Array.isArray(l) ? l : [l, h === "ParenthesizedExpression"], d2 = h === "ArrayPattern" || h === "ObjectPattern" ? { type: h } : e;
            for (let y2 of [].concat(t[u])) y2 && this.checkLVal(y2, { in: d2, binding: s, checkClashes: i, strictModeChanged: r, hasParenthesizedAncestor: f });
          }
          checkIdentifier(t, e, s = false) {
            this.state.strict && (s ? Zt2(t.name, this.inModule) : Qt2(t.name)) && (e === 64 ? this.raise(p.StrictEvalArguments, t, { referenceName: t.name }) : this.raise(p.StrictEvalArgumentsBinding, t, { bindingName: t.name })), e & 8192 && t.name === "let" && this.raise(p.LetInLexicalBinding, t), e & 64 || this.declareNameFromIdentifier(t, e);
          }
          declareNameFromIdentifier(t, e) {
            this.scope.declareName(t.name, e, t.loc.start);
          }
          checkToRestConversion(t, e) {
            switch (t.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(t.expression, e);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (e) break;
              default:
                this.raise(p.InvalidRestAssignmentPattern, t);
            }
          }
          checkCommaAfterRest(t) {
            return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? p.RestTrailingComma : p.ElementAfterRest, this.state.startLoc), true) : false;
          }
        }, Hi2 = (a, t) => hasOwnProperty.call(a, t) && a[t];
        function Wi2(a) {
          if (a == null) throw new Error(`Unexpected ${a} value.`);
          return a;
        }
        function jt(a) {
          if (!a) throw new Error("Assert fail");
        }
        var x = j`typescript`({ AbstractMethodHasImplementation: ({ methodName: a }) => `Method '${a}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: a }) => `Property '${a}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: a }) => `'declare' is not allowed in ${a}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: a }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: a }) => `Duplicate modifier: '${a}'.`, EmptyHeritageClauseType: ({ token: a }) => `'${a}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: a }) => `'${a[0]}' modifier cannot be used with '${a[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: a }) => `Index signatures cannot have an accessibility modifier ('${a}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: a }) => `'${a}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: a }) => `'${a}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: a }) => `'${a}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: a }) => `'${a[0]}' modifier must precede '${a[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: a }) => `Private elements cannot have an accessibility modifier ('${a}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: a }) => `Single type parameter ${a} should have a trailing comma. Example usage: <${a},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: a }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${a}.` });
        function Ji(a) {
          switch (a) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return;
          }
        }
        function $t(a) {
          return a === "private" || a === "public" || a === "protected";
        }
        function Xi2(a) {
          return a === "in" || a === "out";
        }
        var Gi2 = (a) => class extends a {
          constructor(...e) {
            super(...e), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: x.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return ht2;
          }
          tsIsIdentifier() {
            return w(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(e, s) {
            if (!w(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
            let i = this.state.value;
            if (e.includes(i)) {
              if (s && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return i;
            }
          }
          tsParseModifiers({ allowedModifiers: e, disallowedModifiers: s, stopOnStartOfClassStaticBlock: i, errorTemplate: r = x.InvalidModifierOnTypeMember }, n) {
            let o = (c, l, u, f) => {
              l === u && n[f] && this.raise(x.InvalidModifiersOrder, c, { orderedModifiers: [u, f] });
            }, h = (c, l, u, f) => {
              (n[u] && l === f || n[f] && l === u) && this.raise(x.IncompatibleModifiers, c, { modifiers: [u, f] });
            };
            for (; ; ) {
              let { startLoc: c } = this.state, l = this.tsParseModifier(e.concat(s ?? []), i);
              if (!l) break;
              $t(l) ? n.accessibility ? this.raise(x.DuplicateAccessibilityModifier, c, { modifier: l }) : (o(c, l, l, "override"), o(c, l, l, "static"), o(c, l, l, "readonly"), n.accessibility = l) : Xi2(l) ? (n[l] && this.raise(x.DuplicateModifier, c, { modifier: l }), n[l] = true, o(c, l, "in", "out")) : (hasOwnProperty.call(n, l) ? this.raise(x.DuplicateModifier, c, { modifier: l }) : (o(c, l, "static", "readonly"), o(c, l, "static", "override"), o(c, l, "override", "readonly"), o(c, l, "abstract", "override"), h(c, l, "declare", "override"), h(c, l, "static", "abstract")), n[l] = true), s != null && s.includes(l) && this.raise(r, c, { modifier: l });
            }
          }
          tsIsListTerminator(e) {
            switch (e) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(e, s) {
            let i = [];
            for (; !this.tsIsListTerminator(e); ) i.push(s());
            return i;
          }
          tsParseDelimitedList(e, s, i) {
            return Wi2(this.tsParseDelimitedListWorker(e, s, true, i));
          }
          tsParseDelimitedListWorker(e, s, i, r) {
            let n = [], o = -1;
            for (; !this.tsIsListTerminator(e); ) {
              o = -1;
              let h = s();
              if (h == null) return;
              if (n.push(h), this.eat(12)) {
                o = this.state.lastTokStartLoc.index;
                continue;
              }
              if (this.tsIsListTerminator(e)) break;
              i && this.expect(12);
              return;
            }
            return r && (r.value = o), n;
          }
          tsParseBracketedList(e, s, i, r, n) {
            r || (i ? this.expect(0) : this.expect(47));
            let o = this.tsParseDelimitedList(e, s, n);
            return i ? this.expect(3) : this.expect(48), o;
          }
          tsParseImportType() {
            let e = this.startNode();
            return this.expect(83), this.expect(10), this.match(133) || this.raise(x.UnsupportedImportTypeArgument, this.state.startLoc), e.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
          }
          tsParseEntityName(e = true) {
            let s = this.parseIdentifier(e);
            for (; this.eat(16); ) {
              let i = this.startNodeAtNode(s);
              i.left = s, i.right = this.parseIdentifier(e), s = this.finishNode(i, "TSQualifiedName");
            }
            return s;
          }
          tsParseTypeReference() {
            let e = this.startNode();
            return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
          }
          tsParseThisTypePredicate(e) {
            this.next();
            let s = this.startNodeAtNode(e);
            return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            let e = this.startNode();
            return this.next(), this.finishNode(e, "TSThisType");
          }
          tsParseTypeQuery() {
            let e = this.startNode();
            return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
          }
          tsParseTypeParameter(e) {
            let s = this.startNode();
            return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
          }
          tsTryParseTypeParameters(e) {
            if (this.match(47)) return this.tsParseTypeParameters(e);
          }
          tsParseTypeParameters(e) {
            let s = this.startNode();
            this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i = { value: -1 };
            return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s.params.length === 0 && this.raise(x.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
          }
          tsFillSignature(e, s) {
            let i = e === 19, r = "parameters", n = "typeAnnotation";
            s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[r] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
          }
          tsParseBindingListForSignature() {
            let e = super.parseBindingList(11, 41, 2);
            for (let s of e) {
              let { type: i } = s;
              (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(x.UnsupportedSignatureParameterKind, s, { type: i });
            }
            return e;
          }
          tsParseTypeMemberSemicolon() {
            !this.eat(12) && !this.isLineTerminator() && this.expect(13);
          }
          tsParseSignatureMember(e, s) {
            return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), w(this.state.type) ? (this.next(), this.match(14)) : false;
          }
          tsTryParseIndexSignature(e) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
            this.expect(0);
            let s = this.parseIdentifier();
            s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
            let i = this.tsTryParseTypeAnnotation();
            return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(e, s) {
            this.eat(17) && (e.optional = true);
            let i = e;
            if (this.match(10) || this.match(47)) {
              s && this.raise(x.ReadonlyForMethodSignature, e);
              let r = i;
              r.kind && this.match(47) && this.raise(x.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon();
              let n = "parameters", o = "typeAnnotation";
              if (r.kind === "get") r[n].length > 0 && (this.raise(p.BadGetterArity, this.state.curPosition()), this.isThisParam(r[n][0]) && this.raise(x.AccesorCannotDeclareThisParameter, this.state.curPosition()));
              else if (r.kind === "set") {
                if (r[n].length !== 1) this.raise(p.BadSetterArity, this.state.curPosition());
                else {
                  let h = r[n][0];
                  this.isThisParam(h) && this.raise(x.AccesorCannotDeclareThisParameter, this.state.curPosition()), h.type === "Identifier" && h.optional && this.raise(x.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), h.type === "RestElement" && this.raise(x.SetAccesorCannotHaveRestParameter, this.state.curPosition());
                }
                r[o] && this.raise(x.SetAccesorCannotHaveReturnType, r[o]);
              } else r.kind = "method";
              return this.finishNode(r, "TSMethodSignature");
            } else {
              let r = i;
              s && (r.readonly = true);
              let n = this.tsTryParseTypeAnnotation();
              return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            let e = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
            if (this.match(77)) {
              let i = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e);
            let s = this.tsTryParseIndexSignature(e);
            return s || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
          }
          tsParseTypeLiteral() {
            let e = this.startNode();
            return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), e;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
          }
          tsParseMappedTypeParameter() {
            let e = this.startNode();
            return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
          }
          tsParseMappedType() {
            let e = this.startNode();
            return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
          }
          tsParseTupleType() {
            let e = this.startNode();
            e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let s = false;
            return e.elementTypes.forEach((i) => {
              let { type: r } = i;
              s && r !== "TSRestType" && r !== "TSOptionalType" && !(r === "TSNamedTupleMember" && i.optional) && this.raise(x.OptionalTypeBeforeRequired, i), s || (s = r === "TSNamedTupleMember" && i.optional || r === "TSOptionalType");
            }), this.finishNode(e, "TSTupleType");
          }
          tsParseTupleElementType() {
            let { startLoc: e } = this.state, s = this.eat(21), i, r, n, o, c = M(this.state.type) ? this.lookaheadCharCode() : null;
            if (c === 58) i = true, n = false, r = this.parseIdentifier(true), this.expect(14), o = this.tsParseType();
            else if (c === 63) {
              n = true;
              let l = this.state.startLoc, u = this.state.value, f = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (i = true, r = this.createIdentifier(this.startNodeAt(l), u), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = false, o = f, this.expect(17));
            } else o = this.tsParseType(), n = this.eat(17), i = this.eat(14);
            if (i) {
              let l;
              r ? (l = this.startNodeAtNode(r), l.optional = n, l.label = r, l.elementType = o, this.eat(17) && (l.optional = true, this.raise(x.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (l = this.startNodeAtNode(o), l.optional = n, this.raise(x.InvalidTupleMemberLabel, o), l.label = o, l.elementType = this.tsParseType()), o = this.finishNode(l, "TSNamedTupleMember");
            } else if (n) {
              let l = this.startNodeAtNode(o);
              l.typeAnnotation = o, o = this.finishNode(l, "TSOptionalType");
            }
            if (s) {
              let l = this.startNodeAt(e);
              l.typeAnnotation = o, o = this.finishNode(l, "TSRestType");
            }
            return o;
          }
          tsParseParenthesizedType() {
            let e = this.startNode();
            return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(e, s) {
            let i = this.startNode();
            return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
          }
          tsParseLiteralTypeNode() {
            let e = this.startNode();
            switch (this.state.type) {
              case 134:
              case 135:
              case 133:
              case 85:
              case 86:
                e.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            let e = this.startNode();
            return e.literal = super.parseTemplate(false), this.finishNode(e, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            let e = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 133:
              case 134:
              case 135:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  let e = this.startNode(), s = this.lookahead();
                  return s.type !== 134 && s.type !== 135 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                let { type: e } = this.state;
                if (w(e) || e === 88 || e === 84) {
                  let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : Ji(this.state.value);
                  if (s !== void 0 && this.lookaheadCharCode() !== 46) {
                    let i = this.startNode();
                    return this.next(), this.finishNode(i, s);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let e = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              let s = this.startNodeAtNode(e);
              s.elementType = e, this.expect(3), e = this.finishNode(s, "TSArrayType");
            } else {
              let s = this.startNodeAtNode(e);
              s.objectType = e, s.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s, "TSIndexedAccessType");
            }
            return e;
          }
          tsParseTypeOperator() {
            let e = this.startNode(), s = this.state.value;
            return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(e) {
            switch (e.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(x.UnexpectedReadonly, e);
            }
          }
          tsParseInferType() {
            let e = this.startNode();
            this.expectContextual(115);
            let s = this.startNode();
            return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
            }
          }
          tsParseTypeOperatorOrHigher() {
            return di(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e, s, i) {
            let r = this.startNode(), n = this.eat(i), o = [];
            do
              o.push(s());
            while (this.eat(i));
            return o.length === 1 && !n ? o[0] : (r.types = o, this.finishNode(r, e));
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (w(this.state.type) || this.match(78)) return this.next(), true;
            if (this.match(5)) {
              let { errors: e } = this.state, s = e.length;
              try {
                return this.parseObjectLike(8, true), e.length === s;
              } catch {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              let { errors: e } = this.state, s = e.length;
              try {
                return super.parseBindingList(3, 93, 1), e.length === s;
              } catch {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(e) {
            return this.tsInType(() => {
              let s = this.startNode();
              this.expect(e);
              let i = this.startNode(), r = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r && this.match(78)) {
                let h = this.tsParseThisTypeOrThisTypePredicate();
                return h.type === "TSThisType" ? (i.parameterName = h, i.asserts = true, i.typeAnnotation = null, h = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(h, i), h.asserts = true), s.typeAnnotation = h, this.finishNode(s, "TSTypeAnnotation");
              }
              let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!n) return r ? (i.parameterName = this.parseIdentifier(), i.asserts = r, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
              let o = this.tsParseTypeAnnotation(false);
              return i.parameterName = n, i.typeAnnotation = o, i.asserts = r, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            let e = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109) return false;
            let e = this.state.containsEsc;
            return this.next(), !w(this.state.type) && !this.match(78) ? false : (e && this.raise(p.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(e = true, s = this.startNode()) {
            return this.tsInType(() => {
              e && this.expect(14), s.typeAnnotation = this.tsParseType();
            }), this.finishNode(s, "TSTypeAnnotation");
          }
          tsParseType() {
            jt(this.state.inType);
            let e = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
            let s = this.startNodeAtNode(e);
            return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x.ReservedTypeAssertion, this.state.startLoc);
            let e = this.startNode();
            return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
          }
          tsParseHeritageClause(e) {
            let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
              let r = this.startNode();
              return r.expression = this.tsParseEntityName(), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSExpressionWithTypeArguments");
            });
            return i.length || this.raise(x.EmptyHeritageClauseType, s, { token: e }), i;
          }
          tsParseInterfaceDeclaration(e, s = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129), s.declare && (e.declare = true), w(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 130)) : (e.id = null, this.raise(x.MissingInterfaceName, this.state.startLoc)), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
            let i = this.startNode();
            return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(e) {
            return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 2), e.typeAnnotation = this.tsInType(() => {
              if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                let s = this.startNode();
                return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
          }
          tsInNoContext(e) {
            let s = this.state.context;
            this.state.context = [s[0]];
            try {
              return e();
            } finally {
              this.state.context = s;
            }
          }
          tsInType(e) {
            let s = this.state.inType;
            this.state.inType = true;
            try {
              return e();
            } finally {
              this.state.inType = s;
            }
          }
          tsInDisallowConditionalTypesContext(e) {
            let s = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e();
            } finally {
              this.state.inDisallowConditionalTypesContext = s;
            }
          }
          tsInAllowConditionalTypesContext(e) {
            let s = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e();
            } finally {
              this.state.inDisallowConditionalTypesContext = s;
            }
          }
          tsEatThenParseType(e) {
            if (this.match(e)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e) {
            return this.tsInType(() => (this.expect(e), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            let e = this.startNode();
            return e.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
          }
          tsParseEnumDeclaration(e, s = {}) {
            return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(126), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            let e = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(e, s = false) {
            if (e.id = this.parseIdentifier(), s || this.checkIdentifier(e.id, 1024), this.eat(16)) {
              let i = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(i, true), e.body = i;
            } else this.scope.enter(256), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(e, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(e) {
            return this.isContextual(112) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(133) ? e.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(e, s, i) {
            e.isExport = i || false, e.id = s || this.parseIdentifier(), this.checkIdentifier(e.id, 4096), this.expect(29);
            let r = this.tsParseModuleReference();
            return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(x.ImportAliasHasImportType, r), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            let e = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e, "TSExternalModuleReference");
          }
          tsLookAhead(e) {
            let s = this.state.clone(), i = e();
            return this.state = s, i;
          }
          tsTryParseAndCatch(e) {
            let s = this.tryParse((i) => e() || i());
            if (!(s.aborted || !s.node)) return s.error && (this.state = s.failState), s.node;
          }
          tsTryParse(e) {
            let s = this.state.clone(), i = e();
            if (i !== void 0 && i !== false) return i;
            this.state = s;
          }
          tsTryParseDeclare(e) {
            if (this.isLineTerminator()) return;
            let s = this.state.type, i;
            return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
              switch (s) {
                case 68:
                  return e.declare = true, super.parseFunctionStatement(e, false, false);
                case 80:
                  return e.declare = true, this.parseClass(e, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(e, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(e);
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, i || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
                case 129: {
                  let r = this.tsParseInterfaceDeclaration(e, { declare: true });
                  if (r) return r;
                }
                default:
                  if (w(s)) return this.tsParseDeclaration(e, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(e, s, i) {
            switch (s.name) {
              case "declare": {
                let r = this.tsTryParseDeclare(e);
                return r && (r.declare = true), r;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  let r = e;
                  return r.global = true, r.id = s, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(e, s.name, false, i);
            }
          }
          tsParseDeclaration(e, s, i, r) {
            switch (s) {
              case "abstract":
                if (this.tsCheckLineTerminator(i) && (this.match(80) || w(this.state.type))) return this.tsParseAbstractDeclaration(e, r);
                break;
              case "module":
                if (this.tsCheckLineTerminator(i)) {
                  if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(e);
                  if (w(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(i) && w(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
                break;
              case "type":
                if (this.tsCheckLineTerminator(i) && w(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
                break;
            }
          }
          tsCheckLineTerminator(e) {
            return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e) {
            if (!this.match(47)) return;
            let s = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            let i = this.tsTryParseAndCatch(() => {
              let r = this.startNodeAt(e);
              return r.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(r), r.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), r;
            });
            if (this.state.maybeInArrowParameters = s, !!i) return super.parseArrowExpression(i, null, true);
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            let e = this.startNode();
            return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 ? this.raise(x.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === C.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return mi2(this.state.type);
          }
          isExportDefaultSpecifier() {
            return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e, s) {
            let i = this.state.startLoc, r = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, r);
            let n = r.accessibility, o = r.override, h = r.readonly;
            !(e & 4) && (n || h || o) && this.raise(x.UnexpectedParameterModifier, i);
            let c = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(c, e);
            let l = this.parseMaybeDefault(c.loc.start, c);
            if (n || h || o) {
              let u = this.startNodeAt(i);
              return s.length && (u.decorators = s), n && (u.accessibility = n), h && (u.readonly = h), o && (u.override = o), l.type !== "Identifier" && l.type !== "AssignmentPattern" && this.raise(x.UnsupportedParameterPropertyKind, u), u.parameter = l, this.finishNode(u, "TSParameterProperty");
            }
            return s.length && (c.decorators = s), l;
          }
          isSimpleParameter(e) {
            return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
          }
          tsDisallowOptionalPattern(e) {
            for (let s of e.params) s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(x.PatternIsOptional, s);
          }
          setArrowFunctionParameters(e, s, i) {
            super.setArrowFunctionParameters(e, s, i), this.tsDisallowOptionalPattern(e);
          }
          parseFunctionBodyAndFinish(e, s, i = false) {
            this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            let r = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return r && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, r) : r === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(x.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, r, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s, i));
          }
          registerFunctionStatementId(e) {
            !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
          }
          tsCheckForInvalidTypeCasts(e) {
            e.forEach((s) => {
              (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(x.UnexpectedTypeAnnotation, s.typeAnnotation);
            });
          }
          toReferencedList(e, s) {
            return this.tsCheckForInvalidTypeCasts(e), e;
          }
          parseArrayLike(e, s, i, r) {
            let n = super.parseArrayLike(e, s, i, r);
            return n.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n.elements), n;
          }
          parseSubscript(e, s, i, r) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              let o = this.startNodeAt(s);
              return o.expression = e, this.finishNode(o, "TSNonNullExpression");
            }
            let n = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (i) return r.stop = true, e;
              r.optionalChainMember = n = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let o, h = this.tsTryParseAndCatch(() => {
                if (!i && this.atPossibleAsyncArrow(e)) {
                  let f = this.tsTryParseGenericAsyncArrowFunction(s);
                  if (f) return f;
                }
                let c = this.tsParseTypeArgumentsInExpression();
                if (!c) return;
                if (n && !this.match(10)) {
                  o = this.state.curPosition();
                  return;
                }
                if (Le2(this.state.type)) {
                  let f = super.parseTaggedTemplateExpression(e, s, r);
                  return f.typeParameters = c, f;
                }
                if (!i && this.eat(10)) {
                  let f = this.startNodeAt(s);
                  return f.callee = e, f.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(f.arguments), f.typeParameters = c, r.optionalChainMember && (f.optional = n), this.finishCallExpression(f, r.optionalChainMember);
                }
                let l = this.state.type;
                if (l === 48 || l === 52 || l !== 10 && He2(l) && !this.hasPrecedingLineBreak()) return;
                let u = this.startNodeAt(s);
                return u.expression = e, u.typeParameters = c, this.finishNode(u, "TSInstantiationExpression");
              });
              if (o && this.unexpected(o, 10), h) return h.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(x.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), h;
            }
            return super.parseSubscript(e, s, i, r);
          }
          parseNewCallee(e) {
            var s;
            super.parseNewCallee(e);
            let { callee: i } = e;
            i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (e.typeParameters = i.typeParameters, e.callee = i.expression);
          }
          parseExprOp(e, s, i) {
            let r;
            if (Ie(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r = this.isContextual(120)))) {
              let n = this.startNodeAt(s);
              return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r && this.raise(p.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, r ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
            }
            return super.parseExprOp(e, s, i);
          }
          checkReservedWord(e, s, i, r) {
            this.state.isAmbientContext || super.checkReservedWord(e, s, i, r);
          }
          checkImportReflection(e) {
            super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(x.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(e) {
            if (super.isPotentialImportPhase(e)) return true;
            if (this.isContextual(130)) {
              let s = this.lookaheadCharCode();
              return e ? s === 123 || s === 42 : s !== 61;
            }
            return !e && this.isContextual(87);
          }
          applyImportPhase(e, s, i, r) {
            super.applyImportPhase(e, s, i, r), s ? e.exportKind = i === "type" ? "type" : "value" : e.importKind = i === "type" || i === "typeof" ? i : "value";
          }
          parseImport(e) {
            if (this.match(133)) return e.importKind = "value", super.parseImport(e);
            let s;
            if (w(this.state.type) && this.lookaheadCharCode() === 61) return e.importKind = "value", this.tsParseImportEqualsDeclaration(e);
            if (this.isContextual(130)) {
              let i = this.parseMaybeImportPhase(e, false);
              if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(e, i);
              s = super.parseImportSpecifiersAndAfter(e, i);
            } else s = super.parseImport(e);
            return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(x.TypeImportCannotSpecifyDefaultAndNamed, s), s;
          }
          parseExport(e, s) {
            if (this.match(83)) {
              this.next();
              let i = e, r = null;
              return this.isContextual(130) && this.isPotentialImportPhase(false) ? r = this.parseMaybeImportPhase(i, false) : i.importKind = "value", this.tsParseImportEqualsDeclaration(i, r, true);
            } else if (this.eat(29)) {
              let i = e;
              return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(i, "TSExportAssignment");
            } else if (this.eatContextual(93)) {
              let i = e;
              return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
            } else return super.parseExport(e, s);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              let e = this.startNode();
              return this.next(), e.abstract = true, this.parseClass(e, true, true);
            }
            if (this.match(129)) {
              let e = this.tsParseInterfaceDeclaration(this.startNode());
              if (e) return e;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e, s, i = false) {
            let { isAmbientContext: r } = this.state, n = super.parseVarStatement(e, s, i || r);
            if (!r) return n;
            for (let { id: o, init: h } of n.declarations) h && (s !== "const" || o.typeAnnotation ? this.raise(x.InitializerNotAllowedInAmbientContext, h) : Qi(h, this.hasPlugin("estree")) || this.raise(x.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, h));
            return n;
          }
          parseStatementContent(e, s) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              let i = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
            }
            if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              let i = this.tsParseInterfaceDeclaration(this.startNode());
              if (i) return i;
            }
            return super.parseStatementContent(e, s);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(e, s) {
            return s.some((i) => $t(i) ? e.accessibility === i : !!e[i]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(e, s, i) {
            let r = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: r, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: x.InvalidModifierOnTypeParameterPositions }, s);
            let n = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, r) && this.raise(x.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
            };
            s.declare ? this.tsInAmbientContext(n) : n();
          }
          parseClassMemberWithIsStatic(e, s, i, r) {
            let n = this.tsTryParseIndexSignature(s);
            if (n) {
              e.body.push(n), s.abstract && this.raise(x.IndexSignatureHasAbstract, s), s.accessibility && this.raise(x.IndexSignatureHasAccessibility, s, { modifier: s.accessibility }), s.declare && this.raise(x.IndexSignatureHasDeclare, s), s.override && this.raise(x.IndexSignatureHasOverride, s);
              return;
            }
            !this.state.inAbstractClass && s.abstract && this.raise(x.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.raise(x.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(e, s, i, r);
          }
          parsePostMemberNameModifiers(e) {
            this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(x.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(x.ClassMethodHasDeclare, e);
          }
          parseExpressionStatement(e, s, i) {
            return (s.type === "Identifier" ? this.tsParseExpressionStatement(e, s, i) : void 0) || super.parseExpressionStatement(e, s, i);
          }
          shouldParseExportDeclaration() {
            return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
          }
          parseConditional(e, s, i) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, s, i);
            let r = this.tryParse(() => super.parseConditional(e, s));
            return r.node ? (r.error && (this.state = r.failState), r.node) : (r.error && super.setOptionalParametersError(i, r.error), e);
          }
          parseParenItem(e, s) {
            let i = super.parseParenItem(e, s);
            if (this.eat(17) && (i.optional = true, this.resetEndLocation(e)), this.match(14)) {
              let r = this.startNodeAt(s);
              return r.expression = e, r.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r, "TSTypeCastExpression");
            }
            return e;
          }
          parseExportDeclaration(e) {
            if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
            let s = this.state.startLoc, i = this.eatContextual(125);
            if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(x.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            let n = w(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
            return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s), n.declare = true), n) : null;
          }
          parseClassId(e, s, i, r) {
            if ((!s || i) && this.isContextual(113)) return;
            super.parseClassId(e, s, i, e.declare ? 1024 : 8331);
            let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            n && (e.typeParameters = n);
          }
          parseClassPropertyAnnotation(e) {
            e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
            let s = this.tsTryParseTypeAnnotation();
            s && (e.typeAnnotation = s);
          }
          parseClassProperty(e) {
            if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(x.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29)) {
              let { key: s } = e;
              this.raise(x.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(s.start, s.end)}]` });
            }
            return super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
            return e.abstract && this.raise(x.PrivateElementHasAbstract, e), e.accessibility && this.raise(x.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
          }
          parseClassAccessorProperty(e) {
            return this.parseClassPropertyAnnotation(e), e.optional && this.raise(x.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
          }
          pushClassMethod(e, s, i, r, n, o) {
            let h = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            h && n && this.raise(x.ConstructorHasTypeParameters, h);
            let { declare: c = false, kind: l } = s;
            c && (l === "get" || l === "set") && this.raise(x.DeclareAccessor, s, { kind: l }), h && (s.typeParameters = h), super.pushClassMethod(e, s, i, r, n, o);
          }
          pushClassPrivateMethod(e, s, i, r) {
            let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, r);
          }
          declareClassPrivateMethodInScope(e, s) {
            e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !hasOwnProperty.call(e.value, "body") || super.declareClassPrivateMethodInScope(e, s));
          }
          parseClassSuper(e) {
            super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(e, s, i, r, n, o, h) {
            let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return c && (e.typeParameters = c), super.parseObjPropValue(e, s, i, r, n, o, h);
          }
          parseFunctionParams(e, s) {
            let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            i && (e.typeParameters = i), super.parseFunctionParams(e, s);
          }
          parseVarId(e, s) {
            super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
            let i = this.tsTryParseTypeAnnotation();
            i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, s) {
            return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
          }
          parseMaybeAssign(e, s) {
            var i, r, n, o, h;
            let c, l, u;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (c = this.state.clone(), l = this.tryParse(() => super.parseMaybeAssign(e, s), c), !l.error) return l.node;
              let { context: y2 } = this.state, E = y2[y2.length - 1];
              (E === C.j_oTag || E === C.j_expr) && y2.pop();
            }
            if (!((i = l) != null && i.error) && !this.match(47)) return super.parseMaybeAssign(e, s);
            (!c || c === this.state) && (c = this.state.clone());
            let f, d2 = this.tryParse((y2) => {
              var E, L;
              f = this.tsParseTypeParameters(this.tsParseConstModifier);
              let S = super.parseMaybeAssign(e, s);
              return (S.type !== "ArrowFunctionExpression" || (E = S.extra) != null && E.parenthesized) && y2(), ((L = f) == null ? void 0 : L.params.length) !== 0 && this.resetStartLocationFromNode(S, f), S.typeParameters = f, S;
            }, c);
            if (!d2.error && !d2.aborted) return f && this.reportReservedArrowTypeParam(f), d2.node;
            if (!l && (jt(!this.hasPlugin("jsx")), u = this.tryParse(() => super.parseMaybeAssign(e, s), c), !u.error)) return u.node;
            if ((r = l) != null && r.node) return this.state = l.failState, l.node;
            if (d2.node) return this.state = d2.failState, f && this.reportReservedArrowTypeParam(f), d2.node;
            if ((n = u) != null && n.node) return this.state = u.failState, u.node;
            throw ((o = l) == null ? void 0 : o.error) || d2.error || ((h = u) == null ? void 0 : h.error);
          }
          reportReservedArrowTypeParam(e) {
            var s;
            e.params.length === 1 && !e.params[0].constraint && !((s = e.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x.ReservedArrowTypeParam, e);
          }
          parseMaybeUnary(e, s) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
          }
          parseArrow(e) {
            if (this.match(14)) {
              let s = this.tryParse((i) => {
                let r = this.tsParseTypeOrTypePredicateAnnotation(14);
                return (this.canInsertSemicolon() || !this.match(19)) && i(), r;
              });
              if (s.aborted) return;
              s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
            }
            return super.parseArrow(e);
          }
          parseAssignableListItemTypes(e, s) {
            if (!(s & 2)) return e;
            this.eat(17) && (e.optional = true);
            let i = this.tsTryParseTypeAnnotation();
            return i && (e.typeAnnotation = i), this.resetEndLocation(e), e;
          }
          isAssignable(e, s) {
            switch (e.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(e.expression, s);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(e, s);
            }
          }
          toAssignable(e, s = false) {
            switch (e.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(e, s);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                s ? this.expressionScope.recordArrowParameterBindingError(x.UnexpectedTypeCastInParameter, e) : this.raise(x.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, s);
                break;
              case "AssignmentExpression":
                !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
              default:
                super.toAssignable(e, s);
            }
          }
          toAssignableParenthesizedExpression(e, s) {
            switch (e.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(e.expression, s);
                break;
              default:
                super.toAssignable(e, s);
            }
          }
          checkToRestConversion(e, s) {
            switch (e.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(e.expression, false);
                break;
              default:
                super.checkToRestConversion(e, s);
            }
          }
          isValidLVal(e, s, i) {
            return Hi2({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSInstantiationExpression: "expression", TSAsExpression: (i !== 64 || !s) && ["expression", true], TSSatisfiesExpression: (i !== 64 || !s) && ["expression", true], TSTypeAssertion: (i !== 64 || !s) && ["expression", true] }, e) || super.isValidLVal(e, s, i);
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e) {
            if (this.match(47) || this.match(51)) {
              let s = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                let i = super.parseMaybeDecoratorArguments(e);
                return i.typeParameters = s, i;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e);
          }
          checkCommaAfterRest(e) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e, s) {
            let i = super.parseMaybeDefault(e, s);
            return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(x.TypeAnnotationAfterAssign, i.typeAnnotation), i;
          }
          getTokenFromCode(e) {
            if (this.state.inType) {
              if (e === 62) {
                this.finishOp(48, 1);
                return;
              }
              if (e === 60) {
                this.finishOp(47, 1);
                return;
              }
            }
            super.getTokenFromCode(e);
          }
          reScan_lt_gt() {
            let { type: e } = this.state;
            e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            let { type: e } = this.state;
            return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
          }
          toAssignableList(e, s, i) {
            for (let r = 0; r < e.length; r++) {
              let n = e[r];
              (n == null ? void 0 : n.type) === "TSTypeCastExpression" && (e[r] = this.typeCastToParameter(n));
            }
            super.toAssignableList(e, s, i);
          }
          typeCastToParameter(e) {
            return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          shouldParseArrow(e) {
            return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e) {
            if (this.match(47) || this.match(51)) {
              let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              s && (e.typeParameters = s);
            }
            return super.jsxParseOpeningElementAfterName(e);
          }
          getGetterSetterExpectedParamCount(e) {
            let s = super.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e)[0];
            return r && this.isThisParam(r) ? s + 1 : s;
          }
          parseCatchClauseParam() {
            let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
            return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
          }
          tsInAmbientContext(e) {
            let { isAmbientContext: s, strict: i } = this.state;
            this.state.isAmbientContext = true, this.state.strict = false;
            try {
              return e();
            } finally {
              this.state.isAmbientContext = s, this.state.strict = i;
            }
          }
          parseClass(e, s, i) {
            let r = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e.abstract;
            try {
              return super.parseClass(e, s, i);
            } finally {
              this.state.inAbstractClass = r;
            }
          }
          tsParseAbstractDeclaration(e, s) {
            if (this.match(80)) return e.abstract = true, this.maybeTakeDecorators(s, this.parseClass(e, true, false));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak()) return e.abstract = true, this.raise(x.NonClassMethodPropertyHasAbstractModifer, e), this.tsParseInterfaceDeclaration(e);
            } else this.unexpected(null, 80);
          }
          parseMethod(e, s, i, r, n, o, h) {
            let c = super.parseMethod(e, s, i, r, n, o, h);
            if (c.abstract && (this.hasPlugin("estree") ? !!c.value.body : !!c.body)) {
              let { key: u } = c;
              this.raise(x.AbstractMethodHasImplementation, c, { methodName: u.type === "Identifier" && !c.computed ? u.name : `[${this.input.slice(u.start, u.end)}]` });
            }
            return c;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(e, s, i, r) {
            return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, r));
          }
          parseImportSpecifier(e, s, i, r, n) {
            return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, r, i ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e, s, i) {
            let r = s ? "imported" : "local", n = s ? "local" : "exported", o = e[r], h, c = false, l = true, u = o.loc.start;
            if (this.isContextual(93)) {
              let d2 = this.parseIdentifier();
              if (this.isContextual(93)) {
                let y2 = this.parseIdentifier();
                M(this.state.type) ? (c = true, o = d2, h = s ? this.parseIdentifier() : this.parseModuleExportName(), l = false) : (h = y2, l = false);
              } else M(this.state.type) ? (l = false, h = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = true, o = d2);
            } else M(this.state.type) && (c = true, s ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
            c && i && this.raise(s ? x.TypeModifierIsUsedInTypeImports : x.TypeModifierIsUsedInTypeExports, u), e[r] = o, e[n] = h;
            let f = s ? "importKind" : "exportKind";
            e[f] = c ? "type" : "value", l && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = $(e[r])), s && this.checkIdentifier(e[n], c ? 4098 : 4096);
          }
        };
        function Yi2(a) {
          if (a.type !== "MemberExpression") return false;
          let { computed: t, property: e } = a;
          return t && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : os2(a.object);
        }
        function Qi(a, t) {
          var e;
          let { type: s } = a;
          if ((e = a.extra) != null && e.parenthesized) return false;
          if (t) {
            if (s === "Literal") {
              let { value: i } = a;
              if (typeof i == "string" || typeof i == "boolean") return true;
            }
          } else if (s === "StringLiteral" || s === "BooleanLiteral") return true;
          return !!(ns2(a, t) || Zi2(a, t) || s === "TemplateLiteral" && a.expressions.length === 0 || Yi2(a));
        }
        function ns2(a, t) {
          return t ? a.type === "Literal" && (typeof a.value == "number" || "bigint" in a) : a.type === "NumericLiteral" || a.type === "BigIntLiteral";
        }
        function Zi2(a, t) {
          if (a.type === "UnaryExpression") {
            let { operator: e, argument: s } = a;
            if (e === "-" && ns2(s, t)) return true;
          }
          return false;
        }
        function os2(a) {
          return a.type === "Identifier" ? true : a.type !== "MemberExpression" || a.computed ? false : os2(a.object);
        }
        var Vt2 = j`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), er = (a) => class extends a {
          parsePlaceholder(e) {
            if (this.match(144)) {
              let s = this.startNode();
              return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(s, e);
            }
          }
          finishPlaceholder(e, s) {
            let i = e;
            return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
          }
          getTokenFromCode(e) {
            e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(e);
          }
          parseExprAtom(e) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
          }
          parseIdentifier(e) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
          }
          checkReservedWord(e, s, i, r) {
            e !== void 0 && super.checkReservedWord(e, s, i, r);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(e, s, i) {
            return e === "Placeholder" || super.isValidLVal(e, s, i);
          }
          toAssignable(e, s) {
            e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
          }
          chStartsBindingIdentifier(e, s) {
            return !!(super.chStartsBindingIdentifier(e, s) || this.lookahead().type === 144);
          }
          verifyBreakContinue(e, s) {
            e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
          }
          parseExpressionStatement(e, s) {
            var i;
            if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized) return super.parseExpressionStatement(e, s);
            if (this.match(14)) {
              let n = e;
              return n.label = this.finishPlaceholder(s, "Identifier"), this.next(), n.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(n, "LabeledStatement");
            }
            this.semicolon();
            let r = e;
            return r.name = s.name, this.finishPlaceholder(r, "Statement");
          }
          parseBlock(e, s, i) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
          }
          parseFunctionId(e) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
          }
          parseClass(e, s, i) {
            let r = s ? "ClassDeclaration" : "ClassExpression";
            this.next();
            let n = this.state.strict, o = this.parsePlaceholder("Identifier");
            if (o) if (this.match(81) || this.match(144) || this.match(5)) e.id = o;
            else {
              if (i || !s) return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, r);
              throw this.raise(Vt2.ClassNameIsRequired, this.state.startLoc);
            }
            else this.parseClassId(e, s, i);
            return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, r);
          }
          parseExport(e, s) {
            let i = this.parsePlaceholder("Identifier");
            if (!i) return super.parseExport(e, s);
            let r = e;
            if (!this.isContextual(98) && !this.match(12)) return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(r, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            let n = this.startNode();
            return n.exported = i, r.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], super.parseExport(r, s);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let e = this.nextTokenStart();
              if (this.isUnparsedContextual(e, "from") && this.input.startsWith(K(144), this.nextTokenStartSince(e + 4))) return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e, s) {
            var i;
            return (i = e.specifiers) != null && i.length ? true : super.maybeParseExportDefaultSpecifier(e, s);
          }
          checkExport(e) {
            let { specifiers: s } = e;
            s != null && s.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
          }
          parseImport(e) {
            let s = this.parsePlaceholder("Identifier");
            if (!s) return super.parseImport(e);
            if (e.specifiers = [], !this.isContextual(98) && !this.match(12)) return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
            let i = this.startNodeAtNode(s);
            return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(Vt2.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        }, tr2 = (a) => class extends a {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let e = this.state.startLoc, s = this.startNode();
              if (this.next(), w(this.state.type)) {
                let i = this.parseIdentifierName(), r = this.createIdentifier(s, i);
                if (r.type = "V8IntrinsicIdentifier", this.match(10)) return r;
              }
              this.unexpected(e);
            }
          }
          parseExprAtom(e) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e);
          }
        };
        function N2(a, t) {
          let [e, s] = typeof t == "string" ? [t, {}] : t, i = Object.keys(s), r = i.length === 0;
          return a.some((n) => {
            if (typeof n == "string") return r && n === e;
            {
              let [o, h] = n;
              if (o !== e) return false;
              for (let c of i) if (h[c] !== s[c]) return false;
              return true;
            }
          });
        }
        function J(a, t, e) {
          let s = a.find((i) => Array.isArray(i) ? i[0] === t : i === t);
          return s && Array.isArray(s) && s.length > 1 ? s[1][e] : null;
        }
        var qt2 = ["minimal", "fsharp", "hack", "smart"], zt = ["^^", "@@", "^", "%", "#"];
        function sr2(a) {
          if (N2(a, "decorators")) {
            if (N2(a, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            let t = J(a, "decorators", "decoratorsBeforeExport");
            if (t != null && typeof t != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
            let e = J(a, "decorators", "allowCallParenthesized");
            if (e != null && typeof e != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
          }
          if (N2(a, "flow") && N2(a, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
          if (N2(a, "placeholders") && N2(a, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          if (N2(a, "pipelineOperator")) {
            let t = J(a, "pipelineOperator", "proposal");
            if (!qt2.includes(t)) {
              let i = qt2.map((r) => `"${r}"`).join(", ");
              throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
            }
            let e = ["recordAndTuple", { syntaxType: "hash" }], s = N2(a, e);
            if (t === "hack") {
              if (N2(a, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
              if (N2(a, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
              let i = J(a, "pipelineOperator", "topicToken");
              if (!zt.includes(i)) {
                let r = zt.map((n) => `"${n}"`).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${r}.`);
              }
              if (i === "#" && s) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(e)}\`.`);
            } else if (t === "smart" && s) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(e)}\`.`);
          }
          if (N2(a, "moduleAttributes")) {
            if (N2(a, "importAssertions") || N2(a, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
            if (J(a, "moduleAttributes", "version") !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
          if (N2(a, "importAssertions") && N2(a, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
          if (N2(a, "recordAndTuple")) {
            let t = J(a, "recordAndTuple", "syntaxType");
            if (t != null) {
              let e = ["hash", "bar"];
              if (!e.includes(t)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e.map((s) => `'${s}'`).join(", "));
            }
          }
          if (N2(a, "asyncDoExpressions") && !N2(a, "doExpressions")) {
            let t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw t.missingPlugins = "doExpressions", t;
          }
          if (N2(a, "optionalChainingAssign") && J(a, "optionalChainingAssign", "version") !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        }
        var hs2 = { estree: ri2, jsx: zi2, flow: qi, typescript: Gi2, v8intrinsic: tr2, placeholders: er }, ir2 = Object.keys(hs2), qe = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
        function rr2(a) {
          if (a == null) return Object.assign({}, qe);
          if (a.annexB != null && a.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
          let t = {};
          for (let s of Object.keys(qe)) {
            var e;
            t[s] = (e = a[s]) != null ? e : qe[s];
          }
          return t;
        }
        var ct = class extends lt {
          checkProto(t, e, s, i) {
            if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand) return;
            let r = t.key;
            if ((r.type === "Identifier" ? r.name : r.value) === "__proto__") {
              if (e) {
                this.raise(p.RecordNoProto, r);
                return;
              }
              s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = r.loc.start) : this.raise(p.DuplicateProto, r)), s.used = true;
            }
          }
          shouldExitDescending(t, e) {
            return t.type === "ArrowFunctionExpression" && t.start === e;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            let t = this.parseExpression();
            return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
          }
          parseExpression(t, e) {
            return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
          }
          parseExpressionBase(t) {
            let e = this.state.startLoc, s = this.parseMaybeAssign(t);
            if (this.match(12)) {
              let i = this.startNodeAt(e);
              for (i.expressions = [s]; this.eat(12); ) i.expressions.push(this.parseMaybeAssign(t));
              return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
            }
            return s;
          }
          parseMaybeAssignDisallowIn(t, e) {
            return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
          }
          parseMaybeAssignAllowIn(t, e) {
            return this.allowInAnd(() => this.parseMaybeAssign(t, e));
          }
          setOptionalParametersError(t, e) {
            var s;
            t.optionalParametersLoc = (s = e == null ? void 0 : e.loc) != null ? s : this.state.startLoc;
          }
          parseMaybeAssign(t, e) {
            let s = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
              let o = this.parseYield();
              return e && (o = e.call(this, o, s)), o;
            }
            let i;
            t ? i = false : (t = new Z(), i = true);
            let { type: r } = this.state;
            (r === 10 || w(r)) && (this.state.potentialArrowAt = this.state.start);
            let n = this.parseMaybeConditional(t);
            if (e && (n = e.call(this, n, s)), li(this.state.type)) {
              let o = this.startNodeAt(s), h = this.state.value;
              if (o.operator = h, this.match(29)) {
                this.toAssignable(n, true), o.left = n;
                let c = s.index;
                t.doubleProtoLoc != null && t.doubleProtoLoc.index >= c && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= c && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= c && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
              } else o.left = n;
              return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(n, { in: this.finishNode(o, "AssignmentExpression") }), o;
            } else i && this.checkExpressionErrors(t, true);
            return n;
          }
          parseMaybeConditional(t) {
            let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(t);
            return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, e, t);
          }
          parseConditional(t, e, s) {
            if (this.eat(17)) {
              let i = this.startNodeAt(e);
              return i.test = t, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
            }
            return t;
          }
          parseMaybeUnaryOrPrivate(t) {
            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
          }
          parseExprOps(t) {
            let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(t);
            return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, e, -1);
          }
          parseExprOp(t, e, s) {
            if (this.isPrivateName(t)) {
              let r = this.getPrivateNameSV(t);
              (s >= Ie(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(p.PrivateInExpectedIn, t, { identifierName: r }), this.classScope.usePrivateName(r, t.loc.start);
            }
            let i = this.state.type;
            if (pi(i) && (this.prodParam.hasIn || !this.match(58))) {
              let r = Ie(i);
              if (r > s) {
                if (i === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
                  this.checkPipelineAtInfixOperator(t, e);
                }
                let n = this.startNodeAt(e);
                n.left = t, n.operator = this.state.value;
                let o = i === 41 || i === 42, h = i === 40;
                if (h && (r = Ie(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(p.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                n.right = this.parseExprOpRightExpr(i, r);
                let c = this.finishNode(n, o || h ? "LogicalExpression" : "BinaryExpression"), l = this.state.type;
                if (h && (l === 41 || l === 42) || o && l === 40) throw this.raise(p.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(c, e, s);
              }
            }
            return t;
          }
          parseExprOpRightExpr(t, e) {
            let s = this.state.startLoc;
            switch (t) {
              case 39:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "hack":
                    return this.withTopicBindingContext(() => this.parseHackPipeBody());
                  case "smart":
                    return this.withTopicBindingContext(() => {
                      if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(p.PipeBodyIsTighter, this.state.startLoc);
                      return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, e), s);
                    });
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
                }
              default:
                return this.parseExprOpBaseRightExpr(t, e);
            }
          }
          parseExprOpBaseRightExpr(t, e) {
            let s = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, yi2(t) ? e - 1 : e);
          }
          parseHackPipeBody() {
            var t;
            let { startLoc: e } = this.state, s = this.parseMaybeAssign();
            return Qs.has(s.type) && !((t = s.extra) != null && t.parenthesized) && this.raise(p.PipeUnparenthesizedBody, e, { type: s.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipeTopicUnused, e), s;
          }
          checkExponentialAfterUnary(t) {
            this.match(57) && this.raise(p.UnexpectedTokenUnaryExponentiation, t.argument);
          }
          parseMaybeUnary(t, e) {
            let s = this.state.startLoc, i = this.isContextual(96);
            if (i && this.isAwaitAllowed()) {
              this.next();
              let h = this.parseAwait(s);
              return e || this.checkExponentialAfterUnary(h), h;
            }
            let r = this.match(34), n = this.startNode();
            if (fi2(this.state.type)) {
              n.operator = this.state.value, n.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              let h = this.match(89);
              if (this.next(), n.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && h) {
                let c = n.argument;
                c.type === "Identifier" ? this.raise(p.StrictDelete, n) : this.hasPropertyAsPrivateName(c) && this.raise(p.DeletePrivateField, n);
              }
              if (!r) return e || this.checkExponentialAfterUnary(n), this.finishNode(n, "UnaryExpression");
            }
            let o = this.parseUpdate(n, r, t);
            if (i) {
              let { type: h } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? He2(h) : He2(h) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(p.AwaitNotInAsyncContext, s), this.parseAwait(s);
            }
            return o;
          }
          parseUpdate(t, e, s) {
            if (e) {
              let n = t;
              return this.checkLVal(n.argument, { in: this.finishNode(n, "UpdateExpression") }), t;
            }
            let i = this.state.startLoc, r = this.parseExprSubscripts(s);
            if (this.checkExpressionErrors(s, false)) return r;
            for (; ui(this.state.type) && !this.canInsertSemicolon(); ) {
              let n = this.startNodeAt(i);
              n.operator = this.state.value, n.prefix = false, n.argument = r, this.next(), this.checkLVal(r, { in: r = this.finishNode(n, "UpdateExpression") });
            }
            return r;
          }
          parseExprSubscripts(t) {
            let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(t);
            return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, e);
          }
          parseSubscripts(t, e, s) {
            let i = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
            do
              t = this.parseSubscript(t, e, s, i), i.maybeAsyncArrow = false;
            while (!i.stop);
            return t;
          }
          parseSubscript(t, e, s, i) {
            let { type: r } = this.state;
            if (!s && r === 15) return this.parseBind(t, e, s, i);
            if (Le2(r)) return this.parseTaggedTemplateExpression(t, e, i);
            let n = false;
            if (r === 18) {
              if (s && (this.raise(p.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return i.stop = true, t;
              i.optionalChainMember = n = true, this.next();
            }
            if (!s && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(t, e, i, n);
            {
              let o = this.eat(0);
              return o || n || this.eat(16) ? this.parseMember(t, e, i, o, n) : (i.stop = true, t);
            }
          }
          parseMember(t, e, s, i, r) {
            let n = this.startNodeAt(e);
            return n.object = t, n.computed = i, i ? (n.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" && this.raise(p.SuperPrivateField, e), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) : n.property = this.parseIdentifier(true), s.optionalChainMember ? (n.optional = r, this.finishNode(n, "OptionalMemberExpression")) : this.finishNode(n, "MemberExpression");
          }
          parseBind(t, e, s, i) {
            let r = this.startNodeAt(e);
            return r.object = t, this.next(), r.callee = this.parseNoCallExpr(), i.stop = true, this.parseSubscripts(this.finishNode(r, "BindExpression"), e, s);
          }
          parseCoverCallAndAsyncArrowHead(t, e, s, i) {
            let r = this.state.maybeInArrowParameters, n = null;
            this.state.maybeInArrowParameters = true, this.next();
            let o = this.startNodeAt(e);
            o.callee = t;
            let { maybeAsyncArrow: h, optionalChainMember: c } = s;
            h && (this.expressionScope.enter(Fi2()), n = new Z()), c && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, n);
            let l = this.finishCallExpression(o, c);
            return h && this.shouldParseAsyncArrow() && !i ? (s.stop = true, this.checkDestructuringPrivate(n), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e), l)) : (h && (this.checkExpressionErrors(n, true), this.expressionScope.exit()), this.toReferencedArguments(l)), this.state.maybeInArrowParameters = r, l;
          }
          toReferencedArguments(t, e) {
            this.toReferencedListDeep(t.arguments, e);
          }
          parseTaggedTemplateExpression(t, e, s) {
            let i = this.startNodeAt(e);
            return i.tag = t, i.quasi = this.parseTemplate(true), s.optionalChainMember && this.raise(p.OptionalChainingNoTemplate, e), this.finishNode(i, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(t) {
            return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(t, e) {
            if (t.callee.type === "Import") if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 || t.arguments.length > 2) this.raise(p.ImportCallArity, t, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
            else for (let s of t.arguments) s.type === "SpreadElement" && this.raise(p.ImportCallSpreadArgument, s);
            return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(t, e, s, i, r) {
            let n = [], o = true, h = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
              if (o) o = false;
              else if (this.expect(12), this.match(t)) {
                e && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(p.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
                break;
              }
              n.push(this.parseExprListItem(false, r, s));
            }
            return this.state.inFSharpPipelineDirectBody = h, n;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(t, e) {
            var s;
            return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, true, (s = e.extra) == null ? void 0 : s.trailingCommaLoc), e.innerComments && ye(t, e.innerComments), e.callee.trailingComments && ye(t, e.callee.trailingComments), t;
          }
          parseNoCallExpr() {
            let t = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t, true);
          }
          parseExprAtom(t) {
            let e, s = null, { type: i } = this.state;
            switch (i) {
              case 79:
                return this.parseSuper();
              case 83:
                return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(e) : this.finishNode(e, "Import") : (this.raise(p.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e, "Import"));
              case 78:
                return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 134:
                return this.parseNumericLiteral(this.state.value);
              case 135:
                return this.parseBigIntLiteral(this.state.value);
              case 136:
                return this.parseDecimalLiteral(this.state.value);
              case 133:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                let r = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(r);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, t);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, t);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                s = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                e = this.startNode(), this.next(), e.object = null;
                let r = e.callee = this.parseNoCallExpr();
                if (r.type === "MemberExpression") return this.finishNode(e, "BindExpression");
                throw this.raise(p.UnsupportedBind, r);
              }
              case 138:
                return this.raise(p.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                let r = this.getPluginOption("pipelineOperator", "proposal");
                if (r) return this.parseTopicReference(r);
                this.unexpected();
                break;
              }
              case 47: {
                let r = this.input.codePointAt(this.nextTokenStart());
                _2(r) || r === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (w(i)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
                  let r = this.state.potentialArrowAt === this.state.start, n = this.state.containsEsc, o = this.parseIdentifier();
                  if (!n && o.name === "async" && !this.canInsertSemicolon()) {
                    let { type: h } = this.state;
                    if (h === 68) return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
                    if (w(h)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
                    if (h === 90) return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), true);
                  }
                  return r && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], false)) : o;
                } else this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(t, e) {
            let s = this.getPluginOption("pipelineOperator", "proposal");
            if (s) return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = v2(this.state.endLoc, -1), this.parseTopicReference(s);
            this.unexpected();
          }
          parseTopicReference(t) {
            let e = this.startNode(), s = this.state.startLoc, i = this.state.type;
            return this.next(), this.finishTopicReference(e, s, t, i);
          }
          finishTopicReference(t, e, s, i) {
            if (this.testTopicReferenceConfiguration(s, e, i)) {
              let r = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? p.PrimaryTopicNotAllowed : p.PipeTopicUnbound, e), this.registerTopicReference(), this.finishNode(t, r);
            } else throw this.raise(p.PipeTopicUnconfiguredToken, e, { token: K(i) });
          }
          testTopicReferenceConfiguration(t, e, s) {
            switch (t) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: K(s) }]);
              case "smart":
                return s === 27;
              default:
                throw this.raise(p.PipeTopicRequiresHackPipes, e);
            }
          }
          parseAsyncArrowUnaryFunction(t) {
            this.prodParam.enter(ke2(true, this.prodParam.hasYield));
            let e = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(p.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, e, true);
          }
          parseDo(t, e) {
            this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
            let s = this.state.labels;
            return this.state.labels = [], e ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = s, this.finishNode(t, "DoExpression");
          }
          parseSuper() {
            let t = this.startNode();
            return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(p.SuperNotAllowed, t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(p.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(p.UnsupportedSuper, t), this.finishNode(t, "Super");
          }
          parsePrivateName() {
            let t = this.startNode(), e = this.startNodeAt(v2(this.state.startLoc, 1)), s = this.state.value;
            return this.next(), t.id = this.createIdentifier(e, s), this.finishNode(t, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            let t = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              let e = this.createIdentifier(this.startNodeAtNode(t), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
            }
            return this.parseFunction(t);
          }
          parseMetaProperty(t, e, s) {
            t.meta = e;
            let i = this.state.containsEsc;
            return t.property = this.parseIdentifier(true), (t.property.name !== s || i) && this.raise(p.UnsupportedMetaProperty, t.property, { target: e.name, onlyValidPropertyName: s }), this.finishNode(t, "MetaProperty");
          }
          parseImportMetaProperty(t) {
            let e = this.createIdentifier(this.startNodeAtNode(t), "import");
            if (this.next(), this.isContextual(101)) this.inModule || this.raise(p.ImportMetaOutsideModule, e), this.sawUnambiguousESM = true;
            else if (this.isContextual(105) || this.isContextual(97)) {
              let s = this.isContextual(105);
              if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(p.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
              return this.next(), t.phase = s ? "source" : "defer", this.parseImportCall(t);
            }
            return this.parseMetaProperty(t, e, "meta");
          }
          parseLiteralAtNode(t, e, s) {
            return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = t, this.next(), this.finishNode(s, e);
          }
          parseLiteral(t, e) {
            let s = this.startNode();
            return this.parseLiteralAtNode(t, e, s);
          }
          parseStringLiteral(t) {
            return this.parseLiteral(t, "StringLiteral");
          }
          parseNumericLiteral(t) {
            return this.parseLiteral(t, "NumericLiteral");
          }
          parseBigIntLiteral(t) {
            return this.parseLiteral(t, "BigIntLiteral");
          }
          parseDecimalLiteral(t) {
            return this.parseLiteral(t, "DecimalLiteral");
          }
          parseRegExpLiteral(t) {
            let e = this.startNode();
            return this.addExtra(e, "raw", this.input.slice(e.start, this.state.end)), e.pattern = t.pattern, e.flags = t.flags, this.next(), this.finishNode(e, "RegExpLiteral");
          }
          parseBooleanLiteral(t) {
            let e = this.startNode();
            return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
          }
          parseNullLiteral() {
            let t = this.startNode();
            return this.next(), this.finishNode(t, "NullLiteral");
          }
          parseParenAndDistinguishExpression(t) {
            let e = this.state.startLoc, s;
            this.next(), this.expressionScope.enter(Oi2());
            let i = this.state.maybeInArrowParameters, r = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            let n = this.state.startLoc, o = [], h = new Z(), c = true, l, u;
            for (; !this.match(11); ) {
              if (c) c = false;
              else if (this.expect(12, h.optionalParametersLoc === null ? null : h.optionalParametersLoc), this.match(11)) {
                u = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                let y2 = this.state.startLoc;
                if (l = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), y2)), !this.checkCommaAfterRest(41)) break;
              } else o.push(this.parseMaybeAssignAllowIn(h, this.parseParenItem));
            }
            let f = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = r;
            let d2 = this.startNodeAt(e);
            return t && this.shouldParseArrow(o) && (d2 = this.parseArrow(d2)) ? (this.checkDestructuringPrivate(h), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d2, o, false), d2) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), u && this.unexpected(u), l && this.unexpected(l), this.checkExpressionErrors(h, true), this.toReferencedListDeep(o, true), o.length > 1 ? (s = this.startNodeAt(n), s.expressions = o, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s, f)) : s = o[0], this.wrapParenthesis(e, s));
          }
          wrapParenthesis(t, e) {
            if (!this.options.createParenthesizedExpressions) return this.addExtra(e, "parenthesized", true), this.addExtra(e, "parenStart", t.index), this.takeSurroundingComments(e, t.index, this.state.lastTokEndLoc.index), e;
            let s = this.startNodeAt(t);
            return s.expression = e, this.finishNode(s, "ParenthesizedExpression");
          }
          shouldParseArrow(t) {
            return !this.canInsertSemicolon();
          }
          parseArrow(t) {
            if (this.eat(19)) return t;
          }
          parseParenItem(t, e) {
            return t;
          }
          parseNewOrNewTarget() {
            let t = this.startNode();
            if (this.next(), this.match(16)) {
              let e = this.createIdentifier(this.startNodeAtNode(t), "new");
              this.next();
              let s = this.parseMetaProperty(t, e, "target");
              return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(p.UnexpectedNewTarget, s), s;
            }
            return this.parseNew(t);
          }
          parseNew(t) {
            if (this.parseNewCallee(t), this.eat(10)) {
              let e = this.parseExprList(11);
              this.toReferencedList(e), t.arguments = e;
            } else t.arguments = [];
            return this.finishNode(t, "NewExpression");
          }
          parseNewCallee(t) {
            let e = this.match(83), s = this.parseNoCallExpr();
            t.callee = s, e && (s.type === "Import" || s.type === "ImportExpression") && this.raise(p.ImportCallNotNewExpression, s);
          }
          parseTemplateElement(t) {
            let { start: e, startLoc: s, end: i, value: r } = this.state, n = e + 1, o = this.startNodeAt(v2(s, 1));
            r === null && (t || this.raise(p.InvalidEscapeSequenceTemplate, v2(this.state.firstInvalidTemplateEscapePos, 1)));
            let h = this.match(24), c = h ? -1 : -2, l = i + c;
            o.value = { raw: this.input.slice(n, l).replace(/\r\n?/g, `
`), cooked: r === null ? null : r.slice(1, c) }, o.tail = h, this.next();
            let u = this.finishNode(o, "TemplateElement");
            return this.resetEndLocation(u, v2(this.state.lastTokEndLoc, c)), u;
          }
          parseTemplate(t) {
            let e = this.startNode(), s = this.parseTemplateElement(t), i = [s], r = [];
            for (; !s.tail; ) r.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(t));
            return e.expressions = r, e.quasis = i, this.finishNode(e, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(t, e, s, i) {
            s && this.expectPlugin("recordAndTuple");
            let r = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n = /* @__PURE__ */ Object.create(null), o = true, h = this.startNode();
            for (h.properties = [], this.next(); !this.match(t); ) {
              if (o) o = false;
              else if (this.expect(12), this.match(t)) {
                this.addTrailingCommaExtraToNode(h);
                break;
              }
              let l;
              e ? l = this.parseBindingProperty() : (l = this.parsePropertyDefinition(i), this.checkProto(l, s, n, i)), s && !this.isObjectProperty(l) && l.type !== "SpreadElement" && this.raise(p.InvalidRecordProperty, l), l.shorthand && this.addExtra(l, "shorthand", true), h.properties.push(l);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = r;
            let c = "ObjectExpression";
            return e ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(h, c);
          }
          addTrailingCommaExtraToNode(t) {
            this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(t) {
            return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(t) {
            let e = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(p.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
            let s = this.startNode(), i = false, r = false, n;
            if (this.match(21)) return e.length && this.unexpected(), this.parseSpread();
            e.length && (s.decorators = e, e = []), s.method = false, t && (n = this.state.startLoc);
            let o = this.eat(55);
            this.parsePropertyNamePrefixOperator(s);
            let h = this.state.containsEsc;
            if (this.parsePropertyName(s, t), !o && !h && this.maybeAsyncOrAccessorProp(s)) {
              let { key: c } = s, l = c.name;
              l === "async" && !this.hasPrecedingLineBreak() && (i = true, this.resetPreviousNodeTrailingComments(c), o = this.eat(55), this.parsePropertyName(s)), (l === "get" || l === "set") && (r = true, this.resetPreviousNodeTrailingComments(c), s.kind = l, this.match(55) && (o = true, this.raise(p.AccessorIsGenerator, this.state.curPosition(), { kind: l }), this.next()), this.parsePropertyName(s));
            }
            return this.parseObjPropValue(s, n, o, i, false, r, t);
          }
          getGetterSetterExpectedParamCount(t) {
            return t.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(t) {
            return t.params;
          }
          checkGetterSetterParams(t) {
            var e;
            let s = this.getGetterSetterExpectedParamCount(t), i = this.getObjectOrClassMethodParams(t);
            i.length !== s && this.raise(t.kind === "get" ? p.BadGetterArity : p.BadSetterArity, t), t.kind === "set" && ((e = i[i.length - 1]) == null ? void 0 : e.type) === "RestElement" && this.raise(p.BadSetterRestParameter, t);
          }
          parseObjectMethod(t, e, s, i, r) {
            if (r) {
              let n = this.parseMethod(t, e, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(n), n;
            }
            if (s || e || this.match(10)) return i && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, e, s, false, false, "ObjectMethod");
          }
          parseObjectProperty(t, e, s, i) {
            if (t.shorthand = false, this.eat(14)) return t.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(t, "ObjectProperty");
            if (!t.computed && t.key.type === "Identifier") {
              if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), s) t.value = this.parseMaybeDefault(e, $(t.key));
              else if (this.match(29)) {
                let r = this.state.startLoc;
                i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = r) : this.raise(p.InvalidCoverInitializedName, r), t.value = this.parseMaybeDefault(e, $(t.key));
              } else t.value = $(t.key);
              return t.shorthand = true, this.finishNode(t, "ObjectProperty");
            }
          }
          parseObjPropValue(t, e, s, i, r, n, o) {
            let h = this.parseObjectMethod(t, s, i, r, n) || this.parseObjectProperty(t, e, r, o);
            return h || this.unexpected(), h;
          }
          parsePropertyName(t, e) {
            if (this.eat(0)) t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              let { type: s, value: i } = this.state, r;
              if (M(s)) r = this.parseIdentifier(true);
              else switch (s) {
                case 134:
                  r = this.parseNumericLiteral(i);
                  break;
                case 133:
                  r = this.parseStringLiteral(i);
                  break;
                case 135:
                  r = this.parseBigIntLiteral(i);
                  break;
                case 136:
                  r = this.parseDecimalLiteral(i);
                  break;
                case 138: {
                  let n = this.state.startLoc;
                  e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = n) : this.raise(p.UnexpectedPrivateField, n), r = this.parsePrivateName();
                  break;
                }
                default:
                  this.unexpected();
              }
              t.key = r, s !== 138 && (t.computed = false);
            }
          }
          initFunction(t, e) {
            t.id = null, t.generator = false, t.async = e;
          }
          parseMethod(t, e, s, i, r, n, o = false) {
            this.initFunction(t, s), t.generator = e, this.scope.enter(18 | (o ? 64 : 0) | (r ? 32 : 0)), this.prodParam.enter(ke2(s, t.generator)), this.parseFunctionParams(t, i);
            let h = this.parseFunctionBodyAndFinish(t, n, true);
            return this.prodParam.exit(), this.scope.exit(), h;
          }
          parseArrayLike(t, e, s, i) {
            s && this.expectPlugin("recordAndTuple");
            let r = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n = this.startNode();
            return this.next(), n.elements = this.parseExprList(t, !s, i, n), this.state.inFSharpPipelineDirectBody = r, this.finishNode(n, s ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(t, e, s, i) {
            this.scope.enter(6);
            let r = ke2(s, false);
            !this.match(5) && this.prodParam.hasIn && (r |= 8), this.prodParam.enter(r), this.initFunction(t, s);
            let n = this.state.maybeInArrowParameters;
            return e && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, e, i)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n, this.finishNode(t, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(t, e, s) {
            this.toAssignableList(e, s, false), t.params = e;
          }
          parseFunctionBodyAndFinish(t, e, s = false) {
            return this.parseFunctionBody(t, false, s), this.finishNode(t, e);
          }
          parseFunctionBody(t, e, s = false) {
            let i = e && !this.match(5);
            if (this.expressionScope.enter(rs2()), i) t.body = this.parseMaybeAssign(), this.checkParams(t, false, e, false);
            else {
              let r = this.state.strict, n = this.state.labels;
              this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(true, false, (o) => {
                let h = !this.isSimpleParamList(t.params);
                o && h && this.raise(p.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
                let c = !r && this.state.strict;
                this.checkParams(t, !this.state.strict && !e && !s && !h, e, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
              }), this.prodParam.exit(), this.state.labels = n;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(t) {
            return t.type === "Identifier";
          }
          isSimpleParamList(t) {
            for (let e = 0, s = t.length; e < s; e++) if (!this.isSimpleParameter(t[e])) return false;
            return true;
          }
          checkParams(t, e, s, i = true) {
            let r = !e && /* @__PURE__ */ new Set(), n = { type: "FormalParameters" };
            for (let o of t.params) this.checkLVal(o, { in: n, binding: 5, checkClashes: r, strictModeChanged: i });
          }
          parseExprList(t, e, s, i) {
            let r = [], n = true;
            for (; !this.eat(t); ) {
              if (n) n = false;
              else if (this.expect(12), this.match(t)) {
                i && this.addTrailingCommaExtraToNode(i), this.next();
                break;
              }
              r.push(this.parseExprListItem(e, s));
            }
            return r;
          }
          parseExprListItem(t, e, s) {
            let i;
            if (this.match(12)) t || this.raise(p.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), i = null;
            else if (this.match(21)) {
              let r = this.state.startLoc;
              i = this.parseParenItem(this.parseSpread(e), r);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), s || this.raise(p.UnexpectedArgumentPlaceholder, this.state.startLoc);
              let r = this.startNode();
              this.next(), i = this.finishNode(r, "ArgumentPlaceholder");
            } else i = this.parseMaybeAssignAllowIn(e, this.parseParenItem);
            return i;
          }
          parseIdentifier(t) {
            let e = this.startNode(), s = this.parseIdentifierName(t);
            return this.createIdentifier(e, s);
          }
          createIdentifier(t, e) {
            return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
          }
          parseIdentifierName(t) {
            let e, { startLoc: s, type: i } = this.state;
            M(i) ? e = this.state.value : this.unexpected();
            let r = oi2(i);
            return t ? r && this.replaceToken(132) : this.checkReservedWord(e, s, r, false), this.next(), e;
          }
          checkReservedWord(t, e, s, i) {
            if (t.length > 10 || !Ei2(t)) return;
            if (s && Si2(t)) {
              this.raise(p.UnexpectedKeyword, e, { keyword: t });
              return;
            }
            if ((this.state.strict ? i ? Zt2 : Yt : Gt3)(t, this.inModule)) {
              this.raise(p.UnexpectedReservedWord, e, { reservedWord: t });
              return;
            } else if (t === "yield") {
              if (this.prodParam.hasYield) {
                this.raise(p.YieldBindingIdentifier, e);
                return;
              }
            } else if (t === "await") {
              if (this.prodParam.hasAwait) {
                this.raise(p.AwaitBindingIdentifier, e);
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(p.AwaitBindingIdentifierInStaticBlock, e);
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError(e);
            } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(p.ArgumentsInClass, e);
              return;
            }
          }
          isAwaitAllowed() {
            return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
          }
          parseAwait(t) {
            let e = this.startNodeAt(t);
            return this.expressionScope.recordParameterInitializerError(p.AwaitExpressionFormalParameter, e), this.eat(55) && this.raise(p.ObsoleteAwaitStar, e), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (e.argument = this.parseMaybeUnary(null, true)), this.finishNode(e, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak()) return true;
            let { type: t } = this.state;
            return t === 53 || t === 10 || t === 0 || Le2(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
          }
          parseYield() {
            let t = this.startNode();
            this.expressionScope.recordParameterInitializerError(p.YieldInParameter, t), this.next();
            let e = false, s = null;
            if (!this.hasPrecedingLineBreak()) switch (e = this.eat(55), this.state.type) {
              case 13:
              case 139:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!e) break;
              default:
                s = this.parseMaybeAssign();
            }
            return t.delegate = e, t.argument = s, this.finishNode(t, "YieldExpression");
          }
          parseImportCall(t) {
            return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
          }
          checkPipelineAtInfixOperator(t, e) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(p.PipelineHeadSequenceExpression, e);
          }
          parseSmartPipelineBodyInStyle(t, e) {
            if (this.isSimpleReference(t)) {
              let s = this.startNodeAt(e);
              return s.callee = t, this.finishNode(s, "PipelineBareFunction");
            } else {
              let s = this.startNodeAt(e);
              return this.checkSmartPipeTopicBodyEarlyErrors(e), s.expression = t, this.finishNode(s, "PipelineTopicExpression");
            }
          }
          isSimpleReference(t) {
            switch (t.type) {
              case "MemberExpression":
                return !t.computed && this.isSimpleReference(t.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(t) {
            if (this.match(19)) throw this.raise(p.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipelineTopicUnused, t);
          }
          withTopicBindingContext(t) {
            let e = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return t();
            } finally {
              this.state.topicContext = e;
            }
          }
          withSmartMixTopicForbiddingContext(t) {
            if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
              let e = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return t();
              } finally {
                this.state.topicContext = e;
              }
            } else return t();
          }
          withSoloAwaitPermittingContext(t) {
            let e = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return t();
            } finally {
              this.state.soloAwait = e;
            }
          }
          allowInAnd(t) {
            let e = this.prodParam.currentFlags();
            if (8 & ~e) {
              this.prodParam.enter(e | 8);
              try {
                return t();
              } finally {
                this.prodParam.exit();
              }
            }
            return t();
          }
          disallowInAnd(t) {
            let e = this.prodParam.currentFlags();
            if (8 & e) {
              this.prodParam.enter(e & -9);
              try {
                return t();
              } finally {
                this.prodParam.exit();
              }
            }
            return t();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(t) {
            let e = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            let s = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, t);
            return this.state.inFSharpPipelineDirectBody = s, i;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            let t = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            let e = this.startNodeAt(this.state.endLoc);
            this.next();
            let s = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              t.body = this.parseProgram(e, 8, "module");
            } finally {
              s();
            }
            return this.finishNode(t, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(t) {
          }
        }, ze2 = { kind: 1 }, ar2 = { kind: 2 }, nr2 = /[\uD800-\uDFFF]/u, Ke2 = /in(?:stanceof)?/y;
        function or2(a, t) {
          for (let e = 0; e < a.length; e++) {
            let s = a[e], { type: i } = s;
            if (typeof i == "number") {
              {
                if (i === 138) {
                  let { loc: r, start: n, value: o, end: h } = s, c = n + 1, l = v2(r.start, 1);
                  a.splice(e, 1, new O({ type: R(27), value: "#", start: n, end: c, startLoc: r.start, endLoc: l }), new O({ type: R(132), value: o, start: c, end: h, startLoc: l, endLoc: r.end })), e++;
                  continue;
                }
                if (Le2(i)) {
                  let { loc: r, start: n, value: o, end: h } = s, c = n + 1, l = v2(r.start, 1), u;
                  t.charCodeAt(n) === 96 ? u = new O({ type: R(22), value: "`", start: n, end: c, startLoc: r.start, endLoc: l }) : u = new O({ type: R(8), value: "}", start: n, end: c, startLoc: r.start, endLoc: l });
                  let f, d2, y2, E;
                  i === 24 ? (d2 = h - 1, y2 = v2(r.end, -1), f = o === null ? null : o.slice(1, -1), E = new O({ type: R(22), value: "`", start: d2, end: h, startLoc: y2, endLoc: r.end })) : (d2 = h - 2, y2 = v2(r.end, -2), f = o === null ? null : o.slice(1, -2), E = new O({ type: R(23), value: "${", start: d2, end: h, startLoc: y2, endLoc: r.end })), a.splice(e, 1, u, new O({ type: R(20), value: f, start: c, end: d2, startLoc: l, endLoc: y2 }), E), e += 2;
                  continue;
                }
              }
              s.type = R(i);
            }
          }
          return a;
        }
        var pt2 = class extends ct {
          parseTopLevel(t, e) {
            return t.program = this.parseProgram(e), t.comments = this.comments, this.options.tokens && (t.tokens = or2(this.tokens, this.input)), this.finishNode(t, "File");
          }
          parseProgram(t, e = 139, s = this.options.sourceType) {
            if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, e), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (let [r, n] of Array.from(this.scope.undefinedExports)) this.raise(p.ModuleExportUndefined, n, { localName: r });
            let i;
            return e === 139 ? i = this.finishNode(t, "Program") : i = this.finishNodeAt(t, "Program", v2(this.state.startLoc, -1)), i;
          }
          stmtToDirective(t) {
            let e = t;
            e.type = "Directive", e.value = e.expression, delete e.expression;
            let s = e.value, i = s.value, r = this.input.slice(s.start, s.end), n = s.value = r.slice(1, -1);
            return this.addExtra(s, "raw", r), this.addExtra(s, "rawValue", n), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral", e;
          }
          parseInterpreterDirective() {
            if (!this.match(28)) return null;
            let t = this.startNode();
            return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
          }
          isLet() {
            return this.isContextual(100) ? this.hasFollowingBindingAtom() : false;
          }
          chStartsBindingIdentifier(t, e) {
            if (_2(t)) {
              if (Ke2.lastIndex = e, Ke2.test(this.input)) {
                let s = this.codePointAtPos(Ke2.lastIndex);
                if (!Q3(s) && s !== 92) return false;
              }
              return true;
            } else return t === 92;
          }
          chStartsBindingPattern(t) {
            return t === 91 || t === 123;
          }
          hasFollowingBindingAtom() {
            let t = this.nextTokenStart(), e = this.codePointAtPos(t);
            return this.chStartsBindingPattern(e) || this.chStartsBindingIdentifier(e, t);
          }
          hasInLineFollowingBindingIdentifierOrBrace() {
            let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
            return e === 123 || this.chStartsBindingIdentifier(e, t);
          }
          startsUsingForOf() {
            let { type: t, containsEsc: e } = this.lookahead();
            if (t === 102 && !e) return false;
            if (w(t) && !this.hasFollowingLineBreak()) return this.expectPlugin("explicitResourceManagement"), true;
          }
          startsAwaitUsing() {
            let t = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(t, "using")) {
              t = this.nextTokenInLineStartSince(t + 5);
              let e = this.codePointAtPos(t);
              if (this.chStartsBindingIdentifier(e, t)) return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(t = false) {
            let e = 0;
            return this.options.annexB && !this.state.strict && (e |= 4, t && (e |= 8)), this.parseStatementLike(e);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(t) {
            let e = null;
            return this.match(26) && (e = this.parseDecorators(true)), this.parseStatementContent(t, e);
          }
          parseStatementContent(t, e) {
            let s = this.state.type, i = this.startNode(), r = !!(t & 2), n = !!(t & 4), o = t & 1;
            switch (s) {
              case 60:
                return this.parseBreakContinueStatement(i, true);
              case 63:
                return this.parseBreakContinueStatement(i, false);
              case 64:
                return this.parseDebuggerStatement(i);
              case 90:
                return this.parseDoWhileStatement(i);
              case 91:
                return this.parseForStatement(i);
              case 68:
                if (this.lookaheadCharCode() === 46) break;
                return n || this.raise(this.state.strict ? p.StrictFunction : this.options.annexB ? p.SloppyFunctionAnnexB : p.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i, false, !r && n);
              case 80:
                return r || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e, i), true);
              case 69:
                return this.parseIfStatement(i);
              case 70:
                return this.parseReturnStatement(i);
              case 71:
                return this.parseSwitchStatement(i);
              case 72:
                return this.parseThrowStatement(i);
              case 73:
                return this.parseTryStatement(i);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? r || this.raise(p.UnexpectedLexicalDeclaration, i) : this.raise(p.AwaitUsingNotInAsyncContext, i), this.next(), this.parseVarStatement(i, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(p.UnexpectedUsingDeclaration, this.state.startLoc) : r || this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
              case 100: {
                if (this.state.containsEsc) break;
                let l = this.nextTokenStart(), u = this.codePointAtPos(l);
                if (u !== 91 && (!r && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(u, l) && u !== 123)) break;
              }
              case 75:
                r || this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                let l = this.state.value;
                return this.parseVarStatement(i, l);
              }
              case 92:
                return this.parseWhileStatement(i);
              case 76:
                return this.parseWithStatement(i);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(i);
              case 83: {
                let l = this.lookaheadCharCode();
                if (l === 40 || l === 46) break;
              }
              case 82: {
                !this.options.allowImportExportEverywhere && !o && this.raise(p.UnexpectedImportExport, this.state.startLoc), this.next();
                let l;
                return s === 83 ? (l = this.parseImport(i), l.type === "ImportDeclaration" && (!l.importKind || l.importKind === "value") && (this.sawUnambiguousESM = true)) : (l = this.parseExport(i, e), (l.type === "ExportNamedDeclaration" && (!l.exportKind || l.exportKind === "value") || l.type === "ExportAllDeclaration" && (!l.exportKind || l.exportKind === "value") || l.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(l), l;
              }
              default:
                if (this.isAsyncFunction()) return r || this.raise(p.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i, true, !r && n);
            }
            let h = this.state.value, c = this.parseExpression();
            return w(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, h, c, t) : this.parseExpressionStatement(i, c, e);
          }
          assertModuleNodeAllowed(t) {
            !this.options.allowImportExportEverywhere && !this.inModule && this.raise(p.ImportOutsideModule, t);
          }
          decoratorsEnabledBeforeExport() {
            return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
          }
          maybeTakeDecorators(t, e, s) {
            return t && (e.decorators && e.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(p.DecoratorsBeforeAfterExport, e.decorators[0]), e.decorators.unshift(...t)) : e.decorators = t, this.resetStartLocationFromNode(e, t[0]), s && this.resetStartLocationFromNode(s, e)), e;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(t) {
            let e = [];
            do
              e.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82)) t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(p.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(p.UnexpectedLeadingDecorator, this.state.startLoc);
            return e;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            let t = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              let e = this.state.startLoc, s;
              if (this.match(10)) {
                let i = this.state.startLoc;
                this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
                let r = this.state.startLoc;
                t.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === false && t.expression !== s && this.raise(p.DecoratorArgumentsOutsideParentheses, r);
              } else {
                for (s = this.parseIdentifier(false); this.eat(16); ) {
                  let i = this.startNodeAt(e);
                  i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) : i.property = this.parseIdentifier(true), i.computed = false, s = this.finishNode(i, "MemberExpression");
                }
                t.expression = this.parseMaybeDecoratorArguments(s);
              }
            } else t.expression = this.parseExprSubscripts();
            return this.finishNode(t, "Decorator");
          }
          parseMaybeDecoratorArguments(t) {
            if (this.eat(10)) {
              let e = this.startNodeAtNode(t);
              return e.callee = t, e.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e.arguments), this.finishNode(e, "CallExpression");
            }
            return t;
          }
          parseBreakContinueStatement(t, e) {
            return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(t, e) {
            let s;
            for (s = 0; s < this.state.labels.length; ++s) {
              let i = this.state.labels[s];
              if ((t.label == null || i.name === t.label.name) && (i.kind != null && (e || i.kind === 1) || t.label && e)) break;
            }
            if (s === this.state.labels.length) {
              let i = e ? "BreakStatement" : "ContinueStatement";
              this.raise(p.IllegalBreakContinue, t, { type: i });
            }
          }
          parseDebuggerStatement(t) {
            return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            let t = this.parseExpression();
            return this.expect(11), t;
          }
          parseDoWhileStatement(t) {
            return this.next(), this.state.labels.push(ze2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
          }
          parseForStatement(t) {
            this.next(), this.state.labels.push(ze2);
            let e = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (e = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return e !== null && this.unexpected(e), this.parseFor(t, null);
            let s = this.isContextual(100);
            {
              let h = this.isContextual(96) && this.startsAwaitUsing(), c = h || this.isContextual(107) && this.startsUsingForOf(), l = s && this.hasFollowingBindingAtom() || c;
              if (this.match(74) || this.match(75) || l) {
                let u = this.startNode(), f;
                h ? (f = "await using", this.isAwaitAllowed() || this.raise(p.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : f = this.state.value, this.next(), this.parseVar(u, true, f);
                let d2 = this.finishNode(u, "VariableDeclaration"), y2 = this.match(58);
                return y2 && c && this.raise(p.ForInUsing, d2), (y2 || this.isContextual(102)) && d2.declarations.length === 1 ? this.parseForIn(t, d2, e) : (e !== null && this.unexpected(e), this.parseFor(t, d2));
              }
            }
            let i = this.isContextual(95), r = new Z(), n = this.parseExpression(true, r), o = this.isContextual(102);
            if (o && (s && this.raise(p.ForOfLet, n), e === null && i && n.type === "Identifier" && this.raise(p.ForOfAsync, n)), o || this.match(58)) {
              this.checkDestructuringPrivate(r), this.toAssignable(n, true);
              let h = o ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(n, { in: { type: h } }), this.parseForIn(t, n, e);
            } else this.checkExpressionErrors(r, true);
            return e !== null && this.unexpected(e), this.parseFor(t, n);
          }
          parseFunctionStatement(t, e, s) {
            return this.next(), this.parseFunction(t, 1 | (s ? 2 : 0) | (e ? 8 : 0));
          }
          parseIfStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
          }
          parseReturnStatement(t) {
            return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(p.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
          }
          parseSwitchStatement(t) {
            this.next(), t.discriminant = this.parseHeaderExpression();
            let e = t.cases = [];
            this.expect(5), this.state.labels.push(ar2), this.scope.enter(0);
            let s;
            for (let i; !this.match(8); ) if (this.match(61) || this.match(65)) {
              let r = this.match(61);
              s && this.finishNode(s, "SwitchCase"), e.push(s = this.startNode()), s.consequent = [], this.next(), r ? s.test = this.parseExpression() : (i && this.raise(p.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = true, s.test = null), this.expect(14);
            } else s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
          }
          parseThrowStatement(t) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(p.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
          }
          parseCatchClauseParam() {
            let t = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: 9 }), t;
          }
          parseTryStatement(t) {
            if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
              let e = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(0)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
            }
            return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(p.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
          }
          parseVarStatement(t, e, s = false) {
            return this.next(), this.parseVar(t, false, e, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
          }
          parseWhileStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(ze2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
          }
          parseWithStatement(t) {
            return this.state.strict && this.raise(p.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
          }
          parseEmptyStatement(t) {
            return this.next(), this.finishNode(t, "EmptyStatement");
          }
          parseLabeledStatement(t, e, s, i) {
            for (let n of this.state.labels) n.name === e && this.raise(p.LabelRedeclaration, s, { labelName: e });
            let r = ci3(this.state.type) ? 1 : this.match(71) ? 2 : null;
            for (let n = this.state.labels.length - 1; n >= 0; n--) {
              let o = this.state.labels[n];
              if (o.statementStart === t.start) o.statementStart = this.state.start, o.kind = r;
              else break;
            }
            return this.state.labels.push({ name: e, kind: r, statementStart: this.state.start }), t.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
          }
          parseExpressionStatement(t, e, s) {
            return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
          }
          parseBlock(t = false, e = true, s) {
            let i = this.startNode();
            return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(0), this.parseBlockBody(i, t, false, 8, s), e && this.scope.exit(), this.finishNode(i, "BlockStatement");
          }
          isValidDirective(t) {
            return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
          }
          parseBlockBody(t, e, s, i, r) {
            let n = t.body = [], o = t.directives = [];
            this.parseBlockOrModuleBlockBody(n, e ? o : void 0, s, i, r);
          }
          parseBlockOrModuleBlockBody(t, e, s, i, r) {
            let n = this.state.strict, o = false, h = false;
            for (; !this.match(i); ) {
              let c = s ? this.parseModuleItem() : this.parseStatementListItem();
              if (e && !h) {
                if (this.isValidDirective(c)) {
                  let l = this.stmtToDirective(c);
                  e.push(l), !o && l.value.value === "use strict" && (o = true, this.setStrict(true));
                  continue;
                }
                h = true, this.state.strictErrors.clear();
              }
              t.push(c);
            }
            r == null || r.call(this, o), n || this.setStrict(false), this.next();
          }
          parseFor(t, e) {
            return t.init = e, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
          }
          parseForIn(t, e, s) {
            let i = this.match(58);
            return this.next(), i ? s !== null && this.unexpected(s) : t.await = s !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!i || !this.options.annexB || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(p.ForInOfLoopInitializer, e, { type: i ? "ForInStatement" : "ForOfStatement" }), e.type === "AssignmentPattern" && this.raise(p.InvalidLhs, e, { ancestor: { type: "ForStatement" } }), t.left = e, t.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, i ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(t, e, s, i = false) {
            let r = t.declarations = [];
            for (t.kind = s; ; ) {
              let n = this.startNode();
              if (this.parseVarId(n, s), n.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, n.init === null && !i && (n.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(102))) ? this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: s })), r.push(this.finishNode(n, "VariableDeclarator")), !this.eat(12)) break;
            }
            return t;
          }
          parseVarId(t, e) {
            let s = this.parseBindingAtom();
            (e === "using" || e === "await using") && (s.type === "ArrayPattern" || s.type === "ObjectPattern") && this.raise(p.UsingDeclarationHasBindingPattern, s.loc.start), this.checkLVal(s, { in: { type: "VariableDeclarator" }, binding: e === "var" ? 5 : 8201 }), t.id = s;
          }
          parseAsyncFunctionExpression(t) {
            return this.parseFunction(t, 8);
          }
          parseFunction(t, e = 0) {
            let s = e & 2, i = !!(e & 1), r = i && !(e & 4), n = !!(e & 8);
            this.initFunction(t, n), this.match(55) && (s && this.raise(p.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = true), i && (t.id = this.parseFunctionId(r));
            let o = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(ke2(n, t.generator)), i || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(t, i ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
          }
          parseFunctionId(t) {
            return t || w(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(t, e) {
            this.expect(10), this.expressionScope.enter(Mi2()), t.params = this.parseBindingList(11, 41, 2 | (e ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(t) {
            t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
          }
          parseClass(t, e, s) {
            this.next();
            let i = this.state.strict;
            return this.state.strict = true, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(t) {
            return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
          }
          isNonstaticConstructor(t) {
            return !t.computed && !t.static && this.nameIsConstructor(t.key);
          }
          parseClassBody(t, e) {
            this.classScope.enter();
            let s = { hadConstructor: false, hadSuperClass: t }, i = [], r = this.startNode();
            if (r.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (i.length > 0) throw this.raise(p.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  i.push(this.parseDecorator());
                  continue;
                }
                let n = this.startNode();
                i.length && (n.decorators = i, this.resetStartLocationFromNode(n, i[0]), i = []), this.parseClassMember(r, n, s), n.kind === "constructor" && n.decorators && n.decorators.length > 0 && this.raise(p.DecoratorConstructor, n);
              }
            }), this.state.strict = e, this.next(), i.length) throw this.raise(p.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(r, "ClassBody");
          }
          parseClassMemberFromModifier(t, e) {
            let s = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              let i = e;
              return i.kind = "method", i.computed = false, i.key = s, i.static = false, this.pushClassMethod(t, i, false, false, false, false), true;
            } else if (this.isClassProperty()) {
              let i = e;
              return i.computed = false, i.key = s, i.static = false, t.body.push(this.parseClassProperty(i)), true;
            }
            return this.resetPreviousNodeTrailingComments(s), false;
          }
          parseClassMember(t, e, s) {
            let i = this.isContextual(106);
            if (i) {
              if (this.parseClassMemberFromModifier(t, e)) return;
              if (this.eat(5)) {
                this.parseClassStaticBlock(t, e);
                return;
              }
            }
            this.parseClassMemberWithIsStatic(t, e, s, i);
          }
          parseClassMemberWithIsStatic(t, e, s, i) {
            let r = e, n = e, o = e, h = e, c = e, l = r, u = r;
            if (e.static = i, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
              l.kind = "method";
              let S = this.match(138);
              if (this.parseClassElementName(l), S) {
                this.pushClassPrivateMethod(t, n, true, false);
                return;
              }
              this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsGenerator, r.key), this.pushClassMethod(t, r, true, false, false, false);
              return;
            }
            let f = !this.state.containsEsc && w(this.state.type), d2 = this.parseClassElementName(e), y2 = f ? d2.name : null, E = this.isPrivateName(d2), L = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(u), this.isClassMethod()) {
              if (l.kind = "method", E) {
                this.pushClassPrivateMethod(t, n, false, false);
                return;
              }
              let S = this.isNonstaticConstructor(r), I = false;
              S && (r.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(p.DuplicateConstructor, d2), S && this.hasPlugin("typescript") && e.override && this.raise(p.OverrideOnConstructor, d2), s.hadConstructor = true, I = s.hadSuperClass), this.pushClassMethod(t, r, false, false, S, I);
            } else if (this.isClassProperty()) E ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o);
            else if (y2 === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(d2);
              let S = this.eat(55);
              u.optional && this.unexpected(L), l.kind = "method";
              let I = this.match(138);
              this.parseClassElementName(l), this.parsePostMemberNameModifiers(u), I ? this.pushClassPrivateMethod(t, n, S, true) : (this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsAsync, r.key), this.pushClassMethod(t, r, S, true, false, false));
            } else if ((y2 === "get" || y2 === "set") && !(this.match(55) && this.isLineTerminator())) {
              this.resetPreviousNodeTrailingComments(d2), l.kind = y2;
              let S = this.match(138);
              this.parseClassElementName(r), S ? this.pushClassPrivateMethod(t, n, false, false) : (this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsAccessor, r.key), this.pushClassMethod(t, r, false, false, false, false)), this.checkGetterSetterParams(r);
            } else if (y2 === "accessor" && !this.isLineTerminator()) {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d2);
              let S = this.match(138);
              this.parseClassElementName(o), this.pushClassAccessorProperty(t, c, S);
            } else this.isLineTerminator() ? E ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o) : this.unexpected();
          }
          parseClassElementName(t) {
            let { type: e, value: s } = this.state;
            if ((e === 132 || e === 133) && t.static && s === "prototype" && this.raise(p.StaticPrototype, this.state.startLoc), e === 138) {
              s === "constructor" && this.raise(p.ConstructorClassPrivateField, this.state.startLoc);
              let i = this.parsePrivateName();
              return t.key = i, i;
            }
            return this.parsePropertyName(t), t.key;
          }
          parseClassStaticBlock(t, e) {
            var s;
            this.scope.enter(208);
            let i = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            let r = e.body = [];
            this.parseBlockOrModuleBlockBody(r, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, t.body.push(this.finishNode(e, "StaticBlock")), (s = e.decorators) != null && s.length && this.raise(p.DecoratorStaticBlock, e);
          }
          pushClassProperty(t, e) {
            !e.computed && this.nameIsConstructor(e.key) && this.raise(p.ConstructorClassField, e.key), t.body.push(this.parseClassProperty(e));
          }
          pushClassPrivateProperty(t, e) {
            let s = this.parseClassPrivateProperty(e);
            t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
          }
          pushClassAccessorProperty(t, e, s) {
            !s && !e.computed && this.nameIsConstructor(e.key) && this.raise(p.ConstructorClassField, e.key);
            let i = this.parseClassAccessorProperty(e);
            t.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
          }
          pushClassMethod(t, e, s, i, r, n) {
            t.body.push(this.parseMethod(e, s, i, r, n, "ClassMethod", true));
          }
          pushClassPrivateMethod(t, e, s, i) {
            let r = this.parseMethod(e, s, i, false, false, "ClassPrivateMethod", true);
            t.body.push(r);
            let n = r.kind === "get" ? r.static ? 6 : 2 : r.kind === "set" ? r.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(r, n);
          }
          declareClassPrivateMethodInScope(t, e) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
          }
          parsePostMemberNameModifiers(t) {
          }
          parseClassPrivateProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
          }
          parseClassProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
          }
          parseClassAccessorProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
          }
          parseInitializer(t) {
            this.scope.enter(80), this.expressionScope.enter(rs2()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(t, e, s, i = 8331) {
            if (w(this.state.type)) t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, i);
            else if (s || !e) t.id = null;
            else throw this.raise(p.MissingClassName, this.state.startLoc);
          }
          parseClassSuper(t) {
            t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(t, e) {
            let s = this.parseMaybeImportPhase(t, true), i = this.maybeParseExportDefaultSpecifier(t, s), r = !i || this.eat(12), n = r && this.eatExportStar(t), o = n && this.maybeParseExportNamespaceSpecifier(t), h = r && (!o || this.eat(12)), c = i || n;
            if (n && !o) {
              if (i && this.unexpected(), e) throw this.raise(p.UnsupportedDecoratorExport, t);
              return this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
            }
            let l = this.maybeParseExportNamedSpecifiers(t);
            i && r && !n && !l && this.unexpected(null, 5), o && h && this.unexpected(null, 98);
            let u;
            if (c || l) {
              if (u = false, e) throw this.raise(p.UnsupportedDecoratorExport, t);
              this.parseExportFrom(t, c);
            } else u = this.maybeParseExportDeclaration(t);
            if (c || l || u) {
              var f;
              let d2 = t;
              if (this.checkExport(d2, true, false, !!d2.source), ((f = d2.declaration) == null ? void 0 : f.type) === "ClassDeclaration") this.maybeTakeDecorators(e, d2.declaration, d2);
              else if (e) throw this.raise(p.UnsupportedDecoratorExport, t);
              return this.finishNode(d2, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              let d2 = t, y2 = this.parseExportDefaultExpression();
              if (d2.declaration = y2, y2.type === "ClassDeclaration") this.maybeTakeDecorators(e, y2, d2);
              else if (e) throw this.raise(p.UnsupportedDecoratorExport, t);
              return this.checkExport(d2, true, true), this.finishNode(d2, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(t) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(t, e) {
            if (e || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", e == null ? void 0 : e.loc.start);
              let s = e || this.parseIdentifier(true), i = this.startNodeAtNode(s);
              return i.exported = s, t.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(t) {
            if (this.isContextual(93)) {
              var e, s;
              (s = (e = t).specifiers) != null || (e.specifiers = []);
              let i = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), i.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(t) {
            if (this.match(5)) {
              let e = t;
              e.specifiers || (e.specifiers = []);
              let s = e.exportKind === "type";
              return e.specifiers.push(...this.parseExportSpecifiers(s)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") && (e.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(t) {
            return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
          }
          isAsyncFunction() {
            if (!this.isContextual(95)) return false;
            let t = this.nextTokenInLineStart();
            return this.isUnparsedContextual(t, "function");
          }
          parseExportDefaultExpression() {
            let t = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(t, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(t, 13);
            if (this.match(80)) return this.parseClass(t, true, true);
            if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(p.UnsupportedDefaultExport, this.state.startLoc);
            let e = this.parseMaybeAssignAllowIn();
            return this.semicolon(), e;
          }
          parseExportDeclaration(t) {
            return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            let { type: t } = this.state;
            if (w(t)) {
              if (t === 95 && !this.state.containsEsc || t === 100) return false;
              if ((t === 130 || t === 129) && !this.state.containsEsc) {
                let { type: i } = this.lookahead();
                if (w(i) && i !== 98 || i === 5) return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65)) return false;
            let e = this.nextTokenStart(), s = this.isUnparsedContextual(e, "from");
            if (this.input.charCodeAt(e) === 44 || w(this.state.type) && s) return true;
            if (this.match(65) && s) {
              let i = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
              return i === 34 || i === 39;
            }
            return false;
          }
          parseExportFrom(t, e) {
            this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : e && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            let { type: t } = this.state;
            return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p.DecoratorBeforeExport, this.state.startLoc), true) : this.isContextual(107) ? (this.raise(p.UsingDeclarationExport, this.state.startLoc), true) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(p.UsingDeclarationExport, this.state.startLoc), true) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(t, e, s, i) {
            if (e) {
              var r;
              if (s) {
                if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var n;
                  let o = t.declaration;
                  o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((n = o.extra) != null && n.parenthesized) && this.raise(p.ExportDefaultFromAsIdentifier, o);
                }
              } else if ((r = t.specifiers) != null && r.length) for (let o of t.specifiers) {
                let { exported: h } = o, c = h.type === "Identifier" ? h.name : h.value;
                if (this.checkDuplicateExports(o, c), !i && o.local) {
                  let { local: l } = o;
                  l.type !== "Identifier" ? this.raise(p.ExportBindingIsString, o, { localName: l.value, exportName: c }) : (this.checkReservedWord(l.name, l.loc.start, true, false), this.scope.checkLocalExport(l));
                }
              }
              else if (t.declaration) {
                let o = t.declaration;
                if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
                  let { id: h } = o;
                  if (!h) throw new Error("Assertion failure");
                  this.checkDuplicateExports(t, h.name);
                } else if (o.type === "VariableDeclaration") for (let h of o.declarations) this.checkDeclaration(h.id);
              }
            }
          }
          checkDeclaration(t) {
            if (t.type === "Identifier") this.checkDuplicateExports(t, t.name);
            else if (t.type === "ObjectPattern") for (let e of t.properties) this.checkDeclaration(e);
            else if (t.type === "ArrayPattern") for (let e of t.elements) e && this.checkDeclaration(e);
            else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
          }
          checkDuplicateExports(t, e) {
            this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(p.DuplicateDefaultExport, t) : this.raise(p.DuplicateExport, t, { exportName: e })), this.exportedIdentifiers.add(e);
          }
          parseExportSpecifiers(t) {
            let e = [], s = true;
            for (this.expect(5); !this.eat(8); ) {
              if (s) s = false;
              else if (this.expect(12), this.eat(8)) break;
              let i = this.isContextual(130), r = this.match(133), n = this.startNode();
              n.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(n, r, t, i));
            }
            return e;
          }
          parseExportSpecifier(t, e, s, i) {
            return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = Ri2(t.local) : t.exported || (t.exported = $(t.local)), this.finishNode(t, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(133)) {
              let t = this.parseStringLiteral(this.state.value), e = nr2.exec(t.value);
              return e && this.raise(p.ModuleExportNameHasLoneSurrogate, t, { surrogateCharCode: e[0].charCodeAt(0) }), t;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(t) {
            return t.assertions != null ? t.assertions.some(({ key: e, value: s }) => s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type")) : false;
          }
          checkImportReflection(t) {
            let { specifiers: e } = t, s = e.length === 1 ? e[0].type : null;
            if (t.phase === "source") s !== "ImportDefaultSpecifier" && this.raise(p.SourcePhaseImportRequiresDefault, e[0].loc.start);
            else if (t.phase === "defer") s !== "ImportNamespaceSpecifier" && this.raise(p.DeferImportRequiresNamespace, e[0].loc.start);
            else if (t.module) {
              var i;
              s !== "ImportDefaultSpecifier" && this.raise(p.ImportReflectionNotBinding, e[0].loc.start), ((i = t.assertions) == null ? void 0 : i.length) > 0 && this.raise(p.ImportReflectionHasAssertion, e[0].loc.start);
            }
          }
          checkJSONModuleImport(t) {
            if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
              let { specifiers: e } = t;
              if (e != null) {
                let s = e.find((i) => {
                  let r;
                  if (i.type === "ExportSpecifier" ? r = i.local : i.type === "ImportSpecifier" && (r = i.imported), r !== void 0) return r.type === "Identifier" ? r.name !== "default" : r.value !== "default";
                });
                s !== void 0 && this.raise(p.ImportJSONBindingNotDefault, s.loc.start);
              }
            }
          }
          isPotentialImportPhase(t) {
            return t ? false : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
          }
          applyImportPhase(t, e, s, i) {
            e || (s === "module" ? (this.expectPlugin("importReflection", i), t.module = true) : this.hasPlugin("importReflection") && (t.module = false), s === "source" ? (this.expectPlugin("sourcePhaseImports", i), t.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImportEvaluation", i), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
          }
          parseMaybeImportPhase(t, e) {
            if (!this.isPotentialImportPhase(e)) return this.applyImportPhase(t, e, null), null;
            let s = this.parseIdentifier(true), { type: i } = this.state;
            return (M(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(t, e, s.name, s.loc.start), null) : (this.applyImportPhase(t, e, null), s);
          }
          isPrecedingIdImportPhase(t) {
            let { type: e } = this.state;
            return w(e) ? e !== 98 || this.lookaheadCharCode() === 102 : e !== 12;
          }
          parseImport(t) {
            return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, false));
          }
          parseImportSpecifiersAndAfter(t, e) {
            t.specifiers = [];
            let i = !this.maybeParseDefaultImportSpecifier(t, e) || this.eat(12), r = i && this.maybeParseStarImportSpecifier(t);
            return i && !r && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
          }
          parseImportSourceAndAttributes(t) {
            var e;
            return (e = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(133) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(t, e, s) {
            e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, s));
          }
          finishImportSpecifier(t, e, s = 8201) {
            return this.checkLVal(t.local, { in: { type: e }, binding: s }), this.finishNode(t, e);
          }
          parseImportAttributes() {
            this.expect(5);
            let t = [], e = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) break;
              let s = this.startNode(), i = this.state.value;
              if (e.has(i) && this.raise(p.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: i }), e.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(true), this.expect(14), !this.match(133)) throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
              s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), t;
          }
          parseModuleAttributes() {
            let t = [], e = /* @__PURE__ */ new Set();
            do {
              let s = this.startNode();
              if (s.key = this.parseIdentifier(true), s.key.name !== "type" && this.raise(p.ModuleAttributeDifferentFromType, s.key), e.has(s.key.name) && this.raise(p.ModuleAttributesWithDuplicateKeys, s.key, { key: s.key.name }), e.add(s.key.name), this.expect(14), !this.match(133)) throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
              s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
            } while (this.eat(12));
            return t;
          }
          maybeParseImportAttributes(t) {
            let e, s = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
              this.next(), this.hasPlugin("moduleAttributes") ? e = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), e = this.parseImportAttributes()), s = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true && this.raise(p.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), e = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) e = [];
            else if (this.hasPlugin("moduleAttributes")) e = [];
            else return;
            !s && this.hasPlugin("importAssertions") ? t.assertions = e : t.attributes = e;
          }
          maybeParseDefaultImportSpecifier(t, e) {
            if (e) {
              let s = this.startNodeAtNode(e);
              return s.local = e, t.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), true;
            } else if (M(this.state.type)) return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true;
            return false;
          }
          maybeParseStarImportSpecifier(t) {
            if (this.match(55)) {
              let e = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(t) {
            let e = true;
            for (this.expect(5); !this.eat(8); ) {
              if (e) e = false;
              else {
                if (this.eat(14)) throw this.raise(p.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8)) break;
              }
              let s = this.startNode(), i = this.match(133), r = this.isContextual(130);
              s.imported = this.parseModuleExportName();
              let n = this.parseImportSpecifier(s, i, t.importKind === "type" || t.importKind === "typeof", r, void 0);
              t.specifiers.push(n);
            }
          }
          parseImportSpecifier(t, e, s, i, r) {
            if (this.eatContextual(93)) t.local = this.parseIdentifier();
            else {
              let { imported: n } = t;
              if (e) throw this.raise(p.ImportBindingIsString, t, { importName: n.value });
              this.checkReservedWord(n.name, t.loc.start, true, true), t.local || (t.local = $(n));
            }
            return this.finishImportSpecifier(t, "ImportSpecifier", r);
          }
          isThisParam(t) {
            return t.type === "Identifier" && t.name === "this";
          }
        }, Me = class extends pt2 {
          constructor(t, e) {
            t = rr2(t), super(t, e), this.options = t, this.initializeScopes(), this.plugins = hr(this.options.plugins), this.filename = t.sourceFilename;
          }
          getScopeHandler() {
            return me;
          }
          parse() {
            this.enterInitialScopes();
            let t = this.startNode(), e = this.startNode();
            return this.nextToken(), t.errors = null, this.parseTopLevel(t, e), t.errors = this.state.errors, t.comments.length = this.state.commentsLen, t;
          }
        };
        function hr(a) {
          let t = /* @__PURE__ */ new Map();
          for (let e of a) {
            let [s, i] = Array.isArray(e) ? e : [e, {}];
            t.has(s) || t.set(s, i || {});
          }
          return t;
        }
        function lr(a, t) {
          var e;
          if (((e = t) == null ? void 0 : e.sourceType) === "unambiguous") {
            t = Object.assign({}, t);
            try {
              t.sourceType = "module";
              let s = pe(t, a), i = s.parse();
              if (s.sawUnambiguousESM) return i;
              if (s.ambiguousScriptDifferentAst) try {
                return t.sourceType = "script", pe(t, a).parse();
              } catch {
              }
              else i.program.sourceType = "script";
              return i;
            } catch (s) {
              try {
                return t.sourceType = "script", pe(t, a).parse();
              } catch {
              }
              throw s;
            }
          } else return pe(t, a).parse();
        }
        function cr2(a, t) {
          let e = pe(t, a);
          return e.options.strictMode && (e.state.strict = true), e.getExpression();
        }
        function pr2(a) {
          let t = {};
          for (let e of Object.keys(a)) t[e] = R(a[e]);
          return t;
        }
        var ur2 = pr2(ni2);
        function pe(a, t) {
          let e = Me;
          return a != null && a.plugins && (sr2(a.plugins), e = fr2(a.plugins)), new e(a, t);
        }
        var Kt2 = {};
        function fr2(a) {
          let t = ir2.filter((i) => N2(a, i)), e = t.join("/"), s = Kt2[e];
          if (!s) {
            s = Me;
            for (let i of t) s = hs2[i](s);
            Kt2[e] = s;
          }
          return s;
        }
        xe.parse = lr;
        xe.parseExpression = cr2;
        xe.tokTypes = ur2;
      });
      var Zr2 = {};
      Ws2(Zr2, { parsers: () => Qr2 });
      var je = vt(At(), 1);
      function Oe2(a) {
        return (t, e, s) => {
          let i = !!(s != null && s.backwards);
          if (e === false) return false;
          let { length: r } = t, n = e;
          for (; n >= 0 && n < r; ) {
            let o = t.charAt(n);
            if (a instanceof RegExp) {
              if (!a.test(o)) return n;
            } else if (!a.includes(o)) return n;
            i ? n-- : n++;
          }
          return n === -1 || n === r ? n : false;
        };
      }
      var ha2 = Oe2(/\s/u), ls2 = Oe2(" 	"), la2 = Oe2(",; 	"), cs2 = Oe2(/[^\n\r]/u);
      function dr(a, t) {
        if (t === false) return false;
        if (a.charAt(t) === "/" && a.charAt(t + 1) === "*") {
          for (let e = t + 2; e < a.length; ++e) if (a.charAt(e) === "*" && a.charAt(e + 1) === "/") return e + 2;
        }
        return t;
      }
      var ps2 = dr;
      function mr2(a, t, e) {
        let s = !!(e != null && e.backwards);
        if (t === false) return false;
        let i = a.charAt(t);
        if (s) {
          if (a.charAt(t - 1) === "\r" && i === `
`) return t - 2;
          if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return t - 1;
        } else {
          if (i === "\r" && a.charAt(t + 1) === `
`) return t + 2;
          if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return t + 1;
        }
        return t;
      }
      var us3 = mr2;
      function yr2(a, t) {
        return t === false ? false : a.charAt(t) === "/" && a.charAt(t + 1) === "/" ? cs2(a, t) : t;
      }
      var fs2 = yr2;
      function xr(a, t) {
        let e = null, s = t;
        for (; s !== e; ) e = s, s = ls2(a, s), s = ps2(a, s), s = fs2(a, s), s = us3(a, s);
        return s;
      }
      var ds2 = xr;
      function Pr2(a) {
        let t = [];
        for (let e of a) try {
          return e();
        } catch (s) {
          t.push(s);
        }
        throw Object.assign(new Error("All combinations failed"), { errors: t });
      }
      var ms2 = Pr2;
      function gr2(a) {
        if (!a.startsWith("#!")) return "";
        let t = a.indexOf(`
`);
        return t === -1 ? a : a.slice(0, t);
      }
      var Fe2 = gr2;
      var Tr2 = (a, t, e) => {
        if (!(a && t == null)) return Array.isArray(t) || typeof t == "string" ? t[e < 0 ? t.length + e : e] : t.at(e);
      }, St2 = Tr2;
      function br2(a) {
        return Array.isArray(a) && a.length > 0;
      }
      var Pe = br2;
      function D(a) {
        var s, i, r;
        let t = ((s = a.range) == null ? void 0 : s[0]) ?? a.start, e = (r = ((i = a.declaration) == null ? void 0 : i.decorators) ?? a.decorators) == null ? void 0 : r[0];
        return e ? Math.min(D(e), t) : t;
      }
      function B(a) {
        var t;
        return ((t = a.range) == null ? void 0 : t[1]) ?? a.end;
      }
      function Ar2(a) {
        let t = new Set(a);
        return (e) => t.has(e == null ? void 0 : e.type);
      }
      var ys2 = Ar2;
      var Sr2 = ys2(["Block", "CommentBlock", "MultiLine"]), ge = Sr2;
      function wr2(a) {
        let t = `*${a.value}*`.split(`
`);
        return t.length > 1 && t.every((e) => e.trimStart()[0] === "*");
      }
      var wt = wr2;
      function Cr2(a) {
        return ge(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/u.test(a.value);
      }
      var xs2 = Cr2;
      var Te2 = null;
      function be2(a) {
        if (Te2 !== null && typeof Te2.property) {
          let t = Te2;
          return Te2 = be2.prototype = null, t;
        }
        return Te2 = be2.prototype = a ?? /* @__PURE__ */ Object.create(null), new be2();
      }
      var Er2 = 10;
      for (let a = 0; a <= Er2; a++) be2();
      function Ct2(a) {
        return be2(a);
      }
      function Ir2(a, t = "type") {
        Ct2(a);
        function e(s) {
          let i = s[t], r = a[i];
          if (!Array.isArray(r)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: s });
          return r;
        }
        return e;
      }
      var Ps2 = Ir2;
      var gs3 = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"] };
      var Nr2 = Ps2(gs3), Ts2 = Nr2;
      function Et2(a, t) {
        if (!(a !== null && typeof a == "object")) return a;
        if (Array.isArray(a)) {
          for (let s = 0; s < a.length; s++) a[s] = Et2(a[s], t);
          return a;
        }
        let e = Ts2(a);
        for (let s = 0; s < e.length; s++) a[e[s]] = Et2(a[e[s]], t);
        return t(a) || a;
      }
      var Be3 = Et2;
      function kr2(a, t) {
        let { parser: e, text: s } = t;
        if (a.type === "File" && a.program.interpreter) {
          let { program: { interpreter: i }, comments: r } = a;
          delete a.program.interpreter, r.unshift(i);
        }
        if (e === "babel") {
          let i = /* @__PURE__ */ new Set();
          a = Be3(a, (r) => {
            var n;
            (n = r.leadingComments) != null && n.some(xs2) && i.add(D(r));
          }), a = Be3(a, (r) => {
            if (r.type === "ParenthesizedExpression") {
              let { expression: n } = r;
              if (n.type === "TypeCastExpression") return n.range = [...r.range], n;
              let o = D(r);
              if (!i.has(o)) return n.extra = { ...n.extra, parenthesized: true }, n;
            }
          });
        }
        if (a = Be3(a, (i) => {
          var r;
          switch (i.type) {
            case "LogicalExpression":
              if (bs2(i)) return It2(i);
              break;
            case "VariableDeclaration": {
              let n = St2(false, i.declarations, -1);
              n != null && n.init && s[B(n)] !== ";" && (i.range = [D(i), B(n)]);
              break;
            }
            case "TSParenthesizedType":
              return i.typeAnnotation;
            case "TSTypeParameter":
              if (typeof i.name == "string") {
                let n = D(i);
                i.name = { type: "Identifier", name: i.name, range: [n, n + i.name.length] };
              }
              break;
            case "TopicReference":
              a.extra = { ...a.extra, __isUsingHackPipeline: true };
              break;
            case "ExportAllDeclaration":
              if (e === "meriyah" && ((r = i.exported) == null ? void 0 : r.type) === "Identifier") {
                let { exported: n } = i, o = s.slice(D(n), B(n));
                (o.startsWith('"') || o.startsWith("'")) && (i.exported = { ...i.exported, type: "Literal", value: i.exported.name, raw: o });
              }
              break;
            case "TSUnionType":
            case "TSIntersectionType":
              if (i.types.length === 1) return i.types[0];
              break;
          }
        }), Pe(a.comments)) {
          let i = St2(false, a.comments, -1);
          for (let r = a.comments.length - 2; r >= 0; r--) {
            let n = a.comments[r];
            B(n) === D(i) && ge(n) && ge(i) && wt(n) && wt(i) && (a.comments.splice(r + 1, 1), n.value += "*//*" + i.value, n.range = [D(n), B(i)]), i = n;
          }
        }
        return a.type === "Program" && (a.range = [0, s.length]), a;
      }
      function bs2(a) {
        return a.type === "LogicalExpression" && a.right.type === "LogicalExpression" && a.operator === a.right.operator;
      }
      function It2(a) {
        return bs2(a) ? It2({ type: "LogicalExpression", operator: a.operator, left: It2({ type: "LogicalExpression", operator: a.operator, left: a.left, right: a.right.left, range: [D(a.left), B(a.right.left)] }), right: a.right.right, range: [D(a), B(a)] }) : a;
      }
      var As2 = kr2;
      function vr2(a, t) {
        let e = new SyntaxError(a + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
        return Object.assign(e, t);
      }
      var Re = vr2;
      function Lr2(a) {
        let { message: t, loc: { line: e, column: s }, reasonCode: i } = a, r = a;
        (i === "MissingPlugin" || i === "MissingOneOfPlugins") && (t = "Unexpected token.", r = void 0);
        let n = ` (${e}:${s})`;
        return t.endsWith(n) && (t = t.slice(0, -n.length)), Re(t, { loc: { start: { line: e, column: s + 1 } }, cause: r });
      }
      var Ue = Lr2;
      var Dr2 = (a, t, e, s) => {
        if (!(a && t == null)) return t.replaceAll ? t.replaceAll(e, s) : e.global ? t.replace(e, s) : t.split(e).join(s);
      }, ie = Dr2;
      var Mr2 = /\*\/$/, Or2 = /^\/\*\*?/, Fr2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Br2 = /(^|\s+)\/\/([^\n\r]*)/g, Ss2 = /^(\r?\n)+/, Rr2 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ws2 = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Ur2 = /(\r?\n|^) *\* ?/g, _r2 = [];
      function Cs2(a) {
        let t = a.match(Fr2);
        return t ? t[0].trimStart() : "";
      }
      function Es2(a) {
        let t = `
`;
        a = ie(false, a.replace(Or2, "").replace(Mr2, ""), Ur2, "$1");
        let e = "";
        for (; e !== a; ) e = a, a = ie(false, a, Rr2, `${t}$1 $2${t}`);
        a = a.replace(Ss2, "").trimEnd();
        let s = /* @__PURE__ */ Object.create(null), i = ie(false, a, ws2, "").replace(Ss2, "").trimEnd(), r;
        for (; r = ws2.exec(a); ) {
          let n = ie(false, r[2], Br2, "");
          if (typeof s[r[1]] == "string" || Array.isArray(s[r[1]])) {
            let o = s[r[1]];
            s[r[1]] = [..._r2, ...Array.isArray(o) ? o : [o], n];
          } else s[r[1]] = n;
        }
        return { comments: i, pragmas: s };
      }
      function jr2(a) {
        let t = Fe2(a);
        t && (a = a.slice(t.length + 1));
        let e = Cs2(a), { pragmas: s, comments: i } = Es2(e);
        return { shebang: t, text: a, pragmas: s, comments: i };
      }
      function Is2(a) {
        let { pragmas: t } = jr2(a);
        return Object.prototype.hasOwnProperty.call(t, "prettier") || Object.prototype.hasOwnProperty.call(t, "format");
      }
      function $r2(a) {
        return a = typeof a == "function" ? { parse: a } : a, { astFormat: "estree", hasPragma: Is2, locStart: D, locEnd: B, ...a };
      }
      var G = $r2;
      function Vr2(a) {
        let { filepath: t } = a;
        if (t) {
          if (t = t.toLowerCase(), t.endsWith(".cjs")) return "script";
          if (t.endsWith(".mjs")) return "module";
        }
      }
      var Ns2 = Vr2;
      function qr2(a, t) {
        let { type: e = "JsExpressionRoot", rootMarker: s, text: i } = t, { tokens: r, comments: n } = a;
        return delete a.tokens, delete a.comments, { tokens: r, comments: n, type: e, node: a, range: [0, i.length], rootMarker: s };
      }
      var _e3 = qr2;
      var re = (a) => G(Jr2(a)), zr2 = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowNewTargetOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, createImportExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: true }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }], "recordAndTuple"], tokens: true, ranges: true }, ks2 = "v8intrinsic", vs2 = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], V = (a, t = zr2) => ({ ...t, plugins: [...t.plugins, ...a] }), Kr2 = /@(?:no)?flow\b/u;
      function Hr2(a, t) {
        var i;
        if ((i = t.filepath) != null && i.endsWith(".js.flow")) return true;
        let e = Fe2(a);
        e && (a = a.slice(e.length));
        let s = ds2(a, 0);
        return s !== false && (a = a.slice(0, s)), Kr2.test(a);
      }
      function Wr2(a, t, e) {
        let s = a(t, e), i = s.errors.find((r) => !Xr.has(r.reasonCode));
        if (i) throw i;
        return s;
      }
      function Jr2({ isExpression: a = false, optionsCombinations: t }) {
        return (e, s = {}) => {
          if ((s.parser === "babel" || s.parser === "__babel_estree") && Hr2(e, s)) return s.parser = "babel-flow", Bs2.parse(e, s);
          let i = t;
          (s.__babelSourceType ?? Ns2(s)) === "script" && (i = i.map((c) => ({ ...c, sourceType: "script" })));
          let n = /%[A-Z]/u.test(e);
          e.includes("|>") ? i = (n ? [...vs2, ks2] : vs2).flatMap((l) => i.map((u) => V([l], u))) : n && (i = i.map((c) => V([ks2], c)));
          let o = a ? je.parseExpression : je.parse, h;
          try {
            h = ms2(i.map((c) => () => Wr2(o, e, c)));
          } catch ({ errors: [c] }) {
            throw Ue(c);
          }
          return a && (h = _e3(h, { text: e, rootMarker: s.rootMarker })), As2(h, { parser: "babel", text: e });
        };
      }
      var Xr = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "ForInOfLoopInitializer", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Fs2 = [V(["jsx"])], Ls2 = re({ optionsCombinations: Fs2 }), Ds2 = re({ optionsCombinations: [V(["jsx", "typescript"]), V(["typescript"])] }), Ms2 = re({ isExpression: true, optionsCombinations: [V(["jsx"])] }), Os2 = re({ isExpression: true, optionsCombinations: [V(["typescript"])] }), Bs2 = re({ optionsCombinations: [V(["jsx", ["flow", { all: true, enums: true }], "flowComments"])] }), Gr2 = re({ optionsCombinations: Fs2.map((a) => V(["estree"], a)) }), Rs2 = { babel: Ls2, "babel-flow": Bs2, "babel-ts": Ds2, __js_expression: Ms2, __ts_expression: Os2, __vue_expression: Ms2, __vue_ts_expression: Os2, __vue_event_binding: Ls2, __vue_ts_event_binding: Ds2, __babel_estree: Gr2 };
      var Us2 = vt(At(), 1);
      function _s2(a = {}) {
        let { allowComments: t = true } = a;
        return function(s) {
          let i;
          try {
            i = (0, Us2.parseExpression)(s, { tokens: true, ranges: true, attachComment: false });
          } catch (r) {
            throw Ue(r);
          }
          if (!t && Pe(i.comments)) throw H(i.comments[0], "Comment");
          return ae(i), _e3(i, { type: "JsonRoot", text: s });
        };
      }
      function H(a, t) {
        let [e, s] = [a.loc.start, a.loc.end].map(({ line: i, column: r }) => ({ line: i, column: r + 1 }));
        return Re(`${t} is not allowed in JSON.`, { loc: { start: e, end: s } });
      }
      function ae(a) {
        switch (a.type) {
          case "ArrayExpression":
            for (let t of a.elements) t !== null && ae(t);
            return;
          case "ObjectExpression":
            for (let t of a.properties) ae(t);
            return;
          case "ObjectProperty":
            if (a.computed) throw H(a.key, "Computed key");
            if (a.shorthand) throw H(a.key, "Shorthand property");
            a.key.type !== "Identifier" && ae(a.key), ae(a.value);
            return;
          case "UnaryExpression": {
            let { operator: t, argument: e } = a;
            if (t !== "+" && t !== "-") throw H(a, `Operator '${a.operator}'`);
            if (e.type === "NumericLiteral" || e.type === "Identifier" && (e.name === "Infinity" || e.name === "NaN")) return;
            throw H(e, `Operator '${t}' before '${e.type}'`);
          }
          case "Identifier":
            if (a.name !== "Infinity" && a.name !== "NaN" && a.name !== "undefined") throw H(a, `Identifier '${a.name}'`);
            return;
          case "TemplateLiteral":
            if (Pe(a.expressions)) throw H(a.expressions[0], "'TemplateLiteral' with expression");
            for (let t of a.quasis) ae(t);
            return;
          case "NullLiteral":
          case "BooleanLiteral":
          case "NumericLiteral":
          case "StringLiteral":
          case "TemplateElement":
            return;
          default:
            throw H(a, `'${a.type}'`);
        }
      }
      var Nt = _s2(), Yr2 = { json: G({ parse: Nt, hasPragma() {
        return true;
      } }), json5: G(Nt), jsonc: G(Nt), "json-stringify": G({ parse: _s2({ allowComments: false }), astFormat: "estree-json" }) }, js2 = Yr2;
      var Qr2 = { ...Rs2, ...js2 };
      return Js2(Zr2);
    });
  }
});

// node_modules/lowcoder-sdk/dist/66703dd9.js
var _e2 = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var RT = Object.defineProperty;
var AT = (e, t, r) => t in e ? RT(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var Zr = (e, t, r) => (AT(e, typeof t != "symbol" ? t + "" : t, r), r);
var ap = 1024;
var cS = 0;
var Tr = class {
  constructor(t, r) {
    this.from = t, this.to = r;
  }
};
var Le = class {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = cS++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = or.match(t)), (r) => {
      let i = t(r);
      return i === void 0 ? null : [this, i];
    };
  }
};
Le.closedBy = new Le({ deserialize: (e) => e.split(" ") });
Le.openedBy = new Le({ deserialize: (e) => e.split(" ") });
Le.group = new Le({ deserialize: (e) => e.split(" ") });
Le.isolate = new Le({ deserialize: (e) => {
  if (e && e != "rtl" && e != "ltr" && e != "auto")
    throw new RangeError("Invalid value for isolate: " + e);
  return e || "auto";
} });
Le.contextHash = new Le({ perNode: true });
Le.lookAhead = new Le({ perNode: true });
Le.mounted = new Le({ perNode: true });
var qn = class {
  constructor(t, r, i) {
    this.tree = t, this.overlay = r, this.parser = i;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[Le.mounted.id];
  }
};
var fS = /* @__PURE__ */ Object.create(null);
var or = class sp {
  /**
  @internal
  */
  constructor(t, r, i, n = 0) {
    this.name = t, this.props = r, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let r = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : fS, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), n = new sp(t.name || "", r, t.id, i);
    if (t.props) {
      for (let a of t.props)
        if (Array.isArray(a) || (a = a(n)), a) {
          if (a[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[a[0].id] = a[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return true;
      let r = this.prop(Le.group);
      return r ? r.indexOf(t) > -1 : false;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let n of i.split(" "))
        r[n] = t[i];
    return (i) => {
      for (let n = i.prop(Le.group), a = -1; a < (n ? n.length : 0); a++) {
        let s = r[a < 0 ? i.name : n[a]];
        if (s)
          return s;
      }
    };
  }
};
or.none = new or(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var yu = class _yu {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let r = 0; r < t.length; r++)
      if (t[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let r = [];
    for (let i of this.types) {
      let n = null;
      for (let a of t) {
        let s = a(i);
        s && (n || (n = Object.assign({}, i.props)), n[s[0].id] = s[1]);
      }
      r.push(n ? new or(i.name, n, i.id, i.flags) : i);
    }
    return new _yu(r);
  }
};
var Da2 = /* @__PURE__ */ new WeakMap();
var $c = /* @__PURE__ */ new WeakMap();
var st;
(function(e) {
  e[e.ExcludeBuffers = 1] = "ExcludeBuffers", e[e.IncludeAnonymous = 2] = "IncludeAnonymous", e[e.IgnoreMounts = 4] = "IgnoreMounts", e[e.IgnoreOverlays = 8] = "IgnoreOverlays";
})(st || (st = {}));
var ht = class _ht {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, r, i, n, a) {
    if (this.type = t, this.children = r, this.positions = i, this.length = n, this.props = null, a && a.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, o] of a)
        this.props[typeof s == "number" ? s : s.id] = o;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = qn.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let r = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (r && (r += ","), r += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new ss(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, r = 0, i = 0) {
    let n = Da2.get(this) || this.topNode, a = new ss(n);
    return a.moveTo(t, r), Da2.set(this, a._tree), a;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Gt2(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, r = 0) {
    let i = Jn(Da2.get(this) || this.topNode, t, r, false);
    return Da2.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, r = 0) {
    let i = Jn($c.get(this) || this.topNode, t, r, true);
    return $c.set(this, i), i;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, r = 0) {
    return OS(this, t, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: r, leave: i, from: n = 0, to: a = this.length } = t, s = t.mode || 0, o = (s & st.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | st.IncludeAnonymous); ; ) {
      let c = false;
      if (l.from <= a && l.to >= n && (!o && l.type.isAnonymous || r(l) !== false)) {
        if (l.firstChild())
          continue;
        c = true;
      }
      for (; c && i && (o || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let r in this.props)
        t.push([+r, this.props[r]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : Pu(or.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, i, n) => new _ht(this.type, r, i, n, this.propValues), t.makeTree || ((r, i, n) => new _ht(or.none, r, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return ES(t);
  }
};
ht.empty = new ht(or.none, [], [], 0);
var Iu = class _Iu {
  constructor(t, r) {
    this.buffer = t, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _Iu(this.buffer, this.index);
  }
};
var Ti = class _Ti {
  /**
  Create a tree buffer.
  */
  constructor(t, r, i) {
    this.buffer = t, this.length = r, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return or.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let r = 0; r < this.buffer.length; )
      t.push(this.childString(r)), r = this.buffer[r + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let r = this.buffer[t], i = this.buffer[t + 3], n = this.set.types[r], a = n.name;
    if (/\W/.test(a) && !n.isError && (a = JSON.stringify(a)), t += 4, i == t)
      return a;
    let s = [];
    for (; t < i; )
      s.push(this.childString(t)), t = this.buffer[t + 3];
    return a + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, r, i, n, a) {
    let { buffer: s } = this, o = -1;
    for (let l = t; l != r && !(op(a, n, s[l + 1], s[l + 2]) && (o = l, i > 0)); l = s[l + 3])
      ;
    return o;
  }
  /**
  @internal
  */
  slice(t, r, i) {
    let n = this.buffer, a = new Uint16Array(r - t), s = 0;
    for (let o = t, l = 0; o < r; ) {
      a[l++] = n[o++], a[l++] = n[o++] - i;
      let c = a[l++] = n[o++] - i;
      a[l++] = n[o++] - t, s = Math.max(s, c);
    }
    return new _Ti(a, s, this.set);
  }
};
function op(e, t, r, i) {
  switch (e) {
    case -2:
      return r < t;
    case -1:
      return i >= t && r < t;
    case 0:
      return r < t && i > t;
    case 1:
      return r <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return true;
  }
}
function Jn(e, t, r, i) {
  for (var n; e.from == e.to || (r < 1 ? e.from >= t : e.from > t) || (r > -1 ? e.to <= t : e.to < t); ) {
    let s = !i && e instanceof Gt2 && e.index < 0 ? null : e.parent;
    if (!s)
      return e;
    e = s;
  }
  let a = i ? 0 : st.IgnoreOverlays;
  if (i)
    for (let s = e, o = s.parent; o; s = o, o = s.parent)
      s instanceof Gt2 && s.index < 0 && ((n = o.enter(t, r, a)) === null || n === void 0 ? void 0 : n.from) != s.from && (e = o);
  for (; ; ) {
    let s = e.enter(t, r, a);
    if (!s)
      return e;
    e = s;
  }
}
var lp = class {
  cursor(t = 0) {
    return new ss(this, t);
  }
  getChild(t, r = null, i = null) {
    let n = Yc(this, t, r, i);
    return n.length ? n[0] : null;
  }
  getChildren(t, r = null, i = null) {
    return Yc(this, t, r, i);
  }
  resolve(t, r = 0) {
    return Jn(this, t, r, false);
  }
  resolveInner(t, r = 0) {
    return Jn(this, t, r, true);
  }
  matchContext(t) {
    return tl(this, t);
  }
  enterUnfinishedNodesBefore(t) {
    let r = this.childBefore(t), i = this;
    for (; r; ) {
      let n = r.lastChild;
      if (!n || n.to != r.to)
        break;
      n.type.isError && n.from == n.to ? (i = r, r = n.prevSibling) : r = n;
    }
    return i;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var Gt2 = class _Gt extends lp {
  constructor(t, r, i, n) {
    super(), this._tree = t, this.from = r, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, r, i, n, a = 0) {
    for (let s = this; ; ) {
      for (let { children: o, positions: l } = s._tree, c = r > 0 ? o.length : -1; t != c; t += r) {
        let f = o[t], p = l[t] + s.from;
        if (op(n, i, p, p + f.length)) {
          if (f instanceof Ti) {
            if (a & st.ExcludeBuffers)
              continue;
            let O = f.findChild(0, f.buffer.length, r, i - p, n);
            if (O > -1)
              return new Qr(new hS(s, f, t, p), null, O);
          } else if (a & st.IncludeAnonymous || !f.type.isAnonymous || Nu(f)) {
            let O;
            if (!(a & st.IgnoreMounts) && (O = qn.get(f)) && !O.overlay)
              return new _Gt(O.tree, p, t, s);
            let d2 = new _Gt(f, p, t, s);
            return a & st.IncludeAnonymous || !d2.type.isAnonymous ? d2 : d2.nextChild(r < 0 ? f.children.length - 1 : 0, r, i, n);
          }
        }
      }
      if (a & st.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? t = s.index + r : t = r < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, r, i = 0) {
    let n;
    if (!(i & st.IgnoreOverlays) && (n = qn.get(this._tree)) && n.overlay) {
      let a = t - this.from;
      for (let { from: s, to: o } of n.overlay)
        if ((r > 0 ? s <= a : s < a) && (r < 0 ? o >= a : o > a))
          return new _Gt(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, r, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function Yc(e, t, r, i) {
  let n = e.cursor(), a = [];
  if (!n.firstChild())
    return a;
  if (r != null) {
    for (let s = false; !s; )
      if (s = n.type.is(r), !n.nextSibling())
        return a;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return a;
    if (n.type.is(t) && a.push(n.node), !n.nextSibling())
      return i == null ? a : [];
  }
}
function tl(e, t, r = t.length - 1) {
  for (let i = e.parent; r >= 0; i = i.parent) {
    if (!i)
      return false;
    if (!i.type.isAnonymous) {
      if (t[r] && t[r] != i.name)
        return false;
      r--;
    }
  }
  return true;
}
var hS = class {
  constructor(t, r, i, n) {
    this.parent = t, this.buffer = r, this.index = i, this.start = n;
  }
};
var Qr = class _Qr extends lp {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, r, i) {
    super(), this.context = t, this._parent = r, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  child(t, r, i) {
    let { buffer: n } = this.context, a = n.findChild(this.index + 4, n.buffer[this.index + 3], t, r - this.context.start, i);
    return a < 0 ? null : new _Qr(this.context, this, a);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, r, i = 0) {
    if (i & st.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, a = n.findChild(this.index + 4, n.buffer[this.index + 3], r > 0 ? 1 : -1, t - this.context.start, r);
    return a < 0 ? null : new _Qr(this.context, this, a);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, r = t.buffer[this.index + 3];
    return r < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new _Qr(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new _Qr(this.context, this._parent, t.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], r = [], { buffer: i } = this.context, n = this.index + 4, a = i.buffer[this.index + 3];
    if (a > n) {
      let s = i.buffer[this.index + 1];
      t.push(i.slice(n, a, s)), r.push(0);
    }
    return new ht(this.type, t, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function up(e) {
  if (!e.length)
    return null;
  let t = 0, r = e[0];
  for (let a = 1; a < e.length; a++) {
    let s = e[a];
    (s.from > r.from || s.to < r.to) && (r = s, t = a);
  }
  let i = r instanceof Gt2 && r.index < 0 ? null : r.parent, n = e.slice();
  return i ? n[t] = i : n.splice(t, 1), new pS(n, r);
}
var pS = class {
  constructor(t, r) {
    this.heads = t, this.node = r;
  }
  get next() {
    return up(this.heads);
  }
};
function OS(e, t, r) {
  let i = e.resolveInner(t, r), n = null;
  for (let a = i instanceof Gt2 ? i : i.context.parent; a; a = a.parent)
    if (a.index < 0) {
      let s = a.parent;
      (n || (n = [i])).push(s.resolve(t, r)), a = s;
    } else {
      let s = qn.get(a.tree);
      if (s && s.overlay && s.overlay[0].from <= t && s.overlay[s.overlay.length - 1].to >= t) {
        let o = new Gt2(s.tree, s.overlay[0].from + a.from, -1, a);
        (n || (n = [i])).push(Jn(o, t, r, false));
      }
    }
  return n ? up(n) : i;
}
var ss = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof Gt2)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, true) : false;
  }
  yieldBuf(t, r) {
    this.index = t;
    let { start: i, buffer: n } = this.buffer;
    return this.type = r || n.set.types[n.buffer[t]], this.from = i + n.buffer[t + 1], this.to = i + n.buffer[t + 2], true;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof Gt2 ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : false;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, r, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, r, i, this.mode));
    let { buffer: n } = this.buffer, a = n.findChild(this.index + 4, n.buffer[this.index + 3], t, r - this.buffer.start, i);
    return a < 0 ? false : (this.stack.push(this.index), this.yieldBuf(a));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, r, i = this.mode) {
    return this.buffer ? i & st.ExcludeBuffers ? false : this.enterChild(1, t, r) : this.yield(this._tree.enter(t, r, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & st.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & st.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : false;
    let { buffer: r } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(r.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = r.buffer[this.index + 3];
      if (n < (i < 0 ? r.buffer.length : r.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let r, i, { buffer: n } = this;
    if (n) {
      if (t > 0) {
        if (this.index < n.buffer.buffer.length)
          return false;
      } else
        for (let a = 0; a < this.index; a++)
          if (n.buffer.buffer[a + 3] < this.index)
            return false;
      ({ index: r, parent: i } = n);
    } else
      ({ index: r, _parent: i } = this._tree);
    for (; i; { index: r, _parent: i } = i)
      if (r > -1)
        for (let a = r + t, s = t < 0 ? -1 : i._tree.children.length; a != s; a += t) {
          let o = i._tree.children[a];
          if (this.mode & st.IncludeAnonymous || o instanceof Ti || !o.type.isAnonymous || Nu(o))
            return false;
        }
    return true;
  }
  move(t, r) {
    if (r && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(t))
        return true;
      if (this.atLastNode(t) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = true) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = true) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= t : this.from > t) || (r > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, r = null, i = 0;
    if (t && t.context == this.buffer)
      e:
        for (let n = this.index, a = this.stack.length; a >= 0; ) {
          for (let s = t; s; s = s._parent)
            if (s.index == n) {
              if (n == this.index)
                return s;
              r = s, i = a + 1;
              break e;
            }
          n = this.stack[--a];
        }
    for (let n = i; n < this.stack.length; n++)
      r = new Qr(this.buffer, r, this.stack[n]);
    return this.bufferNode = new Qr(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, r) {
    for (let i = 0; ; ) {
      let n = false;
      if (this.type.isAnonymous || t(this) !== false) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = true);
      }
      for (; n && r && r(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = true;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return tl(this.node, t);
    let { buffer: r } = this.buffer, { types: i } = r.set;
    for (let n = t.length - 1, a = this.stack.length - 1; n >= 0; a--) {
      if (a < 0)
        return tl(this.node, t, n);
      let s = i[r.buffer[this.stack[a]]];
      if (!s.isAnonymous) {
        if (t[n] && t[n] != s.name)
          return false;
        n--;
      }
    }
    return true;
  }
};
function Nu(e) {
  return e.children.some((t) => t instanceof Ti || !t.type.isAnonymous || Nu(t));
}
function ES(e) {
  var t;
  let { buffer: r, nodeSet: i, maxBufferLength: n = ap, reused: a = [], minRepeatType: s = i.types.length } = e, o = Array.isArray(r) ? new Iu(r, r.length) : r, l = i.types, c = 0, f = 0;
  function p($, z, F, ae, U, G) {
    let { id: H, start: re, end: B, size: Y } = o, E = f;
    for (; Y < 0; )
      if (o.next(), Y == -1) {
        let y2 = a[H];
        F.push(y2), ae.push(re - $);
        return;
      } else if (Y == -3) {
        c = H;
        return;
      } else if (Y == -4) {
        f = H;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${Y}`);
    let m = l[H], P, R, A = re - $;
    if (B - re <= n && (R = D(o.pos - z, U))) {
      let y2 = new Uint16Array(R.size - R.skip), C = o.pos - R.size, j = y2.length;
      for (; o.pos > C; )
        j = W(R.start, y2, j);
      P = new Ti(y2, B - R.start, i), A = R.start - $;
    } else {
      let y2 = o.pos - Y;
      o.next();
      let C = [], j = [], w = H >= s ? H : -1, J = 0, te = B;
      for (; o.pos > y2; )
        w >= 0 && o.id == w && o.size >= 0 ? (o.end <= te - n && (g(C, j, re, J, o.end, te, w, E), J = C.length, te = o.end), o.next()) : G > 2500 ? O(re, y2, C, j) : p(re, y2, C, j, w, G + 1);
      if (w >= 0 && J > 0 && J < C.length && g(C, j, re, J, re, te, w, E), C.reverse(), j.reverse(), w > -1 && J > 0) {
        let se = d2(m);
        P = Pu(m, C, j, 0, C.length, 0, B - re, se, se);
      } else
        P = L(m, C, j, B - re, E - B);
    }
    F.push(P), ae.push(A);
  }
  function O($, z, F, ae) {
    let U = [], G = 0, H = -1;
    for (; o.pos > z; ) {
      let { id: re, start: B, end: Y, size: E } = o;
      if (E > 4)
        o.next();
      else {
        if (H > -1 && B < H)
          break;
        H < 0 && (H = Y - n), U.push(re, B, Y), G++, o.next();
      }
    }
    if (G) {
      let re = new Uint16Array(G * 4), B = U[U.length - 2];
      for (let Y = U.length - 3, E = 0; Y >= 0; Y -= 3)
        re[E++] = U[Y], re[E++] = U[Y + 1] - B, re[E++] = U[Y + 2] - B, re[E++] = E;
      F.push(new Ti(re, U[2] - B, i)), ae.push(B - $);
    }
  }
  function d2($) {
    return (z, F, ae) => {
      let U = 0, G = z.length - 1, H, re;
      if (G >= 0 && (H = z[G]) instanceof ht) {
        if (!G && H.type == $ && H.length == ae)
          return H;
        (re = H.prop(Le.lookAhead)) && (U = F[G] + H.length + re);
      }
      return L($, z, F, ae, U);
    };
  }
  function g($, z, F, ae, U, G, H, re) {
    let B = [], Y = [];
    for (; $.length > ae; )
      B.push($.pop()), Y.push(z.pop() + F - U);
    $.push(L(i.types[H], B, Y, G - U, re - G)), z.push(U - F);
  }
  function L($, z, F, ae, U = 0, G) {
    if (c) {
      let H = [Le.contextHash, c];
      G = G ? [H].concat(G) : [H];
    }
    if (U > 25) {
      let H = [Le.lookAhead, U];
      G = G ? [H].concat(G) : [H];
    }
    return new ht($, z, F, ae, G);
  }
  function D($, z) {
    let F = o.fork(), ae = 0, U = 0, G = 0, H = F.end - n, re = { size: 0, start: 0, skip: 0 };
    e:
      for (let B = F.pos - $; F.pos > B; ) {
        let Y = F.size;
        if (F.id == z && Y >= 0) {
          re.size = ae, re.start = U, re.skip = G, G += 4, ae += 4, F.next();
          continue;
        }
        let E = F.pos - Y;
        if (Y < 0 || E < B || F.start < H)
          break;
        let m = F.id >= s ? 4 : 0, P = F.start;
        for (F.next(); F.pos > E; ) {
          if (F.size < 0)
            if (F.size == -3)
              m += 4;
            else
              break e;
          else
            F.id >= s && (m += 4);
          F.next();
        }
        U = P, ae += Y, G += m;
      }
    return (z < 0 || ae == $) && (re.size = ae, re.start = U, re.skip = G), re.size > 4 ? re : void 0;
  }
  function W($, z, F) {
    let { id: ae, start: U, end: G, size: H } = o;
    if (o.next(), H >= 0 && ae < s) {
      let re = F;
      if (H > 4) {
        let B = o.pos - (H - 4);
        for (; o.pos > B; )
          F = W($, z, F);
      }
      z[--F] = re, z[--F] = G - $, z[--F] = U - $, z[--F] = ae;
    } else
      H == -3 ? c = ae : H == -4 && (f = ae);
    return F;
  }
  let x = [], V = [];
  for (; o.pos > 0; )
    p(e.start || 0, e.bufferStart || 0, x, V, -1, 0);
  let _2 = (t = e.length) !== null && t !== void 0 ? t : x.length ? V[0] + x[0].length : 0;
  return new ht(l[e.topID], x.reverse(), V.reverse(), _2);
}
var Fc = /* @__PURE__ */ new WeakMap();
function es(e, t) {
  if (!e.isAnonymous || t instanceof Ti || t.type != e)
    return 1;
  let r = Fc.get(t);
  if (r == null) {
    r = 1;
    for (let i of t.children) {
      if (i.type != e || !(i instanceof ht)) {
        r = 1;
        break;
      }
      r += es(e, i);
    }
    Fc.set(t, r);
  }
  return r;
}
function Pu(e, t, r, i, n, a, s, o, l) {
  let c = 0;
  for (let g = i; g < n; g++)
    c += es(e, t[g]);
  let f = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), p = [], O = [];
  function d2(g, L, D, W, x) {
    for (let V = D; V < W; ) {
      let _2 = V, $ = L[V], z = es(e, g[V]);
      for (V++; V < W; V++) {
        let F = es(e, g[V]);
        if (z + F >= f)
          break;
        z += F;
      }
      if (V == _2 + 1) {
        if (z > f) {
          let F = g[_2];
          d2(F.children, F.positions, 0, F.children.length, L[_2] + x);
          continue;
        }
        p.push(g[_2]);
      } else {
        let F = L[V - 1] + g[V - 1].length - $;
        p.push(Pu(e, g, L, _2, V, $, F, null, l));
      }
      O.push($ + x - a);
    }
  }
  return d2(t, r, i, n, 0), (o || l)(p, O, s);
}
var cp = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(t, r, i) {
    let n = this.map.get(t);
    n || this.map.set(t, n = /* @__PURE__ */ new Map()), n.set(r, i);
  }
  getBuffer(t, r) {
    let i = this.map.get(t);
    return i && i.get(r);
  }
  /**
  Set the value for this syntax node.
  */
  set(t, r) {
    t instanceof Qr ? this.setBuffer(t.context.buffer, t.index, r) : t instanceof Gt2 && this.map.set(t.tree, r);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(t) {
    return t instanceof Qr ? this.getBuffer(t.context.buffer, t.index) : t instanceof Gt2 ? this.map.get(t.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(t, r) {
    t.buffer ? this.setBuffer(t.buffer.buffer, t.index, r) : this.map.set(t.tree, r);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(t) {
    return t.buffer ? this.getBuffer(t.buffer.buffer, t.index) : this.map.get(t.tree);
  }
};
var Jr = class _Jr {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, r, i, n, a = false, s = false) {
    this.from = t, this.to = r, this.tree = i, this.offset = n, this.open = (a ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, r = [], i = false) {
    let n = [new _Jr(0, t.length, t, 0, false, i)];
    for (let a of r)
      a.to > t.length && n.push(a);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, r, i = 128) {
    if (!r.length)
      return t;
    let n = [], a = 1, s = t.length ? t[0] : null;
    for (let o = 0, l = 0, c = 0; ; o++) {
      let f = o < r.length ? r[o] : null, p = f ? f.fromA : 1e9;
      if (p - l >= i)
        for (; s && s.from < p; ) {
          let O = s;
          if (l >= O.from || p <= O.to || c) {
            let d2 = Math.max(O.from, l) - c, g = Math.min(O.to, p) - c;
            O = d2 >= g ? null : new _Jr(d2, g, O.tree, O.offset + c, o > 0, !!f);
          }
          if (O && n.push(O), s.to > p)
            break;
          s = a < t.length ? t[a++] : null;
        }
      if (!f)
        break;
      l = f.toA, c = f.toA - f.toB;
    }
    return n;
  }
};
var fp = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, r, i) {
    return typeof t == "string" && (t = new dS(t)), i = i ? i.length ? i.map((n) => new Tr(n.from, n.to)) : [new Tr(0, 0)] : [new Tr(0, t.length)], this.createParse(t, r || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, r, i) {
    let n = this.startParse(t, r, i);
    for (; ; ) {
      let a = n.advance();
      if (a)
        return a;
    }
  }
};
var dS = class {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return false;
  }
  read(t, r) {
    return this.string.slice(t, r);
  }
};
function TS2(e) {
  return (t, r, i, n) => new mS(t, e, r, i, n);
}
var Wc = class {
  constructor(t, r, i, n, a) {
    this.parser = t, this.parse = r, this.overlay = i, this.target = n, this.from = a;
  }
};
function Xc(e) {
  if (!e.length || e.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(e));
}
var SS = class {
  constructor(t, r, i, n, a, s, o) {
    this.parser = t, this.predicate = r, this.mounts = i, this.index = n, this.start = a, this.target = s, this.prev = o, this.depth = 0, this.ranges = [];
  }
};
var rl = new Le({ perNode: true });
var mS = class {
  constructor(t, r, i, n, a) {
    this.nest = r, this.input = i, this.fragments = n, this.ranges = a, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new ht(i.type, i.children, i.positions, i.length, i.propValues.concat([[rl, this.stoppedAt]]))), i;
    }
    let t = this.inner[this.innerDone], r = t.parse.advance();
    if (r) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      i[Le.mounted.id] = new qn(r, t.overlay, t.parser), t.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let r = this.innerDone; r < this.inner.length; r++)
      this.inner[r].from < t && (t = Math.min(t, this.inner[r].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let r = this.innerDone; r < this.inner.length; r++)
        this.inner[r].parse.stopAt(t);
  }
  startInner() {
    let t = new gS(this.fragments), r = null, i = null, n = new ss(new Gt2(this.baseTree, this.ranges[0].from, 0, null), st.IncludeAnonymous | st.IgnoreMounts);
    e:
      for (let a, s; ; ) {
        let o = true, l;
        if (this.stoppedAt != null && n.from >= this.stoppedAt)
          o = false;
        else if (t.hasNode(n)) {
          if (r) {
            let c = r.mounts.find((f) => f.frag.from <= n.from && f.frag.to >= n.to && f.mount.overlay);
            if (c)
              for (let f of c.mount.overlay) {
                let p = f.from + c.pos, O = f.to + c.pos;
                p >= n.from && O <= n.to && !r.ranges.some((d2) => d2.from < O && d2.to > p) && r.ranges.push({ from: p, to: O });
              }
          }
          o = false;
        } else if (i && (s = RS(i.ranges, n.from, n.to)))
          o = s != 2;
        else if (!n.type.isAnonymous && (a = this.nest(n, this.input)) && (n.from < n.to || !a.overlay)) {
          n.tree || AS(n);
          let c = t.findMounts(n.from, a.parser);
          if (typeof a.overlay == "function")
            r = new SS(a.parser, a.overlay, c, this.inner.length, n.from, n.tree, r);
          else {
            let f = Hc(this.ranges, a.overlay || (n.from < n.to ? [new Tr(n.from, n.to)] : []));
            f.length && Xc(f), (f.length || !a.overlay) && this.inner.push(new Wc(a.parser, f.length ? a.parser.startParse(this.input, zc(c, f), f) : a.parser.startParse(""), a.overlay ? a.overlay.map((p) => new Tr(p.from - n.from, p.to - n.from)) : null, n.tree, f.length ? f[0].from : n.from)), a.overlay ? f.length && (i = { ranges: f, depth: 0, prev: i }) : o = false;
          }
        } else
          r && (l = r.predicate(n)) && (l === true && (l = new Tr(n.from, n.to)), l.from < l.to && r.ranges.push(l));
        if (o && n.firstChild())
          r && r.depth++, i && i.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (r && !--r.depth) {
              let c = Hc(this.ranges, r.ranges);
              c.length && (Xc(c), this.inner.splice(r.index, 0, new Wc(r.parser, r.parser.startParse(this.input, zc(r.mounts, c), c), r.ranges.map((f) => new Tr(f.from - r.start, f.to - r.start)), r.target, c[0].from))), r = r.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
};
function RS(e, t, r) {
  for (let i of e) {
    if (i.from >= r)
      break;
    if (i.to > t)
      return i.from <= t && i.to >= r ? 2 : 1;
  }
  return 0;
}
function jc(e, t, r, i, n, a) {
  if (t < r) {
    let s = e.buffer[t + 1];
    i.push(e.slice(t, r, s)), n.push(s - a);
  }
}
function AS(e) {
  let { node: t } = e, r = [], i = t.context.buffer;
  do
    r.push(e.index), e.parent();
  while (!e.tree);
  let n = e.tree, a = n.children.indexOf(i), s = n.children[a], o = s.buffer, l = [a];
  function c(f, p, O, d2, g, L) {
    let D = r[L], W = [], x = [];
    jc(s, f, D, W, x, d2);
    let V = o[D + 1], _2 = o[D + 2];
    l.push(W.length);
    let $ = L ? c(D + 4, o[D + 3], s.set.types[o[D]], V, _2 - V, L - 1) : t.toTree();
    return W.push($), x.push(V - d2), jc(s, o[D + 3], p, W, x, d2), new ht(O, W, x, g);
  }
  n.children[a] = c(0, o.length, or.none, 0, s.length, r.length - 1);
  for (let f of l) {
    let p = e.tree.children[f], O = e.tree.positions[f];
    e.yield(new Gt2(p, O + e.from, f, e._tree));
  }
}
var Zc = class {
  constructor(t, r) {
    this.offset = r, this.done = false, this.cursor = t.cursor(st.IncludeAnonymous | st.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: r } = this, i = t - this.offset;
    for (; !this.done && r.from < i; )
      r.to >= t && r.enter(i, 1, st.IgnoreOverlays | st.ExcludeBuffers) || r.next(false) || (this.done = true);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let r = this.cursor.tree; ; ) {
        if (r == t.tree)
          return true;
        if (r.children.length && r.positions[0] == 0 && r.children[0] instanceof ht)
          r = r.children[0];
        else
          break;
      }
    return false;
  }
};
var gS = class {
  constructor(t) {
    var r;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let i = this.curFrag = t[0];
      this.curTo = (r = i.tree.prop(rl)) !== null && r !== void 0 ? r : i.to, this.inner = new Zc(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let r = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = r.tree.prop(rl)) !== null && t !== void 0 ? t : r.to, this.inner = new Zc(r.tree, -r.offset);
    }
  }
  findMounts(t, r) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let a = this.inner.cursor.node; a; a = a.parent) {
        let s = (i = a.tree) === null || i === void 0 ? void 0 : i.prop(Le.mounted);
        if (s && s.parser == r)
          for (let o = this.fragI; o < this.fragments.length; o++) {
            let l = this.fragments[o];
            if (l.from >= a.to)
              break;
            l.tree == this.curFrag.tree && n.push({
              frag: l,
              pos: a.from - l.offset,
              mount: s
            });
          }
      }
    }
    return n;
  }
};
function Hc(e, t) {
  let r = null, i = t;
  for (let n = 1, a = 0; n < e.length; n++) {
    let s = e[n - 1].to, o = e[n].from;
    for (; a < i.length; a++) {
      let l = i[a];
      if (l.from >= o)
        break;
      l.to <= s || (r || (i = r = t.slice()), l.from < s ? (r[a] = new Tr(l.from, s), l.to > o && r.splice(a + 1, 0, new Tr(o, l.to))) : l.to > o ? r[a--] = new Tr(o, l.to) : r.splice(a--, 1));
    }
  }
  return i;
}
function yS(e, t, r, i) {
  let n = 0, a = 0, s = false, o = false, l = -1e9, c = [];
  for (; ; ) {
    let f = n == e.length ? 1e9 : s ? e[n].to : e[n].from, p = a == t.length ? 1e9 : o ? t[a].to : t[a].from;
    if (s != o) {
      let O = Math.max(l, r), d2 = Math.min(f, p, i);
      O < d2 && c.push(new Tr(O, d2));
    }
    if (l = Math.min(f, p), l == 1e9)
      break;
    f == l && (s ? (s = false, n++) : s = true), p == l && (o ? (o = false, a++) : o = true);
  }
  return c;
}
function zc(e, t) {
  let r = [];
  for (let { pos: i, mount: n, frag: a } of e) {
    let s = i + (n.overlay ? n.overlay[0].from : 0), o = s + n.tree.length, l = Math.max(a.from, s), c = Math.min(a.to, o);
    if (n.overlay) {
      let f = n.overlay.map((O) => new Tr(O.from + i, O.to + i)), p = yS(t, f, l, c);
      for (let O = 0, d2 = l; ; O++) {
        let g = O == p.length, L = g ? c : p[O].from;
        if (L > d2 && r.push(new Jr(d2, L, n.tree, -s, a.from >= d2 || a.openStart, a.to <= L || a.openEnd)), g)
          break;
        d2 = p[O].to;
      }
    } else
      r.push(new Jr(l, c, n.tree, -s, a.from >= s || a.openStart, a.to <= o || a.openEnd));
  }
  return r;
}
var IS = 0;
var Mr = class _Mr {
  /**
  @internal
  */
  constructor(t, r, i) {
    this.set = t, this.base = r, this.modified = i, this.id = IS++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(t) {
    if (t != null && t.base)
      throw new Error("Can not derive from a modified tag");
    let r = new _Mr([], null, []);
    if (r.set.push(r), t)
      for (let i of t.set)
        r.set.push(i);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let t = new os();
    return (r) => r.modified.indexOf(t) > -1 ? r : os.get(r.base || r, r.modified.concat(t).sort((i, n) => i.id - n.id));
  }
};
var NS = 0;
var os = class _os {
  constructor() {
    this.instances = [], this.id = NS++;
  }
  static get(t, r) {
    if (!r.length)
      return t;
    let i = r[0].instances.find((o) => o.base == t && PS(r, o.modified));
    if (i)
      return i;
    let n = [], a = new Mr(n, t, r);
    for (let o of r)
      o.instances.push(a);
    let s = _S(r);
    for (let o of t.set)
      if (!o.modified.length)
        for (let l of s)
          n.push(_os.get(o, l));
    return a;
  }
};
function PS(e, t) {
  return e.length == t.length && e.every((r, i) => r == t[i]);
}
function _S(e) {
  let t = [[]];
  for (let r = 0; r < e.length; r++)
    for (let i = 0, n = t.length; i < n; i++)
      t.push(t[i].concat(e[r]));
  return t.sort((r, i) => i.length - r.length);
}
function An(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in e) {
    let i = e[r];
    Array.isArray(i) || (i = [i]);
    for (let n of r.split(" "))
      if (n) {
        let a = [], s = 2, o = n;
        for (let p = 0; ; ) {
          if (o == "..." && p > 0 && p + 3 == n.length) {
            s = 1;
            break;
          }
          let O = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o);
          if (!O)
            throw new RangeError("Invalid path: " + n);
          if (a.push(O[0] == "*" ? "" : O[0][0] == '"' ? JSON.parse(O[0]) : O[0]), p += O[0].length, p == n.length)
            break;
          let d2 = n[p++];
          if (p == n.length && d2 == "!") {
            s = 0;
            break;
          }
          if (d2 != "/")
            throw new RangeError("Invalid path: " + n);
          o = n.slice(p);
        }
        let l = a.length - 1, c = a[l];
        if (!c)
          throw new RangeError("Invalid path: " + n);
        let f = new ls(i, s, l > 0 ? a.slice(0, l) : null);
        t[c] = f.sort(t[c]);
      }
  }
  return hp.add(t);
}
var hp = new Le();
var ls = class {
  constructor(t, r, i, n) {
    this.tags = t, this.mode = r, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
ls.empty = new ls([], 2, null);
function pp(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let a of e)
    if (!Array.isArray(a.tag))
      r[a.tag.id] = a.class;
    else
      for (let s of a.tag)
        r[s.id] = a.class;
  let { scope: i, all: n = null } = t || {};
  return {
    style: (a) => {
      let s = n;
      for (let o of a)
        for (let l of o.set) {
          let c = r[l.id];
          if (c) {
            s = s ? s + " " + c : c;
            break;
          }
        }
      return s;
    },
    scope: i
  };
}
function bS(e, t) {
  let r = null;
  for (let i of e) {
    let n = i.style(t);
    n && (r = r ? r + " " + n : n);
  }
  return r;
}
function vS(e, t, r, i = 0, n = e.length) {
  let a = new CS(i, Array.isArray(t) ? t : [t], r);
  a.highlightRange(e.cursor(), i, n, "", a.highlighters), a.flush(n);
}
var CS = class {
  constructor(t, r, i) {
    this.at = t, this.highlighters = r, this.span = i, this.class = "";
  }
  startSpan(t, r) {
    r != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = r);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, r, i, n, a) {
    let { type: s, from: o, to: l } = t;
    if (o >= i || l <= r)
      return;
    s.isTop && (a = this.highlighters.filter((d2) => !d2.scope || d2.scope(s)));
    let c = n, f = LS(t) || ls.empty, p = bS(a, f.tags);
    if (p && (c && (c += " "), c += p, f.mode == 1 && (n += (n ? " " : "") + p)), this.startSpan(Math.max(r, o), c), f.opaque)
      return;
    let O = t.tree && t.tree.prop(Le.mounted);
    if (O && O.overlay) {
      let d2 = t.node.enter(O.overlay[0].from + o, 1), g = this.highlighters.filter((D) => !D.scope || D.scope(O.tree.type)), L = t.firstChild();
      for (let D = 0, W = o; ; D++) {
        let x = D < O.overlay.length ? O.overlay[D] : null, V = x ? x.from + o : l, _2 = Math.max(r, W), $ = Math.min(i, V);
        if (_2 < $ && L)
          for (; t.from < $ && (this.highlightRange(t, _2, $, n, a), this.startSpan(Math.min($, t.to), c), !(t.to >= V || !t.nextSibling())); )
            ;
        if (!x || V > i)
          break;
        W = x.to + o, W > r && (this.highlightRange(d2.cursor(), Math.max(r, x.from + o), Math.min(i, W), "", g), this.startSpan(Math.min(i, W), c));
      }
      L && t.parent();
    } else if (t.firstChild()) {
      O && (n = "");
      do
        if (!(t.to <= r)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, r, i, n, a), this.startSpan(Math.min(i, t.to), c);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
};
function LS(e) {
  let t = e.type.prop(hp);
  for (; t && t.context && !e.matchContext(t.context); )
    t = t.next;
  return t || null;
}
var ue = Mr.define;
var Ua = ue();
var fi = ue();
var qc = ue(fi);
var Jc = ue(fi);
var hi = ue();
var wa = ue(hi);
var So = ue(hi);
var wr = ue();
var _i = ue(wr);
var Dr = ue();
var Ur = ue();
var il = ue();
var xn = ue(il);
var Ma = ue();
var Q = {
  /**
  A comment.
  */
  comment: Ua,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ue(Ua),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ue(Ua),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ue(Ua),
  /**
  Any kind of identifier.
  */
  name: fi,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ue(fi),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: qc,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ue(qc),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Jc,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ue(Jc),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ue(fi),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ue(fi),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ue(fi),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ue(fi),
  /**
  A literal value.
  */
  literal: hi,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: wa,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ue(wa),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ue(wa),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ue(wa),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: So,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ue(So),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ue(So),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ue(hi),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ue(hi),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ue(hi),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ue(hi),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ue(hi),
  /**
  A language keyword.
  */
  keyword: Dr,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ue(Dr),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ue(Dr),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ue(Dr),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ue(Dr),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ue(Dr),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ue(Dr),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ue(Dr),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ue(Dr),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ue(Dr),
  /**
  An operator.
  */
  operator: Ur,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ue(Ur),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ue(Ur),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ue(Ur),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ue(Ur),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ue(Ur),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ue(Ur),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ue(Ur),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ue(Ur),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ue(Ur),
  /**
  Program or markup punctuation.
  */
  punctuation: il,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ue(il),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: xn,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ue(xn),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ue(xn),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ue(xn),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ue(xn),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: wr,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: _i,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ue(_i),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ue(_i),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ue(_i),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ue(_i),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ue(_i),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ue(_i),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: ue(wr),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ue(wr),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ue(wr),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ue(wr),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ue(wr),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ue(wr),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ue(wr),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ue(wr),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ue(),
  /**
  Deleted text.
  */
  deleted: ue(),
  /**
  Changed text.
  */
  changed: ue(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ue(),
  /**
  Metadata or meta-instruction.
  */
  meta: Ma,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ue(Ma),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ue(Ma),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ue(Ma),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Mr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Mr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Mr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Mr.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Mr.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Mr.defineModifier()
};
pp([
  { tag: Q.link, class: "tok-link" },
  { tag: Q.heading, class: "tok-heading" },
  { tag: Q.emphasis, class: "tok-emphasis" },
  { tag: Q.strong, class: "tok-strong" },
  { tag: Q.keyword, class: "tok-keyword" },
  { tag: Q.atom, class: "tok-atom" },
  { tag: Q.bool, class: "tok-bool" },
  { tag: Q.url, class: "tok-url" },
  { tag: Q.labelName, class: "tok-labelName" },
  { tag: Q.inserted, class: "tok-inserted" },
  { tag: Q.deleted, class: "tok-deleted" },
  { tag: Q.literal, class: "tok-literal" },
  { tag: Q.string, class: "tok-string" },
  { tag: Q.number, class: "tok-number" },
  { tag: [Q.regexp, Q.escape, Q.special(Q.string)], class: "tok-string2" },
  { tag: Q.variableName, class: "tok-variableName" },
  { tag: Q.local(Q.variableName), class: "tok-variableName tok-local" },
  { tag: Q.definition(Q.variableName), class: "tok-variableName tok-definition" },
  { tag: Q.special(Q.variableName), class: "tok-variableName2" },
  { tag: Q.definition(Q.propertyName), class: "tok-propertyName tok-definition" },
  { tag: Q.typeName, class: "tok-typeName" },
  { tag: Q.namespace, class: "tok-namespace" },
  { tag: Q.className, class: "tok-className" },
  { tag: Q.macroName, class: "tok-macroName" },
  { tag: Q.propertyName, class: "tok-propertyName" },
  { tag: Q.operator, class: "tok-operator" },
  { tag: Q.comment, class: "tok-comment" },
  { tag: Q.meta, class: "tok-meta" },
  { tag: Q.invalid, class: "tok-invalid" },
  { tag: Q.punctuation, class: "tok-punctuation" }
]);
var mo;
var tn = new Le();
function Op(e) {
  return Tn.define({
    combine: e ? (t) => t.concat(e) : void 0
  });
}
var _u = new Le();
var vr = class {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, r, i = [], n = "") {
    this.data = t, this.name = n, i3.prototype.hasOwnProperty("tree") || Object.defineProperty(i3.prototype, "tree", { get() {
      return Ot(this);
    } }), this.parser = r, this.extension = [
      mi.of(this),
      i3.languageData.of((a, s, o) => {
        let l = Kc(a, s, o), c = l.type.prop(tn);
        if (!c)
          return [];
        let f = a.facet(c), p = l.type.prop(_u);
        if (p) {
          let O = l.resolve(s - l.from, o);
          for (let d2 of p)
            if (d2.test(O, a)) {
              let g = a.facet(d2.facet);
              return d2.type == "replace" ? g : g.concat(f);
            }
        }
        return f;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, r, i = -1) {
    return Kc(t, r, i).type.prop(tn) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let r = t.facet(mi);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let i = [], n = (a, s) => {
      if (a.prop(tn) == this.data) {
        i.push({ from: s, to: s + a.length });
        return;
      }
      let o = a.prop(Le.mounted);
      if (o) {
        if (o.tree.prop(tn) == this.data) {
          if (o.overlay)
            for (let l of o.overlay)
              i.push({ from: l.from + s, to: l.to + s });
          else
            i.push({ from: s, to: s + a.length });
          return;
        } else if (o.overlay) {
          let l = i.length;
          if (n(o.tree, o.overlay[0].from + s), i.length > l)
            return;
        }
      }
      for (let l = 0; l < a.children.length; l++) {
        let c = a.children[l];
        c instanceof ht && n(c, a.positions[l] + s);
      }
    };
    return n(Ot(t), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return true;
  }
};
vr.setState = Eo.define();
function Kc(e, t, r) {
  let i = e.facet(mi), n = Ot(e).topNode;
  if (!i || i.allowsNesting)
    for (let a = n; a; a = a.enter(t, r, st.ExcludeBuffers))
      a.type.isTop && (n = a);
  return n;
}
var Si = class _Si extends vr {
  constructor(t, r, i) {
    super(t, r, [], i), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let r = Op(t.languageData);
    return new _Si(r, t.parser.configure({
      props: [tn.add((i) => i.isTop ? r : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, r) {
    return new _Si(this.data, this.parser.configure(t), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
};
function Ot(e) {
  let t = e.field(vr.state, false);
  return t ? t.tree : ht.empty;
}
var xS = class {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return true;
  }
  read(t, r) {
    let i = this.cursorPos - this.string.length;
    return t < i || r >= this.cursorPos ? this.doc.sliceString(t, r) : this.string.slice(t - i, r - i);
  }
};
var Dn = null;
var us2 = class _us {
  constructor(t, r, i = [], n, a, s, o, l) {
    this.parser = t, this.state = r, this.fragments = i, this.tree = n, this.treeLen = a, this.viewport = s, this.skipped = o, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, r, i) {
    return new _us(t, r, [], ht.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new xS(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != ht.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), true) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let n = Date.now() + t;
        t = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(Jr.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        if (t())
          return false;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, r;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = r, this.fragments = this.withoutTempSkipped(Jr.addTree(this.tree, this.fragments, true)), this.parse = null);
  }
  withContext(t) {
    let r = Dn;
    Dn = this;
    try {
      return t();
    } finally {
      Dn = r;
    }
  }
  withoutTempSkipped(t) {
    for (let r; r = this.tempSkipped.pop(); )
      t = ef(t, r.from, r.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, r) {
    let { fragments: i, tree: n, treeLen: a, viewport: s, skipped: o } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((c, f, p, O) => l.push({ fromA: c, toA: f, fromB: p, toB: O })), i = Jr.applyChanges(i, l), n = ht.empty, a = 0, s = { from: t.mapPos(s.from, -1), to: t.mapPos(s.to, 1) }, this.skipped.length) {
        o = [];
        for (let c of this.skipped) {
          let f = t.mapPos(c.from, 1), p = t.mapPos(c.to, -1);
          f < p && o.push({ from: f, to: p });
        }
      }
    }
    return new _us(this.parser, r, i, n, a, s, o, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return false;
    this.viewport = t;
    let r = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: a } = this.skipped[i];
      n < t.to && a > t.from && (this.fragments = ef(this.fragments, n, a), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= r ? false : (this.reset(), true);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, r) {
    this.skipped.push({ from: t, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends fp {
      createParse(r, i, n) {
        let a = n[0].from, s = n[n.length - 1].to;
        return {
          parsedPos: a,
          advance() {
            let l = Dn;
            if (l) {
              for (let c of n)
                l.tempSkipped.push(c);
              t && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, t]) : t);
            }
            return this.parsedPos = s, new ht(or.none, [], [], s - a);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= t && r.length && r[0].from == 0 && r[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Dn;
  }
};
function ef(e, t, r) {
  return Jr.applyChanges(e, [{ fromA: t, toA: r, fromB: t, toB: r }]);
}
var cn = class _cn {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, i) || r.takeTree(), new _cn(r);
  }
  static init(t) {
    let r = Math.min(3e3, t.doc.length), i = us2.create(t.facet(mi).parser, t, { from: 0, to: r });
    return i.work(20, r) || i.takeTree(), new _cn(i);
  }
};
vr.state = tu.define({
  create: cn.init,
  update(e, t) {
    for (let r of t.effects)
      if (r.is(vr.setState))
        return r.value;
    return t.startState.facet(mi) != t.state.facet(mi) ? cn.init(t.state) : e.apply(t);
  }
});
var Ep = (e) => {
  let t = setTimeout(
    () => e(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (Ep = (e) => {
  let t = -1, r = setTimeout(
    () => {
      t = requestIdleCallback(e, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(r) : cancelIdleCallback(t);
});
var Ro = typeof navigator < "u" && (!((mo = navigator.scheduling) === null || mo === void 0) && mo.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
var DS = k0.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let r = this.view.state.field(vr.state).context;
    (r.updateViewport(t.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, r = t.field(vr.state);
    (r.tree != r.context.tree || !r.context.isDone(t.doc.length)) && (this.working = Ep(this.work));
  }
  work(t) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, a = i.field(vr.state);
    if (a.tree == a.context.tree && a.context.isDone(
      n + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, t && !Ro ? Math.max(25, t.timeRemaining() - 5) : 1e9), o = a.context.treeLen < n && i.doc.length > n + 1e3, l = a.context.work(() => Ro && Ro() || Date.now() > s, n + (o ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (l || this.chunkBudget <= 0) && (a.context.takeTree(), this.view.dispatch({ effects: vr.setState.of(new cn(a.context)) })), this.chunkBudget > 0 && !(l && !o) && this.scheduleWork(), this.checkAsyncSchedule(a.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((r) => A6(this.view.state, r)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
var mi = Tn.define({
  combine(e) {
    return e.length ? e[0] : null;
  },
  enables: (e) => [
    vr.state,
    DS,
    ua.contentAttributes.compute([e], (t) => {
      let r = t.facet(e);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
var Ta = class {
  /**
  Create a language support object.
  */
  constructor(t, r = []) {
    this.language = t, this.support = r, this.extension = [t, r];
  }
};
var US = Tn.define();
var Vs = Tn.define({
  combine: (e) => {
    if (!e.length)
      return "  ";
    let t = e[0];
    if (!t || /\S/.test(t) || Array.from(t).some((r) => r != t[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(e[0]));
    return t;
  }
});
function cs(e) {
  let t = e.facet(Vs);
  return t.charCodeAt(0) == 9 ? e.tabSize * t.length : t.length;
}
function Kn(e, t) {
  let r = "", i = e.tabSize, n = e.facet(Vs)[0];
  if (n == "	") {
    for (; t >= i; )
      r += "	", t -= i;
    n = " ";
  }
  for (let a = 0; a < t; a++)
    r += n;
  return r;
}
function bu(e, t) {
  e instanceof i3 && (e = new Bs(e));
  for (let i of e.state.facet(US)) {
    let n = i(e, t);
    if (n !== void 0)
      return n;
  }
  let r = Ot(e.state);
  return r.length >= t ? wS(e, r, t) : null;
}
var Bs = class {
  /**
  Create an indent context.
  */
  constructor(t, r = {}) {
    this.state = t, this.options = r, this.unit = cs(t);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(t, r = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: n, simulateDoubleBreak: a } = this.options;
    return n != null && n >= i.from && n <= i.to ? a && n == t ? { text: "", from: t } : (r < 0 ? n < t : n <= t) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(t, r = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(t, r);
    return i.slice(t - n, Math.min(i.length, t + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(t, r = 1) {
    let { text: i, from: n } = this.lineAt(t, r), a = this.countColumn(i, t - n), s = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return s > -1 && (a += s - this.countColumn(i, i.search(/\S|$/))), a;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(t, r = t.length) {
    return oF1(t, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(t, r = 1) {
    let { text: i, from: n } = this.lineAt(t, r), a = this.options.overrideIndentation;
    if (a) {
      let s = a(n);
      if (s > -1)
        return s;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
};
var gn = new Le();
function wS(e, t, r) {
  let i = t.resolveStack(r), n = i.node.enterUnfinishedNodesBefore(r);
  if (n != i.node) {
    let a = [];
    for (let s = n; s != i.node; s = s.parent)
      a.push(s);
    for (let s = a.length - 1; s >= 0; s--)
      i = { node: a[s], next: i };
  }
  return dp(i, e, r);
}
function dp(e, t, r) {
  for (let i = e; i; i = i.next) {
    let n = kS(i.node);
    if (n)
      return n(vu.create(t, r, i));
  }
  return 0;
}
function MS(e) {
  return e.pos == e.options.simulateBreak && e.options.simulateDoubleBreak;
}
function kS(e) {
  let t = e.type.prop(gn);
  if (t)
    return t;
  let r = e.firstChild, i;
  if (r && (i = r.type.prop(Le.closedBy))) {
    let n = e.lastChild, a = n && i.indexOf(n.name) > -1;
    return (s) => Tp(s, true, 1, void 0, a && !MS(s) ? n.from : void 0);
  }
  return e.parent == null ? QS : null;
}
function QS() {
  return 0;
}
var vu = class _vu extends Bs {
  constructor(t, r, i) {
    super(t.state, t.options), this.base = t, this.pos = r, this.context = i;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(t, r, i) {
    return new _vu(t, r, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(t) {
    let r = this.state.doc.lineAt(t.from);
    for (; ; ) {
      let i = t.resolve(r.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (GS(i, t))
        break;
      r = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return dp(this.context.next, this.base, this.pos);
  }
};
function GS(e, t) {
  for (let r = t; r; r = r.parent)
    if (e == r)
      return true;
  return false;
}
function VS(e) {
  let t = e.node, r = t.childAfter(t.from), i = t.lastChild;
  if (!r)
    return null;
  let n = e.options.simulateBreak, a = e.state.doc.lineAt(r.from), s = n == null || n <= a.from ? a.to : Math.min(a.to, n);
  for (let o = r.to; ; ) {
    let l = t.childAfter(o);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped)
      return l.from < s ? r : null;
    o = l.to;
  }
}
function BS({ closing: e, align: t = true, units: r = 1 }) {
  return (i) => Tp(i, t, r, e);
}
function Tp(e, t, r, i, n) {
  let a = e.textAfter, s = a.match(/^\s*/)[0].length, o = i && a.slice(s, s + i.length) == i || n == e.pos + s, l = t ? VS(e) : null;
  return l ? o ? e.column(l.from) : e.column(l.to) : e.baseIndent + (o ? 0 : e.unit * r);
}
var $S = (e) => e.baseIndent;
function Gi({ except: e, units: t = 1 } = {}) {
  return (r) => {
    let i = e && e.test(r.textAfter);
    return r.baseIndent + (i ? 0 : t * r.unit);
  };
}
var YS = 200;
function FS() {
  return i3.transactionFilter.of((e) => {
    if (!e.docChanged || !e.isUserEvent("input.type") && !e.isUserEvent("input.complete"))
      return e;
    let t = e.startState.languageDataAt("indentOnInput", e.startState.selection.main.head);
    if (!t.length)
      return e;
    let r = e.newDoc, { head: i } = e.newSelection.main, n = r.lineAt(i);
    if (i > n.from + YS)
      return e;
    let a = r.sliceString(n.from, i);
    if (!t.some((c) => c.test(a)))
      return e;
    let { state: s } = e, o = -1, l = [];
    for (let { head: c } of s.selection.ranges) {
      let f = s.doc.lineAt(c);
      if (f.from == o)
        continue;
      o = f.from;
      let p = bu(s, f.from);
      if (p == null)
        continue;
      let O = /^\s*/.exec(f.text)[0], d2 = Kn(s, p);
      O != d2 && l.push({ from: f.from, to: f.from + O.length, insert: d2 });
    }
    return l.length ? [e, { changes: l, sequential: true }] : e;
  });
}
var WS = Tn.define();
var yn = new Le();
function Cu(e) {
  let t = e.firstChild, r = e.lastChild;
  return t && t.to < r.from ? { from: t.to, to: r.type.isError ? e.to : r.from } : null;
}
function XS(e, t, r) {
  let i = Ot(e);
  if (i.length < r)
    return null;
  let n = i.resolveStack(r, 1), a = null;
  for (let s = n; s; s = s.next) {
    let o = s.node;
    if (o.to <= r || o.from > r)
      continue;
    if (a && o.from < t)
      break;
    let l = o.type.prop(yn);
    if (l && (o.to < i.length - 50 || i.length == e.doc.length || !jS(o))) {
      let c = l(o, e);
      c && c.from <= r && c.from >= t && c.to > r && (a = c);
    }
  }
  return a;
}
function jS(e) {
  let t = e.lastChild;
  return t && t.to == e.to && t.type.isError;
}
function fs(e, t, r) {
  for (let i of e.facet(WS)) {
    let n = i(e, t, r);
    if (n)
      return n;
  }
  return XS(e, t, r);
}
function Sp(e, t) {
  let r = t.mapPos(e.from, 1), i = t.mapPos(e.to, -1);
  return r >= i ? void 0 : { from: r, to: i };
}
var $s = Eo.define({ map: Sp });
var Sa = Eo.define({ map: Sp });
function mp(e) {
  let t = [];
  for (let { head: r } of e.state.selection.ranges)
    t.some((i) => i.from <= r && i.to >= r) || t.push(e.lineBlockAt(r));
  return t;
}
var Yi = tu.define({
  create() {
    return Ao.none;
  },
  update(e, t) {
    e = e.map(t.changes);
    for (let r of t.effects)
      if (r.is($s) && !ZS(e, r.value.from, r.value.to)) {
        let { preparePlaceholder: i } = t.state.facet(Lu), n = i ? Ao.replace({ widget: new tm(i(t.state, r.value)) }) : tf;
        e = e.update({ add: [n.range(r.value.from, r.value.to)] });
      } else
        r.is(Sa) && (e = e.update({
          filter: (i, n) => r.value.from != i || r.value.to != n,
          filterFrom: r.value.from,
          filterTo: r.value.to
        }));
    if (t.selection) {
      let r = false, { head: i } = t.selection.main;
      e.between(i, i, (n, a) => {
        n < i && a > i && (r = true);
      }), r && (e = e.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, a) => a <= i || n >= i
      }));
    }
    return e;
  },
  provide: (e) => ua.decorations.from(e),
  toJSON(e, t) {
    let r = [];
    return e.between(0, t.doc.length, (i, n) => {
      r.push(i, n);
    }), r;
  },
  fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let t = [];
    for (let r = 0; r < e.length; ) {
      let i = e[r++], n = e[r++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      t.push(tf.range(i, n));
    }
    return Ao.set(t, true);
  }
});
function hs(e, t, r) {
  var i;
  let n = null;
  return (i = e.field(Yi, false)) === null || i === void 0 || i.between(t, r, (a, s) => {
    (!n || n.from > a) && (n = { from: a, to: s });
  }), n;
}
function ZS(e, t, r) {
  let i = false;
  return e.between(t, t, (n, a) => {
    n == t && a == r && (i = true);
  }), i;
}
function Rp(e, t) {
  return e.field(Yi, false) ? t : t.concat(Eo.appendConfig.of(xu()));
}
var HS = (e) => {
  for (let t of mp(e)) {
    let r = fs(e.state, t.from, t.to);
    if (r)
      return e.dispatch({ effects: Rp(e.state, [$s.of(r), Ap(e, r)]) }), true;
  }
  return false;
};
var zS = (e) => {
  if (!e.state.field(Yi, false))
    return false;
  let t = [];
  for (let r of mp(e)) {
    let i = hs(e.state, r.from, r.to);
    i && t.push(Sa.of(i), Ap(e, i, false));
  }
  return t.length && e.dispatch({ effects: t }), t.length > 0;
};
function Ap(e, t, r = true) {
  let i = e.state.doc.lineAt(t.from).number, n = e.state.doc.lineAt(t.to).number;
  return ua.announce.of(`${e.state.phrase(r ? "Folded lines" : "Unfolded lines")} ${i} ${e.state.phrase("to")} ${n}.`);
}
var qS = (e) => {
  let { state: t } = e, r = [];
  for (let i = 0; i < t.doc.length; ) {
    let n = e.lineBlockAt(i), a = fs(t, n.from, n.to);
    a && r.push($s.of(a)), i = (a ? e.lineBlockAt(a.to) : n).to + 1;
  }
  return r.length && e.dispatch({ effects: Rp(e.state, r) }), !!r.length;
};
var JS = (e) => {
  let t = e.state.field(Yi, false);
  if (!t || !t.size)
    return false;
  let r = [];
  return t.between(0, e.state.doc.length, (i, n) => {
    r.push(Sa.of({ from: i, to: n }));
  }), e.dispatch({ effects: r }), true;
};
var KS = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: HS },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: zS },
  { key: "Ctrl-Alt-[", run: qS },
  { key: "Ctrl-Alt-]", run: JS }
];
var em = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
};
var Lu = Tn.define({
  combine(e) {
    return rF1(e, em);
  }
});
function xu(e) {
  let t = [Yi, nm];
  return e && t.push(Lu.of(e)), t;
}
function gp(e, t) {
  let { state: r } = e, i = r.facet(Lu), n = (s) => {
    let o = e.lineBlockAt(e.posAtDOM(s.target)), l = hs(e.state, o.from, o.to);
    l && e.dispatch({ effects: Sa.of(l) }), s.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(e, n, t);
  let a = document.createElement("span");
  return a.textContent = i.placeholderText, a.setAttribute("aria-label", r.phrase("folded code")), a.title = r.phrase("unfold"), a.className = "cm-foldPlaceholder", a.onclick = n, a;
}
var tf = Ao.replace({ widget: new class extends am {
  toDOM(e) {
    return gp(e, null);
  }
}() });
var tm = class extends am {
  constructor(t) {
    super(), this.value = t;
  }
  eq(t) {
    return this.value == t.value;
  }
  toDOM(t) {
    return gp(t, this.value);
  }
};
var rm = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
var Ao2 = class extends b9 {
  constructor(t, r) {
    super(), this.config = t, this.open = r;
  }
  eq(t) {
    return this.config == t.config && this.open == t.open;
  }
  toDOM(t) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let r = document.createElement("span");
    return r.textContent = this.open ? this.config.openText : this.config.closedText, r.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), r;
  }
};
function im(e = {}) {
  let t = Object.assign(Object.assign({}, rm), e), r = new Ao2(t, true), i = new Ao2(t, false), n = k0.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(mi) != s.state.facet(mi) || s.startState.field(Yi, false) != s.state.field(Yi, false) || Ot(s.startState) != Ot(s.state) || t.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let o = new Bw();
      for (let l of s.viewportLineBlocks) {
        let c = hs(s.state, l.from, l.to) ? i : fs(s.state, l.from, l.to) ? r : null;
        c && o.add(l.from, l.from, c);
      }
      return o.finish();
    }
  }), { domEventHandlers: a } = t;
  return [
    n,
    Slr({
      class: "cm-foldGutter",
      markers(s) {
        var o;
        return ((o = s.plugin(n)) === null || o === void 0 ? void 0 : o.markers) || qr.empty;
      },
      initialSpacer() {
        return new Ao2(t, false);
      },
      domEventHandlers: Object.assign(Object.assign({}, a), { click: (s, o, l) => {
        if (a.click && a.click(s, o, l))
          return true;
        let c = hs(s.state, o.from, o.to);
        if (c)
          return s.dispatch({ effects: Sa.of(c) }), true;
        let f = fs(s.state, o.from, o.to);
        return f ? (s.dispatch({ effects: $s.of(f) }), true) : false;
      } })
    }),
    xu()
  ];
}
var nm = ua.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
var Du = class _Du {
  constructor(t, r) {
    this.specs = t;
    let i;
    function n(o) {
      let l = Eg.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = o, l;
    }
    const a = typeof r.all == "string" ? r.all : r.all ? n(r.all) : void 0, s = r.scope;
    this.scope = s instanceof vr ? (o) => o.prop(tn) == s.data : s ? (o) => o == s : void 0, this.style = pp(t.map((o) => ({
      tag: o.tag,
      class: o.class || n(Object.assign({}, o, { tag: null }))
    })), {
      all: a
    }).style, this.module = i ? new Eg(i) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, r) {
    return new _Du(t, r || {});
  }
};
var am2 = Du.define([
  {
    tag: Q.meta,
    color: "#404740"
  },
  {
    tag: Q.link,
    textDecoration: "underline"
  },
  {
    tag: Q.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: Q.emphasis,
    fontStyle: "italic"
  },
  {
    tag: Q.strong,
    fontWeight: "bold"
  },
  {
    tag: Q.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: Q.keyword,
    color: "#708"
  },
  {
    tag: [Q.atom, Q.bool, Q.url, Q.contentSeparator, Q.labelName],
    color: "#219"
  },
  {
    tag: [Q.literal, Q.inserted],
    color: "#164"
  },
  {
    tag: [Q.string, Q.deleted],
    color: "#a11"
  },
  {
    tag: [Q.regexp, Q.escape, Q.special(Q.string)],
    color: "#e40"
  },
  {
    tag: Q.definition(Q.variableName),
    color: "#00f"
  },
  {
    tag: Q.local(Q.variableName),
    color: "#30a"
  },
  {
    tag: [Q.typeName, Q.namespace],
    color: "#085"
  },
  {
    tag: Q.className,
    color: "#167"
  },
  {
    tag: [Q.special(Q.variableName), Q.macroName],
    color: "#256"
  },
  {
    tag: Q.definition(Q.propertyName),
    color: "#00c"
  },
  {
    tag: Q.comment,
    color: "#940"
  },
  {
    tag: Q.invalid,
    color: "#f00"
  }
]);
var sm = ua.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
var yp = 1e4;
var Ip = "()[]{}";
var Np = Tn.define({
  combine(e) {
    return rF1(e, {
      afterCursor: true,
      brackets: Ip,
      maxScanDistance: yp,
      renderMatch: um
    });
  }
});
var om = Ao.mark({ class: "cm-matchingBracket" });
var lm = Ao.mark({ class: "cm-nonmatchingBracket" });
function um(e) {
  let t = [], r = e.matched ? om : lm;
  return t.push(r.range(e.start.from, e.start.to)), e.end && t.push(r.range(e.end.from, e.end.to)), t;
}
var cm = tu.define({
  create() {
    return Ao.none;
  },
  update(e, t) {
    if (!t.docChanged && !t.selection)
      return e;
    let r = [], i = t.state.facet(Np);
    for (let n of t.state.selection.ranges) {
      if (!n.empty)
        continue;
      let a = Gr(t.state, n.head, -1, i) || n.head > 0 && Gr(t.state, n.head - 1, 1, i) || i.afterCursor && (Gr(t.state, n.head, 1, i) || n.head < t.state.doc.length && Gr(t.state, n.head + 1, -1, i));
      a && (r = r.concat(i.renderMatch(a, t.state)));
    }
    return Ao.set(r, true);
  },
  provide: (e) => ua.decorations.from(e)
});
var fm = [
  cm,
  sm
];
function hm(e = {}) {
  return [Np.of(e), fm];
}
var Pp = new Le();
function nl(e, t, r) {
  let i = e.prop(t < 0 ? Le.openedBy : Le.closedBy);
  if (i)
    return i;
  if (e.name.length == 1) {
    let n = r.indexOf(e.name);
    if (n > -1 && n % 2 == (t < 0 ? 1 : 0))
      return [r[n + t]];
  }
  return null;
}
function al(e) {
  let t = e.type.prop(Pp);
  return t ? t(e.node) : e;
}
function Gr(e, t, r, i = {}) {
  let n = i.maxScanDistance || yp, a = i.brackets || Ip, s = Ot(e), o = s.resolveInner(t, r);
  for (let l = o; l; l = l.parent) {
    let c = nl(l.type, r, a);
    if (c && l.from < l.to) {
      let f = al(l);
      if (f && (r > 0 ? t >= f.from && t < f.to : t > f.from && t <= f.to))
        return pm(e, t, r, l, f, c, a);
    }
  }
  return Om(e, t, r, s, o.type, n, a);
}
function pm(e, t, r, i, n, a, s) {
  let o = i.parent, l = { from: n.from, to: n.to }, c = 0, f = o == null ? void 0 : o.cursor();
  if (f && (r < 0 ? f.childBefore(i.from) : f.childAfter(i.to)))
    do
      if (r < 0 ? f.to <= i.from : f.from >= i.to) {
        if (c == 0 && a.indexOf(f.type.name) > -1 && f.from < f.to) {
          let p = al(f);
          return { start: l, end: p ? { from: p.from, to: p.to } : void 0, matched: true };
        } else if (nl(f.type, r, s))
          c++;
        else if (nl(f.type, -r, s)) {
          if (c == 0) {
            let p = al(f);
            return {
              start: l,
              end: p && p.from < p.to ? { from: p.from, to: p.to } : void 0,
              matched: false
            };
          }
          c--;
        }
      }
    while (r < 0 ? f.prevSibling() : f.nextSibling());
  return { start: l, matched: false };
}
function Om(e, t, r, i, n, a, s) {
  let o = r < 0 ? e.sliceDoc(t - 1, t) : e.sliceDoc(t, t + 1), l = s.indexOf(o);
  if (l < 0 || l % 2 == 0 != r > 0)
    return null;
  let c = { from: r < 0 ? t - 1 : t, to: r > 0 ? t + 1 : t }, f = e.doc.iterRange(t, r > 0 ? e.doc.length : 0), p = 0;
  for (let O = 0; !f.next().done && O <= a; ) {
    let d2 = f.value;
    r < 0 && (O += d2.length);
    let g = t + O * r;
    for (let L = r > 0 ? 0 : d2.length - 1, D = r > 0 ? d2.length : -1; L != D; L += r) {
      let W = s.indexOf(d2[L]);
      if (!(W < 0 || i.resolveInner(g + L, 1).type != n))
        if (W % 2 == 0 == r > 0)
          p++;
        else {
          if (p == 1)
            return { start: c, end: { from: g + L, to: g + L + 1 }, matched: W >> 1 == l >> 1 };
          p--;
        }
    }
    r > 0 && (O += d2.length);
  }
  return f.done ? { start: c, matched: false } : null;
}
var Em = /* @__PURE__ */ Object.create(null);
var rf = [or.none];
var nf = [];
var af = /* @__PURE__ */ Object.create(null);
var dm = /* @__PURE__ */ Object.create(null);
for (let [e, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  dm[e] = Tm(Em, t);
function go(e, t) {
  nf.indexOf(e) > -1 || (nf.push(e), console.warn(t));
}
function Tm(e, t) {
  let r = [];
  for (let o of t.split(" ")) {
    let l = [];
    for (let c of o.split(".")) {
      let f = e[c] || Q[c];
      f ? typeof f == "function" ? l.length ? l = l.map(f) : go(c, `Modifier ${c} used at start of tag`) : l.length ? go(c, `Tag ${c} used as modifier`) : l = Array.isArray(f) ? f : [f] : go(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      r.push(c);
  }
  if (!r.length)
    return 0;
  let i = t.replace(/ /g, "_"), n = i + " " + r.map((o) => o.id), a = af[n];
  if (a)
    return a.id;
  let s = af[n] = or.define({
    id: rf.length,
    name: i,
    props: [An({ [i]: r })]
  });
  return rf.push(s), s.id;
}
ci.RTL, ci.LTR;
var _p = class {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(t, r, i) {
    this.state = t, this.pos = r, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let r = Ot(this.state).resolveInner(this.pos, -1);
    for (; r && t.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let r = this.state.doc.lineAt(this.pos), i = Math.max(r.from, this.pos - 250), n = r.text.slice(i - r.from, this.pos - r.from), a = n.search(bp(t, false));
    return a < 0 ? null : { from: i + a, to: this.pos, text: n.slice(a) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(t, r) {
    t == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
};
function sf(e) {
  let t = Object.keys(e).join(""), r = /\w/.test(t);
  return r && (t = t.replace(/\w/g, "")), `[${r ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Sm(e) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of e) {
    t[n[0]] = true;
    for (let a = 1; a < n.length; a++)
      r[n[a]] = true;
  }
  let i = sf(t) + sf(r) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function Ys(e) {
  let t = e.map((n) => typeof n == "string" ? { label: n } : n), [r, i] = t.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : Sm(t);
  return (n) => {
    let a = n.matchBefore(i);
    return a || n.explicit ? { from: a ? a.from : n.pos, options: t, validFor: r } : null;
  };
}
function Uu(e, t) {
  return (r) => {
    for (let i = Ot(r.state).resolveInner(r.pos, -1); i; i = i.parent) {
      if (e.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return t(r);
  };
}
var of = class {
  constructor(t, r, i, n) {
    this.completion = t, this.source = r, this.match = i, this.score = n;
  }
};
function Oi(e) {
  return e.selection.main.from;
}
function bp(e, t) {
  var r;
  let { source: i } = e, n = t && i[0] != "^", a = i[i.length - 1] != "$";
  return !n && !a ? e : new RegExp(`${n ? "^" : ""}(?:${i})${a ? "$" : ""}`, (r = e.flags) !== null && r !== void 0 ? r : e.ignoreCase ? "i" : "");
}
var wu = UC.define();
function mm(e, t, r, i) {
  let { main: n } = e.selection, a = r - n.from, s = i - n.from;
  return Object.assign(Object.assign({}, e.changeByRange((o) => o != n && r != i && e.sliceDoc(o.from + a, o.from + s) != e.sliceDoc(r, i) ? { range: o } : {
    changes: { from: o.from + a, to: i == n.from ? o.to : o.from + s, insert: t },
    range: $2.cursor(o.from + a + t.length)
  })), { scrollIntoView: true, userEvent: "input.complete" });
}
var lf = /* @__PURE__ */ new WeakMap();
function Rm(e) {
  if (!Array.isArray(e))
    return e;
  let t = lf.get(e);
  return t || lf.set(e, t = Ys(e)), t;
}
var ps = Eo.define();
var ea = Eo.define();
var Am = class {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < t.length; ) {
      let i = _E(t, r), n = yK(i);
      this.chars.push(i);
      let a = t.slice(r, r + n), s = a.toUpperCase();
      this.folded.push(_E(s == a ? a.toLowerCase() : s, 0)), r += n;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, r) {
    return this.score = t, this.matched = r, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: r, folded: i, any: n, precise: a, byWord: s } = this;
    if (r.length == 1) {
      let x = _E(t, 0), V = yK(x), _2 = V == t.length ? 0 : -100;
      if (x != r[0])
        if (x == i[0])
          _2 += -200;
        else
          return null;
      return this.ret(_2, [0, V]);
    }
    let o = t.indexOf(this.pattern);
    if (o == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = r.length, c = 0;
    if (o < 0) {
      for (let x = 0, V = Math.min(t.length, 200); x < V && c < l; ) {
        let _2 = _E(t, x);
        (_2 == r[c] || _2 == i[c]) && (n[c++] = x), x += yK(_2);
      }
      if (c < l)
        return null;
    }
    let f = 0, p = 0, O = false, d2 = 0, g = -1, L = -1, D = /[a-z]/.test(t), W = true;
    for (let x = 0, V = Math.min(t.length, 200), _2 = 0; x < V && p < l; ) {
      let $ = _E(t, x);
      o < 0 && (f < l && $ == r[f] && (a[f++] = x), d2 < l && ($ == r[d2] || $ == i[d2] ? (d2 == 0 && (g = x), L = x + 1, d2++) : d2 = 0));
      let z, F = $ < 255 ? $ >= 48 && $ <= 57 || $ >= 97 && $ <= 122 ? 2 : $ >= 65 && $ <= 90 ? 1 : 0 : (z = ulr($)) != z.toLowerCase() ? 1 : z != z.toUpperCase() ? 2 : 0;
      (!x || F == 1 && D || _2 == 0 && F != 0) && (r[p] == $ || i[p] == $ && (O = true) ? s[p++] = x : s.length && (W = false)), _2 = F, x += yK($);
    }
    return p == l && s[0] == 0 && W ? this.result(-100 + (O ? -200 : 0), s, t) : d2 == l && g == 0 ? this.ret(-200 - t.length + (L == t.length ? 0 : -100), [0, L]) : o > -1 ? this.ret(-700 - t.length, [o, o + this.pattern.length]) : d2 == l ? this.ret(-200 + -700 - t.length, [g, L]) : p == l ? this.result(-100 + (O ? -200 : 0) + -700 + (W ? 0 : -1100), s, t) : r.length == 2 ? null : this.result((n[0] ? -700 : 0) + -200 + -1100, n, t);
  }
  result(t, r, i) {
    let n = [], a = 0;
    for (let s of r) {
      let o = s + (this.astral ? yK(_E(i, s)) : 1);
      a && n[a - 1] == s ? n[a - 1] = o : (n[a++] = s, n[a++] = o);
    }
    return this.ret(t - i.length, n);
  }
};
var gm = class {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let r = t.slice(0, this.pattern.length), i = r == this.pattern ? 0 : r.toLowerCase() == this.folded ? -200 : null;
    return i == null ? null : (this.matched = [0, r.length], this.score = i + (t.length == this.pattern.length ? 0 : -100), this);
  }
};
var Qt = Tn.define({
  combine(e) {
    return rF1(e, {
      activateOnTyping: true,
      activateOnCompletion: () => false,
      activateOnTypingDelay: 100,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      positionInfo: ym,
      filterStrict: false,
      compareCompletions: (t, r) => t.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (t, r) => t && r,
      closeOnBlur: (t, r) => t && r,
      icons: (t, r) => t && r,
      tooltipClass: (t, r) => (i) => uf(t(i), r(i)),
      optionClass: (t, r) => (i) => uf(t(i), r(i)),
      addToOptions: (t, r) => t.concat(r),
      filterStrict: (t, r) => t || r
    });
  }
});
function uf(e, t) {
  return e ? t ? e + " " + t : e : t;
}
function ym(e, t, r, i, n, a) {
  let s = e.textDirection == ci.RTL, o = s, l = false, c = "top", f, p, O = t.left - n.left, d2 = n.right - t.right, g = i.right - i.left, L = i.bottom - i.top;
  if (o && O < Math.min(g, d2) ? o = false : !o && d2 < Math.min(g, O) && (o = true), g <= (o ? O : d2))
    f = Math.max(n.top, Math.min(r.top, n.bottom - L)) - t.top, p = Math.min(400, o ? O : d2);
  else {
    l = true, p = Math.min(
      400,
      (s ? t.right : n.right - t.left) - 30
      /* Info.Margin */
    );
    let x = n.bottom - t.bottom;
    x >= L || x > t.top ? f = r.bottom - t.top : (c = "bottom", f = t.bottom - r.top);
  }
  let D = (t.bottom - t.top) / a.offsetHeight, W = (t.right - t.left) / a.offsetWidth;
  return {
    style: `${c}: ${f / D}px; max-width: ${p / W}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function Im(e) {
  let t = e.addToOptions.slice();
  return e.icons && t.push({
    render(r) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), r.type && i.classList.add(...r.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), t.push({
    render(r, i, n, a) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let o = r.displayLabel || r.label, l = 0;
      for (let c = 0; c < a.length; ) {
        let f = a[c++], p = a[c++];
        f > l && s.appendChild(document.createTextNode(o.slice(l, f)));
        let O = s.appendChild(document.createElement("span"));
        O.appendChild(document.createTextNode(o.slice(f, p))), O.className = "cm-completionMatchedText", l = p;
      }
      return l < o.length && s.appendChild(document.createTextNode(o.slice(l))), s;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = r.detail, i;
    },
    position: 80
  }), t.sort((r, i) => r.position - i.position).map((r) => r.render);
}
function yo(e, t, r) {
  if (e <= r)
    return { from: 0, to: e };
  if (t < 0 && (t = 0), t <= e >> 1) {
    let n = Math.floor(t / r);
    return { from: n * r, to: (n + 1) * r };
  }
  let i = Math.floor((e - t) / r);
  return { from: e - (i + 1) * r, to: e - i * r };
}
var Nm = class {
  constructor(t, r, i) {
    this.view = t, this.stateField = r, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = t.state.field(r), { options: a, selected: s } = n.open, o = t.state.facet(Qt);
    this.optionContent = Im(o), this.optionClass = o.optionClass, this.tooltipClass = o.tooltipClass, this.range = yo(a.length, s, o.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = t.state.field(r).open;
      for (let f = l.target, p; f && f != this.dom; f = f.parentNode)
        if (f.nodeName == "LI" && (p = /-(\d+)$/.exec(f.id)) && +p[1] < c.length) {
          this.applyCompletion(t, c[+p[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = t.state.field(this.stateField, false);
      c && c.tooltip && t.state.facet(Qt).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: ea.of(null) });
    }), this.showOptions(a, n.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var r;
    let i = t.state.field(this.stateField), n = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), i != n) {
      let { options: a, selected: s, disabled: o } = i.open;
      (!n.open || n.open.options != a) && (this.range = yo(a.length, s, t.state.facet(Qt).maxRenderedOptions), this.showOptions(a, i.id)), this.updateSel(), o != ((r = n.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!o);
    }
  }
  updateTooltipClass(t) {
    let r = this.tooltipClass(t);
    if (r != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of r.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = r;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), r = t.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = yo(r.options.length, r.selected, this.view.state.facet(Qt).maxRenderedOptions), this.showOptions(r.options, t.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: i } = r.options[r.selected], { info: n } = i;
      if (!n)
        return;
      let a = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!a)
        return;
      "then" in a ? a.then((s) => {
        s && this.view.state.field(this.stateField, false) == t && this.addInfoPane(s, i);
      }).catch((s) => A6(this.view.state, s, "completion info")) : this.addInfoPane(a, i);
    }
  }
  addInfoPane(t, r) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      i.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: n, destroy: a } = t;
      i.appendChild(n), this.infoDestroy = a || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let r = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == t ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), r = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return r && _m(this.list, r), r;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = t.getBoundingClientRect(), a = this.space;
    if (!a) {
      let s = this.dom.ownerDocument.defaultView || window;
      a = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return n.top > Math.min(a.bottom, r.bottom) - 10 || n.bottom < Math.max(a.top, r.top) + 10 ? null : this.view.state.facet(Qt).positionInfo(this.view, r, n, i, a, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, r, i) {
    const n = document.createElement("ul");
    n.id = r, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let a = null;
    for (let s = i.from; s < i.to; s++) {
      let { completion: o, match: l } = t[s], { section: c } = o;
      if (c) {
        let O = typeof c == "string" ? c : c.name;
        if (O != a && (s > i.from || i.from == 0))
          if (a = O, typeof c != "string" && c.header)
            n.appendChild(c.header(c));
          else {
            let d2 = n.appendChild(document.createElement("completion-section"));
            d2.textContent = O;
          }
      }
      const f = n.appendChild(document.createElement("li"));
      f.id = r + "-" + s, f.setAttribute("role", "option");
      let p = this.optionClass(o);
      p && (f.className = p);
      for (let O of this.optionContent) {
        let d2 = O(o, this.view.state, this.view, l);
        d2 && f.appendChild(d2);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < t.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
};
function Pm(e, t) {
  return (r) => new Nm(r, e, t);
}
function _m(e, t) {
  let r = e.getBoundingClientRect(), i = t.getBoundingClientRect(), n = r.height / e.offsetHeight;
  i.top < r.top ? e.scrollTop -= (r.top - i.top) / n : i.bottom > r.bottom && (e.scrollTop += (i.bottom - r.bottom) / n);
}
function cf(e) {
  return (e.boost || 0) * 100 + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0);
}
function bm(e, t) {
  let r = [], i = null, n = (c) => {
    r.push(c);
    let { section: f } = c.completion;
    if (f) {
      i || (i = []);
      let p = typeof f == "string" ? f : f.name;
      i.some((O) => O.name == p) || i.push(typeof f == "string" ? { name: p } : f);
    }
  }, a = t.facet(Qt);
  for (let c of e)
    if (c.hasResult()) {
      let f = c.result.getMatch;
      if (c.result.filter === false)
        for (let p of c.result.options)
          n(new of(p, c.source, f ? f(p) : [], 1e9 - r.length));
      else {
        let p = t.sliceDoc(c.from, c.to), O, d2 = a.filterStrict ? new gm(p) : new Am(p);
        for (let g of c.result.options)
          if (O = d2.match(g.label)) {
            let L = g.displayLabel ? f ? f(g, O.matched) : [] : O.matched;
            n(new of(g, c.source, L, O.score + (g.boost || 0)));
          }
      }
    }
  if (i) {
    let c = /* @__PURE__ */ Object.create(null), f = 0, p = (O, d2) => {
      var g, L;
      return ((g = O.rank) !== null && g !== void 0 ? g : 1e9) - ((L = d2.rank) !== null && L !== void 0 ? L : 1e9) || (O.name < d2.name ? -1 : 1);
    };
    for (let O of i.sort(p))
      f -= 1e5, c[O.name] = f;
    for (let O of r) {
      let { section: d2 } = O.completion;
      d2 && (O.score += c[typeof d2 == "string" ? d2 : d2.name]);
    }
  }
  let s = [], o = null, l = a.compareCompletions;
  for (let c of r.sort((f, p) => p.score - f.score || l(f.completion, p.completion))) {
    let f = c.completion;
    !o || o.label != f.label || o.detail != f.detail || o.type != null && f.type != null && o.type != f.type || o.apply != f.apply || o.boost != f.boost ? s.push(c) : cf(c.completion) > cf(o) && (s[s.length - 1] = c), o = c.completion;
  }
  return s;
}
var rn = class _rn {
  constructor(t, r, i, n, a, s) {
    this.options = t, this.attrs = r, this.tooltip = i, this.timestamp = n, this.selected = a, this.disabled = s;
  }
  setSelected(t, r) {
    return t == this.selected || t >= this.options.length ? this : new _rn(this.options, ff(r, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, r, i, n, a) {
    let s = bm(t, r);
    if (!s.length)
      return n && t.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new _rn(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, true) : null;
    let o = r.facet(Qt).selectOnOpen ? 0 : -1;
    if (n && n.selected != o && n.selected != -1) {
      let l = n.options[n.selected].completion;
      for (let c = 0; c < s.length; c++)
        if (s[c].completion == l) {
          o = c;
          break;
        }
    }
    return new _rn(s, ff(i, o), {
      pos: t.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
      create: Dm,
      above: a.aboveCursor
    }, n ? n.timestamp : Date.now(), o, false);
  }
  map(t) {
    return new _rn(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
};
var Os = class _Os {
  constructor(t, r, i) {
    this.active = t, this.id = r, this.open = i;
  }
  static start() {
    return new _Os(Lm, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: r } = t, i = r.facet(Qt), a = (i.override || r.languageDataAt("autocomplete", Oi(r)).map(Rm)).map((o) => (this.active.find((c) => c.source == o) || new Ft(
      o,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, i));
    a.length == this.active.length && a.every((o, l) => o == this.active[l]) && (a = this.active);
    let s = this.open;
    s && t.docChanged && (s = s.map(t.changes)), t.selection || a.some((o) => o.hasResult() && t.changes.touchesRange(o.from, o.to)) || !vm(a, this.active) ? s = rn.build(a, r, this.id, s, i) : s && s.disabled && !a.some(
      (o) => o.state == 1
      /* State.Pending */
    ) && (s = null), !s && a.every(
      (o) => o.state != 1
      /* State.Pending */
    ) && a.some((o) => o.hasResult()) && (a = a.map((o) => o.hasResult() ? new Ft(
      o.source,
      0
      /* State.Inactive */
    ) : o));
    for (let o of t.effects)
      o.is(Cp) && (s = s && s.setSelected(o.value, this.id));
    return a == this.active && s == this.open ? this : new _Os(a, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : Cm;
  }
};
function vm(e, t) {
  if (e == t)
    return true;
  for (let r = 0, i = 0; ; ) {
    for (; r < e.length && !e[r].hasResult; )
      r++;
    for (; i < t.length && !t[i].hasResult; )
      i++;
    let n = r == e.length, a = i == t.length;
    if (n || a)
      return n == a;
    if (e[r++].result != t[i++].result)
      return false;
  }
}
var Cm = {
  "aria-autocomplete": "list"
};
function ff(e, t) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": e
  };
  return t > -1 && (r["aria-activedescendant"] = e + "-" + t), r;
}
var Lm = [];
function sl(e, t) {
  if (e.isUserEvent("input.complete")) {
    let r = e.annotation(wu);
    if (r && t.activateOnCompletion(r))
      return "input";
  }
  return e.isUserEvent("input.type") ? "input" : e.isUserEvent("delete.backward") ? "delete" : null;
}
var Ft = class _Ft {
  constructor(t, r, i = -1) {
    this.source = t, this.state = r, this.explicitPos = i;
  }
  hasResult() {
    return false;
  }
  update(t, r) {
    let i = sl(t, r), n = this;
    i ? n = n.handleUserEvent(t, i, r) : t.docChanged ? n = n.handleChange(t) : t.selection && n.state != 0 && (n = new _Ft(
      n.source,
      0
      /* State.Inactive */
    ));
    for (let a of t.effects)
      if (a.is(ps))
        n = new _Ft(n.source, 1, a.value ? Oi(t.state) : -1);
      else if (a.is(ea))
        n = new _Ft(
          n.source,
          0
          /* State.Inactive */
        );
      else if (a.is(vp))
        for (let s of a.value)
          s.source == n.source && (n = s);
    return n;
  }
  handleUserEvent(t, r, i) {
    return r == "delete" || !i.activateOnTyping ? this.map(t.changes) : new _Ft(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(t) {
    return t.changes.touchesRange(Oi(t.startState)) ? new _Ft(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(t.changes);
  }
  map(t) {
    return t.empty || this.explicitPos < 0 ? this : new _Ft(this.source, this.state, t.mapPos(this.explicitPos));
  }
};
var sn = class _sn extends Ft {
  constructor(t, r, i, n, a) {
    super(t, 2, r), this.result = i, this.from = n, this.to = a;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(t, r, i) {
    var n;
    let a = this.result;
    a.map && !t.changes.empty && (a = a.map(a, t.changes));
    let s = t.changes.mapPos(this.from), o = t.changes.mapPos(this.to, 1), l = Oi(t.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > o || !a || r == "delete" && Oi(t.startState) == this.from)
      return new Ft(
        this.source,
        r == "input" && i.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let c = this.explicitPos < 0 ? -1 : t.changes.mapPos(this.explicitPos);
    return xm(a.validFor, t.state, s, o) ? new _sn(this.source, c, a, s, o) : a.update && (a = a.update(a, s, o, new _p(t.state, l, c >= 0))) ? new _sn(this.source, c, a, a.from, (n = a.to) !== null && n !== void 0 ? n : Oi(t.state)) : new Ft(this.source, 1, c);
  }
  handleChange(t) {
    return t.changes.touchesRange(this.from, this.to) ? new Ft(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(t.changes);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new _sn(this.source, this.explicitPos < 0 ? -1 : t.mapPos(this.explicitPos), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new Ft(
      this.source,
      0
      /* State.Inactive */
    );
  }
};
function xm(e, t, r, i) {
  if (!e)
    return false;
  let n = t.sliceDoc(r, i);
  return typeof e == "function" ? e(n, r, i, t) : bp(e, true).test(n);
}
var vp = Eo.define({
  map(e, t) {
    return e.map((r) => r.map(t));
  }
});
var Cp = Eo.define();
var Jt = tu.define({
  create() {
    return Os.start();
  },
  update(e, t) {
    return e.update(t);
  },
  provide: (e) => [
    iB1.from(e, (t) => t.tooltip),
    ua.contentAttributes.from(e, (t) => t.attrs)
  ]
});
function Mu(e, t) {
  const r = t.completion.apply || t.completion.label;
  let i = e.state.field(Jt).active.find((n) => n.source == t.source);
  return i instanceof sn ? (typeof r == "string" ? e.dispatch(Object.assign(Object.assign({}, mm(e.state, r, i.from, i.to)), { annotations: wu.of(t.completion) })) : r(e, t.completion, i.from, i.to), true) : false;
}
var Dm = Pm(Jt, Mu);
function kr(e, t = "option") {
  return (r) => {
    let i = r.state.field(Jt, false);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < r.state.facet(Qt).interactionDelay)
      return false;
    let n = 1, a;
    t == "page" && (a = wlr(r, i.open.tooltip)) && (n = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = i.open.options, o = i.open.selected > -1 ? i.open.selected + n * (e ? 1 : -1) : e ? 0 : s - 1;
    return o < 0 ? o = t == "page" ? 0 : s - 1 : o >= s && (o = t == "page" ? s - 1 : 0), r.dispatch({ effects: Cp.of(o) }), true;
  };
}
var ol = (e) => {
  let t = e.state.field(Jt, false);
  return e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(Qt).interactionDelay ? false : Mu(e, t.open.options[t.open.selected]);
};
var Um = (e) => e.state.field(Jt, false) ? (e.dispatch({ effects: ps.of(true) }), true) : false;
var ku = (e) => {
  let t = e.state.field(Jt, false);
  return !t || !t.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? false : (e.dispatch({ effects: ea.of(null) }), true);
};
var wm = class {
  constructor(t, r) {
    this.active = t, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
};
var Mm = 50;
var km = 1e3;
var Qm = k0.fromClass(class {
  constructor(e) {
    this.view = e, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = false, this.composing = 0;
    for (let t of e.state.field(Jt).active)
      t.state == 1 && this.startQuery(t);
  }
  update(e) {
    let t = e.state.field(Jt), r = e.state.facet(Qt);
    if (!e.selectionSet && !e.docChanged && e.startState.field(Jt) == t)
      return;
    let i = e.transactions.some((a) => (a.selection || a.docChanged) && !sl(a, r));
    for (let a = 0; a < this.running.length; a++) {
      let s = this.running[a];
      if (i || s.updates.length + e.transactions.length > Mm && Date.now() - s.time > km) {
        for (let o of s.context.abortListeners)
          try {
            o();
          } catch (l) {
            A6(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(a--, 1);
      } else
        s.updates.push(...e.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), e.transactions.some((a) => a.effects.some((s) => s.is(ps))) && (this.pendingStart = true);
    let n = this.pendingStart ? 50 : r.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((a) => a.state == 1 && !this.running.some((s) => s.active.source == a.source)) ? setTimeout(() => this.startUpdate(), n) : -1, this.composing != 0)
      for (let a of e.transactions)
        sl(a, r) == "input" ? this.composing = 2 : this.composing == 2 && a.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = false;
    let { state: e } = this.view, t = e.field(Jt);
    for (let r of t.active)
      r.state == 1 && !this.running.some((i) => i.active.source == r.source) && this.startQuery(r);
  }
  startQuery(e) {
    let { state: t } = this.view, r = Oi(t), i = new _p(t, r, e.explicitPos == r), n = new wm(e, i);
    this.running.push(n), Promise.resolve(e.source(i)).then((a) => {
      n.context.aborted || (n.done = a || null, this.scheduleAccept());
    }, (a) => {
      this.view.dispatch({ effects: ea.of(null) }), A6(this.view.state, a);
    });
  }
  scheduleAccept() {
    this.running.every((e) => e.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Qt).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var e;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], r = this.view.state.facet(Qt);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let s = new sn(n.active.source, n.active.explicitPos, n.done, n.done.from, (e = n.done.to) !== null && e !== void 0 ? e : Oi(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let o of n.updates)
          s = s.update(o, r);
        if (s.hasResult()) {
          t.push(s);
          continue;
        }
      }
      let a = this.view.state.field(Jt).active.find((s) => s.source == n.active.source);
      if (a && a.state == 1)
        if (n.done == null) {
          let s = new Ft(
            n.active.source,
            0
            /* State.Inactive */
          );
          for (let o of n.updates)
            s = s.update(o, r);
          s.state != 1 && t.push(s);
        } else
          this.startQuery(a);
    }
    t.length && this.view.dispatch({ effects: vp.of(t) });
  }
}, {
  eventHandlers: {
    blur(e) {
      let t = this.view.state.field(Jt, false);
      if (t && t.tooltip && this.view.state.facet(Qt).closeOnBlur) {
        let r = t.open && wlr(this.view, t.open.tooltip);
        (!r || !r.dom.contains(e.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: ea.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: ps.of(false) }), 20), this.composing = 0;
    }
  }
});
var Gm = typeof navigator == "object" && /Win/.test(navigator.platform);
var Vm = GP1.highest(ua.domEventHandlers({
  keydown(e, t) {
    let r = t.state.field(Jt, false);
    if (!r || !r.open || r.open.disabled || r.open.selected < 0 || e.key.length > 1 || e.ctrlKey && !(Gm && e.altKey) || e.metaKey)
      return false;
    let i = r.open.options[r.open.selected], n = r.active.find((s) => s.source == i.source), a = i.completion.commitCharacters || n.result.commitCharacters;
    return a && a.indexOf(e.key) > -1 && Mu(t, i), false;
  }
}));
var Lp = ua.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
var Bm = class {
  constructor(t, r, i, n) {
    this.field = t, this.line = r, this.from = i, this.to = n;
  }
};
var Qu = class _Qu {
  constructor(t, r, i) {
    this.field = t, this.from = r, this.to = i;
  }
  map(t) {
    let r = t.mapPos(this.from, -1, C0.TrackDel), i = t.mapPos(this.to, 1, C0.TrackDel);
    return r == null || i == null ? null : new _Qu(this.field, r, i);
  }
};
var Gu = class _Gu {
  constructor(t, r) {
    this.lines = t, this.fieldPositions = r;
  }
  instantiate(t, r) {
    let i = [], n = [r], a = t.doc.lineAt(r), s = /^\s*/.exec(a.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let c = s, f = /^\t*/.exec(l)[0].length;
        for (let p = 0; p < f; p++)
          c += t.facet(Vs);
        n.push(r + c.length - f), l = c + l.slice(f);
      }
      i.push(l), r += l.length + 1;
    }
    let o = this.fieldPositions.map((l) => new Qu(l.field, n[l.line] + l.from, n[l.line] + l.to));
    return { text: i, ranges: o };
  }
  static parse(t) {
    let r = [], i = [], n = [], a;
    for (let s of t.split(/\r\n?|\n/)) {
      for (; a = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(s); ) {
        let o = a[1] ? +a[1] : null, l = a[2] || a[3] || "", c = -1;
        for (let f = 0; f < r.length; f++)
          (o != null ? r[f].seq == o : l && r[f].name == l) && (c = f);
        if (c < 0) {
          let f = 0;
          for (; f < r.length && (o == null || r[f].seq != null && r[f].seq < o); )
            f++;
          r.splice(f, 0, { seq: o, name: l }), c = f;
          for (let p of n)
            p.field >= c && p.field++;
        }
        n.push(new Bm(c, i.length, a.index, a.index + l.length)), s = s.slice(0, a.index) + l + s.slice(a.index + a[0].length);
      }
      for (let o; o = /\\([{}])/.exec(s); ) {
        s = s.slice(0, o.index) + o[1] + s.slice(o.index + o[0].length);
        for (let l of n)
          l.line == i.length && l.from > o.index && (l.from--, l.to--);
      }
      i.push(s);
    }
    return new _Gu(i, n);
  }
};
var $m = Ao.widget({ widget: new class extends am {
  toDOM() {
    let e = document.createElement("span");
    return e.className = "cm-snippetFieldPosition", e;
  }
  ignoreEvent() {
    return false;
  }
}() });
var Ym = Ao.mark({ class: "cm-snippetField" });
var In = class _In {
  constructor(t, r) {
    this.ranges = t, this.active = r, this.deco = Ao.set(t.map((i) => (i.from == i.to ? $m : Ym).range(i.from, i.to)));
  }
  map(t) {
    let r = [];
    for (let i of this.ranges) {
      let n = i.map(t);
      if (!n)
        return null;
      r.push(n);
    }
    return new _In(r, this.active);
  }
  selectionInsideField(t) {
    return t.ranges.every((r) => this.ranges.some((i) => i.field == this.active && i.from <= r.from && i.to >= r.to));
  }
};
var ma = Eo.define({
  map(e, t) {
    return e && e.map(t);
  }
});
var Fm = Eo.define();
var ta = tu.define({
  create() {
    return null;
  },
  update(e, t) {
    for (let r of t.effects) {
      if (r.is(ma))
        return r.value;
      if (r.is(Fm) && e)
        return new In(e.ranges, r.value);
    }
    return e && t.docChanged && (e = e.map(t.changes)), e && t.selection && !e.selectionInsideField(t.selection) && (e = null), e;
  },
  provide: (e) => ua.decorations.from(e, (t) => t ? t.deco : Ao.none)
});
function Vu(e, t) {
  return $2.create(e.filter((r) => r.field == t).map((r) => $2.range(r.from, r.to)));
}
function Wm(e) {
  let t = Gu.parse(e);
  return (r, i, n, a) => {
    let { text: s, ranges: o } = t.instantiate(r.state, n), l = {
      changes: { from: n, to: a, insert: va.of(s) },
      scrollIntoView: true,
      annotations: i ? [wu.of(i), i4.userEvent.of("input.complete")] : void 0
    };
    if (o.length && (l.selection = Vu(o, 0)), o.some((c) => c.field > 0)) {
      let c = new In(o, 0), f = l.effects = [ma.of(c)];
      r.state.field(ta, false) === void 0 && f.push(Eo.appendConfig.of([ta, zm, qm, Lp]));
    }
    r.dispatch(r.state.update(l));
  };
}
function xp(e) {
  return ({ state: t, dispatch: r }) => {
    let i = t.field(ta, false);
    if (!i || e < 0 && i.active == 0)
      return false;
    let n = i.active + e, a = e > 0 && !i.ranges.some((s) => s.field == n + e);
    return r(t.update({
      selection: Vu(i.ranges, n),
      effects: ma.of(a ? null : new In(i.ranges, n)),
      scrollIntoView: true
    })), true;
  };
}
var Xm = ({ state: e, dispatch: t }) => e.field(ta, false) ? (t(e.update({ effects: ma.of(null) })), true) : false;
var jm = xp(1);
var Zm = xp(-1);
var Hm = [
  { key: "Tab", run: jm, shift: Zm },
  { key: "Escape", run: Xm }
];
var hf = Tn.define({
  combine(e) {
    return e.length ? e[0] : Hm;
  }
});
var zm = GP1.highest(qXn.compute([hf], (e) => e.facet(hf)));
function qt(e, t) {
  return Object.assign(Object.assign({}, t), { apply: Wm(e) });
}
var qm = ua.domEventHandlers({
  mousedown(e, t) {
    let r = t.state.field(ta, false), i;
    if (!r || (i = t.posAtCoords({ x: e.clientX, y: e.clientY })) == null)
      return false;
    let n = r.ranges.find((a) => a.from <= i && a.to >= i);
    return !n || n.field == r.active ? false : (t.dispatch({
      selection: Vu(r.ranges, n.field),
      effects: ma.of(r.ranges.some((a) => a.field > n.field) ? new In(r.ranges, n.field) : null),
      scrollIntoView: true
    }), true);
  }
});
var ra = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
var Ui = Eo.define({
  map(e, t) {
    let r = t.mapPos(e, -1, C0.TrackAfter);
    return r ?? void 0;
  }
});
var Bu = new class extends bg {
}();
Bu.startSide = 1;
Bu.endSide = -1;
var Dp = tu.define({
  create() {
    return qr.empty;
  },
  update(e, t) {
    if (e = e.map(t.changes), t.selection) {
      let r = t.state.doc.lineAt(t.selection.main.head);
      e = e.update({ filter: (i) => i >= r.from && i <= r.to });
    }
    for (let r of t.effects)
      r.is(Ui) && (e = e.update({ add: [Bu.range(r.value, r.value + 1)] }));
    return e;
  }
});
function Jm() {
  return [eR, Dp];
}
var Io = "()[]{}<>";
function Up(e) {
  for (let t = 0; t < Io.length; t += 2)
    if (Io.charCodeAt(t) == e)
      return Io.charAt(t + 1);
  return ulr(e < 128 ? e : e + 1);
}
function wp(e, t) {
  return e.languageDataAt("closeBrackets", t)[0] || ra;
}
var Km = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var eR = ua.inputHandler.of((e, t, r, i) => {
  if ((Km ? e.composing : e.compositionStarted) || e.state.readOnly)
    return false;
  let n = e.state.selection.main;
  if (i.length > 2 || i.length == 2 && yK(_E(i, 0)) == 1 || t != n.from || r != n.to)
    return false;
  let a = iR(e.state, i);
  return a ? (e.dispatch(a), true) : false;
});
var tR = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return false;
  let i = wp(e, e.selection.main.head).brackets || ra.brackets, n = null, a = e.changeByRange((s) => {
    if (s.empty) {
      let o = nR(e.doc, s.head);
      for (let l of i)
        if (l == o && Fs(e.doc, s.head) == Up(_E(l, 0)))
          return {
            changes: { from: s.head - l.length, to: s.head + l.length },
            range: $2.cursor(s.head - l.length)
          };
    }
    return { range: n = s };
  });
  return n || t(e.update(a, { scrollIntoView: true, userEvent: "delete.backward" })), !n;
};
var rR = [
  { key: "Backspace", run: tR }
];
function iR(e, t) {
  let r = wp(e, e.selection.main.head), i = r.brackets || ra.brackets;
  for (let n of i) {
    let a = Up(_E(n, 0));
    if (t == n)
      return a == n ? oR(e, n, i.indexOf(n + n + n) > -1, r) : aR(e, n, a, r.before || ra.before);
    if (t == a && Mp(e, e.selection.main.from))
      return sR(e, n, a);
  }
  return null;
}
function Mp(e, t) {
  let r = false;
  return e.field(Dp).between(0, e.doc.length, (i) => {
    i == t && (r = true);
  }), r;
}
function Fs(e, t) {
  let r = e.sliceString(t, t + 2);
  return r.slice(0, yK(_E(r, 0)));
}
function nR(e, t) {
  let r = e.sliceString(t - 2, t);
  return yK(_E(r, 0)) == r.length ? r : r.slice(1);
}
function aR(e, t, r, i) {
  let n = null, a = e.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: t, from: s.from }, { insert: r, from: s.to }],
        effects: Ui.of(s.to + t.length),
        range: $2.range(s.anchor + t.length, s.head + t.length)
      };
    let o = Fs(e.doc, s.head);
    return !o || /\s/.test(o) || i.indexOf(o) > -1 ? {
      changes: { insert: t + r, from: s.head },
      effects: Ui.of(s.head + t.length),
      range: $2.cursor(s.head + t.length)
    } : { range: n = s };
  });
  return n ? null : e.update(a, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function sR(e, t, r) {
  let i = null, n = e.changeByRange((a) => a.empty && Fs(e.doc, a.head) == r ? {
    changes: { from: a.head, to: a.head + r.length, insert: r },
    range: $2.cursor(a.head + r.length)
  } : i = { range: a });
  return i ? null : e.update(n, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function oR(e, t, r, i) {
  let n = i.stringPrefixes || ra.stringPrefixes, a = null, s = e.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: t, from: o.from }, { insert: t, from: o.to }],
        effects: Ui.of(o.to + t.length),
        range: $2.range(o.anchor + t.length, o.head + t.length)
      };
    let l = o.head, c = Fs(e.doc, l), f;
    if (c == t) {
      if (pf(e, l))
        return {
          changes: { insert: t + t, from: l },
          effects: Ui.of(l + t.length),
          range: $2.cursor(l + t.length)
        };
      if (Mp(e, l)) {
        let O = r && e.sliceDoc(l, l + t.length * 3) == t + t + t ? t + t + t : t;
        return {
          changes: { from: l, to: l + O.length, insert: O },
          range: $2.cursor(l + O.length)
        };
      }
    } else {
      if (r && e.sliceDoc(l - 2 * t.length, l) == t + t && (f = Of(e, l - 2 * t.length, n)) > -1 && pf(e, f))
        return {
          changes: { insert: t + t + t + t, from: l },
          effects: Ui.of(l + t.length),
          range: $2.cursor(l + t.length)
        };
      if (e.charCategorizer(l)(c) != k8.Word && Of(e, l, n) > -1 && !lR(e, l, t, n))
        return {
          changes: { insert: t + t, from: l },
          effects: Ui.of(l + t.length),
          range: $2.cursor(l + t.length)
        };
    }
    return { range: a = o };
  });
  return a ? null : e.update(s, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function pf(e, t) {
  let r = Ot(e).resolveInner(t + 1);
  return r.parent && r.from == t;
}
function lR(e, t, r, i) {
  let n = Ot(e).resolveInner(t, -1), a = i.reduce((s, o) => Math.max(s, o.length), 0);
  for (let s = 0; s < 5; s++) {
    let o = e.sliceDoc(n.from, Math.min(n.to, n.from + r.length + a)), l = o.indexOf(r);
    if (!l || l > -1 && i.indexOf(o.slice(0, l)) > -1) {
      let f = n.firstChild;
      for (; f && f.from == n.from && f.to - f.from > r.length + l; ) {
        if (e.sliceDoc(f.to - r.length, f.to) == r)
          return false;
        f = f.firstChild;
      }
      return true;
    }
    let c = n.to == t && n.parent;
    if (!c)
      break;
    n = c;
  }
  return false;
}
function Of(e, t, r) {
  let i = e.charCategorizer(t);
  if (i(e.sliceDoc(t - 1, t)) != k8.Word)
    return t;
  for (let n of r) {
    let a = t - n.length;
    if (e.sliceDoc(a, t) == n && i(e.sliceDoc(a - 1, a)) != k8.Word)
      return a;
  }
  return -1;
}
function uR(e = {}) {
  return [
    Vm,
    Jt,
    Qt.of(e),
    Qm,
    fR,
    Lp
  ];
}
var cR = [
  { key: "Ctrl-Space", run: Um },
  { key: "Escape", run: ku },
  { key: "ArrowDown", run: kr(true) },
  { key: "ArrowUp", run: kr(false) },
  { key: "PageDown", run: kr(true, "page") },
  { key: "PageUp", run: kr(false, "page") },
  { key: "Enter", run: ol }
];
var fR = GP1.highest(qXn.computeN([Qt], (e) => e.facet(Qt).defaultKeymap ? [cR] : []));
var Es = class _Es {
  /**
  @internal
  */
  constructor(t, r, i, n, a, s, o, l, c, f = 0, p) {
    this.p = t, this.stack = r, this.state = i, this.reducePos = n, this.pos = a, this.score = s, this.buffer = o, this.bufferBase = l, this.curContext = c, this.lookAhead = f, this.parent = p;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, r, i = 0) {
    let n = t.parser.context;
    return new _Es(t, [], r, i, i, 0, [], 0, n ? new Ef(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var r;
    let i = t >> 19, n = t & 65535, { parser: a } = this.p, s = a.dynamicPrecedence(n);
    if (s && (this.score += s), i == 0) {
      this.pushState(a.getGoto(this.state, n, true), this.reducePos), n < a.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, true), this.reduceContext(n, this.reducePos);
      return;
    }
    let o = this.stack.length - (i - 1) * 3 - (t & 262144 ? 6 : 0), l = o ? this.stack[o - 2] : this.p.ranges[0].from, c = this.reducePos - l;
    c >= 2e3 && !(!((r = this.p.parser.nodeSet.types[n]) === null || r === void 0) && r.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = c));
    let f = o ? this.stack[o - 1] : 0, p = this.bufferBase + this.buffer.length - f;
    if (n < a.minRepeatTerm || t & 131072) {
      let O = a.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, l, O, p + 4, true);
    }
    if (t & 262144)
      this.state = this.stack[o];
    else {
      let O = this.stack[o - 3];
      this.state = a.getGoto(O, n, true);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(n, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, r, i, n = 4, a = false) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, o = this.buffer.length;
      if (o == 0 && s.parent && (o = s.bufferBase - s.parent.bufferBase, s = s.parent), o > 0 && s.buffer[o - 4] == 0 && s.buffer[o - 1] > -1) {
        if (r == i)
          return;
        if (s.buffer[o - 2] >= r) {
          s.buffer[o - 2] = i;
          return;
        }
      }
    }
    if (!a || this.pos == i)
      this.buffer.push(t, r, i, n);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0)
        for (; s > 0 && this.buffer[s - 2] > i; )
          this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, n > 4 && (n -= 4);
      this.buffer[s] = t, this.buffer[s + 1] = r, this.buffer[s + 2] = i, this.buffer[s + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, r, i, n) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if (t & 262144)
      this.pos = n, this.shiftContext(r, i), r <= this.p.parser.maxNode && this.buffer.push(r, i, n, 4);
    else {
      let a = t, { parser: s } = this.p;
      (n > this.pos || r <= s.maxNode) && (this.pos = n, s.stateFlag(
        a,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = n)), this.pushState(a, i), this.shiftContext(r, i), r <= s.maxNode && this.buffer.push(r, i, n, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, r, i, n) {
    t & 65536 ? this.reduce(t) : this.shift(t, r, i, n);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, r) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + t.length, this.pushState(r, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, r = t.buffer.length;
    for (; r > 0 && t.buffer[r - 2] > t.reducePos; )
      r -= 4;
    let i = t.buffer.slice(r), n = t.bufferBase + r;
    for (; t && n == t.bufferBase; )
      t = t.parent;
    return new _Es(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, r) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, r, 4), this.storeNode(0, this.pos, r, i ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let r = new hR(this); ; ) {
      let i = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, t);
      if (i == 0)
        return false;
      if (!(i & 65536))
        return true;
      r.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let a = 0, s; a < r.length; a += 2)
        (s = r[a + 1]) != this.state && this.p.parser.hasAction(s, t) && n.push(r[a], s);
      if (this.stack.length < 120)
        for (let a = 0; n.length < 8 && a < r.length; a += 2) {
          let s = r[a + 1];
          n.some((o, l) => l & 1 && o == s) || n.push(r[a], s);
        }
      r = n;
    }
    let i = [];
    for (let n = 0; n < r.length && i.length < 4; n += 2) {
      let a = r[n + 1];
      if (a == this.state)
        continue;
      let s = this.split();
      s.pushState(a, this.pos), s.storeNode(0, s.pos, s.pos, 4, true), s.shiftContext(r[n], this.pos), s.reducePos = this.pos, s.score -= 200, i.push(s);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, r = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(r & 65536))
      return false;
    if (!t.validAction(this.state, r)) {
      let i = r >> 19, n = r & 65535, a = this.stack.length - i * 3;
      if (a < 0 || t.getGoto(this.stack[a], n, false) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return false;
        r = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, true), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, r = [], i = (n, a) => {
      if (!r.includes(n))
        return r.push(n), t.allActions(n, (s) => {
          if (!(s & 393216))
            if (s & 65536) {
              let o = (s >> 19) - a;
              if (o > 1) {
                let l = s & 65535, c = this.stack.length - o * 3;
                if (c >= 0 && t.getGoto(this.stack[c], l, false) >= 0)
                  return o << 19 | 65536 | l;
              }
            } else {
              let o = i(s, a + 1);
              if (o != null)
                return o;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return false;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != t.stack[r])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(r)));
  }
  reduceContext(t, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let r = new Ef(this.curContext.tracker, t);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
var Ef = class {
  constructor(t, r) {
    this.tracker = t, this.context = r, this.hash = t.strict ? t.hash(r) : 0;
  }
};
var hR = class {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let r = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], r, true);
    this.state = n;
  }
};
var ds = class _ds {
  constructor(t, r, i) {
    this.stack = t, this.pos = r, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, r = t.bufferBase + t.buffer.length) {
    return new _ds(t, r, r - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new _ds(this.stack, this.pos, this.index);
  }
};
function Bn(e, t = Uint16Array) {
  if (typeof e != "string")
    return e;
  let r = null;
  for (let i = 0, n = 0; i < e.length; ) {
    let a = 0;
    for (; ; ) {
      let s = e.charCodeAt(i++), o = false;
      if (s == 126) {
        a = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, o = true), a += l, o)
        break;
      a *= 46;
    }
    r ? r[n++] = a : r = new t(a);
  }
  return r;
}
var ts = class {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
};
var df = new ts();
var pR = class {
  /**
  @internal
  */
  constructor(t, r) {
    this.input = t, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = df, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, r) {
    let i = this.range, n = this.rangeIndex, a = this.pos + t;
    for (; a < i.from; ) {
      if (!n)
        return null;
      let s = this.ranges[--n];
      a -= i.from - s.to, i = s;
    }
    for (; r < 0 ? a > i.to : a >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let s = this.ranges[++n];
      a += s.from - i.to, i = s;
    }
    return a;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let r of this.ranges)
      if (r.to > t)
        return Math.max(t, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let r = this.chunkOff + t, i, n;
    if (r >= 0 && r < this.chunk.length)
      i = this.pos + t, n = this.chunk.charCodeAt(r);
    else {
      let a = this.resolveOffset(t, 1);
      if (a == null)
        return -1;
      if (i = a, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let s = this.rangeIndex, o = this.range;
        for (; o.to <= i; )
          o = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > o.to && (this.chunk2 = this.chunk2.slice(0, o.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, r = 0) {
    let i = r ? this.resolveOffset(r, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, r) {
    this.token.value = t, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), r = this.pos + t.length;
      this.chunk = r > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, r) {
    if (r ? (this.token = r, r.start = t, r.lookAhead = t + 1, r.value = r.extended = -1) : this.token = df, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, r) {
    if (t >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, r - this.chunkPos);
    if (t >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, r - this.chunk2Pos);
    if (t >= this.range.from && r <= this.range.to)
      return this.input.read(t, r);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= r)
        break;
      n.to > t && (i += this.input.read(Math.max(n.from, t), Math.min(n.to, r)));
    }
    return i;
  }
};
var on = class {
  constructor(t, r) {
    this.data = t, this.id = r;
  }
  token(t, r) {
    let { parser: i } = r.p;
    kp(this.data, t, r, this.id, i.data, i.tokenPrecTable);
  }
};
on.prototype.contextual = on.prototype.fallback = on.prototype.extend = false;
var Ts = class {
  constructor(t, r, i) {
    this.precTable = r, this.elseToken = i, this.data = typeof t == "string" ? Bn(t) : t;
  }
  token(t, r) {
    let i = t.pos, n = 0;
    for (; ; ) {
      let a = t.next < 0, s = t.resolveOffset(1, 1);
      if (kp(this.data, t, r, 0, this.data, this.precTable), t.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (a || n++, s == null)
        break;
      t.reset(s, t.token);
    }
    n && (t.reset(i, t.token), t.acceptToken(this.elseToken, n));
  }
};
Ts.prototype.contextual = on.prototype.fallback = on.prototype.extend = false;
var mr = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(t, r = {}) {
    this.token = t, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
};
function kp(e, t, r, i, n, a) {
  let s = 0, o = 1 << i, { dialect: l } = r.p.parser;
  e:
    for (; o & e[s]; ) {
      let c = e[s + 1];
      for (let d2 = s + 3; d2 < c; d2 += 2)
        if ((e[d2 + 1] & o) > 0) {
          let g = e[d2];
          if (l.allows(g) && (t.token.value == -1 || t.token.value == g || OR(g, t.token.value, n, a))) {
            t.acceptToken(g);
            break;
          }
        }
      let f = t.next, p = 0, O = e[s + 2];
      if (t.next < 0 && O > p && e[c + O * 3 - 3] == 65535) {
        s = e[c + O * 3 - 1];
        continue e;
      }
      for (; p < O; ) {
        let d2 = p + O >> 1, g = c + d2 + (d2 << 1), L = e[g], D = e[g + 1] || 65536;
        if (f < L)
          O = d2;
        else if (f >= D)
          p = d2 + 1;
        else {
          s = e[g + 2], t.advance();
          continue e;
        }
      }
      break;
    }
}
function Tf(e, t, r) {
  for (let i = t, n; (n = e[i]) != 65535; i++)
    if (n == r)
      return i - t;
  return -1;
}
function OR(e, t, r, i) {
  let n = Tf(r, i, t);
  return n < 0 || Tf(r, i, e) < n;
}
var tr = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
var No = null;
function Sf(e, t, r) {
  let i = e.cursor(st.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(r < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((r < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            i.to - 1,
            t - 25
            /* Safety.Margin */
          )) : Math.min(e.length, Math.max(
            i.from + 1,
            t + 25
            /* Safety.Margin */
          ));
        if (r < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return r < 0 ? 0 : e.length;
      }
}
var ER = class {
  constructor(t, r) {
    this.fragments = t, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? Sf(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? Sf(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let i = this.trees[r], n = this.index[r];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let a = i.children[n], s = this.start[r] + i.positions[n];
      if (s > t)
        return this.nextStart = s, null;
      if (a instanceof ht) {
        if (s == t) {
          if (s < this.safeFrom)
            return null;
          let o = s + a.length;
          if (o <= this.safeTo) {
            let l = a.prop(Le.lookAhead);
            if (!l || o + l < this.fragment.to)
              return a;
          }
        }
        this.index[r]++, s + a.length >= Math.max(this.safeFrom, t) && (this.trees.push(a), this.start.push(s), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = s + a.length;
    }
  }
};
var dR = class {
  constructor(t, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new ts());
  }
  getActions(t) {
    let r = 0, i = null, { parser: n } = t.p, { tokenizers: a } = n, s = n.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), o = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let c = 0; c < a.length; c++) {
      if (!(1 << c & s))
        continue;
      let f = a[c], p = this.tokens[c];
      if (!(i && !f.fallback) && ((f.contextual || p.start != t.pos || p.mask != s || p.context != o) && (this.updateCachedToken(p, f, t), p.mask = s, p.context = o), p.lookAhead > p.end + 25 && (l = Math.max(p.lookAhead, l)), p.value != 0)) {
        let O = r;
        if (p.extended > -1 && (r = this.addActions(t, p.extended, p.end, r)), r = this.addActions(t, p.value, p.end, r), !f.extend && (i = p, r > O))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return l && t.setLookAhead(l), !i && t.pos == this.stream.end && (i = new ts(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, r = this.addActions(t, i.value, i.end, r)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let r = new ts(), { pos: i, p: n } = t;
    return r.start = i, r.end = Math.min(i + 1, n.stream.end), r.value = i == n.stream.end ? n.parser.eofTerm : 0, r;
  }
  updateCachedToken(t, r, i) {
    let n = this.stream.clipPos(i.pos);
    if (r.token(this.stream.reset(n, t), i), t.value > -1) {
      let { parser: a } = i.p;
      for (let s = 0; s < a.specialized.length; s++)
        if (a.specialized[s] == t.value) {
          let o = a.specializers[s](this.stream.read(t.start, t.end), i);
          if (o >= 0 && i.p.parser.dialect.allows(o >> 1)) {
            o & 1 ? t.extended = o >> 1 : t.value = o >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(n + 1);
  }
  putAction(t, r, i, n) {
    for (let a = 0; a < n; a += 3)
      if (this.actions[a] == t)
        return n;
    return this.actions[n++] = t, this.actions[n++] = r, this.actions[n++] = i, n;
  }
  addActions(t, r, i, n) {
    let { state: a } = t, { parser: s } = t.p, { data: o } = s;
    for (let l = 0; l < 2; l++)
      for (let c = s.stateSlot(
        a,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (o[c] == 65535)
          if (o[c + 1] == 1)
            c = zr(o, c + 2);
          else {
            n == 0 && o[c + 1] == 2 && (n = this.putAction(zr(o, c + 2), r, i, n));
            break;
          }
        o[c] == r && (n = this.putAction(zr(o, c + 1), r, i, n));
      }
    return n;
  }
};
var TR = class {
  constructor(t, r, i, n) {
    this.parser = t, this.input = r, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new pR(r, n), this.tokens = new dR(t, this.stream), this.topTerm = t.top[1];
    let { from: a } = n[0];
    this.stacks = [Es.start(this, t.top[0], a)], this.fragments = i.length && this.stream.end - a > t.bufferLength * 4 ? new ER(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, r = this.minStackPos, i = this.stacks = [], n, a;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [s] = t;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < t.length; s++) {
      let o = t[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, o.pos > r)
          i.push(o);
        else {
          if (this.advanceStack(o, i, t))
            continue;
          {
            n || (n = [], a = []), n.push(o);
            let l = this.tokens.getMainToken(o);
            a.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let s = n && mR(n);
      if (s)
        return tr && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw tr && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let s = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, a, i);
      if (s)
        return tr && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > s)
        for (i.sort((o, l) => l.score - o.score); i.length > s; )
          i.pop();
      i.some((o) => o.reducePos > r) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let s = 0; s < i.length - 1; s++) {
          let o = i[s];
          for (let l = s + 1; l < i.length; l++) {
            let c = i[l];
            if (o.sameState(c) || o.buffer.length > 500 && c.buffer.length > 500)
              if ((o.score - c.score || o.buffer.length - c.buffer.length) > 0)
                i.splice(l--, 1);
              else {
                i.splice(s--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let s = 1; s < i.length; s++)
      i[s].pos < this.minStackPos && (this.minStackPos = i[s].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, r, i) {
    let n = t.pos, { parser: a } = this, s = tr ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let c = t.curContext && t.curContext.tracker.strict, f = c ? t.curContext.hash : 0;
      for (let p = this.fragments.nodeAt(n); p; ) {
        let O = this.parser.nodeSet.types[p.type.id] == p.type ? a.getGoto(t.state, p.type.id) : -1;
        if (O > -1 && p.length && (!c || (p.prop(Le.contextHash) || 0) == f))
          return t.useNode(p, O), tr && console.log(s + this.stackID(t) + ` (via reuse of ${a.getName(p.type.id)})`), true;
        if (!(p instanceof ht) || p.children.length == 0 || p.positions[0] > 0)
          break;
        let d2 = p.children[0];
        if (d2 instanceof ht && p.positions[0] == 0)
          p = d2;
        else
          break;
      }
    }
    let o = a.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (o > 0)
      return t.reduce(o), tr && console.log(s + this.stackID(t) + ` (via always-reduce ${a.getName(
        o & 65535
        /* Action.ValueMask */
      )})`), true;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let c = 0; c < l.length; ) {
      let f = l[c++], p = l[c++], O = l[c++], d2 = c == l.length || !i, g = d2 ? t : t.split(), L = this.tokens.mainToken;
      if (g.apply(f, p, L ? L.start : g.pos, O), tr && console.log(s + this.stackID(g) + ` (via ${f & 65536 ? `reduce of ${a.getName(
        f & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${a.getName(p)} @ ${n}${g == t ? "" : ", split"})`), d2)
        return true;
      g.pos > n ? r.push(g) : i.push(g);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, r) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return false;
      if (t.pos > i)
        return mf(t, r), true;
    }
  }
  runRecovery(t, r, i) {
    let n = null, a = false;
    for (let s = 0; s < t.length; s++) {
      let o = t[s], l = r[s << 1], c = r[(s << 1) + 1], f = tr ? this.stackID(o) + " -> " : "";
      if (o.deadEnd && (a || (a = true, o.restart(), tr && console.log(f + this.stackID(o) + " (restarted)"), this.advanceFully(o, i))))
        continue;
      let p = o.split(), O = f;
      for (let d2 = 0; p.forceReduce() && d2 < 10 && (tr && console.log(O + this.stackID(p) + " (via force-reduce)"), !this.advanceFully(p, i)); d2++)
        tr && (O = this.stackID(p) + " -> ");
      for (let d2 of o.recoverByInsert(l))
        tr && console.log(f + this.stackID(d2) + " (via recover-insert)"), this.advanceFully(d2, i);
      this.stream.end > o.pos ? (c == o.pos && (c++, l = 0), o.recoverByDelete(l, c), tr && console.log(f + this.stackID(o) + ` (via recover-delete ${this.parser.getName(l)})`), mf(o, i)) : (!n || n.score < o.score) && (n = o);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), ht.build({
      buffer: ds.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let r = (No || (No = /* @__PURE__ */ new WeakMap())).get(t);
    return r || No.set(t, r = String.fromCodePoint(this.nextStackID++)), r + t;
  }
};
function mf(e, t) {
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    if (i.pos == e.pos && i.sameState(e)) {
      t[r].score < e.score && (t[r] = e);
      return;
    }
  }
  t.push(e);
}
var SR = class {
  constructor(t, r, i) {
    this.source = t, this.flags = r, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
};
var Po = (e) => e;
var Qp = class {
  /**
  Define a context tracker.
  */
  constructor(t) {
    this.start = t.start, this.shift = t.shift || Po, this.reduce = t.reduce || Po, this.reuse = t.reuse || Po, this.hash = t.hash || (() => 0), this.strict = t.strict !== false;
  }
};
var Ri = class _Ri extends fp {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let r = t.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let o = 0; o < t.repeatNodeCount; o++)
      r.push("");
    let i = Object.keys(t.topRules).map((o) => t.topRules[o][1]), n = [];
    for (let o = 0; o < r.length; o++)
      n.push([]);
    function a(o, l, c) {
      n[o].push([l, l.deserialize(String(c))]);
    }
    if (t.nodeProps)
      for (let o of t.nodeProps) {
        let l = o[0];
        typeof l == "string" && (l = Le[l]);
        for (let c = 1; c < o.length; ) {
          let f = o[c++];
          if (f >= 0)
            a(f, l, o[c++]);
          else {
            let p = o[c + -f];
            for (let O = -f; O > 0; O--)
              a(o[c++], l, p);
            c++;
          }
        }
      }
    this.nodeSet = new yu(r.map((o, l) => or.define({
      name: l >= this.minRepeatTerm ? void 0 : o,
      id: l,
      props: n[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = false, this.bufferLength = ap;
    let s = Bn(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let o = 0; o < this.specializerSpecs.length; o++)
      this.specialized[o] = this.specializerSpecs[o].term;
    this.specializers = this.specializerSpecs.map(Rf), this.states = Bn(t.states, Uint32Array), this.data = Bn(t.stateData), this.goto = Bn(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((o) => typeof o == "number" ? new on(s, o) : o), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, r, i) {
    let n = new TR(this, t, r, i);
    for (let a of this.wrappers)
      n = a(n, t, r, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, r, i = false) {
    let n = this.goto;
    if (r >= n[0])
      return -1;
    for (let a = n[r + 1]; ; ) {
      let s = n[a++], o = s & 1, l = n[a++];
      if (o && i)
        return l;
      for (let c = a + (s >> 1); a < c; a++)
        if (n[a] == t)
          return l;
      if (o)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, r) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let a = this.stateSlot(
        t,
        n ? 2 : 1
        /* ParseState.Actions */
      ), s; ; a += 3) {
        if ((s = i[a]) == 65535)
          if (i[a + 1] == 1)
            s = i[a = zr(i, a + 2)];
          else {
            if (i[a + 1] == 2)
              return zr(i, a + 2);
            break;
          }
        if (s == r || s == 0)
          return zr(i, a + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, r) {
    return this.states[t * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(t, r) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(t, r) {
    return !!this.allActions(t, (i) => i == r ? true : null);
  }
  /**
  @internal
  */
  allActions(t, r) {
    let i = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? r(i) : void 0;
    for (let a = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); n == null; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1)
          a = zr(this.data, a + 2);
        else
          break;
      n = r(zr(this.data, a + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let r = [];
    for (let i = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = zr(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        r.some((a, s) => s & 1 && a == n) || r.push(this.data[i], n);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let r = Object.assign(Object.create(_Ri.prototype), this);
    if (t.props && (r.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      r.top = i;
    }
    return t.tokenizers && (r.tokenizers = this.tokenizers.map((i) => {
      let n = t.tokenizers.find((a) => a.from == i);
      return n ? n.to : i;
    })), t.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let a = t.specializers.find((o) => o.from == i.external);
      if (!a)
        return i;
      let s = Object.assign(Object.assign({}, i), { external: a.to });
      return r.specializers[n] = Rf(s), s;
    })), t.contextTracker && (r.context = t.contextTracker), t.dialect && (r.dialect = this.parseDialect(t.dialect)), t.strict != null && (r.strict = t.strict), t.wrap && (r.wrappers = r.wrappers.concat(t.wrap)), t.bufferLength != null && (r.bufferLength = t.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let r = Object.keys(this.dialects), i = r.map(() => false);
    if (t)
      for (let a of t.split(" ")) {
        let s = r.indexOf(a);
        s >= 0 && (i[s] = true);
      }
    let n = null;
    for (let a = 0; a < r.length; a++)
      if (!i[a])
        for (let s = this.dialects[r[a]], o; (o = this.data[s++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[o] = 1;
    return new SR(t, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new _Ri(t);
  }
};
function zr(e, t) {
  return e[t] | e[t + 1] << 16;
}
function mR(e) {
  let t = null;
  for (let r of e) {
    let i = r.p.stoppedAt;
    (r.pos == r.p.stream.end || i != null && r.pos > i) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < r.score) && (t = r);
  }
  return t;
}
function Rf(e) {
  if (e.external) {
    let t = e.extend ? 1 : 0;
    return (r, i) => e.external(r, i) << 1 | t;
  }
  return e.get;
}
var RR = 310;
var Af = 1;
var AR = 2;
var gR = 3;
var yR = 311;
var IR = 313;
var NR = 314;
var PR = 4;
var _R = 5;
var bR = 0;
var ll = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var Gp = 125;
var vR = 59;
var ul = 47;
var CR = 42;
var LR = 43;
var xR = 45;
var DR = 60;
var UR = 44;
var wR = new Qp({
  start: false,
  shift(e, t) {
    return t == PR || t == _R || t == IR ? e : t == NR;
  },
  strict: false
});
var MR = new mr((e, t) => {
  let { next: r } = e;
  (r == Gp || r == -1 || t.context) && e.acceptToken(yR);
}, { contextual: true, fallback: true });
var kR = new mr((e, t) => {
  let { next: r } = e, i;
  ll.indexOf(r) > -1 || r == ul && ((i = e.peek(1)) == ul || i == CR) || r != Gp && r != vR && r != -1 && !t.context && e.acceptToken(RR);
}, { contextual: true });
var QR = new mr((e, t) => {
  let { next: r } = e;
  if ((r == LR || r == xR) && (e.advance(), r == e.next)) {
    e.advance();
    let i = !t.context && t.canShift(Af);
    e.acceptToken(i ? Af : AR);
  }
}, { contextual: true });
function _o(e, t) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e == 95 || e >= 192 || !t && e >= 48 && e <= 57;
}
var GR = new mr((e, t) => {
  if (e.next != DR || !t.dialectEnabled(bR) || (e.advance(), e.next == ul))
    return;
  let r = 0;
  for (; ll.indexOf(e.next) > -1; )
    e.advance(), r++;
  if (_o(e.next, true)) {
    for (e.advance(), r++; _o(e.next, false); )
      e.advance(), r++;
    for (; ll.indexOf(e.next) > -1; )
      e.advance(), r++;
    if (e.next == UR)
      return;
    for (let i = 0; ; i++) {
      if (i == 7) {
        if (!_o(e.next, true))
          return;
        break;
      }
      if (e.next != "extends".charCodeAt(i))
        break;
      e.advance(), r++;
    }
  }
  e.acceptToken(gR, -r);
});
var VR = An({
  "get set async static": Q.modifier,
  "for while do if else switch try catch finally return throw break continue default case": Q.controlKeyword,
  "in of await yield void typeof delete instanceof": Q.operatorKeyword,
  "let var const using function class extends": Q.definitionKeyword,
  "import export from": Q.moduleKeyword,
  "with debugger as new": Q.keyword,
  TemplateString: Q.special(Q.string),
  super: Q.atom,
  BooleanLiteral: Q.bool,
  this: Q.self,
  null: Q.null,
  Star: Q.modifier,
  VariableName: Q.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": Q.function(Q.variableName),
  VariableDefinition: Q.definition(Q.variableName),
  Label: Q.labelName,
  PropertyName: Q.propertyName,
  PrivatePropertyName: Q.special(Q.propertyName),
  "CallExpression/MemberExpression/PropertyName": Q.function(Q.propertyName),
  "FunctionDeclaration/VariableDefinition": Q.function(Q.definition(Q.variableName)),
  "ClassDeclaration/VariableDefinition": Q.definition(Q.className),
  PropertyDefinition: Q.definition(Q.propertyName),
  PrivatePropertyDefinition: Q.definition(Q.special(Q.propertyName)),
  UpdateOp: Q.updateOperator,
  "LineComment Hashbang": Q.lineComment,
  BlockComment: Q.blockComment,
  Number: Q.number,
  String: Q.string,
  Escape: Q.escape,
  ArithOp: Q.arithmeticOperator,
  LogicOp: Q.logicOperator,
  BitOp: Q.bitwiseOperator,
  CompareOp: Q.compareOperator,
  RegExp: Q.regexp,
  Equals: Q.definitionOperator,
  Arrow: Q.function(Q.punctuation),
  ": Spread": Q.punctuation,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace,
  "InterpolationStart InterpolationEnd": Q.special(Q.brace),
  ".": Q.derefOperator,
  ", ;": Q.separator,
  "@": Q.meta,
  TypeName: Q.typeName,
  TypeDefinition: Q.definition(Q.typeName),
  "type enum interface implements namespace module declare": Q.definitionKeyword,
  "abstract global Privacy readonly override": Q.modifier,
  "is keyof unique infer": Q.operatorKeyword,
  JSXAttributeValue: Q.attributeValue,
  JSXText: Q.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": Q.angleBracket,
  "JSXIdentifier JSXNameSpacedName": Q.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": Q.attributeName,
  "JSXBuiltin/JSXIdentifier": Q.standard(Q.tagName)
});
var BR = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 154, yield: 163, await: 167, class: 172, public: 229, private: 229, protected: 229, readonly: 231, instanceof: 250, satisfies: 253, in: 254, const: 256, import: 288, keyof: 341, unique: 345, infer: 351, is: 387, abstract: 407, implements: 409, type: 411, let: 414, var: 416, using: 419, interface: 425, enum: 429, namespace: 435, module: 437, declare: 441, global: 445, for: 464, of: 473, while: 476, with: 480, do: 484, if: 488, else: 490, switch: 494, case: 500, try: 506, catch: 510, finally: 514, return: 518, throw: 522, break: 526, continue: 530, debugger: 534 };
var $R = { __proto__: null, async: 123, get: 125, set: 127, declare: 189, public: 191, private: 191, protected: 191, static: 193, abstract: 195, override: 197, readonly: 203, accessor: 205, new: 391 };
var YR = { __proto__: null, "<": 145 };
var FR = Ri.deserialize({
  version: 14,
  states: "$=dO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ?NdO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO!0LbO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DzO0fQ^O'#ESOOQ?Mr'#E['#E[O1PQWO'#EXOOQO'#Em'#EmOOQO'#If'#IfO1XQWO'#GnO1dQWO'#ElO1iQWO'#ElO3kQ?NdO'#JjO6[Q?NdO'#JkO6xQWO'#F[O6}Q&jO'#FrOOQ?Mr'#Fd'#FdO7YO,YO'#FdO7hQ7[O'#FyO9UQWO'#FxOOQ?Mr'#Jk'#JkOOQ?Mp'#Jj'#JjO9ZQWO'#GrOOQU'#KW'#KWO9fQWO'#ISO9kQ?MxO'#ITOOQU'#JX'#JXOOQU'#IX'#IXQ`Q^OOO`Q^OOO9sQMnO'#DsO9zQ^O'#EOO:RQ^O'#EQO9aQWO'#GnO:YQ7[O'#CnO:hQWO'#EkO:sQWO'#EvO:xQ7[O'#FcO;gQWO'#GnOOQO'#KX'#KXO;lQWO'#KXO;zQWO'#GvO;zQWO'#GwO;zQWO'#GyO9aQWO'#G|O<qQWO'#HPO>YQWO'#CdO>jQWO'#H]O>rQWO'#HcO>rQWO'#HeO`Q^O'#HgO>rQWO'#HiO>rQWO'#HlO>wQWO'#HrO>|Q?MyO'#HxO%[Q^O'#HzO?XQ?MyO'#H|O?dQ?MyO'#IOO9kQ?MxO'#IQO?oQ?NdO'#ChO@qQ`O'#DiQOQWOOO%[Q^O'#EQOAXQWO'#ETO:YQ7[O'#EkOAdQWO'#EkOAoQpO'#FcOOQU'#Cf'#CfOOQ?Mp'#Dn'#DnOOQ?Mp'#Jn'#JnO%[Q^O'#JnOOQO'#Jr'#JrOOQO'#Ic'#IcOBoQ`O'#EdOOQ?Mp'#Ec'#EcOOQ?Mp'#Ju'#JuOCkQ?NQO'#EdOCuQ`O'#EWOOQO'#Jq'#JqODZQ`O'#JrOEhQ`O'#EWOCuQ`O'#EdPEuO#@ItO'#CaPOOO)CDv)CDvOOOO'#IY'#IYOFQO!bO,59TOOQ?Mr,59T,59TOOOO'#IZ'#IZOF`O#tO,59TO%[Q^O'#D`OOOO'#I]'#I]OFnO!0LbO,59xOOQ?Mr,59x,59xOF|Q^O'#I^OGaQWO'#JlOIcQrO'#JlO+}Q^O'#JlOIjQWO,5:OOJQQWO'#EmOJ_QWO'#J{OJjQWO'#JzOJjQWO'#JzOJrQWO,5;ZOJwQWO'#JyOOQ?Mv,5:Z,5:ZOKOQ^O,5:ZOMPQ?NdO,5:fOMpQWO,5:nONZQ?MxO'#JxONbQWO'#JwO9ZQWO'#JwONvQWO'#JwO! OQWO,5;YO! TQWO'#JwO!#]QrO'#JkOOQ?Mr'#Ch'#ChO%[Q^O'#ESO!#{QpO,5:sOOQO'#Js'#JsOOQO-E<d-E<dO9aQWO,5=YO!$cQWO,5=YO!$hQ^O,5;WO!&kQ7[O'#EhO!(UQWO,5;WO!)tQ7[O'#DtO!){Q^O'#DyO!*VQ`O,5;aO!*_Q`O,5;aO%[Q^O,5;aOOQU'#FS'#FSOOQU'#FU'#FUO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bO%[Q^O,5;bOOQU'#FY'#FYO!*mQ^O,5;sOOQ?Mr,5;x,5;xOOQ?Mr,5;y,5;yO!,pQWO,5;yOOQ?Mr,5;z,5;zO%[Q^O'#IjO!,xQ?MxO,5<fO!&kQ7[O,5;bO!-gQ7[O,5;bO%[Q^O,5;vO!-nQ&jO'#FhO!.kQ&jO'#KPO!.VQ&jO'#KPO!.rQ&jO'#KPOOQO'#KP'#KPO!/WQ&jO,5<QOOOS,5<^,5<^O!/iQ^O'#FtOOOS'#Ii'#IiO7YO,YO,5<OO!/pQ&jO'#FvOOQ?Mr,5<O,5<OO!0aQ!LQO'#CuOOQ?Mr'#Cy'#CyO!0tQWO'#CyO!0yO!0LbO'#C}O!1gQ7[O,5<cO!1nQWO,5<eO!3ZQ$ISO'#GTO!3hQWO'#GUO!3mQWO'#GUO!5]Q$ISO'#GYO!6XQ`O'#G^OOQO'#Gi'#GiO!(ZQ7[O'#GhOOQO'#Gk'#GkO!(ZQ7[O'#GjO!6zQ!LQO'#JeOOQ?Mr'#Je'#JeO!7UQWO'#JdO!7dQWO'#JcO!7lQWO'#CtOOQ?Mr'#Cw'#CwOOQ?Mr'#DR'#DROOQ?Mr'#DT'#DTO1SQWO'#DVO!(ZQ7[O'#F{O!(ZQ7[O'#F}O!7tQWO'#GPO!7yQWO'#GQO!3mQWO'#GWO!(ZQ7[O'#G]O!8OQWO'#EnO!8mQWO,5<dOOQ?Mp'#Cq'#CqO!8uQWO'#EoO!9oQ`O'#EpOOQ?Mp'#Jy'#JyO!9vQ?MxO'#KYO9kQ?MxO,5=^O`Q^O,5>nOOQU'#Ja'#JaOOQU,5>o,5>oOOQU-E<V-E<VO!;xQ?NdO,5:_O!9jQ`O,5:]O!>fQ?NdO,5:jO%[Q^O,5:jO!APQ?NdO,5:lOOQO,5@s,5@sO!ApQ7[O,5=YO!BOQ?MxO'#JbO9UQWO'#JbO!BaQ?MxO,59YO!BlQ`O,59YO!BtQ7[O,59YO:YQ7[O,59YO!CPQWO,5;WO!CXQWO'#H[O!CmQWO'#K]O%[Q^O,5;{O!9jQ`O,5;}O!CuQWO,5=uO!CzQWO,5=uO!DPQWO,5=uO9kQ?MxO,5=uO;zQWO,5=eOOQO'#Cu'#CuO!D_Q`O,5=bO!DgQ7[O,5=cO!DrQWO,5=eO!DwQpO,5=hO!EPQWO'#KXO>wQWO'#HRO9aQWO'#HTO!EUQWO'#HTO:YQ7[O'#HVO!EZQWO'#HVOOQU,5=k,5=kO!E`QWO'#HWO!EqQWO'#CnO!EvQWO,59OO!FQQWO,59OO!HVQ^O,59OOOQU,59O,59OO!HgQ?MxO,59OO%[Q^O,59OO!JrQ^O'#H_OOQU'#H`'#H`OOQU'#Ha'#HaO`Q^O,5=wO!KYQWO,5=wO`Q^O,5=}O`Q^O,5>PO!K_QWO,5>RO`Q^O,5>TO!KdQWO,5>WO!KiQ^O,5>^OOQU,5>d,5>dO%[Q^O,5>dO9kQ?MxO,5>fOOQU,5>h,5>hO# sQWO,5>hOOQU,5>j,5>jO# sQWO,5>jOOQU,5>l,5>lO#!aQ`O'#D[O%[Q^O'#JnO#!kQ`O'#JnO##YQ`O'#DjO##kQ`O'#DjO#%|Q^O'#DjO#&TQWO'#JmO#&]QWO,5:TO#&bQWO'#EqO#&pQWO'#J|O#&xQWO,5;[O#&}Q`O'#DjO#'[Q`O'#EVOOQ?Mr,5:o,5:oO%[Q^O,5:oO#'cQWO,5:oO>wQWO,5;VO!BlQ`O,5;VO!BtQ7[O,5;VO:YQ7[O,5;VO#'kQWO,5@YO#'pQ(CWO,5:sOOQO-E<a-E<aO#(vQ?NQO,5;OOCuQ`O,5:rO#)QQ`O,5:rOCuQ`O,5;OO!BaQ?MxO,5:rOOQ?Mp'#Eg'#EgOOQO,5;O,5;OO%[Q^O,5;OO#)_Q?MxO,5;OO#)jQ?MxO,5;OO!BlQ`O,5:rOOQO,5;U,5;UO#)xQ?MxO,5;OPOOO'#IW'#IWP#*^O#@ItO,58{POOO,58{,58{OOOO-E<W-E<WOOQ?Mr1G.o1G.oOOOO-E<X-E<XO#*iQpO,59zOOOO-E<Z-E<ZOOQ?Mr1G/d1G/dO#*nQrO,5>xO+}Q^O,5>xOOQO,5?O,5?OO#*xQ^O'#I^OOQO-E<[-E<[O#+VQWO,5@WO#+_QrO,5@WO#+fQWO,5@fOOQ?Mr1G/j1G/jO%[Q^O,5@gO#+nQWO'#IdOOQO-E<b-E<bO#+fQWO,5@fOOQ?Mp1G0u1G0uOOQ?Mv1G/u1G/uOOQ?Mv1G0Y1G0YO%[Q^O,5@dO#,SQ?MxO,5@dO#,eQ?MxO,5@dO#,lQWO,5@cO9ZQWO,5@cO#,tQWO,5@cO#-SQWO'#IgO#,lQWO,5@cOOQ?Mp1G0t1G0tO!*VQ`O,5:uO!*bQ`O,5:uOOQO,5:w,5:wO#-tQWO,5:wO#-|Q7[O1G2tO9aQWO1G2tOOQ?Mr1G0r1G0rO#.[Q?NdO1G0rO#/aQ?NbO,5;SOOQ?Mr'#GS'#GSO#/}Q?NdO'#JeO!$hQ^O1G0rO#2VQ7[O'#JoO#2aQWO,5:`O#2fQrO'#JpO%[Q^O'#JpO#2pQWO,5:eOOQ?Mr'#D['#D[OOQ?Mr1G0{1G0{O%[Q^O1G0{OOQ?Mr1G1e1G1eO#2uQWO1G0{O#5^Q?NdO1G0|O#5eQ?NdO1G0|O#8OQ?NdO1G0|O#8VQ?NdO1G0|O#:aQ?NdO1G0|O#:wQ?NdO1G0|O#=qQ?NdO1G0|O#=xQ?NdO1G0|O#@]Q?NdO1G0|O#@jQ?NdO1G0|O#BhQ?NdO1G0|O#EhQ07bO'#ChO#GfQ07bO1G1_O#GmQ07bO'#JkO!,sQWO1G1eO#G}Q?NdO,5?UOOQ?Mp-E<h-E<hO#HqQ?NdO1G0|OOQ?Mr1G0|1G0|O#J|Q?NdO1G1bO#KpQ&jO,5<UO#KxQ&jO,5<VO#LQQ&jO'#FmO#LiQWO'#FlOOQO'#KQ'#KQOOQO'#Ih'#IhO#LnQ&jO1G1lOOQ?Mr1G1l1G1lOOOS1G1w1G1wO#MPQ07bO'#JjO#MZQWO,5<`O!*mQ^O,5<`OOOS-E<g-E<gOOQ?Mr1G1j1G1jO#M`Q`O'#KPOOQ?Mr,5<b,5<bO#MhQ`O,5<bOOQ?Mr,59e,59eO!&kQ7[O'#DPOOOO'#I['#I[O#MmO!0LbO,59iOOQ?Mr,59i,59iO%[Q^O1G1}O!7yQWO'#IlO#MxQ7[O,5<vOOQ?Mr,5<s,5<sO!(ZQ7[O'#IoO#NhQ7[O,5=SO!(ZQ7[O'#IqO$ ZQ7[O,5=UO!&kQ7[O,5=WOOQO1G2P1G2PO$ eQpO'#CqO$ xQ$ISO'#EoO$!wQ`O'#G^O$#eQpO,5<oO$#lQWO'#KTO9ZQWO'#KTO$#zQWO,5<qO!(ZQ7[O,5<pO$$PQWO'#GVO$$bQWO,5<pO$$gQpO'#GSO$$tQpO'#KUO$%OQWO'#KUO!&kQ7[O'#KUO$%TQWO,5<tO$%YQ`O'#G_O!6SQ`O'#G_O$%kQWO'#GaO$%pQWO'#GcO!3mQWO'#GfO$%uQ?MxO'#InO$&QQ`O,5<xOOQ?Mv,5<x,5<xO$&XQ`O'#G_O$&gQ`O'#G`O$&oQ`O'#G`O$&tQ7[O,5=SO$'UQ7[O,5=UOOQ?Mr,5=X,5=XO!(ZQ7[O,5@OO!(ZQ7[O,5@OO$'fQWO'#IsO$'qQWO,5?}O$'yQWO,59`O$(jQ7[O,59qOOQ?Mr,59q,59qO$)]Q7[O,5<gO$*OQ7[O,5<iO@iQWO,5<kOOQ?Mr,5<l,5<lO$*YQWO,5<rO$*_Q7[O,5<wO$*oQWO'#JwO!$hQ^O1G2OO$*tQWO1G2OO9ZQWO'#JzO9ZQWO'#EqO%[Q^O'#EqO9ZQWO'#IuO$*yQ?MxO,5@tOOQU1G2x1G2xOOQU1G4Y1G4YOOQ?Mr1G/y1G/yO!,pQWO1G/yOOQ?Mr1G/w1G/wO$-OQ?NdO1G0UOOQU1G2t1G2tO!&kQ7[O1G2tO%[Q^O1G2tO#.PQWO1G2tO$/SQ7[O'#EhOOQ?Mp,5?|,5?|O$/^Q?MxO,5?|OOQU1G.t1G.tO!BaQ?MxO1G.tO!BlQ`O1G.tO!BtQ7[O1G.tO$/oQWO1G0rO$/tQWO'#ChO$0PQWO'#K^O$0XQWO,5=vO$0^QWO'#K^O$0cQWO'#K^O$0qQWO'#I{O$1PQWO,5@wO$1XQrO1G1gOOQ?Mr1G1i1G1iO9aQWO1G3aO@iQWO1G3aO$1`QWO1G3aO$1eQWO1G3aOOQU1G3a1G3aO!DrQWO1G3PO!&kQ7[O1G2|O$1jQWO1G2|OOQU1G2}1G2}O!&kQ7[O1G2}O$1oQWO1G2}O$1wQ`O'#G{OOQU1G3P1G3PO!6SQ`O'#IwO!DwQpO1G3SOOQU1G3S1G3SOOQU,5=m,5=mO$2PQ7[O,5=oO9aQWO,5=oO$%pQWO,5=qO9UQWO,5=qO!BlQ`O,5=qO!BtQ7[O,5=qO:YQ7[O,5=qO$2_QWO'#K[O$2jQWO,5=rOOQU1G.j1G.jO$2oQ?MxO1G.jO@iQWO1G.jO$2zQWO1G.jO9kQ?MxO1G.jO$5PQrO,5@yO$5aQWO,5@yO9ZQWO,5@yO$5lQ^O,5=yO$5sQWO,5=yOOQU1G3c1G3cO`Q^O1G3cOOQU1G3i1G3iOOQU1G3k1G3kO>rQWO1G3mO$5xQ^O1G3oO$9|Q^O'#HnOOQU1G3r1G3rO$:ZQWO'#HtO>wQWO'#HvOOQU1G3x1G3xO$:cQ^O1G3xO9kQ?MxO1G4OOOQU1G4Q1G4QOOQ?Mp'#GZ'#GZO9kQ?MxO1G4SO9kQ?MxO1G4UO$>jQWO,5@YO!*mQ^O,5;]O9ZQWO,5;]O>wQWO,5:UO!*mQ^O,5:UO!BlQ`O,5:UO$>oQ07bO,5:UOOQO,5;],5;]O$>yQ`O'#I_O$?aQWO,5@XOOQ?Mr1G/o1G/oO$?iQ`O'#IeO$?sQWO,5@hOOQ?Mp1G0v1G0vO##kQ`O,5:UOOQO'#Ib'#IbO$?{Q`O,5:qOOQ?Mv,5:q,5:qO#'fQWO1G0ZOOQ?Mr1G0Z1G0ZO%[Q^O1G0ZOOQ?Mr1G0q1G0qO>wQWO1G0qO!BlQ`O1G0qO!BtQ7[O1G0qOOQ?Mp1G5t1G5tO!BaQ?MxO1G0^OOQO1G0j1G0jO%[Q^O1G0jO$@SQ?MxO1G0jO$@_Q?MxO1G0jO!BlQ`O1G0^OCuQ`O1G0^O$@mQ?MxO1G0jOOQO1G0^1G0^O$ARQ?NdO1G0jPOOO-E<U-E<UPOOO1G.g1G.gOOOO1G/f1G/fO$A]QpO,5<fO$AeQrO1G4dOOQO1G4j1G4jO%[Q^O,5>xO$AoQWO1G5rO$AwQWO1G6QO$BPQrO1G6RO9ZQWO,5?OO$BZQ?NdO1G6OO%[Q^O1G6OO$BkQ?MxO1G6OO$B|QWO1G5}O$B|QWO1G5}O9ZQWO1G5}O$CUQWO,5?RO9ZQWO,5?ROOQO,5?R,5?RO$CjQWO,5?RO$*oQWO,5?ROOQO-E<e-E<eOOQO1G0a1G0aOOQO1G0c1G0cO!,sQWO1G0cOOQU7+(`7+(`O!&kQ7[O7+(`O%[Q^O7+(`O$CxQWO7+(`O$DTQ7[O7+(`O$DcQ?NdO,5=SO$FnQ?NdO,5=UO$HyQ?NdO,5=SO$K[Q?NdO,5=UO$MmQ?NdO,59qO% uQ?NdO,5<gO%$QQ?NdO,5<iO%&]Q?NdO,5<wOOQ?Mr7+&^7+&^O%(nQ?NdO7+&^O%)bQ7[O'#I`O%)lQWO,5@ZOOQ?Mr1G/z1G/zO%)tQ^O'#IaO%*RQWO,5@[O%*ZQrO,5@[OOQ?Mr1G0P1G0PO%*eQWO7+&gOOQ?Mr7+&g7+&gO%*jQ07bO,5:fO%[Q^O7+&yO%*tQ07bO,5:_O%+RQ07bO,5:jO%+]Q07bO,5:lOOQ?Mr7+'P7+'POOQO1G1p1G1pOOQO1G1q1G1qO%+gQtO,5<XO!*mQ^O,5<WOOQO-E<f-E<fOOQ?Mr7+'W7+'WOOOS7+'c7+'cOOOS1G1z1G1zO%+rQWO1G1zOOQ?Mr1G1|1G1|O%+wQpO,59kOOOO-E<Y-E<YOOQ?Mr1G/T1G/TO%,OQ?NdO7+'iOOQ?Mr,5?W,5?WO%,rQpO,5?WOOQ?Mr1G2b1G2bP!&kQ7[O'#IlPOQ?Mr-E<j-E<jO%-bQ7[O,5?ZOOQ?Mr-E<m-E<mO%.TQ7[O,5?]OOQ?Mr-E<o-E<oO%._QpO1G2rO%.fQpO'#CqO%.|Q7[O'#JzO%/TQ^O'#EqOOQ?Mr1G2Z1G2ZO%/_QWO'#IkO%/sQWO,5@oO%/sQWO,5@oO%/{QWO,5@oO%0WQWO,5@oOOQO1G2]1G2]O%0fQ7[O1G2[O!(ZQ7[O1G2[O%0vQ$ISO'#ImO%1TQWO,5@pO!&kQ7[O,5@pO%1]QpO,5@pOOQ?Mr1G2`1G2`OOQ?Mp,5<y,5<yOOQ?Mp,5<z,5<zO$*oQWO,5<zOCfQWO,5<zO!BlQ`O,5<yOOQO'#Gb'#GbO%1gQWO,5<{OOQ?Mp,5<},5<}O$*oQWO,5=QOOQO,5?Y,5?YOOQO-E<l-E<lOOQ?Mv1G2d1G2dO!6SQ`O,5<yO%1oQWO,5<zO$%kQWO,5<{O!6SQ`O,5<zO!(ZQ7[O'#IoO%2cQ7[O1G2nO!(ZQ7[O'#IqO%3UQ7[O1G2pO%3`Q7[O1G5jO%3jQ7[O1G5jOOQO,5?_,5?_OOQO-E<q-E<qOOQO1G.z1G.zO!9jQ`O,59sO%[Q^O,59sO%3wQWO1G2VO!(ZQ7[O1G2^O%3|Q?NdO7+'jOOQ?Mr7+'j7+'jO!$hQ^O7+'jO%4pQWO,5;]OOQ?Mp,5?a,5?aOOQ?Mp-E<s-E<sOOQ?Mr7+%e7+%eO%4uQpO'#KVO#'fQWO7+(`O%5PQrO7+(`O$C{QWO7+(`O%5WQ?NbO'#ChO%5kQ?NbO,5=OO%6]QWO,5=OOOQ?Mp1G5h1G5hOOQU7+$`7+$`O!BaQ?MxO7+$`O!BlQ`O7+$`O!$hQ^O7+&^O%6bQWO'#IzO%6yQWO,5@xOOQO1G3b1G3bO9aQWO,5@xO%6yQWO,5@xO%7RQWO,5@xOOQO,5?g,5?gOOQO-E<y-E<yOOQ?Mr7+'R7+'RO%7WQWO7+({O9kQ?MxO7+({O9aQWO7+({O@iQWO7+({OOQU7+(k7+(kO%7]Q?NbO7+(hO!&kQ7[O7+(hO%7gQpO7+(iOOQU7+(i7+(iO!&kQ7[O7+(iO%7nQWO'#KZO%7yQWO,5=gOOQO,5?c,5?cOOQO-E<u-E<uOOQU7+(n7+(nO%9YQ`O'#HUOOQU1G3Z1G3ZO!&kQ7[O1G3ZO%[Q^O1G3ZO%9aQWO1G3ZO%9lQ7[O1G3ZO9kQ?MxO1G3]O$%pQWO1G3]O9UQWO1G3]O!BlQ`O1G3]O!BtQ7[O1G3]O%9zQWO'#IyO%:`QWO,5@vO%:hQ`O,5@vOOQ?Mp1G3^1G3^OOQU7+$U7+$UO@iQWO7+$UO9kQ?MxO7+$UO%:sQWO7+$UO%[Q^O1G6eO%[Q^O1G6fO%:xQ?MxO1G6eO%;SQ^O1G3eO%;ZQWO1G3eO%;`Q^O1G3eOOQU7+(}7+(}O9kQ?MxO7+)XO`Q^O7+)ZOOQU'#Ka'#KaOOQU'#I|'#I|O%;gQ^O,5>YOOQU,5>Y,5>YO%[Q^O'#HoO%;tQWO'#HqOOQU,5>`,5>`O9ZQWO,5>`OOQU,5>b,5>bOOQU7+)d7+)dOOQU7+)j7+)jOOQU7+)n7+)nOOQU7+)p7+)pO%;yQ`O1G5tO%<_Q07bO1G0wO%<iQWO1G0wOOQO1G/p1G/pO%<tQ07bO1G/pO>wQWO1G/pO!*mQ^O'#DjOOQO,5>y,5>yOOQO-E<]-E<]OOQO,5?P,5?POOQO-E<c-E<cO!BlQ`O1G/pOOQO-E<`-E<`OOQ?Mv1G0]1G0]OOQ?Mr7+%u7+%uO#'fQWO7+%uOOQ?Mr7+&]7+&]O>wQWO7+&]O!BlQ`O7+&]OOQO7+%x7+%xO$ARQ?NdO7+&UOOQO7+&U7+&UO%[Q^O7+&UO%=OQ?MxO7+&UO!BaQ?MxO7+%xO!BlQ`O7+%xO%=ZQ?MxO7+&UO%=iQ?NdO7++jO%[Q^O7++jO%=yQWO7++iO%=yQWO7++iOOQO1G4m1G4mO9ZQWO1G4mO%>RQWO1G4mOOQO7+%}7+%}O#'fQWO<<KzO%5PQrO<<KzO%>aQWO<<KzOOQU<<Kz<<KzO!&kQ7[O<<KzO%[Q^O<<KzO%>iQWO<<KzO%>tQ?NdO,5?ZO%APQ?NdO,5?]O%C[Q?NdO1G2[O%EmQ?NdO1G2nO%GxQ?NdO1G2pO%JTQ7[O,5>zOOQO-E<^-E<^O%J_QrO,5>{O%[Q^O,5>{OOQO-E<_-E<_O%JiQWO1G5vOOQ?Mr<<JR<<JRO%JqQ07bO1G0rO%L{Q07bO1G0|O%MSQ07bO1G0|O& WQ07bO1G0|O& _Q07bO1G0|O&#SQ07bO1G0|O&#jQ07bO1G0|O&%}Q07bO1G0|O&&UQ07bO1G0|O&(SQ07bO1G0|O&(aQ07bO1G0|O&*_Q07bO1G0|O&*rQ?NdO<<JeO&+wQ07bO1G0|O&-mQ07bO'#JeO&/pQ07bO1G1bO&/}Q07bO1G0UO!*mQ^O'#FoOOQO'#KR'#KROOQO1G1s1G1sO&0XQWO1G1rO&0^Q07bO,5?UOOOS7+'f7+'fOOOO1G/V1G/VOOQ?Mr1G4r1G4rO!(ZQ7[O7+(^O&2nQrO'#ChO&2xQWO,5?VO9ZQWO,5?VOOQO-E<i-E<iO&3WQWO1G6ZO&3WQWO1G6ZO&3`QWO1G6ZO&3kQ7[O7+'vO&3{QpO,5?XO&4VQWO,5?XO!&kQ7[O,5?XOOQO-E<k-E<kO&4[QpO1G6[O&4fQWO1G6[OOQ?Mp1G2f1G2fO$*oQWO1G2fOOQ?Mp1G2e1G2eO&4nQWO1G2gO!&kQ7[O1G2gOOQ?Mp1G2l1G2lO!BlQ`O1G2eOCfQWO1G2fO&4sQWO1G2gO&4{QWO1G2fO&5oQ7[O,5?ZOOQ?Mr-E<n-E<nO&6bQ7[O,5?]OOQ?Mr-E<p-E<pO!(ZQ7[O7++UOOQ?Mr1G/_1G/_O&6lQWO1G/_OOQ?Mr7+'q7+'qO&6qQ7[O7+'xO&7RQ?NdO<<KUOOQ?Mr<<KU<<KUO&7uQWO1G0wO!&kQ7[O'#ItO&7zQWO,5@qO!&kQ7[O1G2jOOQU<<Gz<<GzO!BaQ?MxO<<GzO&8SQ?NdO<<IxOOQ?Mr<<Ix<<IxOOQO,5?f,5?fO&8vQWO,5?fO&8{QWO,5?fOOQO-E<x-E<xO&9ZQWO1G6dO&9ZQWO1G6dO9aQWO1G6dO@iQWO<<LgOOQU<<Lg<<LgO&9cQWO<<LgO9kQ?MxO<<LgOOQU<<LS<<LSO%7]Q?NbO<<LSOOQU<<LT<<LTO%7gQpO<<LTO&9hQ`O'#IvO&9sQWO,5@uO!*mQ^O,5@uOOQU1G3R1G3RO%/TQ^O'#JnOOQO'#Ix'#IxO9kQ?MxO'#IxO&9{Q`O,5=pOOQU,5=p,5=pO&:SQ`O'#EdO&:hQWO7+(uO&:mQWO7+(uOOQU7+(u7+(uO!&kQ7[O7+(uO%[Q^O7+(uO&:uQWO7+(uOOQU7+(w7+(wO9kQ?MxO7+(wO$%pQWO7+(wO9UQWO7+(wO!BlQ`O7+(wO&;QQWO,5?eOOQO-E<w-E<wOOQO'#HX'#HXO&;]QWO1G6bO9kQ?MxO<<GpOOQU<<Gp<<GpO@iQWO<<GpO&;eQWO7+,PO&;jQWO7+,QO%[Q^O7+,PO%[Q^O7+,QOOQU7+)P7+)PO&;oQWO7+)PO&;tQ^O7+)PO&;{QWO7+)POOQU<<Ls<<LsOOQU<<Lu<<LuOOQU-E<z-E<zOOQU1G3t1G3tO&<QQWO,5>ZOOQU,5>],5>]O&<VQWO1G3zO9ZQWO7+&cO!*mQ^O7+&cOOQO7+%[7+%[O&<[Q07bO1G6RO>wQWO7+%[OOQ?Mr<<Ia<<IaOOQ?Mr<<Iw<<IwO>wQWO<<IwOOQO<<Ip<<IpO$ARQ?NdO<<IpO%[Q^O<<IpOOQO<<Id<<IdO!BaQ?MxO<<IdO&<fQ?MxO<<IpO&<qQ?NdO<= UO&=RQWO<= TOOQO7+*X7+*XO9ZQWO7+*XOOQUANAfANAfO&=ZQWOANAfO!&kQ7[OANAfO#'fQWOANAfO%5PQrOANAfO%[Q^OANAfO&=cQ?NdO7+'vO&?tQ?NdO,5?ZO&BPQ?NdO,5?]O&D[Q?NdO7+'xO&FmQrO1G4gO&FwQ07bO7+&^O&H{Q07bO,5=SO&KSQ07bO,5=UO&KdQ07bO,5=SO&KtQ07bO,5=UO&LUQ07bO,59qO&NXQ07bO,5<gO'![Q07bO,5<iO'$_Q07bO,5<wO'&TQ07bO7+'iO'&bQ07bO7+'jO'&oQWO,5<ZOOQO7+'^7+'^O'&tQ7[O<<KxOOQO1G4q1G4qO'&{QWO1G4qO''WQWO1G4qO''fQWO7++uO''fQWO7++uO!&kQ7[O1G4sO''nQpO1G4sO''xQWO7++vOOQ?Mp7+(Q7+(QO$*oQWO7+(RO'(QQpO7+(ROOQ?Mp7+(P7+(PO$*oQWO7+(QO'(XQWO7+(RO!&kQ7[O7+(ROCfQWO7+(QO'(^Q7[O<<NpOOQ?Mr7+$y7+$yO'(hQpO,5?`OOQO-E<r-E<rO'(rQ?NbO7+(UOOQUAN=fAN=fO9aQWO1G5QOOQO1G5Q1G5QO')SQWO1G5QO')XQWO7+,OO')XQWO7+,OO9kQ?MxOANBRO@iQWOANBROOQUANBRANBROOQUANAnANAnOOQUANAoANAoO')aQWO,5?bOOQO-E<t-E<tO')lQ07bO1G6aOOQO,5?d,5?dOOQO-E<v-E<vOOQU1G3[1G3[O%/TQ^O,5<{OOQU<<La<<LaO!&kQ7[O<<LaO&:hQWO<<LaO')vQWO<<LaO%[Q^O<<LaOOQU<<Lc<<LcO9kQ?MxO<<LcO$%pQWO<<LcO9UQWO<<LcO'*OQ`O1G5PO'*ZQWO7++|OOQUAN=[AN=[O9kQ?MxOAN=[OOQU<= k<= kOOQU<= l<= lO'*cQWO<= kO'*hQWO<= lOOQU<<Lk<<LkO'*mQWO<<LkO'*rQ^O<<LkOOQU1G3u1G3uO>wQWO7+)fO'*yQWO<<I}O'+UQ07bO<<I}OOQO<<Hv<<HvOOQ?MrAN?cAN?cOOQOAN?[AN?[O$ARQ?NdOAN?[OOQOAN?OAN?OO%[Q^OAN?[OOQO<<Ms<<MsOOQUG27QG27QO!&kQ7[OG27QO#'fQWOG27QO'+`QWOG27QO%5PQrOG27QO'+hQ07bO<<JeO'+uQ07bO1G2[O'-kQ07bO,5?ZO'/nQ07bO,5?]O'1qQ07bO1G2nO'3tQ07bO1G2pO'5wQ07bO<<KUO'6UQ07bO<<IxOOQO1G1u1G1uO!(ZQ7[OANAdOOQO7+*]7+*]O'6cQWO7+*]O'6nQWO<= aO'6vQpO7+*_OOQ?Mp<<Km<<KmO$*oQWO<<KmOOQ?Mp<<Kl<<KlO'7QQpO<<KmO$*oQWO<<KlOOQO7+*l7+*lO9aQWO7+*lO'7XQWO<= jOOQUG27mG27mO9kQ?MxOG27mO!*mQ^O1G4|O'7aQWO7++{O&:hQWOANA{OOQUANA{ANA{O!&kQ7[OANA{O'7iQWOANA{OOQUANA}ANA}O9kQ?MxOANA}O$%pQWOANA}OOQO'#HY'#HYOOQO7+*k7+*kOOQUG22vG22vOOQUANEVANEVOOQUANEWANEWOOQUANBVANBVO'7qQWOANBVOOQU<<MQ<<MQO!*mQ^OAN?iOOQOG24vG24vO$ARQ?NdOG24vO#'fQWOLD,lOOQULD,lLD,lO!&kQ7[OLD,lO'7vQWOLD,lO'8OQ07bO7+'vO'9tQ07bO,5?ZO';wQ07bO,5?]O'=zQ07bO7+'xO'?pQ7[OG27OOOQO<<Mw<<MwOOQ?MpANAXANAXO$*oQWOANAXOOQ?MpANAWANAWOOQO<<NW<<NWOOQULD-XLD-XO'@QQ07bO7+*hOOQUG27gG27gO&:hQWOG27gO!&kQ7[OG27gOOQUG27iG27iO9kQ?MxOG27iOOQUG27qG27qO'@[Q07bOG25TOOQOLD*bLD*bOOQU!$(!W!$(!WO#'fQWO!$(!WO!&kQ7[O!$(!WO'@fQ?NdOG27OOOQ?MpG26sG26sOOQULD-RLD-RO&:hQWOLD-ROOQULD-TLD-TOOQU!)9Er!)9ErO#'fQWO!)9ErOOQU!$(!m!$(!mOOQU!.K;^!.K;^O'BwQ07bOG27OO!*mQ^O'#DzO1PQWO'#EXO'DmQrO'#JjO'DtQMnO'#DsO'D{Q^O'#EOO'ESQrO'#ChO'GjQrO'#ChO!*mQ^O'#EQO'GzQ^O,5;WO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O,5;bO!*mQ^O'#IjO'I}QWO,5<fO'JVQ7[O,5;bO'KpQ7[O,5;bO!*mQ^O,5;vO!&kQ7[O'#GhO'JVQ7[O'#GhO!&kQ7[O'#GjO'JVQ7[O'#GjO1SQWO'#DVO1SQWO'#DVO!&kQ7[O'#F{O'JVQ7[O'#F{O!&kQ7[O'#F}O'JVQ7[O'#F}O!&kQ7[O'#G]O'JVQ7[O'#G]O!*mQ^O,5:jO'KwQ`O'#D[O!*mQ^O,5@gO'GzQ^O1G0rO'LRQ07bO'#ChO!*mQ^O1G1}O!&kQ7[O'#IoO'JVQ7[O'#IoO!&kQ7[O'#IqO'JVQ7[O'#IqO'L]QpO'#CqO!&kQ7[O,5<pO'JVQ7[O,5<pO'GzQ^O1G2OO!*mQ^O7+&yO!&kQ7[O1G2[O'JVQ7[O1G2[O!&kQ7[O'#IoO'JVQ7[O'#IoO!&kQ7[O'#IqO'JVQ7[O'#IqO!&kQ7[O1G2^O'JVQ7[O1G2^O'GzQ^O7+'jO'GzQ^O7+&^O!&kQ7[OANAdO'JVQ7[OANAdO'LpQWO'#ElO'LuQWO'#ElO'L}QWO'#F[O'MSQWO'#EvO'MXQWO'#J{O'MdQWO'#JyO'MoQWO,5;WO'MtQ7[O,5<cO'M{QWO'#GUO'NQQWO'#GUO'NVQWO,5<dO'N_QWO,5;WO'NgQ07bO1G1_O'NnQWO,5<pO'NsQWO,5<pO'NxQWO,5<rO'N}QWO,5<rO( SQWO1G2OO( XQWO1G0rO( ^Q7[O<<KxO( eQ7[O<<KxO7hQ7[O'#FyO9UQWO'#FxOAdQWO'#EkO!*mQ^O,5;sO!3mQWO'#GUO!3mQWO'#GUO!3mQWO'#GWO!3mQWO'#GWO!(ZQ7[O7+(^O!(ZQ7[O7+(^O%._QpO1G2rO%._QpO1G2rO!&kQ7[O,5=WO!&kQ7[O,5=W",
  stateData: "(!i~O'uOS'vOSSOS'wRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!lZO!oYO!pYO!qYO!svO!uwO!xxO!|]O#t!PO$U|O%c}O%e!QO%g!OO%h!OO%i!OO%l!RO%n!SO%q!TO%r!TO%t!UO&Q!WO&W!XO&Y!YO&[!ZO&^![O&a!]O&g!^O&m!_O&o!`O&q!aO&s!bO&u!cO'|SO(OTO(RUO(YVO(h[O(viO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO'|!dO(OTO(RUO(YVO(h[O(viO~O`!wOo!nO!P!oO!_!yO!`!vO!a!vO!|:lO#Q!pO#R!pO#S!xO#T!pO#U!pO#X!zO#Y!zO'}!lO(OTO(RUO(]!mO(h!sO~O'w!{O~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!i[X!j[X!l[X!p[X#][X#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X's[X(Y[X(j[X(q[X(r[X~O!d$}X~P(qO^!}O(O#PO(P!}O(Q#PO~O^#QO(Q#PO(R#PO(S#QO~Ot#SO!R#TO(Z#TO([#VO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO'|:pO(OTO(RUO(YVO(h[O(viO~O!X#ZO!Y#WO!V(`P!V(nP~P+}O!Z#cO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO(OTO(RUO(YVO(h[O(viO~Ol#mO!X#iO!|]O#f#lO#g#iO'|:qO!k(kP~P.iO!l#oO'|#nO~O!x#sO!|]O%c#tO~O#h#uO~O!d#vO#h#uO~OP$^OZ$eOn$RO|#zO}#{O!P#|O!Y$bO!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO#z$ZO(YVO(j$[O(q#}O(r$OO~O`(^X's(^X'q(^X!k(^X!V(^X![(^X%d(^X!d(^X~P1qO#]$fO$P$fOP(_XZ(_Xn(_X|(_X}(_X!P(_X!Y(_X!i(_X!l(_X!p(_X#k(_X#l(_X#m(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#u(_X#w(_X#y(_X#z(_X(Y(_X(j(_X(q(_X(r(_X![(_X%d(_X~O`(_X!j(_X's(_X'q(_X!V(_X!k(_Xr(_X!d(_X~P4XO#]$fO~O$Z$hO$]$gO$d$mO~ORfO![$nO$g$oO$i$qO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz%[O!P$|O![$}O!f%aO!l$yO#g%bO$U%_O$p%]O$r%^O$u%`O'|$sO(OTO(RUO(Y$vO(q%OO(r%QOf(VP~O!l%cO~O!P%fO![%gO'|%eO~O!d%kO~O`%lO's%lO~O|%pO~P%[O'}!lO~P%[O%i%tO~P%[Og%WO!l%cO'|%eO'}!lO~Od%{O!l%cO'|%eO~O#s$TO~O|&QO![%}O!l&PO%e&TO'|%eO'}!lO(OTO(RUO_)PP~O!x#sO~O%n&VO!P({X![({X'|({X~O'|&WO~O!u&]O#t!PO%e!QO%g!OO%h!OO%i!OO%l!RO%n!SO%q!TO%r!TO~Oc&bOd&aO!x&_O%c&`O%v&^O~P<POc&eOdyO![&dO!u&]O!xxO!|]O#t!PO%c}O%g!OO%h!OO%i!OO%l!RO%n!SO%q!TO%r!TO%t!UO~Oa&hO#]&kO%e&fO'}!lO~P=UO!l&lO!u&pO~O!l#oO~O![XO~O`%lO'r&xO's%lO~O`%lO'r&{O's%lO~O`%lO'r&}O's%lO~O'q[X!V[Xr[X!k[X&U[X![[X%d[X!d[X~P(qO!_'[O!`'TO!a'TO'}!lO(OTO(RUO~Oo'RO!P'QO!X'UO(]'PO!Z(aP!Z(pP~P@]Oj'_O![']O'|%eO~Od'dO!l%cO'|%eO~O|&QO!l&PO~Oo!nO!P!oO!|:lO#Q!pO#R!pO#T!pO#U!pO'}!lO(OTO(RUO(]!mO(h!sO~O!_'jO!`'iO!a'iO#S!pO#X'kO#Y'kO~PAwO`%lOg%WO!d#vO!l%cO's%lO(j'mO~O!p'qO#]'oO~PCVOo!nO!P!oO(OTO(RUO(]!mO(h!sO~O![XOo(fX!P(fX!_(fX!`(fX!a(fX!|(fX#Q(fX#R(fX#S(fX#T(fX#U(fX#X(fX#Y(fX'}(fX(O(fX(R(fX(](fX(h(fX~O!`'iO!a'iO'}!lO~PCuO'x'uO'y'uO'z'wO~O^!}O(O'yO(P!}O(Q'yO~O^#QO(Q'yO(R'yO(S#QO~Ot#SO!R#TO(Z#TO(['}O~O!X(PO!V'QX!V'WX!Y'QX!Y'WX~P+}O!Y(RO!V(`X~OP$^OZ$eOn$RO|#zO}#{O!P#|O!Y(RO!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO#z$ZO(YVO(j$[O(q#}O(r$OO~O!V(`X~PGiO!V(WO~O!V(mX!Y(mX!d(mX!k(mX(j(mX~O#](mX#h#aX!Z(mX~PIoO#](XO!V(oX!Y(oX~O!Y(YO!V(nX~O!V(]O~O#]$fO~PIoO!Z(^O~P`O|#zO}#{O!P#|O!j#xO!l#yO(YVOP!naZ!nan!na!Y!na!i!na!p!na#k!na#l!na#m!na#n!na#o!na#p!na#q!na#r!na#s!na#u!na#w!na#y!na#z!na(j!na(q!na(r!na~O`!na's!na'q!na!V!na!k!nar!na![!na%d!na!d!na~PKVO!k(_O~O!d#vO#](`O(j'mO!Y(lX`(lX's(lX~O!k(lX~PMuO!P%fO![%gO!|]O#f(eO#g(dO'|%eO~O!Y(fO!k(kX~O!k(hO~O!P%fO![%gO#g(dO'|%eO~OP(_XZ(_Xn(_X|(_X}(_X!P(_X!Y(_X!i(_X!j(_X!l(_X!p(_X#k(_X#l(_X#m(_X#n(_X#o(_X#p(_X#q(_X#r(_X#s(_X#u(_X#w(_X#y(_X#z(_X(Y(_X(j(_X(q(_X(r(_X~O!d#vO!k(_X~P! cO|(iO}(jO!j#xO!l#yO!|!{a!P!{a~O!x!{a%c!{a![!{a#f!{a#g!{a'|!{a~P!#gO!x(nO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!lZO!oYO!pYO!qYO!svO!u!gO!x!hO$U!kO'|!dO(OTO(RUO(YVO(h[O(viO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;YO!P$|O![$}O!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O'|(rO(OTO(RUO(Y$vO(q%OO(r%QO~O#h(tO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz%[O!P$|O![$}O!f%aO!l$yO#g%bO$U%_O$p%]O$r%^O$u%`O'|(rO(OTO(RUO(Y$vO(q%OO(r%QO~Of(cP~P!(ZO!X(xO!k(dP~P%[O(](zO(h[O~O!P(|O!l#yO(](zO(h[O~OP:kOQ:kORfOc<fOd!iOlkOn:kOokOpkOvkOx:kOz:kO!PWO!TkO!UkO![!eO!f:nO!lZO!o:kO!p:kO!q:kO!s:oO!u:rO!x!hO$U!kO'|)[O(OTO(RUO(YVO(h[O(v<dO~O})_O!l#yO~O!Y$bO`$na's$na'q$na!k$na!V$na![$na%d$na!d$na~O#t)cO~P!&kO|)fO!d)eO![$[X$X$[X$Z$[X$]$[X$d$[X~O!d)eO![(sX$X(sX$Z(sX$](sX$d(sX~O|)fO~P!.VO|)fO![(sX$X(sX$Z(sX$](sX$d(sX~O![)hO$X)lO$Z)gO$])gO$d)mO~O!X)pO~P!*mO$Z$hO$]$gO$d)tO~Oj$vX|$vX!P$vX!j$vX(q$vX(r$vX~OfiXf$vXjiX!YiX#]iX~P!/{Oo)vO~Ot)wO(Z)xO([)zO~Oj*TO|)|O!P)}O(q%OO(r%QO~Of){O~P!1UOf*UO~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;YO!P*WO![*XO!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O(OTO(RUO(Y$vO(q%OO(r%QO~O!X*[O'|*VO!k(wP~P!1sO#h*^O~O!l*_O~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;YO!P$|O![$}O!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O'|*aO(OTO(RUO(Y$vO(q%OO(r%QO~O!X*dO!V(xP~P!3rOn*pO!P*hO!_*nO!`*gO!a*gO!l*_O#X*oO%Z*jO'}!lO(]!mO~O!Z*mO~P!5gO!j#xOj(XX|(XX!P(XX(q(XX(r(XX!Y(XX#](XX~Of(XX#}(XX~P!6`Oj*uO#]*tOf(WX!Y(WX~O!Y*vOf(VX~O'|&WOf(VP~O!l*}O~O'|(rO~Ol+RO!P%fO!X#iO![%gO!|]O#f#lO#g#iO'|%eO!k(kP~O!d#vO#h+SO~O!P%fO!X+UO!Y(YO![%gO'|%eO!V(nP~Oo'XO!P+WO!X+VO(OTO(RUO(](zO~O!Z(pP~P!9ZO!Y+XO`(|X's(|X~OP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO#z$ZO(YVO(j$[O(q#}O(r$OO~O`!ga!Y!ga's!ga'q!ga!V!ga!k!gar!ga![!ga%d!ga!d!ga~P!:RO|#zO}#{O!P#|O!j#xO!l#yO(YVOP!raZ!ran!ra!Y!ra!i!ra!p!ra#k!ra#l!ra#m!ra#n!ra#o!ra#p!ra#q!ra#r!ra#s!ra#u!ra#w!ra#y!ra#z!ra(j!ra(q!ra(r!ra~O`!ra's!ra'q!ra!V!ra!k!rar!ra![!ra%d!ra!d!ra~P!<lO|#zO}#{O!P#|O!j#xO!l#yO(YVOP!taZ!tan!ta!Y!ta!i!ta!p!ta#k!ta#l!ta#m!ta#n!ta#o!ta#p!ta#q!ta#r!ta#s!ta#u!ta#w!ta#y!ta#z!ta(j!ta(q!ta(r!ta~O`!ta's!ta'q!ta!V!ta!k!tar!ta![!ta%d!ta!d!ta~P!?VOg%WOj+cO![']O%d+bO~O!d+eO`(UX![(UX's(UX!Y(UX~O`%lO![XO's%lO~Og%WO!l%cO~Og%WO!l%cO'|%eO~O!d#vO#h(tO~Oa+pO%e+qO'|+mO(OTO(RUO!Z)QP~O!Y+rO_)PX~OZ+vO~O_+wO~O![%}O'|%eO'}!lO_)PP~Og%WO#]+|O~Og%WOj,PO![$}O~O![,RO~O|,TO![XO~O%i%tO~O!x,YO~Od,_O~Oa,`O'|#nO(OTO(RUO!Z)OP~Od%{O~O%e!QO'|&WO~P=UOZ,eO_,dO~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!lZO!oYO!pYO!qYO!svO!xxO!|]O%c}O(OTO(RUO(YVO(h[O(viO~O![!eO!u!gO$U!kO'|!dO~P!FYO_,dO`%lO's%lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!lZO!oYO!pYO!qYO!svO!x!hO$U!kO'|!dO(OTO(RUO(YVO(h[O(viO~O`,jO!uwO#t!OO%g!OO%h!OO%i!OO~P!HrO!l&lO~O&W,pO~O![,rO~O&i,tO&k,uOP&faQ&faR&faX&fa`&fac&fad&fal&fan&fao&fap&fav&fax&faz&fa!P&fa!T&fa!U&fa![&fa!f&fa!l&fa!o&fa!p&fa!q&fa!s&fa!u&fa!x&fa!|&fa#t&fa$U&fa%c&fa%e&fa%g&fa%h&fa%i&fa%l&fa%n&fa%q&fa%r&fa%t&fa&Q&fa&W&fa&Y&fa&[&fa&^&fa&a&fa&g&fa&m&fa&o&fa&q&fa&s&fa&u&fa'q&fa'|&fa(O&fa(R&fa(Y&fa(h&fa(v&fa!Z&fa&_&faa&fa&d&fa~O'|,zO~Og!bX!Y!OX!Z!OX!d!OX!d!bX!l!bX#]!OX~O!Y!bX!Z!bX~P# xO!d-PO#]-OOg(bX!Y#eX!Y(bX!Z#eX!Z(bX!d(bX!l(bX~Og%WO!d-RO!l%cO!Y!^X!Z!^X~Oo!nO!P!oO(OTO(RUO(]!mO~OP:kOQ:kORfOc<fOd!iOlkOn:kOokOpkOvkOx:kOz:kO!PWO!TkO!UkO![!eO!f:nO!lZO!o:kO!p:kO!q:kO!s:oO!u:rO!x!hO$U!kO(OTO(RUO(YVO(h[O(v<dO~O'|;fO~P##|O!Y-VO!Z(aX~O!Z-XO~O!d-PO#]-OO!Y#eX!Z#eX~O!Y-YO!Z(pX~O!Z-[O~O!`-]O!a-]O'}!lO~P##kO!Z-`O~P'_Oj-cO![']O~O!V-hO~Oo!{a!_!{a!`!{a!a!{a#Q!{a#R!{a#S!{a#T!{a#U!{a#X!{a#Y!{a'}!{a(O!{a(R!{a(]!{a(h!{a~P!#gO!p-mO#]-kO~PCVO!`-oO!a-oO'}!lO~PCuO`%lO#]-kO's%lO~O`%lO!d#vO#]-kO's%lO~O`%lO!d#vO!p-mO#]-kO's%lO(j'mO~O'x'uO'y'uO'z-tO~Or-uO~O!V'Qa!Y'Qa~P!:RO!X-yO!V'QX!Y'QX~P%[O!Y(RO!V(`a~O!V(`a~PGiO!Y(YO!V(na~O!P%fO!X-}O![%gO'|%eO!V'WX!Y'WX~O#].PO!Y(la!k(la`(la's(la~O!d#vO~P#,SO!Y(fO!k(ka~O!P%fO![%gO#g.TO'|%eO~Ol.YO!P%fO!X.VO![%gO!|]O#f.XO#g.VO'|%eO!Y'ZX!k'ZX~O}.^O!l#yO~Og%WOj.aO![']O%d.`O~O`#`i!Y#`i's#`i'q#`i!V#`i!k#`ir#`i![#`i%d#`i!d#`i~P!:ROj<pO|)|O!P)}O(q%OO(r%QO~O#h#[a`#[a#]#[a's#[a!Y#[a!k#[a![#[a!V#[a~P#/OO#h(XXP(XXZ(XX`(XXn(XX}(XX!i(XX!l(XX!p(XX#k(XX#l(XX#m(XX#n(XX#o(XX#p(XX#q(XX#r(XX#s(XX#u(XX#w(XX#y(XX#z(XX's(XX(Y(XX(j(XX!k(XX!V(XX'q(XXr(XX![(XX%d(XX!d(XX~P!6`O!Y.nOf(cX~P!1UOf.pO~O!Y.qO!k(dX~P!:RO!k.tO~O!V.vO~OP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O(YVOZ#ji`#jin#ji!Y#ji!i#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji's#ji(j#ji(q#ji(r#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~O#k#ji~P#2zO#k$PO~P#2zOP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO(YVOZ#ji`#ji!Y#ji!i#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji's#ji(j#ji(q#ji(r#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~On#ji~P#5lOn$RO~P#5lOP$^On$RO|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO(YVO`#ji!Y#ji#u#ji#w#ji#y#ji#z#ji's#ji(j#ji(q#ji(r#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~OZ#ji!i#ji#p#ji#q#ji#r#ji#s#ji~P#8^OZ$eO!i$TO#p$TO#q$TO#r$dO#s$TO~P#8^OP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO(YVO(r$OO`#ji!Y#ji#y#ji#z#ji's#ji(j#ji(q#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~O#w$WO~P#;_O#w#ji~P#;_OP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO(YVO`#ji!Y#ji#y#ji#z#ji's#ji(j#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~O#w#ji(q#ji(r#ji~P#>PO#w$WO(q#}O(r$OO~P#>POP$^OZ$eOn$RO|#zO}#{O!P#|O!i$TO!j#xO!l#yO!p$^O#k$PO#l$QO#m$QO#n$QO#o$SO#p$TO#q$TO#r$dO#s$TO#u$UO#w$WO#y$YO(YVO(q#}O(r$OO~O`#ji!Y#ji#z#ji's#ji(j#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~P#@wOP[XZ[Xn[X|[X}[X!P[X!i[X!j[X!l[X!p[X#][X#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X(Y[X(j[X(q[X(r[X!Y[X!Z[X~O#}[X~P#CbOP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO#w:{O#y:}O#z;OO(YVO(j$[O(q#}O(r$OO~O#}.xO~P#EoO#];TO$P;TO#}(_X!Z(_X~P! cO`'^a!Y'^a's'^a'q'^a!k'^a!V'^ar'^a!['^a%d'^a!d'^a~P!:ROP#jiZ#ji`#jin#ji}#ji!Y#ji!i#ji!j#ji!l#ji!p#ji#k#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji's#ji(Y#ji(j#ji'q#ji!V#ji!k#jir#ji![#ji%d#ji!d#ji~P#/OO`$Oi!Y$Oi's$Oi'q$Oi!V$Oi!k$Oir$Oi![$Oi%d$Oi!d$Oi~P!:RO$Z.}O$].}O~O$Z/OO$]/OO~O!d)eO#]/PO![$aX$X$aX$Z$aX$]$aX$d$aX~O!X/QO~O![)hO$X/SO$Z)gO$])gO$d/TO~O!Y;PO!Z(^X~P#EoO!Z/UO~O!d)eO$d(sX~O$d/WO~Ot)wO(Z)xO([/ZO~O!V/_O~P!&kO(q%OOj%[a|%[a!P%[a(r%[a!Y%[a#]%[a~Of%[a#}%[a~P#NPO(r%QOj%^a|%^a!P%^a(q%^a!Y%^a#]%^a~Of%^a#}%^a~P#NrO!YeX!deX!keX!k$vX(jeX~P!/{O!X/hO!Y(YO'|/gO!V(nP!V(xP~P!1sOn*pO!_*nO!`*gO!a*gO!l*_O#X*oO%Z*jO'}!lO~Oo'XO!P/iO!X+VO!Z*mO(OTO(RUO(];cO!Z(pP~P$!]O!k/jO~P#/OO!Y/kO!d#vO(j'mO!k(wX~O!k/pO~O!P%fO!X*[O![%gO'|%eO!k(wP~O#h/rO~O!V$vX!Y$vX!d$}X~P!/{O!Y/sO!V(xX~P#/OO!d/uO~O!V/wO~Og%WOn/{O!d#vO!l%cO(j'mO~O'|/}O~O!d+eO~O`%lO!Y0RO's%lO~O!Z0TO~P!5gO!`0UO!a0UO'}!lO(]!mO~O!P0WO(]!mO~O#X0XO~Of%[a!Y%[a#]%[a#}%[a~P!1UOf%^a!Y%^a#]%^a#}%^a~P!1UO'|&WOf'gX!Y'gX~O!Y*vOf(Va~Of0bO~O|0cO}0cO!P0dOjya(qya(rya!Yya#]ya~Ofya#}ya~P$(OO|)|O!P)}Oj$oa(q$oa(r$oa!Y$oa#]$oa~Of$oa#}$oa~P$(tO|)|O!P)}Oj$qa(q$qa(r$qa!Y$qa#]$qa~Of$qa#}$qa~P$)gO#h0fO~Of%Pa!Y%Pa#]%Pa#}%Pa~P!1UO!d#vO~O#h0iO~O!Y+XO`(|a's(|a~O|#zO}#{O!P#|O!j#xO!l#yO(YVOP!riZ!rin!ri!Y!ri!i!ri!p!ri#k!ri#l!ri#m!ri#n!ri#o!ri#p!ri#q!ri#r!ri#s!ri#u!ri#w!ri#y!ri#z!ri(j!ri(q!ri(r!ri~O`!ri's!ri'q!ri!V!ri!k!rir!ri![!ri%d!ri!d!ri~P$+UOg%WOn$uOo$tOp$tOv%YOx%ZOz;YO!P$|O![$}O!f<jO!l$yO#g;`O$U%_O$p;[O$r;^O$u%`O(OTO(RUO(Y$vO(q%OO(r%QO~Ol0sO'|0rO~P$-oO!d+eO`(Ua![(Ua's(Ua!Y(Ua~O#h0yO~OZ[X!YeX!ZeX~O!Y0zO!Z)QX~O!Z0|O~OZ0}O~Oa1PO'|+mO(OTO(RUO~O![%}O'|%eO_'oX!Y'oX~O!Y+rO_)Pa~O!k1SO~P!:ROZ1VO~O_1WO~O#]1ZO~Oj1^O![$}O~O(](zO!Z(}P~Og%WOj1gO![1dO%d1fO~OZ1qO!Y1oO!Z)OX~O!Z1rO~O_1tO`%lO's%lO~O'|#nO(OTO(RUO~O#]$fO$P$fOP(_XZ(_Xn(_X|(_X}(_X!P(_X!Y(_X!i(_X!l(_X!p(_X#k(_X#l(_X#m(_X#n(_X#o(_X#p(_X#q(_X#r(_X#u(_X#w(_X#y(_X#z(_X(Y(_X(j(_X(q(_X(r(_X~O#s1wO&U1xO`(_X!j(_X~P$3VO#]$fO#s1wO&U1xO~O`1zO~P%[O`1|O~O&_2POP&]iQ&]iR&]iX&]i`&]ic&]id&]il&]in&]io&]ip&]iv&]ix&]iz&]i!P&]i!T&]i!U&]i![&]i!f&]i!l&]i!o&]i!p&]i!q&]i!s&]i!u&]i!x&]i!|&]i#t&]i$U&]i%c&]i%e&]i%g&]i%h&]i%i&]i%l&]i%n&]i%q&]i%r&]i%t&]i&Q&]i&W&]i&Y&]i&[&]i&^&]i&a&]i&g&]i&m&]i&o&]i&q&]i&s&]i&u&]i'q&]i'|&]i(O&]i(R&]i(Y&]i(h&]i(v&]i!Z&]ia&]i&d&]i~Oa2VO!Z2TO&d2UO~P`O![XO!l2XO~O&k,uOP&fiQ&fiR&fiX&fi`&fic&fid&fil&fin&fio&fip&fiv&fix&fiz&fi!P&fi!T&fi!U&fi![&fi!f&fi!l&fi!o&fi!p&fi!q&fi!s&fi!u&fi!x&fi!|&fi#t&fi$U&fi%c&fi%e&fi%g&fi%h&fi%i&fi%l&fi%n&fi%q&fi%r&fi%t&fi&Q&fi&W&fi&Y&fi&[&fi&^&fi&a&fi&g&fi&m&fi&o&fi&q&fi&s&fi&u&fi'q&fi'|&fi(O&fi(R&fi(Y&fi(h&fi(v&fi!Z&fi&_&fia&fi&d&fi~O!V2_O~O!Y!^a!Z!^a~P#EoOo!nO!P!oO!X2eO(]!mO!Y'RX!Z'RX~P@]O!Y-VO!Z(aa~O!Y'XX!Z'XX~P!9ZO!Y-YO!Z(pa~O!Z2lO~P'_O`%lO#]2uO's%lO~O`%lO!d#vO#]2uO's%lO~O`%lO!d#vO!p2yO#]2uO's%lO(j'mO~O`%lO's%lO~P!:RO!Y$bOr$na~O!V'Qi!Y'Qi~P!:RO!Y(RO!V(`i~O!Y(YO!V(ni~O!V(oi!Y(oi~P!:RO!Y(li!k(li`(li's(li~P!:RO#]2{O!Y(li!k(li`(li's(li~O!Y(fO!k(ki~O!P%fO![%gO!|]O#f3QO#g3PO'|%eO~O!P%fO![%gO#g3PO'|%eO~Oj3XO![']O%d3WO~Og%WOj3XO![']O%d3WO~O#h%[aP%[aZ%[a`%[an%[a}%[a!i%[a!j%[a!l%[a!p%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#q%[a#r%[a#s%[a#u%[a#w%[a#y%[a#z%[a's%[a(Y%[a(j%[a!k%[a!V%[a'q%[ar%[a![%[a%d%[a!d%[a~P#NPO#h%^aP%^aZ%^a`%^an%^a}%^a!i%^a!j%^a!l%^a!p%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a's%^a(Y%^a(j%^a!k%^a!V%^a'q%^ar%^a![%^a%d%^a!d%^a~P#NrO#h%[aP%[aZ%[a`%[an%[a}%[a!Y%[a!i%[a!j%[a!l%[a!p%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#q%[a#r%[a#s%[a#u%[a#w%[a#y%[a#z%[a's%[a(Y%[a(j%[a!k%[a!V%[a'q%[a#]%[ar%[a![%[a%d%[a!d%[a~P#/OO#h%^aP%^aZ%^a`%^an%^a}%^a!Y%^a!i%^a!j%^a!l%^a!p%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a's%^a(Y%^a(j%^a!k%^a!V%^a'q%^a#]%^ar%^a![%^a%d%^a!d%^a~P#/OO#hyaPyaZya`yanya!iya!jya!lya!pya#kya#lya#mya#nya#oya#pya#qya#rya#sya#uya#wya#yya#zya'sya(Yya(jya!kya!Vya'qyarya![ya%dya!dya~P$(OO#h$oaP$oaZ$oa`$oan$oa}$oa!i$oa!j$oa!l$oa!p$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#q$oa#r$oa#s$oa#u$oa#w$oa#y$oa#z$oa's$oa(Y$oa(j$oa!k$oa!V$oa'q$oar$oa![$oa%d$oa!d$oa~P$(tO#h$qaP$qaZ$qa`$qan$qa}$qa!i$qa!j$qa!l$qa!p$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa's$qa(Y$qa(j$qa!k$qa!V$qa'q$qar$qa![$qa%d$qa!d$qa~P$)gO#h%PaP%PaZ%Pa`%Pan%Pa}%Pa!Y%Pa!i%Pa!j%Pa!l%Pa!p%Pa#k%Pa#l%Pa#m%Pa#n%Pa#o%Pa#p%Pa#q%Pa#r%Pa#s%Pa#u%Pa#w%Pa#y%Pa#z%Pa's%Pa(Y%Pa(j%Pa!k%Pa!V%Pa'q%Pa#]%Par%Pa![%Pa%d%Pa!d%Pa~P#/OO`#`q!Y#`q's#`q'q#`q!V#`q!k#`qr#`q![#`q%d#`q!d#`q~P!:ROf'SX!Y'SX~P!(ZO!Y.nOf(ca~O!X3cO!Y'TX!k'TX~P%[O!Y.qO!k(da~O!Y.qO!k(da~P!:RO!V3fO~O#}!na!Z!na~PKVO#}!ga!Y!ga!Z!ga~P#EoO#}!ra!Z!ra~P!<lO#}!ta!Z!ta~P!?VORfO![3xO$b3yO~O!Z3}O~Or4OO~P#/OO`$kq!Y$kq's$kq'q$kq!V$kq!k$kqr$kq![$kq%d$kq!d$kq~P!:RO!V4PO~P#/OO|)|O!P)}O(r%QOj'ca(q'ca!Y'ca#]'ca~Of'ca#}'ca~P%,yO|)|O!P)}Oj'ea(q'ea(r'ea!Y'ea#]'ea~Of'ea#}'ea~P%-lO(j$[O~P#/OO!VeX!V$vX!YeX!Y$vX!d$}X#]eX~P!/{O'|;lO~P!1sOlkO'|4RO~P.iO!P%fO!X4TO![%gO'|%eO!Y'_X!k'_X~O!Y/kO!k(wa~O!Y/kO!d#vO!k(wa~O!Y/kO!d#vO(j'mO!k(wa~Of$xi!Y$xi#]$xi#}$xi~P!1UO!X4]O!V'aX!Y'aX~P!3rO!Y/sO!V(xa~O!Y/sO!V(xa~P#/OO!d#vO#s4eO~On4hO!d#vO(j'mO~O(q%OOj%[i|%[i!P%[i(r%[i!Y%[i#]%[i~Of%[i#}%[i~P%1zO(r%QOj%^i|%^i!P%^i(q%^i!Y%^i#]%^i~Of%^i#}%^i~P%2mOf(Wi!Y(Wi~P!1UO#]4oOf(Wi!Y(Wi~P!1UO!k4rO~O`$lq!Y$lq's$lq'q$lq!V$lq!k$lqr$lq![$lq%d$lq!d$lq~P!:RO!V4vO~O!Y4wO![(yX~P#/OO!j#xO~P4XO`$vX![$vX%X[X's$vX!Y$vX~P!/{O%X4yO`kXjkX|kX!PkX![kX'skX(qkX(rkX!YkX~O%X4yO~Oa5PO%e5QO'|+mO(OTO(RUO!Y'nX!Z'nX~O!Y0zO!Z)Qa~OZ5UO~O_5VO~O`%lO's%lO~P#/OO![$}O~P#/OO!Y5_O#]5aO!Z(}X~O!Z5bO~Oo!nO!P5cO!_!yO!`!vO!a!vO!|:lO#Q!pO#R!pO#S!pO#T!pO#U!pO#X5hO#Y!zO'}!lO(OTO(RUO(]!mO(h!sO~O!Z5gO~P%8OOj5mO![1dO%d5lO~Og%WOj5mO![1dO%d5lO~Oa5tO'|#nO(OTO(RUO!Y'mX!Z'mX~O!Y1oO!Z)Oa~O(OTO(RUO(]5vO~O_5zO~O#s5}O&U6OO~PMuO!k6PO~P%[O`6RO~O`6RO~P%[Oa2VO!Z6WO&d2UO~P`O!d6YO~O!d6[Og(bi!Y(bi!Z(bi!d(bi!l(bi~O!Y#ei!Z#ei~P#EoO#]6]O!Y#ei!Z#ei~O!Y!^i!Z!^i~P#EoO`%lO#]6fO's%lO~O`%lO!d#vO#]6fO's%lO~O!Y(lq!k(lq`(lq's(lq~P!:RO!Y(fO!k(kq~O!P%fO![%gO#g6mO'|%eO~O![']O%d6pO~Oj6sO![']O%d6pO~O#h'caP'caZ'ca`'can'ca}'ca!i'ca!j'ca!l'ca!p'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#s'ca#u'ca#w'ca#y'ca#z'ca's'ca(Y'ca(j'ca!k'ca!V'ca'q'car'ca!['ca%d'ca!d'ca~P%,yO#h'eaP'eaZ'ea`'ean'ea}'ea!i'ea!j'ea!l'ea!p'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea's'ea(Y'ea(j'ea!k'ea!V'ea'q'ear'ea!['ea%d'ea!d'ea~P%-lO#h$xiP$xiZ$xi`$xin$xi}$xi!Y$xi!i$xi!j$xi!l$xi!p$xi#k$xi#l$xi#m$xi#n$xi#o$xi#p$xi#q$xi#r$xi#s$xi#u$xi#w$xi#y$xi#z$xi's$xi(Y$xi(j$xi!k$xi!V$xi'q$xi#]$xir$xi![$xi%d$xi!d$xi~P#/OO#h%[iP%[iZ%[i`%[in%[i}%[i!i%[i!j%[i!l%[i!p%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#q%[i#r%[i#s%[i#u%[i#w%[i#y%[i#z%[i's%[i(Y%[i(j%[i!k%[i!V%[i'q%[ir%[i![%[i%d%[i!d%[i~P%1zO#h%^iP%^iZ%^i`%^in%^i}%^i!i%^i!j%^i!l%^i!p%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i's%^i(Y%^i(j%^i!k%^i!V%^i'q%^ir%^i![%^i%d%^i!d%^i~P%2mOf'Sa!Y'Sa~P!1UO!Y'Ta!k'Ta~P!:RO!Y.qO!k(di~O#}#`i!Y#`i!Z#`i~P#EoOP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O(YVOZ#jin#ji!i#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(j#ji(q#ji(r#ji!Y#ji!Z#ji~O#k#ji~P%KOO#k:tO~P%KOOP$^O|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO(YVOZ#ji!i#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(j#ji(q#ji(r#ji!Y#ji!Z#ji~On#ji~P%MZOn:vO~P%MZOP$^On:vO|#zO}#{O!P#|O!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO(YVO#u#ji#w#ji#y#ji#z#ji#}#ji(j#ji(q#ji(r#ji!Y#ji!Z#ji~OZ#ji!i#ji#p#ji#q#ji#r#ji#s#ji~P& fOZ;SO!i:xO#p:xO#q:xO#r;RO#s:xO~P& fOP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO(YVO(r$OO#y#ji#z#ji#}#ji(j#ji(q#ji!Y#ji!Z#ji~O#w:{O~P&$QO#w#ji~P&$QOP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO(YVO#y#ji#z#ji#}#ji(j#ji!Y#ji!Z#ji~O#w#ji(q#ji(r#ji~P&&]O#w:{O(q#}O(r$OO~P&&]OP$^OZ;SOn:vO|#zO}#{O!P#|O!i:xO!j#xO!l#yO!p$^O#k:tO#l:uO#m:uO#n:uO#o:wO#p:xO#q:xO#r;RO#s:xO#u:yO#w:{O#y:}O(YVO(q#}O(r$OO~O#z#ji#}#ji(j#ji!Y#ji!Z#ji~P&(nO`#{y!Y#{y's#{y'q#{y!V#{y!k#{yr#{y![#{y%d#{y!d#{y~P!:ROj<qO|)|O!P)}O(q%OO(r%QO~OP#jiZ#jin#ji}#ji!i#ji!j#ji!l#ji!p#ji#k#ji#l#ji#m#ji#n#ji#o#ji#p#ji#q#ji#r#ji#s#ji#u#ji#w#ji#y#ji#z#ji#}#ji(Y#ji(j#ji!Y#ji!Z#ji~P&+fO!j#xOP(XXZ(XXj(XXn(XX|(XX}(XX!P(XX!i(XX!l(XX!p(XX#k(XX#l(XX#m(XX#n(XX#o(XX#p(XX#q(XX#r(XX#s(XX#u(XX#w(XX#y(XX#z(XX#}(XX(Y(XX(j(XX(q(XX(r(XX!Y(XX!Z(XX~O#}$Oi!Y$Oi!Z$Oi~P#EoO#}!ri!Z!ri~P$+UO!Z7VO~O!Y'^a!Z'^a~P#EoOP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!i[X!j[X!l[X!p[X#][X#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X(Y[X(j[X(q[X(r[X~O!d%UX#s%UX~P&0hO!d#vO(j'mO!Y'_a!k'_a~O!Y/kO!k(wi~O!Y/kO!d#vO!k(wi~Of$xq!Y$xq#]$xq#}$xq~P!1UO!V'aa!Y'aa~P#/OO!d7^O~O!Y/sO!V(xi~P#/OO!Y/sO!V(xi~O!V7bO~O!d#vO#s7gO~On7hO!d#vO(j'mO~O|)|O!P)}O(r%QOj'da(q'da!Y'da#]'da~Of'da#}'da~P&5WO|)|O!P)}Oj'fa(q'fa(r'fa!Y'fa#]'fa~Of'fa#}'fa~P&5yO!V7jO~Of$zq!Y$zq#]$zq#}$zq~P!1UO`$ly!Y$ly's$ly'q$ly!V$ly!k$lyr$ly![$ly%d$ly!d$ly~P!:RO!d6[O~O!Y4wO![(ya~O`#`y!Y#`y's#`y'q#`y!V#`y!k#`yr#`y![#`y%d#`y!d#`y~P!:ROZ7oO~Oa7qO'|+mO(OTO(RUO~O!Y0zO!Z)Qi~O_7uO~O(](zO!Y'jX!Z'jX~O!Y5_O!Z(}a~O!Z8OO~P%8OOo!nO!P8PO(OTO(RUO(]!mO(h!sO~O![1dO~O![1dO%d8RO~Oj8UO![1dO%d8RO~OZ8ZO!Y'ma!Z'ma~O!Y1oO!Z)Oi~O!k8_O~O!k8`O~O!k8cO~O!k8cO~P%[O`8eO~O!d8fO~O!k8gO~O!Y(oi!Z(oi~P#EoO`%lO#]8oO's%lO~O!Y(ly!k(ly`(ly's(ly~P!:RO!Y(fO!k(ky~O![']O%d8rO~O#h$xqP$xqZ$xq`$xqn$xq}$xq!Y$xq!i$xq!j$xq!l$xq!p$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#q$xq#r$xq#s$xq#u$xq#w$xq#y$xq#z$xq's$xq(Y$xq(j$xq!k$xq!V$xq'q$xq#]$xqr$xq![$xq%d$xq!d$xq~P#/OO#h'daP'daZ'da`'dan'da}'da!i'da!j'da!l'da!p'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#s'da#u'da#w'da#y'da#z'da's'da(Y'da(j'da!k'da!V'da'q'dar'da!['da%d'da!d'da~P&5WO#h'faP'faZ'fa`'fan'fa}'fa!i'fa!j'fa!l'fa!p'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa's'fa(Y'fa(j'fa!k'fa!V'fa'q'far'fa!['fa%d'fa!d'fa~P&5yO#h$zqP$zqZ$zq`$zqn$zq}$zq!Y$zq!i$zq!j$zq!l$zq!p$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq's$zq(Y$zq(j$zq!k$zq!V$zq'q$zq#]$zqr$zq![$zq%d$zq!d$zq~P#/OO!Y'Ti!k'Ti~P!:RO#}#`q!Y#`q!Z#`q~P#EoO(q%OOP%[aZ%[an%[a}%[a!i%[a!j%[a!l%[a!p%[a#k%[a#l%[a#m%[a#n%[a#o%[a#p%[a#q%[a#r%[a#s%[a#u%[a#w%[a#y%[a#z%[a#}%[a(Y%[a(j%[a!Y%[a!Z%[a~Oj%[a|%[a!P%[a(r%[a~P&GUO(r%QOP%^aZ%^an%^a}%^a!i%^a!j%^a!l%^a!p%^a#k%^a#l%^a#m%^a#n%^a#o%^a#p%^a#q%^a#r%^a#s%^a#u%^a#w%^a#y%^a#z%^a#}%^a(Y%^a(j%^a!Y%^a!Z%^a~Oj%^a|%^a!P%^a(q%^a~P&I]Oj<qO|)|O!P)}O(r%QO~P&GUOj<qO|)|O!P)}O(q%OO~P&I]O|0cO}0cO!P0dOPyaZyajyanya!iya!jya!lya!pya#kya#lya#mya#nya#oya#pya#qya#rya#sya#uya#wya#yya#zya#}ya(Yya(jya(qya(rya!Yya!Zya~O|)|O!P)}OP$oaZ$oaj$oan$oa}$oa!i$oa!j$oa!l$oa!p$oa#k$oa#l$oa#m$oa#n$oa#o$oa#p$oa#q$oa#r$oa#s$oa#u$oa#w$oa#y$oa#z$oa#}$oa(Y$oa(j$oa(q$oa(r$oa!Y$oa!Z$oa~O|)|O!P)}OP$qaZ$qaj$qan$qa}$qa!i$qa!j$qa!l$qa!p$qa#k$qa#l$qa#m$qa#n$qa#o$qa#p$qa#q$qa#r$qa#s$qa#u$qa#w$qa#y$qa#z$qa#}$qa(Y$qa(j$qa(q$qa(r$qa!Y$qa!Z$qa~OP%PaZ%Pan%Pa}%Pa!i%Pa!j%Pa!l%Pa!p%Pa#k%Pa#l%Pa#m%Pa#n%Pa#o%Pa#p%Pa#q%Pa#r%Pa#s%Pa#u%Pa#w%Pa#y%Pa#z%Pa#}%Pa(Y%Pa(j%Pa!Y%Pa!Z%Pa~P&+fO#}$kq!Y$kq!Z$kq~P#EoO#}$lq!Y$lq!Z$lq~P#EoO!Z9OO~O#}9PO~P!1UO!d#vO!Y'_i!k'_i~O!d#vO(j'mO!Y'_i!k'_i~O!Y/kO!k(wq~O!V'ai!Y'ai~P#/OO!Y/sO!V(xq~O!V9VO~P#/OO!V9VO~Of(Wy!Y(Wy~P!1UO!Y'ha!['ha~P#/OO`%Wq![%Wq's%Wq!Y%Wq~P#/OOZ9[O~O!Y0zO!Z)Qq~O#]9`O!Y'ja!Z'ja~O!Y5_O!Z(}i~P#EoO![1dO%d9dO~O(OTO(RUO(]9iO~O!Y1oO!Z)Oq~O!k9lO~O!k9mO~O!k9nO~O!k9nO~P%[O#]9qO!Y#ey!Z#ey~O!Y#ey!Z#ey~P#EoO![']O%d9vO~O#}#{y!Y#{y!Z#{y~P#EoOP$xiZ$xin$xi}$xi!i$xi!j$xi!l$xi!p$xi#k$xi#l$xi#m$xi#n$xi#o$xi#p$xi#q$xi#r$xi#s$xi#u$xi#w$xi#y$xi#z$xi#}$xi(Y$xi(j$xi!Y$xi!Z$xi~P&+fO|)|O!P)}O(r%QOP'caZ'caj'can'ca}'ca!i'ca!j'ca!l'ca!p'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#s'ca#u'ca#w'ca#y'ca#z'ca#}'ca(Y'ca(j'ca(q'ca!Y'ca!Z'ca~O|)|O!P)}OP'eaZ'eaj'ean'ea}'ea!i'ea!j'ea!l'ea!p'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#s'ea#u'ea#w'ea#y'ea#z'ea#}'ea(Y'ea(j'ea(q'ea(r'ea!Y'ea!Z'ea~O(q%OOP%[iZ%[ij%[in%[i|%[i}%[i!P%[i!i%[i!j%[i!l%[i!p%[i#k%[i#l%[i#m%[i#n%[i#o%[i#p%[i#q%[i#r%[i#s%[i#u%[i#w%[i#y%[i#z%[i#}%[i(Y%[i(j%[i(r%[i!Y%[i!Z%[i~O(r%QOP%^iZ%^ij%^in%^i|%^i}%^i!P%^i!i%^i!j%^i!l%^i!p%^i#k%^i#l%^i#m%^i#n%^i#o%^i#p%^i#q%^i#r%^i#s%^i#u%^i#w%^i#y%^i#z%^i#}%^i(Y%^i(j%^i(q%^i!Y%^i!Z%^i~O#}$ly!Y$ly!Z$ly~P#EoO#}#`y!Y#`y!Z#`y~P#EoO!d#vO!Y'_q!k'_q~O!Y/kO!k(wy~O!V'aq!Y'aq~P#/OO!V:PO~P#/OO!Y0zO!Z)Qy~O!Y5_O!Z(}q~O![1dO%d:WO~O!k:ZO~O![']O%d:`O~OP$xqZ$xqn$xq}$xq!i$xq!j$xq!l$xq!p$xq#k$xq#l$xq#m$xq#n$xq#o$xq#p$xq#q$xq#r$xq#s$xq#u$xq#w$xq#y$xq#z$xq#}$xq(Y$xq(j$xq!Y$xq!Z$xq~P&+fO|)|O!P)}O(r%QOP'daZ'daj'dan'da}'da!i'da!j'da!l'da!p'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#s'da#u'da#w'da#y'da#z'da#}'da(Y'da(j'da(q'da!Y'da!Z'da~O|)|O!P)}OP'faZ'faj'fan'fa}'fa!i'fa!j'fa!l'fa!p'fa#k'fa#l'fa#m'fa#n'fa#o'fa#p'fa#q'fa#r'fa#s'fa#u'fa#w'fa#y'fa#z'fa#}'fa(Y'fa(j'fa(q'fa(r'fa!Y'fa!Z'fa~OP$zqZ$zqn$zq}$zq!i$zq!j$zq!l$zq!p$zq#k$zq#l$zq#m$zq#n$zq#o$zq#p$zq#q$zq#r$zq#s$zq#u$zq#w$zq#y$zq#z$zq#}$zq(Y$zq(j$zq!Y$zq!Z$zq~P&+fOf%`!Z!Y%`!Z#]%`!Z#}%`!Z~P!1UO!Y'jq!Z'jq~P#EoO!Y#e!Z!Z#e!Z~P#EoO#h%`!ZP%`!ZZ%`!Z`%`!Zn%`!Z}%`!Z!Y%`!Z!i%`!Z!j%`!Z!l%`!Z!p%`!Z#k%`!Z#l%`!Z#m%`!Z#n%`!Z#o%`!Z#p%`!Z#q%`!Z#r%`!Z#s%`!Z#u%`!Z#w%`!Z#y%`!Z#z%`!Z's%`!Z(Y%`!Z(j%`!Z!k%`!Z!V%`!Z'q%`!Z#]%`!Zr%`!Z![%`!Z%d%`!Z!d%`!Z~P#/OOP%`!ZZ%`!Zn%`!Z}%`!Z!i%`!Z!j%`!Z!l%`!Z!p%`!Z#k%`!Z#l%`!Z#m%`!Z#n%`!Z#o%`!Z#p%`!Z#q%`!Z#r%`!Z#s%`!Z#u%`!Z#w%`!Z#y%`!Z#z%`!Z#}%`!Z(Y%`!Z(j%`!Z!Y%`!Z!Z%`!Z~P&+fOr(^X~P1qO|%pO~P!*mO'}!lO~P!*mO!VeX!YeX#]eX~P&0hOP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!i[X!j[X!l[X!p[X#][X#]eX#heX#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#s[X#u[X#w[X#y[X#z[X$P[X(Y[X(j[X(q[X(r[X~O!deX!k[X!keX(jeX~P'EaOP:kOQ:kORfOc<fOd!iOlkOn:kOokOpkOvkOx:kOz:kO!PWO!TkO!UkO![XO!f:nO!lZO!o:kO!p:kO!q:kO!s:oO!u:rO!x!hO$U!kO'|)[O(OTO(RUO(YVO(h[O(v<dO~O!Y;PO!Z$na~Og%WOl%XOn$uOo$tOp$tOv%YOx%ZOz;ZO!P$|O![$}O!f<kO!l$yO#g;aO$U%_O$p;]O$r;_O$u%`O'|(rO(OTO(RUO(Y$vO(q%OO(r%QO~O#t)cO~P'JVOn!bX(j!bX~P# xO!Z[X!ZeX~P'EaO!VeX!V$vX!YeX!Y$vX#]eX~P!/{O#h:sO~O!d#vO#h:sO~O#];TO~O#s:xO~O#];dO!Y(oX!Z(oX~O#];TO!Y(mX!Z(mX~O#h;eO~Of;gO~P!1UO#h;mO~O#h;nO~O!d#vO#h;oO~O!d#vO#h;eO~O#};pO~P#EoO#h;qO~O#h;rO~O#h;wO~O#h;xO~O#h;yO~O#h;zO~O#};{O~P!1UO#};|O~P!1UO!j#Q#R#T#U#X#f#g#r(v$p$r$u%X%c%d%e%l%n%q%r%t%v~'wS#l!U'u'}#mo#k#nn|'v$Z'v'|$](]~",
  goto: "$4d)UPPPPP)VPP)YP)kP*{/QPPPP5xPP6`PP<V?lP@PP@PPPP@PPBPP@PP@PP@PPBTPPBYPBwPGpPPPGtPPPPGtJvPPPJ|KxPGtPGtNWPPPP!!fGtPPPGtPGtP!$tGtP!(Z!)]!)fP!*Y!*^!*YPPPPP!-j!)]PP!-z!.tP!1hGtGt!1m!4x!9`!9`!=^PPP!=fGtPPPPPPPPPPP!@tP!BRPPGt!CdPGtPGtGtGtGtPGt!DvP!HPP!KUP!KY!Kd!Kh!KhP!G|P!Kl!KlP!NqP!NuGtGt!N{#$P@PP@PP@P@PP#%]@P@P#'g@P#*V@P#,Z@P@P#,y#/V#/V#/[#/e#/V#/nP#/VP@P#0W@P#3w@P@P5xPPP#7nPPP#8X#8XP#8XP#8o#8XPP#8uP#8lP#8l#9Y#8l#9t#9z5u)Y#9})YP#:U#:U#:UP)YP)YP)YP)YPP)YP#:[#:_P#:_)YP#:cP#:fP)YP)YP)YP)YP)YP)Y)YPP#:l#:r#:}#;T#;Z#;a#;g#;u#;{#<R#<]#<c#<m#<}#=T#=u#>X#>_#>e#>s#?Y#@w#AV#A^#Br#CQ#Dl#Dz#EQ#EW#E^#Eh#En#Et#FO#Fb#FhPPPPPPPPPP#FnPPPPPPP#Gc#Jj#Ky#LQ#LYPPPP$#`$&W$,p$,s$,v$-c$-f$-i$-p$-xP$.OP$.l$.p$/h$0v$0{$1cPP$1h$1n$1rP$1u$1y$1}$2s$3[$3s$3w$3z$3}$4T$4W$4[$4`R!|RoqOXst!Z#d%k&o&q&r&t,m,r2P2SY!vQ']-_1d5fQ%rvQ%zyQ&R|Q&g!VS'T!e-VQ'c!iS'i!r!yU*g$}*X*lQ+k%{Q+x&TQ,^&aQ-]'[Q-g'dQ-o'jQ0U*nQ1n,_R;b:o%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W,j,m,r-c-k-y.P.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3c5c5m5}6O6R6f8P8U8e8oS#q]:l!r)^$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ*y%[Q+p%}Q,`&dQ,g&lQ.h;YQ0p+cQ0t+eQ1P+qQ1v,eQ3T.aQ5P0zQ5t1oQ6r3XQ7O;ZQ7q5QR8u6s'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gt!nQ!r!v!y!z'T'[']'i'j'k-V-]-_-o1d5f5h$z$ti#v#x$d$e$y$|%P%R%]%^%b)w)}*P*R*T*W*^*d*t*u+b+e+|,P.`.n/`/h/r/s/u0Y0[0f1Z1^1f3W4Q4]4e4o4w4y5l6p7^7g8R8r9P9d9v:W:`;R;S;U;V;W;X;[;];^;_;`;a;h;i;j;k;m;n;q;r;s;t;u;v;w;x;{;|<d<l<m<p<qQ&U|Q'R!eU'X%g*X-YQ+p%}Q,`&dQ0e*}Q1P+qQ1U+wQ1u,dQ1v,eQ5P0zQ5Y1WQ5t1oQ5w1qQ5x1tQ7q5QQ7t5VQ8^5zQ9_7uR9j8ZrnOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SR,b&h&x^OPXYstuvwz!Z!`!g!j!o#S#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<f<g[#]WZ#W#Z'U(P!b%hm#h#i#l$y%c%f(Y(d(e(f*W*[*_+U+V+X,i-P-}.T.U.V.X/h/k2X3P3Q4T6[6mQ%uxQ%yyS&O|&TQ&[!TQ'`!hQ'b!iQ(m#sS+j%z%{Q+n%}Q,X&_Q,]&aS-f'c'dQ.c(nQ0x+kQ1O+qQ1Q+rQ1T+vQ1i,YS1m,^,_Q2q-gQ5O0zQ5S0}Q5X1VQ5s1nQ7p5QQ7s5UQ9Z7oR:R9[!O${i#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<m!S%wy!i!u%y%z%{'S'b'c'd'h'r*f+j+k-S-f-g-n/|0x2j2q2x4gQ+d%uQ+}&XQ,Q&YQ,[&aQ.b(mQ1h,XU1l,],^,_Q3Y.cQ5n1iS5r1m1nQ8Y5s#[<h#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qo<i;R;S;V;X;];_;a;i;k;n;r;t;v;x;|W%Ui%W*v<dS&X!Q&fQ&Y!RQ&Z!SR+{&V${%Ti#v#x$d$e$y$|%P%R%]%^%b)w)}*P*R*T*W*^*d*t*u+b+e+|,P.`.n/`/h/r/s/u0Y0[0f1Z1^1f3W4Q4]4e4o4w4y5l6p7^7g8R8r9P9d9v:W:`;R;S;U;V;W;X;[;];^;_;`;a;h;i;j;k;m;n;q;r;s;t;u;v;w;x;{;|<d<l<m<p<qT)x$v)yV*z%[;Y;ZW'X!e%g*X-YS({#z#{Q+_%pQ+u&QS.[(i(jQ1_,RQ4p0cR7y5_'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<g$i$ac#Y#e%o%q%s(O(U(p(w)P)Q)R)S)T)U)V)W)X)Y)Z)])`)d)n+`+t-T-r-w-|.O.m.s.w.y.z.{/[0g2`2c2s2z3b3g3h3i3j3k3l3m3n3o3p3q3r3s3v3w3|4t4|6_6e6j6x6y7S7T7{8i8m8v8|8}9s:T:[:m<ZT#TV#U'PkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ'V!eR2f-Vv!nQ!e!r!v!y!z'T'[']'i'j'k-V-]-_-o1d5f5hU*f$}*X*lS/|*g*nQ0V*oQ1a,TQ4g0UR4j0XnqOXst!Z#d%k&o&q&r&t,m,r2P2SQ&v!^Q's!xS(o#u:sQ+h%xQ,V&[Q,W&^Q-d'aQ-q'lS.l(t;eS0h+S;oQ0v+iQ1c,UQ2W,tQ2Y,uQ2b-QQ2o-eQ2r-iS4u0i;yQ4z0wS4}0y;zQ6^2dQ6b2pQ6g2wQ7n4{Q8j6`Q8k6cQ8n6hR9p8g$d$`c#Y#e%q%s(O(U(p(w)P)Q)R)S)T)U)V)W)X)Y)Z)])`)d)n+`+t-T-r-w-|.O.m.s.w.z.{/[0g2`2c2s2z3b3g3h3i3j3k3l3m3n3o3p3q3r3s3v3w3|4t4|6_6e6j6x6y7S7T7{8i8m8v8|8}9s:T:[:m<ZS(l#p'fU*s%S(s3uS+^%o.yQ3U0pQ6o3TQ8t6rR9w8u$d$_c#Y#e%q%s(O(U(p(w)P)Q)R)S)T)U)V)W)X)Y)Z)])`)d)n+`+t-T-r-w-|.O.m.s.w.z.{/[0g2`2c2s2z3b3g3h3i3j3k3l3m3n3o3p3q3r3s3v3w3|4t4|6_6e6j6x6y7S7T7{8i8m8v8|8}9s:T:[:m<ZS(k#p'fS(}#{$`S+]%o.yS.](j(lQ.|)_Q0m+^R3R.^'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gS#q]:lQ&q!XQ&r!YQ&t![Q&u!]R2O,pQ'^!hQ+a%uQ-b'`S._(m+dQ2m-aW3V.b.c0o0qQ6a2nU6n3S3U3YS8q6o6qS9u8s8tS:^9t9wQ:f:_R:i:gU!wQ']-_T5d1d5f!Q_OXZ`st!V!Z#d#h%c%k&f&h&o&q&r&t(f,m,r.U2P2S]!pQ!r']-_1d5fT#q]:l%[{OPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oS({#z#{S.[(i(j!s<Q$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gm!tQ!r!v!y!z']'i'j'k-_-o1d5f5hQ'q!uS(b#g1yS-m'h'tQ/n*ZQ/z*fQ2y-pQ4X/oS4b/{0VQ7Y4SS7e4h4jQ9R7ZR9Y7hQ#wbQ'p!uS(a#g1yS(c#m+RQ+T%dQ+f%vQ+l%|U-l'h'q'tQ.Q(bQ/m*ZQ/y*fQ0P*iQ0u+gQ1j,ZS2v-m-pQ3O.YS4W/n/oS4a/z0VQ4d0OQ4f0QQ5p1kQ6i2yQ7X4SQ7]4XS7a4b4jQ7f4iQ8W5qS9Q7Y7ZQ9U7bQ9W7eQ9g8XQ9}9RQ:O9VQ:Q9YQ:Y9hQ:b:PQ<T<OQ<`<XR<a<YV!wQ']-_%[aOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oS#wz!j!r;}$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gR<T<f%[bOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oQ%dj!S%vy!i!u%y%z%{'S'b'c'd'h'r*f+j+k-S-f-g-n/|0x2j2q2x4gS%|z!jQ+g%wQ,Z&aW1k,[,],^,_U5q1l1m1nS8X5r5sQ9h8Y!r<O$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ<X<eR<Y<f%OeOPXYstuvw!Z!`!g!o#S#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&o&q&r&t&x'Q'_'o(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8oY#bWZ#W#Z(P!b%hm#h#i#l$y%c%f(Y(d(e(f*W*[*_+U+V+X,i-P-}.T.U.V.X/h/k2X3P3Q4T6[6mQ,h&l!p<P$]$n)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gR<S'UU'Y!e%g*XR2h-Y%QdOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W,j,m,r-c-k-y.P.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3c5c5m5}6O6R6f8P8U8e8o!r)^$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gQ,g&lQ0p+cQ3T.aQ6r3XR8u6s!b$Vc#Y%o(O(U(p(w)Y)Z)`)d+t-r-w-|.O.m.s/[0g2s2z3b3s4t4|6e6j6x8m9s:m!P:z)])n-T.y2`2c3g3q3r3v3|6_6y7S7T7{8i8v8|8}:T:[<Z!f$Xc#Y%o(O(U(p(w)V)W)Y)Z)`)d+t-r-w-|.O.m.s/[0g2s2z3b3s4t4|6e6j6x8m9s:m!T:|)])n-T.y2`2c3g3n3o3q3r3v3|6_6y7S7T7{8i8v8|8}:T:[<Z!^$]c#Y%o(O(U(p(w)`)d+t-r-w-|.O.m.s/[0g2s2z3b3s4t4|6e6j6x8m9s:mQ4Q/fz<g)])n-T.y2`2c3g3v3|6_6y7S7T7{8i8v8|8}:T:[<ZQ<l<nR<m<o'OkOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gS$oh$pR3y/P'VgOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/P/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gT$kf$qQ$ifS)g$l)kR)s$qT$jf$qT)i$l)k'VhOPWXYZhstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$]$b$f$n$p%k%r&P&h&k&l&o&q&r&t&x'Q'U'_'o(P(R(X(`(t(x(|)p){+S+W+c,j,m,r-O-R-c-k-y.P.a.q.x/P/Q/i0d0i0y1g1w1x1z1|2P2S2U2e2u2{3X3c3x5a5c5m5}6O6R6]6f6s8P8U8e8o9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<gT$oh$pQ$rhR)r$p%[jOPWXYZstuvw!Z!`!g!o#S#W#Z#d#o#u#y#|$P$Q$R$S$T$U$V$W$X$Y$Z$b$f%k%r&P&h&k&l&o&q&r&t&x'Q'_'o(P(R(X(`(t(x(|){+S+W+c,j,m,r-c-k-y.P.a.q.x/i0d0i0y1g1w1x1z1|2P2S2U2u2{3X3c5c5m5}6O6R6f6s8P8U8e8o!s<e$]$n'U)p-O-R/Q2e3x5a6]9`9q:k:n:o:r:s:t:u:v:w:x:y:z:{:|:};O;P;T;b;d;e;g;o;p;y;z<g#elOPXZst!Z!`!o#S#d#o#|$n%k&h&k&l&o&q&r&t&x'Q'_(|)p+W+c,j,m,r-c.a/Q/i0d1g1w1x1z1|2P2S2U3X3x5c5m5}6O6R6s8P8U8e!O%Si#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<m#[(s#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qQ+O%`Q/])|o3u;R;S;V;X;];_;a;i;k;n;r;t;v;x;|!O$zi#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<mQ*`${U*i$}*X*lQ+P%aQ0Q*j#[<V#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qn<W;R;S;V;X;];_;a;i;k;n;r;t;v;x;|Q<[<hQ<]<iQ<^<jR<_<k!O%Si#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<m#[(s#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qo3u;R;S;V;X;];_;a;i;k;n;r;t;v;x;|noOXst!Z#d%k&o&q&r&t,m,r2P2SS*c$|*WQ,{&{Q,|&}R4[/s$z%Ti#v#x$d$e$y$|%P%R%]%^%b)w)}*P*R*T*W*^*d*t*u+b+e+|,P.`.n/`/h/r/s/u0Y0[0f1Z1^1f3W4Q4]4e4o4w4y5l6p7^7g8R8r9P9d9v:W:`;R;S;U;V;W;X;[;];^;_;`;a;h;i;j;k;m;n;q;r;s;t;u;v;w;x;{;|<d<l<m<p<qQ,O&YQ1],QQ5]1[R7x5^V*k$}*X*lU*k$}*X*lT5e1d5fU0O*h/i5cT4i0W8PQ+f%vQ0P*iQ0u+gQ1j,ZQ5p1kQ8W5qQ9g8XR:Y9h!O%Pi#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<mr*P$w(u*Q*r+Q/q0^0_3`4Y4s7W7i9|<U<b<cS0Y*q0Z#[;U#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qn;V;R;S;V;X;];_;a;i;k;n;r;t;v;x;|!^;h(q)b*Y*b.d.g.k/X/^/f/v0n1Y1[3]4Z4_5[5^6t6w7_7c7k7m9T9X:a<n<o`;i3t6z6}7R8w9x9{:jS;s.f3^T;t6|8z!O%Ri#x%P%R%]%^%b*P*R*^*t*u.n/r0Y0[0f4Q4o9P<d<l<mv*R$w(u*S*q+Q/b/q0^0_3`4Y4k4s7W7i9|<U<b<cS0[*r0]#[;W#v$d$e$y$|)w)}*T*W*d+b+e+|,P.`/`/h/s/u1Z1^1f3W4]4e4w4y5l6p7^7g8R8r9d9v:W:`;U;W;[;^;`;h;j;m;q;s;u;w;{<p<qn;X;R;S;V;X;];_;a;i;k;n;r;t;v;x;|!b;j(q)b*Y*b.e.f.k/X/^/f/v0n1Y1[3Z3]4Z4_5[5^6t6u6w7_7c7k7m9T9X:a<n<od;k3t6{6|7R8w8x9x9y9{:jS;u.g3_T;v6}8{rnOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SQ&c!UR,j&lrnOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SR&c!UQ,S&ZR1X+{snOXst!V!Z#d%k&f&o&q&r&t,m,r2P2SQ1e,XS5k1h1iU8Q5i5j5nS9c8S8TS:U9b9eQ:c:VR:h:dQ&j!VR,c&fR5w1qS&O|&TR1Q+rQ&o!WR,m&pR,s&uT2Q,r2SR,w&vQ,v&vR2Z,wQ'v!{R-s'vSsOtQ#dXT%ns#dQ#OTR'x#OQ#RUR'z#RQ)y$vR/Y)yQ#UVR'|#UQ#XWU(S#X(T-zQ(T#YR-z(UQ-W'VR2g-WQ.o(uR3a.oQ.r(wS3d.r3eR3e.sQ-_']R2k-_Y!rQ']-_1d5fR'g!rU#_W%f*WU(Z#_([-{Q([#`R-{(VQ-Z'YR2i-Zt`OXst!V!Z#d%k&f&h&o&q&r&t,m,r2P2SS#hZ%cU#r`#h.UR.U(fQ(g#jQ.R(cW.Z(g.R2|6kQ2|.SR6k2}Q)k$lR/R)kQ$phR)q$pQ$ccU)a$c-v;QQ-v:mR;Q)nQ/l*ZW4U/l4V7[9SU4V/m/n/oS7[4W4XR9S7]$X*O$w(q(u)b*Y*b*q*r*{*|+Q.f.g.i.j.k/X/^/b/d/f/q/v0^0_0n1Y1[3Z3[3]3`3t4Y4Z4_4k4m4s5[5^6t6u6v6w6|6}7P7Q7R7W7_7c7i7k7m8w8x8y9T9X9x9y9z9{9|:a:j<U<b<c<n<oQ/t*bU4^/t4`7`Q4`/vR7`4_S*l$}*XR0S*lr*Q$w(u*q*r+Q/q0^0_3`4Y4s7W7i9|<U<b<c!^.d(q)b*Y*b.f.g.k/X/^/f/v0n1Y1[3]4Z4_5[5^6t6w7_7c7k7m9T9X:a<n<oU/c*Q.d6za6z3t6|6}7R8w9x9{:jQ0Z*qQ3^.fU4l0Z3^8zR8z6|v*S$w(u*q*r+Q/b/q0^0_3`4Y4k4s7W7i9|<U<b<c!b.e(q)b*Y*b.f.g.k/X/^/f/v0n1Y1[3Z3]4Z4_5[5^6t6u6w7_7c7k7m9T9X:a<n<oU/e*S.e6{e6{3t6|6}7R8w8x9x9y9{:jQ0]*rQ3_.gU4n0]3_8{R8{6}Q*w%VR0a*wQ4x0nR7l4xQ+Y%iR0l+YQ5`1_S7z5`9aR9a7{Q,U&[R1b,UQ5f1dR7}5fQ1p,`S5u1p8[R8[5wQ0{+nW5R0{5T7r9]Q5T1OQ7r5SR9]7sQ+s&OR1R+sQ2S,rR6V2SYrOXst#dQ&s!ZQ+[%kQ,l&oQ,n&qQ,o&rQ,q&tQ1},mS2Q,r2SR6U2PQ%mpQ&w!_Q&z!aQ&|!bQ'O!cQ'n!uQ+Z%jQ+h%xQ+z&UQ,b&jQ,y&yW-j'h'p'q'tQ-q'lQ0R*kQ0v+iS1s,c,fQ2[,xQ2],{Q2^,|Q2r-iW2t-l-m-p-rQ4z0wQ5W1UQ5Z1YQ5o1jQ5y1uQ6T2OU6d2s2v2yQ6g2wQ7n4{Q7v5YQ7w5[Q7|5eQ8V5pQ8]5xS8l6e6iQ8n6hQ9^7tQ9f8WQ9k8^Q9r8mQ:S9_Q:X9gQ:]9sR:e:YQ%xyQ'a!iQ'l!uU+i%y%z%{Q-Q'SU-e'b'c'dS-i'h'rQ/x*fS0w+j+kQ2d-SS2p-f-gQ2w-nQ4c/|Q4{0xQ6`2jQ6c2qQ6h2xR7d4gS$xi<dR*x%WU%Vi%W<dR0`*vQ$wiS(q#v+eQ(u#xS)b$d$eQ*Y$yS*b$|*WQ*q%PQ*r%RQ*{%]Q*|%^Q+Q%bQ.f;UQ.g;WQ.i;[Q.j;^Q.k;`Q/X)wS/^)}/`Q/b*PQ/d*RQ/f*TQ/q*^S/v*d/hQ0^*tQ0_*uh0n+b.`1f3W5l6p8R8r9d9v:W:`Q1Y+|Q1[,PQ3Z;hQ3[;jQ3];mQ3`.nS3t;R;SQ4Y/rQ4Z/sQ4_/uQ4k0YQ4m0[Q4s0fQ5[1ZQ5^1^Q6t;qQ6u;sQ6v;uQ6w;wQ6|;VQ6};XQ7P;]Q7Q;_Q7R;aQ7W4QQ7_4]Q7c4eQ7i4oQ7k4wQ7m4yQ8w;nQ8x;iQ8y;kQ9T7^Q9X7gQ9x;rQ9y;tQ9z;vQ9{;xQ9|9PQ:a;{Q:j;|Q<U<dQ<b<lQ<c<mQ<n<pR<o<qnpOXst!Z#d%k&o&q&r&t,m,r2P2SQ!fPS#fZ#oQ&y!`U'e!o5c8PQ'{#SQ)O#|Q)o$nS,f&h&kQ,k&lQ,x&xQ,}'QQ-a'_Q.u(|Q/V)pS0j+W/iQ0q+cQ1{,jQ2n-cQ3U.aQ3{/QQ4q0dQ5j1gQ5{1wQ5|1xQ6Q1zQ6S1|Q6X2UQ6o3XQ7U3xQ8T5mQ8a5}Q8b6OQ8d6RQ8t6sQ9e8UR9o8e#YcOPXZst!Z!`!o#d#o#|%k&h&k&l&o&q&r&t&x'Q'_(|+W+c,j,m,r-c.a/i0d1g1w1x1z1|2P2S2U3X5c5m5}6O6R6s8P8U8eQ#YWQ#eYQ%ouQ%qvS%sw!gS(O#W(RQ(U#ZQ(p#uQ(w#yQ)P$PQ)Q$QQ)R$RQ)S$SQ)T$TQ)U$UQ)V$VQ)W$WQ)X$XQ)Y$YQ)Z$ZQ)]$]Q)`$bQ)d$fW)n$n)p/Q3xQ+`%rQ+t&PS-T'U2eQ-r'oS-w(P-yQ-|(XQ.O(`Q.m(tQ.s(xQ.w:kQ.y:nQ.z:oQ.{:rQ/[){Q0g+SQ2`-OQ2c-RQ2s-kQ2z.PQ3b.qQ3g:sQ3h:tQ3i:uQ3j:vQ3k:wQ3l:xQ3m:yQ3n:zQ3o:{Q3p:|Q3q:}Q3r;OQ3s.xQ3v;TQ3w;bQ3|;PQ4t0iQ4|0yQ6_;dQ6e2uQ6j2{Q6x3cQ6y;eQ7S;gQ7T;oQ7{5aQ8i6]Q8m6fQ8v;pQ8|;yQ8};zQ9s8oQ:T9`Q:[9qQ:m#SR<Z<gR#[WR'W!el!tQ!r!v!y!z']'i'j'k-_-o1d5f5hS'S!e-VS-S'T'[R2j-]R(v#xR(y#yQ!fQT-^']-_]!qQ!r']-_1d5fQ#p]R'f:lY!uQ']-_1d5fQ'h!rS'r!v!yS't!z5hS-n'i'jQ-p'kR2x-oT#kZ%cS#jZ%cS%im,iU(c#h#i#lS.S(d(eQ.W(fQ0k+XQ2}.TU3O.U.V.XS6l3P3QR8p6md#^W#W#Z%f(P(Y*W+U-}/hr#gZm#h#i#l%c(d(e(f+X.T.U.V.X3P3Q6mS*Z$y*_Q/o*[Q1y,iQ2a-PQ4S/kQ6Z2XQ7Z4TQ8h6[T<R'U+VV#aW%f*WU#`W%f*WS(Q#W(YU(V#Z+U/hS-U'U+VT-x(P-}V'Z!e%g*XQ$lfR)u$qT)j$l)kR3z/PT*]$y*_T*e$|*WQ0o+bQ3S.`Q5i1fQ6q3WQ8S5lQ8s6pQ9b8RQ9t8rQ:V9dQ:_9vQ:d:WR:g:`nqOXst!Z#d%k&o&q&r&t,m,r2P2SQ&i!VR,b&ftmOXst!U!V!Z#d%k&f&o&q&r&t,m,r2P2SR,i&lT%jm,iR1`,RR,a&dQ&S|R+y&TR+o%}T&m!W&pT&n!W&pT2R,r2S",
  nodeNames: " ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewTarget new NewExpression TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 373,
  context: wR,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 202, 206, 210, 211, 213, 216, 219, 229, 231, 237, 239, 241, 243, 246, 252, 258, 260, 262, 264, 266, 268, 269, "Statement", -33, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 69, 76, 80, 82, 84, 85, 107, 108, 117, 118, 135, 138, 140, 141, 142, 143, 145, 146, 165, 166, 168, "Expression", -23, 27, 29, 33, 37, 39, 41, 169, 171, 173, 174, 176, 177, 178, 180, 181, 182, 184, 185, 186, 196, 198, 200, 201, "Type", -3, 88, 100, 106, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 73, "(", 158, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 74, ")", 163, "JSXEndTag"]
  ],
  propSources: [VR],
  skippedNodes: [0, 4, 5, 272],
  repeatNodeCount: 37,
  tokenData: "$HR07[R!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#:O!R![#<_![!]#I_!]!^#Jk!^!_#Ku!_!`$![!`!a$$v!a!b$*T!b!c$.S!c!}Er!}#O$/^#O#P$0h#P#Q$6P#Q#R$7Z#R#SEr#S#T$8h#T#o$9r#o#p$>S#p#q$>x#q#r$@Y#r#s$Af#s$f%Z$f$g+g$g#BYEr#BY#BZ$Bp#BZ$ISEr$IS$I_$Bp$I_$I|Er$I|$I}$E{$I}$JO$E{$JO$JTEr$JT$JU$Bp$JU$KVEr$KV$KW$Bp$KW&FUEr&FU&FV$Bp&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$Bp?HUOEr(n%d_$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$g&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$g&j(S!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(S!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$g&j(PpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(PpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z07[+rq$g&j(Pp(S!b'u0/lOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z07[.ST(Q#S$g&j'v0/lO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c07[.n_$g&j(Pp(S!b'v0/lOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)3p/x`$g&j!p),Q(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW1V`#u(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW2d_#u(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At3l_(O':f$g&j(S!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$g&j(S!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$g&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$b`$g&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$b``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$b`$g&j(S!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(S!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$b`(S!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k%9[:hh$g&j(Pp(S!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$g&j(Pp(S!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$g&j(S!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$g&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(S!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$g&j(PpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(PpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Pp(S!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S%9[C}i$g&j(h%1l(Pp(S!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr%9[EoP;=`<%lCr07[FRk$g&j(Pp(S!b$Z#t'|,2j(]$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$g&j(Pp(S!b$Z#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv07[JPP;=`<%lEr(KWJ_`$g&j(Pp(S!b#m(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWKl_$g&j$P(Ch(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,#xLva(r+JY$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KWNW`$g&j#y(Ch(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'At! c_(R';W$g&j(PpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$g&j(PpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$g&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$b`$g&j(PpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(PpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$b`(PpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b/5|!'t_!l/.^$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&U!)O_!k!Lf$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n!*[b$g&j(Pp(S!b'}%&f#n(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW!+o`$g&j(Pp(S!b#k(ChOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;x!,|`$g&j(Pp(S!bn+4YOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z,$U!.Z_!Y+Jf$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!/ec$g&j(Pp(S!b|.2^OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!0ya$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#%|!2Z_!X!L^$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!3eg$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!5Vg$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!6wc$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad!8_c$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[!9uf$g&j(Pp(S!b#l(ChOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcxz!;Zz{#-}{!P!;Z!P!Q#/d!Q!^!;Z!^!_#(i!_!`#7S!`!a#8i!a!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z?O!;fb$g&j(Pp(S!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z>^!<w`$g&j(S!b!U7`OY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eq!Q!^!<n!^!_!Gr!_!}!<n!}#O!KS#O#P!Dy#P#o!<n#o#p!Gr#p;'S!<n;'S;=`!L]<%lO!<n<z!>Q^$g&j!U7`OY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@c!_!}!=y!}#O!CW#O#P!Dy#P#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!?Td$g&j!U7`O!^&c!_#W&c#W#X!>|#X#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#k!>|#k#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&c7`!@hX!U7`OY!@cZ!P!@c!P!Q!AT!Q!}!@c!}#O!Ar#O#P!Bq#P;'S!@c;'S;=`!CQ<%lO!@c7`!AYW!U7`#W#X!AT#Z#[!AT#]#^!AT#a#b!AT#g#h!AT#i#j!AT#j#k!AT#m#n!AT7`!AuVOY!ArZ#O!Ar#O#P!B[#P#Q!@c#Q;'S!Ar;'S;=`!Bk<%lO!Ar7`!B_SOY!ArZ;'S!Ar;'S;=`!Bk<%lO!Ar7`!BnP;=`<%l!Ar7`!BtSOY!@cZ;'S!@c;'S;=`!CQ<%lO!@c7`!CTP;=`<%l!@c<z!C][$g&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#O!CW#O#P!DR#P#Q!=y#Q#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DWX$g&jOY!CWYZ&cZ!^!CW!^!_!Ar!_#o!CW#o#p!Ar#p;'S!CW;'S;=`!Ds<%lO!CW<z!DvP;=`<%l!CW<z!EOX$g&jOY!=yYZ&cZ!^!=y!^!_!@c!_#o!=y#o#p!@c#p;'S!=y;'S;=`!Ek<%lO!=y<z!EnP;=`<%l!=y>^!Ezl$g&j(S!b!U7`OY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#W&}#W#X!Eq#X#Z&}#Z#[!Eq#[#]&}#]#^!Eq#^#a&}#a#b!Eq#b#g&}#g#h!Eq#h#i&}#i#j!Eq#j#k!Eq#k#m&}#m#n!Eq#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}8r!GyZ(S!b!U7`OY!GrZw!Grwx!@cx!P!Gr!P!Q!Hl!Q!}!Gr!}#O!JU#O#P!Bq#P;'S!Gr;'S;=`!J|<%lO!Gr8r!Hse(S!b!U7`OY'}Zw'}x#O'}#P#W'}#W#X!Hl#X#Z'}#Z#[!Hl#[#]'}#]#^!Hl#^#a'}#a#b!Hl#b#g'}#g#h!Hl#h#i'}#i#j!Hl#j#k!Hl#k#m'}#m#n!Hl#n;'S'};'S;=`(f<%lO'}8r!JZX(S!bOY!JUZw!JUwx!Arx#O!JU#O#P!B[#P#Q!Gr#Q;'S!JU;'S;=`!Jv<%lO!JU8r!JyP;=`<%l!JU8r!KPP;=`<%l!Gr>^!KZ^$g&j(S!bOY!KSYZ&cZw!KSwx!CWx!^!KS!^!_!JU!_#O!KS#O#P!DR#P#Q!<n#Q#o!KS#o#p!JU#p;'S!KS;'S;=`!LV<%lO!KS>^!LYP;=`<%l!KS>^!L`P;=`<%l!<n=l!Ll`$g&j(Pp!U7`OY!LcYZ&cZr!Lcrs!=ys!P!Lc!P!Q!Mn!Q!^!Lc!^!_# o!_!}!Lc!}#O#%P#O#P!Dy#P#o!Lc#o#p# o#p;'S!Lc;'S;=`#&Y<%lO!Lc=l!Mwl$g&j(Pp!U7`OY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#W(r#W#X!Mn#X#Z(r#Z#[!Mn#[#](r#]#^!Mn#^#a(r#a#b!Mn#b#g(r#g#h!Mn#h#i(r#i#j!Mn#j#k!Mn#k#m(r#m#n!Mn#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r8Q# vZ(Pp!U7`OY# oZr# ors!@cs!P# o!P!Q#!i!Q!}# o!}#O#$R#O#P!Bq#P;'S# o;'S;=`#$y<%lO# o8Q#!pe(Pp!U7`OY)rZr)rs#O)r#P#W)r#W#X#!i#X#Z)r#Z#[#!i#[#])r#]#^#!i#^#a)r#a#b#!i#b#g)r#g#h#!i#h#i)r#i#j#!i#j#k#!i#k#m)r#m#n#!i#n;'S)r;'S;=`*Z<%lO)r8Q#$WX(PpOY#$RZr#$Rrs!Ars#O#$R#O#P!B[#P#Q# o#Q;'S#$R;'S;=`#$s<%lO#$R8Q#$vP;=`<%l#$R8Q#$|P;=`<%l# o=l#%W^$g&j(PpOY#%PYZ&cZr#%Prs!CWs!^#%P!^!_#$R!_#O#%P#O#P!DR#P#Q!Lc#Q#o#%P#o#p#$R#p;'S#%P;'S;=`#&S<%lO#%P=l#&VP;=`<%l#%P=l#&]P;=`<%l!Lc?O#&kn$g&j(Pp(S!b!U7`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#W%Z#W#X#&`#X#Z%Z#Z#[#&`#[#]%Z#]#^#&`#^#a%Z#a#b#&`#b#g%Z#g#h#&`#h#i%Z#i#j#&`#j#k#&`#k#m%Z#m#n#&`#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z9d#(r](Pp(S!b!U7`OY#(iZr#(irs!Grsw#(iwx# ox!P#(i!P!Q#)k!Q!}#(i!}#O#+`#O#P!Bq#P;'S#(i;'S;=`#,`<%lO#(i9d#)th(Pp(S!b!U7`OY*gZr*grs'}sw*gwx)rx#O*g#P#W*g#W#X#)k#X#Z*g#Z#[#)k#[#]*g#]#^#)k#^#a*g#a#b#)k#b#g*g#g#h#)k#h#i*g#i#j#)k#j#k#)k#k#m*g#m#n#)k#n;'S*g;'S;=`+Z<%lO*g9d#+gZ(Pp(S!bOY#+`Zr#+`rs!JUsw#+`wx#$Rx#O#+`#O#P!B[#P#Q#(i#Q;'S#+`;'S;=`#,Y<%lO#+`9d#,]P;=`<%l#+`9d#,cP;=`<%l#(i?O#,o`$g&j(Pp(S!bOY#,fYZ&cZr#,frs!KSsw#,fwx#%Px!^#,f!^!_#+`!_#O#,f#O#P!DR#P#Q!;Z#Q#o#,f#o#p#+`#p;'S#,f;'S;=`#-q<%lO#,f?O#-tP;=`<%l#,f?O#-zP;=`<%l!;Z07[#.[b$g&j(Pp(S!b'w0/l!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z07[#/o_$g&j(Pp(S!bS0/lOY#/dYZ&cZr#/drs#0nsw#/dwx#4Ox!^#/d!^!_#5}!_#O#/d#O#P#1p#P#o#/d#o#p#5}#p;'S#/d;'S;=`#6|<%lO#/d06j#0w]$g&j(S!bS0/lOY#0nYZ&cZw#0nwx#1px!^#0n!^!_#3R!_#O#0n#O#P#1p#P#o#0n#o#p#3R#p;'S#0n;'S;=`#3x<%lO#0n05W#1wX$g&jS0/lOY#1pYZ&cZ!^#1p!^!_#2d!_#o#1p#o#p#2d#p;'S#1p;'S;=`#2{<%lO#1p0/l#2iSS0/lOY#2dZ;'S#2d;'S;=`#2u<%lO#2d0/l#2xP;=`<%l#2d05W#3OP;=`<%l#1p01O#3YW(S!bS0/lOY#3RZw#3Rwx#2dx#O#3R#O#P#2d#P;'S#3R;'S;=`#3r<%lO#3R01O#3uP;=`<%l#3R06j#3{P;=`<%l#0n05x#4X]$g&j(PpS0/lOY#4OYZ&cZr#4Ors#1ps!^#4O!^!_#5Q!_#O#4O#O#P#1p#P#o#4O#o#p#5Q#p;'S#4O;'S;=`#5w<%lO#4O00^#5XW(PpS0/lOY#5QZr#5Qrs#2ds#O#5Q#O#P#2d#P;'S#5Q;'S;=`#5q<%lO#5Q00^#5tP;=`<%l#5Q05x#5zP;=`<%l#4O01p#6WY(Pp(S!bS0/lOY#5}Zr#5}rs#3Rsw#5}wx#5Qx#O#5}#O#P#2d#P;'S#5};'S;=`#6v<%lO#5}01p#6yP;=`<%l#5}07[#7PP;=`<%l#/d)3h#7ab$g&j$P(Ch(Pp(S!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;ZAt#8vb$X#t$g&j(Pp(S!b!U7`OY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Lcx!P!;Z!P!Q#&`!Q!^!;Z!^!_#(i!_!}!;Z!}#O#,f#O#P!Dy#P#o!;Z#o#p#(i#p;'S!;Z;'S;=`#-w<%lO!;Z'Ad#:Zp$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#U%Z#U#V#?i#V#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#d#Bq#d#l%Z#l#m#Es#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#<jk$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#<_![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#<_#S#X%Z#X#Y!4|#Y#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#>j_$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#?rd$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#A]f$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#AQ!R!S#AQ!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#AQ#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Bzc$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Dbe$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#DV!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#DV#S#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#E|g$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'Ad#Gpi$g&j(Pp(S!bo'9tOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#Ge![!^%Z!^!_*g!_!c%Z!c!i#Ge!i#O%Z#O#P&c#P#R%Z#R#S#Ge#S#T%Z#T#Z#Ge#Z#b%Z#b#c#>_#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x#Il_!d$b$g&j#})Lv(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Jv_`l$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f#LS^g#)`!i-<U(Pp(S!b(v7`OY*gZr*grs'}sw*gwx)rx!P*g!P!Q#MO!Q!^*g!^!_#Mt!_!`$ f!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#MXX$i&j(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El#M}Z#o(Ch(Pp(S!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Np!`#O*g#P;'S*g;'S;=`+Z<%lO*g(El#NyX$P(Ch(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g(El$ oX#p(Ch(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g*)x$!ga#]*!Y$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$#l!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(K[$#w_#h(Cl$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z*)x$%Vaf!*r#p(Ch$d#|$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$&[!`!a$'f!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$&g_#p(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$'qa#o(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$(v!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$)R`#o(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!n$*`c(j(Ct$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$+k!P!^%Z!^!_*g!_!a%Z!a!b$,u!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z-!f$+v_},Hv$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$-Q`$g&j#z(Ch(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`$.__!|$Ip$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z04f$/i_!P0,v$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$0mZ$g&jO!^$1`!^!_$1v!_#i$1`#i#j$1{#j#l$1`#l#m$3n#m#o$1`#o#p$1v#p;'S$1`;'S;=`$5y<%lO$1`(n$1gT^#S$g&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$1{O^#S(n$2Q[$g&jO!Q&c!Q![$2v![!^&c!_!c&c!c!i$2v!i#T&c#T#Z$2v#Z#o&c#o#p$5^#p;'S&c;'S;=`&w<%lO&c(n$2{Z$g&jO!Q&c!Q![$3n![!^&c!_!c&c!c!i$3n!i#T&c#T#Z$3n#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3sZ$g&jO!Q&c!Q![$4f![!^&c!_!c&c!c!i$4f!i#T&c#T#Z$4f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$4kZ$g&jO!Q&c!Q![$1`![!^&c!_!c&c!c!i$1`!i#T&c#T#Z$1`#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$5aR!Q![$5j!c!i$5j#T#Z$5j#S$5mS!Q![$5j!c!i$5j#T#Z$5j#q#r$1v(n$5|P;=`<%l$1`#1[$6[_!V#)l$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(KW$7f`#w(Ch$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z+;p$8s_$g&j(Pp(S!b(Y+4QOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$:Rk$g&j(Pp(S!b'|,2j$]#t(]$I[OY%ZYZ&cZr%Zrs&}st%Ztu$9ruw%Zwx(rx}%Z}!O$;v!O!Q%Z!Q![$9r![!^%Z!^!_*g!_!c%Z!c!}$9r!}#O%Z#O#P&c#P#R%Z#R#S$9r#S#T%Z#T#o$9r#o#p*g#p$g%Z$g;'S$9r;'S;=`$=|<%lO$9r+d$<Rk$g&j(Pp(S!b$]#tOY%ZYZ&cZr%Zrs&}st%Ztu$;vuw%Zwx(rx}%Z}!O$;v!O!Q%Z!Q![$;v![!^%Z!^!_*g!_!c%Z!c!}$;v!}#O%Z#O#P&c#P#R%Z#R#S$;v#S#T%Z#T#o$;v#o#p*g#p$g%Z$g;'S$;v;'S;=`$=v<%lO$;v+d$=yP;=`<%l$;v07[$>PP;=`<%l$9r#Jf$>]X![#Hb(Pp(S!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g,#x$?Ta(q+JY$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$,u#q;'S%Z;'S;=`+a<%lO%Z(Kd$@g_!Z(Cdr`$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z?O$Aq_!q7`$g&j(Pp(S!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z07[$CR|$g&j(Pp(S!b'u0/l$Z#t'|,2j(]$I[OX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$Bp#BZ$ISEr$IS$I_$Bp$I_$JTEr$JT$JU$Bp$JU$KVEr$KV$KW$Bp$KW&FUEr&FU&FV$Bp&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$Bp?HUOEr07[$F^k$g&j(Pp(S!b'v0/l$Z#t'|,2j(]$I[OY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [kR, QR, GR, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, MR, new Ts("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO([~~", 141, 333), new Ts("j~RQYZXz{^~^O'y~~aP!P!Qd~iO'z~~", 25, 316)],
  topRules: { Script: [0, 6], SingleExpression: [1, 270], SingleClassItem: [2, 271] },
  dialects: { jsx: 0, ts: 14840 },
  dynamicPrecedences: { 70: 1, 80: 1, 82: 1, 166: 1, 194: 1 },
  specialized: [{ term: 320, get: (e) => BR[e] || -1 }, { term: 335, get: (e) => $R[e] || -1 }, { term: 71, get: (e) => YR[e] || -1 }],
  tokenPrec: 14864
});
var Vp = [
  qt("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  qt("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  qt("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  qt("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  qt("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  qt(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  qt("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  qt(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  qt(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  qt('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  qt('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
var WR = Vp.concat([
  qt("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  qt("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  qt("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]);
var gf = new cp();
var Bp = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Un(e) {
  return (t, r) => {
    let i = t.node.getChild("VariableDefinition");
    return i && r(i, e), true;
  };
}
var XR = ["FunctionDeclaration"];
var jR = {
  FunctionDeclaration: Un("function"),
  ClassDeclaration: Un("class"),
  ClassExpression: () => true,
  EnumDeclaration: Un("constant"),
  TypeAliasDeclaration: Un("type"),
  NamespaceDeclaration: Un("namespace"),
  VariableDefinition(e, t) {
    e.matchContext(XR) || t(e, "variable");
  },
  TypeDefinition(e, t) {
    t(e, "type");
  },
  __proto__: null
};
function $p(e, t) {
  let r = gf.get(t);
  if (r)
    return r;
  let i = [], n = true;
  function a(s, o) {
    let l = e.sliceString(s.from, s.to);
    i.push({ label: l, type: o });
  }
  return t.cursor(st.IncludeAnonymous).iterate((s) => {
    if (n)
      n = false;
    else if (s.name) {
      let o = jR[s.name];
      if (o && o(s, a) || Bp.has(s.name))
        return false;
    } else if (s.to - s.from > 8192) {
      for (let o of $p(e, s.node))
        i.push(o);
      return false;
    }
  }), gf.set(t, i), i;
}
var yf = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
var Yp = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function ZR(e) {
  let t = Ot(e.state).resolveInner(e.pos, -1);
  if (Yp.indexOf(t.name) > -1)
    return null;
  let r = t.name == "VariableName" || t.to - t.from < 20 && yf.test(e.state.sliceDoc(t.from, t.to));
  if (!r && !e.explicit)
    return null;
  let i = [];
  for (let n = t; n; n = n.parent)
    Bp.has(n.name) && (i = i.concat($p(e.state.doc, n)));
  return {
    options: i,
    from: r ? t.from : e.pos,
    validFor: yf
  };
}
var Cr = Si.define({
  name: "javascript",
  parser: FR.configure({
    props: [
      gn.add({
        IfStatement: Gi({ except: /^\s*({|else\b)/ }),
        TryStatement: Gi({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: $S,
        SwitchBody: (e) => {
          let t = e.textAfter, r = /^\s*\}/.test(t), i = /^\s*(case|default)\b/.test(t);
          return e.baseIndent + (r ? 0 : i ? 1 : 2) * e.unit;
        },
        Block: BS({ closing: "}" }),
        ArrowFunction: (e) => e.baseIndent + e.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": Gi({ except: /^{/ }),
        JSXElement(e) {
          let t = /^\s*<\//.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        JSXEscape(e) {
          let t = /\s*\}/.test(e.textAfter);
          return e.lineIndent(e.node.from) + (t ? 0 : e.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        }
      }),
      yn.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Cu,
        BlockComment(e) {
          return { from: e.from + 2, to: e.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
var Fp = {
  test: (e) => /^JSX/.test(e.name),
  facet: Op({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
var Wp = Cr.configure({ dialect: "ts" }, "typescript");
var Xp = Cr.configure({
  dialect: "jsx",
  props: [_u.add((e) => e.isTop ? [Fp] : void 0)]
});
var jp = Cr.configure({
  dialect: "jsx ts",
  props: [_u.add((e) => e.isTop ? [Fp] : void 0)]
}, "typescript");
var Zp = (e) => ({ label: e, type: "keyword" });
var Hp = "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(Zp);
var HR = Hp.concat(["declare", "implements", "private", "protected", "public"].map(Zp));
function zp(e = {}) {
  let t = e.jsx ? e.typescript ? jp : Xp : e.typescript ? Wp : Cr, r = e.typescript ? WR.concat(HR) : Vp.concat(Hp);
  return new Ta(t, [
    Cr.data.of({
      autocomplete: Uu(Yp, Ys(r))
    }),
    Cr.data.of({
      autocomplete: ZR
    }),
    e.jsx ? JR : []
  ]);
}
function zR(e) {
  for (; ; ) {
    if (e.name == "JSXOpenTag" || e.name == "JSXSelfClosingTag" || e.name == "JSXFragmentTag")
      return e;
    if (e.name == "JSXEscape" || !e.parent)
      return null;
    e = e.parent;
  }
}
function If(e, t, r = e.length) {
  for (let i = t == null ? void 0 : t.firstChild; i; i = i.nextSibling)
    if (i.name == "JSXIdentifier" || i.name == "JSXBuiltin" || i.name == "JSXNamespacedName" || i.name == "JSXMemberExpression")
      return e.sliceString(i.from, Math.min(i.to, r));
  return "";
}
var qR = typeof navigator == "object" && /Android\b/.test(navigator.userAgent);
var JR = ua.inputHandler.of((e, t, r, i, n) => {
  if ((qR ? e.composing : e.compositionStarted) || e.state.readOnly || t != r || i != ">" && i != "/" || !Cr.isActiveAt(e.state, t, -1))
    return false;
  let a = n(), { state: s } = a, o = s.changeByRange((l) => {
    var c;
    let { head: f } = l, p = Ot(s).resolveInner(f - 1, -1), O;
    if (p.name == "JSXStartTag" && (p = p.parent), !(s.doc.sliceString(f - 1, f) != i || p.name == "JSXAttributeValue" && p.to > f)) {
      if (i == ">" && p.name == "JSXFragmentTag")
        return { range: l, changes: { from: f, insert: "</>" } };
      if (i == "/" && p.name == "JSXStartCloseTag") {
        let d2 = p.parent, g = d2.parent;
        if (g && d2.from == f - 2 && ((O = If(s.doc, g.firstChild, f)) || ((c = g.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let L = `${O}>`;
          return { range: $2.cursor(f + L.length, -1), changes: { from: f, insert: L } };
        }
      } else if (i == ">") {
        let d2 = zR(p);
        if (d2 && d2.name == "JSXOpenTag" && !/^\/?>|^<\//.test(s.doc.sliceString(f, f + 2)) && (O = If(s.doc, d2, f)))
          return { range: l, changes: { from: f, insert: `</${O}>` } };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? false : (e.dispatch([
    a,
    s.update(o, { userEvent: "input.complete", scrollIntoView: true })
  ]), true);
});
function KR(e, t) {
  return t || (t = {
    parserOptions: { ecmaVersion: 2019, sourceType: "module" },
    env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
    rules: {}
  }, e.getRules().forEach((r, i) => {
    r.meta.docs.recommended && (t.rules[i] = 2);
  })), (r) => {
    let { state: i } = r, n = [];
    for (let { from: a, to: s } of Cr.findRegions(i)) {
      let o = i.doc.lineAt(a), l = { line: o.number - 1, col: a - o.from, pos: a };
      for (let c of e.verify(i.sliceDoc(a, s), t))
        n.push(eA(c, i.doc, l));
    }
    return n;
  };
}
function Nf(e, t, r, i) {
  return r.line(e + i.line).from + t + (e == 1 ? i.col - 1 : -1);
}
function eA(e, t, r) {
  let i = Nf(e.line, e.column, t, r), n = {
    from: i,
    to: e.endLine != null && e.endColumn != 1 ? Nf(e.endLine, e.endColumn, t, r) : i,
    message: e.message,
    source: e.ruleId ? "eslint:" + e.ruleId : "eslint",
    severity: e.severity == 1 ? "warning" : "error"
  };
  if (e.fix) {
    let { range: a, text: s } = e.fix, o = a[0] + r.pos - i, l = a[1] + r.pos - i;
    n.actions = [{
      name: "fix",
      apply(c, f) {
        c.dispatch({ changes: { from: f + o, to: f + l, insert: s }, scrollIntoView: true });
      }
    }];
  }
  return n;
}
var tA = An({
  String: Q.string,
  Number: Q.number,
  "True False": Q.bool,
  PropertyName: Q.propertyName,
  Null: Q.null,
  ",": Q.separator,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
});
var rA = Ri.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [tA],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
});
var iA = () => (e) => {
  try {
    JSON.parse(e.state.doc.toString());
  } catch (t) {
    if (!(t instanceof SyntaxError))
      throw t;
    const r = nA(t, e.state.doc);
    return [{
      from: r,
      message: t.message,
      severity: "error",
      to: r
    }];
  }
  return [];
};
function nA(e, t) {
  let r;
  return (r = e.message.match(/at position (\d+)/)) ? Math.min(+r[1], t.length) : (r = e.message.match(/at line (\d+) column (\d+)/)) ? Math.min(t.line(+r[1]).from + +r[2] - 1, t.length) : 0;
}
var aA = Si.define({
  name: "json",
  parser: rA.configure({
    props: [
      gn.add({
        Object: Gi({ except: /^\s*\}/ }),
        Array: Gi({ except: /^\s*\]/ })
      }),
      yn.add({
        "Object Array": Cu
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function sA() {
  return new Ta(aA);
}
var oA = 36;
var Pf = 1;
var lA = 2;
var wn = 3;
var bo = 4;
var uA = 5;
var cA = 6;
var fA = 7;
var hA = 8;
var pA = 9;
var OA = 10;
var EA = 11;
var dA = 12;
var TA = 13;
var SA = 14;
var mA = 15;
var RA = 16;
var AA = 17;
var _f2 = 18;
var gA = 19;
var qp = 20;
var Jp = 21;
var bf = 22;
var yA = 23;
var IA = 24;
function cl(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 48 && e <= 57;
}
function NA(e) {
  return e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70;
}
function Ci(e, t, r) {
  for (let i = false; ; ) {
    if (e.next < 0)
      return;
    if (e.next == t && !i) {
      e.advance();
      return;
    }
    i = r && !i && e.next == 92, e.advance();
  }
}
function PA(e, t) {
  e:
    for (; ; ) {
      if (e.next < 0)
        return console.log("exit at end", e.pos);
      if (e.next == 36) {
        e.advance();
        for (let r = 0; r < t.length; r++) {
          if (e.next != t.charCodeAt(r))
            continue e;
          e.advance();
        }
        if (e.next == 36) {
          e.advance();
          return;
        }
      } else
        e.advance();
    }
}
function _A(e, t) {
  let r = "[{<(".indexOf(String.fromCharCode(t)), i = r < 0 ? t : "]}>)".charCodeAt(r);
  for (; ; ) {
    if (e.next < 0)
      return;
    if (e.next == i && e.peek(1) == 39) {
      e.advance(2);
      return;
    }
    e.advance();
  }
}
function fl(e, t) {
  for (; !(e.next != 95 && !cl(e.next)); )
    t != null && (t += String.fromCharCode(e.next)), e.advance();
  return t;
}
function bA(e) {
  if (e.next == 39 || e.next == 34 || e.next == 96) {
    let t = e.next;
    e.advance(), Ci(e, t, false);
  } else
    fl(e);
}
function vf(e, t) {
  for (; e.next == 48 || e.next == 49; )
    e.advance();
  t && e.next == t && e.advance();
}
function Cf(e, t) {
  for (; ; ) {
    if (e.next == 46) {
      if (t)
        break;
      t = true;
    } else if (e.next < 48 || e.next > 57)
      break;
    e.advance();
  }
  if (e.next == 69 || e.next == 101)
    for (e.advance(), (e.next == 43 || e.next == 45) && e.advance(); e.next >= 48 && e.next <= 57; )
      e.advance();
}
function Lf(e) {
  for (; !(e.next < 0 || e.next == 10); )
    e.advance();
}
function bi(e, t) {
  for (let r = 0; r < t.length; r++)
    if (t.charCodeAt(r) == e)
      return true;
  return false;
}
var vo = ` 	\r
`;
function Kp(e, t, r) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = uA, i.null = i.unknown = cA;
  for (let n of e.split(" "))
    n && (i[n] = qp);
  for (let n of t.split(" "))
    n && (i[n] = Jp);
  for (let n of (r || "").split(" "))
    n && (i[n] = IA);
  return i;
}
var vA = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ";
var CA = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ";
var hl = {
  backslashEscapes: false,
  hashComments: false,
  spaceAfterDashes: false,
  slashComments: false,
  doubleQuotedStrings: false,
  doubleDollarQuotedStrings: false,
  unquotedBitLiterals: false,
  treatBitsAsBytes: false,
  charSetCasts: false,
  plsqlQuotingMechanism: false,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: Kp(CA, vA)
};
function LA2(e, t, r, i) {
  let n = {};
  for (let a in hl)
    n[a] = (e.hasOwnProperty(a) ? e : hl)[a];
  return t && (n.words = Kp(t, r || "", i)), n;
}
function eO(e) {
  return new mr((t) => {
    var r;
    let { next: i } = t;
    if (t.advance(), bi(i, vo)) {
      for (; bi(t.next, vo); )
        t.advance();
      t.acceptToken(oA);
    } else if (i == 36 && e.doubleDollarQuotedStrings) {
      let n = fl(t, "");
      t.next == 36 && (t.advance(), PA(t, n), t.acceptToken(wn));
    } else if (i == 39 || i == 34 && e.doubleQuotedStrings)
      Ci(t, i, e.backslashEscapes), t.acceptToken(wn);
    else if (i == 35 && e.hashComments || i == 47 && t.next == 47 && e.slashComments)
      Lf(t), t.acceptToken(Pf);
    else if (i == 45 && t.next == 45 && (!e.spaceAfterDashes || t.peek(1) == 32))
      Lf(t), t.acceptToken(Pf);
    else if (i == 47 && t.next == 42) {
      t.advance();
      for (let n = 1; ; ) {
        let a = t.next;
        if (t.next < 0)
          break;
        if (t.advance(), a == 42 && t.next == 47) {
          if (n--, t.advance(), !n)
            break;
        } else
          a == 47 && t.next == 42 && (n++, t.advance());
      }
      t.acceptToken(lA);
    } else if ((i == 101 || i == 69) && t.next == 39)
      t.advance(), Ci(t, 39, true);
    else if ((i == 110 || i == 78) && t.next == 39 && e.charSetCasts)
      t.advance(), Ci(t, 39, e.backslashEscapes), t.acceptToken(wn);
    else if (i == 95 && e.charSetCasts)
      for (let n = 0; ; n++) {
        if (t.next == 39 && n > 1) {
          t.advance(), Ci(t, 39, e.backslashEscapes), t.acceptToken(wn);
          break;
        }
        if (!cl(t.next))
          break;
        t.advance();
      }
    else if (e.plsqlQuotingMechanism && (i == 113 || i == 81) && t.next == 39 && t.peek(1) > 0 && !bi(t.peek(1), vo)) {
      let n = t.peek(1);
      t.advance(2), _A(t, n), t.acceptToken(wn);
    } else if (i == 40)
      t.acceptToken(fA);
    else if (i == 41)
      t.acceptToken(hA);
    else if (i == 123)
      t.acceptToken(pA);
    else if (i == 125)
      t.acceptToken(OA);
    else if (i == 91)
      t.acceptToken(EA);
    else if (i == 93)
      t.acceptToken(dA);
    else if (i == 59)
      t.acceptToken(TA);
    else if (e.unquotedBitLiterals && i == 48 && t.next == 98)
      t.advance(), vf(t), t.acceptToken(bf);
    else if ((i == 98 || i == 66) && (t.next == 39 || t.next == 34)) {
      const n = t.next;
      t.advance(), e.treatBitsAsBytes ? (Ci(t, n, e.backslashEscapes), t.acceptToken(yA)) : (vf(t, n), t.acceptToken(bf));
    } else if (i == 48 && (t.next == 120 || t.next == 88) || (i == 120 || i == 88) && t.next == 39) {
      let n = t.next == 39;
      for (t.advance(); NA(t.next); )
        t.advance();
      n && t.next == 39 && t.advance(), t.acceptToken(bo);
    } else if (i == 46 && t.next >= 48 && t.next <= 57)
      Cf(t, true), t.acceptToken(bo);
    else if (i == 46)
      t.acceptToken(SA);
    else if (i >= 48 && i <= 57)
      Cf(t, false), t.acceptToken(bo);
    else if (bi(i, e.operatorChars)) {
      for (; bi(t.next, e.operatorChars); )
        t.advance();
      t.acceptToken(mA);
    } else if (bi(i, e.specialVar))
      t.next == i && t.advance(), bA(t), t.acceptToken(AA);
    else if (bi(i, e.identifierQuotes))
      Ci(t, i, false), t.acceptToken(gA);
    else if (i == 58 || i == 44)
      t.acceptToken(RA);
    else if (cl(i)) {
      let n = fl(t, String.fromCharCode(i));
      t.acceptToken(t.next == 46 || t.peek(-n.length - 1) == 46 ? _f2 : (r = e.words[n.toLowerCase()]) !== null && r !== void 0 ? r : _f2);
    }
  });
}
var tO = eO(hl);
var xA = Ri.deserialize({
  version: 14,
  states: "%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw",
  stateData: ",[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O",
  goto: "#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq",
  nodeNames: " LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 38,
  nodeProps: [
    ["isolate", -4, 1, 2, 3, 19, ""]
  ],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, tO],
  topRules: { Script: [0, 25] },
  tokenPrec: 0
});
function pl(e) {
  let t = e.cursor().moveTo(e.from, -1);
  for (; /Comment/.test(t.name); )
    t.moveTo(t.from, -1);
  return t.node;
}
function ia(e, t) {
  let r = e.sliceString(t.from, t.to), i = /^([`'"])(.*)\1$/.exec(r);
  return i ? i[2] : r;
}
function Ss(e) {
  return e && (e.name == "Identifier" || e.name == "QuotedIdentifier");
}
function DA(e, t) {
  if (t.name == "CompositeIdentifier") {
    let r = [];
    for (let i = t.firstChild; i; i = i.nextSibling)
      Ss(i) && r.push(ia(e, i));
    return r;
  }
  return [ia(e, t)];
}
function xf(e, t) {
  for (let r = []; ; ) {
    if (!t || t.name != ".")
      return r;
    let i = pl(t);
    if (!Ss(i))
      return r;
    r.unshift(ia(e, i)), t = pl(i);
  }
}
function UA(e, t) {
  let r = Ot(e).resolveInner(t, -1), i = MA(e.doc, r);
  return r.name == "Identifier" || r.name == "QuotedIdentifier" || r.name == "Keyword" ? {
    from: r.from,
    quoted: r.name == "QuotedIdentifier" ? e.doc.sliceString(r.from, r.from + 1) : null,
    parents: xf(e.doc, pl(r)),
    aliases: i
  } : r.name == "." ? { from: t, quoted: null, parents: xf(e.doc, r), aliases: i } : { from: t, quoted: null, parents: [], empty: true, aliases: i };
}
var wA = new Set("where group having order union intersect except all distinct limit offset fetch for".split(" "));
function MA(e, t) {
  let r;
  for (let n = t; !r; n = n.parent) {
    if (!n)
      return null;
    n.name == "Statement" && (r = n);
  }
  let i = null;
  for (let n = r.firstChild, a = false, s = null; n; n = n.nextSibling) {
    let o = n.name == "Keyword" ? e.sliceString(n.from, n.to).toLowerCase() : null, l = null;
    if (!a)
      a = o == "from";
    else if (o == "as" && s && Ss(n.nextSibling))
      l = ia(e, n.nextSibling);
    else {
      if (o && wA.has(o))
        break;
      s && Ss(n) && (l = ia(e, n));
    }
    l && (i || (i = /* @__PURE__ */ Object.create(null)), i[l] = DA(e, s)), s = /Identifier$/.test(n.name) ? n : null;
  }
  return i;
}
function kA(e, t) {
  return e ? t.map((r) => Object.assign(Object.assign({}, r), { label: r.label[0] == e ? r.label : e + r.label + e, apply: void 0 })) : t;
}
var QA = /^\w*$/;
var GA = /^[`'"]?\w*[`'"]?$/;
function Df(e) {
  return e.self && typeof e.self.label == "string";
}
var $u = class _$u {
  constructor(t) {
    this.idQuote = t, this.list = [], this.children = void 0;
  }
  child(t) {
    let r = this.children || (this.children = /* @__PURE__ */ Object.create(null)), i = r[t];
    return i || (t && !this.list.some((n) => n.label == t) && this.list.push(Uf(t, "type", this.idQuote)), r[t] = new _$u(this.idQuote));
  }
  maybeChild(t) {
    return this.children ? this.children[t] : null;
  }
  addCompletion(t) {
    let r = this.list.findIndex((i) => i.label == t.label);
    r > -1 ? this.list[r] = t : this.list.push(t);
  }
  addCompletions(t) {
    for (let r of t)
      this.addCompletion(typeof r == "string" ? Uf(r, "property", this.idQuote) : r);
  }
  addNamespace(t) {
    Array.isArray(t) ? this.addCompletions(t) : Df(t) ? this.addNamespace(t.children) : this.addNamespaceObject(t);
  }
  addNamespaceObject(t) {
    for (let r of Object.keys(t)) {
      let i = t[r], n = null, a = r.replace(/\\?\./g, (o) => o == "." ? "\0" : o).split("\0"), s = this;
      Df(i) && (n = i.self, i = i.children);
      for (let o = 0; o < a.length; o++)
        n && o == a.length - 1 && s.addCompletion(n), s = s.child(a[o].replace(/\\\./g, "."));
      s.addNamespace(i);
    }
  }
};
function Uf(e, t, r) {
  return /^[a-z_][a-z_\d]*$/.test(e) ? { label: e, type: t } : { label: e, type: t, apply: r + e + r };
}
function VA(e, t, r, i, n, a) {
  var s;
  let o = ((s = a == null ? void 0 : a.spec.identifierQuotes) === null || s === void 0 ? void 0 : s[0]) || '"', l = new $u(o), c = n ? l.child(n) : null;
  return l.addNamespace(e), t && (c || l).addCompletions(t), r && l.addCompletions(r), c && l.addCompletions(c.list), i && l.addCompletions((c || l).child(i).list), (f) => {
    let { parents: p, from: O, quoted: d2, empty: g, aliases: L } = UA(f.state, f.pos);
    if (g && !f.explicit)
      return null;
    L && p.length == 1 && (p = L[p[0]] || p);
    let D = l;
    for (let V of p) {
      for (; !D.children || !D.children[V]; )
        if (D == l)
          D = c;
        else if (D == c && i)
          D = D.child(i);
        else
          return null;
      let _2 = D.maybeChild(V);
      if (!_2)
        return null;
      D = _2;
    }
    let W = d2 && f.state.sliceDoc(f.pos, f.pos + 1) == d2, x = D.list;
    return D == l && L && (x = x.concat(Object.keys(L).map((V) => ({ label: V, type: "constant" })))), {
      from: O,
      to: W ? f.pos + 1 : void 0,
      options: kA(d2, x),
      validFor: d2 ? GA : QA
    };
  };
}
function BA(e, t) {
  let r = Object.keys(e).map((i) => ({
    label: t ? i.toUpperCase() : i,
    type: e[i] == Jp ? "type" : e[i] == qp ? "keyword" : "variable",
    boost: -1
  }));
  return Uu(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Ys(r));
}
var $A = xA.configure({
  props: [
    gn.add({
      Statement: Gi()
    }),
    yn.add({
      Statement(e) {
        return { from: e.firstChild.to, to: e.to };
      },
      BlockComment(e) {
        return { from: e.from + 2, to: e.to - 2 };
      }
    }),
    An({
      Keyword: Q.keyword,
      Type: Q.typeName,
      Builtin: Q.standard(Q.name),
      Bits: Q.number,
      Bytes: Q.string,
      Bool: Q.bool,
      Null: Q.null,
      Number: Q.number,
      String: Q.string,
      Identifier: Q.name,
      QuotedIdentifier: Q.special(Q.string),
      SpecialVar: Q.special(Q.name),
      LineComment: Q.lineComment,
      BlockComment: Q.blockComment,
      Operator: Q.operator,
      "Semi Punctuation": Q.punctuation,
      "( )": Q.paren,
      "{ }": Q.brace,
      "[ ]": Q.squareBracket
    })
  ]
});
var Yu = class _Yu {
  constructor(t, r, i) {
    this.dialect = t, this.language = r, this.spec = i;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(t) {
    let r = LA2(t, t.keywords, t.types, t.builtin), i = Si.define({
      name: "sql",
      parser: $A.configure({
        tokenizers: [{ from: tO, to: eO(r) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new _Yu(r, i, t);
  }
};
function YA(e, t = false) {
  return BA(e.dialect.words, t);
}
function FA(e, t = false) {
  return e.language.data.of({
    autocomplete: YA(e, t)
  });
}
function WA(e) {
  return e.schema ? VA(e.schema, e.tables, e.schemas, e.defaultTable, e.defaultSchema, e.dialect || Fu) : () => null;
}
function XA(e) {
  return e.schema ? (e.dialect || Fu).language.data.of({
    autocomplete: WA(e)
  }) : [];
}
function jA(e = {}) {
  let t = e.dialect || Fu;
  return new Ta(t.language, [XA(e), FA(t, !!e.upperCaseKeywords)]);
}
var Fu = Yu.define({});
var ZA = 99;
var wf = 1;
var HA = 100;
var zA = 101;
var Mf = 2;
var rO = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var qA = 58;
var JA = 40;
var iO = 95;
var KA = 91;
var rs = 45;
var eg = 46;
var tg = 35;
var rg = 37;
var ig = 38;
var ng = 92;
var ag = 10;
function na(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122 || e >= 161;
}
function nO(e) {
  return e >= 48 && e <= 57;
}
var sg = new mr((e, t) => {
  for (let r = false, i = 0, n = 0; ; n++) {
    let { next: a } = e;
    if (na(a) || a == rs || a == iO || r && nO(a))
      !r && (a != rs || n > 0) && (r = true), i === n && a == rs && i++, e.advance();
    else if (a == ng && e.peek(1) != ag)
      e.advance(), e.next > -1 && e.advance(), r = true;
    else {
      r && e.acceptToken(a == JA ? HA : i == 2 && t.canShift(Mf) ? Mf : zA);
      break;
    }
  }
});
var og = new mr((e) => {
  if (rO.includes(e.peek(-1))) {
    let { next: t } = e;
    (na(t) || t == iO || t == tg || t == eg || t == KA || t == qA && na(e.peek(1)) || t == rs || t == ig) && e.acceptToken(ZA);
  }
});
var lg = new mr((e) => {
  if (!rO.includes(e.peek(-1))) {
    let { next: t } = e;
    if (t == rg && (e.advance(), e.acceptToken(wf)), na(t)) {
      do
        e.advance();
      while (na(e.next) || nO(e.next));
      e.acceptToken(wf);
    }
  }
});
var ug = An({
  "AtKeyword import charset namespace keyframes media supports": Q.definitionKeyword,
  "from to selector": Q.keyword,
  NamespaceName: Q.namespace,
  KeyframeName: Q.labelName,
  KeyframeRangeName: Q.operatorKeyword,
  TagName: Q.tagName,
  ClassName: Q.className,
  PseudoClassName: Q.constant(Q.className),
  IdName: Q.labelName,
  "FeatureName PropertyName": Q.propertyName,
  AttributeName: Q.attributeName,
  NumberLiteral: Q.number,
  KeywordQuery: Q.keyword,
  UnaryQueryOp: Q.operatorKeyword,
  "CallTag ValueName": Q.atom,
  VariableName: Q.variableName,
  Callee: Q.operatorKeyword,
  Unit: Q.unit,
  "UniversalSelector NestingSelector": Q.definitionOperator,
  MatchOp: Q.compareOperator,
  "ChildOp SiblingOp, LogicOp": Q.logicOperator,
  BinOp: Q.arithmeticOperator,
  Important: Q.modifier,
  Comment: Q.blockComment,
  ColorLiteral: Q.color,
  "ParenthesizedContent StringLiteral": Q.string,
  ":": Q.punctuation,
  "PseudoOp #": Q.derefOperator,
  "; ,": Q.separator,
  "( )": Q.paren,
  "[ ]": Q.squareBracket,
  "{ }": Q.brace
});
var cg = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 };
var fg = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 };
var hg = { __proto__: null, not: 132, only: 132 };
var pg = Ri.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [ug],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [og, lg, sg, 1, 2, 3, 4, new Ts("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (e) => cg[e] || -1 }, { term: 58, get: (e) => fg[e] || -1 }, { term: 101, get: (e) => hg[e] || -1 }],
  tokenPrec: 1200
});
var Co = null;
function Lo() {
  if (!Co && typeof document == "object" && document.body) {
    let { style: e } = document.body, t = [], r = /* @__PURE__ */ new Set();
    for (let i in e)
      i != "cssText" && i != "cssFloat" && typeof e[i] == "string" && (/[A-Z]/.test(i) && (i = i.replace(/[A-Z]/g, (n) => "-" + n.toLowerCase())), r.has(i) || (t.push(i), r.add(i)));
    Co = t.sort().map((i) => ({ type: "property", label: i }));
  }
  return Co || [];
}
var kf = [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((e) => ({ type: "class", label: e }));
var Qf = [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((e) => ({ type: "keyword", label: e })).concat([
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((e) => ({ type: "constant", label: e })));
var Og = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((e) => ({ type: "type", label: e }));
var ci2 = /^(\w[\w-]*|-\w[\w-]*|)$/;
var Eg2 = /^-(-[\w-]*)?$/;
function dg(e, t) {
  var r;
  if ((e.name == "(" || e.type.isError) && (e = e.parent || e), e.name != "ArgList")
    return false;
  let i = (r = e.parent) === null || r === void 0 ? void 0 : r.firstChild;
  return (i == null ? void 0 : i.name) != "Callee" ? false : t.sliceString(i.from, i.to) == "var";
}
var Gf = new cp();
var Tg = ["Declaration"];
function Sg(e) {
  for (let t = e; ; ) {
    if (t.type.isTop)
      return t;
    if (!(t = t.parent))
      return e;
  }
}
function aO(e, t, r) {
  if (t.to - t.from > 4096) {
    let i = Gf.get(t);
    if (i)
      return i;
    let n = [], a = /* @__PURE__ */ new Set(), s = t.cursor(st.IncludeAnonymous);
    if (s.firstChild())
      do
        for (let o of aO(e, s.node, r))
          a.has(o.label) || (a.add(o.label), n.push(o));
      while (s.nextSibling());
    return Gf.set(t, n), n;
  } else {
    let i = [], n = /* @__PURE__ */ new Set();
    return t.cursor().iterate((a) => {
      var s;
      if (r(a) && a.matchContext(Tg) && ((s = a.node.nextSibling) === null || s === void 0 ? void 0 : s.name) == ":") {
        let o = e.sliceString(a.from, a.to);
        n.has(o) || (n.add(o), i.push({ label: o, type: "variable" }));
      }
    }), i;
  }
}
var mg = (e) => (t) => {
  let { state: r, pos: i } = t, n = Ot(r).resolveInner(i, -1), a = n.type.isError && n.from == n.to - 1 && r.doc.sliceString(n.from, n.to) == "-";
  if (n.name == "PropertyName" || (a || n.name == "TagName") && /^(Block|Styles)$/.test(n.resolve(n.to).name))
    return { from: n.from, options: Lo(), validFor: ci2 };
  if (n.name == "ValueName")
    return { from: n.from, options: Qf, validFor: ci2 };
  if (n.name == "PseudoClassName")
    return { from: n.from, options: kf, validFor: ci2 };
  if (e(n) || (t.explicit || a) && dg(n, r.doc))
    return {
      from: e(n) || a ? n.from : i,
      options: aO(r.doc, Sg(n), e),
      validFor: Eg2
    };
  if (n.name == "TagName") {
    for (let { parent: l } = n; l; l = l.parent)
      if (l.name == "Block")
        return { from: n.from, options: Lo(), validFor: ci2 };
    return { from: n.from, options: Og, validFor: ci2 };
  }
  if (!t.explicit)
    return null;
  let s = n.resolve(i), o = s.childBefore(i);
  return o && o.name == ":" && s.name == "PseudoClassSelector" ? { from: i, options: kf, validFor: ci2 } : o && o.name == ":" && s.name == "Declaration" || s.name == "ArgList" ? { from: i, options: Qf, validFor: ci2 } : s.name == "Block" || s.name == "Styles" ? { from: i, options: Lo(), validFor: ci2 } : null;
};
var Rg = mg((e) => e.name == "VariableName");
var ms = Si.define({
  name: "css",
  parser: pg.configure({
    props: [
      gn.add({
        Declaration: Gi()
      }),
      yn.add({
        "Block KeyframeList": Cu
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function sO() {
  return new Ta(ms, ms.data.of({ autocomplete: Rg }));
}
var Ag = 54;
var gg = 1;
var yg = 55;
var Ig = 2;
var Ng = 56;
var Pg = 3;
var Vf = 4;
var _g = 5;
var Rs = 6;
var oO = 7;
var lO = 8;
var uO = 9;
var cO = 10;
var bg2 = 11;
var vg = 12;
var Cg = 13;
var xo = 57;
var Lg = 14;
var Bf = 58;
var fO = 20;
var xg = 22;
var hO = 23;
var Dg = 24;
var Ol = 26;
var pO = 27;
var Ug = 28;
var wg = 31;
var Mg = 34;
var kg = 36;
var Qg = 37;
var Gg = 0;
var Vg = 1;
var Bg = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
var $g = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
var $f = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function Yg(e) {
  return e == 45 || e == 46 || e == 58 || e >= 65 && e <= 90 || e == 95 || e >= 97 && e <= 122 || e >= 161;
}
function OO(e) {
  return e == 9 || e == 10 || e == 13 || e == 32;
}
var Yf = null;
var Ff2 = null;
var Wf = 0;
function El(e, t) {
  let r = e.pos + t;
  if (Wf == r && Ff2 == e)
    return Yf;
  let i = e.peek(t);
  for (; OO(i); )
    i = e.peek(++t);
  let n = "";
  for (; Yg(i); )
    n += String.fromCharCode(i), i = e.peek(++t);
  return Ff2 = e, Wf = r, Yf = n ? n.toLowerCase() : i == Fg || i == Wg ? void 0 : null;
}
var EO = 60;
var As = 62;
var Wu = 47;
var Fg = 63;
var Wg = 33;
var Xg = 45;
function Xf(e, t) {
  this.name = e, this.parent = t, this.hash = t ? t.hash : 0;
  for (let r = 0; r < e.length; r++)
    this.hash += (this.hash << 4) + e.charCodeAt(r) + (e.charCodeAt(r) << 8);
}
var jg = [Rs, cO, oO, lO, uO];
var Zg = new Qp({
  start: null,
  shift(e, t, r, i) {
    return jg.indexOf(t) > -1 ? new Xf(El(i, 1) || "", e) : e;
  },
  reduce(e, t) {
    return t == fO && e ? e.parent : e;
  },
  reuse(e, t, r, i) {
    let n = t.type.id;
    return n == Rs || n == kg ? new Xf(El(i, 1) || "", e) : e;
  },
  hash(e) {
    return e ? e.hash : 0;
  },
  strict: false
});
var Hg = new mr((e, t) => {
  if (e.next != EO) {
    e.next < 0 && t.context && e.acceptToken(xo);
    return;
  }
  e.advance();
  let r = e.next == Wu;
  r && e.advance();
  let i = El(e, 0);
  if (i === void 0)
    return;
  if (!i)
    return e.acceptToken(r ? Lg : Rs);
  let n = t.context ? t.context.name : null;
  if (r) {
    if (i == n)
      return e.acceptToken(bg2);
    if (n && $g[n])
      return e.acceptToken(xo, -2);
    if (t.dialectEnabled(Gg))
      return e.acceptToken(vg);
    for (let a = t.context; a; a = a.parent)
      if (a.name == i)
        return;
    e.acceptToken(Cg);
  } else {
    if (i == "script")
      return e.acceptToken(oO);
    if (i == "style")
      return e.acceptToken(lO);
    if (i == "textarea")
      return e.acceptToken(uO);
    if (Bg.hasOwnProperty(i))
      return e.acceptToken(cO);
    n && $f[n] && $f[n][i] ? e.acceptToken(xo, -1) : e.acceptToken(Rs);
  }
}, { contextual: true });
var zg = new mr((e) => {
  for (let t = 0, r = 0; ; r++) {
    if (e.next < 0) {
      r && e.acceptToken(Bf);
      break;
    }
    if (e.next == Xg)
      t++;
    else if (e.next == As && t >= 2) {
      r >= 3 && e.acceptToken(Bf, -2);
      break;
    } else
      t = 0;
    e.advance();
  }
});
function qg(e) {
  for (; e; e = e.parent)
    if (e.name == "svg" || e.name == "math")
      return true;
  return false;
}
var Jg = new mr((e, t) => {
  if (e.next == Wu && e.peek(1) == As) {
    let r = t.dialectEnabled(Vg) || qg(t.context);
    e.acceptToken(r ? _g : Vf, 2);
  } else
    e.next == As && e.acceptToken(Vf, 1);
});
function Xu(e, t, r) {
  let i = 2 + e.length;
  return new mr((n) => {
    for (let a = 0, s = 0, o = 0; ; o++) {
      if (n.next < 0) {
        o && n.acceptToken(t);
        break;
      }
      if (a == 0 && n.next == EO || a == 1 && n.next == Wu || a >= 2 && a < i && n.next == e.charCodeAt(a - 2))
        a++, s++;
      else if ((a == 2 || a == i) && OO(n.next))
        s++;
      else if (a == i && n.next == As) {
        o > s ? n.acceptToken(t, -s) : n.acceptToken(r, -(s - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && o) {
        n.acceptToken(t, 1);
        break;
      } else
        a = s = 0;
      n.advance();
    }
  });
}
var Kg = Xu("script", Ag, gg);
var ey = Xu("style", yg, Ig);
var ty = Xu("textarea", Ng, Pg);
var ry = An({
  "Text RawText": Q.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": Q.angleBracket,
  TagName: Q.tagName,
  "MismatchedCloseTag/TagName": [Q.tagName, Q.invalid],
  AttributeName: Q.attributeName,
  "AttributeValue UnquotedAttributeValue": Q.attributeValue,
  Is: Q.definitionOperator,
  "EntityReference CharacterReference": Q.character,
  Comment: Q.blockComment,
  ProcessingInst: Q.processingInstruction,
  DoctypeDecl: Q.documentMeta
});
var iy = Ri.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Zg,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [ry],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [Kg, ey, ty, Jg, Hg, zg, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function dO(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let i of e.getChildren(hO)) {
    let n = i.getChild(Dg), a = i.getChild(Ol) || i.getChild(pO);
    n && (r[t.read(n.from, n.to)] = a ? a.type.id == Ol ? t.read(a.from + 1, a.to - 1) : t.read(a.from, a.to) : "");
  }
  return r;
}
function jf(e, t) {
  let r = e.getChild(xg);
  return r ? t.read(r.from, r.to) : " ";
}
function Do(e, t, r) {
  let i;
  for (let n of r)
    if (!n.attrs || n.attrs(i || (i = dO(e.node.parent.firstChild, t))))
      return { parser: n.parser };
  return null;
}
function TO(e = [], t = []) {
  let r = [], i = [], n = [], a = [];
  for (let o of e)
    (o.tag == "script" ? r : o.tag == "style" ? i : o.tag == "textarea" ? n : a).push(o);
  let s = t.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let o of t)
    (s[o.name] || (s[o.name] = [])).push(o);
  return TS2((o, l) => {
    let c = o.type.id;
    if (c == Ug)
      return Do(o, l, r);
    if (c == wg)
      return Do(o, l, i);
    if (c == Mg)
      return Do(o, l, n);
    if (c == fO && a.length) {
      let f = o.node, p = f.firstChild, O = p && jf(p, l), d2;
      if (O) {
        for (let g of a)
          if (g.tag == O && (!g.attrs || g.attrs(d2 || (d2 = dO(f, l))))) {
            let L = f.lastChild, D = L.type.id == Qg ? L.from : f.to;
            if (D > p.to)
              return { parser: g.parser, overlay: [{ from: p.to, to: D }] };
          }
      }
    }
    if (s && c == hO) {
      let f = o.node, p;
      if (p = f.firstChild) {
        let O = s[l.read(p.from, p.to)];
        if (O)
          for (let d2 of O) {
            if (d2.tagName && d2.tagName != jf(f.parent, l))
              continue;
            let g = f.lastChild;
            if (g.type.id == Ol) {
              let L = g.from + 1, D = g.lastChild, W = g.to - (D && D.isError ? 0 : 1);
              if (W > L)
                return { parser: d2.parser, overlay: [{ from: L, to: W }] };
            } else if (g.type.id == pO)
              return { parser: d2.parser, overlay: [{ from: g.from, to: g.to }] };
          }
      }
    }
    return null;
  });
}
var Mn = ["_blank", "_self", "_top", "_parent"];
var Uo = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
var wo = ["get", "post", "put", "delete"];
var Mo = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
var rr = ["true", "false"];
var Oe = {};
var ny = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Mn,
      hreflang: null
    }
  },
  abbr: Oe,
  address: Oe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Oe,
  aside: Oe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Oe,
  base: { attrs: { href: null, target: Mn } },
  bdi: Oe,
  bdo: Oe,
  blockquote: { attrs: { cite: null } },
  body: Oe,
  br: Oe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Mo,
      formmethod: wo,
      formnovalidate: ["novalidate"],
      formtarget: Mn,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Oe,
  center: Oe,
  cite: Oe,
  code: Oe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Oe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Oe,
  div: Oe,
  dl: Oe,
  dt: Oe,
  em: Oe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Oe,
  figure: Oe,
  footer: Oe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Uo,
      autocomplete: ["on", "off"],
      enctype: Mo,
      method: wo,
      novalidate: ["novalidate"],
      target: Mn
    }
  },
  h1: Oe,
  h2: Oe,
  h3: Oe,
  h4: Oe,
  h5: Oe,
  h6: Oe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Oe,
  hgroup: Oe,
  hr: Oe,
  html: {
    attrs: { manifest: null }
  },
  i: Oe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Mo,
      formmethod: wo,
      formnovalidate: ["novalidate"],
      formtarget: Mn,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Oe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Oe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Oe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Uo,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Oe,
  noscript: Oe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Oe,
  param: { attrs: { name: null, value: null } },
  pre: Oe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Oe,
  rt: Oe,
  ruby: Oe,
  samp: Oe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Uo
    }
  },
  section: Oe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Oe,
  source: { attrs: { src: null, type: null, media: null } },
  span: Oe,
  strong: Oe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Oe,
  summary: Oe,
  sup: Oe,
  table: Oe,
  tbody: Oe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Oe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Oe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Oe,
  time: { attrs: { datetime: null } },
  title: Oe,
  tr: Oe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Oe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Oe
};
var SO = {
  accesskey: null,
  class: null,
  contenteditable: rr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: rr,
  autocorrect: rr,
  autocapitalize: rr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": rr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": rr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": rr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": rr,
  "aria-hidden": rr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": rr,
  "aria-multiselectable": rr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": rr,
  "aria-relevant": null,
  "aria-required": rr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
var mO = "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((e) => "on" + e);
for (let e of mO)
  SO[e] = null;
var gs2 = class {
  constructor(t, r) {
    this.tags = Object.assign(Object.assign({}, ny), t), this.globalAttrs = Object.assign(Object.assign({}, SO), r), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
gs2.default = new gs2();
function fn(e, t, r = e.length) {
  if (!t)
    return "";
  let i = t.firstChild, n = i && i.getChild("TagName");
  return n ? e.sliceString(n.from, Math.min(n.to, r)) : "";
}
function hn(e, t = false) {
  for (; e; e = e.parent)
    if (e.name == "Element")
      if (t)
        t = false;
      else
        return e;
  return null;
}
function RO(e, t, r) {
  let i = r.tags[fn(e, hn(t))];
  return (i == null ? void 0 : i.children) || r.allTags;
}
function ju(e, t) {
  let r = [];
  for (let i = hn(t); i && !i.type.isTop; i = hn(i.parent)) {
    let n = fn(e, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && r.indexOf(n) < 0 && (t.name == "EndTag" || t.from >= i.firstChild.to) && r.push(n);
  }
  return r;
}
var AO = /^[:\-\.\w\u00b7-\uffff]*$/;
function Zf(e, t, r, i, n) {
  let a = /\s*>/.test(e.sliceDoc(n, n + 5)) ? "" : ">", s = hn(r, true);
  return {
    from: i,
    to: n,
    options: RO(e.doc, s, t).map((o) => ({ label: o, type: "type" })).concat(ju(e.doc, r).map((o, l) => ({
      label: "/" + o,
      apply: "/" + o + a,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Hf(e, t, r, i) {
  let n = /\s*>/.test(e.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: r,
    to: i,
    options: ju(e.doc, t).map((a, s) => ({ label: a, apply: a + n, type: "type", boost: 99 - s })),
    validFor: AO
  };
}
function ay(e, t, r, i) {
  let n = [], a = 0;
  for (let s of RO(e.doc, r, t))
    n.push({ label: "<" + s, type: "type" });
  for (let s of ju(e.doc, r))
    n.push({ label: "</" + s + ">", type: "type", boost: 99 - a++ });
  return { from: i, to: i, options: n, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function sy(e, t, r, i, n) {
  let a = hn(r), s = a ? t.tags[fn(e.doc, a)] : null, o = s && s.attrs ? Object.keys(s.attrs) : [], l = s && s.globalAttrs === false ? o : o.length ? o.concat(t.globalAttrNames) : t.globalAttrNames;
  return {
    from: i,
    to: n,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: AO
  };
}
function oy(e, t, r, i, n) {
  var a;
  let s = (a = r.parent) === null || a === void 0 ? void 0 : a.getChild("AttributeName"), o = [], l;
  if (s) {
    let c = e.sliceDoc(s.from, s.to), f = t.globalAttrs[c];
    if (!f) {
      let p = hn(r), O = p ? t.tags[fn(e.doc, p)] : null;
      f = (O == null ? void 0 : O.attrs) && O.attrs[c];
    }
    if (f) {
      let p = e.sliceDoc(i, n).toLowerCase(), O = '"', d2 = '"';
      /^['"]/.test(p) ? (l = p[0] == '"' ? /^[^"]*$/ : /^[^']*$/, O = "", d2 = e.sliceDoc(n, n + 1) == p[0] ? "" : p[0], p = p.slice(1), i++) : l = /^[^\s<>='"]*$/;
      for (let g of f)
        o.push({ label: g, apply: O + g + d2, type: "constant" });
    }
  }
  return { from: i, to: n, options: o, validFor: l };
}
function ly(e, t) {
  let { state: r, pos: i } = t, n = Ot(r).resolveInner(i, -1), a = n.resolve(i);
  for (let s = i, o; a == n && (o = n.childBefore(s)); ) {
    let l = o.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    a = n = o, s = l.from;
  }
  return n.name == "TagName" ? n.parent && /CloseTag$/.test(n.parent.name) ? Hf(r, n, n.from, i) : Zf(r, e, n, n.from, i) : n.name == "StartTag" ? Zf(r, e, n, i, i) : n.name == "StartCloseTag" || n.name == "IncompleteCloseTag" ? Hf(r, n, i, i) : n.name == "OpenTag" || n.name == "SelfClosingTag" || n.name == "AttributeName" ? sy(r, e, n, n.name == "AttributeName" ? n.from : i, i) : n.name == "Is" || n.name == "AttributeValue" || n.name == "UnquotedAttributeValue" ? oy(r, e, n, n.name == "Is" ? i : n.from, i) : t.explicit && (a.name == "Element" || a.name == "Text" || a.name == "Document") ? ay(r, e, n, i) : null;
}
function uy(e) {
  let { extraTags: t, extraGlobalAttributes: r } = e, i = r || t ? new gs2(t, r) : gs2.default;
  return (n) => ly(i, n);
}
var cy = Cr.parser.configure({ top: "SingleExpression" });
var gO = [
  {
    tag: "script",
    attrs: (e) => e.type == "text/typescript" || e.lang == "ts",
    parser: Wp.parser
  },
  {
    tag: "script",
    attrs: (e) => e.type == "text/babel" || e.type == "text/jsx",
    parser: Xp.parser
  },
  {
    tag: "script",
    attrs: (e) => e.type == "text/typescript-jsx",
    parser: jp.parser
  },
  {
    tag: "script",
    attrs(e) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(e.type);
    },
    parser: cy
  },
  {
    tag: "script",
    attrs(e) {
      return !e.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(e.type);
    },
    parser: Cr.parser
  },
  {
    tag: "style",
    attrs(e) {
      return (!e.lang || e.lang == "css") && (!e.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(e.type));
    },
    parser: ms.parser
  }
];
var yO = [
  {
    name: "style",
    parser: ms.parser.configure({ top: "Styles" })
  }
].concat(mO.map((e) => ({ name: e, parser: Cr.parser })));
var IO = Si.define({
  name: "html",
  parser: iy.configure({
    props: [
      gn.add({
        Element(e) {
          let t = /^(\s*)(<\/)?/.exec(e.textAfter);
          return e.node.to <= e.pos + t[0].length ? e.continue() : e.lineIndent(e.node.from) + (t[2] ? 0 : e.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(e) {
          return e.column(e.node.from) + e.unit;
        },
        Document(e) {
          if (e.pos + /\s*/.exec(e.textAfter)[0].length < e.node.to)
            return e.continue();
          let t = null, r;
          for (let i = e.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            t = i = n;
          }
          return t && !((r = t.lastChild) && (r.name == "CloseTag" || r.name == "SelfClosingTag")) ? e.lineIndent(t.from) + e.unit : null;
        }
      }),
      yn.add({
        Element(e) {
          let t = e.firstChild, r = e.lastChild;
          return !t || t.name != "OpenTag" ? null : { from: t.to, to: r.name == "CloseTag" ? r.from : e.to };
        }
      }),
      Pp.add({
        "OpenTag CloseTag": (e) => e.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
var is = IO.configure({
  wrap: TO(gO, yO)
});
function fy(e = {}) {
  let t = "", r;
  e.matchClosingTags === false && (t = "noMatch"), e.selfClosingTags === true && (t = (t ? t + " " : "") + "selfClosing"), (e.nestedLanguages && e.nestedLanguages.length || e.nestedAttributes && e.nestedAttributes.length) && (r = TO((e.nestedLanguages || []).concat(gO), (e.nestedAttributes || []).concat(yO)));
  let i = r ? IO.configure({ wrap: r, dialect: t }) : t ? is.configure({ dialect: t }) : is;
  return new Ta(i, [
    is.data.of({ autocomplete: uy(e) }),
    e.autoCloseTags !== false ? hy : [],
    zp().support,
    sO().support
  ]);
}
var zf = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
var hy = ua.inputHandler.of((e, t, r, i, n) => {
  if (e.composing || e.state.readOnly || t != r || i != ">" && i != "/" || !is.isActiveAt(e.state, t, -1))
    return false;
  let a = n(), { state: s } = a, o = s.changeByRange((l) => {
    var c, f, p;
    let O = s.doc.sliceString(l.from - 1, l.to) == i, { head: d2 } = l, g = Ot(s).resolveInner(d2, -1), L;
    if (O && i == ">" && g.name == "EndTag") {
      let D = g.parent;
      if (((f = (c = D.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || f === void 0 ? void 0 : f.name) != "CloseTag" && (L = fn(s.doc, D.parent, d2)) && !zf.has(L)) {
        let W = d2 + (s.doc.sliceString(d2, d2 + 1) === ">" ? 1 : 0), x = `</${L}>`;
        return { range: l, changes: { from: d2, to: W, insert: x } };
      }
    } else if (O && i == "/" && g.name == "IncompleteCloseTag") {
      let D = g.parent;
      if (g.from == d2 - 2 && ((p = D.lastChild) === null || p === void 0 ? void 0 : p.name) != "CloseTag" && (L = fn(s.doc, D, d2)) && !zf.has(L)) {
        let W = d2 + (s.doc.sliceString(d2, d2 + 1) === ">" ? 1 : 0), x = `${L}>`;
        return {
          range: $2.cursor(d2 + x.length, -1),
          changes: { from: d2, to: W, insert: x }
        };
      }
    }
    return { range: l };
  });
  return o.changes.empty ? false : (e.dispatch([
    a,
    s.update(o, {
      userEvent: "input.complete",
      scrollIntoView: true
    })
  ]), true);
});
var py = (e) => {
  let { state: t } = e, r = t.doc.lineAt(t.selection.main.from), i = Hu(e.state, r.from);
  return i.line ? Oy(e) : i.block ? dy(e) : false;
};
function Zu(e, t) {
  return ({ state: r, dispatch: i }) => {
    if (r.readOnly)
      return false;
    let n = e(t, r);
    return n ? (i(r.update(n)), true) : false;
  };
}
var Oy = Zu(
  my,
  0
  /* CommentOption.Toggle */
);
var Ey = Zu(
  NO,
  0
  /* CommentOption.Toggle */
);
var dy = Zu(
  (e, t) => NO(e, t, Sy(t)),
  0
  /* CommentOption.Toggle */
);
function Hu(e, t) {
  let r = e.languageDataAt("commentTokens", t);
  return r.length ? r[0] : {};
}
var kn = 50;
function Ty(e, { open: t, close: r }, i, n) {
  let a = e.sliceDoc(i - kn, i), s = e.sliceDoc(n, n + kn), o = /\s*$/.exec(a)[0].length, l = /^\s*/.exec(s)[0].length, c = a.length - o;
  if (a.slice(c - t.length, c) == t && s.slice(l, l + r.length) == r)
    return {
      open: { pos: i - o, margin: o && 1 },
      close: { pos: n + l, margin: l && 1 }
    };
  let f, p;
  n - i <= 2 * kn ? f = p = e.sliceDoc(i, n) : (f = e.sliceDoc(i, i + kn), p = e.sliceDoc(n - kn, n));
  let O = /^\s*/.exec(f)[0].length, d2 = /\s*$/.exec(p)[0].length, g = p.length - d2 - r.length;
  return f.slice(O, O + t.length) == t && p.slice(g, g + r.length) == r ? {
    open: {
      pos: i + O + t.length,
      margin: /\s/.test(f.charAt(O + t.length)) ? 1 : 0
    },
    close: {
      pos: n - d2 - r.length,
      margin: /\s/.test(p.charAt(g - 1)) ? 1 : 0
    }
  } : null;
}
function Sy(e) {
  let t = [];
  for (let r of e.selection.ranges) {
    let i = e.doc.lineAt(r.from), n = r.to <= i.to ? i : e.doc.lineAt(r.to), a = t.length - 1;
    a >= 0 && t[a].to > i.from ? t[a].to = n.to : t.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return t;
}
function NO(e, t, r = t.selection.ranges) {
  let i = r.map((a) => Hu(t, a.from).block);
  if (!i.every((a) => a))
    return null;
  let n = r.map((a, s) => Ty(t, i[s], a.from, a.to));
  if (e != 2 && !n.every((a) => a))
    return { changes: t.changes(r.map((a, s) => n[s] ? [] : [{ from: a.from, insert: i[s].open + " " }, { from: a.to, insert: " " + i[s].close }])) };
  if (e != 1 && n.some((a) => a)) {
    let a = [];
    for (let s = 0, o; s < n.length; s++)
      if (o = n[s]) {
        let l = i[s], { open: c, close: f } = o;
        a.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: f.pos - f.margin, to: f.pos + l.close.length });
      }
    return { changes: a };
  }
  return null;
}
function my(e, t, r = t.selection.ranges) {
  let i = [], n = -1;
  for (let { from: a, to: s } of r) {
    let o = i.length, l = 1e9, c = Hu(t, a).line;
    if (c) {
      for (let f = a; f <= s; ) {
        let p = t.doc.lineAt(f);
        if (p.from > n && (a == s || s > p.from)) {
          n = p.from;
          let O = /^\s*/.exec(p.text)[0].length, d2 = O == p.length, g = p.text.slice(O, O + c.length) == c ? O : -1;
          O < p.text.length && O < l && (l = O), i.push({ line: p, comment: g, token: c, indent: O, empty: d2, single: false });
        }
        f = p.to + 1;
      }
      if (l < 1e9)
        for (let f = o; f < i.length; f++)
          i[f].indent < i[f].line.text.length && (i[f].indent = l);
      i.length == o + 1 && (i[o].single = true);
    }
  }
  if (e != 2 && i.some((a) => a.comment < 0 && (!a.empty || a.single))) {
    let a = [];
    for (let { line: o, token: l, indent: c, empty: f, single: p } of i)
      (p || !f) && a.push({ from: o.from + c, insert: l + " " });
    let s = t.changes(a);
    return { changes: s, selection: t.selection.map(s, 1) };
  } else if (e != 1 && i.some((a) => a.comment >= 0)) {
    let a = [];
    for (let { line: s, comment: o, token: l } of i)
      if (o >= 0) {
        let c = s.from + o, f = c + l.length;
        s.text[f - s.from] == " " && f++, a.push({ from: c, to: f });
      }
    return { changes: a };
  }
  return null;
}
var dl = UC.define();
var Ry = UC.define();
var Ay = Tn.define();
var PO = Tn.define({
  combine(e) {
    return rF1(e, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (t, r) => r
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (t, r) => (i, n) => t(i, n) || r(i, n)
    });
  }
});
var _O = tu.define({
  create() {
    return Vr.empty;
  },
  update(e, t) {
    let r = t.state.facet(PO), i = t.annotation(dl);
    if (i) {
      let l = Kt.fromTransaction(t, i.selection), c = i.side, f = c == 0 ? e.undone : e.done;
      return l ? f = ys(f, f.length, r.minDepth, l) : f = CO(f, t.startState.selection), new Vr(c == 0 ? i.rest : f, c == 0 ? f : i.rest);
    }
    let n = t.annotation(Ry);
    if ((n == "full" || n == "before") && (e = e.isolate()), t.annotation(i4.addToHistory) === false)
      return t.changes.empty ? e : e.addMapping(t.changes.desc);
    let a = Kt.fromTransaction(t), s = t.annotation(i4.time), o = t.annotation(i4.userEvent);
    return a ? e = e.addChanges(a, s, o, r, t) : t.selection && (e = e.addSelection(t.startState.selection, s, o, r.newGroupDelay)), (n == "full" || n == "after") && (e = e.isolate()), e;
  },
  toJSON(e) {
    return { done: e.done.map((t) => t.toJSON()), undone: e.undone.map((t) => t.toJSON()) };
  },
  fromJSON(e) {
    return new Vr(e.done.map(Kt.fromJSON), e.undone.map(Kt.fromJSON));
  }
});
function gy(e = {}) {
  return [
    _O,
    PO.of(e),
    ua.domEventHandlers({
      beforeinput(t, r) {
        let i = t.inputType == "historyUndo" ? bO : t.inputType == "historyRedo" ? Tl : null;
        return i ? (t.preventDefault(), i(r)) : false;
      }
    })
  ];
}
function Ws(e, t) {
  return function({ state: r, dispatch: i }) {
    if (!t && r.readOnly)
      return false;
    let n = r.field(_O, false);
    if (!n)
      return false;
    let a = n.pop(e, r, t);
    return a ? (i(a), true) : false;
  };
}
var bO = Ws(0, false);
var Tl = Ws(1, false);
var yy = Ws(0, true);
var Iy = Ws(1, true);
var Kt = class _Kt {
  constructor(t, r, i, n, a) {
    this.changes = t, this.effects = r, this.mapped = i, this.startSelection = n, this.selectionsAfter = a;
  }
  setSelAfter(t) {
    return new _Kt(this.changes, this.effects, this.mapped, this.startSelection, t);
  }
  toJSON() {
    var t, r, i;
    return {
      changes: (t = this.changes) === null || t === void 0 ? void 0 : t.toJSON(),
      mapped: (r = this.mapped) === null || r === void 0 ? void 0 : r.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(t) {
    return new _Kt(t.changes && t5.fromJSON(t.changes), [], t.mapped && N8.fromJSON(t.mapped), t.startSelection && $2.fromJSON(t.startSelection), t.selectionsAfter.map($2.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(t, r) {
    let i = Sr;
    for (let n of t.startState.facet(Ay)) {
      let a = n(t);
      a.length && (i = i.concat(a));
    }
    return !i.length && t.changes.empty ? null : new _Kt(t.changes.invert(t.startState.doc), i, void 0, r || t.startState.selection, Sr);
  }
  static selection(t) {
    return new _Kt(void 0, Sr, void 0, void 0, t);
  }
};
function ys(e, t, r, i) {
  let n = t + 1 > r + 20 ? t - r - 1 : 0, a = e.slice(n, t);
  return a.push(i), a;
}
function Ny(e, t) {
  let r = [], i = false;
  return e.iterChangedRanges((n, a) => r.push(n, a)), t.iterChangedRanges((n, a, s, o) => {
    for (let l = 0; l < r.length; ) {
      let c = r[l++], f = r[l++];
      o >= c && s <= f && (i = true);
    }
  }), i;
}
function Py(e, t) {
  return e.ranges.length == t.ranges.length && e.ranges.filter((r, i) => r.empty != t.ranges[i].empty).length === 0;
}
function vO(e, t) {
  return e.length ? t.length ? e.concat(t) : e : t;
}
var Sr = [];
var _y = 200;
function CO(e, t) {
  if (e.length) {
    let r = e[e.length - 1], i = r.selectionsAfter.slice(Math.max(0, r.selectionsAfter.length - _y));
    return i.length && i[i.length - 1].eq(t) ? e : (i.push(t), ys(e, e.length - 1, 1e9, r.setSelAfter(i)));
  } else
    return [Kt.selection([t])];
}
function by(e) {
  let t = e[e.length - 1], r = e.slice();
  return r[e.length - 1] = t.setSelAfter(t.selectionsAfter.slice(0, t.selectionsAfter.length - 1)), r;
}
function ko(e, t) {
  if (!e.length)
    return e;
  let r = e.length, i = Sr;
  for (; r; ) {
    let n = vy(e[r - 1], t, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let a = e.slice(0, r);
      return a[r - 1] = n, a;
    } else
      t = n.mapped, r--, i = n.selectionsAfter;
  }
  return i.length ? [Kt.selection(i)] : Sr;
}
function vy(e, t, r) {
  let i = vO(e.selectionsAfter.length ? e.selectionsAfter.map((o) => o.map(t)) : Sr, r);
  if (!e.changes)
    return Kt.selection(i);
  let n = e.changes.map(t), a = t.mapDesc(e.changes, true), s = e.mapped ? e.mapped.composeDesc(a) : a;
  return new Kt(n, Eo.mapEffects(e.effects, t), s, e.startSelection.map(a), i);
}
var Cy = /^(input\.type|delete)($|\.)/;
var Vr = class _Vr {
  constructor(t, r, i = 0, n = void 0) {
    this.done = t, this.undone = r, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new _Vr(this.done, this.undone) : this;
  }
  addChanges(t, r, i, n, a) {
    let s = this.done, o = s[s.length - 1];
    return o && o.changes && !o.changes.empty && t.changes && (!i || Cy.test(i)) && (!o.selectionsAfter.length && r - this.prevTime < n.newGroupDelay && n.joinToEvent(a, Ny(o.changes, t.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? s = ys(s, s.length - 1, n.minDepth, new Kt(t.changes.compose(o.changes), vO(t.effects, o.effects), o.mapped, o.startSelection, Sr)) : s = ys(s, s.length, n.minDepth, t), new _Vr(s, Sr, r, i);
  }
  addSelection(t, r, i, n) {
    let a = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Sr;
    return a.length > 0 && r - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && Py(a[a.length - 1], t) ? this : new _Vr(CO(this.done, t), this.undone, r, i);
  }
  addMapping(t) {
    return new _Vr(ko(this.done, t), ko(this.undone, t), this.prevTime, this.prevUserEvent);
  }
  pop(t, r, i) {
    let n = t == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let a = n[n.length - 1], s = a.selectionsAfter[0] || r.selection;
    if (i && a.selectionsAfter.length)
      return r.update({
        selection: a.selectionsAfter[a.selectionsAfter.length - 1],
        annotations: dl.of({ side: t, rest: by(n), selection: s }),
        userEvent: t == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    if (a.changes) {
      let o = n.length == 1 ? Sr : n.slice(0, n.length - 1);
      return a.mapped && (o = ko(o, a.mapped)), r.update({
        changes: a.changes,
        selection: a.startSelection,
        effects: a.effects,
        annotations: dl.of({ side: t, rest: o, selection: s }),
        filter: false,
        userEvent: t == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    } else
      return null;
  }
};
Vr.empty = new Vr(Sr, Sr);
var Ly = [
  { key: "Mod-z", run: bO, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Tl, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: Tl, preventDefault: true },
  { key: "Mod-u", run: yy, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: Iy, preventDefault: true }
];
function Nn(e, t) {
  return $2.create(e.ranges.map(t), e.mainIndex);
}
function jr(e, t) {
  return e.update({ selection: t, scrollIntoView: true, userEvent: "select" });
}
function Lr({ state: e, dispatch: t }, r) {
  let i = Nn(e.selection, r);
  return i.eq(e.selection, true) ? false : (t(jr(e, i)), true);
}
function Xs(e, t) {
  return $2.cursor(t ? e.to : e.from);
}
function LO(e, t) {
  return Lr(e, (r) => r.empty ? e.moveByChar(r, t) : Xs(r, t));
}
function Bt(e) {
  return e.textDirectionAt(e.state.selection.main.head) == ci.LTR;
}
var xO = (e) => LO(e, !Bt(e));
var DO = (e) => LO(e, Bt(e));
function UO(e, t) {
  return Lr(e, (r) => r.empty ? e.moveByGroup(r, t) : Xs(r, t));
}
var xy = (e) => UO(e, !Bt(e));
var Dy = (e) => UO(e, Bt(e));
function Uy(e, t, r) {
  if (t.type.prop(r))
    return true;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(e.sliceDoc(t.from, t.to))) || t.firstChild;
}
function js(e, t, r) {
  let i = Ot(e).resolveInner(t.head), n = r ? Le.closedBy : Le.openedBy;
  for (let l = t.head; ; ) {
    let c = r ? i.childAfter(l) : i.childBefore(l);
    if (!c)
      break;
    Uy(e, c, n) ? i = c : l = r ? c.to : c.from;
  }
  let a = i.type.prop(n), s, o;
  return a && (s = r ? Gr(e, i.from, 1) : Gr(e, i.to, -1)) && s.matched ? o = r ? s.end.to : s.end.from : o = r ? i.to : i.from, $2.cursor(o, r ? -1 : 1);
}
var wy = (e) => Lr(e, (t) => js(e.state, t, !Bt(e)));
var My = (e) => Lr(e, (t) => js(e.state, t, Bt(e)));
function wO(e, t) {
  return Lr(e, (r) => {
    if (!r.empty)
      return Xs(r, t);
    let i = e.moveVertically(r, t);
    return i.head != r.head ? i : e.moveToLineBoundary(r, t);
  });
}
var MO = (e) => wO(e, false);
var kO = (e) => wO(e, true);
function QO(e) {
  let t = e.scrollDOM.clientHeight < e.scrollDOM.scrollHeight - 2, r = 0, i = 0, n;
  if (t) {
    for (let a of e.state.facet(ua.scrollMargins)) {
      let s = a(e);
      s != null && s.top && (r = Math.max(s == null ? void 0 : s.top, r)), s != null && s.bottom && (i = Math.max(s == null ? void 0 : s.bottom, i));
    }
    n = e.scrollDOM.clientHeight - r - i;
  } else
    n = (e.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: r,
    marginBottom: i,
    selfScroll: t,
    height: Math.max(e.defaultLineHeight, n - 5)
  };
}
function GO(e, t) {
  let r = QO(e), { state: i } = e, n = Nn(i.selection, (s) => s.empty ? e.moveVertically(s, t, r.height) : Xs(s, t));
  if (n.eq(i.selection))
    return false;
  let a;
  if (r.selfScroll) {
    let s = e.coordsAtPos(i.selection.main.head), o = e.scrollDOM.getBoundingClientRect(), l = o.top + r.marginTop, c = o.bottom - r.marginBottom;
    s && s.top > l && s.bottom < c && (a = ua.scrollIntoView(n.main.head, { y: "start", yMargin: s.top - l }));
  }
  return e.dispatch(jr(i, n), { effects: a }), true;
}
var qf = (e) => GO(e, false);
var Sl = (e) => GO(e, true);
function yi(e, t, r) {
  let i = e.lineBlockAt(t.head), n = e.moveToLineBoundary(t, r);
  if (n.head == t.head && n.head != (r ? i.to : i.from) && (n = e.moveToLineBoundary(t, r, false)), !r && n.head == i.from && i.length) {
    let a = /^\s*/.exec(e.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    a && t.head != i.from + a && (n = $2.cursor(i.from + a));
  }
  return n;
}
var ky = (e) => Lr(e, (t) => yi(e, t, true));
var Qy = (e) => Lr(e, (t) => yi(e, t, false));
var Gy = (e) => Lr(e, (t) => yi(e, t, !Bt(e)));
var Vy = (e) => Lr(e, (t) => yi(e, t, Bt(e)));
var By = (e) => Lr(e, (t) => $2.cursor(e.lineBlockAt(t.head).from, 1));
var $y = (e) => Lr(e, (t) => $2.cursor(e.lineBlockAt(t.head).to, -1));
function Yy(e, t, r) {
  let i = false, n = Nn(e.selection, (a) => {
    let s = Gr(e, a.head, -1) || Gr(e, a.head, 1) || a.head > 0 && Gr(e, a.head - 1, 1) || a.head < e.doc.length && Gr(e, a.head + 1, -1);
    if (!s || !s.end)
      return a;
    i = true;
    let o = s.start.from == a.head ? s.end.to : s.end.from;
    return r ? $2.range(a.anchor, o) : $2.cursor(o);
  });
  return i ? (t(jr(e, n)), true) : false;
}
var Fy = ({ state: e, dispatch: t }) => Yy(e, t, false);
function Rr(e, t) {
  let r = Nn(e.state.selection, (i) => {
    let n = t(i);
    return $2.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return r.eq(e.state.selection) ? false : (e.dispatch(jr(e.state, r)), true);
}
function VO(e, t) {
  return Rr(e, (r) => e.moveByChar(r, t));
}
var BO = (e) => VO(e, !Bt(e));
var $O = (e) => VO(e, Bt(e));
function YO(e, t) {
  return Rr(e, (r) => e.moveByGroup(r, t));
}
var Wy = (e) => YO(e, !Bt(e));
var Xy = (e) => YO(e, Bt(e));
var jy = (e) => Rr(e, (t) => js(e.state, t, !Bt(e)));
var Zy = (e) => Rr(e, (t) => js(e.state, t, Bt(e)));
function FO(e, t) {
  return Rr(e, (r) => e.moveVertically(r, t));
}
var WO = (e) => FO(e, false);
var XO = (e) => FO(e, true);
function jO(e, t) {
  return Rr(e, (r) => e.moveVertically(r, t, QO(e).height));
}
var Jf = (e) => jO(e, false);
var Kf = (e) => jO(e, true);
var Hy = (e) => Rr(e, (t) => yi(e, t, true));
var zy = (e) => Rr(e, (t) => yi(e, t, false));
var qy = (e) => Rr(e, (t) => yi(e, t, !Bt(e)));
var Jy = (e) => Rr(e, (t) => yi(e, t, Bt(e)));
var Ky = (e) => Rr(e, (t) => $2.cursor(e.lineBlockAt(t.head).from));
var eI = (e) => Rr(e, (t) => $2.cursor(e.lineBlockAt(t.head).to));
var eh = ({ state: e, dispatch: t }) => (t(jr(e, { anchor: 0 })), true);
var th = ({ state: e, dispatch: t }) => (t(jr(e, { anchor: e.doc.length })), true);
var rh = ({ state: e, dispatch: t }) => (t(jr(e, { anchor: e.selection.main.anchor, head: 0 })), true);
var ih = ({ state: e, dispatch: t }) => (t(jr(e, { anchor: e.selection.main.anchor, head: e.doc.length })), true);
var tI = ({ state: e, dispatch: t }) => (t(e.update({ selection: { anchor: 0, head: e.doc.length }, userEvent: "select" })), true);
var rI = ({ state: e, dispatch: t }) => {
  let r = Zs(e).map(({ from: i, to: n }) => $2.range(i, Math.min(n + 1, e.doc.length)));
  return t(e.update({ selection: $2.create(r), userEvent: "select" })), true;
};
var iI = ({ state: e, dispatch: t }) => {
  let r = Nn(e.selection, (i) => {
    var n;
    let a = Ot(e).resolveStack(i.from, 1);
    for (let s = a; s; s = s.next) {
      let { node: o } = s;
      if ((o.from < i.from && o.to >= i.to || o.to > i.to && o.from <= i.from) && (!((n = o.parent) === null || n === void 0) && n.parent))
        return $2.range(o.to, o.from);
    }
    return i;
  });
  return t(jr(e, r)), true;
};
var nI = ({ state: e, dispatch: t }) => {
  let r = e.selection, i = null;
  return r.ranges.length > 1 ? i = $2.create([r.main]) : r.main.empty || (i = $2.create([$2.cursor(r.main.head)])), i ? (t(jr(e, i)), true) : false;
};
function Ra(e, t) {
  if (e.state.readOnly)
    return false;
  let r = "delete.selection", { state: i } = e, n = i.changeByRange((a) => {
    let { from: s, to: o } = a;
    if (s == o) {
      let l = t(a);
      l < s ? (r = "delete.backward", l = ka(e, l, false)) : l > s && (r = "delete.forward", l = ka(e, l, true)), s = Math.min(s, l), o = Math.max(o, l);
    } else
      s = ka(e, s, false), o = ka(e, o, true);
    return s == o ? { range: a } : { changes: { from: s, to: o }, range: $2.cursor(s, s < a.head ? -1 : 1) };
  });
  return n.changes.empty ? false : (e.dispatch(i.update(n, {
    scrollIntoView: true,
    userEvent: r,
    effects: r == "delete.selection" ? ua.announce.of(i.phrase("Selection deleted")) : void 0
  })), true);
}
function ka(e, t, r) {
  if (e instanceof ua)
    for (let i of e.state.facet(ua.atomicRanges).map((n) => n(e)))
      i.between(t, t, (n, a) => {
        n < t && a > t && (t = r ? a : n);
      });
  return t;
}
var ZO = (e, t, r) => Ra(e, (i) => {
  let n = i.from, { state: a } = e, s = a.doc.lineAt(n), o, l;
  if (r && !t && n > s.from && n < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, n - s.from))) {
    if (o[o.length - 1] == "	")
      return n - 1;
    let c = oF1(o, a.tabSize), f = c % cs(a) || cs(a);
    for (let p = 0; p < f && o[o.length - 1 - p] == " "; p++)
      n--;
    l = n;
  } else
    l = V6(s.text, n - s.from, t, t) + s.from, l == n && s.number != (t ? a.doc.lines : 1) ? l += t ? 1 : -1 : !t && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, n - s.from)) && (l = V6(s.text, l - s.from, false, false) + s.from);
  return l;
});
var ml = (e) => ZO(e, false, true);
var HO = (e) => ZO(e, true, false);
var zO = (e, t) => Ra(e, (r) => {
  let i = r.head, { state: n } = e, a = n.doc.lineAt(i), s = n.charCategorizer(i);
  for (let o = null; ; ) {
    if (i == (t ? a.to : a.from)) {
      i == r.head && a.number != (t ? n.doc.lines : 1) && (i += t ? 1 : -1);
      break;
    }
    let l = V6(a.text, i - a.from, t) + a.from, c = a.text.slice(Math.min(i, l) - a.from, Math.max(i, l) - a.from), f = s(c);
    if (o != null && f != o)
      break;
    (c != " " || i != r.head) && (o = f), i = l;
  }
  return i;
});
var qO = (e) => zO(e, false);
var aI = (e) => zO(e, true);
var sI = (e) => Ra(e, (t) => {
  let r = e.lineBlockAt(t.head).to;
  return t.head < r ? r : Math.min(e.state.doc.length, t.head + 1);
});
var oI = (e) => Ra(e, (t) => {
  let r = e.moveToLineBoundary(t, false).head;
  return t.head > r ? r : Math.max(0, t.head - 1);
});
var lI = (e) => Ra(e, (t) => {
  let r = e.moveToLineBoundary(t, true).head;
  return t.head < r ? r : Math.min(e.state.doc.length, t.head + 1);
});
var uI = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return false;
  let r = e.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: va.of(["", ""]) },
    range: $2.cursor(i.from)
  }));
  return t(e.update(r, { scrollIntoView: true, userEvent: "input" })), true;
};
var cI = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return false;
  let r = e.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == e.doc.length)
      return { range: i };
    let n = i.from, a = e.doc.lineAt(n), s = n == a.from ? n - 1 : V6(a.text, n - a.from, false) + a.from, o = n == a.to ? n + 1 : V6(a.text, n - a.from, true) + a.from;
    return {
      changes: { from: s, to: o, insert: e.doc.slice(n, o).append(e.doc.slice(s, n)) },
      range: $2.cursor(o)
    };
  });
  return r.changes.empty ? false : (t(e.update(r, { scrollIntoView: true, userEvent: "move.character" })), true);
};
function Zs(e) {
  let t = [], r = -1;
  for (let i of e.selection.ranges) {
    let n = e.doc.lineAt(i.from), a = e.doc.lineAt(i.to);
    if (!i.empty && i.to == a.from && (a = e.doc.lineAt(i.to - 1)), r >= n.number) {
      let s = t[t.length - 1];
      s.to = a.to, s.ranges.push(i);
    } else
      t.push({ from: n.from, to: a.to, ranges: [i] });
    r = a.number + 1;
  }
  return t;
}
function JO(e, t, r) {
  if (e.readOnly)
    return false;
  let i = [], n = [];
  for (let a of Zs(e)) {
    if (r ? a.to == e.doc.length : a.from == 0)
      continue;
    let s = e.doc.lineAt(r ? a.to + 1 : a.from - 1), o = s.length + 1;
    if (r) {
      i.push({ from: a.to, to: s.to }, { from: a.from, insert: s.text + e.lineBreak });
      for (let l of a.ranges)
        n.push($2.range(Math.min(e.doc.length, l.anchor + o), Math.min(e.doc.length, l.head + o)));
    } else {
      i.push({ from: s.from, to: a.from }, { from: a.to, insert: e.lineBreak + s.text });
      for (let l of a.ranges)
        n.push($2.range(l.anchor - o, l.head - o));
    }
  }
  return i.length ? (t(e.update({
    changes: i,
    scrollIntoView: true,
    selection: $2.create(n, e.selection.mainIndex),
    userEvent: "move.line"
  })), true) : false;
}
var fI = ({ state: e, dispatch: t }) => JO(e, t, false);
var hI = ({ state: e, dispatch: t }) => JO(e, t, true);
function KO(e, t, r) {
  if (e.readOnly)
    return false;
  let i = [];
  for (let n of Zs(e))
    r ? i.push({ from: n.from, insert: e.doc.slice(n.from, n.to) + e.lineBreak }) : i.push({ from: n.to, insert: e.lineBreak + e.doc.slice(n.from, n.to) });
  return t(e.update({ changes: i, scrollIntoView: true, userEvent: "input.copyline" })), true;
}
var pI = ({ state: e, dispatch: t }) => KO(e, t, false);
var OI = ({ state: e, dispatch: t }) => KO(e, t, true);
var EI = (e) => {
  if (e.state.readOnly)
    return false;
  let { state: t } = e, r = t.changes(Zs(t).map(({ from: n, to: a }) => (n > 0 ? n-- : a < t.doc.length && a++, { from: n, to: a }))), i = Nn(t.selection, (n) => {
    let a;
    if (e.lineWrapping) {
      let s = e.lineBlockAt(n.head), o = e.coordsAtPos(n.head, n.assoc || 1);
      o && (a = s.bottom + e.documentTop - o.bottom + e.defaultLineHeight / 2);
    }
    return e.moveVertically(n, true, a);
  }).map(r);
  return e.dispatch({ changes: r, selection: i, scrollIntoView: true, userEvent: "delete.line" }), true;
};
function dI(e, t) {
  if (/\(\)|\[\]|\{\}/.test(e.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let r = Ot(e).resolveInner(t), i = r.childBefore(t), n = r.childAfter(t), a;
  return i && n && i.to <= t && n.from >= t && (a = i.type.prop(Le.closedBy)) && a.indexOf(n.name) > -1 && e.doc.lineAt(i.to).from == e.doc.lineAt(n.from).from && !/\S/.test(e.sliceDoc(i.to, n.from)) ? { from: i.to, to: n.from } : null;
}
var TI = eE(false);
var SI = eE(true);
function eE(e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return false;
    let i = t.changeByRange((n) => {
      let { from: a, to: s } = n, o = t.doc.lineAt(a), l = !e && a == s && dI(t, a);
      e && (a = s = (s <= o.to ? o : t.doc.lineAt(s)).to);
      let c = new Bs(t, { simulateBreak: a, simulateDoubleBreak: !!l }), f = bu(c, a);
      for (f == null && (f = oF1(/^\s*/.exec(t.doc.lineAt(a).text)[0], t.tabSize)); s < o.to && /\s/.test(o.text[s - o.from]); )
        s++;
      l ? { from: a, to: s } = l : a > o.from && a < o.from + 100 && !/\S/.test(o.text.slice(0, a)) && (a = o.from);
      let p = ["", Kn(t, f)];
      return l && p.push(Kn(t, c.lineIndent(o.from, -1))), {
        changes: { from: a, to: s, insert: va.of(p) },
        range: $2.cursor(a + 1 + p[1].length)
      };
    });
    return r(t.update(i, { scrollIntoView: true, userEvent: "input" })), true;
  };
}
function zu(e, t) {
  let r = -1;
  return e.changeByRange((i) => {
    let n = [];
    for (let s = i.from; s <= i.to; ) {
      let o = e.doc.lineAt(s);
      o.number > r && (i.empty || i.to > o.from) && (t(o, n, i), r = o.number), s = o.to + 1;
    }
    let a = e.changes(n);
    return {
      changes: n,
      range: $2.range(a.mapPos(i.anchor, 1), a.mapPos(i.head, 1))
    };
  });
}
var mI = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return false;
  let r = /* @__PURE__ */ Object.create(null), i = new Bs(e, { overrideIndentation: (a) => {
    let s = r[a];
    return s ?? -1;
  } }), n = zu(e, (a, s, o) => {
    let l = bu(i, a.from);
    if (l == null)
      return;
    /\S/.test(a.text) || (l = 0);
    let c = /^\s*/.exec(a.text)[0], f = Kn(e, l);
    (c != f || o.from < a.from + c.length) && (r[a.from] = l, s.push({ from: a.from, to: a.from + c.length, insert: f }));
  });
  return n.changes.empty || t(e.update(n, { userEvent: "indent" })), true;
};
var tE = ({ state: e, dispatch: t }) => e.readOnly ? false : (t(e.update(zu(e, (r, i) => {
  i.push({ from: r.from, insert: e.facet(Vs) });
}), { userEvent: "input.indent" })), true);
var rE = ({ state: e, dispatch: t }) => e.readOnly ? false : (t(e.update(zu(e, (r, i) => {
  let n = /^\s*/.exec(r.text)[0];
  if (!n)
    return;
  let a = oF1(n, e.tabSize), s = 0, o = Kn(e, Math.max(0, a - cs(e)));
  for (; s < n.length && s < o.length && n.charCodeAt(s) == o.charCodeAt(s); )
    s++;
  i.push({ from: r.from + s, to: r.from + n.length, insert: o.slice(s) });
}), { userEvent: "delete.dedent" })), true);
var RI = [
  { key: "Ctrl-b", run: xO, shift: BO, preventDefault: true },
  { key: "Ctrl-f", run: DO, shift: $O },
  { key: "Ctrl-p", run: MO, shift: WO },
  { key: "Ctrl-n", run: kO, shift: XO },
  { key: "Ctrl-a", run: By, shift: Ky },
  { key: "Ctrl-e", run: $y, shift: eI },
  { key: "Ctrl-d", run: HO },
  { key: "Ctrl-h", run: ml },
  { key: "Ctrl-k", run: sI },
  { key: "Ctrl-Alt-h", run: qO },
  { key: "Ctrl-o", run: uI },
  { key: "Ctrl-t", run: cI },
  { key: "Ctrl-v", run: Sl }
];
var AI = [
  { key: "ArrowLeft", run: xO, shift: BO, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: xy, shift: Wy, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: Gy, shift: qy, preventDefault: true },
  { key: "ArrowRight", run: DO, shift: $O, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: Dy, shift: Xy, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: Vy, shift: Jy, preventDefault: true },
  { key: "ArrowUp", run: MO, shift: WO, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: eh, shift: rh },
  { mac: "Ctrl-ArrowUp", run: qf, shift: Jf },
  { key: "ArrowDown", run: kO, shift: XO, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: th, shift: ih },
  { mac: "Ctrl-ArrowDown", run: Sl, shift: Kf },
  { key: "PageUp", run: qf, shift: Jf },
  { key: "PageDown", run: Sl, shift: Kf },
  { key: "Home", run: Qy, shift: zy, preventDefault: true },
  { key: "Mod-Home", run: eh, shift: rh },
  { key: "End", run: ky, shift: Hy, preventDefault: true },
  { key: "Mod-End", run: th, shift: ih },
  { key: "Enter", run: TI },
  { key: "Mod-a", run: tI },
  { key: "Backspace", run: ml, shift: ml },
  { key: "Delete", run: HO },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: qO },
  { key: "Mod-Delete", mac: "Alt-Delete", run: aI },
  { mac: "Mod-Backspace", run: oI },
  { mac: "Mod-Delete", run: lI }
].concat(RI.map((e) => ({ mac: e.key, run: e.run, shift: e.shift })));
var gI = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: wy, shift: jy },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: My, shift: Zy },
  { key: "Alt-ArrowUp", run: fI },
  { key: "Shift-Alt-ArrowUp", run: pI },
  { key: "Alt-ArrowDown", run: hI },
  { key: "Shift-Alt-ArrowDown", run: OI },
  { key: "Escape", run: nI },
  { key: "Mod-Enter", run: SI },
  { key: "Alt-l", mac: "Ctrl-l", run: rI },
  { key: "Mod-i", run: iI, preventDefault: true },
  { key: "Mod-[", run: rE },
  { key: "Mod-]", run: tE },
  { key: "Mod-Alt-\\", run: mI },
  { key: "Shift-Mod-k", run: EI },
  { key: "Shift-Mod-\\", run: Fy },
  { key: "Mod-/", run: py },
  { key: "Alt-A", run: Ey }
].concat(AI);
var yI = { key: "Tab", run: tE, shift: rE };
function at() {
  var e = arguments[0];
  typeof e == "string" && (e = document.createElement(e));
  var t = 1, r = arguments[1];
  if (r && typeof r == "object" && r.nodeType == null && !Array.isArray(r)) {
    for (var i in r)
      if (Object.prototype.hasOwnProperty.call(r, i)) {
        var n = r[i];
        typeof n == "string" ? e.setAttribute(i, n) : n != null && (e[i] = n);
      }
    t++;
  }
  for (; t < arguments.length; t++)
    iE(e, arguments[t]);
  return e;
}
function iE(e, t) {
  if (typeof t == "string")
    e.appendChild(document.createTextNode(t));
  else if (t != null)
    if (t.nodeType != null)
      e.appendChild(t);
    else if (Array.isArray(t))
      for (var r = 0; r < t.length; r++)
        iE(e, t[r]);
    else
      throw new RangeError("Unsupported child node: " + t);
}
var nh = typeof String.prototype.normalize == "function" ? (e) => e.normalize("NFKD") : (e) => e;
var pn = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(t, r, i = 0, n = t.length, a, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = false, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = t.iterRange(i, n), this.bufferStart = i, this.normalize = a ? (o) => a(nh(o)) : nh, this.query = this.normalize(r);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return _E(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let t = this.peek();
      if (t < 0)
        return this.done = true, this;
      let r = ulr(t), i = this.bufferStart + this.bufferPos;
      this.bufferPos += yK(t);
      let n = this.normalize(r);
      for (let a = 0, s = i; ; a++) {
        let o = n.charCodeAt(a), l = this.match(o, s, this.bufferPos + this.bufferStart);
        if (a == n.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        s == i && a < r.length && r.charCodeAt(a) == o && s++;
      }
    }
  }
  match(t, r, i) {
    let n = null;
    for (let a = 0; a < this.matches.length; a += 2) {
      let s = this.matches[a], o = false;
      this.query.charCodeAt(s) == t && (s == this.query.length - 1 ? n = { from: this.matches[a + 1], to: i } : (this.matches[a]++, o = true)), o || (this.matches.splice(a, 2), a -= 2);
    }
    return this.query.charCodeAt(0) == t && (this.query.length == 1 ? n = { from: r, to: i } : this.matches.push(1, r)), n && this.test && !this.test(n.from, n.to, this.buffer, this.bufferStart) && (n = null), n;
  }
};
typeof Symbol < "u" && (pn.prototype[Symbol.iterator] = function() {
  return this;
});
var nE = { from: -1, to: -1, match: /.*/.exec("") };
var qu = "gm" + (/x/.unicode == null ? "" : "u");
var aE = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(t, r, i, n = 0, a = t.length) {
    if (this.text = t, this.to = a, this.curLine = "", this.done = false, this.value = nE, /\\[sWDnr]|\n|\r|\[\^/.test(r))
      return new sE(t, r, i, n, a);
    this.re = new RegExp(r, qu + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = t.iter();
    let s = t.lineAt(n);
    this.curLineStart = s.from, this.matchPos = Is(t, n), this.getLine(this.curLineStart);
  }
  getLine(t) {
    this.iter.next(t), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let t = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = t;
      let r = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (r) {
        let i = this.curLineStart + r.index, n = i + r[0].length;
        if (this.matchPos = Is(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, r)))
          return this.value = { from: i, to: n, match: r }, this;
        t = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), t = 0;
      else
        return this.done = true, this;
    }
  }
};
var Qo = /* @__PURE__ */ new WeakMap();
var ln = class _ln {
  constructor(t, r) {
    this.from = t, this.text = r;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(t, r, i) {
    let n = Qo.get(t);
    if (!n || n.from >= i || n.to <= r) {
      let o = new _ln(r, t.sliceString(r, i));
      return Qo.set(t, o), o;
    }
    if (n.from == r && n.to == i)
      return n;
    let { text: a, from: s } = n;
    return s > r && (a = t.sliceString(r, s) + a, s = r), n.to < i && (a += t.sliceString(n.to, i)), Qo.set(t, new _ln(s, a)), new _ln(r, a.slice(r - s, i - s));
  }
};
var sE = class {
  constructor(t, r, i, n, a) {
    this.text = t, this.to = a, this.done = false, this.value = nE, this.matchPos = Is(t, n), this.re = new RegExp(r, qu + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = ln.get(t, n, this.chunkEnd(
      n + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(t) {
    return t >= this.to ? this.to : this.text.lineAt(t).to;
  }
  next() {
    for (; ; ) {
      let t = this.re.lastIndex = this.matchPos - this.flat.from, r = this.re.exec(this.flat.text);
      if (r && !r[0] && r.index == t && (this.re.lastIndex = t + 1, r = this.re.exec(this.flat.text)), r) {
        let i = this.flat.from + r.index, n = i + r[0].length;
        if ((this.flat.to >= this.to || r.index + r[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, r)))
          return this.value = { from: i, to: n, match: r }, this.matchPos = Is(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = true, this;
      this.flat = ln.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
typeof Symbol < "u" && (aE.prototype[Symbol.iterator] = sE.prototype[Symbol.iterator] = function() {
  return this;
});
function II(e) {
  try {
    return new RegExp(e, qu), true;
  } catch {
    return false;
  }
}
function Is(e, t) {
  if (t >= e.length)
    return t;
  let r = e.lineAt(t), i;
  for (; t < r.to && (i = r.text.charCodeAt(t - r.from)) >= 56320 && i < 57344; )
    t++;
  return t;
}
function Rl(e) {
  let t = String(e.state.doc.lineAt(e.state.selection.main.head).number), r = at("input", { class: "cm-textfield", name: "line", value: t }), i = at("form", {
    class: "cm-gotoLine",
    onkeydown: (a) => {
      a.keyCode == 27 ? (a.preventDefault(), e.dispatch({ effects: Ns.of(false) }), e.focus()) : a.keyCode == 13 && (a.preventDefault(), n());
    },
    onsubmit: (a) => {
      a.preventDefault(), n();
    }
  }, at("label", e.state.phrase("Go to line"), ": ", r), " ", at("button", { class: "cm-button", type: "submit" }, e.state.phrase("go")));
  function n() {
    let a = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(r.value);
    if (!a)
      return;
    let { state: s } = e, o = s.doc.lineAt(s.selection.main.head), [, l, c, f, p] = a, O = f ? +f.slice(1) : 0, d2 = c ? +c : o.number;
    if (c && p) {
      let D = d2 / 100;
      l && (D = D * (l == "-" ? -1 : 1) + o.number / s.doc.lines), d2 = Math.round(s.doc.lines * D);
    } else
      c && l && (d2 = d2 * (l == "-" ? -1 : 1) + o.number);
    let g = s.doc.line(Math.max(1, Math.min(s.doc.lines, d2))), L = $2.cursor(g.from + Math.max(0, Math.min(O, g.length)));
    e.dispatch({
      effects: [Ns.of(false), ua.scrollIntoView(L.from, { y: "center" })],
      selection: L
    }), e.focus();
  }
  return { dom: i };
}
var Ns = Eo.define();
var ah = tu.define({
  create() {
    return true;
  },
  update(e, t) {
    for (let r of t.effects)
      r.is(Ns) && (e = r.value);
    return e;
  },
  provide: (e) => qbe.from(e, (t) => t ? Rl : null)
});
var NI = (e) => {
  let t = xlr(e, Rl);
  if (!t) {
    let r = [Ns.of(true)];
    e.state.field(ah, false) == null && r.push(Eo.appendConfig.of([ah, PI])), e.dispatch({ effects: r }), t = xlr(e, Rl);
  }
  return t && t.dom.querySelector("input").select(), true;
};
var PI = ua.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var _I = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var oE = Tn.define({
  combine(e) {
    return rF1(e, _I, {
      highlightWordAroundCursor: (t, r) => t || r,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function bI(e) {
  let t = [DI, xI];
  return e && t.push(oE.of(e)), t;
}
var vI = Ao.mark({ class: "cm-selectionMatch" });
var CI = Ao.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function sh(e, t, r, i) {
  return (r == 0 || e(t.sliceDoc(r - 1, r)) != k8.Word) && (i == t.doc.length || e(t.sliceDoc(i, i + 1)) != k8.Word);
}
function LI(e, t, r, i) {
  return e(t.sliceDoc(r, r + 1)) == k8.Word && e(t.sliceDoc(i - 1, i)) == k8.Word;
}
var xI = k0.fromClass(class {
  constructor(e) {
    this.decorations = this.getDeco(e);
  }
  update(e) {
    (e.selectionSet || e.docChanged || e.viewportChanged) && (this.decorations = this.getDeco(e.view));
  }
  getDeco(e) {
    let t = e.state.facet(oE), { state: r } = e, i = r.selection;
    if (i.ranges.length > 1)
      return Ao.none;
    let n = i.main, a, s = null;
    if (n.empty) {
      if (!t.highlightWordAroundCursor)
        return Ao.none;
      let l = r.wordAt(n.head);
      if (!l)
        return Ao.none;
      s = r.charCategorizer(n.head), a = r.sliceDoc(l.from, l.to);
    } else {
      let l = n.to - n.from;
      if (l < t.minSelectionLength || l > 200)
        return Ao.none;
      if (t.wholeWords) {
        if (a = r.sliceDoc(n.from, n.to), s = r.charCategorizer(n.head), !(sh(s, r, n.from, n.to) && LI(s, r, n.from, n.to)))
          return Ao.none;
      } else if (a = r.sliceDoc(n.from, n.to), !a)
        return Ao.none;
    }
    let o = [];
    for (let l of e.visibleRanges) {
      let c = new pn(r.doc, a, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: f, to: p } = c.value;
        if ((!s || sh(s, r, f, p)) && (n.empty && f <= n.from && p >= n.to ? o.push(CI.range(f, p)) : (f >= n.to || p <= n.from) && o.push(vI.range(f, p)), o.length > t.maxMatches))
          return Ao.none;
      }
    }
    return Ao.set(o);
  }
}, {
  decorations: (e) => e.decorations
});
var DI = ua.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var UI = ({ state: e, dispatch: t }) => {
  let { selection: r } = e, i = $2.create(r.ranges.map((n) => e.wordAt(n.head) || $2.cursor(n.head)), r.mainIndex);
  return i.eq(r) ? false : (t(e.update({ selection: i })), true);
};
function wI(e, t) {
  let { main: r, ranges: i } = e.selection, n = e.wordAt(r.head), a = n && n.from == r.from && n.to == r.to;
  for (let s = false, o = new pn(e.doc, t, i[i.length - 1].to); ; )
    if (o.next(), o.done) {
      if (s)
        return null;
      o = new pn(e.doc, t, 0, Math.max(0, i[i.length - 1].from - 1)), s = true;
    } else {
      if (s && i.some((l) => l.from == o.value.from))
        continue;
      if (a) {
        let l = e.wordAt(o.value.from);
        if (!l || l.from != o.value.from || l.to != o.value.to)
          continue;
      }
      return o.value;
    }
}
var MI = ({ state: e, dispatch: t }) => {
  let { ranges: r } = e.selection;
  if (r.some((a) => a.from === a.to))
    return UI({ state: e, dispatch: t });
  let i = e.sliceDoc(r[0].from, r[0].to);
  if (e.selection.ranges.some((a) => e.sliceDoc(a.from, a.to) != i))
    return false;
  let n = wI(e, i);
  return n ? (t(e.update({
    selection: e.selection.addRange($2.range(n.from, n.to), false),
    effects: ua.scrollIntoView(n.to)
  })), true) : false;
};
var Pn = Tn.define({
  combine(e) {
    return rF1(e, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (t) => new ZI(t),
      scrollToMatch: (t) => ua.scrollIntoView(t)
    });
  }
});
var lE = class {
  /**
  Create a query object.
  */
  constructor(t) {
    this.search = t.search, this.caseSensitive = !!t.caseSensitive, this.literal = !!t.literal, this.regexp = !!t.regexp, this.replace = t.replace || "", this.valid = !!this.search && (!this.regexp || II(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!t.wholeWord;
  }
  /**
  @internal
  */
  unquote(t) {
    return this.literal ? t : t.replace(/\\([nrt\\])/g, (r, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(t) {
    return this.search == t.search && this.replace == t.replace && this.caseSensitive == t.caseSensitive && this.regexp == t.regexp && this.wholeWord == t.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new VI(this) : new QI(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(t, r = 0, i) {
    let n = t.doc ? t : i3.create({ doc: t });
    return i == null && (i = n.doc.length), this.regexp ? en(this, n, r, i) : Ki(this, n, r, i);
  }
};
var uE = class {
  constructor(t) {
    this.spec = t;
  }
};
function Ki(e, t, r, i) {
  return new pn(t.doc, e.unquoted, r, i, e.caseSensitive ? void 0 : (n) => n.toLowerCase(), e.wholeWord ? kI(t.doc, t.charCategorizer(t.selection.main.head)) : void 0);
}
function kI(e, t) {
  return (r, i, n, a) => ((a > r || a + n.length < i) && (a = Math.max(0, r - 2), n = e.sliceString(a, Math.min(e.length, i + 2))), (t(Ps(n, r - a)) != k8.Word || t(_s(n, r - a)) != k8.Word) && (t(_s(n, i - a)) != k8.Word || t(Ps(n, i - a)) != k8.Word));
}
var QI = class extends uE {
  constructor(t) {
    super(t);
  }
  nextMatch(t, r, i) {
    let n = Ki(this.spec, t, i, t.doc.length).nextOverlapping();
    return n.done && (n = Ki(this.spec, t, 0, r).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(t, r, i) {
    for (let n = i; ; ) {
      let a = Math.max(r, n - 1e4 - this.spec.unquoted.length), s = Ki(this.spec, t, a, n), o = null;
      for (; !s.nextOverlapping().done; )
        o = s.value;
      if (o)
        return o;
      if (a == r)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(t, r, i) {
    return this.prevMatchInRange(t, 0, r) || this.prevMatchInRange(t, i, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(t, r) {
    let i = Ki(this.spec, t, 0, t.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= r)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(t, r, i, n) {
    let a = Ki(this.spec, t, Math.max(0, r - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, t.doc.length));
    for (; !a.next().done; )
      n(a.value.from, a.value.to);
  }
};
function en(e, t, r, i) {
  return new aE(t.doc, e.search, {
    ignoreCase: !e.caseSensitive,
    test: e.wholeWord ? GI(t.charCategorizer(t.selection.main.head)) : void 0
  }, r, i);
}
function Ps(e, t) {
  return e.slice(V6(e, t, false), t);
}
function _s(e, t) {
  return e.slice(t, V6(e, t));
}
function GI(e) {
  return (t, r, i) => !i[0].length || (e(Ps(i.input, i.index)) != k8.Word || e(_s(i.input, i.index)) != k8.Word) && (e(_s(i.input, i.index + i[0].length)) != k8.Word || e(Ps(i.input, i.index + i[0].length)) != k8.Word);
}
var VI = class extends uE {
  nextMatch(t, r, i) {
    let n = en(this.spec, t, i, t.doc.length).next();
    return n.done && (n = en(this.spec, t, 0, r).next()), n.done ? null : n.value;
  }
  prevMatchInRange(t, r, i) {
    for (let n = 1; ; n++) {
      let a = Math.max(
        r,
        i - n * 1e4
        /* FindPrev.ChunkSize */
      ), s = en(this.spec, t, a, i), o = null;
      for (; !s.next().done; )
        o = s.value;
      if (o && (a == r || o.from > a + 10))
        return o;
      if (a == r)
        return null;
    }
  }
  prevMatch(t, r, i) {
    return this.prevMatchInRange(t, 0, r) || this.prevMatchInRange(t, i, t.doc.length);
  }
  getReplacement(t) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (r, i) => i == "$" ? "$" : i == "&" ? t.match[0] : i != "0" && +i < t.match.length ? t.match[i] : r);
  }
  matchAll(t, r) {
    let i = en(this.spec, t, 0, t.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= r)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(t, r, i, n) {
    let a = en(this.spec, t, Math.max(
      0,
      r - 250
      /* RegExp.HighlightMargin */
    ), Math.min(i + 250, t.doc.length));
    for (; !a.next().done; )
      n(a.value.from, a.value.to);
  }
};
var aa = Eo.define();
var Ju = Eo.define();
var Ei = tu.define({
  create(e) {
    return new Go(Al(e).create(), null);
  },
  update(e, t) {
    for (let r of t.effects)
      r.is(aa) ? e = new Go(r.value.create(), e.panel) : r.is(Ju) && (e = new Go(e.query, r.value ? Ku : null));
    return e;
  },
  provide: (e) => qbe.from(e, (t) => t.panel)
});
var Go = class {
  constructor(t, r) {
    this.query = t, this.panel = r;
  }
};
var BI = Ao.mark({ class: "cm-searchMatch" });
var $I = Ao.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var YI = k0.fromClass(class {
  constructor(e) {
    this.view = e, this.decorations = this.highlight(e.state.field(Ei));
  }
  update(e) {
    let t = e.state.field(Ei);
    (t != e.startState.field(Ei) || e.docChanged || e.selectionSet || e.viewportChanged) && (this.decorations = this.highlight(t));
  }
  highlight({ query: e, panel: t }) {
    if (!t || !e.spec.valid)
      return Ao.none;
    let { view: r } = this, i = new Bw();
    for (let n = 0, a = r.visibleRanges, s = a.length; n < s; n++) {
      let { from: o, to: l } = a[n];
      for (; n < s - 1 && l > a[n + 1].from - 2 * 250; )
        l = a[++n].to;
      e.highlight(r.state, o, l, (c, f) => {
        let p = r.state.selection.ranges.some((O) => O.from == c && O.to == f);
        i.add(c, f, p ? $I : BI);
      });
    }
    return i.finish();
  }
}, {
  decorations: (e) => e.decorations
});
function Aa(e) {
  return (t) => {
    let r = t.state.field(Ei, false);
    return r && r.query.spec.valid ? e(t, r) : hE(t);
  };
}
var bs = Aa((e, { query: t }) => {
  let { to: r } = e.state.selection.main, i = t.nextMatch(e.state, r, r);
  if (!i)
    return false;
  let n = $2.single(i.from, i.to), a = e.state.facet(Pn);
  return e.dispatch({
    selection: n,
    effects: [ec(e, i), a.scrollToMatch(n.main, e)],
    userEvent: "select.search"
  }), fE(e), true;
});
var vs = Aa((e, { query: t }) => {
  let { state: r } = e, { from: i } = r.selection.main, n = t.prevMatch(r, i, i);
  if (!n)
    return false;
  let a = $2.single(n.from, n.to), s = e.state.facet(Pn);
  return e.dispatch({
    selection: a,
    effects: [ec(e, n), s.scrollToMatch(a.main, e)],
    userEvent: "select.search"
  }), fE(e), true;
});
var FI = Aa((e, { query: t }) => {
  let r = t.matchAll(e.state, 1e3);
  return !r || !r.length ? false : (e.dispatch({
    selection: $2.create(r.map((i) => $2.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), true);
});
var WI = ({ state: e, dispatch: t }) => {
  let r = e.selection;
  if (r.ranges.length > 1 || r.main.empty)
    return false;
  let { from: i, to: n } = r.main, a = [], s = 0;
  for (let o = new pn(e.doc, e.sliceDoc(i, n)); !o.next().done; ) {
    if (a.length > 1e3)
      return false;
    o.value.from == i && (s = a.length), a.push($2.range(o.value.from, o.value.to));
  }
  return t(e.update({
    selection: $2.create(a, s),
    userEvent: "select.search.matches"
  })), true;
};
var oh = Aa((e, { query: t }) => {
  let { state: r } = e, { from: i, to: n } = r.selection.main;
  if (r.readOnly)
    return false;
  let a = t.nextMatch(r, i, i);
  if (!a)
    return false;
  let s = [], o, l, c = [];
  if (a.from == i && a.to == n && (l = r.toText(t.getReplacement(a)), s.push({ from: a.from, to: a.to, insert: l }), a = t.nextMatch(r, a.from, a.to), c.push(ua.announce.of(r.phrase("replaced match on line $", r.doc.lineAt(i).number) + "."))), a) {
    let f = s.length == 0 || s[0].from >= a.to ? 0 : a.to - a.from - l.length;
    o = $2.single(a.from - f, a.to - f), c.push(ec(e, a)), c.push(r.facet(Pn).scrollToMatch(o.main, e));
  }
  return e.dispatch({
    changes: s,
    selection: o,
    effects: c,
    userEvent: "input.replace"
  }), true;
});
var XI = Aa((e, { query: t }) => {
  if (e.state.readOnly)
    return false;
  let r = t.matchAll(e.state, 1e9).map((n) => {
    let { from: a, to: s } = n;
    return { from: a, to: s, insert: t.getReplacement(n) };
  });
  if (!r.length)
    return false;
  let i = e.state.phrase("replaced $ matches", r.length) + ".";
  return e.dispatch({
    changes: r,
    effects: ua.announce.of(i),
    userEvent: "input.replace.all"
  }), true;
});
function Ku(e) {
  return e.state.facet(Pn).createPanel(e);
}
function Al(e, t) {
  var r, i, n, a, s;
  let o = e.selection.main, l = o.empty || o.to > o.from + 100 ? "" : e.sliceDoc(o.from, o.to);
  if (t && !l)
    return t;
  let c = e.facet(Pn);
  return new lE({
    search: ((r = t == null ? void 0 : t.literal) !== null && r !== void 0 ? r : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = t == null ? void 0 : t.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (n = t == null ? void 0 : t.literal) !== null && n !== void 0 ? n : c.literal,
    regexp: (a = t == null ? void 0 : t.regexp) !== null && a !== void 0 ? a : c.regexp,
    wholeWord: (s = t == null ? void 0 : t.wholeWord) !== null && s !== void 0 ? s : c.wholeWord
  });
}
function cE(e) {
  let t = xlr(e, Ku);
  return t && t.dom.querySelector("[main-field]");
}
function fE(e) {
  let t = cE(e);
  t && t == e.root.activeElement && t.select();
}
var hE = (e) => {
  let t = e.state.field(Ei, false);
  if (t && t.panel) {
    let r = cE(e);
    if (r && r != e.root.activeElement) {
      let i = Al(e.state, t.query.spec);
      i.valid && e.dispatch({ effects: aa.of(i) }), r.focus(), r.select();
    }
  } else
    e.dispatch({ effects: [
      Ju.of(true),
      t ? aa.of(Al(e.state, t.query.spec)) : Eo.appendConfig.of(zI)
    ] });
  return true;
};
var pE = (e) => {
  let t = e.state.field(Ei, false);
  if (!t || !t.panel)
    return false;
  let r = xlr(e, Ku);
  return r && r.dom.contains(e.root.activeElement) && e.focus(), e.dispatch({ effects: Ju.of(false) }), true;
};
var jI = [
  { key: "Mod-f", run: hE, scope: "editor search-panel" },
  { key: "F3", run: bs, shift: vs, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: bs, shift: vs, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: pE, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: WI },
  { key: "Mod-Alt-g", run: NI },
  { key: "Mod-d", run: MI, preventDefault: true }
];
var ZI = class {
  constructor(t) {
    this.view = t;
    let r = this.query = t.state.field(Ei).query.spec;
    this.commit = this.commit.bind(this), this.searchField = at("input", {
      value: r.search,
      placeholder: ir(t, "Find"),
      "aria-label": ir(t, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = at("input", {
      value: r.replace,
      placeholder: ir(t, "Replace"),
      "aria-label": ir(t, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = at("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: r.caseSensitive,
      onchange: this.commit
    }), this.reField = at("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: r.regexp,
      onchange: this.commit
    }), this.wordField = at("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: r.wholeWord,
      onchange: this.commit
    });
    function i(n, a, s) {
      return at("button", { class: "cm-button", name: n, onclick: a, type: "button" }, s);
    }
    this.dom = at("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => bs(t), [ir(t, "next")]),
      i("prev", () => vs(t), [ir(t, "previous")]),
      i("select", () => FI(t), [ir(t, "all")]),
      at("label", null, [this.caseField, ir(t, "match case")]),
      at("label", null, [this.reField, ir(t, "regexp")]),
      at("label", null, [this.wordField, ir(t, "by word")]),
      ...t.state.readOnly ? [] : [
        at("br"),
        this.replaceField,
        i("replace", () => oh(t), [ir(t, "replace")]),
        i("replaceAll", () => XI(t), [ir(t, "replace all")])
      ],
      at("button", {
        name: "close",
        onclick: () => pE(t),
        "aria-label": ir(t, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let t = new lE({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    t.eq(this.query) || (this.query = t, this.view.dispatch({ effects: aa.of(t) }));
  }
  keydown(t) {
    hlr(this.view, t, "search-panel") ? t.preventDefault() : t.keyCode == 13 && t.target == this.searchField ? (t.preventDefault(), (t.shiftKey ? vs : bs)(this.view)) : t.keyCode == 13 && t.target == this.replaceField && (t.preventDefault(), oh(this.view));
  }
  update(t) {
    for (let r of t.transactions)
      for (let i of r.effects)
        i.is(aa) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(t) {
    this.query = t, this.searchField.value = t.search, this.replaceField.value = t.replace, this.caseField.checked = t.caseSensitive, this.reField.checked = t.regexp, this.wordField.checked = t.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Pn).top;
  }
};
function ir(e, t) {
  return e.state.phrase(t);
}
var Qa = 30;
var Ga = /[\s\.,:;?!]/;
function ec(e, { from: t, to: r }) {
  let i = e.state.doc.lineAt(t), n = e.state.doc.lineAt(r).to, a = Math.max(i.from, t - Qa), s = Math.min(n, r + Qa), o = e.state.sliceDoc(a, s);
  if (a != i.from) {
    for (let l = 0; l < Qa; l++)
      if (!Ga.test(o[l + 1]) && Ga.test(o[l])) {
        o = o.slice(l);
        break;
      }
  }
  if (s != n) {
    for (let l = o.length - 1; l > o.length - Qa; l--)
      if (!Ga.test(o[l - 1]) && Ga.test(o[l])) {
        o = o.slice(0, l);
        break;
      }
  }
  return ua.announce.of(`${e.state.phrase("current match")}. ${o} ${e.state.phrase("on line")} ${i.number}.`);
}
var HI = ua.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var zI = [
  Ei,
  GP1.low(YI),
  HI
];
var qI = class {
  constructor(t, r, i) {
    this.from = t, this.to = r, this.diagnostic = i;
  }
};
var Di = class _Di {
  constructor(t, r, i) {
    this.diagnostics = t, this.panel = r, this.selected = i;
  }
  static init(t, r, i) {
    let n = t, a = i.facet(wi).markerFilter;
    a && (n = a(n, i));
    let s = Ao.set(n.map((o) => o.from == o.to || o.from == o.to - 1 && i.doc.lineAt(o.from).to == o.from ? Ao.widget({
      widget: new oN(o),
      diagnostic: o
    }).range(o.from) : Ao.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + o.severity + (o.markClass ? " " + o.markClass : "") },
      diagnostic: o,
      inclusive: true
    }).range(o.from, o.to)), true);
    return new _Di(s, r, On(s));
  }
};
function On(e, t = null, r = 0) {
  let i = null;
  return e.between(r, 1e9, (n, a, { spec: s }) => {
    if (!(t && s.diagnostic != t))
      return i = new qI(n, a, s.diagnostic), false;
  }), i;
}
function JI(e, t) {
  let r = e.startState.doc.lineAt(t.pos);
  return !!(e.effects.some((i) => i.is(tc)) || e.changes.touchesRange(r.from, r.to));
}
function OE(e, t) {
  return e.field(sr, false) ? t : t.concat(Eo.appendConfig.of(SE));
}
function KI(e, t) {
  return {
    effects: OE(e, [tc.of(t)])
  };
}
var tc = Eo.define();
var rc = Eo.define();
var EE = Eo.define();
var sr = tu.define({
  create() {
    return new Di(Ao.none, null, null);
  },
  update(e, t) {
    if (t.docChanged) {
      let r = e.diagnostics.map(t.changes), i = null;
      if (e.selected) {
        let n = t.changes.mapPos(e.selected.from, 1);
        i = On(r, e.selected.diagnostic, n) || On(r, null, n);
      }
      e = new Di(r, e.panel, i);
    }
    for (let r of t.effects)
      r.is(tc) ? e = Di.init(r.value, e.panel, t.state) : r.is(rc) ? e = new Di(e.diagnostics, r.value ? Hs.open : null, e.selected) : r.is(EE) && (e = new Di(e.diagnostics, e.panel, r.value));
    return e;
  },
  provide: (e) => [
    qbe.from(e, (t) => t.panel),
    ua.decorations.from(e, (t) => t.diagnostics)
  ]
});
var eN = Ao.mark({ class: "cm-lintRange cm-lintRange-active", inclusive: true });
function tN(e, t, r) {
  let { diagnostics: i } = e.state.field(sr), n = [], a = 2e8, s = 0;
  i.between(t - (r < 0 ? 1 : 0), t + (r > 0 ? 1 : 0), (l, c, { spec: f }) => {
    t >= l && t <= c && (l == c || (t > l || r > 0) && (t < c || r < 0)) && (n.push(f.diagnostic), a = Math.min(l, a), s = Math.max(c, s));
  });
  let o = e.state.facet(wi).tooltipFilter;
  return o && (n = o(n, e.state)), n.length ? {
    pos: a,
    end: s,
    above: e.state.doc.lineAt(a).to < s,
    create() {
      return { dom: rN(e, n) };
    }
  } : null;
}
function rN(e, t) {
  return at("ul", { class: "cm-tooltip-lint" }, t.map((r) => TE(e, r, false)));
}
var iN = (e) => {
  let t = e.state.field(sr, false);
  (!t || !t.panel) && e.dispatch({ effects: OE(e.state, [rc.of(true)]) });
  let r = xlr(e, Hs.open);
  return r && r.dom.querySelector(".cm-panel-lint ul").focus(), true;
};
var lh = (e) => {
  let t = e.state.field(sr, false);
  return !t || !t.panel ? false : (e.dispatch({ effects: rc.of(false) }), true);
};
var nN = (e) => {
  let t = e.state.field(sr, false);
  if (!t)
    return false;
  let r = e.state.selection.main, i = t.diagnostics.iter(r.to + 1);
  return !i.value && (i = t.diagnostics.iter(0), !i.value || i.from == r.from && i.to == r.to) ? false : (e.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: true }), true);
};
var aN = [
  { key: "Mod-Shift-m", run: iN, preventDefault: true },
  { key: "F8", run: nN }
];
var sN = k0.fromClass(class {
  constructor(e) {
    this.view = e, this.timeout = -1, this.set = true;
    let { delay: t } = e.state.facet(wi);
    this.lintTime = Date.now() + t, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, t);
  }
  run() {
    let e = Date.now();
    if (e < this.lintTime - 10)
      this.timeout = setTimeout(this.run, this.lintTime - e);
    else {
      this.set = false;
      let { state: t } = this.view, { sources: r } = t.facet(wi);
      r.length && Promise.all(r.map((i) => Promise.resolve(i(this.view)))).then((i) => {
        let n = i.reduce((a, s) => a.concat(s));
        this.view.state.doc == t.doc && this.view.dispatch(KI(this.view.state, n));
      }, (i) => {
        A6(this.view.state, i);
      });
    }
  }
  update(e) {
    let t = e.state.facet(wi);
    (e.docChanged || t != e.startState.facet(wi) || t.needsRefresh && t.needsRefresh(e)) && (this.lintTime = Date.now() + t.delay, this.set || (this.set = true, this.timeout = setTimeout(this.run, t.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
var wi = Tn.define({
  combine(e) {
    return Object.assign({ sources: e.map((t) => t.source).filter((t) => t != null) }, rF1(e.map((t) => t.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (t, r) => t ? r ? (i) => t(i) || r(i) : t : r
    }));
  }
});
function uh(e, t = {}) {
  return [
    wi.of({ source: e, config: t }),
    sN,
    SE
  ];
}
function dE(e) {
  let t = [];
  if (e)
    e:
      for (let { name: r } of e) {
        for (let i = 0; i < r.length; i++) {
          let n = r[i];
          if (/[a-zA-Z]/.test(n) && !t.some((a) => a.toLowerCase() == n.toLowerCase())) {
            t.push(n);
            continue e;
          }
        }
        t.push("");
      }
  return t;
}
function TE(e, t, r) {
  var i;
  let n = r ? dE(t.actions) : [];
  return at("li", { class: "cm-diagnostic cm-diagnostic-" + t.severity }, at("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage() : t.message), (i = t.actions) === null || i === void 0 ? void 0 : i.map((a, s) => {
    let o = false, l = (O) => {
      if (O.preventDefault(), o)
        return;
      o = true;
      let d2 = On(e.state.field(sr).diagnostics, t);
      d2 && a.apply(e, d2.from, d2.to);
    }, { name: c } = a, f = n[s] ? c.indexOf(n[s]) : -1, p = f < 0 ? c : [
      c.slice(0, f),
      at("u", c.slice(f, f + 1)),
      c.slice(f + 1)
    ];
    return at("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${f < 0 ? "" : ` (access key "${n[s]})"`}.`
    }, p);
  }), t.source && at("div", { class: "cm-diagnosticSource" }, t.source));
}
var oN = class extends am {
  constructor(t) {
    super(), this.diagnostic = t;
  }
  eq(t) {
    return t.diagnostic == this.diagnostic;
  }
  toDOM() {
    return at("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var ch = class {
  constructor(t, r) {
    this.diagnostic = r, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = TE(t, r, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
};
var Hs = class _Hs {
  constructor(t) {
    this.view = t, this.items = [];
    let r = (n) => {
      if (n.keyCode == 27)
        lh(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: a } = this.items[this.selectedIndex], s = dE(a.actions);
        for (let o = 0; o < s.length; o++)
          if (s[o].toUpperCase().charCodeAt(0) == n.keyCode) {
            let l = On(this.view.state.field(sr).diagnostics, a);
            l && a.actions[o].apply(t, l.from, l.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let a = 0; a < this.items.length; a++)
        this.items[a].dom.contains(n.target) && this.moveSelection(a);
    };
    this.list = at("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: r,
      onclick: i
    }), this.dom = at("div", { class: "cm-panel-lint" }, this.list, at("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => lh(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let t = this.view.state.field(sr).selected;
    if (!t)
      return -1;
    for (let r = 0; r < this.items.length; r++)
      if (this.items[r].diagnostic == t.diagnostic)
        return r;
    return -1;
  }
  update() {
    let { diagnostics: t, selected: r } = this.view.state.field(sr), i = 0, n = false, a = null;
    for (t.between(0, this.view.state.doc.length, (s, o, { spec: l }) => {
      let c = -1, f;
      for (let p = i; p < this.items.length; p++)
        if (this.items[p].diagnostic == l.diagnostic) {
          c = p;
          break;
        }
      c < 0 ? (f = new ch(this.view, l.diagnostic), this.items.splice(i, 0, f), n = true) : (f = this.items[c], c > i && (this.items.splice(i, c - i), n = true)), r && f.diagnostic == r.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), a = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = true, this.items.pop();
    this.items.length == 0 && (this.items.push(new ch(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = true), a ? (this.list.setAttribute("aria-activedescendant", a.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: s, panel: o }) => {
        let l = o.height / this.list.offsetHeight;
        s.top < o.top ? this.list.scrollTop -= (o.top - s.top) / l : s.bottom > o.bottom && (this.list.scrollTop += (s.bottom - o.bottom) / l);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let t = this.list.firstChild;
    function r() {
      let i = t;
      t = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; t != i.dom; )
          r();
        t = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, t);
    for (; t; )
      r();
  }
  moveSelection(t) {
    if (this.selectedIndex < 0)
      return;
    let r = this.view.state.field(sr), i = On(r.diagnostics, this.items[t].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: true,
      effects: EE.of(i)
    });
  }
  static open(t) {
    return new _Hs(t);
  }
};
function lN(e, t = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(e)}</svg>')`;
}
function Va(e) {
  return lN(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${e}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
var uN = ua.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: Va("#d11") },
  ".cm-lintRange-warning": { backgroundImage: Va("orange") },
  ".cm-lintRange-info": { backgroundImage: Va("#999") },
  ".cm-lintRange-hint": { backgroundImage: Va("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
var SE = [
  sr,
  ua.decorations.compute([sr], (e) => {
    let { selected: t, panel: r } = e.field(sr);
    return !t || !r || t.from == t.to ? Ao.none : Ao.set([
      eN.range(t.from, t.to)
    ]);
  }),
  Elr(tN, { hideOn: JI }),
  uN
];
function ic(e, t) {
  if (t)
    return true;
  const {
    state: r,
    pos: i
  } = e, n = r.sliceDoc(0, i), a = Ux(n);
  let s = 0;
  for (const o of a) {
    const l = s, c = o.indexOf("{{"), f = c > -1, p = c + l + 2, O = o.indexOf("}}"), d2 = O > -1, g = O + l;
    if (f && p <= i && (!d2 || i <= g))
      return true;
    s += o.length;
  }
  return false;
}
var gl = { exports: {} };
var Ba = { exports: {} };
var Vo = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var Bo = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var cN = {
  5: Bo,
  "5module": Bo + " export import",
  6: Bo + " const class extends export import super"
};
var fN = /^in(stanceof)?$/;
var nc = "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var mE = "--------------------------------------------------------------------------------------------------------------------------------------------------";
var hN = new RegExp("[" + nc + "]");
var pN = new RegExp("[" + nc + mE + "]");
nc = mE = null;
var RE = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];
var ON = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];
function yl(e, t) {
  for (var r = 65536, i = 0; i < t.length; i += 2) {
    if (r += t[i], r > e)
      return false;
    if (r += t[i + 1], r >= e)
      return true;
  }
}
function ti(e, t) {
  return e < 65 ? e === 36 : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && hN.test(String.fromCharCode(e)) : t === false ? false : yl(e, RE);
}
function Fi(e, t) {
  return e < 48 ? e === 36 : e < 58 ? true : e < 65 ? false : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && pN.test(String.fromCharCode(e)) : t === false ? false : yl(e, RE) || yl(e, ON);
}
var Ze = function(t, r) {
  r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
};
function Ir(e, t) {
  return new Ze(e, { beforeExpr: true, binop: t });
}
var pr = { beforeExpr: true };
var nr = { startsExpr: true };
var zs = {};
function Ve(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, zs[e] = new Ze(e, t);
}
var v = {
  num: new Ze("num", nr),
  regexp: new Ze("regexp", nr),
  string: new Ze("string", nr),
  name: new Ze("name", nr),
  eof: new Ze("eof"),
  // Punctuation token types.
  bracketL: new Ze("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new Ze("]"),
  braceL: new Ze("{", { beforeExpr: true, startsExpr: true }),
  braceR: new Ze("}"),
  parenL: new Ze("(", { beforeExpr: true, startsExpr: true }),
  parenR: new Ze(")"),
  comma: new Ze(",", pr),
  semi: new Ze(";", pr),
  colon: new Ze(":", pr),
  dot: new Ze("."),
  question: new Ze("?", pr),
  arrow: new Ze("=>", pr),
  template: new Ze("template"),
  invalidTemplate: new Ze("invalidTemplate"),
  ellipsis: new Ze("...", pr),
  backQuote: new Ze("`", nr),
  dollarBraceL: new Ze("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new Ze("=", { beforeExpr: true, isAssign: true }),
  assign: new Ze("_=", { beforeExpr: true, isAssign: true }),
  incDec: new Ze("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new Ze("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: Ir("||", 1),
  logicalAND: Ir("&&", 2),
  bitwiseOR: Ir("|", 3),
  bitwiseXOR: Ir("^", 4),
  bitwiseAND: Ir("&", 5),
  equality: Ir("==/!=/===/!==", 6),
  relational: Ir("</>/<=/>=", 7),
  bitShift: Ir("<</>>/>>>", 8),
  plusMin: new Ze("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: Ir("%", 10),
  star: Ir("*", 10),
  slash: Ir("/", 10),
  starstar: new Ze("**", { beforeExpr: true }),
  // Keyword token types.
  _break: Ve("break"),
  _case: Ve("case", pr),
  _catch: Ve("catch"),
  _continue: Ve("continue"),
  _debugger: Ve("debugger"),
  _default: Ve("default", pr),
  _do: Ve("do", { isLoop: true, beforeExpr: true }),
  _else: Ve("else", pr),
  _finally: Ve("finally"),
  _for: Ve("for", { isLoop: true }),
  _function: Ve("function", nr),
  _if: Ve("if"),
  _return: Ve("return", pr),
  _switch: Ve("switch"),
  _throw: Ve("throw", pr),
  _try: Ve("try"),
  _var: Ve("var"),
  _const: Ve("const"),
  _while: Ve("while", { isLoop: true }),
  _with: Ve("with"),
  _new: Ve("new", { beforeExpr: true, startsExpr: true }),
  _this: Ve("this", nr),
  _super: Ve("super", nr),
  _class: Ve("class", nr),
  _extends: Ve("extends", pr),
  _export: Ve("export"),
  _import: Ve("import", nr),
  _null: Ve("null", nr),
  _true: Ve("true", nr),
  _false: Ve("false", nr),
  _in: Ve("in", { beforeExpr: true, binop: 7 }),
  _instanceof: Ve("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: Ve("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: Ve("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: Ve("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var Ar = /\r\n?|\n|\u2028|\u2029/;
var En = new RegExp(Ar.source, "g");
function _n(e, t) {
  return e === 10 || e === 13 || !t && (e === 8232 || e === 8233);
}
var ac = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var Br = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var AE = Object.prototype;
var EN = AE.hasOwnProperty;
var dN = AE.toString;
function qs(e, t) {
  return EN.call(e, t);
}
var fh = Array.isArray || function(e) {
  return dN.call(e) === "[object Array]";
};
function Mi(e) {
  return new RegExp("^(?:" + e.replace(/ /g, "|") + ")$");
}
var dn = function(t, r) {
  this.line = t, this.column = r;
};
dn.prototype.offset = function(t) {
  return new dn(this.line, this.column + t);
};
var ga = function(t, r, i) {
  this.start = r, this.end = i, t.sourceFile !== null && (this.source = t.sourceFile);
};
function sc(e, t) {
  for (var r = 1, i = 0; ; ) {
    En.lastIndex = i;
    var n = En.exec(e);
    if (n && n.index < t)
      ++r, i = n.index + n[0].length;
    else
      return new dn(r, t - i);
  }
}
var Cs = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
function TN(e) {
  var t = {};
  for (var r in Cs)
    t[r] = e && qs(e, r) ? e[r] : Cs[r];
  if (t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), fh(t.onToken)) {
    var i = t.onToken;
    t.onToken = function(n) {
      return i.push(n);
    };
  }
  return fh(t.onComment) && (t.onComment = SN(t, t.onComment)), t;
}
function SN(e, t) {
  return function(r, i, n, a, s, o) {
    var l = {
      type: r ? "Block" : "Line",
      value: i,
      start: n,
      end: a
    };
    e.locations && (l.loc = new ga(this, s, o)), e.ranges && (l.range = [n, a]), t.push(l);
  };
}
var sa = 1;
var ya = 2;
var oc = sa | ya;
var gE = 4;
var yE = 8;
var IE = 16;
var NE = 32;
var PE = 64;
var _E2 = 128;
function lc(e, t) {
  return ya | (e ? gE : 0) | (t ? yE : 0);
}
var hh = 0;
var uc = 1;
var Kr = 2;
var bE = 3;
var vE = 4;
var CE = 5;
var Et = function(t, r, i) {
  this.options = t = TN(t), this.sourceFile = t.sourceFile, this.keywords = Mi(cN[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var n = "";
  if (t.allowReserved !== true) {
    for (var a = t.ecmaVersion; !(n = Vo[a]); a--)
      ;
    t.sourceType === "module" && (n += " await");
  }
  this.reservedWords = Mi(n);
  var s = (n ? n + " " : "") + Vo.strict;
  this.reservedWordsStrict = Mi(s), this.reservedWordsStrictBind = Mi(s + " " + Vo.strictBind), this.input = String(r), this.containsEsc = false, i ? (this.pos = i, this.lineStart = this.input.lastIndexOf(`
`, i - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Ar).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = v.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(sa), this.regexpState = null;
};
var Zi = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true } };
Et.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
Zi.inFunction.get = function() {
  return (this.currentVarScope().flags & ya) > 0;
};
Zi.inGenerator.get = function() {
  return (this.currentVarScope().flags & yE) > 0;
};
Zi.inAsync.get = function() {
  return (this.currentVarScope().flags & gE) > 0;
};
Zi.allowSuper.get = function() {
  return (this.currentThisScope().flags & PE) > 0;
};
Zi.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & _E2) > 0;
};
Zi.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
Et.prototype.inNonArrowFunction = function() {
  return (this.currentThisScope().flags & ya) > 0;
};
Et.extend = function() {
  for (var t = [], r = arguments.length; r--; )
    t[r] = arguments[r];
  for (var i = this, n = 0; n < t.length; n++)
    i = t[n](i);
  return i;
};
Et.parse = function(t, r) {
  return new this(r, t).parse();
};
Et.parseExpressionAt = function(t, r, i) {
  var n = new this(i, t, r);
  return n.nextToken(), n.parseExpression();
};
Et.tokenizer = function(t, r) {
  return new this(r, t);
};
Object.defineProperties(Et.prototype, Zi);
var Zt = Et.prototype;
var mN = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
Zt.strictDirective = function(e) {
  for (; ; ) {
    Br.lastIndex = e, e += Br.exec(this.input)[0].length;
    var t = mN.exec(this.input.slice(e));
    if (!t)
      return false;
    if ((t[1] || t[2]) === "use strict")
      return true;
    e += t[0].length, Br.lastIndex = e, e += Br.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
Zt.eat = function(e) {
  return this.type === e ? (this.next(), true) : false;
};
Zt.isContextual = function(e) {
  return this.type === v.name && this.value === e && !this.containsEsc;
};
Zt.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), true) : false;
};
Zt.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
Zt.canInsertSemicolon = function() {
  return this.type === v.eof || this.type === v.braceR || Ar.test(this.input.slice(this.lastTokEnd, this.start));
};
Zt.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
};
Zt.semicolon = function() {
  !this.eat(v.semi) && !this.insertSemicolon() && this.unexpected();
};
Zt.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), true;
};
Zt.expect = function(e) {
  this.eat(e) || this.unexpected();
};
Zt.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
function oa() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
Zt.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
    r > -1 && this.raiseRecoverable(r, "Parenthesized pattern");
  }
};
Zt.checkExpressionErrors = function(e, t) {
  if (!e)
    return false;
  var r = e.shorthandAssign, i = e.doubleProto;
  if (!t)
    return r >= 0 || i >= 0;
  r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), i >= 0 && this.raiseRecoverable(i, "Redefinition of __proto__ property");
};
Zt.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
Zt.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var be = Et.prototype;
be.parseTopLevel = function(e) {
  var t = {};
  for (e.body || (e.body = []); this.type !== v.eof; ) {
    var r = this.parseStatement(null, true, t);
    e.body.push(r);
  }
  if (this.inModule)
    for (var i = 0, n = Object.keys(this.undefinedExports); i < n.length; i += 1) {
      var a = n[i];
      this.raiseRecoverable(this.undefinedExports[a].start, "Export '" + a + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var cc = { kind: "loop" };
var RN = { kind: "switch" };
be.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return false;
  Br.lastIndex = this.pos;
  var t = Br.exec(this.input), r = this.pos + t[0].length, i = this.input.charCodeAt(r);
  if (i === 91)
    return true;
  if (e)
    return false;
  if (i === 123)
    return true;
  if (ti(i, true)) {
    for (var n = r + 1; Fi(this.input.charCodeAt(n), true); )
      ++n;
    var a = this.input.slice(r, n);
    if (!fN.test(a))
      return true;
  }
  return false;
};
be.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return false;
  Br.lastIndex = this.pos;
  var e = Br.exec(this.input), t = this.pos + e[0].length;
  return !Ar.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !Fi(this.input.charAt(t + 8)));
};
be.parseStatement = function(e, t, r) {
  var i = this.type, n = this.startNode(), a;
  switch (this.isLet(e) && (i = v._var, a = "let"), i) {
    case v._break:
    case v._continue:
      return this.parseBreakContinueStatement(n, i.keyword);
    case v._debugger:
      return this.parseDebuggerStatement(n);
    case v._do:
      return this.parseDoStatement(n);
    case v._for:
      return this.parseForStatement(n);
    case v._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, false, !e);
    case v._class:
      return e && this.unexpected(), this.parseClass(n, true);
    case v._if:
      return this.parseIfStatement(n);
    case v._return:
      return this.parseReturnStatement(n);
    case v._switch:
      return this.parseSwitchStatement(n);
    case v._throw:
      return this.parseThrowStatement(n);
    case v._try:
      return this.parseTryStatement(n);
    case v._const:
    case v._var:
      return a = a || this.value, e && a !== "var" && this.unexpected(), this.parseVarStatement(n, a);
    case v._while:
      return this.parseWhileStatement(n);
    case v._with:
      return this.parseWithStatement(n);
    case v.braceL:
      return this.parseBlock(true, n);
    case v.semi:
      return this.parseEmptyStatement(n);
    case v._export:
    case v._import:
      if (this.options.ecmaVersion > 10 && i === v._import) {
        Br.lastIndex = this.pos;
        var s = Br.exec(this.input), o = this.pos + s[0].length, l = this.input.charCodeAt(o);
        if (l === 40)
          return this.parseExpressionStatement(n, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === v._import ? this.parseImport(n) : this.parseExport(n, r);
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(n, true, !e);
      var c = this.value, f = this.parseExpression();
      return i === v.name && f.type === "Identifier" && this.eat(v.colon) ? this.parseLabeledStatement(n, c, f, e) : this.parseExpressionStatement(n, f);
  }
};
be.parseBreakContinueStatement = function(e, t) {
  var r = t === "break";
  this.next(), this.eat(v.semi) || this.insertSemicolon() ? e.label = null : this.type !== v.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var i = 0; i < this.labels.length; ++i) {
    var n = this.labels[i];
    if ((e.label == null || n.name === e.label.name) && (n.kind != null && (r || n.kind === "loop") || e.label && r))
      break;
  }
  return i === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
};
be.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
be.parseDoStatement = function(e) {
  return this.next(), this.labels.push(cc), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(v._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(v.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
be.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(cc), this.enterScope(0), this.expect(v.parenL), this.type === v.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var r = this.isLet();
  if (this.type === v._var || this.type === v._const || r) {
    var i = this.startNode(), n = r ? "let" : this.value;
    return this.next(), this.parseVar(i, true, n), this.finishNode(i, "VariableDeclaration"), (this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && i.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === v._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, i)) : (t > -1 && this.unexpected(t), this.parseFor(e, i));
  }
  var a = new oa(), s = this.parseExpression(true, a);
  return this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === v._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.toAssignable(s, false, a), this.checkLVal(s), this.parseForIn(e, s)) : (this.checkExpressionErrors(a, true), t > -1 && this.unexpected(t), this.parseFor(e, s));
};
be.parseFunctionStatement = function(e, t, r) {
  return this.next(), this.parseFunction(e, Wn | (r ? 0 : Il), false, t);
};
be.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(v._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
be.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(v.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
be.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(v.braceL), this.labels.push(RN), this.enterScope(0);
  for (var t, r = false; this.type !== v.braceR; )
    if (this.type === v._case || this.type === v._default) {
      var i = this.type === v._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), i ? t.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = true, t.test = null), this.expect(v.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
be.parseThrowStatement = function(e) {
  return this.next(), Ar.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var AN = [];
be.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === v._catch) {
    var t = this.startNode();
    if (this.next(), this.eat(v.parenL)) {
      t.param = this.parseBindingAtom();
      var r = t.param.type === "Identifier";
      this.enterScope(r ? NE : 0), this.checkLVal(t.param, r ? vE : Kr), this.expect(v.parenR);
    } else
      this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0);
    t.body = this.parseBlock(false), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(v._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
be.parseVarStatement = function(e, t) {
  return this.next(), this.parseVar(e, false, t), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
be.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(cc), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
be.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
be.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
be.parseLabeledStatement = function(e, t, r, i) {
  for (var n = 0, a = this.labels; n < a.length; n += 1) {
    var s = a[n];
    s.name === t && this.raise(r.start, "Label '" + t + "' is already declared");
  }
  for (var o = this.type.isLoop ? "loop" : this.type === v._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var c = this.labels[l];
    if (c.statementStart === e.start)
      c.statementStart = this.start, c.kind = o;
    else
      break;
  }
  return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i + "label" : i : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
};
be.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
be.parseBlock = function(e, t) {
  for (e === void 0 && (e = true), t === void 0 && (t = this.startNode()), t.body = [], this.expect(v.braceL), e && this.enterScope(0); !this.eat(v.braceR); ) {
    var r = this.parseStatement(null);
    t.body.push(r);
  }
  return e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
be.parseFor = function(e, t) {
  return e.init = t, this.expect(v.semi), e.test = this.type === v.semi ? null : this.parseExpression(), this.expect(v.semi), e.update = this.type === v.parenR ? null : this.parseExpression(), this.expect(v.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
be.parseForIn = function(e, t) {
  var r = this.type === v._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") ? this.raise(
    t.start,
    (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ) : t.type === "AssignmentPattern" && this.raise(t.start, "Invalid left-hand side in for-loop"), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(v.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
};
be.parseVar = function(e, t, r) {
  for (e.declarations = [], e.kind = r; ; ) {
    var i = this.startNode();
    if (this.parseVarId(i, r), this.eat(v.eq) ? i.init = this.parseMaybeAssign(t) : r === "const" && !(this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : i.id.type !== "Identifier" && !(t && (this.type === v._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(v.comma))
      break;
  }
  return e;
};
be.parseVarId = function(e, t) {
  e.id = this.parseBindingAtom(), this.checkLVal(e.id, t === "var" ? uc : Kr, false);
};
var Wn = 1;
var Il = 2;
var LE = 4;
be.parseFunction = function(e, t, r, i) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i) && (this.type === v.star && t & Il && this.unexpected(), e.generator = this.eat(v.star)), this.options.ecmaVersion >= 8 && (e.async = !!i), t & Wn && (e.id = t & LE && this.type !== v.name ? null : this.parseIdent(), e.id && !(t & Il) && this.checkLVal(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? uc : Kr : bE));
  var n = this.yieldPos, a = this.awaitPos, s = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(lc(e.async, e.generator)), t & Wn || (e.id = this.type === v.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, false), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = s, this.finishNode(e, t & Wn ? "FunctionDeclaration" : "FunctionExpression");
};
be.parseFunctionParams = function(e) {
  this.expect(v.parenL), e.params = this.parseBindingList(v.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
be.parseClass = function(e, t) {
  this.next();
  var r = this.strict;
  this.strict = true, this.parseClassId(e, t), this.parseClassSuper(e);
  var i = this.startNode(), n = false;
  for (i.body = [], this.expect(v.braceL); !this.eat(v.braceR); ) {
    var a = this.parseClassElement(e.superClass !== null);
    a && (i.body.push(a), a.type === "MethodDefinition" && a.kind === "constructor" && (n && this.raise(a.start, "Duplicate constructor in the same class"), n = true));
  }
  return e.body = this.finishNode(i, "ClassBody"), this.strict = r, this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
be.parseClassElement = function(e) {
  var t = this;
  if (this.eat(v.semi))
    return null;
  var r = this.startNode(), i = function(l, c) {
    c === void 0 && (c = false);
    var f = t.start, p = t.startLoc;
    return t.eatContextual(l) ? t.type !== v.parenL && (!c || !t.canInsertSemicolon()) ? true : (r.key && t.unexpected(), r.computed = false, r.key = t.startNodeAt(f, p), r.key.name = l, t.finishNode(r.key, "Identifier"), false) : false;
  };
  r.kind = "method", r.static = i("static");
  var n = this.eat(v.star), a = false;
  n || (this.options.ecmaVersion >= 8 && i("async", true) ? (a = true, n = this.options.ecmaVersion >= 9 && this.eat(v.star)) : i("get") ? r.kind = "get" : i("set") && (r.kind = "set")), r.key || this.parsePropertyName(r);
  var s = r.key, o = false;
  return !r.computed && !r.static && (s.type === "Identifier" && s.name === "constructor" || s.type === "Literal" && s.value === "constructor") ? (r.kind !== "method" && this.raise(s.start, "Constructor can't have get/set modifier"), n && this.raise(s.start, "Constructor can't be a generator"), a && this.raise(s.start, "Constructor can't be an async method"), r.kind = "constructor", o = e) : r.static && s.type === "Identifier" && s.name === "prototype" && this.raise(s.start, "Classes may not have a static property named prototype"), this.parseClassMethod(r, n, a, o), r.kind === "get" && r.value.params.length !== 0 && this.raiseRecoverable(r.value.start, "getter should have no params"), r.kind === "set" && r.value.params.length !== 1 && this.raiseRecoverable(r.value.start, "setter should have exactly one param"), r.kind === "set" && r.value.params[0].type === "RestElement" && this.raiseRecoverable(r.value.params[0].start, "Setter cannot use rest params"), r;
};
be.parseClassMethod = function(e, t, r, i) {
  return e.value = this.parseMethod(t, r, i), this.finishNode(e, "MethodDefinition");
};
be.parseClassId = function(e, t) {
  this.type === v.name ? (e.id = this.parseIdent(), t && this.checkLVal(e.id, Kr, false)) : (t === true && this.unexpected(), e.id = null);
};
be.parseClassSuper = function(e) {
  e.superClass = this.eat(v._extends) ? this.parseExprSubscripts() : null;
};
be.parseExport = function(e, t) {
  if (this.next(), this.eat(v.star))
    return this.expectContextual("from"), this.type !== v.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
  if (this.eat(v._default)) {
    this.checkExport(t, "default", this.lastTokStart);
    var r;
    if (this.type === v._function || (r = this.isAsyncFunction())) {
      var i = this.startNode();
      this.next(), r && this.next(), e.declaration = this.parseFunction(i, Wn | LE, false, r);
    } else if (this.type === v._class) {
      var n = this.startNode();
      e.declaration = this.parseClass(n, "nullableID");
    } else
      e.declaration = this.parseMaybeAssign(), this.semicolon();
    return this.finishNode(e, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement())
    e.declaration = this.parseStatement(null), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id.name, e.declaration.id.start), e.specifiers = [], e.source = null;
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== v.string && this.unexpected(), e.source = this.parseExprAtom();
    else {
      for (var a = 0, s = e.specifiers; a < s.length; a += 1) {
        var o = s[a];
        this.checkUnreserved(o.local), this.checkLocalExport(o.local);
      }
      e.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
be.checkExport = function(e, t, r) {
  e && (qs(e, t) && this.raiseRecoverable(r, "Duplicate export '" + t + "'"), e[t] = true);
};
be.checkPatternExport = function(e, t) {
  var r = t.type;
  if (r === "Identifier")
    this.checkExport(e, t.name, t.start);
  else if (r === "ObjectPattern")
    for (var i = 0, n = t.properties; i < n.length; i += 1) {
      var a = n[i];
      this.checkPatternExport(e, a);
    }
  else if (r === "ArrayPattern")
    for (var s = 0, o = t.elements; s < o.length; s += 1) {
      var l = o[s];
      l && this.checkPatternExport(e, l);
    }
  else
    r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "RestElement" ? this.checkPatternExport(e, t.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(e, t.expression);
};
be.checkVariableExport = function(e, t) {
  if (e)
    for (var r = 0, i = t; r < i.length; r += 1) {
      var n = i[r];
      this.checkPatternExport(e, n.id);
    }
};
be.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
be.parseExportSpecifiers = function(e) {
  var t = [], r = true;
  for (this.expect(v.braceL); !this.eat(v.braceR); ) {
    if (r)
      r = false;
    else if (this.expect(v.comma), this.afterTrailingComma(v.braceR))
      break;
    var i = this.startNode();
    i.local = this.parseIdent(true), i.exported = this.eatContextual("as") ? this.parseIdent(true) : i.local, this.checkExport(e, i.exported.name, i.exported.start), t.push(this.finishNode(i, "ExportSpecifier"));
  }
  return t;
};
be.parseImport = function(e) {
  return this.next(), this.type === v.string ? (e.specifiers = AN, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === v.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
be.parseImportSpecifiers = function() {
  var e = [], t = true;
  if (this.type === v.name) {
    var r = this.startNode();
    if (r.local = this.parseIdent(), this.checkLVal(r.local, Kr), e.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat(v.comma))
      return e;
  }
  if (this.type === v.star) {
    var i = this.startNode();
    return this.next(), this.expectContextual("as"), i.local = this.parseIdent(), this.checkLVal(i.local, Kr), e.push(this.finishNode(i, "ImportNamespaceSpecifier")), e;
  }
  for (this.expect(v.braceL); !this.eat(v.braceR); ) {
    if (t)
      t = false;
    else if (this.expect(v.comma), this.afterTrailingComma(v.braceR))
      break;
    var n = this.startNode();
    n.imported = this.parseIdent(true), this.eatContextual("as") ? n.local = this.parseIdent() : (this.checkUnreserved(n.imported), n.local = n.imported), this.checkLVal(n.local, Kr), e.push(this.finishNode(n, "ImportSpecifier"));
  }
  return e;
};
be.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
be.isDirectiveCandidate = function(e) {
  return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var ni = Et.prototype;
ni.toAssignable = function(e, t, r) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", r && this.checkPatternErrors(r, true);
        for (var i = 0, n = e.properties; i < n.length; i += 1) {
          var a = n[i];
          this.toAssignable(a, t), a.type === "RestElement" && (a.argument.type === "ArrayPattern" || a.argument.type === "ObjectPattern") && this.raise(a.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", r && this.checkPatternErrors(r, true), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
      case "AssignmentPattern":
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, r);
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else
    r && this.checkPatternErrors(r, true);
  return e;
};
ni.toAssignableList = function(e, t) {
  for (var r = e.length, i = 0; i < r; i++) {
    var n = e[i];
    n && this.toAssignable(n, t);
  }
  if (r) {
    var a = e[r - 1];
    this.options.ecmaVersion === 6 && t && a && a.type === "RestElement" && a.argument.type !== "Identifier" && this.unexpected(a.argument.start);
  }
  return e;
};
ni.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(false, e), this.finishNode(t, "SpreadElement");
};
ni.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== v.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
ni.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case v.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(v.bracketR, true, true), this.finishNode(e, "ArrayPattern");
      case v.braceL:
        return this.parseObj(true);
    }
  return this.parseIdent();
};
ni.parseBindingList = function(e, t, r) {
  for (var i = [], n = true; !this.eat(e); )
    if (n ? n = false : this.expect(v.comma), t && this.type === v.comma)
      i.push(null);
    else {
      if (r && this.afterTrailingComma(e))
        break;
      if (this.type === v.ellipsis) {
        var a = this.parseRestBinding();
        this.parseBindingListItem(a), i.push(a), this.type === v.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else {
        var s = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(s), i.push(s);
      }
    }
  return i;
};
ni.parseBindingListItem = function(e) {
  return e;
};
ni.parseMaybeDefault = function(e, t, r) {
  if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(v.eq))
    return r;
  var i = this.startNodeAt(e, t);
  return i.left = r, i.right = this.parseMaybeAssign(), this.finishNode(i, "AssignmentPattern");
};
ni.checkLVal = function(e, t, r) {
  switch (t === void 0 && (t = hh), e.type) {
    case "Identifier":
      t === Kr && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (t ? "Binding " : "Assigning to ") + e.name + " in strict mode"), r && (qs(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = true), t !== hh && t !== CE && this.declareName(e.name, t, e.start);
      break;
    case "MemberExpression":
      t && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ObjectPattern":
      for (var i = 0, n = e.properties; i < n.length; i += 1) {
        var a = n[i];
        this.checkLVal(a, t, r);
      }
      break;
    case "Property":
      this.checkLVal(e.value, t, r);
      break;
    case "ArrayPattern":
      for (var s = 0, o = e.elements; s < o.length; s += 1) {
        var l = o[s];
        l && this.checkLVal(l, t, r);
      }
      break;
    case "AssignmentPattern":
      this.checkLVal(e.left, t, r);
      break;
    case "RestElement":
      this.checkLVal(e.argument, t, r);
      break;
    case "ParenthesizedExpression":
      this.checkLVal(e.expression, t, r);
      break;
    default:
      this.raise(e.start, (t ? "Binding" : "Assigning to") + " rvalue");
  }
};
var ke = Et.prototype;
ke.checkPropClash = function(e, t, r) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var i = e.key, n;
    switch (i.type) {
      case "Identifier":
        n = i.name;
        break;
      case "Literal":
        n = String(i.value);
        break;
      default:
        return;
    }
    var a = e.kind;
    if (this.options.ecmaVersion >= 6) {
      n === "__proto__" && a === "init" && (t.proto && (r && r.doubleProto < 0 ? r.doubleProto = i.start : this.raiseRecoverable(i.start, "Redefinition of __proto__ property")), t.proto = true);
      return;
    }
    n = "$" + n;
    var s = t[n];
    if (s) {
      var o;
      a === "init" ? o = this.strict && s.init || s.get || s.set : o = s.init || s[a], o && this.raiseRecoverable(i.start, "Redefinition of property");
    } else
      s = t[n] = {
        init: false,
        get: false,
        set: false
      };
    s[a] = true;
  }
};
ke.parseExpression = function(e, t) {
  var r = this.start, i = this.startLoc, n = this.parseMaybeAssign(e, t);
  if (this.type === v.comma) {
    var a = this.startNodeAt(r, i);
    for (a.expressions = [n]; this.eat(v.comma); )
      a.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(a, "SequenceExpression");
  }
  return n;
};
ke.parseMaybeAssign = function(e, t, r) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = false;
  }
  var i = false, n = -1, a = -1, s = -1;
  t ? (n = t.parenthesizedAssign, a = t.trailingComma, s = t.shorthandAssign, t.parenthesizedAssign = t.trailingComma = t.shorthandAssign = -1) : (t = new oa(), i = true);
  var o = this.start, l = this.startLoc;
  (this.type === v.parenL || this.type === v.name) && (this.potentialArrowAt = this.start);
  var c = this.parseMaybeConditional(e, t);
  if (r && (c = r.call(this, c, o, l)), this.type.isAssign) {
    var f = this.startNodeAt(o, l);
    return f.operator = this.value, f.left = this.type === v.eq ? this.toAssignable(c, false, t) : c, i || oa.call(t), t.shorthandAssign = -1, this.checkLVal(c), this.next(), f.right = this.parseMaybeAssign(e), this.finishNode(f, "AssignmentExpression");
  } else
    i && this.checkExpressionErrors(t, true);
  return n > -1 && (t.parenthesizedAssign = n), a > -1 && (t.trailingComma = a), s > -1 && (t.shorthandAssign = s), c;
};
ke.parseMaybeConditional = function(e, t) {
  var r = this.start, i = this.startLoc, n = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return n;
  if (this.eat(v.question)) {
    var a = this.startNodeAt(r, i);
    return a.test = n, a.consequent = this.parseMaybeAssign(), this.expect(v.colon), a.alternate = this.parseMaybeAssign(e), this.finishNode(a, "ConditionalExpression");
  }
  return n;
};
ke.parseExprOps = function(e, t) {
  var r = this.start, i = this.startLoc, n = this.parseMaybeUnary(t, false);
  return this.checkExpressionErrors(t) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, i, -1, e);
};
ke.parseExprOp = function(e, t, r, i, n) {
  var a = this.type.binop;
  if (a != null && (!n || this.type !== v._in) && a > i) {
    var s = this.type === v.logicalOR || this.type === v.logicalAND, o = this.value;
    this.next();
    var l = this.start, c = this.startLoc, f = this.parseExprOp(this.parseMaybeUnary(null, false), l, c, a, n), p = this.buildBinary(t, r, e, f, o, s);
    return this.parseExprOp(p, t, r, i, n);
  }
  return e;
};
ke.buildBinary = function(e, t, r, i, n, a) {
  var s = this.startNodeAt(e, t);
  return s.left = r, s.operator = n, s.right = i, this.finishNode(s, a ? "LogicalExpression" : "BinaryExpression");
};
ke.parseMaybeUnary = function(e, t) {
  var r = this.start, i = this.startLoc, n;
  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
    n = this.parseAwait(), t = true;
  else if (this.type.prefix) {
    var a = this.startNode(), s = this.type === v.incDec;
    a.operator = this.value, a.prefix = true, this.next(), a.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e, true), s ? this.checkLVal(a.argument) : this.strict && a.operator === "delete" && a.argument.type === "Identifier" ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : t = true, n = this.finishNode(a, s ? "UpdateExpression" : "UnaryExpression");
  } else {
    if (n = this.parseExprSubscripts(e), this.checkExpressionErrors(e))
      return n;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var o = this.startNodeAt(r, i);
      o.operator = this.value, o.prefix = false, o.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(o, "UpdateExpression");
    }
  }
  return !t && this.eat(v.starstar) ? this.buildBinary(r, i, n, this.parseMaybeUnary(null, false), "**", false) : n;
};
ke.parseExprSubscripts = function(e) {
  var t = this.start, r = this.startLoc, i = this.parseExprAtom(e), n = i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(e) || n)
    return i;
  var a = this.parseSubscripts(i, t, r);
  return e && a.type === "MemberExpression" && (e.parenthesizedAssign >= a.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= a.start && (e.parenthesizedBind = -1)), a;
};
ke.parseSubscripts = function(e, t, r, i) {
  for (var n = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && this.input.slice(e.start, e.end) === "async"; ; ) {
    var a = this.parseSubscript(e, t, r, i, n);
    if (a === e || a.type === "ArrowFunctionExpression")
      return a;
    e = a;
  }
};
ke.parseSubscript = function(e, t, r, i, n) {
  var a = this.eat(v.bracketL);
  if (a || this.eat(v.dot)) {
    var s = this.startNodeAt(t, r);
    s.object = e, s.property = a ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), s.computed = !!a, a && this.expect(v.bracketR), e = this.finishNode(s, "MemberExpression");
  } else if (!i && this.eat(v.parenL)) {
    var o = new oa(), l = this.yieldPos, c = this.awaitPos, f = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var p = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8 && e.type !== "Import", false, o);
    if (n && !this.canInsertSemicolon() && this.eat(v.arrow))
      return this.checkPatternErrors(o, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = l, this.awaitPos = c, this.awaitIdentPos = f, this.parseArrowExpression(this.startNodeAt(t, r), p, true);
    this.checkExpressionErrors(o, true), this.yieldPos = l || this.yieldPos, this.awaitPos = c || this.awaitPos, this.awaitIdentPos = f || this.awaitIdentPos;
    var O = this.startNodeAt(t, r);
    if (O.callee = e, O.arguments = p, O.callee.type === "Import") {
      O.arguments.length !== 1 && this.raise(O.start, "import() requires exactly one argument");
      var d2 = O.arguments[0];
      d2 && d2.type === "SpreadElement" && this.raise(d2.start, "... is not allowed in import()");
    }
    e = this.finishNode(O, "CallExpression");
  } else if (this.type === v.backQuote) {
    var g = this.startNodeAt(t, r);
    g.tag = e, g.quasi = this.parseTemplate({ isTagged: true }), e = this.finishNode(g, "TaggedTemplateExpression");
  }
  return e;
};
ke.parseExprAtom = function(e) {
  this.type === v.slash && this.readRegexp();
  var t, r = this.potentialArrowAt === this.start;
  switch (this.type) {
    case v._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), t = this.startNode(), this.next(), this.type === v.parenL && !this.allowDirectSuper && this.raise(t.start, "super() call outside constructor of a subclass"), this.type !== v.dot && this.type !== v.bracketL && this.type !== v.parenL && this.unexpected(), this.finishNode(t, "Super");
    case v._this:
      return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
    case v.name:
      var i = this.start, n = this.startLoc, a = this.containsEsc, s = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !a && s.name === "async" && !this.canInsertSemicolon() && this.eat(v._function))
        return this.parseFunction(this.startNodeAt(i, n), 0, false, true);
      if (r && !this.canInsertSemicolon()) {
        if (this.eat(v.arrow))
          return this.parseArrowExpression(this.startNodeAt(i, n), [s], false);
        if (this.options.ecmaVersion >= 8 && s.name === "async" && this.type === v.name && !a)
          return s = this.parseIdent(false), (this.canInsertSemicolon() || !this.eat(v.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(i, n), [s], true);
      }
      return s;
    case v.regexp:
      var o = this.value;
      return t = this.parseLiteral(o.value), t.regex = { pattern: o.pattern, flags: o.flags }, t;
    case v.num:
    case v.string:
      return this.parseLiteral(this.value);
    case v._null:
    case v._true:
    case v._false:
      return t = this.startNode(), t.value = this.type === v._null ? null : this.type === v._true, t.raw = this.type.keyword, this.next(), this.finishNode(t, "Literal");
    case v.parenL:
      var l = this.start, c = this.parseParenAndDistinguishExpression(r);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(c) && (e.parenthesizedAssign = l), e.parenthesizedBind < 0 && (e.parenthesizedBind = l)), c;
    case v.bracketL:
      return t = this.startNode(), this.next(), t.elements = this.parseExprList(v.bracketR, true, true, e), this.finishNode(t, "ArrayExpression");
    case v.braceL:
      return this.parseObj(false, e);
    case v._function:
      return t = this.startNode(), this.next(), this.parseFunction(t, 0);
    case v._class:
      return this.parseClass(this.startNode(), false);
    case v._new:
      return this.parseNew();
    case v.backQuote:
      return this.parseTemplate();
    case v._import:
      return this.options.ecmaVersion > 10 ? this.parseDynamicImport() : this.unexpected();
    default:
      this.unexpected();
  }
};
ke.parseDynamicImport = function() {
  var e = this.startNode();
  return this.next(), this.type !== v.parenL && this.unexpected(), this.finishNode(e, "Import");
};
ke.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1)), this.next(), this.finishNode(t, "Literal");
};
ke.parseParenExpression = function() {
  this.expect(v.parenL);
  var e = this.parseExpression();
  return this.expect(v.parenR), e;
};
ke.parseParenAndDistinguishExpression = function(e) {
  var t = this.start, r = this.startLoc, i, n = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var a = this.start, s = this.startLoc, o = [], l = true, c = false, f = new oa(), p = this.yieldPos, O = this.awaitPos, d2;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== v.parenR; )
      if (l ? l = false : this.expect(v.comma), n && this.afterTrailingComma(v.parenR, true)) {
        c = true;
        break;
      } else if (this.type === v.ellipsis) {
        d2 = this.start, o.push(this.parseParenItem(this.parseRestBinding())), this.type === v.comma && this.raise(this.start, "Comma is not permitted after the rest element");
        break;
      } else
        o.push(this.parseMaybeAssign(false, f, this.parseParenItem));
    var g = this.start, L = this.startLoc;
    if (this.expect(v.parenR), e && !this.canInsertSemicolon() && this.eat(v.arrow))
      return this.checkPatternErrors(f, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = O, this.parseParenArrowList(t, r, o);
    (!o.length || c) && this.unexpected(this.lastTokStart), d2 && this.unexpected(d2), this.checkExpressionErrors(f, true), this.yieldPos = p || this.yieldPos, this.awaitPos = O || this.awaitPos, o.length > 1 ? (i = this.startNodeAt(a, s), i.expressions = o, this.finishNodeAt(i, "SequenceExpression", g, L)) : i = o[0];
  } else
    i = this.parseParenExpression();
  if (this.options.preserveParens) {
    var D = this.startNodeAt(t, r);
    return D.expression = i, this.finishNode(D, "ParenthesizedExpression");
  } else
    return i;
};
ke.parseParenItem = function(e) {
  return e;
};
ke.parseParenArrowList = function(e, t, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), r);
};
var gN = [];
ke.parseNew = function() {
  var e = this.startNode(), t = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(v.dot)) {
    e.meta = t;
    var r = this.containsEsc;
    return e.property = this.parseIdent(true), (e.property.name !== "target" || r) && this.raiseRecoverable(e.property.start, "The only valid meta property for new is new.target"), this.inNonArrowFunction() || this.raiseRecoverable(e.start, "new.target can only be used in functions"), this.finishNode(e, "MetaProperty");
  }
  var i = this.start, n = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(), i, n, true), this.options.ecmaVersion > 10 && e.callee.type === "Import" && this.raise(e.callee.start, "Cannot use new with import(...)"), this.eat(v.parenL) ? e.arguments = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8 && e.callee.type !== "Import", false) : e.arguments = gN, this.finishNode(e, "NewExpression");
};
ke.parseTemplateElement = function(e) {
  var t = e.isTagged, r = this.startNode();
  return this.type === v.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = {
    raw: this.value,
    cooked: null
  }) : r.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), r.tail = this.type === v.backQuote, this.finishNode(r, "TemplateElement");
};
ke.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = false);
  var r = this.startNode();
  this.next(), r.expressions = [];
  var i = this.parseTemplateElement({ isTagged: t });
  for (r.quasis = [i]; !i.tail; )
    this.type === v.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(v.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(v.braceR), r.quasis.push(i = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(r, "TemplateLiteral");
};
ke.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === v.name || this.type === v.num || this.type === v.string || this.type === v.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === v.star) && !Ar.test(this.input.slice(this.lastTokEnd, this.start));
};
ke.parseObj = function(e, t) {
  var r = this.startNode(), i = true, n = {};
  for (r.properties = [], this.next(); !this.eat(v.braceR); ) {
    if (i)
      i = false;
    else if (this.expect(v.comma), this.afterTrailingComma(v.braceR))
      break;
    var a = this.parseProperty(e, t);
    e || this.checkPropClash(a, n, t), r.properties.push(a);
  }
  return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
};
ke.parseProperty = function(e, t) {
  var r = this.startNode(), i, n, a, s;
  if (this.options.ecmaVersion >= 9 && this.eat(v.ellipsis))
    return e ? (r.argument = this.parseIdent(false), this.type === v.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (this.type === v.parenL && t && (t.parenthesizedAssign < 0 && (t.parenthesizedAssign = this.start), t.parenthesizedBind < 0 && (t.parenthesizedBind = this.start)), r.argument = this.parseMaybeAssign(false, t), this.type === v.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (r.method = false, r.shorthand = false, (e || t) && (a = this.start, s = this.startLoc), e || (i = this.eat(v.star)));
  var o = this.containsEsc;
  return this.parsePropertyName(r), !e && !o && this.options.ecmaVersion >= 8 && !i && this.isAsyncProp(r) ? (n = true, i = this.options.ecmaVersion >= 9 && this.eat(v.star), this.parsePropertyName(r, t)) : n = false, this.parsePropertyValue(r, e, i, n, a, s, t, o), this.finishNode(r, "Property");
};
ke.parsePropertyValue = function(e, t, r, i, n, a, s, o) {
  if ((r || i) && this.type === v.colon && this.unexpected(), this.eat(v.colon))
    e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, s), e.kind = "init";
  else if (this.options.ecmaVersion >= 6 && this.type === v.parenL)
    t && this.unexpected(), e.kind = "init", e.method = true, e.value = this.parseMethod(r, i);
  else if (!t && !o && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== v.comma && this.type !== v.braceR) {
    (r || i) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(false);
    var l = e.kind === "get" ? 0 : 1;
    if (e.value.params.length !== l) {
      var c = e.value.start;
      e.kind === "get" ? this.raiseRecoverable(c, "getter should have no params") : this.raiseRecoverable(c, "setter should have exactly one param");
    } else
      e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
  } else
    this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r || i) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), e.kind = "init", t ? e.value = this.parseMaybeDefault(n, a, e.key) : this.type === v.eq && s ? (s.shorthandAssign < 0 && (s.shorthandAssign = this.start), e.value = this.parseMaybeDefault(n, a, e.key)) : e.value = e.key, e.shorthand = true) : this.unexpected();
};
ke.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(v.bracketL))
      return e.computed = true, e.key = this.parseMaybeAssign(), this.expect(v.bracketR), e.key;
    e.computed = false;
  }
  return e.key = this.type === v.num || this.type === v.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
ke.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = false), this.options.ecmaVersion >= 8 && (e.async = false);
};
ke.parseMethod = function(e, t, r) {
  var i = this.startNode(), n = this.yieldPos, a = this.awaitPos, s = this.awaitIdentPos;
  return this.initFunction(i), this.options.ecmaVersion >= 6 && (i.generator = e), this.options.ecmaVersion >= 8 && (i.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(lc(t, i.generator) | PE | (r ? _E2 : 0)), this.expect(v.parenL), i.params = this.parseBindingList(v.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i, false, true), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = s, this.finishNode(i, "FunctionExpression");
};
ke.parseArrowExpression = function(e, t, r) {
  var i = this.yieldPos, n = this.awaitPos, a = this.awaitIdentPos;
  return this.enterScope(lc(r, false) | IE), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, true), this.parseFunctionBody(e, true, false), this.yieldPos = i, this.awaitPos = n, this.awaitIdentPos = a, this.finishNode(e, "ArrowFunctionExpression");
};
ke.parseFunctionBody = function(e, t, r) {
  var i = t && this.type !== v.braceL, n = this.strict, a = false;
  if (i)
    e.body = this.parseMaybeAssign(), e.expression = true, this.checkParams(e, false);
  else {
    var s = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!n || s) && (a = this.strictDirective(this.end), a && s && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var o = this.labels;
    this.labels = [], a && (this.strict = true), this.checkParams(e, !n && !a && !t && !r && this.isSimpleParamList(e.params)), e.body = this.parseBlock(false), e.expression = false, this.adaptDirectivePrologue(e.body.body), this.labels = o;
  }
  this.exitScope(), this.strict && e.id && this.checkLVal(e.id, CE), this.strict = n;
};
ke.isSimpleParamList = function(e) {
  for (var t = 0, r = e; t < r.length; t += 1) {
    var i = r[t];
    if (i.type !== "Identifier")
      return false;
  }
  return true;
};
ke.checkParams = function(e, t) {
  for (var r = {}, i = 0, n = e.params; i < n.length; i += 1) {
    var a = n[i];
    this.checkLVal(a, uc, t ? null : r);
  }
};
ke.parseExprList = function(e, t, r, i) {
  for (var n = [], a = true; !this.eat(e); ) {
    if (a)
      a = false;
    else if (this.expect(v.comma), t && this.afterTrailingComma(e))
      break;
    var s = void 0;
    r && this.type === v.comma ? s = null : this.type === v.ellipsis ? (s = this.parseSpread(i), i && this.type === v.comma && i.trailingComma < 0 && (i.trailingComma = this.start)) : s = this.parseMaybeAssign(false, i), n.push(s);
  }
  return n;
};
ke.checkUnreserved = function(e) {
  var t = e.start, r = e.end, i = e.name;
  if (this.inGenerator && i === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(i) && this.raise(t, "Unexpected keyword '" + i + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) {
    var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
    n.test(i) && (!this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + i + "' is reserved"));
  }
};
ke.parseIdent = function(e, t) {
  var r = this.startNode();
  return this.type === v.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(), this.finishNode(r, "Identifier"), e || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r;
};
ke.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === v.semi || this.canInsertSemicolon() || this.type !== v.star && !this.type.startsExpr ? (t.delegate = false, t.argument = null) : (t.delegate = this.eat(v.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
ke.parseAwait = function() {
  this.awaitPos || (this.awaitPos = this.start);
  var e = this.startNode();
  return this.next(), e.argument = this.parseMaybeUnary(null, true), this.finishNode(e, "AwaitExpression");
};
var Ls = Et.prototype;
Ls.raise = function(e, t) {
  var r = sc(this.input, e);
  t += " (" + r.line + ":" + r.column + ")";
  var i = new SyntaxError(t);
  throw i.pos = e, i.loc = r, i.raisedAt = this.pos, i;
};
Ls.raiseRecoverable = Ls.raise;
Ls.curPosition = function() {
  if (this.options.locations)
    return new dn(this.curLine, this.pos - this.lineStart);
};
var Ii = Et.prototype;
var yN = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [];
};
Ii.enterScope = function(e) {
  this.scopeStack.push(new yN(e));
};
Ii.exitScope = function() {
  this.scopeStack.pop();
};
Ii.treatFunctionsAsVarInScope = function(e) {
  return e.flags & ya || !this.inModule && e.flags & sa;
};
Ii.declareName = function(e, t, r) {
  var i = false;
  if (t === Kr) {
    var n = this.currentScope();
    i = n.lexical.indexOf(e) > -1 || n.functions.indexOf(e) > -1 || n.var.indexOf(e) > -1, n.lexical.push(e), this.inModule && n.flags & sa && delete this.undefinedExports[e];
  } else if (t === vE) {
    var a = this.currentScope();
    a.lexical.push(e);
  } else if (t === bE) {
    var s = this.currentScope();
    this.treatFunctionsAsVar ? i = s.lexical.indexOf(e) > -1 : i = s.lexical.indexOf(e) > -1 || s.var.indexOf(e) > -1, s.functions.push(e);
  } else
    for (var o = this.scopeStack.length - 1; o >= 0; --o) {
      var l = this.scopeStack[o];
      if (l.lexical.indexOf(e) > -1 && !(l.flags & NE && l.lexical[0] === e) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(e) > -1) {
        i = true;
        break;
      }
      if (l.var.push(e), this.inModule && l.flags & sa && delete this.undefinedExports[e], l.flags & oc)
        break;
    }
  i && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared");
};
Ii.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
Ii.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Ii.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & oc)
      return t;
  }
};
Ii.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & oc && !(t.flags & IE))
      return t;
  }
};
var Js = function(t, r, i) {
  this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new ga(t, i)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]);
};
var Ks = Et.prototype;
Ks.startNode = function() {
  return new Js(this, this.start, this.startLoc);
};
Ks.startNodeAt = function(e, t) {
  return new Js(this, e, t);
};
function xE(e, t, r, i) {
  return e.type = t, e.end = r, this.options.locations && (e.loc.end = i), this.options.ranges && (e.range[1] = r), e;
}
Ks.finishNode = function(e, t) {
  return xE.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
Ks.finishNodeAt = function(e, t, r, i) {
  return xE.call(this, e, t, r, i);
};
var Er = function(t, r, i, n, a) {
  this.token = t, this.isExpr = !!r, this.preserveSpace = !!i, this.override = n, this.generator = !!a;
};
var dt = {
  b_stat: new Er("{", false),
  b_expr: new Er("{", true),
  b_tmpl: new Er("${", false),
  p_stat: new Er("(", false),
  p_expr: new Er("(", true),
  q_tmpl: new Er("`", true, true, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new Er("function", false),
  f_expr: new Er("function", true),
  f_expr_gen: new Er("function", true, false, null, true),
  f_gen: new Er("function", false, false, null, true)
};
var eo = Et.prototype;
eo.initialContext = function() {
  return [dt.b_stat];
};
eo.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === dt.f_expr || t === dt.f_stat ? true : e === v.colon && (t === dt.b_stat || t === dt.b_expr) ? !t.isExpr : e === v._return || e === v.name && this.exprAllowed ? Ar.test(this.input.slice(this.lastTokEnd, this.start)) : e === v._else || e === v.semi || e === v.eof || e === v.parenR || e === v.arrow ? true : e === v.braceL ? t === dt.b_stat : e === v._var || e === v._const || e === v.name ? false : !this.exprAllowed;
};
eo.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return false;
};
eo.updateContext = function(e) {
  var t, r = this.type;
  r.keyword && e === v.dot ? this.exprAllowed = false : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr;
};
v.parenR.updateContext = v.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var e = this.context.pop();
  e === dt.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
v.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? dt.b_stat : dt.b_expr), this.exprAllowed = true;
};
v.dollarBraceL.updateContext = function() {
  this.context.push(dt.b_tmpl), this.exprAllowed = true;
};
v.parenL.updateContext = function(e) {
  var t = e === v._if || e === v._for || e === v._with || e === v._while;
  this.context.push(t ? dt.p_stat : dt.p_expr), this.exprAllowed = true;
};
v.incDec.updateContext = function() {
};
v._function.updateContext = v._class.updateContext = function(e) {
  e.beforeExpr && e !== v.semi && e !== v._else && !(e === v._return && Ar.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === v.colon || e === v.braceL) && this.curContext() === dt.b_stat) ? this.context.push(dt.f_expr) : this.context.push(dt.f_stat), this.exprAllowed = false;
};
v.backQuote.updateContext = function() {
  this.curContext() === dt.q_tmpl ? this.context.pop() : this.context.push(dt.q_tmpl), this.exprAllowed = false;
};
v.star.updateContext = function(e) {
  if (e === v._function) {
    var t = this.context.length - 1;
    this.context[t] === dt.f_expr ? this.context[t] = dt.f_expr_gen : this.context[t] = dt.f_gen;
  }
  this.exprAllowed = true;
};
v.name.updateContext = function(e) {
  var t = false;
  this.options.ecmaVersion >= 6 && e !== v.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = true), this.exprAllowed = t;
};
var DE = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var UE = DE + " Extended_Pictographic";
var IN = UE;
var NN = {
  9: DE,
  10: UE,
  11: IN
};
var ph = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var wE = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ME = wE + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var PN = ME + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var _N = {
  9: wE,
  10: ME,
  11: PN
};
var kE = {};
function fc(e) {
  var t = kE[e] = {
    binary: Mi(NN[e] + " " + ph),
    nonBinary: {
      General_Category: Mi(ph),
      Script: Mi(_N[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
fc(9);
fc(10);
fc(11);
var de2 = Et.prototype;
var ai = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = kE[t.options.ecmaVersion >= 11 ? 11 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
ai.prototype.reset = function(t, r, i) {
  var n = i.indexOf("u") !== -1;
  this.start = t | 0, this.source = r + "", this.flags = i, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9;
};
ai.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
ai.prototype.at = function(t) {
  var r = this.source, i = r.length;
  if (t >= i)
    return -1;
  var n = r.charCodeAt(t);
  if (!this.switchU || n <= 55295 || n >= 57344 || t + 1 >= i)
    return n;
  var a = r.charCodeAt(t + 1);
  return a >= 56320 && a <= 57343 ? (n << 10) + a - 56613888 : n;
};
ai.prototype.nextIndex = function(t) {
  var r = this.source, i = r.length;
  if (t >= i)
    return i;
  var n = r.charCodeAt(t), a;
  return !this.switchU || n <= 55295 || n >= 57344 || t + 1 >= i || (a = r.charCodeAt(t + 1)) < 56320 || a > 57343 ? t + 1 : t + 2;
};
ai.prototype.current = function() {
  return this.at(this.pos);
};
ai.prototype.lookahead = function() {
  return this.at(this.nextIndex(this.pos));
};
ai.prototype.advance = function() {
  this.pos = this.nextIndex(this.pos);
};
ai.prototype.eat = function(t) {
  return this.current() === t ? (this.advance(), true) : false;
};
function xs(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
de2.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, r = e.flags, i = 0; i < r.length; i++) {
    var n = r.charAt(i);
    t.indexOf(n) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(n, i + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag");
  }
};
de2.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = true, this.regexp_pattern(e));
};
de2.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = false, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* [ */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
    var i = r[t];
    e.groupNames.indexOf(i) === -1 && e.raise("Invalid named capture referenced");
  }
};
de2.regexp_disjunction = function(e) {
  for (this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_alternative(e);
  this.regexp_eatQuantifier(e, true) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
de2.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
de2.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), true) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), true) : false;
};
de2.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = false, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return true;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return true;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var r = false;
    if (this.options.ecmaVersion >= 9 && (r = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, true;
  }
  return e.pos = t, false;
};
de2.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = false), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), true) : false;
};
de2.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
de2.regexp_eatBracedQuantifier = function(e, t) {
  var r = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var i = 0, n = -1;
    if (this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return n !== -1 && n < i && !t && e.raise("numbers out of order in {} quantifier"), true;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r;
  }
  return false;
};
de2.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
de2.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return true;
    e.pos = t;
  }
  return false;
};
de2.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    ) && e.eat(
      58
      /* : */
    )) {
      if (this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ))
        return true;
      e.raise("Unterminated group");
    }
    e.pos = t;
  }
  return false;
};
de2.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, true;
    e.raise("Unterminated group");
  }
  return false;
};
de2.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
de2.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, true) && e.raise("Nothing to repeat"), false;
};
de2.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return QE(t) ? (e.lastIntValue = t, e.advance(), true) : false;
};
function QE(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
de2.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !QE(r); )
    e.advance();
  return e.pos !== t;
};
de2.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), true) : false;
};
de2.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(e)) {
      e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise("Duplicate capture group name"), e.groupNames.push(e.lastStringValue);
      return;
    }
    e.raise("Invalid group");
  }
};
de2.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return true;
    e.raise("Invalid capture group name");
  }
  return false;
};
de2.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += xs(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += xs(e.lastIntValue);
    return true;
  }
  return false;
};
de2.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, r = e.current();
  return e.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (r = e.lastIntValue), bN(r) ? (e.lastIntValue = r, true) : (e.pos = t, false);
};
function bN(e) {
  return ti(e, true) || e === 36 || e === 95;
}
de2.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, r = e.current();
  return e.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (r = e.lastIntValue), vN(r) ? (e.lastIntValue = r, true) : (e.pos = t, false);
};
function vN(e) {
  return Fi(e, true) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
de2.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? true : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), false);
};
de2.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var r = e.lastIntValue;
    if (e.switchU)
      return r > e.maxBackReference && (e.maxBackReference = r), true;
    if (r <= e.numCapturingParens)
      return true;
    e.pos = t;
  }
  return false;
};
de2.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), true;
    e.raise("Invalid named reference");
  }
  return false;
};
de2.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
de2.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return true;
    e.pos = t;
  }
  return false;
};
de2.regexp_eatZero = function(e) {
  return e.current() === 48 && !to(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), true) : false;
};
de2.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), true) : t === 110 ? (e.lastIntValue = 10, e.advance(), true) : t === 118 ? (e.lastIntValue = 11, e.advance(), true) : t === 102 ? (e.lastIntValue = 12, e.advance(), true) : t === 114 ? (e.lastIntValue = 13, e.advance(), true) : false;
};
de2.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return GE(t) ? (e.lastIntValue = t % 32, e.advance(), true) : false;
};
function GE(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
de2.regexp_eatRegExpUnicodeEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var r = e.lastIntValue;
      if (e.switchU && r >= 55296 && r <= 56319) {
        var i = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var n = e.lastIntValue;
          if (n >= 56320 && n <= 57343)
            return e.lastIntValue = (r - 55296) * 1024 + (n - 56320) + 65536, true;
        }
        e.pos = i, e.lastIntValue = r;
      }
      return true;
    }
    if (e.switchU && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && CN(e.lastIntValue))
      return true;
    e.switchU && e.raise("Invalid unicode escape"), e.pos = t;
  }
  return false;
};
function CN(e) {
  return e >= 0 && e <= 1114111;
}
de2.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? true : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, true) : false;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), true) : false;
};
de2.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return true;
  }
  return false;
};
de2.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (LN(t))
    return e.lastIntValue = -1, e.advance(), true;
  if (e.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) {
    if (e.lastIntValue = -1, e.advance(), e.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(
      125
      /* } */
    ))
      return true;
    e.raise("Invalid property name");
  }
  return false;
};
function LN(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
de2.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var r = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var i = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, r, i), true;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var n = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, n), true;
  }
  return false;
};
de2.regexp_validateUnicodePropertyNameAndValue = function(e, t, r) {
  qs(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid property value");
};
de2.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  e.unicodeProperties.binary.test(t) || e.raise("Invalid property name");
};
de2.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; VE(t = e.current()); )
    e.lastStringValue += xs(t), e.advance();
  return e.lastStringValue !== "";
};
function VE(e) {
  return GE(e) || e === 95;
}
de2.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; xN(t = e.current()); )
    e.lastStringValue += xs(t), e.advance();
  return e.lastStringValue !== "";
};
function xN(e) {
  return VE(e) || to(e);
}
de2.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
de2.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    if (e.eat(
      94
      /* ^ */
    ), this.regexp_classRanges(e), e.eat(
      93
      /* [ */
    ))
      return true;
    e.raise("Unterminated character class");
  }
  return false;
};
de2.regexp_classRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var r = e.lastIntValue;
      e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of order in character class");
    }
  }
};
de2.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return true;
    if (e.switchU) {
      var r = e.current();
      (r === 99 || YE(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var i = e.current();
  return i !== 93 ? (e.lastIntValue = i, e.advance(), true) : false;
};
de2.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, true;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, true;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return true;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
de2.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return to(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), true) : false;
};
de2.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return true;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return false;
};
de2.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, r = 0;
  for (e.lastIntValue = 0; to(r = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
  return e.pos !== t;
};
function to(e) {
  return e >= 48 && e <= 57;
}
de2.regexp_eatHexDigits = function(e) {
  var t = e.pos, r = 0;
  for (e.lastIntValue = 0; BE(r = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + $E(r), e.advance();
  return e.pos !== t;
};
function BE(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function $E(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
de2.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var r = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r;
    } else
      e.lastIntValue = t;
    return true;
  }
  return false;
};
de2.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return YE(t) ? (e.lastIntValue = t - 48, e.advance(), true) : (e.lastIntValue = 0, false);
};
function YE(e) {
  return e >= 48 && e <= 55;
}
de2.regexp_eatFixedHexDigits = function(e, t) {
  var r = e.pos;
  e.lastIntValue = 0;
  for (var i = 0; i < t; ++i) {
    var n = e.current();
    if (!BE(n))
      return e.pos = r, false;
    e.lastIntValue = 16 * e.lastIntValue + $E(n), e.advance();
  }
  return true;
};
var ro = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new ga(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
};
var Ye2 = Et.prototype;
Ye2.next = function() {
  this.options.onToken && this.options.onToken(new ro(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
Ye2.getToken = function() {
  return this.next(), new ro(this);
};
typeof Symbol < "u" && (Ye2[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === v.eof,
        value: t
      };
    }
  };
});
Ye2.curContext = function() {
  return this.context[this.context.length - 1];
};
Ye2.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(v.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
Ye2.readToken = function(e) {
  return ti(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
Ye2.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 57344)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return (e << 10) + t - 56613888;
};
Ye2.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2);
  if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) {
    En.lastIndex = t;
    for (var i; (i = En.exec(this.input)) && i.index < this.pos; )
      ++this.curLine, this.lineStart = i.index + i[0].length;
  }
  this.options.onComment && this.options.onComment(
    true,
    this.input.slice(t + 2, r),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
Ye2.skipLineComment = function(e) {
  for (var t = this.pos, r = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !_n(i); )
    i = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    false,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    r,
    this.curPosition()
  );
};
Ye2.skipSpace = function() {
  e:
    for (; this.pos < this.input.length; ) {
      var e = this.input.charCodeAt(this.pos);
      switch (e) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (e > 8 && e < 14 || e >= 5760 && ac.test(String.fromCharCode(e)))
            ++this.pos;
          else
            break e;
      }
    }
};
Ye2.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var r = this.type;
  this.type = e, this.value = t, this.updateContext(r);
};
Ye2.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(true);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(v.ellipsis)) : (++this.pos, this.finishToken(v.dot));
};
Ye2.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.slash, 1);
};
Ye2.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), r = 1, i = e === 42 ? v.star : v.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, i = v.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(v.assign, r + 1) : this.finishOp(i, r);
};
Ye2.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? this.finishOp(e === 124 ? v.logicalOR : v.logicalAND, 2) : t === 61 ? this.finishOp(v.assign, 2) : this.finishOp(e === 124 ? v.bitwiseOR : v.bitwiseAND, 1);
};
Ye2.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.bitwiseXOR, 1);
};
Ye2.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Ar.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(v.incDec, 2) : t === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.plusMin, 1);
};
Ye2.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), r = 1;
  return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(v.assign, r + 1) : this.finishOp(v.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2), this.finishOp(v.relational, r));
};
Ye2.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(v.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(v.arrow)) : this.finishOp(e === 61 ? v.eq : v.prefix, 1);
};
Ye2.getTokenFromCode = function(e) {
  switch (e) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(v.parenL);
    case 41:
      return ++this.pos, this.finishToken(v.parenR);
    case 59:
      return ++this.pos, this.finishToken(v.semi);
    case 44:
      return ++this.pos, this.finishToken(v.comma);
    case 91:
      return ++this.pos, this.finishToken(v.bracketL);
    case 93:
      return ++this.pos, this.finishToken(v.bracketR);
    case 123:
      return ++this.pos, this.finishToken(v.braceL);
    case 125:
      return ++this.pos, this.finishToken(v.braceR);
    case 58:
      return ++this.pos, this.finishToken(v.colon);
    case 63:
      return ++this.pos, this.finishToken(v.question);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(v.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(e);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 126:
      return this.finishOp(v.prefix, 1);
  }
  this.raise(this.pos, "Unexpected character '" + hc(e) + "'");
};
Ye2.finishOp = function(e, t) {
  var r = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, r);
};
Ye2.readRegexp = function() {
  for (var e, t, r = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
    var i = this.input.charAt(this.pos);
    if (Ar.test(i) && this.raise(r, "Unterminated regular expression"), e)
      e = false;
    else {
      if (i === "[")
        t = true;
      else if (i === "]" && t)
        t = false;
      else if (i === "/" && !t)
        break;
      e = i === "\\";
    }
    ++this.pos;
  }
  var n = this.input.slice(r, this.pos);
  ++this.pos;
  var a = this.pos, s = this.readWord1();
  this.containsEsc && this.unexpected(a);
  var o = this.regexpState || (this.regexpState = new ai(this));
  o.reset(r, n, s), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
  var l = null;
  try {
    l = new RegExp(n, s);
  } catch {
  }
  return this.finishToken(v.regexp, { pattern: n, flags: s, value: l });
};
Ye2.readInt = function(e, t) {
  for (var r = this.pos, i = 0, n = 0, a = t ?? 1 / 0; n < a; ++n) {
    var s = this.input.charCodeAt(this.pos), o = void 0;
    if (s >= 97 ? o = s - 97 + 10 : s >= 65 ? o = s - 65 + 10 : s >= 48 && s <= 57 ? o = s - 48 : o = 1 / 0, o >= e)
      break;
    ++this.pos, i = i * e + o;
  }
  return this.pos === r || t != null && this.pos - r !== t ? null : i;
};
Ye2.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var r = this.readInt(e);
  return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = typeof BigInt < "u" ? BigInt(this.input.slice(t, this.pos)) : null, ++this.pos) : ti(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(v.num, r);
};
Ye2.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10) === null && this.raise(t, "Invalid number");
  var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  r && this.strict && this.raise(t, "Invalid number"), r && /[89]/.test(this.input.slice(t, this.pos)) && (r = false);
  var i = this.input.charCodeAt(this.pos);
  if (!r && !e && this.options.ecmaVersion >= 11 && i === 110) {
    var n = this.input.slice(t, this.pos), a = typeof BigInt < "u" ? BigInt(n) : null;
    return ++this.pos, ti(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(v.num, a);
  }
  i === 46 && !r && (++this.pos, this.readInt(10), i = this.input.charCodeAt(this.pos)), (i === 69 || i === 101) && !r && (i = this.input.charCodeAt(++this.pos), (i === 43 || i === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), ti(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = this.input.slice(t, this.pos), o = r ? parseInt(s, 8) : parseFloat(s);
  return this.finishToken(v.num, o);
};
Ye2.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var r = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
function hc(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
Ye2.readString = function(e) {
  for (var t = "", r = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var i = this.input.charCodeAt(this.pos);
    if (i === e)
      break;
    i === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(false), r = this.pos) : (_n(i, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(r, this.pos++), this.finishToken(v.string, t);
};
var FE = {};
Ye2.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === FE)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = false;
};
Ye2.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw FE;
  this.raise(e, t);
};
Ye2.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var r = this.input.charCodeAt(this.pos);
    if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === v.template || this.type === v.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(v.dollarBraceL)) : (++this.pos, this.finishToken(v.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(v.template, e));
    if (r === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(true), t = this.pos;
    else if (_n(r)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(r);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
Ye2.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken(v.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
Ye2.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return hc(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    default:
      if (t >= 48 && t <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(r, 8);
        return i > 255 && (r = r.slice(0, -1), i = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), (r !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - r.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(i);
      }
      return _n(t) ? "" : String.fromCharCode(t);
  }
};
Ye2.readHexChar = function(e) {
  var t = this.pos, r = this.readInt(16, e);
  return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r;
};
Ye2.readWord1 = function() {
  this.containsEsc = false;
  for (var e = "", t = true, r = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var n = this.fullCharCodeAtPos();
    if (Fi(n, i))
      this.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.containsEsc = true, e += this.input.slice(r, this.pos);
      var a = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var s = this.readCodePoint();
      (t ? ti : Fi)(s, i) || this.invalidStringToken(a, "Invalid Unicode escape"), e += hc(s), r = this.pos;
    } else
      break;
    t = false;
  }
  return e + this.input.slice(r, this.pos);
};
Ye2.readWord = function() {
  var e = this.readWord1(), t = v.name;
  return this.keywords.test(e) && (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + e), t = zs[e]), this.finishToken(t, e);
};
var WE = "6.4.2";
Et.acorn = {
  Parser: Et,
  version: WE,
  defaultOptions: Cs,
  Position: dn,
  SourceLocation: ga,
  getLineInfo: sc,
  Node: Js,
  TokenType: Ze,
  tokTypes: v,
  keywordTypes: zs,
  TokContext: Er,
  tokContexts: dt,
  isIdentifierChar: Fi,
  isIdentifierStart: ti,
  Token: ro,
  isNewLine: _n,
  lineBreak: Ar,
  lineBreakG: En,
  nonASCIIwhitespace: ac
};
function DN(e, t) {
  return Et.parse(e, t);
}
function UN(e, t, r) {
  return Et.parseExpressionAt(e, t, r);
}
function wN(e, t) {
  return Et.tokenizer(e, t);
}
var MN = Object.freeze(Object.defineProperty({
  __proto__: null,
  Node: Js,
  Parser: Et,
  Position: dn,
  SourceLocation: ga,
  TokContext: Er,
  Token: ro,
  TokenType: Ze,
  defaultOptions: Cs,
  getLineInfo: sc,
  isIdentifierChar: Fi,
  isIdentifierStart: ti,
  isNewLine: _n,
  keywordTypes: zs,
  lineBreak: Ar,
  lineBreakG: En,
  nonASCIIwhitespace: ac,
  parse: DN,
  parseExpressionAt: UN,
  tokContexts: dt,
  tokTypes: v,
  tokenizer: wN,
  version: WE
}, Symbol.toStringTag, { value: "Module" }));
var XE = a5(MN);
var $o = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var Yo = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var kN = {
  5: Yo,
  "5module": Yo + " export import",
  6: Yo + " const class extends export import super"
};
var QN = /^in(stanceof)?$/;
var pc = "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var jE = "--------------------------------------------------------------------------------------------------------------------------------------------------";
var GN = new RegExp("[" + pc + "]");
var VN = new RegExp("[" + pc + jE + "]");
pc = jE = null;
var ZE = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];
var BN = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];
function Nl(e, t) {
  for (var r = 65536, i = 0; i < t.length; i += 2) {
    if (r += t[i], r > e)
      return false;
    if (r += t[i + 1], r >= e)
      return true;
  }
}
function Ai(e, t) {
  return e < 65 ? e === 36 : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && GN.test(String.fromCharCode(e)) : t === false ? false : Nl(e, ZE);
}
function Tn2(e, t) {
  return e < 48 ? e === 36 : e < 58 ? true : e < 65 ? false : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && VN.test(String.fromCharCode(e)) : t === false ? false : Nl(e, ZE) || Nl(e, BN);
}
var He = function(t, r) {
  r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
};
function Nr(e, t) {
  return new He(e, { beforeExpr: true, binop: t });
}
var Or = { beforeExpr: true };
var ar = { startsExpr: true };
var Oc = {};
function Be2(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, Oc[e] = new He(e, t);
}
var T = {
  num: new He("num", ar),
  regexp: new He("regexp", ar),
  string: new He("string", ar),
  name: new He("name", ar),
  eof: new He("eof"),
  // Punctuation token types.
  bracketL: new He("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new He("]"),
  braceL: new He("{", { beforeExpr: true, startsExpr: true }),
  braceR: new He("}"),
  parenL: new He("(", { beforeExpr: true, startsExpr: true }),
  parenR: new He(")"),
  comma: new He(",", Or),
  semi: new He(";", Or),
  colon: new He(":", Or),
  dot: new He("."),
  question: new He("?", Or),
  arrow: new He("=>", Or),
  template: new He("template"),
  invalidTemplate: new He("invalidTemplate"),
  ellipsis: new He("...", Or),
  backQuote: new He("`", ar),
  dollarBraceL: new He("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new He("=", { beforeExpr: true, isAssign: true }),
  assign: new He("_=", { beforeExpr: true, isAssign: true }),
  incDec: new He("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new He("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: Nr("||", 1),
  logicalAND: Nr("&&", 2),
  bitwiseOR: Nr("|", 3),
  bitwiseXOR: Nr("^", 4),
  bitwiseAND: Nr("&", 5),
  equality: Nr("==/!=/===/!==", 6),
  relational: Nr("</>/<=/>=", 7),
  bitShift: Nr("<</>>/>>>", 8),
  plusMin: new He("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: Nr("%", 10),
  star: Nr("*", 10),
  slash: Nr("/", 10),
  starstar: new He("**", { beforeExpr: true }),
  // Keyword token types.
  _break: Be2("break"),
  _case: Be2("case", Or),
  _catch: Be2("catch"),
  _continue: Be2("continue"),
  _debugger: Be2("debugger"),
  _default: Be2("default", Or),
  _do: Be2("do", { isLoop: true, beforeExpr: true }),
  _else: Be2("else", Or),
  _finally: Be2("finally"),
  _for: Be2("for", { isLoop: true }),
  _function: Be2("function", ar),
  _if: Be2("if"),
  _return: Be2("return", Or),
  _switch: Be2("switch"),
  _throw: Be2("throw", Or),
  _try: Be2("try"),
  _var: Be2("var"),
  _const: Be2("const"),
  _while: Be2("while", { isLoop: true }),
  _with: Be2("with"),
  _new: Be2("new", { beforeExpr: true, startsExpr: true }),
  _this: Be2("this", ar),
  _super: Be2("super", ar),
  _class: Be2("class", ar),
  _extends: Be2("extends", Or),
  _export: Be2("export"),
  _import: Be2("import", ar),
  _null: Be2("null", ar),
  _true: Be2("true", ar),
  _false: Be2("false", ar),
  _in: Be2("in", { beforeExpr: true, binop: 7 }),
  _instanceof: Be2("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: Be2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: Be2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: Be2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var gr = /\r\n?|\n|\u2028|\u2029/;
var Wi = new RegExp(gr.source, "g");
function Ni(e, t) {
  return e === 10 || e === 13 || !t && (e === 8232 || e === 8233);
}
var HE = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var $r = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var zE = Object.prototype;
var $N = zE.hasOwnProperty;
var YN = zE.toString;
function io(e, t) {
  return $N.call(e, t);
}
var Oh = Array.isArray || function(e) {
  return YN.call(e) === "[object Array]";
};
function ki(e) {
  return new RegExp("^(?:" + e.replace(/ /g, "|") + ")$");
}
var la = function(t, r) {
  this.line = t, this.column = r;
};
la.prototype.offset = function(t) {
  return new la(this.line, this.column + t);
};
var bn = function(t, r, i) {
  this.start = r, this.end = i, t.sourceFile !== null && (this.source = t.sourceFile);
};
function ua2(e, t) {
  for (var r = 1, i = 0; ; ) {
    Wi.lastIndex = i;
    var n = Wi.exec(e);
    if (n && n.index < t)
      ++r, i = n.index + n[0].length;
    else
      return new la(r, t - i);
  }
}
var Ds = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 9.
  ecmaVersion: 9,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
function FN(e) {
  var t = {};
  for (var r in Ds)
    t[r] = e && io(e, r) ? e[r] : Ds[r];
  if (t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), Oh(t.onToken)) {
    var i = t.onToken;
    t.onToken = function(n) {
      return i.push(n);
    };
  }
  return Oh(t.onComment) && (t.onComment = WN(t, t.onComment)), t;
}
function WN(e, t) {
  return function(r, i, n, a, s, o) {
    var l = {
      type: r ? "Block" : "Line",
      value: i,
      start: n,
      end: a
    };
    e.locations && (l.loc = new bn(this, s, o)), e.ranges && (l.range = [n, a]), t.push(l);
  };
}
var ca = 1;
var Ia = 2;
var Ec = ca | Ia;
var qE = 4;
var JE = 8;
var KE = 16;
var ed = 32;
var td = 64;
var rd = 128;
function dc(e, t) {
  return Ia | (e ? qE : 0) | (t ? JE : 0);
}
var Eh = 0;
var Tc = 1;
var ei = 2;
var id = 3;
var nd = 4;
var ad = 5;
var _t = function(t, r, i) {
  this.options = t = FN(t), this.sourceFile = t.sourceFile, this.keywords = ki(kN[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var n = "";
  if (t.allowReserved !== true) {
    for (var a = t.ecmaVersion; !(n = $o[a]); a--)
      ;
    t.sourceType === "module" && (n += " await");
  }
  this.reservedWords = ki(n);
  var s = (n ? n + " " : "") + $o.strict;
  this.reservedWordsStrict = ki(s), this.reservedWordsStrictBind = ki(s + " " + $o.strictBind), this.input = String(r), this.containsEsc = false, i ? (this.pos = i, this.lineStart = this.input.lastIndexOf(`
`, i - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(gr).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = T.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(ca), this.regexpState = null;
};
var Hi = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true } };
_t.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
Hi.inFunction.get = function() {
  return (this.currentVarScope().flags & Ia) > 0;
};
Hi.inGenerator.get = function() {
  return (this.currentVarScope().flags & JE) > 0;
};
Hi.inAsync.get = function() {
  return (this.currentVarScope().flags & qE) > 0;
};
Hi.allowSuper.get = function() {
  return (this.currentThisScope().flags & td) > 0;
};
Hi.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & rd) > 0;
};
Hi.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
_t.prototype.inNonArrowFunction = function() {
  return (this.currentThisScope().flags & Ia) > 0;
};
_t.extend = function() {
  for (var t = [], r = arguments.length; r--; )
    t[r] = arguments[r];
  for (var i = this, n = 0; n < t.length; n++)
    i = t[n](i);
  return i;
};
_t.parse = function(t, r) {
  return new this(r, t).parse();
};
_t.parseExpressionAt = function(t, r, i) {
  var n = new this(i, t, r);
  return n.nextToken(), n.parseExpression();
};
_t.tokenizer = function(t, r) {
  return new this(r, t);
};
Object.defineProperties(_t.prototype, Hi);
var Ht = _t.prototype;
var XN = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
Ht.strictDirective = function(e) {
  for (; ; ) {
    $r.lastIndex = e, e += $r.exec(this.input)[0].length;
    var t = XN.exec(this.input.slice(e));
    if (!t)
      return false;
    if ((t[1] || t[2]) === "use strict")
      return true;
    e += t[0].length, $r.lastIndex = e, e += $r.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
Ht.eat = function(e) {
  return this.type === e ? (this.next(), true) : false;
};
Ht.isContextual = function(e) {
  return this.type === T.name && this.value === e && !this.containsEsc;
};
Ht.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), true) : false;
};
Ht.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
Ht.canInsertSemicolon = function() {
  return this.type === T.eof || this.type === T.braceR || gr.test(this.input.slice(this.lastTokEnd, this.start));
};
Ht.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
};
Ht.semicolon = function() {
  !this.eat(T.semi) && !this.insertSemicolon() && this.unexpected();
};
Ht.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), true;
};
Ht.expect = function(e) {
  this.eat(e) || this.unexpected();
};
Ht.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
function fa() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
Ht.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
    r > -1 && this.raiseRecoverable(r, "Parenthesized pattern");
  }
};
Ht.checkExpressionErrors = function(e, t) {
  if (!e)
    return false;
  var r = e.shorthandAssign, i = e.doubleProto;
  if (!t)
    return r >= 0 || i >= 0;
  r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), i >= 0 && this.raiseRecoverable(i, "Redefinition of __proto__ property");
};
Ht.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
Ht.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var ve = _t.prototype;
ve.parseTopLevel = function(e) {
  var t = {};
  for (e.body || (e.body = []); this.type !== T.eof; ) {
    var r = this.parseStatement(null, true, t);
    e.body.push(r);
  }
  if (this.inModule)
    for (var i = 0, n = Object.keys(this.undefinedExports); i < n.length; i += 1) {
      var a = n[i];
      this.raiseRecoverable(this.undefinedExports[a].start, "Export '" + a + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var Sc = { kind: "loop" };
var jN = { kind: "switch" };
ve.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return false;
  $r.lastIndex = this.pos;
  var t = $r.exec(this.input), r = this.pos + t[0].length, i = this.input.charCodeAt(r);
  if (i === 91)
    return true;
  if (e)
    return false;
  if (i === 123)
    return true;
  if (Ai(i, true)) {
    for (var n = r + 1; Tn2(this.input.charCodeAt(n), true); )
      ++n;
    var a = this.input.slice(r, n);
    if (!QN.test(a))
      return true;
  }
  return false;
};
ve.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return false;
  $r.lastIndex = this.pos;
  var e = $r.exec(this.input), t = this.pos + e[0].length;
  return !gr.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !Tn2(this.input.charAt(t + 8)));
};
ve.parseStatement = function(e, t, r) {
  var i = this.type, n = this.startNode(), a;
  switch (this.isLet(e) && (i = T._var, a = "let"), i) {
    case T._break:
    case T._continue:
      return this.parseBreakContinueStatement(n, i.keyword);
    case T._debugger:
      return this.parseDebuggerStatement(n);
    case T._do:
      return this.parseDoStatement(n);
    case T._for:
      return this.parseForStatement(n);
    case T._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, false, !e);
    case T._class:
      return e && this.unexpected(), this.parseClass(n, true);
    case T._if:
      return this.parseIfStatement(n);
    case T._return:
      return this.parseReturnStatement(n);
    case T._switch:
      return this.parseSwitchStatement(n);
    case T._throw:
      return this.parseThrowStatement(n);
    case T._try:
      return this.parseTryStatement(n);
    case T._const:
    case T._var:
      return a = a || this.value, e && a !== "var" && this.unexpected(), this.parseVarStatement(n, a);
    case T._while:
      return this.parseWhileStatement(n);
    case T._with:
      return this.parseWithStatement(n);
    case T.braceL:
      return this.parseBlock(true, n);
    case T.semi:
      return this.parseEmptyStatement(n);
    case T._export:
    case T._import:
      if (this.options.ecmaVersion > 10 && i === T._import) {
        $r.lastIndex = this.pos;
        var s = $r.exec(this.input), o = this.pos + s[0].length, l = this.input.charCodeAt(o);
        if (l === 40)
          return this.parseExpressionStatement(n, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), i === T._import ? this.parseImport(n) : this.parseExport(n, r);
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(n, true, !e);
      var c = this.value, f = this.parseExpression();
      return i === T.name && f.type === "Identifier" && this.eat(T.colon) ? this.parseLabeledStatement(n, c, f, e) : this.parseExpressionStatement(n, f);
  }
};
ve.parseBreakContinueStatement = function(e, t) {
  var r = t === "break";
  this.next(), this.eat(T.semi) || this.insertSemicolon() ? e.label = null : this.type !== T.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var i = 0; i < this.labels.length; ++i) {
    var n = this.labels[i];
    if ((e.label == null || n.name === e.label.name) && (n.kind != null && (r || n.kind === "loop") || e.label && r))
      break;
  }
  return i === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
};
ve.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
ve.parseDoStatement = function(e) {
  return this.next(), this.labels.push(Sc), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(T._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(T.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
ve.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(Sc), this.enterScope(0), this.expect(T.parenL), this.type === T.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var r = this.isLet();
  if (this.type === T._var || this.type === T._const || r) {
    var i = this.startNode(), n = r ? "let" : this.value;
    return this.next(), this.parseVar(i, true, n), this.finishNode(i, "VariableDeclaration"), (this.type === T._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && i.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === T._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, i)) : (t > -1 && this.unexpected(t), this.parseFor(e, i));
  }
  var a = new fa(), s = this.parseExpression(true, a);
  return this.type === T._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === T._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.toAssignable(s, false, a), this.checkLVal(s), this.parseForIn(e, s)) : (this.checkExpressionErrors(a, true), t > -1 && this.unexpected(t), this.parseFor(e, s));
};
ve.parseFunctionStatement = function(e, t, r) {
  return this.next(), this.parseFunction(e, Xn | (r ? 0 : Pl), false, t);
};
ve.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(T._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
ve.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(T.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
ve.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(T.braceL), this.labels.push(jN), this.enterScope(0);
  for (var t, r = false; this.type !== T.braceR; )
    if (this.type === T._case || this.type === T._default) {
      var i = this.type === T._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), i ? t.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = true, t.test = null), this.expect(T.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
ve.parseThrowStatement = function(e) {
  return this.next(), gr.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var ZN = [];
ve.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === T._catch) {
    var t = this.startNode();
    if (this.next(), this.eat(T.parenL)) {
      t.param = this.parseBindingAtom();
      var r = t.param.type === "Identifier";
      this.enterScope(r ? ed : 0), this.checkLVal(t.param, r ? nd : ei), this.expect(T.parenR);
    } else
      this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0);
    t.body = this.parseBlock(false), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(T._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
ve.parseVarStatement = function(e, t) {
  return this.next(), this.parseVar(e, false, t), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
ve.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(Sc), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
ve.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
ve.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
ve.parseLabeledStatement = function(e, t, r, i) {
  for (var n = 0, a = this.labels; n < a.length; n += 1) {
    var s = a[n];
    s.name === t && this.raise(r.start, "Label '" + t + "' is already declared");
  }
  for (var o = this.type.isLoop ? "loop" : this.type === T._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var c = this.labels[l];
    if (c.statementStart === e.start)
      c.statementStart = this.start, c.kind = o;
    else
      break;
  }
  return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(i ? i.indexOf("label") === -1 ? i + "label" : i : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
};
ve.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
ve.parseBlock = function(e, t) {
  for (e === void 0 && (e = true), t === void 0 && (t = this.startNode()), t.body = [], this.expect(T.braceL), e && this.enterScope(0); !this.eat(T.braceR); ) {
    var r = this.parseStatement(null);
    t.body.push(r);
  }
  return e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
ve.parseFor = function(e, t) {
  return e.init = t, this.expect(T.semi), e.test = this.type === T.semi ? null : this.parseExpression(), this.expect(T.semi), e.update = this.type === T.parenR ? null : this.parseExpression(), this.expect(T.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
ve.parseForIn = function(e, t) {
  var r = this.type === T._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") ? this.raise(
    t.start,
    (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ) : t.type === "AssignmentPattern" && this.raise(t.start, "Invalid left-hand side in for-loop"), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(T.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
};
ve.parseVar = function(e, t, r) {
  for (e.declarations = [], e.kind = r; ; ) {
    var i = this.startNode();
    if (this.parseVarId(i, r), this.eat(T.eq) ? i.init = this.parseMaybeAssign(t) : r === "const" && !(this.type === T._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : i.id.type !== "Identifier" && !(t && (this.type === T._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : i.init = null, e.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(T.comma))
      break;
  }
  return e;
};
ve.parseVarId = function(e, t) {
  e.id = this.parseBindingAtom(), this.checkLVal(e.id, t === "var" ? Tc : ei, false);
};
var Xn = 1;
var Pl = 2;
var sd = 4;
ve.parseFunction = function(e, t, r, i) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i) && (this.type === T.star && t & Pl && this.unexpected(), e.generator = this.eat(T.star)), this.options.ecmaVersion >= 8 && (e.async = !!i), t & Xn && (e.id = t & sd && this.type !== T.name ? null : this.parseIdent(), e.id && !(t & Pl) && this.checkLVal(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? Tc : ei : id));
  var n = this.yieldPos, a = this.awaitPos, s = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(dc(e.async, e.generator)), t & Xn || (e.id = this.type === T.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, false), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = s, this.finishNode(e, t & Xn ? "FunctionDeclaration" : "FunctionExpression");
};
ve.parseFunctionParams = function(e) {
  this.expect(T.parenL), e.params = this.parseBindingList(T.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
ve.parseClass = function(e, t) {
  this.next();
  var r = this.strict;
  this.strict = true, this.parseClassId(e, t), this.parseClassSuper(e);
  var i = this.startNode(), n = false;
  for (i.body = [], this.expect(T.braceL); !this.eat(T.braceR); ) {
    var a = this.parseClassElement(e.superClass !== null);
    a && (i.body.push(a), a.type === "MethodDefinition" && a.kind === "constructor" && (n && this.raise(a.start, "Duplicate constructor in the same class"), n = true));
  }
  return e.body = this.finishNode(i, "ClassBody"), this.strict = r, this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
ve.parseClassElement = function(e) {
  var t = this;
  if (this.eat(T.semi))
    return null;
  var r = this.startNode(), i = function(l, c) {
    c === void 0 && (c = false);
    var f = t.start, p = t.startLoc;
    return t.eatContextual(l) ? t.type !== T.parenL && (!c || !t.canInsertSemicolon()) ? true : (r.key && t.unexpected(), r.computed = false, r.key = t.startNodeAt(f, p), r.key.name = l, t.finishNode(r.key, "Identifier"), false) : false;
  };
  r.kind = "method", r.static = i("static");
  var n = this.eat(T.star), a = false;
  n || (this.options.ecmaVersion >= 8 && i("async", true) ? (a = true, n = this.options.ecmaVersion >= 9 && this.eat(T.star)) : i("get") ? r.kind = "get" : i("set") && (r.kind = "set")), r.key || this.parsePropertyName(r);
  var s = r.key, o = false;
  return !r.computed && !r.static && (s.type === "Identifier" && s.name === "constructor" || s.type === "Literal" && s.value === "constructor") ? (r.kind !== "method" && this.raise(s.start, "Constructor can't have get/set modifier"), n && this.raise(s.start, "Constructor can't be a generator"), a && this.raise(s.start, "Constructor can't be an async method"), r.kind = "constructor", o = e) : r.static && s.type === "Identifier" && s.name === "prototype" && this.raise(s.start, "Classes may not have a static property named prototype"), this.parseClassMethod(r, n, a, o), r.kind === "get" && r.value.params.length !== 0 && this.raiseRecoverable(r.value.start, "getter should have no params"), r.kind === "set" && r.value.params.length !== 1 && this.raiseRecoverable(r.value.start, "setter should have exactly one param"), r.kind === "set" && r.value.params[0].type === "RestElement" && this.raiseRecoverable(r.value.params[0].start, "Setter cannot use rest params"), r;
};
ve.parseClassMethod = function(e, t, r, i) {
  return e.value = this.parseMethod(t, r, i), this.finishNode(e, "MethodDefinition");
};
ve.parseClassId = function(e, t) {
  this.type === T.name ? (e.id = this.parseIdent(), t && this.checkLVal(e.id, ei, false)) : (t === true && this.unexpected(), e.id = null);
};
ve.parseClassSuper = function(e) {
  e.superClass = this.eat(T._extends) ? this.parseExprSubscripts() : null;
};
ve.parseExport = function(e, t) {
  if (this.next(), this.eat(T.star))
    return this.expectContextual("from"), this.type !== T.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
  if (this.eat(T._default)) {
    this.checkExport(t, "default", this.lastTokStart);
    var r;
    if (this.type === T._function || (r = this.isAsyncFunction())) {
      var i = this.startNode();
      this.next(), r && this.next(), e.declaration = this.parseFunction(i, Xn | sd, false, r);
    } else if (this.type === T._class) {
      var n = this.startNode();
      e.declaration = this.parseClass(n, "nullableID");
    } else
      e.declaration = this.parseMaybeAssign(), this.semicolon();
    return this.finishNode(e, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement())
    e.declaration = this.parseStatement(null), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id.name, e.declaration.id.start), e.specifiers = [], e.source = null;
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== T.string && this.unexpected(), e.source = this.parseExprAtom();
    else {
      for (var a = 0, s = e.specifiers; a < s.length; a += 1) {
        var o = s[a];
        this.checkUnreserved(o.local), this.checkLocalExport(o.local);
      }
      e.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
ve.checkExport = function(e, t, r) {
  e && (io(e, t) && this.raiseRecoverable(r, "Duplicate export '" + t + "'"), e[t] = true);
};
ve.checkPatternExport = function(e, t) {
  var r = t.type;
  if (r === "Identifier")
    this.checkExport(e, t.name, t.start);
  else if (r === "ObjectPattern")
    for (var i = 0, n = t.properties; i < n.length; i += 1) {
      var a = n[i];
      this.checkPatternExport(e, a);
    }
  else if (r === "ArrayPattern")
    for (var s = 0, o = t.elements; s < o.length; s += 1) {
      var l = o[s];
      l && this.checkPatternExport(e, l);
    }
  else
    r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "RestElement" ? this.checkPatternExport(e, t.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(e, t.expression);
};
ve.checkVariableExport = function(e, t) {
  if (e)
    for (var r = 0, i = t; r < i.length; r += 1) {
      var n = i[r];
      this.checkPatternExport(e, n.id);
    }
};
ve.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
ve.parseExportSpecifiers = function(e) {
  var t = [], r = true;
  for (this.expect(T.braceL); !this.eat(T.braceR); ) {
    if (r)
      r = false;
    else if (this.expect(T.comma), this.afterTrailingComma(T.braceR))
      break;
    var i = this.startNode();
    i.local = this.parseIdent(true), i.exported = this.eatContextual("as") ? this.parseIdent(true) : i.local, this.checkExport(e, i.exported.name, i.exported.start), t.push(this.finishNode(i, "ExportSpecifier"));
  }
  return t;
};
ve.parseImport = function(e) {
  return this.next(), this.type === T.string ? (e.specifiers = ZN, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === T.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
ve.parseImportSpecifiers = function() {
  var e = [], t = true;
  if (this.type === T.name) {
    var r = this.startNode();
    if (r.local = this.parseIdent(), this.checkLVal(r.local, ei), e.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat(T.comma))
      return e;
  }
  if (this.type === T.star) {
    var i = this.startNode();
    return this.next(), this.expectContextual("as"), i.local = this.parseIdent(), this.checkLVal(i.local, ei), e.push(this.finishNode(i, "ImportNamespaceSpecifier")), e;
  }
  for (this.expect(T.braceL); !this.eat(T.braceR); ) {
    if (t)
      t = false;
    else if (this.expect(T.comma), this.afterTrailingComma(T.braceR))
      break;
    var n = this.startNode();
    n.imported = this.parseIdent(true), this.eatContextual("as") ? n.local = this.parseIdent() : (this.checkUnreserved(n.imported), n.local = n.imported), this.checkLVal(n.local, ei), e.push(this.finishNode(n, "ImportSpecifier"));
  }
  return e;
};
ve.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
ve.isDirectiveCandidate = function(e) {
  return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var si = _t.prototype;
si.toAssignable = function(e, t, r) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", r && this.checkPatternErrors(r, true);
        for (var i = 0, n = e.properties; i < n.length; i += 1) {
          var a = n[i];
          this.toAssignable(a, t), a.type === "RestElement" && (a.argument.type === "ArrayPattern" || a.argument.type === "ObjectPattern") && this.raise(a.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", r && this.checkPatternErrors(r, true), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
      case "AssignmentPattern":
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, r);
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else
    r && this.checkPatternErrors(r, true);
  return e;
};
si.toAssignableList = function(e, t) {
  for (var r = e.length, i = 0; i < r; i++) {
    var n = e[i];
    n && this.toAssignable(n, t);
  }
  if (r) {
    var a = e[r - 1];
    this.options.ecmaVersion === 6 && t && a && a.type === "RestElement" && a.argument.type !== "Identifier" && this.unexpected(a.argument.start);
  }
  return e;
};
si.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(false, e), this.finishNode(t, "SpreadElement");
};
si.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== T.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
si.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case T.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(T.bracketR, true, true), this.finishNode(e, "ArrayPattern");
      case T.braceL:
        return this.parseObj(true);
    }
  return this.parseIdent();
};
si.parseBindingList = function(e, t, r) {
  for (var i = [], n = true; !this.eat(e); )
    if (n ? n = false : this.expect(T.comma), t && this.type === T.comma)
      i.push(null);
    else {
      if (r && this.afterTrailingComma(e))
        break;
      if (this.type === T.ellipsis) {
        var a = this.parseRestBinding();
        this.parseBindingListItem(a), i.push(a), this.type === T.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else {
        var s = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(s), i.push(s);
      }
    }
  return i;
};
si.parseBindingListItem = function(e) {
  return e;
};
si.parseMaybeDefault = function(e, t, r) {
  if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(T.eq))
    return r;
  var i = this.startNodeAt(e, t);
  return i.left = r, i.right = this.parseMaybeAssign(), this.finishNode(i, "AssignmentPattern");
};
si.checkLVal = function(e, t, r) {
  switch (t === void 0 && (t = Eh), e.type) {
    case "Identifier":
      t === ei && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (t ? "Binding " : "Assigning to ") + e.name + " in strict mode"), r && (io(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = true), t !== Eh && t !== ad && this.declareName(e.name, t, e.start);
      break;
    case "MemberExpression":
      t && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ObjectPattern":
      for (var i = 0, n = e.properties; i < n.length; i += 1) {
        var a = n[i];
        this.checkLVal(a, t, r);
      }
      break;
    case "Property":
      this.checkLVal(e.value, t, r);
      break;
    case "ArrayPattern":
      for (var s = 0, o = e.elements; s < o.length; s += 1) {
        var l = o[s];
        l && this.checkLVal(l, t, r);
      }
      break;
    case "AssignmentPattern":
      this.checkLVal(e.left, t, r);
      break;
    case "RestElement":
      this.checkLVal(e.argument, t, r);
      break;
    case "ParenthesizedExpression":
      this.checkLVal(e.expression, t, r);
      break;
    default:
      this.raise(e.start, (t ? "Binding" : "Assigning to") + " rvalue");
  }
};
var Qe = _t.prototype;
Qe.checkPropClash = function(e, t, r) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var i = e.key, n;
    switch (i.type) {
      case "Identifier":
        n = i.name;
        break;
      case "Literal":
        n = String(i.value);
        break;
      default:
        return;
    }
    var a = e.kind;
    if (this.options.ecmaVersion >= 6) {
      n === "__proto__" && a === "init" && (t.proto && (r && r.doubleProto < 0 ? r.doubleProto = i.start : this.raiseRecoverable(i.start, "Redefinition of __proto__ property")), t.proto = true);
      return;
    }
    n = "$" + n;
    var s = t[n];
    if (s) {
      var o;
      a === "init" ? o = this.strict && s.init || s.get || s.set : o = s.init || s[a], o && this.raiseRecoverable(i.start, "Redefinition of property");
    } else
      s = t[n] = {
        init: false,
        get: false,
        set: false
      };
    s[a] = true;
  }
};
Qe.parseExpression = function(e, t) {
  var r = this.start, i = this.startLoc, n = this.parseMaybeAssign(e, t);
  if (this.type === T.comma) {
    var a = this.startNodeAt(r, i);
    for (a.expressions = [n]; this.eat(T.comma); )
      a.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(a, "SequenceExpression");
  }
  return n;
};
Qe.parseMaybeAssign = function(e, t, r) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = false;
  }
  var i = false, n = -1, a = -1, s = -1;
  t ? (n = t.parenthesizedAssign, a = t.trailingComma, s = t.shorthandAssign, t.parenthesizedAssign = t.trailingComma = t.shorthandAssign = -1) : (t = new fa(), i = true);
  var o = this.start, l = this.startLoc;
  (this.type === T.parenL || this.type === T.name) && (this.potentialArrowAt = this.start);
  var c = this.parseMaybeConditional(e, t);
  if (r && (c = r.call(this, c, o, l)), this.type.isAssign) {
    var f = this.startNodeAt(o, l);
    return f.operator = this.value, f.left = this.type === T.eq ? this.toAssignable(c, false, t) : c, i || fa.call(t), t.shorthandAssign = -1, this.checkLVal(c), this.next(), f.right = this.parseMaybeAssign(e), this.finishNode(f, "AssignmentExpression");
  } else
    i && this.checkExpressionErrors(t, true);
  return n > -1 && (t.parenthesizedAssign = n), a > -1 && (t.trailingComma = a), s > -1 && (t.shorthandAssign = s), c;
};
Qe.parseMaybeConditional = function(e, t) {
  var r = this.start, i = this.startLoc, n = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return n;
  if (this.eat(T.question)) {
    var a = this.startNodeAt(r, i);
    return a.test = n, a.consequent = this.parseMaybeAssign(), this.expect(T.colon), a.alternate = this.parseMaybeAssign(e), this.finishNode(a, "ConditionalExpression");
  }
  return n;
};
Qe.parseExprOps = function(e, t) {
  var r = this.start, i = this.startLoc, n = this.parseMaybeUnary(t, false);
  return this.checkExpressionErrors(t) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, i, -1, e);
};
Qe.parseExprOp = function(e, t, r, i, n) {
  var a = this.type.binop;
  if (a != null && (!n || this.type !== T._in) && a > i) {
    var s = this.type === T.logicalOR || this.type === T.logicalAND, o = this.value;
    this.next();
    var l = this.start, c = this.startLoc, f = this.parseExprOp(this.parseMaybeUnary(null, false), l, c, a, n), p = this.buildBinary(t, r, e, f, o, s);
    return this.parseExprOp(p, t, r, i, n);
  }
  return e;
};
Qe.buildBinary = function(e, t, r, i, n, a) {
  var s = this.startNodeAt(e, t);
  return s.left = r, s.operator = n, s.right = i, this.finishNode(s, a ? "LogicalExpression" : "BinaryExpression");
};
Qe.parseMaybeUnary = function(e, t) {
  var r = this.start, i = this.startLoc, n;
  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
    n = this.parseAwait(), t = true;
  else if (this.type.prefix) {
    var a = this.startNode(), s = this.type === T.incDec;
    a.operator = this.value, a.prefix = true, this.next(), a.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e, true), s ? this.checkLVal(a.argument) : this.strict && a.operator === "delete" && a.argument.type === "Identifier" ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : t = true, n = this.finishNode(a, s ? "UpdateExpression" : "UnaryExpression");
  } else {
    if (n = this.parseExprSubscripts(e), this.checkExpressionErrors(e))
      return n;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var o = this.startNodeAt(r, i);
      o.operator = this.value, o.prefix = false, o.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(o, "UpdateExpression");
    }
  }
  return !t && this.eat(T.starstar) ? this.buildBinary(r, i, n, this.parseMaybeUnary(null, false), "**", false) : n;
};
Qe.parseExprSubscripts = function(e) {
  var t = this.start, r = this.startLoc, i = this.parseExprAtom(e), n = i.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(e) || n)
    return i;
  var a = this.parseSubscripts(i, t, r);
  return e && a.type === "MemberExpression" && (e.parenthesizedAssign >= a.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= a.start && (e.parenthesizedBind = -1)), a;
};
Qe.parseSubscripts = function(e, t, r, i) {
  for (var n = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && this.input.slice(e.start, e.end) === "async"; ; ) {
    var a = this.parseSubscript(e, t, r, i, n);
    if (a === e || a.type === "ArrowFunctionExpression")
      return a;
    e = a;
  }
};
Qe.parseSubscript = function(e, t, r, i, n) {
  var a = this.eat(T.bracketL);
  if (a || this.eat(T.dot)) {
    var s = this.startNodeAt(t, r);
    s.object = e, s.property = a ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), s.computed = !!a, a && this.expect(T.bracketR), e = this.finishNode(s, "MemberExpression");
  } else if (!i && this.eat(T.parenL)) {
    var o = new fa(), l = this.yieldPos, c = this.awaitPos, f = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var p = this.parseExprList(T.parenR, this.options.ecmaVersion >= 8 && e.type !== "Import", false, o);
    if (n && !this.canInsertSemicolon() && this.eat(T.arrow))
      return this.checkPatternErrors(o, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = l, this.awaitPos = c, this.awaitIdentPos = f, this.parseArrowExpression(this.startNodeAt(t, r), p, true);
    this.checkExpressionErrors(o, true), this.yieldPos = l || this.yieldPos, this.awaitPos = c || this.awaitPos, this.awaitIdentPos = f || this.awaitIdentPos;
    var O = this.startNodeAt(t, r);
    if (O.callee = e, O.arguments = p, O.callee.type === "Import") {
      O.arguments.length !== 1 && this.raise(O.start, "import() requires exactly one argument");
      var d2 = O.arguments[0];
      d2 && d2.type === "SpreadElement" && this.raise(d2.start, "... is not allowed in import()");
    }
    e = this.finishNode(O, "CallExpression");
  } else if (this.type === T.backQuote) {
    var g = this.startNodeAt(t, r);
    g.tag = e, g.quasi = this.parseTemplate({ isTagged: true }), e = this.finishNode(g, "TaggedTemplateExpression");
  }
  return e;
};
Qe.parseExprAtom = function(e) {
  this.type === T.slash && this.readRegexp();
  var t, r = this.potentialArrowAt === this.start;
  switch (this.type) {
    case T._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), t = this.startNode(), this.next(), this.type === T.parenL && !this.allowDirectSuper && this.raise(t.start, "super() call outside constructor of a subclass"), this.type !== T.dot && this.type !== T.bracketL && this.type !== T.parenL && this.unexpected(), this.finishNode(t, "Super");
    case T._this:
      return t = this.startNode(), this.next(), this.finishNode(t, "ThisExpression");
    case T.name:
      var i = this.start, n = this.startLoc, a = this.containsEsc, s = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !a && s.name === "async" && !this.canInsertSemicolon() && this.eat(T._function))
        return this.parseFunction(this.startNodeAt(i, n), 0, false, true);
      if (r && !this.canInsertSemicolon()) {
        if (this.eat(T.arrow))
          return this.parseArrowExpression(this.startNodeAt(i, n), [s], false);
        if (this.options.ecmaVersion >= 8 && s.name === "async" && this.type === T.name && !a)
          return s = this.parseIdent(false), (this.canInsertSemicolon() || !this.eat(T.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(i, n), [s], true);
      }
      return s;
    case T.regexp:
      var o = this.value;
      return t = this.parseLiteral(o.value), t.regex = { pattern: o.pattern, flags: o.flags }, t;
    case T.num:
    case T.string:
      return this.parseLiteral(this.value);
    case T._null:
    case T._true:
    case T._false:
      return t = this.startNode(), t.value = this.type === T._null ? null : this.type === T._true, t.raw = this.type.keyword, this.next(), this.finishNode(t, "Literal");
    case T.parenL:
      var l = this.start, c = this.parseParenAndDistinguishExpression(r);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(c) && (e.parenthesizedAssign = l), e.parenthesizedBind < 0 && (e.parenthesizedBind = l)), c;
    case T.bracketL:
      return t = this.startNode(), this.next(), t.elements = this.parseExprList(T.bracketR, true, true, e), this.finishNode(t, "ArrayExpression");
    case T.braceL:
      return this.parseObj(false, e);
    case T._function:
      return t = this.startNode(), this.next(), this.parseFunction(t, 0);
    case T._class:
      return this.parseClass(this.startNode(), false);
    case T._new:
      return this.parseNew();
    case T.backQuote:
      return this.parseTemplate();
    case T._import:
      return this.options.ecmaVersion > 10 ? this.parseDynamicImport() : this.unexpected();
    default:
      this.unexpected();
  }
};
Qe.parseDynamicImport = function() {
  var e = this.startNode();
  return this.next(), this.type !== T.parenL && this.unexpected(), this.finishNode(e, "Import");
};
Qe.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1)), this.next(), this.finishNode(t, "Literal");
};
Qe.parseParenExpression = function() {
  this.expect(T.parenL);
  var e = this.parseExpression();
  return this.expect(T.parenR), e;
};
Qe.parseParenAndDistinguishExpression = function(e) {
  var t = this.start, r = this.startLoc, i, n = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var a = this.start, s = this.startLoc, o = [], l = true, c = false, f = new fa(), p = this.yieldPos, O = this.awaitPos, d2;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== T.parenR; )
      if (l ? l = false : this.expect(T.comma), n && this.afterTrailingComma(T.parenR, true)) {
        c = true;
        break;
      } else if (this.type === T.ellipsis) {
        d2 = this.start, o.push(this.parseParenItem(this.parseRestBinding())), this.type === T.comma && this.raise(this.start, "Comma is not permitted after the rest element");
        break;
      } else
        o.push(this.parseMaybeAssign(false, f, this.parseParenItem));
    var g = this.start, L = this.startLoc;
    if (this.expect(T.parenR), e && !this.canInsertSemicolon() && this.eat(T.arrow))
      return this.checkPatternErrors(f, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = O, this.parseParenArrowList(t, r, o);
    (!o.length || c) && this.unexpected(this.lastTokStart), d2 && this.unexpected(d2), this.checkExpressionErrors(f, true), this.yieldPos = p || this.yieldPos, this.awaitPos = O || this.awaitPos, o.length > 1 ? (i = this.startNodeAt(a, s), i.expressions = o, this.finishNodeAt(i, "SequenceExpression", g, L)) : i = o[0];
  } else
    i = this.parseParenExpression();
  if (this.options.preserveParens) {
    var D = this.startNodeAt(t, r);
    return D.expression = i, this.finishNode(D, "ParenthesizedExpression");
  } else
    return i;
};
Qe.parseParenItem = function(e) {
  return e;
};
Qe.parseParenArrowList = function(e, t, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), r);
};
var HN = [];
Qe.parseNew = function() {
  var e = this.startNode(), t = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(T.dot)) {
    e.meta = t;
    var r = this.containsEsc;
    return e.property = this.parseIdent(true), (e.property.name !== "target" || r) && this.raiseRecoverable(e.property.start, "The only valid meta property for new is new.target"), this.inNonArrowFunction() || this.raiseRecoverable(e.start, "new.target can only be used in functions"), this.finishNode(e, "MetaProperty");
  }
  var i = this.start, n = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(), i, n, true), this.options.ecmaVersion > 10 && e.callee.type === "Import" && this.raise(e.callee.start, "Cannot use new with import(...)"), this.eat(T.parenL) ? e.arguments = this.parseExprList(T.parenR, this.options.ecmaVersion >= 8 && e.callee.type !== "Import", false) : e.arguments = HN, this.finishNode(e, "NewExpression");
};
Qe.parseTemplateElement = function(e) {
  var t = e.isTagged, r = this.startNode();
  return this.type === T.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = {
    raw: this.value,
    cooked: null
  }) : r.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), r.tail = this.type === T.backQuote, this.finishNode(r, "TemplateElement");
};
Qe.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = false);
  var r = this.startNode();
  this.next(), r.expressions = [];
  var i = this.parseTemplateElement({ isTagged: t });
  for (r.quasis = [i]; !i.tail; )
    this.type === T.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(T.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(T.braceR), r.quasis.push(i = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(r, "TemplateLiteral");
};
Qe.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === T.name || this.type === T.num || this.type === T.string || this.type === T.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === T.star) && !gr.test(this.input.slice(this.lastTokEnd, this.start));
};
Qe.parseObj = function(e, t) {
  var r = this.startNode(), i = true, n = {};
  for (r.properties = [], this.next(); !this.eat(T.braceR); ) {
    if (i)
      i = false;
    else if (this.expect(T.comma), this.afterTrailingComma(T.braceR))
      break;
    var a = this.parseProperty(e, t);
    e || this.checkPropClash(a, n, t), r.properties.push(a);
  }
  return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
};
Qe.parseProperty = function(e, t) {
  var r = this.startNode(), i, n, a, s;
  if (this.options.ecmaVersion >= 9 && this.eat(T.ellipsis))
    return e ? (r.argument = this.parseIdent(false), this.type === T.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (this.type === T.parenL && t && (t.parenthesizedAssign < 0 && (t.parenthesizedAssign = this.start), t.parenthesizedBind < 0 && (t.parenthesizedBind = this.start)), r.argument = this.parseMaybeAssign(false, t), this.type === T.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (r.method = false, r.shorthand = false, (e || t) && (a = this.start, s = this.startLoc), e || (i = this.eat(T.star)));
  var o = this.containsEsc;
  return this.parsePropertyName(r), !e && !o && this.options.ecmaVersion >= 8 && !i && this.isAsyncProp(r) ? (n = true, i = this.options.ecmaVersion >= 9 && this.eat(T.star), this.parsePropertyName(r, t)) : n = false, this.parsePropertyValue(r, e, i, n, a, s, t, o), this.finishNode(r, "Property");
};
Qe.parsePropertyValue = function(e, t, r, i, n, a, s, o) {
  if ((r || i) && this.type === T.colon && this.unexpected(), this.eat(T.colon))
    e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, s), e.kind = "init";
  else if (this.options.ecmaVersion >= 6 && this.type === T.parenL)
    t && this.unexpected(), e.kind = "init", e.method = true, e.value = this.parseMethod(r, i);
  else if (!t && !o && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== T.comma && this.type !== T.braceR) {
    (r || i) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(false);
    var l = e.kind === "get" ? 0 : 1;
    if (e.value.params.length !== l) {
      var c = e.value.start;
      e.kind === "get" ? this.raiseRecoverable(c, "getter should have no params") : this.raiseRecoverable(c, "setter should have exactly one param");
    } else
      e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
  } else
    this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r || i) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), e.kind = "init", t ? e.value = this.parseMaybeDefault(n, a, e.key) : this.type === T.eq && s ? (s.shorthandAssign < 0 && (s.shorthandAssign = this.start), e.value = this.parseMaybeDefault(n, a, e.key)) : e.value = e.key, e.shorthand = true) : this.unexpected();
};
Qe.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(T.bracketL))
      return e.computed = true, e.key = this.parseMaybeAssign(), this.expect(T.bracketR), e.key;
    e.computed = false;
  }
  return e.key = this.type === T.num || this.type === T.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
Qe.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = false), this.options.ecmaVersion >= 8 && (e.async = false);
};
Qe.parseMethod = function(e, t, r) {
  var i = this.startNode(), n = this.yieldPos, a = this.awaitPos, s = this.awaitIdentPos;
  return this.initFunction(i), this.options.ecmaVersion >= 6 && (i.generator = e), this.options.ecmaVersion >= 8 && (i.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(dc(t, i.generator) | td | (r ? rd : 0)), this.expect(T.parenL), i.params = this.parseBindingList(T.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i, false, true), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = s, this.finishNode(i, "FunctionExpression");
};
Qe.parseArrowExpression = function(e, t, r) {
  var i = this.yieldPos, n = this.awaitPos, a = this.awaitIdentPos;
  return this.enterScope(dc(r, false) | KE), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, true), this.parseFunctionBody(e, true, false), this.yieldPos = i, this.awaitPos = n, this.awaitIdentPos = a, this.finishNode(e, "ArrowFunctionExpression");
};
Qe.parseFunctionBody = function(e, t, r) {
  var i = t && this.type !== T.braceL, n = this.strict, a = false;
  if (i)
    e.body = this.parseMaybeAssign(), e.expression = true, this.checkParams(e, false);
  else {
    var s = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!n || s) && (a = this.strictDirective(this.end), a && s && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var o = this.labels;
    this.labels = [], a && (this.strict = true), this.checkParams(e, !n && !a && !t && !r && this.isSimpleParamList(e.params)), e.body = this.parseBlock(false), e.expression = false, this.adaptDirectivePrologue(e.body.body), this.labels = o;
  }
  this.exitScope(), this.strict && e.id && this.checkLVal(e.id, ad), this.strict = n;
};
Qe.isSimpleParamList = function(e) {
  for (var t = 0, r = e; t < r.length; t += 1) {
    var i = r[t];
    if (i.type !== "Identifier")
      return false;
  }
  return true;
};
Qe.checkParams = function(e, t) {
  for (var r = {}, i = 0, n = e.params; i < n.length; i += 1) {
    var a = n[i];
    this.checkLVal(a, Tc, t ? null : r);
  }
};
Qe.parseExprList = function(e, t, r, i) {
  for (var n = [], a = true; !this.eat(e); ) {
    if (a)
      a = false;
    else if (this.expect(T.comma), t && this.afterTrailingComma(e))
      break;
    var s = void 0;
    r && this.type === T.comma ? s = null : this.type === T.ellipsis ? (s = this.parseSpread(i), i && this.type === T.comma && i.trailingComma < 0 && (i.trailingComma = this.start)) : s = this.parseMaybeAssign(false, i), n.push(s);
  }
  return n;
};
Qe.checkUnreserved = function(e) {
  var t = e.start, r = e.end, i = e.name;
  if (this.inGenerator && i === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(i) && this.raise(t, "Unexpected keyword '" + i + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) {
    var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
    n.test(i) && (!this.inAsync && i === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + i + "' is reserved"));
  }
};
Qe.parseIdent = function(e, t) {
  var r = this.startNode();
  return this.type === T.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(), this.finishNode(r, "Identifier"), e || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r;
};
Qe.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === T.semi || this.canInsertSemicolon() || this.type !== T.star && !this.type.startsExpr ? (t.delegate = false, t.argument = null) : (t.delegate = this.eat(T.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
Qe.parseAwait = function() {
  this.awaitPos || (this.awaitPos = this.start);
  var e = this.startNode();
  return this.next(), e.argument = this.parseMaybeUnary(null, true), this.finishNode(e, "AwaitExpression");
};
var Us = _t.prototype;
Us.raise = function(e, t) {
  var r = ua2(this.input, e);
  t += " (" + r.line + ":" + r.column + ")";
  var i = new SyntaxError(t);
  throw i.pos = e, i.loc = r, i.raisedAt = this.pos, i;
};
Us.raiseRecoverable = Us.raise;
Us.curPosition = function() {
  if (this.options.locations)
    return new la(this.curLine, this.pos - this.lineStart);
};
var Pi = _t.prototype;
var zN = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [];
};
Pi.enterScope = function(e) {
  this.scopeStack.push(new zN(e));
};
Pi.exitScope = function() {
  this.scopeStack.pop();
};
Pi.treatFunctionsAsVarInScope = function(e) {
  return e.flags & Ia || !this.inModule && e.flags & ca;
};
Pi.declareName = function(e, t, r) {
  var i = false;
  if (t === ei) {
    var n = this.currentScope();
    i = n.lexical.indexOf(e) > -1 || n.functions.indexOf(e) > -1 || n.var.indexOf(e) > -1, n.lexical.push(e), this.inModule && n.flags & ca && delete this.undefinedExports[e];
  } else if (t === nd) {
    var a = this.currentScope();
    a.lexical.push(e);
  } else if (t === id) {
    var s = this.currentScope();
    this.treatFunctionsAsVar ? i = s.lexical.indexOf(e) > -1 : i = s.lexical.indexOf(e) > -1 || s.var.indexOf(e) > -1, s.functions.push(e);
  } else
    for (var o = this.scopeStack.length - 1; o >= 0; --o) {
      var l = this.scopeStack[o];
      if (l.lexical.indexOf(e) > -1 && !(l.flags & ed && l.lexical[0] === e) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(e) > -1) {
        i = true;
        break;
      }
      if (l.var.push(e), this.inModule && l.flags & ca && delete this.undefinedExports[e], l.flags & Ec)
        break;
    }
  i && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared");
};
Pi.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
Pi.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Pi.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & Ec)
      return t;
  }
};
Pi.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & Ec && !(t.flags & KE))
      return t;
  }
};
var Sn = function(t, r, i) {
  this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new bn(t, i)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]);
};
var no = _t.prototype;
no.startNode = function() {
  return new Sn(this, this.start, this.startLoc);
};
no.startNodeAt = function(e, t) {
  return new Sn(this, e, t);
};
function od(e, t, r, i) {
  return e.type = t, e.end = r, this.options.locations && (e.loc.end = i), this.options.ranges && (e.range[1] = r), e;
}
no.finishNode = function(e, t) {
  return od.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
no.finishNodeAt = function(e, t, r, i) {
  return od.call(this, e, t, r, i);
};
var Pr = function(t, r, i, n, a) {
  this.token = t, this.isExpr = !!r, this.preserveSpace = !!i, this.override = n, this.generator = !!a;
};
var gt = {
  b_stat: new Pr("{", false),
  b_expr: new Pr("{", true),
  b_tmpl: new Pr("${", false),
  p_stat: new Pr("(", false),
  p_expr: new Pr("(", true),
  q_tmpl: new Pr("`", true, true, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new Pr("function", false),
  f_expr: new Pr("function", true),
  f_expr_gen: new Pr("function", true, false, null, true),
  f_gen: new Pr("function", false, false, null, true)
};
var ao = _t.prototype;
ao.initialContext = function() {
  return [gt.b_stat];
};
ao.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === gt.f_expr || t === gt.f_stat ? true : e === T.colon && (t === gt.b_stat || t === gt.b_expr) ? !t.isExpr : e === T._return || e === T.name && this.exprAllowed ? gr.test(this.input.slice(this.lastTokEnd, this.start)) : e === T._else || e === T.semi || e === T.eof || e === T.parenR || e === T.arrow ? true : e === T.braceL ? t === gt.b_stat : e === T._var || e === T._const || e === T.name ? false : !this.exprAllowed;
};
ao.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return false;
};
ao.updateContext = function(e) {
  var t, r = this.type;
  r.keyword && e === T.dot ? this.exprAllowed = false : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr;
};
T.parenR.updateContext = T.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var e = this.context.pop();
  e === gt.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
T.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? gt.b_stat : gt.b_expr), this.exprAllowed = true;
};
T.dollarBraceL.updateContext = function() {
  this.context.push(gt.b_tmpl), this.exprAllowed = true;
};
T.parenL.updateContext = function(e) {
  var t = e === T._if || e === T._for || e === T._with || e === T._while;
  this.context.push(t ? gt.p_stat : gt.p_expr), this.exprAllowed = true;
};
T.incDec.updateContext = function() {
};
T._function.updateContext = T._class.updateContext = function(e) {
  e.beforeExpr && e !== T.semi && e !== T._else && !(e === T._return && gr.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === T.colon || e === T.braceL) && this.curContext() === gt.b_stat) ? this.context.push(gt.f_expr) : this.context.push(gt.f_stat), this.exprAllowed = false;
};
T.backQuote.updateContext = function() {
  this.curContext() === gt.q_tmpl ? this.context.pop() : this.context.push(gt.q_tmpl), this.exprAllowed = false;
};
T.star.updateContext = function(e) {
  if (e === T._function) {
    var t = this.context.length - 1;
    this.context[t] === gt.f_expr ? this.context[t] = gt.f_expr_gen : this.context[t] = gt.f_gen;
  }
  this.exprAllowed = true;
};
T.name.updateContext = function(e) {
  var t = false;
  this.options.ecmaVersion >= 6 && e !== T.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = true), this.exprAllowed = t;
};
var ld = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ud = ld + " Extended_Pictographic";
var qN = ud;
var JN = {
  9: ld,
  10: ud,
  11: qN
};
var dh = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var cd = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var fd = cd + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var KN = fd + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var eP = {
  9: cd,
  10: fd,
  11: KN
};
var hd = {};
function mc(e) {
  var t = hd[e] = {
    binary: ki(JN[e] + " " + dh),
    nonBinary: {
      General_Category: ki(dh),
      Script: ki(eP[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
mc(9);
mc(10);
mc(11);
var Te = _t.prototype;
var oi = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = hd[t.options.ecmaVersion >= 11 ? 11 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
oi.prototype.reset = function(t, r, i) {
  var n = i.indexOf("u") !== -1;
  this.start = t | 0, this.source = r + "", this.flags = i, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9;
};
oi.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
oi.prototype.at = function(t) {
  var r = this.source, i = r.length;
  if (t >= i)
    return -1;
  var n = r.charCodeAt(t);
  if (!this.switchU || n <= 55295 || n >= 57344 || t + 1 >= i)
    return n;
  var a = r.charCodeAt(t + 1);
  return a >= 56320 && a <= 57343 ? (n << 10) + a - 56613888 : n;
};
oi.prototype.nextIndex = function(t) {
  var r = this.source, i = r.length;
  if (t >= i)
    return i;
  var n = r.charCodeAt(t), a;
  return !this.switchU || n <= 55295 || n >= 57344 || t + 1 >= i || (a = r.charCodeAt(t + 1)) < 56320 || a > 57343 ? t + 1 : t + 2;
};
oi.prototype.current = function() {
  return this.at(this.pos);
};
oi.prototype.lookahead = function() {
  return this.at(this.nextIndex(this.pos));
};
oi.prototype.advance = function() {
  this.pos = this.nextIndex(this.pos);
};
oi.prototype.eat = function(t) {
  return this.current() === t ? (this.advance(), true) : false;
};
function ws(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
Te.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, r = e.flags, i = 0; i < r.length; i++) {
    var n = r.charAt(i);
    t.indexOf(n) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(n, i + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag");
  }
};
Te.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = true, this.regexp_pattern(e));
};
Te.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = false, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* [ */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
    var i = r[t];
    e.groupNames.indexOf(i) === -1 && e.raise("Invalid named capture referenced");
  }
};
Te.regexp_disjunction = function(e) {
  for (this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_alternative(e);
  this.regexp_eatQuantifier(e, true) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
Te.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
Te.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), true) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), true) : false;
};
Te.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = false, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return true;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return true;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var r = false;
    if (this.options.ecmaVersion >= 9 && (r = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, true;
  }
  return e.pos = t, false;
};
Te.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = false), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), true) : false;
};
Te.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
Te.regexp_eatBracedQuantifier = function(e, t) {
  var r = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var i = 0, n = -1;
    if (this.regexp_eatDecimalDigits(e) && (i = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return n !== -1 && n < i && !t && e.raise("numbers out of order in {} quantifier"), true;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r;
  }
  return false;
};
Te.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
Te.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return true;
    e.pos = t;
  }
  return false;
};
Te.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    ) && e.eat(
      58
      /* : */
    )) {
      if (this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ))
        return true;
      e.raise("Unterminated group");
    }
    e.pos = t;
  }
  return false;
};
Te.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, true;
    e.raise("Unterminated group");
  }
  return false;
};
Te.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
Te.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, true) && e.raise("Nothing to repeat"), false;
};
Te.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return pd(t) ? (e.lastIntValue = t, e.advance(), true) : false;
};
function pd(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
Te.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !pd(r); )
    e.advance();
  return e.pos !== t;
};
Te.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), true) : false;
};
Te.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(e)) {
      e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise("Duplicate capture group name"), e.groupNames.push(e.lastStringValue);
      return;
    }
    e.raise("Invalid group");
  }
};
Te.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return true;
    e.raise("Invalid capture group name");
  }
  return false;
};
Te.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += ws(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += ws(e.lastIntValue);
    return true;
  }
  return false;
};
Te.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, r = e.current();
  return e.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (r = e.lastIntValue), tP(r) ? (e.lastIntValue = r, true) : (e.pos = t, false);
};
function tP(e) {
  return Ai(e, true) || e === 36 || e === 95;
}
Te.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, r = e.current();
  return e.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e) && (r = e.lastIntValue), rP(r) ? (e.lastIntValue = r, true) : (e.pos = t, false);
};
function rP(e) {
  return Tn2(e, true) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
Te.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? true : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), false);
};
Te.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var r = e.lastIntValue;
    if (e.switchU)
      return r > e.maxBackReference && (e.maxBackReference = r), true;
    if (r <= e.numCapturingParens)
      return true;
    e.pos = t;
  }
  return false;
};
Te.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), true;
    e.raise("Invalid named reference");
  }
  return false;
};
Te.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
Te.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return true;
    e.pos = t;
  }
  return false;
};
Te.regexp_eatZero = function(e) {
  return e.current() === 48 && !so(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), true) : false;
};
Te.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), true) : t === 110 ? (e.lastIntValue = 10, e.advance(), true) : t === 118 ? (e.lastIntValue = 11, e.advance(), true) : t === 102 ? (e.lastIntValue = 12, e.advance(), true) : t === 114 ? (e.lastIntValue = 13, e.advance(), true) : false;
};
Te.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return Od(t) ? (e.lastIntValue = t % 32, e.advance(), true) : false;
};
function Od(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
Te.regexp_eatRegExpUnicodeEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var r = e.lastIntValue;
      if (e.switchU && r >= 55296 && r <= 56319) {
        var i = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var n = e.lastIntValue;
          if (n >= 56320 && n <= 57343)
            return e.lastIntValue = (r - 55296) * 1024 + (n - 56320) + 65536, true;
        }
        e.pos = i, e.lastIntValue = r;
      }
      return true;
    }
    if (e.switchU && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && iP(e.lastIntValue))
      return true;
    e.switchU && e.raise("Invalid unicode escape"), e.pos = t;
  }
  return false;
};
function iP(e) {
  return e >= 0 && e <= 1114111;
}
Te.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? true : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, true) : false;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), true) : false;
};
Te.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return true;
  }
  return false;
};
Te.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (nP(t))
    return e.lastIntValue = -1, e.advance(), true;
  if (e.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) {
    if (e.lastIntValue = -1, e.advance(), e.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(
      125
      /* } */
    ))
      return true;
    e.raise("Invalid property name");
  }
  return false;
};
function nP(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
Te.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var r = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var i = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, r, i), true;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var n = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, n), true;
  }
  return false;
};
Te.regexp_validateUnicodePropertyNameAndValue = function(e, t, r) {
  io(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid property value");
};
Te.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  e.unicodeProperties.binary.test(t) || e.raise("Invalid property name");
};
Te.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; Ed(t = e.current()); )
    e.lastStringValue += ws(t), e.advance();
  return e.lastStringValue !== "";
};
function Ed(e) {
  return Od(e) || e === 95;
}
Te.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; aP(t = e.current()); )
    e.lastStringValue += ws(t), e.advance();
  return e.lastStringValue !== "";
};
function aP(e) {
  return Ed(e) || so(e);
}
Te.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
Te.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    if (e.eat(
      94
      /* ^ */
    ), this.regexp_classRanges(e), e.eat(
      93
      /* [ */
    ))
      return true;
    e.raise("Unterminated character class");
  }
  return false;
};
Te.regexp_classRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var r = e.lastIntValue;
      e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of order in character class");
    }
  }
};
Te.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return true;
    if (e.switchU) {
      var r = e.current();
      (r === 99 || Sd(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var i = e.current();
  return i !== 93 ? (e.lastIntValue = i, e.advance(), true) : false;
};
Te.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, true;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, true;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return true;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
Te.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return so(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), true) : false;
};
Te.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return true;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return false;
};
Te.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, r = 0;
  for (e.lastIntValue = 0; so(r = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
  return e.pos !== t;
};
function so(e) {
  return e >= 48 && e <= 57;
}
Te.regexp_eatHexDigits = function(e) {
  var t = e.pos, r = 0;
  for (e.lastIntValue = 0; dd(r = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + Td(r), e.advance();
  return e.pos !== t;
};
function dd(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function Td(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
Te.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var r = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r;
    } else
      e.lastIntValue = t;
    return true;
  }
  return false;
};
Te.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return Sd(t) ? (e.lastIntValue = t - 48, e.advance(), true) : (e.lastIntValue = 0, false);
};
function Sd(e) {
  return e >= 48 && e <= 55;
}
Te.regexp_eatFixedHexDigits = function(e, t) {
  var r = e.pos;
  e.lastIntValue = 0;
  for (var i = 0; i < t; ++i) {
    var n = e.current();
    if (!dd(n))
      return e.pos = r, false;
    e.lastIntValue = 16 * e.lastIntValue + Td(n), e.advance();
  }
  return true;
};
var oo = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new bn(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
};
var Fe = _t.prototype;
Fe.next = function() {
  this.options.onToken && this.options.onToken(new oo(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
Fe.getToken = function() {
  return this.next(), new oo(this);
};
typeof Symbol < "u" && (Fe[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === T.eof,
        value: t
      };
    }
  };
});
Fe.curContext = function() {
  return this.context[this.context.length - 1];
};
Fe.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(T.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
Fe.readToken = function(e) {
  return Ai(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
Fe.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 57344)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return (e << 10) + t - 56613888;
};
Fe.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2);
  if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) {
    Wi.lastIndex = t;
    for (var i; (i = Wi.exec(this.input)) && i.index < this.pos; )
      ++this.curLine, this.lineStart = i.index + i[0].length;
  }
  this.options.onComment && this.options.onComment(
    true,
    this.input.slice(t + 2, r),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
Fe.skipLineComment = function(e) {
  for (var t = this.pos, r = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !Ni(i); )
    i = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    false,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    r,
    this.curPosition()
  );
};
Fe.skipSpace = function() {
  e:
    for (; this.pos < this.input.length; ) {
      var e = this.input.charCodeAt(this.pos);
      switch (e) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (e > 8 && e < 14 || e >= 5760 && HE.test(String.fromCharCode(e)))
            ++this.pos;
          else
            break e;
      }
    }
};
Fe.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var r = this.type;
  this.type = e, this.value = t, this.updateContext(r);
};
Fe.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(true);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(T.ellipsis)) : (++this.pos, this.finishToken(T.dot));
};
Fe.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(T.assign, 2) : this.finishOp(T.slash, 1);
};
Fe.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), r = 1, i = e === 42 ? T.star : T.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, i = T.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(T.assign, r + 1) : this.finishOp(i, r);
};
Fe.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? this.finishOp(e === 124 ? T.logicalOR : T.logicalAND, 2) : t === 61 ? this.finishOp(T.assign, 2) : this.finishOp(e === 124 ? T.bitwiseOR : T.bitwiseAND, 1);
};
Fe.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(T.assign, 2) : this.finishOp(T.bitwiseXOR, 1);
};
Fe.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || gr.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(T.incDec, 2) : t === 61 ? this.finishOp(T.assign, 2) : this.finishOp(T.plusMin, 1);
};
Fe.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), r = 1;
  return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(T.assign, r + 1) : this.finishOp(T.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2), this.finishOp(T.relational, r));
};
Fe.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(T.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(T.arrow)) : this.finishOp(e === 61 ? T.eq : T.prefix, 1);
};
Fe.getTokenFromCode = function(e) {
  switch (e) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(T.parenL);
    case 41:
      return ++this.pos, this.finishToken(T.parenR);
    case 59:
      return ++this.pos, this.finishToken(T.semi);
    case 44:
      return ++this.pos, this.finishToken(T.comma);
    case 91:
      return ++this.pos, this.finishToken(T.bracketL);
    case 93:
      return ++this.pos, this.finishToken(T.bracketR);
    case 123:
      return ++this.pos, this.finishToken(T.braceL);
    case 125:
      return ++this.pos, this.finishToken(T.braceR);
    case 58:
      return ++this.pos, this.finishToken(T.colon);
    case 63:
      return ++this.pos, this.finishToken(T.question);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(T.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(e);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 126:
      return this.finishOp(T.prefix, 1);
  }
  this.raise(this.pos, "Unexpected character '" + Rc(e) + "'");
};
Fe.finishOp = function(e, t) {
  var r = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, r);
};
Fe.readRegexp = function() {
  for (var e, t, r = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
    var i = this.input.charAt(this.pos);
    if (gr.test(i) && this.raise(r, "Unterminated regular expression"), e)
      e = false;
    else {
      if (i === "[")
        t = true;
      else if (i === "]" && t)
        t = false;
      else if (i === "/" && !t)
        break;
      e = i === "\\";
    }
    ++this.pos;
  }
  var n = this.input.slice(r, this.pos);
  ++this.pos;
  var a = this.pos, s = this.readWord1();
  this.containsEsc && this.unexpected(a);
  var o = this.regexpState || (this.regexpState = new oi(this));
  o.reset(r, n, s), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
  var l = null;
  try {
    l = new RegExp(n, s);
  } catch {
  }
  return this.finishToken(T.regexp, { pattern: n, flags: s, value: l });
};
Fe.readInt = function(e, t) {
  for (var r = this.pos, i = 0, n = 0, a = t ?? 1 / 0; n < a; ++n) {
    var s = this.input.charCodeAt(this.pos), o = void 0;
    if (s >= 97 ? o = s - 97 + 10 : s >= 65 ? o = s - 65 + 10 : s >= 48 && s <= 57 ? o = s - 48 : o = 1 / 0, o >= e)
      break;
    ++this.pos, i = i * e + o;
  }
  return this.pos === r || t != null && this.pos - r !== t ? null : i;
};
Fe.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var r = this.readInt(e);
  return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = typeof BigInt < "u" ? BigInt(this.input.slice(t, this.pos)) : null, ++this.pos) : Ai(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(T.num, r);
};
Fe.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10) === null && this.raise(t, "Invalid number");
  var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  r && this.strict && this.raise(t, "Invalid number"), r && /[89]/.test(this.input.slice(t, this.pos)) && (r = false);
  var i = this.input.charCodeAt(this.pos);
  if (!r && !e && this.options.ecmaVersion >= 11 && i === 110) {
    var n = this.input.slice(t, this.pos), a = typeof BigInt < "u" ? BigInt(n) : null;
    return ++this.pos, Ai(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(T.num, a);
  }
  i === 46 && !r && (++this.pos, this.readInt(10), i = this.input.charCodeAt(this.pos)), (i === 69 || i === 101) && !r && (i = this.input.charCodeAt(++this.pos), (i === 43 || i === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), Ai(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = this.input.slice(t, this.pos), o = r ? parseInt(s, 8) : parseFloat(s);
  return this.finishToken(T.num, o);
};
Fe.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var r = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
function Rc(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
Fe.readString = function(e) {
  for (var t = "", r = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var i = this.input.charCodeAt(this.pos);
    if (i === e)
      break;
    i === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(false), r = this.pos) : (Ni(i, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(r, this.pos++), this.finishToken(T.string, t);
};
var md = {};
Fe.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === md)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = false;
};
Fe.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw md;
  this.raise(e, t);
};
Fe.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var r = this.input.charCodeAt(this.pos);
    if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === T.template || this.type === T.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(T.dollarBraceL)) : (++this.pos, this.finishToken(T.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(T.template, e));
    if (r === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(true), t = this.pos;
    else if (Ni(r)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(r);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
Fe.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken(T.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
Fe.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return Rc(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    default:
      if (t >= 48 && t <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], i = parseInt(r, 8);
        return i > 255 && (r = r.slice(0, -1), i = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), (r !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - r.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(i);
      }
      return Ni(t) ? "" : String.fromCharCode(t);
  }
};
Fe.readHexChar = function(e) {
  var t = this.pos, r = this.readInt(16, e);
  return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r;
};
Fe.readWord1 = function() {
  this.containsEsc = false;
  for (var e = "", t = true, r = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var n = this.fullCharCodeAtPos();
    if (Tn2(n, i))
      this.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.containsEsc = true, e += this.input.slice(r, this.pos);
      var a = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var s = this.readCodePoint();
      (t ? Ai : Tn2)(s, i) || this.invalidStringToken(a, "Invalid Unicode escape"), e += Rc(s), r = this.pos;
    } else
      break;
    t = false;
  }
  return e + this.input.slice(r, this.pos);
};
Fe.readWord = function() {
  var e = this.readWord1(), t = T.name;
  return this.keywords.test(e) && (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + e), t = Oc[e]), this.finishToken(t, e);
};
var sP = "6.4.2";
_t.acorn = {
  Parser: _t,
  version: sP,
  defaultOptions: Ds,
  Position: la,
  SourceLocation: bn,
  getLineInfo: ua2,
  Node: Sn,
  TokenType: He,
  tokTypes: T,
  keywordTypes: Oc,
  TokContext: Pr,
  tokContexts: gt,
  isIdentifierChar: Tn2,
  isIdentifierStart: Ai,
  Token: oo,
  isNewLine: Ni,
  lineBreak: gr,
  lineBreakG: Wi,
  nonASCIIwhitespace: HE
};
function Th() {
}
var Ke = function(t, r) {
  if (r === void 0 && (r = {}), this.toks = this.constructor.BaseParser.tokenizer(t, r), this.options = this.toks.options, this.input = this.toks.input, this.tok = this.last = { type: T.eof, start: 0, end: 0 }, this.tok.validateRegExpFlags = Th, this.tok.validateRegExpPattern = Th, this.options.locations) {
    var i = this.toks.curPosition();
    this.tok.loc = new bn(this.toks, i, i);
  }
  this.ahead = [], this.context = [], this.curIndent = 0, this.curLineStart = 0, this.nextLineStart = this.lineEnd(this.curLineStart) + 1, this.inAsync = false, this.inFunction = false;
};
Ke.prototype.startNode = function() {
  return new Sn(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
};
Ke.prototype.storeCurrentPos = function() {
  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
};
Ke.prototype.startNodeAt = function(t) {
  return this.options.locations ? new Sn(this.toks, t[0], t[1]) : new Sn(this.toks, t);
};
Ke.prototype.finishNode = function(t, r) {
  return t.type = r, t.end = this.last.end, this.options.locations && (t.loc.end = this.last.loc.end), this.options.ranges && (t.range[1] = this.last.end), t;
};
Ke.prototype.dummyNode = function(t) {
  var r = this.startNode();
  return r.type = t, r.end = r.start, this.options.locations && (r.loc.end = r.loc.start), this.options.ranges && (r.range[1] = r.start), this.last = { type: T.name, start: r.start, end: r.start, loc: r.loc }, r;
};
Ke.prototype.dummyIdent = function() {
  var t = this.dummyNode("Identifier");
  return t.name = "", t;
};
Ke.prototype.dummyString = function() {
  var t = this.dummyNode("Literal");
  return t.value = t.raw = "", t;
};
Ke.prototype.eat = function(t) {
  return this.tok.type === t ? (this.next(), true) : false;
};
Ke.prototype.isContextual = function(t) {
  return this.tok.type === T.name && this.tok.value === t;
};
Ke.prototype.eatContextual = function(t) {
  return this.tok.value === t && this.eat(T.name);
};
Ke.prototype.canInsertSemicolon = function() {
  return this.tok.type === T.eof || this.tok.type === T.braceR || gr.test(this.input.slice(this.last.end, this.tok.start));
};
Ke.prototype.semicolon = function() {
  return this.eat(T.semi);
};
Ke.prototype.expect = function(t) {
  if (this.eat(t))
    return true;
  for (var r = 1; r <= 2; r++)
    if (this.lookAhead(r).type === t) {
      for (var i = 0; i < r; i++)
        this.next();
      return true;
    }
};
Ke.prototype.pushCx = function() {
  this.context.push(this.curIndent);
};
Ke.prototype.popCx = function() {
  this.curIndent = this.context.pop();
};
Ke.prototype.lineEnd = function(t) {
  for (; t < this.input.length && !Ni(this.input.charCodeAt(t)); )
    ++t;
  return t;
};
Ke.prototype.indentationAfter = function(t) {
  for (var r = 0; ; ++t) {
    var i = this.input.charCodeAt(t);
    if (i === 32)
      ++r;
    else if (i === 9)
      r += this.options.tabSize;
    else
      return r;
  }
};
Ke.prototype.closes = function(t, r, i, n) {
  return this.tok.type === t || this.tok.type === T.eof ? true : i !== this.curLineStart && this.curIndent < r && this.tokenStartsLine() && (!n || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < r);
};
Ke.prototype.tokenStartsLine = function() {
  for (var t = this.tok.start - 1; t >= this.curLineStart; --t) {
    var r = this.input.charCodeAt(t);
    if (r !== 9 && r !== 32)
      return false;
  }
  return true;
};
Ke.prototype.extend = function(t, r) {
  this[t] = r(this[t]);
};
Ke.prototype.parse = function() {
  return this.next(), this.parseTopLevel();
};
Ke.extend = function() {
  for (var t = [], r = arguments.length; r--; )
    t[r] = arguments[r];
  for (var i = this, n = 0; n < t.length; n++)
    i = t[n](i);
  return i;
};
Ke.parse = function(t, r) {
  return new this(t, r).parse();
};
Ke.BaseParser = _t;
var lo = Ke.prototype;
function oP(e) {
  return e < 14 && e > 8 || e === 32 || e === 160 || Ni(e);
}
lo.next = function() {
  if (this.last = this.tok, this.ahead.length ? this.tok = this.ahead.shift() : this.tok = this.readToken(), this.tok.start >= this.nextLineStart) {
    for (; this.tok.start >= this.nextLineStart; )
      this.curLineStart = this.nextLineStart, this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    this.curIndent = this.indentationAfter(this.curLineStart);
  }
};
lo.readToken = function() {
  for (; ; )
    try {
      return this.toks.next(), this.toks.type === T.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6 && (this.toks.end++, this.toks.type = T.ellipsis), new oo(this.toks);
    } catch (a) {
      if (!(a instanceof SyntaxError))
        throw a;
      var e = a.message, t = a.raisedAt, r = true;
      if (/unterminated/i.test(e))
        if (t = this.lineEnd(a.pos + 1), /string/.test(e))
          r = { start: a.pos, end: t, type: T.string, value: this.input.slice(a.pos + 1, t) };
        else if (/regular expr/i.test(e)) {
          var i = this.input.slice(a.pos, t);
          try {
            i = new RegExp(i);
          } catch {
          }
          r = { start: a.pos, end: t, type: T.regexp, value: i };
        } else
          /template/.test(e) ? r = {
            start: a.pos,
            end: t,
            type: T.template,
            value: this.input.slice(a.pos, t)
          } : r = false;
      else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(e))
        for (; t < this.input.length && !oP(this.input.charCodeAt(t)); )
          ++t;
      else if (/character escape|expected hexadecimal/i.test(e))
        for (; t < this.input.length; ) {
          var n = this.input.charCodeAt(t++);
          if (n === 34 || n === 39 || Ni(n))
            break;
        }
      else if (/unexpected character/i.test(e))
        t++, r = false;
      else if (/regular expression/i.test(e))
        r = true;
      else
        throw a;
      if (this.resetTo(t), r === true && (r = { start: t, end: t, type: T.name, value: "" }), r)
        return this.options.locations && (r.loc = new bn(
          this.toks,
          ua2(this.input, r.start),
          ua2(this.input, r.end)
        )), r;
    }
};
lo.resetTo = function(e) {
  this.toks.pos = e;
  var t = this.input.charAt(e - 1);
  if (this.toks.exprAllowed = !t || /[[{(,;:?/*=+\-~!|&%^<>]/.test(t) || /[enwfd]/.test(t) && /\b(case|else|return|throw|new|in|(instance|type)?of|delete|void)$/.test(this.input.slice(e - 10, e)), this.options.locations) {
    this.toks.curLine = 1, this.toks.lineStart = Wi.lastIndex = 0;
    for (var r; (r = Wi.exec(this.input)) && r.index < e; )
      ++this.toks.curLine, this.toks.lineStart = r.index + r[0].length;
  }
};
lo.lookAhead = function(e) {
  for (; e > this.ahead.length; )
    this.ahead.push(this.readToken());
  return this.ahead[e - 1];
};
function ri(e) {
  return e.name === "";
}
var yr = Ke.prototype;
yr.parseTopLevel = function() {
  var e = this.startNodeAt(this.options.locations ? [0, ua2(this.input, 0)] : 0);
  for (e.body = []; this.tok.type !== T.eof; )
    e.body.push(this.parseStatement());
  return this.toks.adaptDirectivePrologue(e.body), this.last = this.tok, this.options.ecmaVersion >= 6 && (e.sourceType = this.options.sourceType), this.finishNode(e, "Program");
};
yr.parseStatement = function() {
  var e = this.tok.type, t = this.startNode(), r;
  switch (this.toks.isLet() && (e = T._var, r = "let"), e) {
    case T._break:
    case T._continue:
      this.next();
      var i = e === T._break;
      return this.semicolon() || this.canInsertSemicolon() ? t.label = null : (t.label = this.tok.type === T.name ? this.parseIdent() : null, this.semicolon()), this.finishNode(t, i ? "BreakStatement" : "ContinueStatement");
    case T._debugger:
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    case T._do:
      return this.next(), t.body = this.parseStatement(), t.test = this.eat(T._while) ? this.parseParenExpression() : this.dummyIdent(), this.semicolon(), this.finishNode(t, "DoWhileStatement");
    case T._for:
      this.next();
      var n = this.options.ecmaVersion >= 9 && this.inAsync && this.eatContextual("await");
      if (this.pushCx(), this.expect(T.parenL), this.tok.type === T.semi)
        return this.parseFor(t, null);
      var a = this.toks.isLet();
      if (a || this.tok.type === T._var || this.tok.type === T._const) {
        var s = this.parseVar(this.startNode(), true, a ? "let" : this.tok.value);
        return s.declarations.length === 1 && (this.tok.type === T._in || this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && this.tok.type !== T._in && (t.await = n), this.parseForIn(t, s)) : this.parseFor(t, s);
      }
      var o = this.parseExpression(true);
      return this.tok.type === T._in || this.isContextual("of") ? (this.options.ecmaVersion >= 9 && this.tok.type !== T._in && (t.await = n), this.parseForIn(t, this.toAssignable(o))) : this.parseFor(t, o);
    case T._function:
      return this.next(), this.parseFunction(t, true);
    case T._if:
      return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement(), t.alternate = this.eat(T._else) ? this.parseStatement() : null, this.finishNode(t, "IfStatement");
    case T._return:
      return this.next(), this.eat(T.semi) || this.canInsertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    case T._switch:
      var l = this.curIndent, c = this.curLineStart;
      this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.pushCx(), this.expect(T.braceL);
      for (var f; !this.closes(T.braceR, l, c, true); )
        if (this.tok.type === T._case || this.tok.type === T._default) {
          var p = this.tok.type === T._case;
          f && this.finishNode(f, "SwitchCase"), t.cases.push(f = this.startNode()), f.consequent = [], this.next(), p ? f.test = this.parseExpression() : f.test = null, this.expect(T.colon);
        } else
          f || (t.cases.push(f = this.startNode()), f.consequent = [], f.test = null), f.consequent.push(this.parseStatement());
      return f && this.finishNode(f, "SwitchCase"), this.popCx(), this.eat(T.braceR), this.finishNode(t, "SwitchStatement");
    case T._throw:
      return this.next(), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
    case T._try:
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.tok.type === T._catch) {
        var O = this.startNode();
        this.next(), this.eat(T.parenL) ? (O.param = this.toAssignable(this.parseExprAtom(), true), this.expect(T.parenR)) : O.param = null, O.body = this.parseBlock(), t.handler = this.finishNode(O, "CatchClause");
      }
      return t.finalizer = this.eat(T._finally) ? this.parseBlock() : null, !t.handler && !t.finalizer ? t.block : this.finishNode(t, "TryStatement");
    case T._var:
    case T._const:
      return this.parseVar(t, false, r || this.tok.value);
    case T._while:
      return this.next(), t.test = this.parseParenExpression(), t.body = this.parseStatement(), this.finishNode(t, "WhileStatement");
    case T._with:
      return this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement(), this.finishNode(t, "WithStatement");
    case T.braceL:
      return this.parseBlock();
    case T.semi:
      return this.next(), this.finishNode(t, "EmptyStatement");
    case T._class:
      return this.parseClass(true);
    case T._import:
      return this.options.ecmaVersion > 10 && this.lookAhead(1).type === T.parenL ? (t.expression = this.parseExpression(), this.semicolon(), this.finishNode(t, "ExpressionStatement")) : this.parseImport();
    case T._export:
      return this.parseExport();
    default:
      if (this.toks.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, true, true);
      var d2 = this.parseExpression();
      return ri(d2) ? (this.next(), this.tok.type === T.eof ? this.finishNode(t, "EmptyStatement") : this.parseStatement()) : e === T.name && d2.type === "Identifier" && this.eat(T.colon) ? (t.body = this.parseStatement(), t.label = d2, this.finishNode(t, "LabeledStatement")) : (t.expression = d2, this.semicolon(), this.finishNode(t, "ExpressionStatement"));
  }
};
yr.parseBlock = function() {
  var e = this.startNode();
  this.pushCx(), this.expect(T.braceL);
  var t = this.curIndent, r = this.curLineStart;
  for (e.body = []; !this.closes(T.braceR, t, r, true); )
    e.body.push(this.parseStatement());
  return this.popCx(), this.eat(T.braceR), this.finishNode(e, "BlockStatement");
};
yr.parseFor = function(e, t) {
  return e.init = t, e.test = e.update = null, this.eat(T.semi) && this.tok.type !== T.semi && (e.test = this.parseExpression()), this.eat(T.semi) && this.tok.type !== T.parenR && (e.update = this.parseExpression()), this.popCx(), this.expect(T.parenR), e.body = this.parseStatement(), this.finishNode(e, "ForStatement");
};
yr.parseForIn = function(e, t) {
  var r = this.tok.type === T._in ? "ForInStatement" : "ForOfStatement";
  return this.next(), e.left = t, e.right = this.parseExpression(), this.popCx(), this.expect(T.parenR), e.body = this.parseStatement(), this.finishNode(e, r);
};
yr.parseVar = function(e, t, r) {
  e.kind = r, this.next(), e.declarations = [];
  do {
    var i = this.startNode();
    i.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent(), i.init = this.eat(T.eq) ? this.parseMaybeAssign(t) : null, e.declarations.push(this.finishNode(i, "VariableDeclarator"));
  } while (this.eat(T.comma));
  if (!e.declarations.length) {
    var n = this.startNode();
    n.id = this.dummyIdent(), e.declarations.push(this.finishNode(n, "VariableDeclarator"));
  }
  return t || this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
yr.parseClass = function(e) {
  var t = this.startNode();
  this.next(), this.tok.type === T.name ? t.id = this.parseIdent() : e === true ? t.id = this.dummyIdent() : t.id = null, t.superClass = this.eat(T._extends) ? this.parseExpression() : null, t.body = this.startNode(), t.body.body = [], this.pushCx();
  var r = this.curIndent + 1, i = this.curLineStart;
  for (this.eat(T.braceL), this.curIndent + 1 < r && (r = this.curIndent, i = this.curLineStart); !this.closes(T.braceR, r, i); )
    if (!this.semicolon()) {
      var n = this.startNode(), a = void 0, s = void 0;
      if (this.options.ecmaVersion >= 6 && (n.static = false, a = this.eat(T.star)), this.parsePropertyName(n), ri(n.key)) {
        ri(this.parseMaybeAssign()) && this.next(), this.eat(T.comma);
        continue;
      }
      n.key.type === "Identifier" && !n.computed && n.key.name === "static" && this.tok.type !== T.parenL && this.tok.type !== T.braceL ? (n.static = true, a = this.eat(T.star), this.parsePropertyName(n)) : n.static = false, !n.computed && n.key.type === "Identifier" && n.key.name === "async" && this.tok.type !== T.parenL && !this.canInsertSemicolon() ? (s = true, a = this.options.ecmaVersion >= 9 && this.eat(T.star), this.parsePropertyName(n)) : s = false, this.options.ecmaVersion >= 5 && n.key.type === "Identifier" && !n.computed && (n.key.name === "get" || n.key.name === "set") && this.tok.type !== T.parenL && this.tok.type !== T.braceL ? (n.kind = n.key.name, this.parsePropertyName(n), n.value = this.parseMethod(false)) : (!n.computed && !n.static && !a && !s && (n.key.type === "Identifier" && n.key.name === "constructor" || n.key.type === "Literal" && n.key.value === "constructor") ? n.kind = "constructor" : n.kind = "method", n.value = this.parseMethod(a, s)), t.body.body.push(this.finishNode(n, "MethodDefinition"));
    }
  return this.popCx(), this.eat(T.braceR) || (this.last.end = this.tok.start, this.options.locations && (this.last.loc.end = this.tok.loc.start)), this.semicolon(), this.finishNode(t.body, "ClassBody"), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
};
yr.parseFunction = function(e, t, r) {
  var i = this.inAsync, n = this.inFunction;
  return this.initFunction(e), this.options.ecmaVersion >= 6 && (e.generator = this.eat(T.star)), this.options.ecmaVersion >= 8 && (e.async = !!r), this.tok.type === T.name ? e.id = this.parseIdent() : t === true && (e.id = this.dummyIdent()), this.inAsync = e.async, this.inFunction = true, e.params = this.parseFunctionParams(), e.body = this.parseBlock(), this.toks.adaptDirectivePrologue(e.body.body), this.inAsync = i, this.inFunction = n, this.finishNode(e, t ? "FunctionDeclaration" : "FunctionExpression");
};
yr.parseExport = function() {
  var e = this.startNode();
  if (this.next(), this.eat(T.star))
    return e.source = this.eatContextual("from") ? this.parseExprAtom() : this.dummyString(), this.finishNode(e, "ExportAllDeclaration");
  if (this.eat(T._default)) {
    var t;
    if (this.tok.type === T._function || (t = this.toks.isAsyncFunction())) {
      var r = this.startNode();
      this.next(), t && this.next(), e.declaration = this.parseFunction(r, "nullableID", t);
    } else
      this.tok.type === T._class ? e.declaration = this.parseClass("nullableID") : (e.declaration = this.parseMaybeAssign(), this.semicolon());
    return this.finishNode(e, "ExportDefaultDeclaration");
  }
  return this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction() ? (e.declaration = this.parseStatement(), e.specifiers = [], e.source = null) : (e.declaration = null, e.specifiers = this.parseExportSpecifierList(), e.source = this.eatContextual("from") ? this.parseExprAtom() : null, this.semicolon()), this.finishNode(e, "ExportNamedDeclaration");
};
yr.parseImport = function() {
  var e = this.startNode();
  if (this.next(), this.tok.type === T.string)
    e.specifiers = [], e.source = this.parseExprAtom();
  else {
    var t;
    this.tok.type === T.name && this.tok.value !== "from" && (t = this.startNode(), t.local = this.parseIdent(), this.finishNode(t, "ImportDefaultSpecifier"), this.eat(T.comma)), e.specifiers = this.parseImportSpecifiers(), e.source = this.eatContextual("from") && this.tok.type === T.string ? this.parseExprAtom() : this.dummyString(), t && e.specifiers.unshift(t);
  }
  return this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
yr.parseImportSpecifiers = function() {
  var e = [];
  if (this.tok.type === T.star) {
    var t = this.startNode();
    this.next(), t.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent(), e.push(this.finishNode(t, "ImportNamespaceSpecifier"));
  } else {
    var r = this.curIndent, i = this.curLineStart, n = this.nextLineStart;
    for (this.pushCx(), this.eat(T.braceL), this.curLineStart > n && (n = this.curLineStart); !this.closes(T.braceR, r + (this.curLineStart <= n ? 1 : 0), i); ) {
      var a = this.startNode();
      if (this.eat(T.star))
        a.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent(), this.finishNode(a, "ImportNamespaceSpecifier");
      else {
        if (this.isContextual("from") || (a.imported = this.parseIdent(), ri(a.imported)))
          break;
        a.local = this.eatContextual("as") ? this.parseIdent() : a.imported, this.finishNode(a, "ImportSpecifier");
      }
      e.push(a), this.eat(T.comma);
    }
    this.eat(T.braceR), this.popCx();
  }
  return e;
};
yr.parseExportSpecifierList = function() {
  var e = [], t = this.curIndent, r = this.curLineStart, i = this.nextLineStart;
  for (this.pushCx(), this.eat(T.braceL), this.curLineStart > i && (i = this.curLineStart); !this.closes(T.braceR, t + (this.curLineStart <= i ? 1 : 0), r) && !this.isContextual("from"); ) {
    var n = this.startNode();
    if (n.local = this.parseIdent(), ri(n.local))
      break;
    n.exported = this.eatContextual("as") ? this.parseIdent() : n.local, this.finishNode(n, "ExportSpecifier"), e.push(n), this.eat(T.comma);
  }
  return this.eat(T.braceR), this.popCx(), e;
};
var nt = Ke.prototype;
nt.checkLVal = function(e) {
  if (!e)
    return e;
  switch (e.type) {
    case "Identifier":
    case "MemberExpression":
      return e;
    case "ParenthesizedExpression":
      return e.expression = this.checkLVal(e.expression), e;
    default:
      return this.dummyIdent();
  }
};
nt.parseExpression = function(e) {
  var t = this.storeCurrentPos(), r = this.parseMaybeAssign(e);
  if (this.tok.type === T.comma) {
    var i = this.startNodeAt(t);
    for (i.expressions = [r]; this.eat(T.comma); )
      i.expressions.push(this.parseMaybeAssign(e));
    return this.finishNode(i, "SequenceExpression");
  }
  return r;
};
nt.parseParenExpression = function() {
  this.pushCx(), this.expect(T.parenL);
  var e = this.parseExpression();
  return this.popCx(), this.expect(T.parenR), e;
};
nt.parseMaybeAssign = function(e) {
  if (this.toks.isContextual("yield")) {
    var t = this.startNode();
    return this.next(), this.semicolon() || this.canInsertSemicolon() || this.tok.type !== T.star && !this.tok.type.startsExpr ? (t.delegate = false, t.argument = null) : (t.delegate = this.eat(T.star), t.argument = this.parseMaybeAssign()), this.finishNode(t, "YieldExpression");
  }
  var r = this.storeCurrentPos(), i = this.parseMaybeConditional(e);
  if (this.tok.type.isAssign) {
    var n = this.startNodeAt(r);
    return n.operator = this.tok.value, n.left = this.tok.type === T.eq ? this.toAssignable(i) : this.checkLVal(i), this.next(), n.right = this.parseMaybeAssign(e), this.finishNode(n, "AssignmentExpression");
  }
  return i;
};
nt.parseMaybeConditional = function(e) {
  var t = this.storeCurrentPos(), r = this.parseExprOps(e);
  if (this.eat(T.question)) {
    var i = this.startNodeAt(t);
    return i.test = r, i.consequent = this.parseMaybeAssign(), i.alternate = this.expect(T.colon) ? this.parseMaybeAssign(e) : this.dummyIdent(), this.finishNode(i, "ConditionalExpression");
  }
  return r;
};
nt.parseExprOps = function(e) {
  var t = this.storeCurrentPos(), r = this.curIndent, i = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(false), t, -1, e, r, i);
};
nt.parseExprOp = function(e, t, r, i, n, a) {
  if (this.curLineStart !== a && this.curIndent < n && this.tokenStartsLine())
    return e;
  var s = this.tok.type.binop;
  if (s != null && (!i || this.tok.type !== T._in) && s > r) {
    var o = this.startNodeAt(t);
    if (o.left = e, o.operator = this.tok.value, this.next(), this.curLineStart !== a && this.curIndent < n && this.tokenStartsLine())
      o.right = this.dummyIdent();
    else {
      var l = this.storeCurrentPos();
      o.right = this.parseExprOp(this.parseMaybeUnary(false), l, s, i, n, a);
    }
    return this.finishNode(o, /&&|\|\|/.test(o.operator) ? "LogicalExpression" : "BinaryExpression"), this.parseExprOp(o, t, r, i, n, a);
  }
  return e;
};
nt.parseMaybeUnary = function(e) {
  var t = this.storeCurrentPos(), r;
  if (this.options.ecmaVersion >= 8 && this.toks.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
    r = this.parseAwait(), e = true;
  else if (this.tok.type.prefix) {
    var i = this.startNode(), n = this.tok.type === T.incDec;
    n || (e = true), i.operator = this.tok.value, i.prefix = true, this.next(), i.argument = this.parseMaybeUnary(true), n && (i.argument = this.checkLVal(i.argument)), r = this.finishNode(i, n ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === T.ellipsis) {
    var a = this.startNode();
    this.next(), a.argument = this.parseMaybeUnary(e), r = this.finishNode(a, "SpreadElement");
  } else
    for (r = this.parseExprSubscripts(); this.tok.type.postfix && !this.canInsertSemicolon(); ) {
      var s = this.startNodeAt(t);
      s.operator = this.tok.value, s.prefix = false, s.argument = this.checkLVal(r), this.next(), r = this.finishNode(s, "UpdateExpression");
    }
  if (!e && this.eat(T.starstar)) {
    var o = this.startNodeAt(t);
    return o.operator = "**", o.left = r, o.right = this.parseMaybeUnary(false), this.finishNode(o, "BinaryExpression");
  }
  return r;
};
nt.parseExprSubscripts = function() {
  var e = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), e, false, this.curIndent, this.curLineStart);
};
nt.parseSubscripts = function(e, t, r, i, n) {
  for (; ; ) {
    if (this.curLineStart !== n && this.curIndent <= i && this.tokenStartsLine())
      if (this.tok.type === T.dot && this.curIndent === i)
        --i;
      else
        return e;
    var a = e.type === "Identifier" && e.name === "async" && !this.canInsertSemicolon();
    if (this.eat(T.dot)) {
      var s = this.startNodeAt(t);
      s.object = e, this.curLineStart !== n && this.curIndent <= i && this.tokenStartsLine() ? s.property = this.dummyIdent() : s.property = this.parsePropertyAccessor() || this.dummyIdent(), s.computed = false, e = this.finishNode(s, "MemberExpression");
    } else if (this.tok.type === T.bracketL) {
      this.pushCx(), this.next();
      var o = this.startNodeAt(t);
      o.object = e, o.property = this.parseExpression(), o.computed = true, this.popCx(), this.expect(T.bracketR), e = this.finishNode(o, "MemberExpression");
    } else if (!r && this.tok.type === T.parenL) {
      var l = this.parseExprList(T.parenR);
      if (a && this.eat(T.arrow))
        return this.parseArrowExpression(this.startNodeAt(t), l, true);
      var c = this.startNodeAt(t);
      c.callee = e, c.arguments = l, e = this.finishNode(c, "CallExpression");
    } else if (this.tok.type === T.backQuote) {
      var f = this.startNodeAt(t);
      f.tag = e, f.quasi = this.parseTemplate(), e = this.finishNode(f, "TaggedTemplateExpression");
    } else
      return e;
  }
};
nt.parseExprAtom = function() {
  var e;
  switch (this.tok.type) {
    case T._this:
    case T._super:
      var t = this.tok.type === T._this ? "ThisExpression" : "Super";
      return e = this.startNode(), this.next(), this.finishNode(e, t);
    case T.name:
      var r = this.storeCurrentPos(), i = this.parseIdent(), n = false;
      if (i.name === "async" && !this.canInsertSemicolon()) {
        if (this.eat(T._function))
          return this.parseFunction(this.startNodeAt(r), false, true);
        this.tok.type === T.name && (i = this.parseIdent(), n = true);
      }
      return this.eat(T.arrow) ? this.parseArrowExpression(this.startNodeAt(r), [i], n) : i;
    case T.regexp:
      e = this.startNode();
      var a = this.tok.value;
      return e.regex = { pattern: a.pattern, flags: a.flags }, e.value = a.value, e.raw = this.input.slice(this.tok.start, this.tok.end), this.next(), this.finishNode(e, "Literal");
    case T.num:
    case T.string:
      return e = this.startNode(), e.value = this.tok.value, e.raw = this.input.slice(this.tok.start, this.tok.end), this.tok.type === T.num && e.raw.charCodeAt(e.raw.length - 1) === 110 && (e.bigint = e.raw.slice(0, -1)), this.next(), this.finishNode(e, "Literal");
    case T._null:
    case T._true:
    case T._false:
      return e = this.startNode(), e.value = this.tok.type === T._null ? null : this.tok.type === T._true, e.raw = this.tok.type.keyword, this.next(), this.finishNode(e, "Literal");
    case T.parenL:
      var s = this.storeCurrentPos();
      this.next();
      var o = this.parseExpression();
      if (this.expect(T.parenR), this.eat(T.arrow)) {
        var l = o.expressions || [o];
        return l.length && ri(l[l.length - 1]) && l.pop(), this.parseArrowExpression(this.startNodeAt(s), l);
      }
      if (this.options.preserveParens) {
        var c = this.startNodeAt(s);
        c.expression = o, o = this.finishNode(c, "ParenthesizedExpression");
      }
      return o;
    case T.bracketL:
      return e = this.startNode(), e.elements = this.parseExprList(T.bracketR, true), this.finishNode(e, "ArrayExpression");
    case T.braceL:
      return this.parseObj();
    case T._class:
      return this.parseClass(false);
    case T._function:
      return e = this.startNode(), this.next(), this.parseFunction(e, false);
    case T._new:
      return this.parseNew();
    case T.backQuote:
      return this.parseTemplate();
    case T._import:
      return this.options.ecmaVersion > 10 ? this.parseDynamicImport() : this.dummyIdent();
    default:
      return this.dummyIdent();
  }
};
nt.parseDynamicImport = function() {
  var e = this.startNode();
  return this.next(), this.finishNode(e, "Import");
};
nt.parseNew = function() {
  var e = this.startNode(), t = this.curIndent, r = this.curLineStart, i = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(T.dot))
    return e.meta = i, e.property = this.parseIdent(true), this.finishNode(e, "MetaProperty");
  var n = this.storeCurrentPos();
  return e.callee = this.parseSubscripts(this.parseExprAtom(), n, true, t, r), this.tok.type === T.parenL ? e.arguments = this.parseExprList(T.parenR) : e.arguments = [], this.finishNode(e, "NewExpression");
};
nt.parseTemplateElement = function() {
  var e = this.startNode();
  return this.tok.type === T.invalidTemplate ? e.value = {
    raw: this.tok.value,
    cooked: null
  } : e.value = {
    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, `
`),
    cooked: this.tok.value
  }, this.next(), e.tail = this.tok.type === T.backQuote, this.finishNode(e, "TemplateElement");
};
nt.parseTemplate = function() {
  var e = this.startNode();
  this.next(), e.expressions = [];
  var t = this.parseTemplateElement();
  for (e.quasis = [t]; !t.tail; )
    this.next(), e.expressions.push(this.parseExpression()), this.expect(T.braceR) ? t = this.parseTemplateElement() : (t = this.startNode(), t.value = { cooked: "", raw: "" }, t.tail = true, this.finishNode(t, "TemplateElement")), e.quasis.push(t);
  return this.expect(T.backQuote), this.finishNode(e, "TemplateLiteral");
};
nt.parseObj = function() {
  var e = this.startNode();
  e.properties = [], this.pushCx();
  var t = this.curIndent + 1, r = this.curLineStart;
  for (this.eat(T.braceL), this.curIndent + 1 < t && (t = this.curIndent, r = this.curLineStart); !this.closes(T.braceR, t, r); ) {
    var i = this.startNode(), n = void 0, a = void 0, s = void 0;
    if (this.options.ecmaVersion >= 9 && this.eat(T.ellipsis)) {
      i.argument = this.parseMaybeAssign(), e.properties.push(this.finishNode(i, "SpreadElement")), this.eat(T.comma);
      continue;
    }
    if (this.options.ecmaVersion >= 6 && (s = this.storeCurrentPos(), i.method = false, i.shorthand = false, n = this.eat(T.star)), this.parsePropertyName(i), this.toks.isAsyncProp(i) ? (a = true, n = this.options.ecmaVersion >= 9 && this.eat(T.star), this.parsePropertyName(i)) : a = false, ri(i.key)) {
      ri(this.parseMaybeAssign()) && this.next(), this.eat(T.comma);
      continue;
    }
    if (this.eat(T.colon))
      i.kind = "init", i.value = this.parseMaybeAssign();
    else if (this.options.ecmaVersion >= 6 && (this.tok.type === T.parenL || this.tok.type === T.braceL))
      i.kind = "init", i.method = true, i.value = this.parseMethod(n, a);
    else if (this.options.ecmaVersion >= 5 && i.key.type === "Identifier" && !i.computed && (i.key.name === "get" || i.key.name === "set") && this.tok.type !== T.comma && this.tok.type !== T.braceR && this.tok.type !== T.eq)
      i.kind = i.key.name, this.parsePropertyName(i), i.value = this.parseMethod(false);
    else {
      if (i.kind = "init", this.options.ecmaVersion >= 6)
        if (this.eat(T.eq)) {
          var o = this.startNodeAt(s);
          o.operator = "=", o.left = i.key, o.right = this.parseMaybeAssign(), i.value = this.finishNode(o, "AssignmentExpression");
        } else
          i.value = i.key;
      else
        i.value = this.dummyIdent();
      i.shorthand = true;
    }
    e.properties.push(this.finishNode(i, "Property")), this.eat(T.comma);
  }
  return this.popCx(), this.eat(T.braceR) || (this.last.end = this.tok.start, this.options.locations && (this.last.loc.end = this.tok.loc.start)), this.finishNode(e, "ObjectExpression");
};
nt.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6)
    if (this.eat(T.bracketL)) {
      e.computed = true, e.key = this.parseExpression(), this.expect(T.bracketR);
      return;
    } else
      e.computed = false;
  var t = this.tok.type === T.num || this.tok.type === T.string ? this.parseExprAtom() : this.parseIdent();
  e.key = t || this.dummyIdent();
};
nt.parsePropertyAccessor = function() {
  if (this.tok.type === T.name || this.tok.type.keyword)
    return this.parseIdent();
};
nt.parseIdent = function() {
  var e = this.tok.type === T.name ? this.tok.value : this.tok.type.keyword;
  if (!e)
    return this.dummyIdent();
  var t = this.startNode();
  return this.next(), t.name = e, this.finishNode(t, "Identifier");
};
nt.initFunction = function(e) {
  e.id = null, e.params = [], this.options.ecmaVersion >= 6 && (e.generator = false, e.expression = false), this.options.ecmaVersion >= 8 && (e.async = false);
};
nt.toAssignable = function(e, t) {
  if (!(!e || e.type === "Identifier" || e.type === "MemberExpression" && !t))
    if (e.type === "ParenthesizedExpression")
      this.toAssignable(e.expression, t);
    else {
      if (this.options.ecmaVersion < 6)
        return this.dummyIdent();
      if (e.type === "ObjectExpression") {
        e.type = "ObjectPattern";
        for (var r = 0, i = e.properties; r < i.length; r += 1) {
          var n = i[r];
          this.toAssignable(n, t);
        }
      } else if (e.type === "ArrayExpression")
        e.type = "ArrayPattern", this.toAssignableList(e.elements, t);
      else if (e.type === "Property")
        this.toAssignable(e.value, t);
      else if (e.type === "SpreadElement")
        e.type = "RestElement", this.toAssignable(e.argument, t);
      else if (e.type === "AssignmentExpression")
        e.type = "AssignmentPattern", delete e.operator;
      else
        return this.dummyIdent();
    }
  return e;
};
nt.toAssignableList = function(e, t) {
  for (var r = 0, i = e; r < i.length; r += 1) {
    var n = i[r];
    this.toAssignable(n, t);
  }
  return e;
};
nt.parseFunctionParams = function(e) {
  return e = this.parseExprList(T.parenR), this.toAssignableList(e, true);
};
nt.parseMethod = function(e, t) {
  var r = this.startNode(), i = this.inAsync, n = this.inFunction;
  return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = !!e), this.options.ecmaVersion >= 8 && (r.async = !!t), this.inAsync = r.async, this.inFunction = true, r.params = this.parseFunctionParams(), r.body = this.parseBlock(), this.toks.adaptDirectivePrologue(r.body.body), this.inAsync = i, this.inFunction = n, this.finishNode(r, "FunctionExpression");
};
nt.parseArrowExpression = function(e, t, r) {
  var i = this.inAsync, n = this.inFunction;
  return this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.inAsync = e.async, this.inFunction = true, e.params = this.toAssignableList(t, true), e.expression = this.tok.type !== T.braceL, e.expression ? e.body = this.parseMaybeAssign() : (e.body = this.parseBlock(), this.toks.adaptDirectivePrologue(e.body.body)), this.inAsync = i, this.inFunction = n, this.finishNode(e, "ArrowFunctionExpression");
};
nt.parseExprList = function(e, t) {
  this.pushCx();
  var r = this.curIndent, i = this.curLineStart, n = [];
  for (this.next(); !this.closes(e, r + 1, i); ) {
    if (this.eat(T.comma)) {
      n.push(t ? null : this.dummyIdent());
      continue;
    }
    var a = this.parseMaybeAssign();
    if (ri(a)) {
      if (this.closes(e, r, i))
        break;
      this.next();
    } else
      n.push(a);
    this.eat(T.comma);
  }
  return this.popCx(), this.eat(e) || (this.last.end = this.tok.start, this.options.locations && (this.last.loc.end = this.tok.loc.start)), n;
};
nt.parseAwait = function() {
  var e = this.startNode();
  return this.next(), e.argument = this.parseMaybeUnary(), this.finishNode(e, "AwaitExpression");
};
Ds.tabSize = 4;
function lP(e, t) {
  return Ke.parse(e, t);
}
var uP = Object.freeze(Object.defineProperty({
  __proto__: null,
  LooseParser: Ke,
  parse: lP
}, Symbol.toStringTag, { value: "Module" }));
var cP = a5(uP);
function fP(e, t, r, i, n) {
  r || (r = le), function a(s, o, l) {
    var c = l || s.type, f = t[c];
    r[c](s, o, a), f && f(s, o);
  }(e, i, n);
}
function hP(e, t, r, i) {
  var n = [];
  r || (r = le), function a(s, o, l) {
    var c = l || s.type, f = t[c], p = s !== n[n.length - 1];
    p && n.push(s), r[c](s, o, a), f && f(s, o || n, n), p && n.pop();
  }(e, i);
}
function pP(e, t, r, i, n) {
  var a = r ? Rd(r, i || void 0) : i;
  (function s(o, l, c) {
    a[c || o.type](o, l, s);
  })(e, t, n);
}
function uo(e) {
  return typeof e == "string" ? function(t) {
    return t === e;
  } : e || function() {
    return true;
  };
}
var Xi = function(t, r) {
  this.node = t, this.state = r;
};
function OP(e, t, r, i, n) {
  r || (r = le), function a(s, o, l) {
    var c = l || s.type;
    r[c](s, o, a), l || t(s, o, c);
  }(e, i, n);
}
function EP(e, t, r, i) {
  r || (r = le);
  var n = [];
  (function a(s, o, l) {
    var c = l || s.type, f = s !== n[n.length - 1];
    f && n.push(s), r[c](s, o, a), l || t(s, o || n, n, c), f && n.pop();
  })(e, i);
}
function dP(e, t, r, i, n, a) {
  n || (n = le), i = uo(i);
  try {
    (function s(o, l, c) {
      var f = c || o.type;
      if ((t == null || o.start <= t) && (r == null || o.end >= r) && n[f](o, l, s), (t == null || o.start === t) && (r == null || o.end === r) && i(f, o))
        throw new Xi(o, l);
    })(e, a);
  } catch (s) {
    if (s instanceof Xi)
      return s;
    throw s;
  }
}
function TP(e, t, r, i, n) {
  r = uo(r), i || (i = le);
  try {
    (function a(s, o, l) {
      var c = l || s.type;
      if (!(s.start > t || s.end < t) && (i[c](s, o, a), r(c, s)))
        throw new Xi(s, o);
    })(e, n);
  } catch (a) {
    if (a instanceof Xi)
      return a;
    throw a;
  }
}
function SP(e, t, r, i, n) {
  r = uo(r), i || (i = le);
  try {
    (function a(s, o, l) {
      if (!(s.end < t)) {
        var c = l || s.type;
        if (s.start >= t && r(c, s))
          throw new Xi(s, o);
        i[c](s, o, a);
      }
    })(e, n);
  } catch (a) {
    if (a instanceof Xi)
      return a;
    throw a;
  }
}
function mP(e, t, r, i, n) {
  r = uo(r), i || (i = le);
  var a;
  return function s(o, l, c) {
    if (!(o.start > t)) {
      var f = c || o.type;
      o.end <= t && (!a || a.node.end < o.end) && r(f, o) && (a = new Xi(o, l)), i[f](o, l, s);
    }
  }(e, n), a;
}
var RP = Object.create || function(e) {
  function t() {
  }
  return t.prototype = e, new t();
};
function Rd(e, t) {
  var r = RP(t || le);
  for (var i in e)
    r[i] = e[i];
  return r;
}
function Ac(e, t, r) {
  r(e, t);
}
function zi(e, t, r) {
}
var le = {};
le.Program = le.BlockStatement = function(e, t, r) {
  for (var i = 0, n = e.body; i < n.length; i += 1) {
    var a = n[i];
    r(a, t, "Statement");
  }
};
le.Statement = Ac;
le.EmptyStatement = zi;
le.ExpressionStatement = le.ParenthesizedExpression = function(e, t, r) {
  return r(e.expression, t, "Expression");
};
le.IfStatement = function(e, t, r) {
  r(e.test, t, "Expression"), r(e.consequent, t, "Statement"), e.alternate && r(e.alternate, t, "Statement");
};
le.LabeledStatement = function(e, t, r) {
  return r(e.body, t, "Statement");
};
le.BreakStatement = le.ContinueStatement = zi;
le.WithStatement = function(e, t, r) {
  r(e.object, t, "Expression"), r(e.body, t, "Statement");
};
le.SwitchStatement = function(e, t, r) {
  r(e.discriminant, t, "Expression");
  for (var i = 0, n = e.cases; i < n.length; i += 1) {
    var a = n[i];
    a.test && r(a.test, t, "Expression");
    for (var s = 0, o = a.consequent; s < o.length; s += 1) {
      var l = o[s];
      r(l, t, "Statement");
    }
  }
};
le.SwitchCase = function(e, t, r) {
  e.test && r(e.test, t, "Expression");
  for (var i = 0, n = e.consequent; i < n.length; i += 1) {
    var a = n[i];
    r(a, t, "Statement");
  }
};
le.ReturnStatement = le.YieldExpression = le.AwaitExpression = function(e, t, r) {
  e.argument && r(e.argument, t, "Expression");
};
le.ThrowStatement = le.SpreadElement = function(e, t, r) {
  return r(e.argument, t, "Expression");
};
le.TryStatement = function(e, t, r) {
  r(e.block, t, "Statement"), e.handler && r(e.handler, t), e.finalizer && r(e.finalizer, t, "Statement");
};
le.CatchClause = function(e, t, r) {
  e.param && r(e.param, t, "Pattern"), r(e.body, t, "Statement");
};
le.WhileStatement = le.DoWhileStatement = function(e, t, r) {
  r(e.test, t, "Expression"), r(e.body, t, "Statement");
};
le.ForStatement = function(e, t, r) {
  e.init && r(e.init, t, "ForInit"), e.test && r(e.test, t, "Expression"), e.update && r(e.update, t, "Expression"), r(e.body, t, "Statement");
};
le.ForInStatement = le.ForOfStatement = function(e, t, r) {
  r(e.left, t, "ForInit"), r(e.right, t, "Expression"), r(e.body, t, "Statement");
};
le.ForInit = function(e, t, r) {
  e.type === "VariableDeclaration" ? r(e, t) : r(e, t, "Expression");
};
le.DebuggerStatement = zi;
le.FunctionDeclaration = function(e, t, r) {
  return r(e, t, "Function");
};
le.VariableDeclaration = function(e, t, r) {
  for (var i = 0, n = e.declarations; i < n.length; i += 1) {
    var a = n[i];
    r(a, t);
  }
};
le.VariableDeclarator = function(e, t, r) {
  r(e.id, t, "Pattern"), e.init && r(e.init, t, "Expression");
};
le.Function = function(e, t, r) {
  e.id && r(e.id, t, "Pattern");
  for (var i = 0, n = e.params; i < n.length; i += 1) {
    var a = n[i];
    r(a, t, "Pattern");
  }
  r(e.body, t, e.expression ? "Expression" : "Statement");
};
le.Pattern = function(e, t, r) {
  e.type === "Identifier" ? r(e, t, "VariablePattern") : e.type === "MemberExpression" ? r(e, t, "MemberPattern") : r(e, t);
};
le.VariablePattern = zi;
le.MemberPattern = Ac;
le.RestElement = function(e, t, r) {
  return r(e.argument, t, "Pattern");
};
le.ArrayPattern = function(e, t, r) {
  for (var i = 0, n = e.elements; i < n.length; i += 1) {
    var a = n[i];
    a && r(a, t, "Pattern");
  }
};
le.ObjectPattern = function(e, t, r) {
  for (var i = 0, n = e.properties; i < n.length; i += 1) {
    var a = n[i];
    a.type === "Property" ? (a.computed && r(a.key, t, "Expression"), r(a.value, t, "Pattern")) : a.type === "RestElement" && r(a.argument, t, "Pattern");
  }
};
le.Expression = Ac;
le.ThisExpression = le.Super = le.MetaProperty = zi;
le.ArrayExpression = function(e, t, r) {
  for (var i = 0, n = e.elements; i < n.length; i += 1) {
    var a = n[i];
    a && r(a, t, "Expression");
  }
};
le.ObjectExpression = function(e, t, r) {
  for (var i = 0, n = e.properties; i < n.length; i += 1) {
    var a = n[i];
    r(a, t);
  }
};
le.FunctionExpression = le.ArrowFunctionExpression = le.FunctionDeclaration;
le.SequenceExpression = function(e, t, r) {
  for (var i = 0, n = e.expressions; i < n.length; i += 1) {
    var a = n[i];
    r(a, t, "Expression");
  }
};
le.TemplateLiteral = function(e, t, r) {
  for (var i = 0, n = e.quasis; i < n.length; i += 1) {
    var a = n[i];
    r(a, t);
  }
  for (var s = 0, o = e.expressions; s < o.length; s += 1) {
    var l = o[s];
    r(l, t, "Expression");
  }
};
le.TemplateElement = zi;
le.UnaryExpression = le.UpdateExpression = function(e, t, r) {
  r(e.argument, t, "Expression");
};
le.BinaryExpression = le.LogicalExpression = function(e, t, r) {
  r(e.left, t, "Expression"), r(e.right, t, "Expression");
};
le.AssignmentExpression = le.AssignmentPattern = function(e, t, r) {
  r(e.left, t, "Pattern"), r(e.right, t, "Expression");
};
le.ConditionalExpression = function(e, t, r) {
  r(e.test, t, "Expression"), r(e.consequent, t, "Expression"), r(e.alternate, t, "Expression");
};
le.NewExpression = le.CallExpression = function(e, t, r) {
  if (r(e.callee, t, "Expression"), e.arguments)
    for (var i = 0, n = e.arguments; i < n.length; i += 1) {
      var a = n[i];
      r(a, t, "Expression");
    }
};
le.MemberExpression = function(e, t, r) {
  r(e.object, t, "Expression"), e.computed && r(e.property, t, "Expression");
};
le.ExportNamedDeclaration = le.ExportDefaultDeclaration = function(e, t, r) {
  e.declaration && r(e.declaration, t, e.type === "ExportNamedDeclaration" || e.declaration.id ? "Statement" : "Expression"), e.source && r(e.source, t, "Expression");
};
le.ExportAllDeclaration = function(e, t, r) {
  r(e.source, t, "Expression");
};
le.ImportDeclaration = function(e, t, r) {
  for (var i = 0, n = e.specifiers; i < n.length; i += 1) {
    var a = n[i];
    r(a, t);
  }
  r(e.source, t, "Expression");
};
le.ImportSpecifier = le.ImportDefaultSpecifier = le.ImportNamespaceSpecifier = le.Identifier = le.Literal = le.Import = zi;
le.TaggedTemplateExpression = function(e, t, r) {
  r(e.tag, t, "Expression"), r(e.quasi, t, "Expression");
};
le.ClassDeclaration = le.ClassExpression = function(e, t, r) {
  return r(e, t, "Class");
};
le.Class = function(e, t, r) {
  e.id && r(e.id, t, "Pattern"), e.superClass && r(e.superClass, t, "Expression"), r(e.body, t);
};
le.ClassBody = function(e, t, r) {
  for (var i = 0, n = e.body; i < n.length; i += 1) {
    var a = n[i];
    r(a, t);
  }
};
le.MethodDefinition = le.Property = function(e, t, r) {
  e.computed && r(e.key, t, "Expression"), r(e.value, t, "Expression");
};
var AP = Object.freeze(Object.defineProperty({
  __proto__: null,
  ancestor: hP,
  base: le,
  findNodeAfter: SP,
  findNodeAround: TP,
  findNodeAt: dP,
  findNodeBefore: mP,
  full: OP,
  fullAncestor: EP,
  make: Rd,
  recursive: pP,
  simple: fP
}, Symbol.toStringTag, { value: "Module" }));
var Ad = a5(AP);
var $a = { exports: {} };
var Sh;
function gP() {
  return Sh || (Sh = 1, function(e, t) {
    (function(r) {
      return t.init = r;
    })(function(r, i) {
      function n(R, A) {
        return Object.prototype.hasOwnProperty.call(R, A);
      }
      var a = r.TypeParser = function(R, A, y2, C) {
        this.pos = A || 0, this.spec = R, this.base = y2, this.forceNew = C;
      };
      function s(R, A, y2) {
        return R.call ? R(A, y2) : R;
      }
      function o(R, A) {
        if (A == "!ret") {
          if (R.retval)
            return R.retval;
          var y2 = new i.AVal();
          return R.propagate(new i.IsCallee(i.ANull, [], null, y2)), y2;
        } else
          return R.getProp(A);
      }
      function l(R, A, y2, C) {
        return function(j, w) {
          for (var J = [], te = 0; te < A.length; te++)
            J.push(s(A[te], j, w));
          return new i.Fn(R, i.ANull, J, s(y2, j, w), C);
        };
      }
      function c(R) {
        return function(A, y2) {
          for (var C = new i.AVal(), j = 0; j < R.length; j++)
            s(R[j], A, y2).propagate(C);
          return C.maxWeight = 1e5, C;
        };
      }
      function f(R) {
        return function(A, y2) {
          return new i.Arr(R(A, y2));
        };
      }
      function p(R) {
        return function(A, y2) {
          return new i.Arr(R.map(function(C) {
            return s(C, A, y2);
          }));
        };
      }
      function O(R, A) {
        return function(y2, C) {
          var j = new i.Obj();
          return R.forEach(function(w, J) {
            j.defProp(w).addType(s(A[J], y2, C));
          }), j;
        };
      }
      a.prototype = {
        eat: function(R) {
          if (R.length == 1 ? this.spec.charAt(this.pos) == R : this.spec.indexOf(R, this.pos) == this.pos)
            return this.pos += R.length, true;
        },
        word: function(C) {
          for (var A = "", y2, C = C || /[\w$]/; (y2 = this.spec.charAt(this.pos)) && C.test(y2); )
            A += y2, ++this.pos;
          return A;
        },
        error: function() {
          throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
        },
        parseFnType: function(R, A, y2, C) {
          var j = [], w = [], J = false;
          if (!this.eat(")"))
            for (var te = 0; ; ++te) {
              var se = this.spec.indexOf(": ", this.pos), ge;
              se != -1 && (ge = this.spec.slice(this.pos, se), /^(\.\.\.)?[$\w?]+$/.test(ge) ? this.pos = se + 2 : ge = null), w.push(ge);
              var fe = this.parseType(R);
              if (fe.call && (J = true), j.push(fe), !this.eat(", ")) {
                this.eat(")") || this.error();
                break;
              }
            }
          var et, yt, De, Ce;
          if (this.eat(" -> ")) {
            var Ee = this.pos;
            et = this.parseType(true), et.call && !J && (yt = et, et = i.ANull, De = Ee);
          } else
            et = i.ANull;
          return J ? l(A, j, et, C) : (y2 && (Ce = this.base) ? i.Fn.call(this.base, A, i.ANull, j, w, et, C) : Ce = new i.Fn(A, i.ANull, j, w, et, C), yt && (Ce.computeRet = yt), De != null && (Ce.computeRetSource = this.spec.slice(De, this.pos)), Ce);
        },
        parseType: function(R, A, y2) {
          var C = this.parseTypeMaybeProp(R, A, y2);
          if (!this.eat("|"))
            return C;
          for (var j = [C], w = C.call; ; ) {
            var J = this.parseTypeMaybeProp(R, A, y2);
            if (j.push(J), J.call && (w = true), !this.eat("|"))
              break;
          }
          if (w)
            return c(j);
          for (var te = new i.AVal(), se = 0; se < j.length; se++)
            j[se].propagate(te);
          return te.maxWeight = 1e5, te;
        },
        parseTypeMaybeProp: function(R, A, y2) {
          for (var C = this.parseTypeInner(R, A, y2); R && this.eat("."); )
            C = this.extendWithProp(C);
          return C;
        },
        extendWithProp: function(R) {
          var A = this.word(/[\w<>$!:]/) || this.error();
          return R.apply ? function(y2, C) {
            return o(R(y2, C), A);
          } : o(R, A);
        },
        parseTypeInner: function(R, A, y2) {
          var C;
          if (this.eat("fn(") || (C = this.eat("fn*(")))
            return this.parseFnType(R, A, y2, C);
          if (this.eat("[")) {
            for (var j = this.parseType(R), w, J = j.call; this.eat(", "); ) {
              w || (w = [j]);
              var te = this.parseType(R);
              w.push(te), J = J || te.call;
            }
            return this.eat("]") || this.error(), J ? w ? p(w) : f(j) : y2 && this.base ? (i.Arr.call(this.base, w || j), this.base) : new i.Arr(w || j);
          } else if (this.eat("{")) {
            var w = [], se = [], J = false;
            if (!this.eat("}"))
              for (var ge = 0; ; ++ge) {
                var fe = this.spec.indexOf(": ", this.pos), et;
                fe != -1 && (et = this.spec.slice(this.pos, fe), /^[$\w?]+$/.test(et) ? this.pos = fe + 2 : et = null);
                var yt = this.parseType(R);
                if (yt.call && (J = true), se.push(et), w.push(yt), !this.eat(", ")) {
                  this.eat("}") || this.error();
                  break;
                }
              }
            if (J)
              return O(se, w);
            var De = new i.Obj();
            return se.forEach(function(It2, tt) {
              De.defProp(It2).addType(w[tt]);
            }), De;
          } else if (this.eat("+")) {
            var Ce = this.word(/[\w$<>\.:!]/), Ee = i.cx().localDefs[Ce + ".prototype"];
            if (!Ee) {
              var Ee = V(Ce);
              if (!(Ee instanceof i.Obj))
                return Ee;
              var ut = _2(Ee, ["prototype"]);
              ut && (ut = ut.getObjType()) && (Ee = ut);
            }
            if (R && this.eat("["))
              return this.parsePoly(Ee);
            if (y2 && this.base) {
              this.base.proto = Ee;
              var A = Ee.hasCtor && Ee.hasCtor.name || Ee.name;
              return A && (this.base.name = A), this.base;
            }
            return y2 && this.forceNew ? new i.Obj(Ee) : i.getInstance(Ee);
          } else if (this.eat(":")) {
            var A = this.word(/[\w$\.]/);
            return i.getSymbol(A);
          } else if (R && this.eat("!")) {
            var Je = this.word(/\d/);
            if (Je)
              return Je = Number(Je), function(ot, $t) {
                return $t[Je] || i.ANull;
              };
            if (this.eat("this"))
              return function(ot) {
                return ot;
              };
            if (this.eat("custom:")) {
              var q = this.word(/[\w$]/);
              return H[q] || function() {
                return i.ANull;
              };
            } else
              return this.fromWord("!" + this.word(/[\w$<>\.!:]/));
          } else
            return this.eat("?") ? i.ANull : this.fromWord(this.word(/[\w$<>\.!:`]/));
        },
        fromWord: function(R) {
          var A = i.cx();
          switch (R) {
            case "number":
              return A.num;
            case "string":
              return A.str;
            case "bool":
              return A.bool;
            case "<top>":
              return A.topScope;
          }
          return A.localDefs && R in A.localDefs ? A.localDefs[R] : V(R);
        },
        parsePoly: function(R) {
          var A = "<i>", y2;
          (y2 = this.spec.slice(this.pos).match(/^\s*([\w$:]+)\s*=\s*/)) && (A = y2[1], this.pos += y2[0].length);
          var C = this.parseType(true);
          if (this.eat("]") || this.error(), C.call)
            return function(w, J) {
              var te = new i.Obj(R);
              return C(w, J).propagate(te.defProp(A)), te;
            };
          var j = new i.Obj(R);
          return C.propagate(j.defProp(A)), j;
        }
      };
      function d2(R) {
        if (R instanceof i.Fn && R.args)
          for (var A = 0; A < R.args.length; ++A) {
            var y2 = R.args[A];
            y2 instanceof i.Fn && y2.args && y2.args.length && g(R, A);
          }
      }
      function g(R, A) {
        D(R, function(y2, C) {
          C[A] && C[A].propagate(
            new i.IsCallee(i.cx().topScope, R.args[A].args, null, i.ANull)
          );
        });
      }
      function L(R, A, y2, C) {
        var j = new a(R, null, y2, C).parseType(false, A, true);
        return j instanceof i.AVal ? j.types.forEach(d2) : d2(j), j;
      }
      function D(R, A, y2) {
        var C = R.computeRet, j = R.retval;
        R.computeRet = function(w, J, te) {
          var se = A(w, J, te), ge = C ? C(w, J, te) : j;
          return y2 ? se : ge;
        };
      }
      var W = r.parseEffect = function(R, A) {
        var y2;
        if (R.indexOf("propagate ") == 0) {
          var C = new a(R, 10), j = C.parseType(true);
          C.eat(" ") || C.error();
          var w = C.parseType(true);
          D(A, function(De, Ce) {
            s(j, De, Ce).propagate(s(w, De, Ce));
          });
        } else if (R.indexOf("call ") == 0) {
          var J = R.indexOf("and return ", 5) == 5, C = new a(R, J ? 16 : 5), te = C.parseType(true), se = null, ge = [];
          for (C.eat(" this=") && (se = C.parseType(true)); C.eat(" "); )
            ge.push(C.parseType(true));
          D(A, function(Ce, Ee) {
            for (var ut = s(te, Ce, Ee), Je = se ? s(se, Ce, Ee) : i.ANull, q = [], ot = 0; ot < ge.length; ++ot)
              q.push(s(ge[ot], Ce, Ee));
            var $t = J ? new i.AVal() : i.ANull;
            return ut.propagate(new i.IsCallee(Je, q, null, $t)), $t;
          }, J);
        } else if (y2 = R.match(/^custom (\S+)\s*(.*)/)) {
          var fe = H[y2[1]];
          fe && D(A, y2[2] ? fe(y2[2]) : fe);
        } else if (R.indexOf("copy ") == 0) {
          var C = new a(R, 5), et = C.parseType(true);
          C.eat(" ");
          var yt = C.parseType(true);
          D(A, function(Ce, Ee) {
            var ut = s(et, Ce, Ee), Je = s(yt, Ce, Ee);
            ut.forAllProps(function(q, ot, $t) {
              $t && q != "<i>" && Je.propagate(new i.DefProp(q, ot));
            });
          });
        } else
          throw new Error("Unknown effect type: " + R);
      }, x, V = r.parsePath = function(R, A) {
        var y2 = i.cx(), C = y2.paths[R], j = R;
        if (C != null)
          return C;
        y2.paths[R] = i.ANull;
        var w = A || x || y2.topScope;
        if (y2.localDefs) {
          for (var J in y2.localDefs)
            if (R.indexOf(J) == 0) {
              if (R == J)
                return y2.paths[R] = y2.localDefs[R];
              if (R.charAt(J.length) == ".") {
                w = y2.localDefs[J], R = R.slice(J.length + 1);
                break;
              }
            }
        }
        var te = _2(w, R.split("."));
        return y2.paths[j] = te == i.ANull ? null : te, te;
      };
      function _2(R, A) {
        for (var y2 = 0; y2 < A.length && R != i.ANull; ++y2) {
          var C = A[y2];
          if (C.charAt(0) == "!")
            if (C == "!proto")
              R = R instanceof i.Obj && R.proto || i.ANull;
            else {
              var j = R.getFunctionType();
              if (!j)
                R = i.ANull;
              else if (C == "!ret")
                R = j.retval && j.retval.getType(false) || i.ANull;
              else {
                var w = j.args && j.args[Number(C.slice(1))];
                R = w && w.getType(false) || i.ANull;
              }
            }
          else if (R instanceof i.Obj && (C == "prototype" && R instanceof i.Fn || R.hasProp(C))) {
            var J = R.getProp(C);
            !J || J.isEmpty() ? R = i.ANull : R = J.types[0];
          } else
            R = i.ANull;
        }
        return R;
      }
      function $(R) {
        var A = Object.create(R.prototype);
        return A.props = /* @__PURE__ */ Object.create(null), A.isShell = true, A;
      }
      function z(R) {
        if (!R["!type"] || /^(fn\(|\[|\+)/.test(R["!type"]))
          return false;
        for (var A in R)
          if (A != "!type" && A != "!doc" && A != "!url" && A != "!span" && A != "!data")
            return false;
        return true;
      }
      function F(R, A, y2) {
        if (!R) {
          var C = A["!type"];
          if (C)
            if (/^fn\(/.test(C))
              R = $(i.Fn);
            else if (C.charAt(0) == "[")
              R = $(i.Arr);
            else if (C.charAt(0) == "+")
              R = $(i.Obj);
            else
              throw new Error("Invalid !type spec: " + C);
          else
            A["!stdProto"] ? R = i.cx().protos[A["!stdProto"]] : R = $(i.Obj);
          R.name = y2;
        }
        for (var j in A)
          if (n(A, j) && j.charCodeAt(0) != 33) {
            var w = A[j];
            if (typeof w == "string" || z(w))
              continue;
            var J = R.defProp(j);
            F(J.getObjType(), w, y2 ? y2 + "." + j : j).propagate(J);
          }
        return R;
      }
      function ae(R, A, y2) {
        if (R.isShell) {
          delete R.isShell;
          var C = A["!type"];
          if (C)
            L(C, y2, R);
          else {
            var j = A["!proto"] && L(A["!proto"]);
            i.Obj.call(R, j instanceof i.Obj ? j : true, y2);
          }
        }
        var w = A["!effects"];
        if (w && R instanceof i.Fn)
          for (var J = 0; J < w.length; ++J)
            W(w[J], R);
        U(A, R);
        for (var te in A)
          if (n(A, te) && te.charCodeAt(0) != 33) {
            var se = A[te], ge = R.defProp(te), fe = y2 ? y2 + "." + te : te;
            if (typeof se == "string")
              ge.isEmpty() && L(se, fe).propagate(ge);
            else {
              if (!z(se))
                ae(ge.getObjType(), se, fe);
              else if (ge.isEmpty())
                L(se["!type"], fe, null, true).propagate(ge);
              else
                continue;
              se["!doc"] && (ge.doc = se["!doc"]), se["!url"] && (ge.url = se["!url"]), se["!span"] && (ge.span = se["!span"]);
            }
          }
        return R;
      }
      function U(R, A) {
        R["!doc"] && (A.doc = R["!doc"]), R["!url"] && (A.url = R["!url"]), R["!span"] && (A.span = R["!span"]), R["!data"] && (A.metaData = R["!data"]);
      }
      function G(R, A) {
        var y2 = i.cx(), C = y2.parent;
        i.addOrigin(y2.curOrigin = R["!name"] || "env#" + y2.origins.length), y2.localDefs = y2.definitions[y2.curOrigin] = /* @__PURE__ */ Object.create(null), C && C.signal("preLoadDef", R), F(A, R);
        var j = R["!define"];
        if (j) {
          for (var w in j) {
            var J = j[w];
            y2.localDefs[w] = typeof J == "string" ? V(J) : F(null, J, w);
          }
          for (var w in j) {
            var J = j[w];
            typeof J != "string" && ae(y2.localDefs[w], j[w], w);
          }
        }
        ae(A, R), C && C.signal("postLoadDef", R), y2.curOrigin = y2.localDefs = null;
      }
      r.load = function(R, A) {
        A || (A = i.cx().topScope);
        var y2 = x;
        x = A;
        try {
          G(R, A);
        } finally {
          x = y2;
        }
      }, r.parse = function(R, A, y2) {
        var C = i.cx();
        A && (C.origin = A, C.localDefs = C.definitions[A]);
        try {
          return typeof R == "string" ? L(R, y2) : ae(F(null, R, y2), R, y2);
        } finally {
          A && (C.origin = C.localDefs = null);
        }
      };
      var H = /* @__PURE__ */ Object.create(null);
      i.registerFunction = function(R, A) {
        H[R] = A;
      };
      var re = i.constraint({
        construct: function(R, A, y2) {
          this.created = R, this.target = A, this.spec = y2;
        },
        addType: function(R) {
          if (R instanceof i.Obj && this.created++ < 5) {
            var A = new i.Obj(R), y2 = this.spec;
            if (y2 instanceof i.AVal && (y2 = y2.getObjType(false)), y2 instanceof i.Obj)
              for (var C in y2.props) {
                var j = y2.props[C].types[0], w = A.defProp(C);
                if (j && j instanceof i.Obj && j.props.value) {
                  var J = j.props.value.getType(false);
                  J && w.addType(J);
                }
              }
            this.target.addType(A);
          }
        }
      });
      i.registerFunction("Object_create", function(R, A, y2) {
        if (y2 && y2.length && y2[0].type == "Literal" && y2[0].value == null)
          return new i.Obj();
        var C = new i.AVal();
        return A[0] && A[0].propagate(new re(0, C, A[1])), C;
      });
      var B = i.constraint({
        construct: function(R) {
          this.target = R;
        },
        addType: function(R) {
          R instanceof i.Obj && (R.hasProp("value") ? R.getProp("value").propagate(this.target) : R.hasProp("get") && R.getProp("get").propagate(new i.IsCallee(i.ANull, [], null, this.target)));
        }
      });
      i.registerFunction("Object_defineProperty", function(R, A, y2) {
        if (y2 && y2.length >= 3 && y2[1].type == "Literal" && typeof y2[1].value == "string") {
          var C = A[0], j = new i.AVal();
          C.propagate(new i.DefProp(y2[1].value, j, y2[1])), A[2].propagate(new B(j));
        }
        return i.ANull;
      }), i.registerFunction("Object_defineProperties", function(R, A, y2) {
        if (A.length >= 2) {
          var C = A[0];
          A[1].forAllProps(function(j, w, J) {
            if (J) {
              var te = new i.AVal();
              C.propagate(new i.DefProp(j, te, y2 && y2[1])), w.propagate(new B(te));
            }
          });
        }
        return i.ANull;
      });
      var Y = i.constraint({
        construct: function(R, A, y2) {
          this.self = R, this.args = A, this.target = y2;
        },
        addType: function(R) {
          if (R instanceof i.Fn) {
            this.target.addType(new i.Fn(
              R.name,
              i.ANull,
              R.args.slice(this.args.length),
              R.argNames.slice(this.args.length),
              R.retval,
              R.generator
            )), this.self.propagate(R.self);
            for (var A = 0; A < Math.min(R.args.length, this.args.length); ++A)
              this.args[A].propagate(R.args[A]);
          }
        }
      });
      i.registerFunction("Function_bind", function(R, A) {
        if (!A.length)
          return i.ANull;
        var y2 = new i.AVal();
        return R.propagate(new Y(A[0], A.slice(1), y2)), y2;
      }), i.registerFunction("Array_ctor", function(R, A) {
        var y2 = new i.Arr();
        if (A.length != 1 || !A[0].hasType(i.cx().num))
          for (var C = y2.getProp("<i>"), j = 0; j < A.length; ++j)
            A[j].propagate(C);
        return y2;
      });
      function E() {
        var R = i.cx().definitions.ecmascript;
        return R && new i.Obj(R["Promise.prototype"]);
      }
      i.registerFunction("Promise_ctor", function(R, A, y2) {
        var C = E();
        if (!C || A.length < 1)
          return i.ANull;
        var j = C.defProp(":t", y2 && y2[0]), w = new i.AVal();
        w.propagate(j);
        var J = new i.Fn("execute", i.ANull, [w], ["value"], i.ANull), te = i.cx().definitions.ecmascript.Promise_reject;
        return A[0].propagate(new i.IsCallee(i.ANull, [J, te], null, i.ANull)), C;
      }), i.registerFunction("Promise_resolve", function(R, A, y2) {
        var C = E();
        if (!C)
          return i.ANull;
        if (A.length) {
          var j = C.defProp(":t", y2 && y2[0]), w = new i.AVal();
          w.propagate(j), A[0].propagate(new m(w));
        }
        return C;
      });
      var m = i.constraint({
        construct: function(R) {
          this.output = R;
        },
        addType: function(R) {
          R.constructor == i.Obj && R.name == "Promise" && R.hasProp(":t") ? R.getProp(":t").propagate(this.output) : R.propagate(this.output);
        }
      }), P = 50;
      return i.registerFunction("Promise_then", function(R, A, y2) {
        var C = A.length && A[0].getFunctionType(), j = i.cx().definitions.ecmascript;
        if (!C || !j)
          return R;
        var w = new i.Obj(j["Promise.prototype"]), J = w.defProp(":t", y2 && y2[0]), te;
        return C.retval.isEmpty() && (te = R.getType()) instanceof i.Obj && te.hasProp(":t") && te.getProp(":t").propagate(J, P), C.retval.propagate(new m(J)), w;
      }), i.registerFunction("getOwnPropertySymbols", function(R, A) {
        if (!A.length)
          return i.ANull;
        var y2 = new i.AVal();
        return A[0].forAllProps(function(C, j, w) {
          w && C.charAt(0) == ":" && y2.addType(i.getSymbol(C.slice(1)));
        }), y2;
      }), i.registerFunction("getSymbol", function(R, A, y2) {
        return y2 && y2.length && y2[0].type == "Literal" && typeof y2[0].value == "string" ? i.getSymbol(y2[0].value) : i.ANull;
      }), r;
    });
  }($a, $a.exports)), $a.exports;
}
var Ya = { exports: {} };
var mh;
function gd() {
  return mh || (mh = 1, function(e, t) {
    (function(r, i) {
      return i(t);
    })(Q2, function(r) {
      function i(f, p) {
        var O = this._handlers || (this._handlers = /* @__PURE__ */ Object.create(null));
        (O[f] || (O[f] = [])).push(p);
      }
      function n(f, p) {
        var O = this._handlers && this._handlers[f];
        if (O) {
          for (var d2 = 0; d2 < O.length; ++d2)
            if (O[d2] == p) {
              O.splice(d2, 1);
              break;
            }
        }
      }
      var a = [];
      function s(f, p) {
        var O = f._handlers && f._handlers[p];
        return O && O.length ? O.slice() : a;
      }
      function o(f, p, O, d2, g) {
        for (var L = s(this, f), D = 0; D < L.length; ++D)
          L[D].call(this, p, O, d2, g);
      }
      function l(f, p, O, d2, g) {
        for (var L = s(this, f), D = 0; D < L.length; ++D) {
          var W = L[D].call(this, p, O, d2, g);
          if (W)
            return W;
        }
      }
      function c(f) {
        var p = this._handlers && this._handlers[f];
        return p && p.length > 0 && p;
      }
      r.mixin = function(f) {
        return f.on = i, f.off = n, f.signal = o, f.signalReturnFirst = l, f.hasHandler = c, f;
      };
    });
  }(Ya, Ya.exports)), Ya.exports;
}
var Rh;
function yP() {
  return Rh || (Rh = 1, function(e, t) {
    (function(r, i) {
      return i(
        t,
        XE,
        cP,
        Ad,
        gP(),
        gd()
      );
    })(Q2, function(r, i, n, a, s, o) {
      var l = r.toString = function(u, h, S) {
        return !u || u == S || h && h < -3 ? "?" : u.toString(h, S);
      }, c = r.ANull = o.mixin({
        addType: function() {
        },
        propagate: function() {
        },
        getProp: function() {
          return c;
        },
        forAllProps: function() {
        },
        hasType: function() {
          return false;
        },
        isEmpty: function() {
          return true;
        },
        getFunctionType: function() {
        },
        getObjType: function() {
        },
        getSymbolType: function() {
        },
        getType: function() {
        },
        gatherProperties: function() {
        },
        propagatesTo: function() {
        },
        typeHint: function() {
        },
        propHint: function() {
        },
        toString: function() {
          return "?";
        }
      });
      function f(u, h) {
        var S = Object.create(u);
        if (h)
          for (var I in h)
            S[I] = h[I];
        return S;
      }
      var p = 100, O = 90, d2 = 10, g = 6, L = 6, D = 1, W = 90, x = 2, V = 4, _2 = r.AVal = function() {
        this.types = [], this.forward = null, this.maxWeight = 0;
      };
      _2.prototype = f(c, {
        addType: function(u, h) {
          if (h = h || p, this.maxWeight < h) {
            if (this.maxWeight = h, this.types.length == 1 && this.types[0] == u)
              return;
            this.types.length = 0;
          } else if (this.maxWeight > h || this.types.indexOf(u) > -1)
            return;
          this.signal("addType", u), this.types.push(u);
          var S = this.forward;
          S && tt(function(I) {
            for (var k = 0; k < S.length; ++k)
              I(u, S[k], h);
          });
        },
        propagate: function(u, h) {
          if (!(u == c || u instanceof te && this.forward && this.forward.length > 2)) {
            h && h != p && (u = new J(u, h)), (this.forward || (this.forward = [])).push(u);
            var S = this.types;
            S.length && tt(function(I) {
              for (var k = 0; k < S.length; ++k)
                I(S[k], u, h);
            });
          }
        },
        getProp: function(u) {
          if (yt(u))
            return c;
          var h = (this.props || (this.props = /* @__PURE__ */ Object.create(null)))[u];
          return h || (h = this.props[u] = new _2(), this.propagate(new G(u, h))), h;
        },
        forAllProps: function(u) {
          this.propagate(new re(u));
        },
        hasType: function(u) {
          return this.types.indexOf(u) > -1;
        },
        isEmpty: function() {
          return this.types.length === 0;
        },
        getFunctionType: function() {
          for (var u = this.types.length - 1; u >= 0; --u)
            if (this.types[u] instanceof De)
              return this.types[u];
        },
        getObjType: function() {
          for (var u = null, h = this.types.length - 1; h >= 0; --h) {
            var S = this.types[h];
            if (S instanceof fe) {
              if (S.name)
                return S;
              u || (u = S);
            }
          }
          return u;
        },
        getSymbolType: function() {
          for (var u = this.types.length - 1; u >= 0; --u)
            if (this.types[u] instanceof Ee)
              return this.types[u];
        },
        getType: function(u) {
          return this.types.length === 0 && u !== false ? this.makeupType() : this.types.length === 1 ? this.types[0] : ae(this.types);
        },
        toString: function(u, h) {
          if (this.types.length == 0)
            return l(this.makeupType(), u, h);
          if (this.types.length == 1)
            return l(this.types[0], u, h);
          var S = F(this.types);
          return S.length > 2 ? "?" : S.map(function(I) {
            return l(I, u, h);
          }).join("|");
        },
        makeupPropType: function(u) {
          var h = this.propertyName, S = u.proto && u.proto.hasProp(h);
          if (S) {
            var I = S.getType();
            if (I)
              return I;
          }
          if (h != "<i>") {
            var k = u.hasProp("<i>");
            if (k)
              return k.getType();
          } else if (u.props["<i>"] != this)
            for (var K in u.props) {
              var ie = u.props[K];
              if (!ie.isEmpty())
                return ie.getType();
            }
        },
        makeupType: function() {
          var u = this.propertyOf && this.makeupPropType(this.propertyOf);
          if (u)
            return u;
          if (!this.forward)
            return null;
          for (var h = this.forward.length - 1; h >= 0; --h) {
            var S = this.forward[h].typeHint();
            if (S && !S.isEmpty())
              return Cn = true, S;
          }
          for (var I = /* @__PURE__ */ Object.create(null), k = null, h = 0; h < this.forward.length; ++h) {
            var K = this.forward[h].propHint();
            K && K != "length" && K != "<i>" && K != "" && K != q.completingProperty && (I[K] = true, k = K);
          }
          if (!k)
            return null;
          var ie = Je(k);
          if (ie) {
            var oe = [];
            e:
              for (var h = 0; h < ie.length; ++h) {
                var he = ie[h];
                for (var K in I)
                  if (!he.hasProp(K))
                    continue e;
                he.hasCtor && (he = P(he)), oe.push(he);
              }
            var ye = ae(oe);
            if (ye)
              return Cn = true, ye;
          }
        },
        typeHint: function() {
          return this.types.length ? this.getType() : null;
        },
        propagatesTo: function() {
          return this;
        },
        gatherProperties: function(u, h) {
          for (var S = 0; S < this.types.length; ++S)
            this.types[S].gatherProperties(u, h);
        },
        guessProperties: function(u) {
          if (this.forward)
            for (var h = 0; h < this.forward.length; ++h) {
              var S = this.forward[h].propHint();
              S && u(S, null, 0);
            }
          var I = this.makeupType();
          I && I.gatherProperties(u);
        }
      });
      function $(u, h, S) {
        var I = u.getType(false), k = h.getType(false);
        return !I || !k ? true : z(I, k, S);
      }
      function z(u, h, S) {
        if (!u || S >= 5)
          return h;
        if (!u || u == h || !h)
          return u;
        if (u.constructor != h.constructor)
          return false;
        if (u.constructor == Ce) {
          var I = u.getProp("<i>").getType(false);
          if (!I)
            return h;
          var k = h.getProp("<i>").getType(false);
          if (!k || z(I, k, S + 1))
            return h;
        } else if (u.constructor == fe) {
          var K = 0, ie = 0, oe = 0;
          for (var he in u.props)
            K++, he in h.props && $(u.props[he], h.props[he], S + 1) && oe++;
          for (var he in h.props)
            ie++;
          return K && ie && oe < Math.max(K, ie) / 2 ? false : K > ie ? u : h;
        } else
          return u.constructor == De ? u.args.length != h.args.length || !u.args.every(function(ye, We) {
            return $(ye, h.args[We], S + 1);
          }) || !$(u.retval, h.retval, S + 1) || !$(u.self, h.self, S + 1) ? false : u : false;
      }
      var F = r.simplifyTypes = function(u) {
        var h = [];
        e:
          for (var S = 0; S < u.length; ++S) {
            for (var I = u[S], k = 0; k < h.length; k++) {
              var K = z(I, h[k], 0);
              if (K) {
                h[k] = K;
                continue e;
              }
            }
            h.push(I);
          }
        return h;
      };
      function ae(u) {
        for (var h = 0, S = 0, I = 0, k = null, K = 0; K < u.length; ++K) {
          var ie = u[K];
          if (ie instanceof Ce)
            ++h;
          else if (ie instanceof De)
            ++S;
          else if (ie instanceof fe)
            ++I;
          else if (ie instanceof se) {
            if (k && ie.name != k.name)
              return null;
            k = ie;
          }
        }
        var oe = (h && 1) + (S && 1) + (I && 1) + (k && 1);
        if (oe > 1)
          return null;
        if (k)
          return k;
        for (var he = 0, ye = null, K = 0; K < u.length; ++K) {
          var ie = u[K], We = 0;
          if (h)
            We = ie.getProp("<i>").isEmpty() ? 1 : 2;
          else if (S) {
            We = 1;
            for (var Me = 0; Me < ie.args.length; ++Me)
              ie.args[Me].isEmpty() || ++We;
            ie.retval.isEmpty() || ++We;
          } else
            I && (We = ie.name ? 100 : 2);
          We >= he && (he = We, ye = ie);
        }
        return ye;
      }
      var U = r.constraint = function(u) {
        var h = function() {
          this.origin = q.curOrigin, this.construct.apply(this, arguments);
        };
        h.prototype = Object.create(c);
        for (var S in u)
          u.hasOwnProperty(S) && (h.prototype[S] = u[S]);
        return h;
      }, G = U({
        construct: function(u, h) {
          this.prop = u, this.target = h;
        },
        addType: function(u, h) {
          u.getProp && u.getProp(this.prop).propagate(this.target, h);
        },
        propHint: function() {
          return this.prop;
        },
        propagatesTo: function() {
          if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
            return { target: this.target, pathExt: "." + this.prop };
        }
      }), H = r.PropHasSubset = r.DefProp = U({
        construct: function(u, h, S) {
          this.prop = u, this.type = h, this.originNode = S;
        },
        addType: function(u, h) {
          if (u instanceof fe) {
            var S = u.defProp(this.prop, this.originNode);
            S.origin || (S.origin = this.origin), this.type.propagate(S, h);
          }
        },
        propHint: function() {
          return this.prop;
        }
      }), re = U({
        construct: function(u) {
          this.c = u;
        },
        addType: function(u) {
          u instanceof fe && u.forAllProps(this.c);
        }
      });
      function B(u, h) {
        q.disabledComputing = { fn: u, prev: q.disabledComputing };
        var S = h();
        return q.disabledComputing = q.disabledComputing.prev, S;
      }
      var Y = r.IsCallee = U({
        construct: function(u, h, S, I) {
          this.self = u, this.args = h, this.argNodes = S, this.retval = I, this.disabled = q.disabledComputing;
        },
        addType: function(u, h) {
          if (u instanceof De) {
            for (var S = 0; S < this.args.length; ++S)
              S < u.args.length && this.args[S].propagate(u.args[S], h), u.arguments && this.args[S].propagate(u.arguments, h);
            u.isArrowFn() || this.self.propagate(u.self, this.self == q.topScope ? W : h);
            var I = u.computeRet, k = u.retval;
            if (I)
              for (var K = this.disabled; K; K = K.prev)
                (K.fn == u || u.originNode && K.fn.originNode == u.originNode) && (I = null);
            if (I) {
              var ie = q.disabledComputing;
              q.disabledComputing = this.disabled, k = I(this.self, this.args, this.argNodes), q.disabledComputing = ie;
            }
            if (u.async && !u.generator) {
              var oe = k.getType();
              if (!(oe && oe.constructor == fe && oe.name == "Promise")) {
                var he = q.definitions.ecmascript, ye = he && new fe(he["Promise.prototype"]);
                ye && (ye.getType().propagate(new H(":t", k)), k = ye);
              }
            }
            wc(u, k).propagate(this.retval, h);
          }
        },
        typeHint: function() {
          for (var u = [], h = 0; h < this.args.length; ++h)
            u.push("?");
          return new De(null, this.self, this.args, u, c);
        },
        propagatesTo: function() {
          return { target: this.retval, pathExt: ".!ret" };
        }
      }), E = U({
        construct: function(u, h, S, I) {
          this.propName = u, this.args = h, this.argNodes = S, this.retval = I, this.disabled = q.disabledComputing;
        },
        addType: function(u, h) {
          var S = new Y(u, this.args, this.argNodes, this.retval);
          S.disabled = this.disabled, u.getProp(this.propName).propagate(S, h);
        },
        propHint: function() {
          return this.propName;
        }
      }), m = r.IsCtor = U({
        construct: function(u, h) {
          this.target = u, this.noReuse = h;
        },
        addType: function(u, h) {
          u instanceof De && (q.parent && !q.parent.options.reuseInstances && (this.noReuse = true), u.getProp("prototype").propagate(new R(this.noReuse ? false : u, this.target), h));
        }
      }), P = r.getInstance = function(u, h) {
        if (h === false)
          return new fe(u);
        h || (h = u.hasCtor), u.instances || (u.instances = []);
        for (var S = 0; S < u.instances.length; ++S) {
          var I = u.instances[S];
          if (I.ctor == h)
            return I.instance;
        }
        var k = new fe(u, h && h.name);
        return k.origin = u.origin, u.instances.push({ ctor: h, instance: k }), k;
      }, R = r.IsProto = U({
        construct: function(u, h) {
          this.ctor = u, this.target = h;
        },
        addType: function(u, h) {
          u instanceof fe && ((this.count = (this.count || 0) + 1) > 8 || (u == q.protos.Array ? this.target.addType(new Ce()) : this.target.addType(P(u, this.ctor))));
        }
      }), A = U({
        construct: function(u) {
          this.fn = u;
        },
        addType: function(u, h) {
          if (u instanceof fe && !u.hasCtor) {
            u.hasCtor = this.fn;
            var S = new j(u, this.fn);
            S.addType(this.fn), u.forAllProps(function(I, k, K) {
              K && k.propagate(S);
            });
          }
        }
      }), y2 = U({
        construct: function(u, h) {
          this.other = u, this.target = h;
        },
        addType: function(u, h) {
          u == q.str ? this.target.addType(q.str, h) : u == q.num && this.other.hasType(q.num) && this.target.addType(q.num, h);
        },
        typeHint: function() {
          return this.other;
        }
      }), C = r.IfObj = U({
        construct: function(u) {
          this.target = u;
        },
        addType: function(u, h) {
          u instanceof fe && this.target.addType(u, h);
        },
        propagatesTo: function() {
          return this.target;
        }
      }), j = U({
        construct: function(u, h) {
          this.obj = u, this.ctor = h;
        },
        addType: function(u) {
          u instanceof De && u.self && u.self.addType(P(this.obj, this.ctor), V);
        }
      }), w = U({
        construct: function(u) {
          this.obj = u;
        },
        addType: function(u) {
          u instanceof fe && this.obj.proto == q.protos.Object && this.obj.replaceProto(u);
        }
      }), J = U({
        construct: function(u, h) {
          this.inner = u, this.weight = h;
        },
        addType: function(u, h) {
          this.inner.addType(u, Math.min(h, this.weight));
        },
        propagatesTo: function() {
          return this.inner.propagatesTo();
        },
        typeHint: function() {
          return this.inner.typeHint();
        },
        propHint: function() {
          return this.inner.propHint();
        }
      }), te = r.Type = function() {
      };
      te.prototype = f(c, {
        constructor: te,
        propagate: function(u, h) {
          u.addType(this, h);
        },
        hasType: function(u) {
          return u == this;
        },
        isEmpty: function() {
          return false;
        },
        typeHint: function() {
          return this;
        },
        getType: function() {
          return this;
        }
      });
      var se = r.Prim = function(u, h) {
        this.name = h, this.proto = u;
      };
      se.prototype = f(te.prototype, {
        constructor: se,
        toString: function() {
          return this.name;
        },
        getProp: function(u) {
          return this.proto.hasProp(u) || c;
        },
        gatherProperties: function(u, h) {
          this.proto && this.proto.gatherProperties(u, h);
        }
      });
      function ge(u) {
        var h = u.charCodeAt(0);
        return h >= 48 && h <= 57 ? !/\D/.test(u) : false;
      }
      var fe = r.Obj = function(u, h) {
        if (this.props || (this.props = /* @__PURE__ */ Object.create(null)), this.proto = u === true ? q.protos.Object : u, u && u != q.protos.Object && !h && u.name && !(this instanceof De)) {
          var S = /^(.*)\.prototype$/.exec(this.proto.name);
          S && (h = S[1]);
        }
        this.name = h, this.maybeProps = null, this.origin = q.curOrigin;
      };
      fe.prototype = f(te.prototype, {
        constructor: fe,
        toString: function(u) {
          if (u == null && (u = 0), u <= 0 && this.name)
            return this.name;
          var h = [], S = false;
          for (var I in this.props)
            if (I != "<i>") {
              if (h.length > 5) {
                S = true;
                break;
              }
              u ? h.push(I + ": " + l(this.props[I], u - 1, this)) : h.push(I);
            }
          return h.sort(), S && h.push("..."), "{" + h.join(", ") + "}";
        },
        hasProp: function(u, h) {
          ge(u) && (u = this.normalizeIntegerProp(u));
          var S = this.props[u];
          if (h !== false)
            for (var I = this.proto; I && !S; I = I.proto)
              S = I.props[u];
          return S;
        },
        defProp: function(u, h) {
          var S = this.hasProp(u, false);
          if (S)
            return h && !S.originNode && (S.originNode = h), S;
          if (yt(u))
            return c;
          ge(u) && (u = this.normalizeIntegerProp(u));
          var I = this.maybeProps && this.maybeProps[u];
          return I ? (delete this.maybeProps[u], this.maybeUnregProtoPropHandler()) : (I = new _2(), I.propertyOf = this, I.propertyName = u), this.props[u] = I, I.originNode = h, I.origin = q.curOrigin, this.broadcastProp(u, I, true), I;
        },
        getProp: function(u) {
          var h = this.hasProp(u, true) || this.maybeProps && this.maybeProps[u];
          if (h)
            return h;
          if (yt(u))
            return c;
          ge(u) && (u = this.normalizeIntegerProp(u));
          var S = this.ensureMaybeProps()[u] = new _2();
          return S.propertyOf = this, S.propertyName = u, S;
        },
        normalizeIntegerProp: function(u) {
          return "<i>";
        },
        broadcastProp: function(u, h, S) {
          if (S && (this.signal("addProp", u, h), this instanceof lt || ut(u, this)), this.onNewProp)
            for (var I = 0; I < this.onNewProp.length; ++I) {
              var k = this.onNewProp[I];
              k.onProtoProp ? k.onProtoProp(u, h, S) : k(u, h, S);
            }
        },
        onProtoProp: function(u, h, S) {
          var I = this.maybeProps && this.maybeProps[u];
          I && (delete this.maybeProps[u], this.maybeUnregProtoPropHandler(), this.proto.getProp(u).propagate(I)), this.broadcastProp(u, h, false);
        },
        replaceProto: function(u) {
          for (var h = u; h; h = h.proto)
            if (h == this)
              return;
          this.proto && this.maybeProps && this.proto.unregPropHandler(this), this.proto = u, this.maybeProps && this.proto.forAllProps(this);
        },
        ensureMaybeProps: function() {
          return this.maybeProps || (this.proto && this.proto.forAllProps(this), this.maybeProps = /* @__PURE__ */ Object.create(null)), this.maybeProps;
        },
        removeProp: function(u) {
          var h = this.props[u];
          delete this.props[u], this.ensureMaybeProps()[u] = h, h.types.length = 0;
        },
        forAllProps: function(u) {
          this.onNewProp || (this.onNewProp = [], this.proto && this.proto.forAllProps(this)), this.onNewProp.push(u);
          for (var h = this; h; h = h.proto)
            for (var S in h.props)
              u.onProtoProp ? u.onProtoProp(S, h.props[S], h == this) : u(S, h.props[S], h == this);
        },
        maybeUnregProtoPropHandler: function() {
          if (this.maybeProps) {
            for (var u in this.maybeProps)
              return;
            this.maybeProps = null;
          }
          !this.proto || this.onNewProp && this.onNewProp.length || this.proto.unregPropHandler(this);
        },
        unregPropHandler: function(u) {
          for (var h = 0; h < this.onNewProp.length; ++h)
            if (this.onNewProp[h] == u) {
              this.onNewProp.splice(h, 1);
              break;
            }
          this.maybeUnregProtoPropHandler();
        },
        gatherProperties: function(u, h) {
          for (var S in this.props)
            S != "<i>" && S.charAt(0) != ":" && u(S, this, h);
          this.proto && this.proto.gatherProperties(u, h + 1);
        },
        getObjType: function() {
          return this;
        }
      });
      var et = typeof StopIteration < "u";
      function yt(u) {
        return u == "__proto__" || u == "" || et && u == "__iterator__";
      }
      var De = r.Fn = function(u, h, S, I, k, K, ie) {
        fe.call(this, q.protos.Function, u), this.self = h, this.args = S, this.argNames = I, this.retval = k, this.generator = K, this.async = ie;
      };
      De.prototype = f(fe.prototype, {
        constructor: De,
        toString: function(u) {
          u == null && (u = 0);
          for (var h = this.generator ? "fn*(" : "fn(", S = 0; S < this.args.length; ++S) {
            S && (h += ", ");
            var I = this.argNames[S];
            I && I != "?" && (h += I + ": "), h += u > -3 ? l(this.args[S], u - 1, this) : "?";
          }
          return h += ")", this.retval.isEmpty() || (h += " -> " + (u > -3 ? l(this.retval, u - 1, this) : "?")), h;
        },
        getProp: function(u) {
          if (u == "prototype") {
            var h = this.hasProp(u, false);
            if (!h) {
              h = this.defProp(u);
              var S = new fe(true, this.name && this.name + ".prototype");
              S.origin = this.origin, h.addType(S, d2);
            }
            return h;
          }
          return fe.prototype.getProp.call(this, u);
        },
        defProp: function(u, h) {
          if (u == "prototype") {
            var S = this.hasProp(u, false);
            return S || (S = fe.prototype.defProp.call(this, u, h), S.origin = this.origin, S.propagate(new A(this)), S);
          }
          return fe.prototype.defProp.call(this, u, h);
        },
        getFunctionType: function() {
          return this;
        },
        isArrowFn: function() {
          return this.originNode && this.originNode.type == "ArrowFunctionExpression";
        }
      });
      var Ce = r.Arr = function(u) {
        fe.call(this, q.protos.Array);
        var h = this.defProp("<i>");
        if (Array.isArray(u)) {
          this.tuple = u.length;
          for (var S = 0; S < u.length; S++) {
            var I = this.defProp(String(S));
            u[S].propagate(I), I.propagate(h);
          }
        } else
          u && (this.tuple = 0, u.propagate(h));
      };
      Ce.prototype = f(fe.prototype, {
        constructor: Ce,
        toString: function(u) {
          if (u == null && (u = 0), u <= -3)
            return "[?]";
          var h = "";
          if (this.tuple) {
            for (var S, I = 0; I in this.props; I++) {
              var k = l(this.getProp(String(I)), u - 1, this);
              S == null ? S = k : S != k ? S = false : S = k, h += (h ? ", " : "") + k;
            }
            S && (h = S);
          } else
            h = l(this.getProp("<i>"), u - 1, this);
          return "[" + h + "]";
        },
        normalizeIntegerProp: function(u) {
          return +u < this.tuple ? u : "<i>";
        }
      });
      var Ee = r.Sym = function(u, h) {
        se.call(this, q.protos.Symbol, "Symbol"), this.symName = u, this.originNode = h;
      };
      Ee.prototype = f(se.prototype, {
        constructor: Ee,
        asPropName: function() {
          return ":" + this.symName;
        },
        getSymbolType: function() {
          return this;
        }
      }), r.getSymbol = function(u, h) {
        var S = u.replace(/[^\w$\.]/g, "_"), I = q.symbols[S];
        return I ? (h && !I.originNode && (I.originNode = h), I) : q.symbols[S] = new Ee(S, h);
      };
      function ut(u, h) {
        var S = q.props[u] || (q.props[u] = []);
        S.push(h);
      }
      function Je(u) {
        return q.props[u];
      }
      r.Context = function(u, h) {
        this.parent = h, this.props = /* @__PURE__ */ Object.create(null), this.protos = /* @__PURE__ */ Object.create(null), this.origins = [], this.curOrigin = "ecmascript", this.paths = /* @__PURE__ */ Object.create(null), this.definitions = /* @__PURE__ */ Object.create(null), this.purgeGen = 0, this.workList = null, this.disabledComputing = null, this.curSuperCtor = this.curSuper = null, this.symbols = /* @__PURE__ */ Object.create(null), r.withContext(this, function() {
          if (q.protos.Object = new fe(null, "Object.prototype"), q.topScope = new lt(), q.topScope.name = "<top>", q.protos.Array = new fe(true, "Array.prototype"), q.protos.Function = new De("Function.prototype", c, [], [], c), q.protos.Function.proto = q.protos.Object, q.protos.RegExp = new fe(true, "RegExp.prototype"), q.protos.String = new fe(true, "String.prototype"), q.protos.Number = new fe(true, "Number.prototype"), q.protos.Boolean = new fe(true, "Boolean.prototype"), q.protos.Symbol = new fe(true, "Symbol.prototype"), q.str = new se(q.protos.String, "string"), q.bool = new se(q.protos.Boolean, "bool"), q.num = new se(q.protos.Number, "number"), q.curOrigin = null, u)
            for (var S = 0; S < u.length; ++S)
              s.load(u[S]);
        });
      }, r.Context.prototype.startAnalysis = function() {
        this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;
      };
      var q = null;
      r.cx = function() {
        return q;
      }, r.withContext = function(u, h) {
        var S = q;
        q = u;
        try {
          return h();
        } finally {
          q = S;
        }
      }, r.TimedOut = function() {
        this.message = "Timed out", this.stack = new Error().stack;
      }, r.TimedOut.prototype = Object.create(Error.prototype), r.TimedOut.prototype.name = "infer.TimedOut";
      var ot;
      r.withTimeout = function(u, h) {
        var S = +/* @__PURE__ */ new Date() + u, I = ot;
        if (I && I < S)
          return h();
        ot = S;
        try {
          return h();
        } finally {
          ot = I;
        }
      }, r.addOrigin = function(u) {
        q.origins.indexOf(u) < 0 && q.origins.push(u);
      };
      var $t = 20, It2 = 1e-4;
      function tt(u) {
        if (q.workList)
          return u(q.workList);
        for (var h = [], S = 0, I = q.workList = function(ie, oe, he) {
          S < $t - It2 * h.length && h.push(ie, oe, he, S);
        }, k = u(I), K = 0; K < h.length; K += 4) {
          if (ot && +/* @__PURE__ */ new Date() >= ot)
            throw new r.TimedOut();
          S = h[K + 3] + 1, h[K + 1].addType(h[K], h[K + 2]);
        }
        return q.workList = null, k;
      }
      function St2(u, h, S) {
        var I = q.curSuperCtor, k = q.curSuper;
        q.curSuperCtor = u, q.curSuper = h;
        var K = S();
        return q.curSuperCtor = I, q.curSuper = k, K;
      }
      var lt = r.Scope = function(u, h, S, I) {
        fe.call(this, u || true), this.prev = u, this.originNode = h, this.isBlock = !!S, this.isCatch = !!I;
      };
      lt.prototype = f(fe.prototype, {
        constructor: lt,
        defVar: function(u, h) {
          for (var S = this; ; S = S.proto) {
            var I = S.props[u];
            if (I)
              return I;
            if (!S.prev)
              return S.defProp(u, h);
          }
        }
      });
      function vt(u, h) {
        for (; u.isBlock || u.isCatch || h === false && u.fnType && u.fnType.isArrowFn(); )
          u = u.prev;
        return u;
      }
      function xr(u, h) {
        var S = vt(u).fnType;
        S && (S.instantiateScore = (S.instantiateScore || 0) + h);
      }
      var ba = {};
      function va2(u, h) {
        try {
          return a.simple(u, { Expression: function() {
            if (--h <= 0)
              throw ba;
          } }), true;
        } catch (S) {
          if (S == ba)
            return false;
          throw S;
        }
      }
      function qi(u, h) {
        var S = h.instantiateScore;
        if (!q.disabledComputing && S && h.args.length && va2(u, S * 5))
          return xr(vt(h.originNode.scope.prev), S / 2), Oo(u, h), true;
        h.instantiateScore = null;
      }
      function Oo(u, h) {
        for (var S = u.scope, I = 0; I < h.args.length; ++I)
          h.args[I] = new _2();
        h.self = new _2(), h.computeRet = function(k, K) {
          return B(h, function() {
            var ie = q.curOrigin;
            q.curOrigin = h.origin;
            var oe = u.scope ? u.scope : S, he = new lt(oe.prev, oe.originNode);
            for (var ye in oe.props)
              for (var We = he.defProp(ye, oe.props[ye].originNode), Me = 0; Me < K.length; ++Me)
                h.argNames[Me] == ye && Me < K.length && K[Me].propagate(We);
            for (var Ct2 = h.argNames.length != K.length ? h.argNames.slice(0, K.length) : h.argNames; Ct2.length < K.length; )
              Ct2.push("?");
            if (he.fnType = new De(h.name, k, K, Ct2, c, h.generator, h.async), he.fnType.originNode = h.originNode, h.arguments) {
              var wt = he.fnType.arguments = new _2();
              he.defProp("arguments").addType(new Ce(wt));
              for (var Me = 0; Me < K.length; ++Me)
                K[Me].propagate(wt);
            }
            return u.scope = he, a.recursive(u.body, he, null, Z), a.recursive(u.body, he, null, zt), q.curOrigin = ie, he.fnType.retval;
          });
        };
      }
      function Ca(u) {
        var h = u.retval;
        if (h == c || u.isArrowFn())
          return;
        var S, I;
        !h.isEmpty() && (S = h.getType()) instanceof Ce && (h = I = S.getProp("<i>"));
        function k(ye, We, Me) {
          if (!(Me > 3 || !ye.forward))
            for (var Ct2 = 0; Ct2 < ye.forward.length; ++Ct2) {
              var wt = ye.forward[Ct2].propagatesTo();
              if (wt) {
                var Mt = We, Yt;
                if (wt instanceof _2)
                  Yt = wt;
                else if (wt.target instanceof _2)
                  Mt += wt.pathExt, Yt = wt.target;
                else
                  continue;
                if (Yt == h)
                  return Mt;
                var Ln = k(Yt, Mt, Me + 1);
                if (Ln)
                  return Ln;
              }
            }
        }
        for (var K = k(u.self, "!this", 0), ie = 0; !K && ie < u.args.length; ++ie)
          K = k(u.args[ie], "!" + ie, 0);
        if (K) {
          I && (K = "[" + K + "]");
          var oe = new s.TypeParser(K), he = oe.parseType(true);
          return u.computeRet = he.apply ? he : function() {
            return he;
          }, u.computeRetSource = K, true;
        }
      }
      function li(u, h) {
        return u.defProp(h.name, h);
      }
      function N2(u) {
        return u.type == "Identifier" ? u.name : u.type == "AssignmentPattern" ? N2(u.left) : u.type == "ObjectPattern" ? "{" + u.properties.map(function(h) {
          return N2(h.type === "RestElement" ? h : h.value);
        }).join(", ") + "}" : u.type == "ArrayPattern" ? "[" + u.elements.map(function(h) {
          return h ? N2(h) : "";
        }).join(", ") + "]" : u.type == "RestElement" ? "..." + N2(u.argument) : "_";
      }
      function b(u) {
        return u.type == "VariableDeclaration" && u.kind != "var" || u.type == "FunctionDeclaration" || u.type == "ClassDeclaration";
      }
      function M(u, h) {
        return { inner: u, outer: h || u };
      }
      var Z = r.scopeGatherer = a.make({
        VariablePattern: function(u, h) {
          h.inner && li(h.inner, u);
        },
        AssignmentPattern: function(u, h, S) {
          S(u.left, h, "Pattern"), S(u.right, h.outer, "Expression");
        },
        AssignmentExpression: function(u, h, S) {
          u.left.type == "MemberExpression" ? S(u.left, h, "Expression") : S(u.left, M(false, h), "Pattern"), S(u.right, h, "Expression");
        },
        MemberPattern: function(u, h, S) {
          S(u, h.outer);
        },
        Function: function(u, h, S) {
          for (var I = u.scope = new lt(h, u), k = [], K = [], ie = 0; ie < u.params.length; ++ie) {
            var oe = u.params[ie];
            if (K.push(N2(oe)), oe.type == "Identifier")
              k.push(li(I, oe));
            else {
              var he = new _2();
              k.push(he), he.originNode = oe, S(oe, M(I), "Pattern");
            }
          }
          if (I.fnType = new De(u.id && u.id.name, new _2(), k, K, c, u.generator, u.async), I.fnType.originNode = u, u.id) {
            var ye = u.type == "FunctionDeclaration";
            li(ye ? h : I, u.id);
          }
          S(u.body, I, u.expression ? "Expression" : "Statement");
        },
        BlockStatement: function(u, h, S) {
          !u.scope && u.body.some(b) && (h = u.scope = new lt(h, u, true)), a.base.BlockStatement(u, h, S);
        },
        CatchClause: function(u, h, S) {
          if (u.param)
            if (h = u.scope = new lt(h, u, false, true), u.param.type == "Identifier") {
              var I = li(h, u.param);
              S(u.body, h, "Statement");
              var k = q.definitions.ecmascript;
              k && I.isEmpty() && P(k["Error.prototype"]).propagate(I, L);
            } else
              S(u.param, M(h), "Pattern");
        },
        VariableDeclaration: function(u, h, S) {
          for (var I = u.kind == "var" ? vt(h) : h, k = 0; k < u.declarations.length; ++k) {
            var K = u.declarations[k];
            S(K.id, M(I, h), "Pattern"), K.init && S(K.init, h, "Expression");
          }
        },
        ClassDeclaration: function(u, h, S) {
          u.id && li(h, u.id), u.superClass && S(u.superClass, h, "Expression");
          for (var I = 0; I < u.body.body.length; I++)
            S(u.body.body[I], h);
        },
        ForInStatement: function(u, h, S) {
          !u.scope && b(u.left) && (h = u.scope = new lt(h, u, true)), a.base.ForInStatement(u, h, S);
        },
        ForStatement: function(u, h, S) {
          !u.scope && u.init && b(u.init) && (h = u.scope = new lt(h, u, true)), a.base.ForStatement(u, h, S);
        },
        ImportDeclaration: function(u, h) {
          for (var S = 0; S < u.specifiers.length; S++)
            li(h, u.specifiers[S].local);
        }
      });
      Z.ForOfStatement = Z.ForInStatement;
      function X(u) {
        u.scope && (u.scope = null);
      }
      var ee = {
        BlockStatement: X,
        Function: X,
        CatchClause: X,
        ForInStateMent: X,
        ForStatement: X
      };
      r.clearScopes = function(u) {
        a.simple(u, ee);
      };
      var ne = r.propName = function(u, h) {
        var S = u.property || u.key;
        if (!u.computed && S.type == "Identifier")
          return S.name;
        if (S.type == "Literal") {
          if (typeof S.value == "string")
            return S.value;
          if (typeof S.value == "number")
            return String(S.value);
        }
        if (h) {
          var I = ce(pe(S, h));
          if (I)
            return u.propName = I;
        } else if (u.propName)
          return u.propName;
        return "<i>";
      };
      function ce(u) {
        var h = u.getSymbolType();
        if (h)
          return h.asPropName();
      }
      function Se(u) {
        switch (u) {
          case "+":
          case "-":
          case "~":
            return q.num;
          case "!":
            return q.bool;
          case "typeof":
            return q.str;
          case "void":
          case "delete":
            return c;
        }
      }
      function Ae(u) {
        switch (u) {
          case "==":
          case "!=":
          case "===":
          case "!==":
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "in":
          case "instanceof":
            return true;
        }
      }
      function Ie(u) {
        if (u.regex)
          return P(q.protos.RegExp);
        switch (typeof u.value) {
          case "boolean":
            return q.bool;
          case "number":
            return q.num;
          case "string":
            return q.str;
          case "object":
          case "function":
            return u.value ? P(q.protos.RegExp) : c;
        }
      }
      function je(u, h) {
        if (u == h || h == c)
          return u;
        if (u == c)
          return h;
        var S = new _2();
        return u.propagate(S), h.propagate(S), S;
      }
      function Ge(u, h) {
        for (var S = 0; S < u.params.length; S++) {
          var I = u.params[S];
          I.type != "Identifier" && mt(I, h, u.scope.fnType.args[S]);
        }
      }
      function qe(u, h) {
        return h.hasProp(u.name) || q.topScope.defProp(u.name, u);
      }
      var er = r.inferPatternVisitor = {
        Identifier: function(u, h, S) {
          S.propagate(qe(u, h));
        },
        MemberExpression: function(u, h, S) {
          var I = pe(u.object, h), k = ne(u, h);
          I.propagate(new H(k, S, u.property));
        },
        RestElement: function(u, h, S) {
          mt(u.argument, h, new Ce(S));
        },
        ObjectPattern: function(u, h, S) {
          for (var I = 0; I < u.properties.length; ++I) {
            var k = u.properties[I];
            k.type != "RestElement" && mt(k.value, h, S.getProp(ne(k)));
          }
        },
        ArrayPattern: function(u, h, S) {
          for (var I = 0; I < u.elements.length; I++)
            u.elements[I] && mt(u.elements[I], h, S.getProp(String(I)));
        },
        AssignmentPattern: function(u, h, S) {
          mt(u.left, h, je(S, pe(u.right, h)));
        }
      };
      function mt(u, h, S) {
        var I = er[u.type];
        I && I(u, h, S);
      }
      function Rt(u) {
        var h = vt(u);
        return h.fnType ? h.fnType.self : h;
      }
      function Nt(u) {
        !u.isEmpty() || !u.propertyOf || (u.propertyOf.getProp(u.propertyName).addType(new fe(), D), Nt(u.propertyOf));
      }
      function ct(u, h, S) {
        !S && u.id && (S = u.id.name);
        var I = q.protos.Object, k, K;
        if (u.superClass)
          if (u.superClass.type == "Literal" && u.superClass.value == null)
            I = null;
          else {
            var ie = pe(u.superClass, h), oe;
            k = ie.getFunctionType(), k && (oe = k.getProp("prototype").getObjType()) ? I = oe : (k = ie, K = ie.getProp("prototype"));
          }
        var he = new fe(I, S && S + ".prototype");
        return K && K.propagate(new w(he)), St2(k, K || I, function() {
          for (var ye, We = u.body.body, Me = 0; Me < We.length; Me++)
            We[Me].kind == "constructor" && (ye = We[Me].value);
          var Ct2 = u.objType = ye ? pe(ye, h) : new De(S, c, [], null, c);
          Ct2.originNode = u.id || ye || u;
          var wt = P(he, Ct2);
          Ct2.self.addType(wt), Ct2.defProp("prototype", u).addType(he);
          for (var Me = 0; Me < We.length; Me++) {
            var Mt = We[Me], Yt;
            if (Mt.kind != "constructor") {
              var Ln = ne(Mt, h);
              Ln == "<i>" || Mt.kind == "set" ? Yt = c : (Yt = (Mt.static ? Ct2 : he).defProp(Ln, Mt.key), Yt.initializer = true, Mt.kind == "get" && (Yt = new Y(wt, [], null, Yt))), pe(Mt.value, h, Yt);
              var Qc = Yt.getFunctionType();
              Qc && Qc.self.addType(wt);
            }
          }
          return Ct2;
        });
      }
      function hr(u, h, S) {
        var I = u.length > 1 && u.length < 6;
        if (I) {
          for (var k = true, K, ie = 0; ie < u.length; ie++) {
            var oe = u[ie];
            oe ? oe.type != "Literal" || K && K != typeof oe.value ? k = false : K = typeof oe.value : I = false;
          }
          k && (I = false);
        }
        if (I) {
          for (var he = [], ie = 0; ie < u.length; ++ie)
            he.push(S(u[ie], h));
          return new Ce(he);
        } else {
          if (u.length < 2)
            return new Ce(u[0] && S(u[0], h));
          for (var ye = new _2(), ie = 0; ie < u.length; ie++)
            u[ie] && S(u[ie], h).propagate(ye);
          return new Ce(ye);
        }
      }
      function rt(u) {
        return function(h, S, I, k) {
          var K = u(h, S, k);
          return I && K.propagate(I), K;
        };
      }
      function xt(u) {
        return function(h, S, I, k) {
          return I || (I = new _2()), u(h, S, I, k), I;
        };
      }
      var ui = r.inferExprVisitor = {
        ArrayExpression: rt(function(u, h) {
          return hr(u.elements, h, pe);
        }),
        ObjectExpression: rt(function(u, h, S) {
          for (var I = q.protos.Object, k, K = 0; K < u.properties.length; ++K) {
            var ie = u.properties[K];
            if (ie.type != "SpreadElement" && ie.key.name == "__proto__")
              if (ie.value.type == "Literal" && ie.value.value == null)
                I = null;
              else {
                var oe = pe(ie.value, h), he = oe.getObjType();
                he ? I = he : k = oe;
              }
          }
          var ye = u.objType = new fe(I, S);
          return k && k.propagate(new w(ye)), ye.originNode = u, St2(null, k || I, function() {
            for (var We = 0; We < u.properties.length; ++We) {
              var Me = u.properties[We], Ct2 = Me.key;
              if (!(Me.type == "SpreadElement" || yt(Me.key.name))) {
                var wt = ne(Me, h), Mt;
                if (wt == "<i>" || Me.kind == "set")
                  Mt = c;
                else {
                  Mt = ye.defProp(wt, Ct2);
                  var Yt = Mt;
                  Yt.initializer = true, Me.kind == "get" && (Mt = new Y(ye, [], null, Yt));
                }
                pe(Me.value, h, Mt, wt), Me.value.type == "FunctionExpression" && Me.value.scope.fnType.self.addType(ye, x);
              }
            }
          }), ye;
        }),
        FunctionExpression: rt(function(u, h, S) {
          var I = u.scope, k = I.fnType;
          return S && !k.name && (k.name = S), Ge(u, I), u.expression ? pe(u.body, I, I.fnType.retval = new _2()) : a.recursive(u.body, I, null, zt, "Statement"), u.type == "ArrowFunctionExpression" && Rt(h).propagate(k.self), qi(u, k) || Ca(k), u.id && I.getProp(u.id.name).addType(k), k;
        }),
        ClassExpression: rt(ct),
        SequenceExpression: rt(function(u, h) {
          for (var S = 0, I = u.expressions.length - 1; S < I; ++S)
            pe(u.expressions[S], h, c);
          return pe(u.expressions[I], h);
        }),
        UnaryExpression: rt(function(u, h) {
          return pe(u.argument, h, c), Se(u.operator);
        }),
        UpdateExpression: rt(function(u, h) {
          return pe(u.argument, h, c), q.num;
        }),
        BinaryExpression: rt(function(u, h) {
          if (u.operator == "+") {
            var S = pe(u.left, h), I = pe(u.right, h);
            if (S.hasType(q.str) || I.hasType(q.str))
              return q.str;
            if (S.hasType(q.num) && I.hasType(q.num))
              return q.num;
            var k = new _2();
            return S.propagate(new y2(I, k)), I.propagate(new y2(S, k)), k;
          } else
            return pe(u.left, h, c), pe(u.right, h, c), Ae(u.operator) ? q.bool : q.num;
        }),
        AssignmentExpression: rt(function(u, h, S) {
          var I, k;
          if (u.left.type == "MemberExpression" ? (k = ne(u.left, h), S || (S = u.left.object.type == "Identifier" ? u.left.object.name + "." + k : k)) : !S && u.left.type == "Identifier" && (S = u.left.name), u.operator && u.operator != "=" && u.operator != "+=" ? (pe(u.right, h, c), I = q.num) : I = pe(u.right, h, null, S), u.left.type == "MemberExpression") {
            var K = pe(u.left.object, h);
            if (k == "prototype" && xr(h, 20), k == "<i>") {
              var ie = u.left.property.name, oe = h.props[ie], he = oe && oe.iteratesOver;
              if (he) {
                xr(h, 20);
                var ye = u.right.type == "MemberExpression" && u.right.computed && u.right.property.name == ie;
                return he.forAllProps(function(We, Me, Ct2) {
                  Ct2 && We != "prototype" && We != "<i>" && K.propagate(new H(We, ye ? Me : c));
                }), I;
              }
            }
            K.propagate(new H(k, I, u.left.property)), Nt(K), u.right.type == "FunctionExpression" && K.propagate(u.right.scope.fnType.self, x);
          } else
            mt(u.left, h, I);
          return I;
        }),
        LogicalExpression: xt(function(u, h, S) {
          pe(u.left, h, S), pe(u.right, h, S);
        }),
        ConditionalExpression: xt(function(u, h, S) {
          pe(u.test, h, c), pe(u.consequent, h, S), pe(u.alternate, h, S);
        }),
        NewExpression: xt(function(u, h, S, I) {
          u.callee.type == "Identifier" && u.callee.name in h.props && xr(h, 20);
          for (var k = 0, K = []; k < u.arguments.length; ++k)
            K.push(pe(u.arguments[k], h));
          var ie = pe(u.callee, h), oe = new _2();
          ie.propagate(new m(oe, I && /\.prototype$/.test(I))), oe.propagate(S, O), ie.propagate(new Y(oe, K, u.arguments, new C(S)));
        }),
        CallExpression: xt(function(u, h, S) {
          for (var I = 0, k = []; I < u.arguments.length; ++I)
            k.push(pe(u.arguments[I], h));
          var K = vt(h).fnType;
          if (u.callee.type == "MemberExpression") {
            var ie = pe(u.callee.object, h), oe = ne(u.callee, h);
            K && (oe == "call" || oe == "apply") && K.args.indexOf(ie) > -1 && xr(h, 30), ie.propagate(new E(oe, k, u.arguments, S));
          } else if (u.callee.type == "Super" && q.curSuperCtor)
            u.callee.superType = q.curSuperCtor, q.curSuperCtor.propagate(new Y(Rt(h), k, u.arguments, S)), Rt(h).propagate(S, O);
          else {
            var he = pe(u.callee, h);
            K && K.args.indexOf(he) > -1 && xr(h, 30);
            var ye = he.getFunctionType();
            ye && ye.instantiateScore && K && xr(h, ye.instantiateScore / 5), he.propagate(new Y(q.topScope, k, u.arguments, S));
          }
        }),
        AwaitExpression: xt(function(u, h, S, I) {
          var k = pe(u.argument, h, null, I), K = k.getType();
          K && K.constructor == fe && K.name == "Promise" ? K.hasProp(":t") && K.getProp(":t").propagate(S) : k.propagate(S);
        }),
        MemberExpression: xt(function(u, h, S) {
          var I = ne(u), k;
          if (I == "<i>") {
            var K = pe(u.property, h), ie = ce(K);
            ie ? I = u.propName = ie : K.hasType(q.num) || (k = g);
          }
          pe(u.object, h).getProp(I).propagate(S, k);
        }),
        Identifier: rt(function(u, h) {
          if (u.name == "arguments") {
            var S = vt(h, false);
            S.fnType && !(u.name in S.props) && S.defProp(u.name, S.fnType.originNode).addType(new Ce(S.fnType.arguments = new _2()));
          }
          return h.getProp(u.name);
        }),
        ThisExpression: rt(function(u, h) {
          return Rt(h);
        }),
        Super: rt(function(u) {
          return u.superType = q.curSuper || c;
        }),
        Literal: rt(function(u) {
          return Ie(u);
        }),
        TemplateLiteral: rt(function(u, h) {
          for (var S = 0; S < u.expressions.length; ++S)
            pe(u.expressions[S], h, c);
          return q.str;
        }),
        TaggedTemplateExpression: xt(function(u, h, S) {
          for (var I = [new Ce(q.str)], k = 0; k < u.quasi.expressions.length; ++k)
            I.push(pe(u.quasi.expressions[k], h));
          pe(u.tag, h, new Y(q.topScope, I, u.quasi.expressions, S));
        }),
        YieldExpression: rt(function(u, h) {
          var S = c, I = vt(h).fnType;
          return I && (I.retval == c && (I.retval = new _2()), I.yieldval || (I.yieldval = new _2()), S = I.retval), u.argument && (u.delegate ? pe(u.argument, h, new E(
            "next",
            [],
            null,
            new G("value", S)
          )) : pe(u.argument, h, S)), I ? I.yieldval : c;
        })
      };
      ui.ArrowFunctionExpression = ui.FunctionExpression;
      function pe(u, h, S, I) {
        var k = ui[u.type];
        return k ? k(u, h, S, I) : c;
      }
      function Dt(u) {
        return u.type == "VariableDeclaration" ? u.declarations[0].id : u;
      }
      var zt = r.inferWrapper = a.make({
        Expression: function(u, h) {
          pe(u, u.scope || h, c);
        },
        ObjectExpression: function(u, h) {
          pe(u, u.scope || h, c);
        },
        FunctionDeclaration: function(u, h, S) {
          var I = u.scope, k = I.fnType;
          Ge(u, I), S(u.body, I, "Statement"), qi(u, k) || Ca(k), u.id && h.getProp(u.id.name).addType(k);
        },
        Statement: function(u, h, S) {
          S(u, u.scope || h);
        },
        ExportDefaultDeclaration: function(u, h, S) {
          S(u.declaration, u.scope || h);
        },
        VariableDeclaration: function(u, h) {
          for (var S = 0; S < u.declarations.length; ++S) {
            var I = u.declarations[S];
            if (I.id.type == "Identifier") {
              var k = h.getProp(I.id.name);
              I.init && pe(I.init, h, k, I.id.name);
            } else
              I.init && mt(I.id, h, pe(I.init, h));
          }
        },
        ClassDeclaration: function(u, h) {
          u.id ? h.getProp(u.id.name).addType(ct(u, h, u.id.name)) : ct(u, h);
        },
        ReturnStatement: function(u, h) {
          if (u.argument) {
            var S = c, I = vt(h).fnType;
            I && (I.retval == c && (I.retval = new _2()), S = I.retval), pe(u.argument, h, S);
          }
        },
        ForInStatement: function(u, h, S) {
          var I = pe(u.right, h);
          if (u.right.type == "Identifier" && u.right.name in h.props || u.right.type == "MemberExpression" && u.right.property.name == "prototype") {
            xr(h, 5);
            var k = Dt(u.left);
            k.type == "Identifier" ? (k.name in h.props && (h.getProp(k.name).iteratesOver = I), I.getProp("<i>").propagate(qe(k, h))) : mt(k, h, I.getProp("<i>"));
          }
          S(u.body, h, "Statement");
        },
        ForOfStatement: function(u, h, S) {
          var I = Dt(u.left), k;
          I.type == "Identifier" ? k = qe(I, h) : mt(I, h, k = new _2()), u.await ? pe(u.right, h, new E(
            ":Symbol.asyncIterator",
            [],
            null,
            new E(
              "next",
              [],
              null,
              new G(
                ":t",
                new G("value", k)
              )
            )
          )) : pe(u.right, h, new E(
            ":Symbol.iterator",
            [],
            null,
            new E(
              "next",
              [],
              null,
              new G("value", k)
            )
          )), S(u.body, h, "Statement");
        }
      }), Ji = r.parse = function(u, h, S) {
        (!h || Array.isArray(h)) && (h = S);
        var I;
        try {
          I = i.parse(u, h);
        } catch {
          I = n.parse(u, h);
        }
        return I;
      };
      r.analyze = function(u, h, S) {
        typeof u == "string" && (u = Ji(u)), h || (h = "file#" + q.origins.length), r.addOrigin(q.curOrigin = h), S || (S = q.topScope), q.startAnalysis(), a.recursive(u, S, null, Z), q.parent && q.parent.signal("preInfer", u, S), a.recursive(u, S, null, zt), q.parent && q.parent.signal("postInfer", u, S), q.curOrigin = null;
      }, r.purge = function(u, h, S) {
        var I = vn(u, h, S);
        ++q.purgeGen, q.topScope.purge(I);
        for (var k in q.props) {
          for (var K = q.props[k], ie = 0; ie < K.length; ++ie) {
            var oe = K[ie], he = oe.props[k];
            (!he || I(he, he.originNode)) && K.splice(ie--, 1);
          }
          K.length || delete q.props[k];
        }
      };
      function vn(u, h, S) {
        var I = Array.isArray(u);
        return I && u.length == 1 && (u = u[0], I = false), I ? S == null ? function(k) {
          return u.indexOf(k.origin) > -1;
        } : function(k, K) {
          return K && K.start >= h && K.end <= S && u.indexOf(k.origin) > -1;
        } : S == null ? function(k) {
          return k.origin == u;
        } : function(k, K) {
          return K && K.start >= h && K.end <= S && k.origin == u;
        };
      }
      _2.prototype.purge = function(u) {
        if (this.purgeGen != q.purgeGen) {
          this.purgeGen = q.purgeGen;
          for (var h = 0; h < this.types.length; ++h) {
            var S = this.types[h];
            u(S, S.originNode) ? this.types.splice(h--, 1) : S.purge(u);
          }
          if (this.types.length || (this.maxWeight = 0), this.forward)
            for (var h = 0; h < this.forward.length; ++h) {
              var I = this.forward[h];
              u(I) ? (this.forward.splice(h--, 1), this.props && (this.props = null)) : I.purge && I.purge(u);
            }
        }
      }, c.purge = function() {
      }, fe.prototype.purge = function(u) {
        if (this.purgeGen == q.purgeGen)
          return true;
        this.purgeGen = q.purgeGen;
        for (var h in this.props) {
          var S = this.props[h];
          u(S, S.originNode) && this.removeProp(h), S.purge(u);
        }
      }, De.prototype.purge = function(u) {
        if (!fe.prototype.purge.call(this, u)) {
          this.self.purge(u), this.retval.purge(u);
          for (var h = 0; h < this.args.length; ++h)
            this.args[h].purge(u);
        }
      };
      function TT(u) {
        Cn = true;
        var h = Je(u);
        if (h)
          for (var S = 0; S < h.length; ++S) {
            var I = h[S].getProp(u);
            if (!I.isEmpty())
              return I;
          }
        return c;
      }
      function Uc(u, h, S) {
        var I = q.definitions.ecmascript, k = new fe(true);
        k.defProp("done").addType(q.bool), h.propagate(k.defProp("value"));
        var K = k;
        S && I && (K = new fe(I["Promise.prototype"]), K.getType().propagate(new H(":t", k)));
        var ie = new De(null, c, u ? [u] : [], u ? ["?"] : [], K), oe = new fe(I ? S ? I.async_generator_prototype : I.generator_prototype : true);
        return oe.defProp("next").addType(ie), oe;
      }
      function wc(u, h) {
        return u.generator ? u.computeRet ? Uc(u.yieldval, h, u.async) : (u.generator === true && (u.generator = Uc(u.yieldval, h, u.async)), u.generator) : h;
      }
      function Mc(u, h, S) {
        var I = Ut(u, S).getFunctionType();
        if (!I)
          return c;
        var k = I.retval;
        if (I.computeRet) {
          for (var K = 0, ie = []; K < h.length; ++K)
            ie.push(Ut(h[K], S));
          var oe = c;
          u.type == "MemberExpression" && (oe = Ut(u.object, S)), k = I.computeRet(oe, ie, h);
        }
        return wc(I, k);
      }
      var La = r.typeFinder = {
        ArrayExpression: function(u, h) {
          return hr(u.elements, h, Ut);
        },
        ObjectExpression: function(u) {
          return u.objType;
        },
        ClassDeclaration: function(u) {
          return u.objType;
        },
        ClassExpression: function(u) {
          return u.objType;
        },
        FunctionDeclaration: function(u) {
          return u.scope.fnType;
        },
        FunctionExpression: function(u) {
          return u.scope.fnType;
        },
        ArrowFunctionExpression: function(u) {
          return u.scope.fnType;
        },
        SequenceExpression: function(u, h) {
          return Ut(u.expressions[u.expressions.length - 1], h);
        },
        UnaryExpression: function(u) {
          return Se(u.operator);
        },
        UpdateExpression: function() {
          return q.num;
        },
        BinaryExpression: function(u, h) {
          if (Ae(u.operator))
            return q.bool;
          if (u.operator == "+") {
            var S = Ut(u.left, h), I = Ut(u.right, h);
            if (S.hasType(q.str) || I.hasType(q.str))
              return q.str;
          }
          return q.num;
        },
        AssignmentExpression: function(u, h) {
          return Ut(u.right, h);
        },
        LogicalExpression: function(u, h) {
          var S = Ut(u.left, h);
          return S.isEmpty() ? Ut(u.right, h) : S;
        },
        ConditionalExpression: function(u, h) {
          var S = Ut(u.consequent, h);
          return S.isEmpty() ? Ut(u.alternate, h) : S;
        },
        NewExpression: function(u, h) {
          var S = Ut(u.callee, h).getFunctionType(), I = S && S.getProp("prototype").getObjType();
          return I ? P(I, S) : c;
        },
        CallExpression: function(u, h) {
          return Mc(u.callee, u.arguments, h);
        },
        MemberExpression: function(u, h) {
          var S = ne(u), I = Ut(u.object, h).getType();
          return I ? I.getProp(S) : S == "<i>" ? c : TT(S);
        },
        MethodDefinition: function(u) {
          var h = ne(u), S = Rt(u.value.scope).getType();
          return S ? S.getProp(h) : c;
        },
        Identifier: function(u, h) {
          return h.hasProp(u.name) || c;
        },
        ThisExpression: function(u, h) {
          return Rt(h);
        },
        Literal: function(u) {
          return Ie(u);
        },
        Super: rt(function(u) {
          return u.superType;
        }),
        TemplateLiteral: function() {
          return q.str;
        },
        TaggedTemplateExpression: function(u, h) {
          return Mc(u.tag, u.quasi.expressions, h);
        },
        YieldExpression: function(u, h) {
          var S = vt(h).fnType;
          return S ? S.yieldval : c;
        }
      };
      function Ut(u, h) {
        var S = La[u.type];
        return S ? S(u, h) : c;
      }
      var Eo2 = r.searchVisitor = a.make({
        Function: function(u, h, S) {
          a.base.Function(u, u.scope, S);
        },
        CatchClause: function(u, h, S) {
          a.base.CatchClause(u, u.scope, S);
        },
        Property: function(u, h, S) {
          u.computed && S(u.key, h, "Expression"), u.key != u.value && S(u.value, h, "Expression");
        },
        Statement: function(u, h, S) {
          S(u, u.scope || h);
        },
        ImportSpecifier: function(u, h, S) {
          S(u.local, h);
        },
        ImportDefaultSpecifier: function(u, h, S) {
          S(u.local, h);
        },
        ImportNamespaceSpecifier: function(u, h, S) {
          S(u.local, h);
        }
      }), kc = r.searchExprVisitor = a.make({
        MemberExpression: function(u, h, S) {
          S(u.object, h, "Expression"), u.computed && S(u.property, h, "Expression");
        },
        Property: function(u, h, S) {
          u.computed && S(u.key, h, "Expression"), S(u.value, h, "Expression");
        }
      }, Eo2);
      r.fullVisitor = a.make({
        MemberExpression: function(u, h, S) {
          S(u.object, h, "Expression"), S(u.property, h, u.computed ? "Expression" : null);
        },
        Property: function(u, h, S) {
          u.computed && S(u.key, h, "Expression"), S(u.value, h, "Expression");
        }
      }, Eo2), r.findExpressionAt = function(u, h, S, I, k) {
        var K = k || function(ie, oe) {
          return oe.type == "Identifier" && oe.name == "" ? false : La.hasOwnProperty(oe.type);
        };
        return a.findNodeAt(u, h, S, K, kc, I || q.topScope);
      }, r.findClosestExpression = function(u, h, S, I, k) {
        var K = k || function(ie, oe) {
          return h != null && oe.start > h || oe.type == "Identifier" && oe.name == "" ? false : La.hasOwnProperty(oe.type);
        };
        return a.findNodeAround(u, S, K, kc, I || q.topScope);
      }, r.findExpressionAround = function(u, h, S, I, k) {
        var K = k || function(ie, oe) {
          return h != null && oe.start > h || oe.type == "Identifier" && oe.name == "" ? false : La.hasOwnProperty(oe.type);
        };
        return a.findNodeAround(u, S, K, Eo2, I || q.topScope);
      }, r.expressionType = function(u) {
        return Ut(u.node, u.state);
      }, r.parentNode = function(u, h) {
        var S = [];
        function I(k, K, ie) {
          if (k.start <= u.start && k.end >= u.end) {
            var oe = S[S.length - 1];
            if (k == u)
              throw { found: oe };
            oe != k && S.push(k), a.base[ie || k.type](k, K, I), oe != k && S.pop();
          }
        }
        try {
          I(h, null);
        } catch (k) {
          if (k.found)
            return k.found;
          throw k;
        }
      };
      var xa = r.findTypeFromContext = {
        ArrayExpression: function(u, h, S) {
          return S(u, true).getProp("<i>");
        },
        ObjectExpression: function(u, h, S) {
          for (var I = 0; I < u.properties.length; ++I) {
            var k = h.properties[I];
            if (k.value == h)
              return S(u, true).getProp(ne(k));
          }
        },
        UnaryExpression: function(u) {
          return Se(u.operator);
        },
        UpdateExpression: function() {
          return q.num;
        },
        BinaryExpression: function(u) {
          return Ae(u.operator) ? q.bool : q.num;
        },
        AssignmentExpression: function(u, h, S) {
          return S(u.left);
        },
        LogicalExpression: function(u, h, S) {
          return S(u, true);
        },
        ConditionalExpression: function(u, h, S) {
          if (u.consequent == h || u.alternate == h)
            return S(u, true);
        },
        CallExpression: function(u, h, S) {
          for (var I = 0; I < u.arguments.length; I++) {
            var k = u.arguments[I];
            if (k == h) {
              var K = S(u.callee).getFunctionType();
              if (K instanceof De)
                return K.args[I];
              break;
            }
          }
        },
        ReturnStatement: function(u, h, S) {
          var I = a.findNodeAround(h.sourceFile.ast, h.start - 1, "Function");
          if (I) {
            var k = I.node.type != "FunctionDeclaration" ? S(I.node, true).getFunctionType() : I.node.scope.fnType;
            if (k)
              return k.retval.getType();
          }
        },
        VariableDeclarator: function(u, h, S) {
          if (u.init == h)
            return S(u.id);
        }
      };
      xa.NewExpression = xa.CallExpression, r.typeFromContext = function(u, h) {
        var S = r.parentNode(h.node, u), I = null;
        if (xa.hasOwnProperty(S.type)) {
          var k = xa[S.type];
          I = k && k(S, h.node, function(K, ie) {
            var oe = { node: K, state: h.state }, he = ie ? r.typeFromContext(u, oe) : r.expressionType(oe);
            return he || c;
          });
        }
        return I || r.expressionType(h);
      };
      var Cn = false;
      r.resetGuessing = function(u) {
        Cn = u;
      }, r.didGuess = function() {
        return Cn;
      }, r.forAllPropertiesOf = function(u, h) {
        u.gatherProperties(h, 0);
      }, r.findRefs = function(u, h, S, I, k) {
        function K(ie, oe, he) {
          var ye = he[he.length - 2];
          if (!(ye.type == "MemberExpression" && !ye.computed && ie.object) && !(ie.name != S || ie == u.id && u.type == "FunctionDeclaration") && ye.property !== ie) {
            for (var We = oe; We; We = We.prev)
              if (We == I && k(ie, oe, he), S in We.props)
                return;
          }
        }
        a.ancestor(
          u,
          { Identifier: K, VariablePattern: K },
          r.fullVisitor,
          h
        );
      };
      var ST = a.make({
        Function: function(u, h, S) {
          S(u.body, u.scope, u.expression ? "Expression" : "Statement");
        },
        Statement: function(u, h, S) {
          S(u, u.scope || h);
        }
      });
      r.findPropRefs = function(u, h, S, I, k) {
        for (; S && !S.props[I] && !(S.maybeProps && S.maybeProps[I]); )
          S = S.proto;
        if (!S)
          throw new Error("Couldn't locate property in the base object type.");
        function K(ie) {
          for (; ie && ie != S; ) {
            if (ie.props[I] || ie.maybeProps && ie.maybeProps[I])
              return false;
            ie = ie.proto;
          }
          return ie;
        }
        a.simple(u, {
          MemberExpression: function(ie, oe) {
            ie.computed || ne(ie) != I || K(Ut(ie.object, oe).getType()) && k(ie.property, oe);
          },
          ObjectExpression: function(ie, oe) {
            if (Ut(ie, oe).getType() == S)
              for (var he = 0; he < ie.properties.length; ++he)
                ne(ie.properties[he]) == I && k(ie.properties[he].key, oe);
          },
          MethodDefinition: function(ie) {
            ne(ie) == I && ie.value && K(Rt(ie.value.scope).getType()) && k(ie.key, ie.value.scope);
          }
        }, ST, h);
      };
      var mT = r.scopeAt = function(u, h, S) {
        var I = a.findNodeAround(u, h, function(k, K) {
          return K.scope;
        });
        return I ? I.node.scope : S || q.topScope;
      };
      r.forAllLocalsAt = function(u, h, S, I) {
        var k = mT(u, h, S);
        k.gatherProperties(I, 0);
      }, s = r.def = s.init({}, r);
    });
  }(Ba, Ba.exports)), Ba.exports;
}
(function(e, t) {
  (function(r, i) {
    return i(
      t,
      yP(),
      gd(),
      XE,
      Ad
    );
  })(Q2, function(r, i, n, a, s) {
    var o = /* @__PURE__ */ Object.create(null);
    r.registerPlugin = function(N2, b) {
      o[N2] = b;
    };
    var l = r.defaultOptions = {
      debug: false,
      async: false,
      getFile: function(N2, b) {
        this.async && b(null, null);
      },
      normalizeFilename: function(N2) {
        return N2;
      },
      defs: [],
      plugins: {},
      fetchTimeout: 1e3,
      dependencyBudget: 2e4,
      reuseInstances: true,
      stripCRs: false,
      ecmaVersion: 9,
      projectDir: "/",
      parent: null
    }, c = {
      completions: {
        takesFile: true,
        run: yt
      },
      properties: {
        run: De
      },
      type: {
        takesFile: true,
        run: It2
      },
      documentation: {
        takesFile: true,
        run: St2
      },
      definition: {
        takesFile: true,
        run: ba
      },
      refs: {
        takesFile: true,
        fullFile: true,
        run: Oo
      },
      rename: {
        takesFile: true,
        fullFile: true,
        run: Ca
      },
      files: {
        run: li
      }
    };
    r.defineQueryType = function(N2, b) {
      c[N2] = b;
    };
    function f(N2, b) {
      this.name = N2, this.parent = b, this.scope = this.text = this.ast = this.lineOffsets = null;
    }
    f.prototype.asLineChar = function(N2) {
      return y2(this, N2);
    };
    function p(N2, b) {
      var M = {
        directSourceFile: b,
        allowReturnOutsideFunction: true,
        allowImportExportEverywhere: true,
        ecmaVersion: N2.options.ecmaVersion,
        allowHashBang: true
      }, Z = N2.signalReturnFirst("preParse", b.text, M) || b.text, X = i.parse(Z, M);
      return N2.signal("postParse", X, Z), X;
    }
    var O = /[\uD800-\uDBFF]/g;
    function d2(N2, b, M) {
      N2.text = M.options.stripCRs ? b.replace(/\r\n/g, `
`) : b, N2.hasAstral = O.test(N2.text), i.withContext(M.cx, function() {
        N2.ast = p(M, N2);
      }), N2.lineOffsets = null;
    }
    var g = r.Server = function(N2) {
      this.cx = null, this.options = N2 || {};
      for (var b in l)
        N2.hasOwnProperty(b) || (N2[b] = l[b]);
      this.projectDir = N2.projectDir.replace(/\\/g, "/"), /\/$/.test(this.projectDir) || (this.projectDir += "/"), this.parent = N2.parent, this.handlers = /* @__PURE__ */ Object.create(null), this.files = [], this.fileMap = /* @__PURE__ */ Object.create(null), this.needsPurge = [], this.budgets = /* @__PURE__ */ Object.create(null), this.uses = 0, this.pending = 0, this.asyncError = null, this.mod = {}, this.defs = N2.defs.slice(0), this.plugins = /* @__PURE__ */ Object.create(null);
      for (var M in N2.plugins)
        N2.plugins.hasOwnProperty(M) && this.loadPlugin(M, N2.plugins[M]);
      this.reset();
    };
    g.prototype = n.mixin({
      addFile: function(N2, b, M) {
        M && !(M in this.fileMap) && (M = null), N2 in this.fileMap || (N2 = this.normalizeFilename(N2)), W(this, N2, M, b);
      },
      delFile: function(N2) {
        var b = this.findFile(N2);
        if (b) {
          this.needsPurge.push(b.name);
          for (var M = 0; M < this.files.length; M++)
            this.files[M] == b ? this.files.splice(M--, 1) : this.files[M].parent == N2 && (this.files[M].parent = null);
          delete this.fileMap[b.name];
        }
      },
      reset: function() {
        this.signal("reset"), this.cx = new i.Context(this.defs, this), this.uses = 0, this.budgets = /* @__PURE__ */ Object.create(null);
        for (var N2 = 0; N2 < this.files.length; ++N2) {
          var b = this.files[N2];
          b.scope && (i.clearScopes(b.ast), b.scope = null);
        }
        this.signal("postReset");
      },
      request: function(N2, b) {
        var M = Y(N2);
        if (M)
          return b(M);
        var Z = this;
        L(this, N2, function(X, ee) {
          b(X, ee), Z.uses > 40 && (Z.reset(), V(Z, null, function() {
          }));
        });
      },
      findFile: function(N2) {
        return this.fileMap[this.normalizeFilename(N2)];
      },
      flush: function(N2) {
        var b = this.cx;
        V(this, null, function(M) {
          if (M)
            return N2(M);
          i.withContext(b, N2);
        });
      },
      startAsyncAction: function() {
        ++this.pending;
      },
      finishAsyncAction: function(N2) {
        N2 && (this.asyncError = N2), --this.pending === 0 && this.signal("everythingFetched");
      },
      addDefs: function(N2, b) {
        b ? this.defs.unshift(N2) : this.defs.push(N2), this.cx && this.reset();
      },
      deleteDefs: function(N2) {
        for (var b = 0; b < this.defs.length; b++)
          if (this.defs[b]["!name"] == N2) {
            this.defs.splice(b, 1), this.cx && this.reset();
            return;
          }
      },
      loadPlugin: function(N2, b) {
        if (arguments.length == 1 && (b = this.options.plugins[N2] || true), !(N2 in this.plugins || !(N2 in o) || !b)) {
          this.plugins[N2] = true;
          var M = o[N2](this, b);
          if (M && (M.defs && this.addDefs(M.defs, M.loadFirst), M.passes))
            for (var Z in M.passes)
              M.passes.hasOwnProperty(Z) && this.on(Z, M.passes[Z]);
        }
      },
      normalizeFilename: function(N2) {
        var b = this.options.normalizeFilename(N2).replace(/\\/g, "/");
        return b.indexOf(this.projectDir) == 0 && (b = b.slice(this.projectDir.length)), b;
      }
    });
    function L(N2, b, M) {
      if (b.query && !c.hasOwnProperty(b.query.type))
        return M("No query type '" + b.query.type + "' defined");
      var Z = b.query;
      Z || M(null, {});
      var X = b.files || [];
      X.length && ++N2.uses;
      for (var ee = 0; ee < X.length; ++ee) {
        var ne = X[ee];
        ne.name = N2.normalizeFilename(ne.name), ne.type == "delete" ? N2.delFile(ne.name) : W(N2, ne.name, null, ne.type == "full" ? ne.text : null);
      }
      var ce = typeof b.timeout == "number" ? [b.timeout] : null;
      if (!Z) {
        V(N2, ce, function() {
        });
        return;
      }
      var Se = c[Z.type];
      if (Se.takesFile) {
        if (typeof Z.file != "string")
          return M(".query.file must be a string");
        /^#/.test(Z.file) || W(N2, Z.file, null);
      }
      V(N2, ce, function(Ae) {
        if (Ae)
          return M(Ae);
        var Ie = Se.takesFile && ae(N2, X, Z.file);
        if (Se.fullFile && Ie.type == "part")
          return M("Can't run a " + Z.type + " query on a file fragment");
        i.resetGuessing(), i.withContext(N2.cx, function() {
          var je, Ge = function() {
            je = Se.run(N2, Z, Ie);
          };
          try {
            ce ? i.withTimeout(ce[0], Ge) : Ge();
          } catch (qe) {
            return N2.options.debug && qe.name != "TernError" && console.error(qe.stack), M(qe);
          }
          M(null, je);
        });
      });
    }
    function D(N2, b) {
      return i.withContext(N2.cx, function() {
        b.scope = N2.cx.topScope, N2.signal("beforeLoad", b), i.analyze(b.ast, b.name, b.scope), N2.signal("afterLoad", b);
      }), b;
    }
    function W(N2, b, M, Z) {
      var X = N2.findFile(b);
      if (X) {
        Z != null && (X.scope && (N2.needsPurge.push(b), i.clearScopes(X.ast), X.scope = null), d2(X, Z, N2)), G(N2, X.parent) > G(N2, M) && (X.parent = M, X.excluded && (X.excluded = null));
        return;
      }
      var ee = new f(b, M);
      N2.files.push(ee), N2.fileMap[b] = ee, Z != null ? d2(ee, Z, N2) : N2.options.async ? (N2.startAsyncAction(), N2.options.getFile(b, function(ne, ce) {
        d2(ee, ce || "", N2), N2.finishAsyncAction(ne);
      })) : d2(ee, N2.options.getFile(b) || "", N2);
    }
    function x(N2, b, M) {
      var Z = function() {
        N2.off("everythingFetched", Z), clearTimeout(X), V(N2, b, M);
      };
      N2.on("everythingFetched", Z);
      var X = setTimeout(Z, N2.options.fetchTimeout);
    }
    function V(N2, b, M) {
      if (N2.pending)
        return x(N2, b, M);
      var Z = N2.fetchError;
      if (Z)
        return N2.fetchError = null, M(Z);
      N2.needsPurge.length > 0 && i.withContext(N2.cx, function() {
        i.purge(N2.needsPurge), N2.needsPurge.length = 0;
      });
      for (var X = true, ee = 0; ee < N2.files.length; ) {
        for (var ne = []; ee < N2.files.length; ++ee) {
          var ce = N2.files[ee];
          ce.text == null ? X = false : ce.scope == null && !ce.excluded && ne.push(ce);
        }
        ne.sort(function(Ie, je) {
          return G(N2, Ie.parent) - G(N2, je.parent);
        });
        for (var Se = 0; Se < ne.length; Se++) {
          var ce = ne[Se];
          if (ce.parent && !re(N2, ce))
            ce.excluded = true;
          else if (b) {
            var Ae = +/* @__PURE__ */ new Date();
            try {
              i.withTimeout(b[0], function() {
                D(N2, ce);
              });
            } catch (je) {
              if (je instanceof i.TimedOut)
                return M(je);
              throw je;
            }
            b[0] -= +/* @__PURE__ */ new Date() - Ae;
          } else
            D(N2, ce);
        }
      }
      X ? M() : x(N2, b, M);
    }
    function _2(N2) {
      var b = N2.indexOf(`
`);
      return b < 0 ? N2 : N2.slice(0, b);
    }
    function $(N2, b, M) {
      var Z = Math.max(0, M - 500), X = null;
      if (!/^\s*$/.test(N2))
        for (; ; ) {
          var ee = b.indexOf(N2, Z);
          if (ee < 0 || ee > M + 500)
            break;
          (X == null || Math.abs(X - M) > Math.abs(ee - M)) && (X = ee), Z = ee + N2.length;
        }
      return X;
    }
    function z(N2) {
      for (var b = 0; N2; ++b, N2 = N2.prev)
        ;
      return b;
    }
    function F(N2) {
      var b = new Error(N2);
      return b.name = "TernError", b;
    }
    function ae(N2, b, M) {
      var Z = M.match(/^#(\d+)$/);
      if (!Z)
        return N2.findFile(M);
      var X = b[Z[1]];
      if (!X || X.type == "delete")
        throw F("Reference to unknown file " + M);
      if (X.type == "full")
        return N2.fileMap[X.name];
      var ee = X.backing = N2.fileMap[X.name], ne = R(ee, X.offsetLines == null ? X.offset : { line: X.offsetLines, ch: 0 }, true), ce = _2(X.text), Se = $(ce, ee.text, ne), Ae = Se ?? Math.max(0, ee.text.lastIndexOf(`
`, ne)), Ie, je;
      return i.withContext(N2.cx, function() {
        i.purge(X.name, Ae, Ae + X.text.length);
        var Ge = X.text, qe;
        if (qe = Ge.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
          var er = s.findNodeAround(X.backing.ast, Ae, "ObjectExpression");
          er && er.node.objType && (Ie = { type: er.node.objType, prop: qe[2] || qe[1] });
        }
        if (Se && (qe = ce.match(/^(.*?)\bfunction\b/))) {
          for (var mt = qe[1].length, Rt = "", Nt = 0; Nt < mt; ++Nt)
            Rt += " ";
          X.text = Rt + Ge.slice(mt), je = true;
        }
        var ct = i.scopeAt(ee.ast, Ae, ee.scope), hr = i.scopeAt(ee.ast, Ae + Ge.length, ee.scope), rt = X.scope = z(ct) < z(hr) ? hr : ct;
        X.ast = p(N2, X), i.analyze(X.ast, X.name, rt);
        e:
          if (Ie || je) {
            var xt = i.scopeAt(X.ast, ce.length, ct);
            if (!xt.fnType)
              break e;
            if (Ie) {
              var ui = Ie.type.getProp(Ie.prop);
              ui.addType(xt.fnType);
            } else if (je) {
              var pe = i.scopeAt(ee.ast, Ae + ce.length, ee.scope);
              if (pe == ct || !pe.fnType)
                break e;
              var Dt = pe.fnType, zt = xt.fnType;
              if (!zt || zt.name != Dt.name && Dt.name)
                break e;
              for (var Nt = 0, Ji = Math.min(Dt.args.length, zt.args.length); Nt < Ji; ++Nt)
                Dt.args[Nt].propagate(zt.args[Nt]);
              Dt.self.propagate(zt.self), zt.retval.propagate(Dt.retval);
            }
          }
      }), X;
    }
    function U(N2) {
      var b = 0;
      return s.simple(N2, { Expression: function() {
        ++b;
      } }), b;
    }
    function G(N2, b) {
      for (var M = 0; b; )
        b = N2.fileMap[b].parent, ++M;
      return M;
    }
    function H(N2, b) {
      for (; ; ) {
        var M = N2.fileMap[b.parent];
        if (!M.parent)
          break;
        b = M;
      }
      return b.name;
    }
    function re(N2, b) {
      var M = H(N2, b), Z = U(b.ast), X = N2.budgets[M];
      return X == null && (X = N2.budgets[M] = N2.options.dependencyBudget), X < Z ? false : (N2.budgets[M] = X - Z, true);
    }
    function B(N2) {
      return typeof N2 == "number" || typeof N2 == "object" && typeof N2.line == "number" && typeof N2.ch == "number";
    }
    function Y(N2) {
      if (N2.query) {
        if (typeof N2.query.type != "string")
          return ".query.type must be a string";
        if (N2.query.start && !B(N2.query.start))
          return ".query.start must be a position";
        if (N2.query.end && !B(N2.query.end))
          return ".query.end must be a position";
      }
      if (N2.files) {
        if (!Array.isArray(N2.files))
          return "Files property must be an array";
        for (var b = 0; b < N2.files.length; ++b) {
          var M = N2.files[b];
          if (typeof M != "object")
            return ".files[n] must be objects";
          if (typeof M.name != "string")
            return ".files[n].name must be a string";
          if (M.type == "delete")
            continue;
          if (typeof M.text != "string")
            return ".files[n].text must be a string";
          if (M.type == "part") {
            if (!B(M.offset) && typeof M.offsetLines != "number")
              return ".files[n].offset must be a position";
          } else if (M.type != "full")
            return '.files[n].type must be "full" or "part"';
        }
      }
    }
    var E = 25;
    function m(N2, b, M) {
      var Z = b + M, X;
      if (N2.hasAstral)
        for (O.lastIndex = b; (X = O.exec(N2.text)) && X.index < Z; )
          Z++;
      return Z;
    }
    function P(N2, b) {
      for (var M = N2.text, Z = N2.lineOffsets || (N2.lineOffsets = [0]), ee = 0, ne = 0, X = Math.min(Math.floor(b / E), Z.length - 1), ee = Z[X], ne = X * E; ne < b; ) {
        if (++ne, ee = M.indexOf(`
`, ee) + 1, ee === 0)
          return null;
        ne % E === 0 && Z.push(ee);
      }
      return ee;
    }
    var R = r.resolvePos = function(N2, b, M) {
      if (typeof b != "number") {
        var Z = P(N2, b.line);
        if (Z == null)
          if (M)
            b = N2.text.length;
          else
            throw F("File doesn't contain a line " + b.line);
        else
          b = m(N2, Z, b.ch);
      } else
        b = m(N2, 0, b);
      if (b > N2.text.length)
        if (M)
          b = N2.text.length;
        else
          throw F("Position " + b + " is outside of file.");
      return b;
    };
    function A(N2, b, M) {
      var Z = M - b, X;
      if (N2.hasAstral)
        for (O.lastIndex = b; (X = O.exec(N2.text)) && X.index < M; )
          Z--;
      return Z;
    }
    function y2(N2, b) {
      if (!N2)
        return { line: 0, ch: 0 };
      for (var M = N2.lineOffsets || (N2.lineOffsets = [0]), Z = N2.text, X, ee, ne = M.length - 1; ne >= 0; --ne)
        M[ne] <= b && (X = ne * E, ee = M[ne]);
      for (; ; ) {
        var ce = Z.indexOf(`
`, ee);
        if (ce >= b || ce < 0)
          break;
        ee = ce + 1, ++X;
      }
      return { line: X, ch: A(N2, ee, b) };
    }
    var C = r.outputPos = function(N2, b, M) {
      if (N2.lineCharPositions) {
        var Z = y2(b, M);
        return b.type == "part" && (Z.line += b.offsetLines != null ? b.offsetLines : y2(b.backing, b.offset).line), Z;
      } else
        return A(b, 0, M) + (b.type == "part" ? b.offset : 0);
    };
    function j(N2) {
      for (var b in N2)
        N2[b] == null && delete N2[b];
      return N2;
    }
    function w(N2, b, M) {
      M != null && (N2[b] = M);
    }
    function J(N2, b) {
      typeof N2 != "string" && (N2 = N2.name, b = b.name);
      var M = /^[A-Z]/.test(N2), Z = /^[A-Z]/.test(b);
      return M == Z ? N2 < b ? -1 : N2 == b ? 0 : 1 : M ? 1 : -1;
    }
    function te(N2, b, M) {
      return N2.type == "Literal" && typeof N2.value == "string" && N2.start == b - 1 && N2.end <= M + 1;
    }
    function se(N2, b) {
      for (var M = 0; M < N2.properties.length; M++) {
        var Z = N2.properties[M];
        if (Z.key && Z.key.start <= b && Z.key.end >= b)
          return Z;
      }
    }
    var ge = "break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try".split(" "), fe = ge.concat("export class extends const super yield import let static".split(" ")), et = r.addCompletion = function(N2, b, M, Z, X) {
      for (var ee = N2.types || N2.docs || N2.urls || N2.origins, ne = ee || N2.depths, ce = 0; ce < b.length; ++ce) {
        var Se = b[ce];
        if ((ne ? Se.name : Se) == M)
          return;
      }
      var Ae = ne ? { name: M } : M;
      if (b.push(Ae), Z && ee) {
        i.resetGuessing();
        var Ie = Z.getType();
        Ae.guess = i.didGuess(), N2.types && (Ae.type = i.toString(Z)), N2.docs && w(Ae, "doc", tt(N2, Z.doc || Ie && Ie.doc)), N2.urls && w(Ae, "url", Z.url || Ie && Ie.url), N2.origins && w(Ae, "origin", Z.origin || Ie && Ie.origin);
      }
      return N2.depths && (Ae.depth = X || 0), Ae;
    };
    function yt(N2, b, M) {
      if (b.end == null)
        throw F("missing .query.end field");
      var Z = N2.signalReturnFirst("completion", M, b);
      if (Z)
        return Z;
      for (var X = R(M, b.end), ee = X, ne = M.text; X && a.isIdentifierChar(ne.charCodeAt(X - 1)); )
        --X;
      if (b.expandWordForward !== false)
        for (; ee < ne.length && a.isIdentifierChar(ne.charCodeAt(ee)); )
          ++ee;
      var ce = ne.slice(X, ee), Se = [], Ae;
      b.caseInsensitive && (ce = ce.toLowerCase());
      function Ie(pe, Dt, zt, Ji) {
        if (!((Nt || b.omitObjectPrototype !== false) && Dt == N2.cx.protos.Object && !ce) && !(b.filter !== false && ce && (b.caseInsensitive ? pe.toLowerCase() : pe).indexOf(ce) !== 0) && !(Ae && Ae.props[pe])) {
          var vn = et(b, Se, pe, Dt && Dt.props[pe], zt);
          Ji && vn && typeof vn != "string" && Ji(vn);
        }
      }
      var je, Ge, qe, er, mt = i.findExpressionAround(M.ast, null, X, M.scope), Rt, Nt;
      if (mt) {
        var ct = mt.node;
        if (b.inLiteral === false && ct.type === "Literal" && (typeof ct.value == "string" || ct.regex))
          return {
            start: C(b, M, X),
            end: C(b, M, ee),
            completions: []
          };
        if (ct.type == "MemberExpression" && ct.object.end < X)
          Rt = mt;
        else if (te(ct, X, ee)) {
          var hr = i.parentNode(ct, M.ast);
          hr.type == "MemberExpression" && hr.property == ct && (Rt = { node: hr, state: mt.state });
        } else if (ct.type == "ObjectExpression") {
          var rt = se(ct, ee);
          rt ? (Nt = mt, Ge = er = rt.key.name || rt.key.value) : !ce && !/:\s*$/.test(M.text.slice(0, X)) && (Nt = mt, Ge = er = true);
        }
      }
      if (Nt)
        qe = i.typeFromContext(M.ast, Nt), Ae = Nt.node.objType;
      else if (Rt)
        Ge = Rt.node.property, Ge = Ge.type == "Literal" ? Ge.value.slice(1) : Ge.name, Rt.node = Rt.node.object, qe = i.expressionType(Rt);
      else if (ne.charAt(X - 1) == ".") {
        for (var xt = X - 1; xt && (ne.charAt(xt - 1) == "." || a.isIdentifierChar(ne.charCodeAt(xt - 1))); )
          xt--;
        var ui = ne.slice(xt, X - 1);
        ui && (qe = i.def.parsePath(ui, M.scope).getObjType(), Ge = ce);
      }
      if (Ge != null) {
        if (N2.cx.completingProperty = Ge, qe && i.forAllPropertiesOf(qe, Ie), !Se.length && b.guess !== false && qe && qe.guessProperties && qe.guessProperties(function(pe, Dt, zt) {
          pe != Ge && pe != "" && pe != "<i>" && Ie(pe, Dt, zt);
        }), !Se.length && ce.length >= 2 && b.guess !== false)
          for (var Ge in N2.cx.props)
            Ie(Ge, N2.cx.props[Ge][0], 0);
        je = "memberCompletion";
      } else
        i.forAllLocalsAt(M.ast, X, M.scope, Ie), b.includeKeywords && (N2.options.ecmaVersion >= 6 ? fe : ge).forEach(function(pe) {
          Ie(pe, null, 0, function(Dt) {
            Dt.isKeyword = true;
          });
        }), je = "variableCompletion";
      return N2.signal(je, M, X, ee, Ie), b.sort !== false && Se.sort(J), N2.cx.completingProperty = null, {
        start: C(b, M, X),
        end: C(b, M, ee),
        isProperty: !!Ge,
        isObjectKey: !!er,
        completions: Se
      };
    }
    function De(N2, b) {
      var M = b.prefix, Z = [];
      for (var X in N2.cx.props)
        X != "<i>" && (!M || X.indexOf(M) === 0) && Z.push(X);
      return b.sort !== false && Z.sort(J), { completions: Z };
    }
    function Ce(N2, b) {
      var M = N2.body, Z, X;
      return M ? (Array.isArray(M) ? (Z = M[0].start, X = M[M.length - 1].end) : (Z = M.start, X = M.end), Z <= b && X >= b) : false;
    }
    var Ee = r.findQueryExpr = function(N2, b, M) {
      if (b.end == null)
        throw F("missing .query.end field");
      if (b.variable) {
        var Z = i.scopeAt(N2.ast, R(N2, b.end), N2.scope);
        return {
          node: { type: "Identifier", name: b.variable, start: b.end, end: b.end + 1 },
          state: Z
        };
      } else {
        var X = b.start && R(N2, b.start), ee = R(N2, b.end), ne = i.findExpressionAt(N2.ast, X, ee, N2.scope);
        if (!ne) {
          var ce = i.findClosestExpression(N2.ast, X, ee, N2.scope);
          ce && !Ce(ce.node, ee) && (M || (X ?? ee) - ce.node.start < 20 || ce.node.end - ee < 20) && (ne = ce);
        }
        if (!ne) {
          var Se = i.findExpressionAround(N2.ast, X, ee, N2.scope);
          Se && !Ce(Se.node, ee) && (Se.node.type == "ObjectExpression" || M || (X ?? ee) - Se.node.start < 20 || Se.node.end - ee < 20) && (ne = Se);
        }
        return ne;
      }
    };
    function ut(N2, b, M) {
      var Z = b.start && R(N2, b.start), X = R(N2, b.end), ee = null, ne = i.findExpressionAround(N2.ast, Z, X, N2.scope);
      return ne && !Ce(ne.node, X) && (ne.node.type == "ObjectExpression" || M || (Z ?? X) - ne.node.start < 20 || ne.node.end - X < 20) && (ee = ne), ee;
    }
    function Je(N2, b, M) {
      var Z = Ee(N2, b, M);
      if (Z)
        return Z;
      throw F("No expression at the given position.");
    }
    function q(N2) {
      return !N2 || !(N2 = N2.getType()) || !(N2 instanceof i.Obj) ? null : N2;
    }
    function ot(N2, b, M, Z) {
      var X;
      Z && (i.resetGuessing(), X = i.expressionType(Z));
      var ee = N2.hasHandler("typeAt");
      if (ee)
        for (var ne = R(M, b.end), ce = 0; ce < ee.length; ce++)
          X = ee[ce](M, ne, Z, X);
      if (!X)
        throw F("No type found at the given position.");
      var Se;
      if (Z.node.type == "ObjectExpression" && b.end != null && (Se = se(Z.node, R(M, b.end)))) {
        var Ae = Se.key.name, Ie = q(i.typeFromContext(M.ast, Z));
        if (Ie && Ie.hasProp(Ae))
          X = Ie.hasProp(Ae);
        else {
          var je = q(X);
          je && je.hasProp(Ae) && (X = je.hasProp(Ae));
        }
      }
      return X;
    }
    function $t(N2, b, M, Z) {
      var X, ne, ee = ot(N2, b, M, Z), ne = ee;
      if (b.preferFunction ? ee = ee.getFunctionType() || ee.getType() : ee = ee.getType(), Z && (Z.node.type == "Identifier" ? X = Z.node.name : Z.node.type == "MemberExpression" && !Z.node.computed ? X = Z.node.property.name : Z.node.type == "MethodDefinition" && !Z.node.computed && (X = Z.node.key.name)), b.depth != null && typeof b.depth != "number")
        throw F(".query.depth must be a number");
      return [ee, X, ne];
    }
    function It2(N2, b, M) {
      var Z, X, ee, ne = Ee(M, b), ce = $t(N2, b, M, ne);
      Z = ce[0], Z || (ne = ut(M, b), ce = $t(N2, b, M, ne), Z = ce[0]), X = ce[1], ee = ce[2];
      var Se = {
        guess: i.didGuess(),
        type: i.toString(ee, b.depth),
        name: Z && Z.name,
        exprName: X,
        doc: ee.doc,
        url: ee.url
      };
      return Z && lt(b, Z, Se), j(Se);
    }
    function tt(N2, b) {
      if (!b)
        return null;
      if (N2.docFormat == "full")
        return b;
      var M = /.\n[\s@\n]/.exec(b);
      if (M && (b = b.slice(0, M.index + 1)), b = b.replace(/\n\s*/g, " "), b.length < 100)
        return b;
      var Z = /[\.!?] [A-Z]/g;
      Z.lastIndex = 80;
      var X = Z.exec(b);
      return X && (b = b.slice(0, X.index + 1)), b;
    }
    function St2(N2, b, M) {
      var Z = Ee(M, b), X = ot(N2, b, M, Z), ee = X.getType();
      ee || (Z = ut(M, b), X = ot(N2, b, M, Z), ee = X.getType());
      var ne = { url: X.url, doc: tt(b, X.doc), type: i.toString(X) };
      return ee && lt(b, ee, ne), j(ne);
    }
    function lt(N2, b, M) {
      M.url || (M.url = b.url), M.doc || (M.doc = tt(N2, b.doc)), M.origin || (M.origin = b.origin);
      var Z, X = i.cx().protos;
      !M.url && !M.doc && b.proto && (Z = b.proto.hasCtor) && b.proto != X.Object && b.proto != X.Function && b.proto != X.Array && (M.url = Z.url, M.doc = tt(N2, Z.doc));
    }
    var vt = r.getSpan = function(N2) {
      if (N2.origin) {
        if (N2.originNode) {
          var b = N2.originNode;
          return /^Function/.test(b.type) && b.id && (b = b.id), { origin: N2.origin, node: b };
        }
        if (N2.span)
          return { origin: N2.origin, span: N2.span };
      }
    }, xr = r.storeSpan = function(N2, b, M, Z) {
      if (Z.origin = M.origin, M.span) {
        var X = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(M.span);
        Z.start = b.lineCharPositions ? { line: Number(X[2]), ch: Number(X[3]) } : Number(X[1]), Z.end = b.lineCharPositions ? { line: Number(X[5]), ch: Number(X[6]) } : Number(X[4]);
      } else {
        var ee = N2.fileMap[M.origin];
        Z.start = C(b, ee, M.node.start), Z.end = C(b, ee, M.node.end);
      }
    };
    function ba(N2, b, M) {
      var Z = Ee(M, b), X = ot(N2, b, M, Z);
      if (i.didGuess())
        return {};
      var ee = vt(X), ne = { url: X.url, doc: tt(b, X.doc), origin: X.origin };
      if (X.types)
        for (var ce = X.types.length - 1; ce >= 0; --ce) {
          var Se = X.types[ce];
          lt(b, Se, ne), ee || (ee = vt(Se));
        }
      if (ee && ee.node) {
        var Ae = ee.node.sourceFile || N2.fileMap[ee.origin], Ie = C(b, Ae, ee.node.start), je = C(b, Ae, ee.node.end);
        ne.start = Ie, ne.end = je, ne.file = ee.origin;
        var Ge = Math.max(0, ee.node.start - 50);
        ne.contextOffset = ee.node.start - Ge, ne.context = Ae.text.slice(Ge, Ge + 50);
      } else
        ee && (ne.file = ee.origin, xr(N2, b, ee, ne));
      return j(ne);
    }
    function va2(N2, b, M, Z, X) {
      for (var ee = Z.node.name, ne = Z.state; ne && !(ee in ne.props); ne = ne.prev)
        ;
      if (!ne)
        throw F("Could not find a definition for " + ee);
      var ce, Se = [];
      function Ae(qe) {
        return function(er, mt, Rt) {
          var Nt = {
            file: qe.name,
            start: C(b, qe, er.start),
            end: C(b, qe, er.end)
          };
          if (X) {
            for (var ct = mt; ct != ne; ct = ct.prev) {
              var hr = ct.hasProp(X);
              if (hr)
                throw F("Renaming `" + ee + "` to `" + X + "` would make a variable at line " + (y2(qe, er.start).line + 1) + " point to the definition at line " + (y2(qe, hr.name.start).line + 1));
            }
            var rt = Rt[Rt.length - 2];
            rt && rt.type == "Property" && rt.key == rt.value && (Nt.isShorthand = true);
          }
          Se.push(Nt);
        };
      }
      if (ne.originNode) {
        if (ce = "local", X) {
          for (var Ie = ne.prev; Ie && !(X in Ie.props); Ie = Ie.prev)
            ;
          Ie && i.findRefs(ne.originNode, ne, X, Ie, function(qe) {
            throw F("Renaming `" + ee + "` to `" + X + "` would shadow the definition used at line " + (y2(M, qe.start).line + 1));
          });
        }
        i.findRefs(ne.originNode, ne, ee, ne, Ae(M));
      } else if (ce = "global", b.onlySourceFile)
        i.findRefs(M.ast, M.scope, ee, ne, Ae(M));
      else
        for (var je = 0; je < N2.files.length; ++je) {
          var Ge = N2.files[je];
          i.findRefs(Ge.ast, Ge.scope, ee, ne, Ae(Ge));
        }
      return { refs: Se, type: ce, name: ee };
    }
    function qi(N2, b, M, Z, X) {
      var ee = i.expressionType(Z);
      Z.node.type == "MethodDefinition" && (ee = ee.propertyOf);
      var ne = ee.getObjType();
      if (!ne)
        throw F("Couldn't determine type of base object.");
      var ce = [];
      function Se(je) {
        return function(Ge) {
          ce.push({
            file: je.name,
            start: C(b, je, Ge.start),
            end: C(b, je, Ge.end)
          });
        };
      }
      if (b.onlySourceFile)
        i.findPropRefs(M.ast, M.scope, ne, X.name, Se(M));
      else
        for (var Ae = 0; Ae < N2.files.length; ++Ae) {
          var Ie = N2.files[Ae];
          i.findPropRefs(Ie.ast, Ie.scope, ne, X.name, Se(Ie));
        }
      return { refs: ce, name: X.name };
    }
    function Oo(N2, b, M) {
      var Z = Je(M, b, true);
      if (Z && Z.node.type == "Identifier")
        return va2(N2, b, M, Z);
      if (Z && Z.node.type == "MemberExpression" && !Z.node.computed) {
        var X = Z.node.property;
        return Z.node = Z.node.object, qi(N2, b, M, Z, X);
      } else if (Z && Z.node.type == "ObjectExpression")
        for (var ee = R(M, b.end), ne = 0; ne < Z.node.properties.length; ++ne) {
          var ce = Z.node.properties[ne].key;
          if (ce.start <= ee && ce.end >= ee)
            return qi(N2, b, M, Z, ce);
        }
      else if (Z && Z.node.type == "MethodDefinition") {
        var X = Z.node.key;
        return qi(N2, b, M, Z, X);
      }
      throw F("Not at a variable or property name.");
    }
    function Ca(N2, b, M) {
      if (typeof b.newName != "string")
        throw F(".query.newName should be a string");
      var Z = Je(M, b);
      if (!Z || Z.node.type != "Identifier")
        throw F("Not at a variable.");
      var X = va2(N2, b, M, Z, b.newName), ee = X.refs;
      delete X.refs, X.files = N2.files.map(function(Ae) {
        return Ae.name;
      });
      for (var ne = X.changes = [], ce = 0; ce < ee.length; ++ce) {
        var Se = ee[ce];
        Se.isShorthand ? Se.text = Z.node.name + ": " + b.newName : Se.text = b.newName, ne.push(Se);
      }
      return X;
    }
    function li(N2) {
      return { files: N2.files.map(function(b) {
        return b.name;
      }) };
    }
    r.version = "0.24.3";
  });
})(gl, gl.exports);
var IP = gl.exports;
var NP = {};
var PP = {};
var _P = {
  "!type": "fn(number)",
  "!doc": "Numbers can be formatted to look like currency, percentages, times, or even plain old numbers with decimal places, thousands, and abbreviations.",
  "!url": "https://numbrojs.com/format.html"
};
var bP = {};
var vP = {
  "!name": "ecmascript",
  "!define": {
    "Error.prototype": "Error.prototype",
    propertyDescriptor: {
      enumerable: "bool",
      configurable: "bool",
      value: "?",
      writable: "bool",
      get: "fn() -> ?",
      set: "fn(value: ?)"
    },
    "Promise.prototype": {
      catch: {
        "!doc": "The catch() method returns a Promise and deals with rejected cases only. It behaves the same as calling Promise.prototype.then(undefined, onRejected).",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch",
        "!type": "fn(onRejected: fn(reason: ?)) -> !this"
      },
      then: {
        "!doc": "The then() method returns a Promise. It takes two arguments, both are callback functions for the success and failure cases of the Promise.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then",
        "!type": "fn(onFulfilled: fn(value: ?), onRejected: fn(reason: ?)) -> !custom:Promise_then",
        "!effects": [
          "call !0 !this.:t"
        ]
      }
    },
    Promise_reject: {
      "!type": "fn(reason: ?) -> !this",
      "!doc": "The Promise.reject(reason) method returns a Promise object that is rejected with the given reason.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"
    },
    iter_prototype: {
      ":Symbol.iterator": "fn() -> !this"
    },
    iter: {
      "!proto": "iter_prototype",
      next: {
        "!type": "fn() -> +iter_result[value=!this.:t]",
        "!doc": "Return the next item in the sequence.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators"
      },
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators"
    },
    iter_result: {
      done: "bool",
      value: "?"
    },
    generator_prototype: {
      "!proto": "iter_prototype",
      next: "fn(value?: ?) -> iter_result",
      return: "fn(value?: ?) -> iter_result",
      throw: "fn(exception: +Error)"
    },
    Proxy_handler: {
      "!doc": "The proxy's handler object is a placeholder object which contains traps for proxies.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler",
      getPrototypeOf: "fn(target: ?)",
      setPrototypeOf: "fn(target: ?, prototype: ?)",
      isExtensible: "fn(target: ?)",
      preventExtensions: "fn(target: ?)",
      getOwnPropertyDescriptor: "fn(target: ?, property: string) -> propertyDescriptor",
      defineProperty: "fn(target: ?, property: string, descriptor: propertyDescriptor)",
      has: "fn(target: ?, property: string)",
      get: "fn(target: ?, property: string)",
      set: "fn(target: ?, property: string, value: ?)",
      deleteProperty: "fn(target: ?, property: string)",
      enumerate: "fn(target: ?)",
      ownKeys: "fn(target: ?)",
      apply: "fn(target: ?, self: ?, arguments: [?])",
      construct: "fn(target: ?, arguments: [?])"
    },
    Proxy_revocable: {
      proxy: "+Proxy",
      revoke: "fn()"
    },
    TypedArray: {
      "!type": "fn(size: number)",
      "!doc": "A TypedArray object describes an array-like view of an underlying binary data buffer. There is no global property named TypedArray, nor is there a directly visible TypedArray constructor.  Instead, there are a number of different global properties, whose values are typed array constructors for specific element types, listed below. On the following pages you will find common properties and methods that can be used with any typed array containing elements of any type.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray",
      from: {
        "!type": "fn(arrayLike: ?, mapFn?: fn(elt: ?, i: number) -> number, thisArg?: ?) -> +TypedArray",
        "!effects": [
          "call !1 this=!2 !0.<i> number"
        ],
        "!doc": "Creates a new typed array from an array-like or iterable object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from"
      },
      of: {
        "!type": "fn(elements: number) -> +TypedArray",
        "!doc": "Creates a new typed array from a variable number of arguments.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/of"
      },
      BYTES_PER_ELEMENT: {
        "!type": "number",
        "!doc": "The TypedArray.BYTES_PER_ELEMENT property represents the size in bytes of each element in an typed array.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/BYTES_PER_ELEMENT"
      },
      name: {
        "!type": "string",
        "!doc": "The TypedArray.name property represents a string value of the typed array constructor name.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/name"
      },
      prototype: {
        "<i>": "number",
        buffer: {
          "!type": "+ArrayBuffer",
          "!doc": "The buffer accessor property represents the ArrayBuffer referenced by a TypedArray at construction time.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/buffer"
        },
        byteLength: {
          "!type": "number",
          "!doc": "The byteLength accessor property represents the length (in bytes) of a typed array from the start of its ArrayBuffer.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/byteLength"
        },
        byteOffset: {
          "!type": "number",
          "!doc": "The byteOffset accessor property represents the offset (in bytes) of a typed array from the start of its ArrayBuffer.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/byteOffset"
        },
        copyWithin: {
          "!type": "fn(target: number, start: number, end?: number) -> ?",
          "!doc": "The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end. The end argument is optional and defaults to the length of the array. This method has the same algorithm as Array.prototype.copyWithin. TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/copyWithin"
        },
        entries: {
          "!type": "fn() -> +iter[:t=number]",
          "!doc": "The entries() method returns a new Array Iterator object that contains the key/value pairs for each index in the array.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/entries"
        },
        every: {
          "!type": "fn(callback: fn(element: number, index: number, array: TypedArray) -> bool, thisArg?: ?) -> bool",
          "!effects": [
            "call !0 this=!1 number number !this"
          ],
          "!doc": "The every() method tests whether all elements in the typed array pass the test implemented by the provided function. This method has the same algorithm as Array.prototype.every(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/every"
        },
        fill: {
          "!type": "fn(value: number, start?: number, end?: number)",
          "!doc": "The fill() method fills all the elements of a typed array from a start index to an end index with a static value. This method has the same algorithm as Array.prototype.fill(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/fill"
        },
        filter: {
          "!type": "fn(test: fn(element: number, i: number) -> bool, context?: ?) -> !this",
          "!effects": [
            "call !0 this=!1 number number"
          ],
          "!doc": "Creates a new array with all of the elements of this array for which the provided filtering function returns true. See also Array.prototype.filter().",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/filter"
        },
        find: {
          "!type": "fn(callback: fn(element: number, index: number, array: +TypedArray) -> bool, thisArg?: ?) -> number",
          "!effects": [
            "call !0 this=!1 number number !this"
          ],
          "!doc": `The find() method returns a value in the typed array, if an element satisfies the provided testing function. Otherwise undefined is returned. TypedArray is one of the typed array types here.
See also the findIndex() method, which returns the index of a found element in the typed array instead of its value.`,
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/find"
        },
        findIndex: {
          "!type": "fn(callback: fn(element: number, index: number, array: +TypedArray) -> bool, thisArg?: ?) -> number",
          "!effects": [
            "call !0 this=!1 number number !this"
          ],
          "!doc": `The findIndex() method returns an index in the typed array, if an element in the typed array satisfies the provided testing function. Otherwise -1 is returned.
See also the find() method, which returns the value of a found element in the typed array instead of its index.`,
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/findIndex"
        },
        forEach: {
          "!type": "fn(callback: fn(value: number, key: number, array: +TypedArray), thisArg?: ?)",
          "!effects": [
            "call !0 this=!1 number number !this"
          ],
          "!doc": "Executes a provided function once per array element.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/forEach"
        },
        indexOf: {
          "!type": "fn(searchElement: number, fromIndex?: number) -> number",
          "!doc": "The indexOf() method returns the first index at which a given element can be found in the typed array, or -1 if it is not present. This method has the same algorithm as Array.prototype.indexOf(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/indexOf"
        },
        join: {
          "!type": "fn(separator?: string) -> string",
          "!doc": "The join() method joins all elements of an array into a string. This method has the same algorithm as Array.prototype.join(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/join"
        },
        keys: {
          "!type": "fn() -> +iter[:t=number]",
          "!doc": "The keys() method returns a new Array Iterator object that contains the keys for each index in the array.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/keys"
        },
        lastIndexOf: {
          "!type": "fn(searchElement: number, fromIndex?: number) -> number",
          "!doc": "The lastIndexOf() method returns the last index at which a given element can be found in the typed array, or -1 if it is not present. The typed array is searched backwards, starting at fromIndex. This method has the same algorithm as Array.prototype.lastIndexOf(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/lastIndexOf"
        },
        length: {
          "!type": "number",
          "!doc": "Returns the number of elements hold in the typed array. Fixed at construction time and thus read only.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/length"
        },
        map: {
          "!type": "fn(f: fn(element: number, i: number) -> number, context?: ?) -> +TypedArray",
          "!effects": [
            "call !0 this=!1 number number"
          ],
          "!doc": "Creates a new array with the results of calling a provided function on every element in this array. See also Array.prototype.map().",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/map"
        },
        reduce: {
          "!type": "fn(combine: fn(sum: ?, elt: number, i: number) -> ?, init?: ?) -> !0.!ret",
          "!effects": [
            "call !0 !1 number number"
          ],
          "!doc": "Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value. See also Array.prototype.reduce().",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduce"
        },
        reduceRight: {
          "!type": "fn(combine: fn(sum: ?, elt: number, i: number) -> ?, init?: ?) -> !0.!ret",
          "!effects": [
            "call !0 !1 number number"
          ],
          "!doc": "Apply a function against an accumulator and each value of the array (from right-to-left) as to reduce it to a single value. See also Array.prototype.reduceRight().",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduceRight"
        },
        reverse: {
          "!type": "fn()",
          "!doc": "The reverse() method reverses a typed array in place. The first typed array element becomes the last and the last becomes the first. This method has the same algorithm as Array.prototype.reverse(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reverse"
        },
        set: {
          "!type": "fn(array: [number], offset?: number)",
          "!doc": "The set() method stores multiple values in the typed array, reading input values from a specified array.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set"
        },
        slice: {
          "!type": "fn(from: number, to?: number) -> +TypedArray",
          "!doc": "Extracts a section of an array and returns a new array. See also Array.prototype.slice().",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice"
        },
        some: {
          "!type": "fn(test: fn(elt: number, i: number) -> bool, context?: ?) -> bool",
          "!effects": [
            "call !0 this=!1 number number"
          ],
          "!doc": "The some() method tests whether some element in the typed array passes the test implemented by the provided function. This method has the same algorithm as Array.prototype.some(). TypedArray is one of the typed array types here.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/some"
        },
        sort: {
          "!type": "fn(compare?: fn(a: number, b: number) -> number)",
          "!effects": [
            "call !0 number number"
          ],
          "!doc": "Sorts the elements of an array in place and returns the array. See also Array.prototype.sort().",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/sort"
        },
        subarray: {
          "!type": "fn(begin?: number, end?: number) -> +TypedArray",
          "!doc": "The subarray() method returns a new TypedArray on the same ArrayBuffer store and with the same element types as for this TypedArray object. The begin offset is inclusive and the end offset is exclusive. TypedArray is one of the typed array types.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray"
        },
        values: {
          "!type": "fn() -> +iter[:t=number]",
          "!doc": "The values() method returns a new Array Iterator object that contains the values for each index in the array.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/values"
        },
        ":Symbol.iterator": {
          "!type": "fn() -> +iter[:t=number]",
          "!doc": "Returns a new Array Iterator object that contains the values for each index in the array.",
          "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/@@iterator"
        }
      }
    }
  },
  Infinity: {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Infinity",
    "!doc": "A numeric value representing infinity."
  },
  undefined: {
    "!type": "?",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/undefined",
    "!doc": "The value undefined."
  },
  NaN: {
    "!type": "number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN",
    "!doc": "A value representing Not-A-Number."
  },
  Object: {
    "!type": "fn()",
    getPrototypeOf: {
      "!type": "fn(obj: ?) -> ?",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getPrototypeOf",
      "!doc": "Returns the prototype (i.e. the internal prototype) of the specified object."
    },
    create: {
      "!type": "fn(proto: ?) -> !custom:Object_create",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create",
      "!doc": "Creates a new object with the specified prototype object and properties."
    },
    defineProperty: {
      "!type": "fn(obj: ?, prop: string, desc: propertyDescriptor) -> !custom:Object_defineProperty",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
    },
    defineProperties: {
      "!type": "fn(obj: ?, props: ?) -> !custom:Object_defineProperties",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
    },
    getOwnPropertyDescriptor: {
      "!type": "fn(obj: ?, prop: string) -> propertyDescriptor",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor",
      "!doc": "Returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object."
    },
    keys: {
      "!type": "fn(obj: ?) -> [string]",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys",
      "!doc": "Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
    },
    getOwnPropertyNames: {
      "!type": "fn(obj: ?) -> [string]",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames",
      "!doc": "Returns an array of all properties (enumerable or not) found directly upon a given object."
    },
    seal: {
      "!type": "fn(obj: ?)",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal",
      "!doc": "Seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable."
    },
    isSealed: {
      "!type": "fn(obj: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isSealed",
      "!doc": "Determine if an object is sealed."
    },
    freeze: {
      "!type": "fn(obj: ?) -> !0",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze",
      "!doc": "Freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen."
    },
    isFrozen: {
      "!type": "fn(obj: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isFrozen",
      "!doc": "Determine if an object is frozen."
    },
    preventExtensions: {
      "!type": "fn(obj: ?)",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions",
      "!doc": "Prevents new properties from ever being added to an object."
    },
    isExtensible: {
      "!type": "fn(obj: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible",
      "!doc": "The Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it)."
    },
    assign: {
      "!type": "fn(target: ?, source: ?, source?: ?) -> !0",
      "!effects": [
        "copy !1 !0",
        "copy !2 !0",
        "copy !3 !0"
      ],
      "!doc": "The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"
    },
    getOwnPropertySymbols: {
      "!type": "fn(obj: ?) -> !custom:getOwnPropertySymbols",
      "!doc": "The Object.getOwnPropertySymbols() method returns an array of all symbol properties found directly upon a given object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"
    },
    is: {
      "!type": "fn(value1: ?, value2: ?) -> bool",
      "!doc": "The Object.is() method determines whether two values are the same value.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"
    },
    setPrototypeOf: {
      "!type": "fn(obj: ?, prototype: ?)",
      "!doc": "The Object.setPrototype() method sets the prototype (i.e., the internal [[Prototype]] property) of a specified object to another object or null.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"
    },
    prototype: {
      "!stdProto": "Object",
      toString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString",
        "!doc": "Returns a string representing the object."
      },
      toLocaleString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toLocaleString",
        "!doc": "Returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes."
      },
      valueOf: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf",
        "!doc": "Returns the primitive value of the specified object"
      },
      hasOwnProperty: {
        "!type": "fn(prop: string) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
        "!doc": "Returns a boolean indicating whether the object has the specified property."
      },
      propertyIsEnumerable: {
        "!type": "fn(prop: string) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable",
        "!doc": "Returns a Boolean indicating whether the specified property is enumerable."
      },
      isPrototypeOf: {
        "!type": "fn(obj: ?) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf",
        "!doc": "Tests for an object in another object's prototype chain."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object",
    "!doc": "Creates an object wrapper."
  },
  Function: {
    "!type": "fn(body: string) -> fn()",
    prototype: {
      "!stdProto": "Function",
      apply: {
        "!type": "fn(this: ?, args: [?])",
        "!effects": [
          "call and return !this this=!0 !1.<i> !1.<i> !1.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply",
        "!doc": "Calls a function with a given this value and arguments provided as an array (or an array like object)."
      },
      call: {
        "!type": "fn(this: ?, args?: ?) -> !this.!ret",
        "!effects": [
          "call and return !this this=!0 !1 !2 !3 !4"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call",
        "!doc": "Calls a function with a given this value and arguments provided individually."
      },
      bind: {
        "!type": "fn(this: ?, args?: ?) -> !custom:Function_bind",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind",
        "!doc": "Creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function was called."
      },
      prototype: "?"
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function",
    "!doc": "Every function in JavaScript is actually a Function object."
  },
  Array: {
    "!type": "fn(size: number) -> !custom:Array_ctor",
    isArray: {
      "!type": "fn(value: ?) -> bool",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray",
      "!doc": "Returns true if an object is an array, false if it is not."
    },
    from: {
      "!type": "fn(arrayLike: ?, mapFn?: fn(elt: ?, i: number) -> ?, thisArg?: ?) -> [!0.<i>]",
      "!effects": [
        "call !1 this=!2 !0.<i> number"
      ],
      "!doc": "The Array.from() method creates a new Array instance from an array-like or iterable object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from"
    },
    of: {
      "!type": "fn(elementN: ?) -> [!0]",
      "!doc": "The Array.of() method creates a new Array instance with a variable number of arguments, regardless of number or type of the arguments.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of"
    },
    prototype: {
      "!stdProto": "Array",
      length: {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/length",
        "!doc": "An unsigned, 32-bit integer that specifies the number of elements in an array."
      },
      concat: {
        "!type": "fn(other: [?]) -> !this",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat",
        "!doc": "Returns a new array comprised of this array joined with other array(s) and/or value(s)."
      },
      join: {
        "!type": "fn(separator?: string) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/join",
        "!doc": "Joins all elements of an array into a string."
      },
      splice: {
        "!type": "fn(pos: number, amount: number, newelt?: ?) -> [?]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice",
        "!doc": "Changes the content of an array, adding new elements while removing old elements."
      },
      pop: {
        "!type": "fn() -> !this.<i>",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/pop",
        "!doc": "Removes the last element from an array and returns that element."
      },
      push: {
        "!type": "fn(newelt: ?) -> number",
        "!effects": [
          "propagate !0 !this.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push",
        "!doc": "Mutates an array by appending the given elements and returning the new length of the array."
      },
      shift: {
        "!type": "fn() -> !this.<i>",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/shift",
        "!doc": "Removes the first element from an array and returns that element. This method changes the length of the array."
      },
      unshift: {
        "!type": "fn(newelt: ?) -> number",
        "!effects": [
          "propagate !0 !this.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/unshift",
        "!doc": "Adds one or more elements to the beginning of an array and returns the new length of the array."
      },
      slice: {
        "!type": "fn(from?: number, to?: number) -> !this",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/slice",
        "!doc": "Returns a shallow copy of a portion of an array."
      },
      reverse: {
        "!type": "fn()",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/reverse",
        "!doc": "Reverses an array in place.  The first array element becomes the last and the last becomes the first."
      },
      sort: {
        "!type": "fn(compare?: fn(a: ?, b: ?) -> number)",
        "!effects": [
          "call !0 !this.<i> !this.<i>"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort",
        "!doc": "Sorts the elements of an array in place and returns the array."
      },
      indexOf: {
        "!type": "fn(elt: ?, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf",
        "!doc": "Returns the first index at which a given element can be found in the array, or -1 if it is not present."
      },
      lastIndexOf: {
        "!type": "fn(elt: ?, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/lastIndexOf",
        "!doc": "Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex."
      },
      every: {
        "!type": "fn(test: fn(elt: ?, i: number, array: +Array) -> bool, context?: ?) -> bool",
        "!effects": [
          "call !0 this=!1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/every",
        "!doc": "Tests whether all elements in the array pass the test implemented by the provided function."
      },
      some: {
        "!type": "fn(test: fn(elt: ?, i: number, array: +Array) -> bool, context?: ?) -> bool",
        "!effects": [
          "call !0 this=!1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/some",
        "!doc": "Tests whether some element in the array passes the test implemented by the provided function."
      },
      filter: {
        "!type": "fn(test: fn(elt: ?, i: number, array: +Array) -> bool, context?: ?) -> !this",
        "!effects": [
          "call !0 this=!1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter",
        "!doc": "Creates a new array with all elements that pass the test implemented by the provided function."
      },
      forEach: {
        "!type": "fn(f: fn(elt: ?, i: number, array: +Array), context?: ?)",
        "!effects": [
          "call !0 this=!1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach",
        "!doc": "Executes a provided function once per array element."
      },
      map: {
        "!type": "fn(f: fn(elt: ?, i: number, array: +Array) -> ?, context?: ?) -> [!0.!ret]",
        "!effects": [
          "call !0 this=!1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map",
        "!doc": "Creates a new array with the results of calling a provided function on every element in this array."
      },
      reduce: {
        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number, array: +Array) -> ?, init?: ?) -> !0.!ret",
        "!effects": [
          "call !0 !1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce",
        "!doc": "Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value."
      },
      reduceRight: {
        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number, array: +Array) -> ?, init?: ?) -> !0.!ret",
        "!effects": [
          "call !0 !1 !this.<i> number !this"
        ],
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/ReduceRight",
        "!doc": "Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value."
      },
      copyWithin: {
        "!type": "fn(target: number, start: number, end?: number) -> !this",
        "!doc": "The copyWithin() method copies the sequence of array elements within the array to the position starting at target. The copy is taken from the index positions of the second and third arguments start and end.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin"
      },
      entries: {
        "!type": "fn() -> +iter[:t=[number, !this.<i>]]",
        "!doc": "The entries() method returns a new Array Iterator object that contains the key/value pairs for each index in the array.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries"
      },
      fill: {
        "!type": "fn(value: ?, start?: number, end?: number) -> !this",
        "!doc": "The fill() method fills all the elements of an array from a start index to an end index with a static value.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill"
      },
      find: {
        "!type": "fn(callback: fn(element: ?, index: number, array: [?]) -> bool, thisArg?: ?) -> !this.<i>",
        "!effects": [
          "call !0 this=!2 !this.<i> number"
        ],
        "!doc": "The find() method returns a value in the array, if an element in the array satisfies the provided testing function. Otherwise undefined is returned.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find"
      },
      findIndex: {
        "!type": "fn(callback: fn(element: ?, index: number, array: [?]), thisArg?: ?) -> number",
        "!effects": [
          "call !0 this=!2 !this.<i> number"
        ],
        "!doc": "The findIndex() method returns an index in the array, if an element in the array satisfies the provided testing function. Otherwise -1 is returned.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex"
      },
      keys: {
        "!type": "fn() -> +iter[:t=number]",
        "!doc": "The keys() method returns a new Array Iterator that contains the keys for each index in the array.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys"
      },
      values: {
        "!type": "fn() -> +iter[:t=!this.<i>]",
        "!doc": "The values() method returns a new Array Iterator object that contains the values for each index in the array.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values"
      },
      ":Symbol.iterator": {
        "!type": "fn() -> +iter[:t=!this.<i>]",
        "!doc": "Returns a new Array Iterator object that contains the values for each index in the array.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator"
      },
      includes: {
        "!type": "fn(value: ?) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes",
        "!doc": "Determines whether an array includes a certain element, returning true or false as appropriate."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array",
    "!doc": "The JavaScript Array global object is a constructor for arrays, which are high-level, list-like objects."
  },
  String: {
    "!type": "fn(value: ?) -> string",
    fromCharCode: {
      "!type": "fn(code: number) -> string",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode",
      "!doc": "Returns a string created by using the specified sequence of Unicode values."
    },
    fromCodePoint: {
      "!type": "fn(point: number, point?: number) -> string",
      "!doc": "The static String.fromCodePoint() method returns a string created by using the specified sequence of code points.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint"
    },
    raw: {
      "!type": "fn(template: [string], substitutions: ?, templateString: ?) -> string",
      "!doc": "The static String.raw() method is a tag function of template strings, used to get the raw string form of template strings.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw"
    },
    prototype: {
      "!stdProto": "String",
      length: {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String/length",
        "!doc": "Represents the length of a string."
      },
      "<i>": "string",
      charAt: {
        "!type": "fn(i: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charAt",
        "!doc": "Returns the specified character from a string."
      },
      charCodeAt: {
        "!type": "fn(i: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt",
        "!doc": "Returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."
      },
      indexOf: {
        "!type": "fn(char: string, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/indexOf",
        "!doc": `Returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex,
returns -1 if the value is not found.`
      },
      lastIndexOf: {
        "!type": "fn(char: string, from?: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/lastIndexOf",
        "!doc": "Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found. The calling string is searched backward, starting at fromIndex."
      },
      substring: {
        "!type": "fn(from: number, to?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substring",
        "!doc": "Returns a subset of a string between one index and another, or through the end of the string."
      },
      substr: {
        "!type": "fn(from: number, length?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substr",
        "!doc": "Returns the characters in a string beginning at the specified location through the specified number of characters."
      },
      slice: {
        "!type": "fn(from: number, to?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/slice",
        "!doc": "Extracts a section of a string and returns a new string."
      },
      trim: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim",
        "!doc": "Removes whitespace from both ends of the string."
      },
      toUpperCase: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toUpperCase",
        "!doc": "Returns the calling string value converted to uppercase."
      },
      toLowerCase: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLowerCase",
        "!doc": "Returns the calling string value converted to lowercase."
      },
      toLocaleUpperCase: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase",
        "!doc": "Returns the calling string value converted to upper case, according to any locale-specific case mappings."
      },
      toLocaleLowerCase: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase",
        "!doc": "Returns the calling string value converted to lower case, according to any locale-specific case mappings."
      },
      split: {
        "!type": "fn(pattern?: string|+RegExp, limit?: number) -> [string]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split",
        "!doc": "Splits a String object into an array of strings by separating the string into substrings."
      },
      concat: {
        "!type": "fn(other: string) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/concat",
        "!doc": "Combines the text of two or more strings and returns a new string."
      },
      localeCompare: {
        "!type": "fn(other: string) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/localeCompare",
        "!doc": "Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order."
      },
      match: {
        "!type": "fn(pattern: +RegExp) -> [string]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match",
        "!doc": "Used to retrieve the matches when matching a string against a regular expression."
      },
      replace: {
        "!type": "fn(pattern: string|+RegExp, replacement: string) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace",
        "!doc": "Returns a new string with some or all matches of a pattern replaced by a replacement.  The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match."
      },
      search: {
        "!type": "fn(pattern: +RegExp) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search",
        "!doc": "Executes the search for a match between a regular expression and this String object."
      },
      codePointAt: {
        "!type": "fn(pos: number) -> number",
        "!doc": "The codePointAt() method returns a non-negative integer that is the UTF-16 encoded code point value.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt"
      },
      endsWith: {
        "!type": "fn(searchString: string, position?: number) -> bool",
        "!doc": "The endsWith() method determines whether a string ends with the characters of another string, returning true or false as appropriate.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith"
      },
      includes: {
        "!type": "fn(searchString: string, position?: number) -> bool",
        "!doc": "The includes() method determines whether one string may be found within another string, returning true or false as appropriate.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/contains"
      },
      normalize: {
        "!type": "fn(form: string) -> string",
        "!doc": "The normalize() method returns the Unicode Normalization Form of a given string (if the value isn't a string, it will be converted to one first).",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize"
      },
      repeat: {
        "!type": "fn(count: number) -> string",
        "!doc": "The repeat() method constructs and returns a new string which contains the specified number of copies of the string on which it was called, concatenated together.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat"
      },
      startsWith: {
        "!type": "fn(searchString: string, position?: number) -> bool",
        "!doc": "The startsWith() method determines whether a string begins with the characters of another string, returning true or false as appropriate.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith"
      },
      ":Symbol.iterator": {
        "!type": "fn() -> +iter[:t=string]",
        "!doc": "Returns a new Iterator object that iterates over the code points of a String value, returning each code point as a String value.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator"
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String",
    "!doc": "The String global object is a constructor for strings, or a sequence of characters."
  },
  Number: {
    "!type": "fn(value: ?) -> number",
    MAX_VALUE: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MAX_VALUE",
      "!doc": "The maximum numeric value representable in JavaScript."
    },
    MIN_VALUE: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MIN_VALUE",
      "!doc": "The smallest positive numeric value representable in JavaScript."
    },
    POSITIVE_INFINITY: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY",
      "!doc": "A value representing the positive Infinity value."
    },
    NEGATIVE_INFINITY: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY",
      "!doc": "A value representing the negative Infinity value."
    },
    prototype: {
      "!stdProto": "Number",
      toString: {
        "!type": "fn(radix?: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toString",
        "!doc": "Returns a string representing the specified Number object"
      },
      toFixed: {
        "!type": "fn(digits: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed",
        "!doc": "Formats a number using fixed-point notation"
      },
      toExponential: {
        "!type": "fn(digits: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toExponential",
        "!doc": "Returns a string representing the Number object in exponential notation"
      },
      toPrecision: {
        "!type": "fn(digits: number) -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toPrecision",
        "!doc": "The toPrecision() method returns a string representing the number to the specified precision."
      }
    },
    EPSILON: {
      "!type": "number",
      "!doc": "The Number.EPSILON property represents the difference between one and the smallest value greater than one that can be represented as a Number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON"
    },
    MAX_SAFE_INTEGER: {
      "!type": "number",
      "!doc": "The Number.MAX_SAFE_INTEGER constant represents the maximum safe integer in JavaScript (253 - 1).",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER"
    },
    MIN_SAFE_INTEGER: {
      "!type": "number",
      "!doc": "The Number.MIN_SAFE_INTEGER constant represents the minimum safe integer in JavaScript (-(253 - 1)).",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER"
    },
    isFinite: {
      "!type": "fn(testValue: ?) -> bool",
      "!doc": "The Number.isFinite() method determines whether the passed value is finite.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite"
    },
    isInteger: {
      "!type": "fn(testValue: ?) -> bool",
      "!doc": "The Number.isInteger() method determines whether the passed value is an integer.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger"
    },
    isNaN: {
      "!type": "fn(testValue: ?) -> bool",
      "!doc": "The Number.isNaN() method determines whether the passed value is NaN. More robust version of the original global isNaN().",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN"
    },
    isSafeInteger: {
      "!type": "fn(testValue: ?) -> bool",
      "!doc": "The Number.isSafeInteger() method determines whether the provided value is a number that is a safe integer. A safe integer is an integer that",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger"
    },
    parseFloat: {
      "!type": "fn(string: string) -> number",
      "!doc": "The Number.parseFloat() method parses a string argument and returns a floating point number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat"
    },
    parseInt: {
      "!type": "fn(string: string, radix?: number) -> number",
      "!doc": "The Number.parseInt() method parses a string argument and returns an integer of the specified radix or base.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt"
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number",
    "!doc": "The Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor."
  },
  Boolean: {
    "!type": "fn(value: ?) -> bool",
    prototype: {
      "!stdProto": "Boolean"
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Boolean",
    "!doc": "The Boolean object is an object wrapper for a boolean value."
  },
  RegExp: {
    "!type": "fn(source: string, flags?: string)",
    prototype: {
      "!stdProto": "RegExp",
      exec: {
        "!type": "fn(input: string) -> [string]",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec",
        "!doc": "Executes a search for a match in a specified string. Returns a result array, or null."
      },
      test: {
        "!type": "fn(input: string) -> bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/test",
        "!doc": "Executes the search for a match between a regular expression and a specified string. Returns true or false."
      },
      global: {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
        "!doc": "Creates a regular expression object for matching text with a pattern."
      },
      ignoreCase: {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
        "!doc": "Creates a regular expression object for matching text with a pattern."
      },
      multiline: {
        "!type": "bool",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/multiline",
        "!doc": `Reflects whether or not to search in strings across multiple lines.
`
      },
      source: {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/source",
        "!doc": `A read-only property that contains the text of the pattern, excluding the forward slashes.
`
      },
      lastIndex: {
        "!type": "number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/lastIndex",
        "!doc": "A read/write integer property that specifies the index at which to start the next match."
      },
      flags: {
        "!type": "string",
        "!doc": "The flags property returns a string consisting of the flags of the current regular expression object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags"
      },
      sticky: {
        "!type": "bool",
        "!doc": "The sticky property reflects whether or not the search is sticky (searches in strings only from the index indicated by the lastIndex property of this regular expression). sticky is a read-only property of an individual regular expression object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"
      },
      unicode: {
        "!type": "bool",
        "!doc": "The 'u' flag enables various Unicode-related features.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode"
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
    "!doc": "Creates a regular expression object for matching text with a pattern."
  },
  Date: {
    "!type": "fn(ms: number)",
    parse: {
      "!type": "fn(source: string) -> +Date",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse",
      "!doc": "Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC."
    },
    UTC: {
      "!type": "fn(year: number, month: number, date: number, hour?: number, min?: number, sec?: number, ms?: number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/UTC",
      "!doc": "Accepts the same parameters as the longest form of the constructor, and returns the number of milliseconds in a Date object since January 1, 1970, 00:00:00, universal time."
    },
    now: {
      "!type": "fn() -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now",
      "!doc": "Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
    },
    prototype: {
      toUTCString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString",
        "!doc": "Converts a date to a string, using the universal time convention."
      },
      toISOString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toISOString",
        "!doc": "JavaScript provides a direct way to convert a date object into a string in ISO format, the ISO 8601 Extended Format."
      },
      toDateString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toDateString",
        "!doc": "Returns the date portion of a Date object in human readable form in American English."
      },
      toTimeString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toTimeString",
        "!doc": "Returns the time portion of a Date object in human readable form in American English."
      },
      toLocaleDateString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleDateString",
        "!doc": `Converts a date to a string, returning the "date" portion using the operating system's locale's conventions.
`
      },
      toLocaleTimeString: {
        "!type": "fn() -> string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString",
        "!doc": `Converts a date to a string, returning the "time" portion using the current locale's conventions.`
      },
      getTime: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTime",
        "!doc": "Returns the numeric value corresponding to the time for the specified date according to universal time."
      },
      getFullYear: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getFullYear",
        "!doc": "Returns the year of the specified date according to local time."
      },
      getYear: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getYear",
        "!doc": "Returns the year in the specified date according to local time."
      },
      getMonth: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMonth",
        "!doc": "Returns the month in the specified date according to local time."
      },
      getUTCMonth: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMonth",
        "!doc": `Returns the month of the specified date according to universal time.
`
      },
      getDate: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDate",
        "!doc": "Returns the day of the month for the specified date according to local time."
      },
      getUTCDate: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDate",
        "!doc": `Returns the day (date) of the month in the specified date according to universal time.
`
      },
      getDay: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDay",
        "!doc": "Returns the day of the week for the specified date according to local time."
      },
      getUTCDay: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDay",
        "!doc": `Returns the day of the week in the specified date according to universal time.
`
      },
      getHours: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getHours",
        "!doc": "Returns the hour for the specified date according to local time."
      },
      getUTCHours: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCHours",
        "!doc": `Returns the hours in the specified date according to universal time.
`
      },
      getMinutes: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMinutes",
        "!doc": "Returns the minutes in the specified date according to local time."
      },
      getUTCMinutes: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
        "!doc": "Creates JavaScript Date instances which let you work with dates and times."
      },
      getSeconds: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getSeconds",
        "!doc": "Returns the seconds in the specified date according to local time."
      },
      getUTCSeconds: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCSeconds",
        "!doc": `Returns the seconds in the specified date according to universal time.
`
      },
      getMilliseconds: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMilliseconds",
        "!doc": "Returns the milliseconds in the specified date according to local time."
      },
      getUTCMilliseconds: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds",
        "!doc": `Returns the milliseconds in the specified date according to universal time.
`
      },
      getTimezoneOffset: {
        "!type": "fn() -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset",
        "!doc": "Returns the time-zone offset from UTC, in minutes, for the current locale."
      },
      setTime: {
        "!type": "fn(date: +Date) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setTime",
        "!doc": `Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.
`
      },
      setFullYear: {
        "!type": "fn(year: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setFullYear",
        "!doc": `Sets the full year for a specified date according to local time.
`
      },
      setUTCFullYear: {
        "!type": "fn(year: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCFullYear",
        "!doc": `Sets the full year for a specified date according to universal time.
`
      },
      setMonth: {
        "!type": "fn(month: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMonth",
        "!doc": "Set the month for a specified date according to local time."
      },
      setUTCMonth: {
        "!type": "fn(month: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMonth",
        "!doc": `Sets the month for a specified date according to universal time.
`
      },
      setDate: {
        "!type": "fn(day: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setDate",
        "!doc": "Sets the day of the month for a specified date according to local time."
      },
      setUTCDate: {
        "!type": "fn(day: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCDate",
        "!doc": `Sets the day of the month for a specified date according to universal time.
`
      },
      setHours: {
        "!type": "fn(hour: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setHours",
        "!doc": "Sets the hours for a specified date according to local time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated Date instance."
      },
      setUTCHours: {
        "!type": "fn(hour: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCHours",
        "!doc": `Sets the hour for a specified date according to universal time.
`
      },
      setMinutes: {
        "!type": "fn(min: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMinutes",
        "!doc": "Sets the minutes for a specified date according to local time."
      },
      setUTCMinutes: {
        "!type": "fn(min: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMinutes",
        "!doc": `Sets the minutes for a specified date according to universal time.
`
      },
      setSeconds: {
        "!type": "fn(sec: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setSeconds",
        "!doc": "Sets the seconds for a specified date according to local time."
      },
      setUTCSeconds: {
        "!type": "fn(sec: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCSeconds",
        "!doc": `Sets the seconds for a specified date according to universal time.
`
      },
      setMilliseconds: {
        "!type": "fn(ms: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMilliseconds",
        "!doc": `Sets the milliseconds for a specified date according to local time.
`
      },
      setUTCMilliseconds: {
        "!type": "fn(ms: number) -> number",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds",
        "!doc": `Sets the milliseconds for a specified date according to universal time.
`
      },
      toJSON: {
        "!type": "fn() -> string",
        "!doc": "Returns a string (using toISOString()) representing the Date object's value.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toJSON"
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
    "!doc": "Creates JavaScript Date instances which let you work with dates and times."
  },
  Error: {
    "!type": "fn(message: string)",
    prototype: {
      name: {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/name",
        "!doc": "A name for the type of error."
      },
      message: {
        "!type": "string",
        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/message",
        "!doc": "A human-readable description of the error."
      }
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error",
    "!doc": "Creates an error object."
  },
  SyntaxError: {
    "!type": "fn(message: string)",
    prototype: "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/SyntaxError",
    "!doc": "Represents an error when trying to interpret syntactically invalid code."
  },
  ReferenceError: {
    "!type": "fn(message: string)",
    prototype: "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/ReferenceError",
    "!doc": "Represents an error when a non-existent variable is referenced."
  },
  URIError: {
    "!type": "fn(message: string)",
    prototype: "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/URIError",
    "!doc": "Represents an error when a malformed URI is encountered."
  },
  EvalError: {
    "!type": "fn(message: string)",
    prototype: "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/EvalError",
    "!doc": "Represents an error regarding the eval function."
  },
  RangeError: {
    "!type": "fn(message: string)",
    prototype: "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RangeError",
    "!doc": "Represents an error when a number is not within the correct range allowed."
  },
  TypeError: {
    "!type": "fn(message: string)",
    prototype: "Error.prototype",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/TypeError",
    "!doc": "Represents an error an error when a value is not of the expected type."
  },
  parseInt: {
    "!type": "fn(string: string, radix?: number) -> number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseInt",
    "!doc": "Parses a string argument and returns an integer of the specified radix or base."
  },
  parseFloat: {
    "!type": "fn(string: string) -> number",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseFloat",
    "!doc": "Parses a string argument and returns a floating point number."
  },
  isNaN: {
    "!type": "fn(value: number) -> bool",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isNaN",
    "!doc": "Determines whether a value is NaN or not. Be careful, this function is broken. You may be interested in ECMAScript 6 Number.isNaN."
  },
  isFinite: {
    "!type": "fn(value: number) -> bool",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isFinite",
    "!doc": "Determines whether the passed value is a finite number."
  },
  eval: {
    "!type": "fn(code: string) -> ?",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval",
    "!doc": "Evaluates JavaScript code represented as a string."
  },
  encodeURI: {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURI",
    "!doc": 'Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two "surrogate" characters).'
  },
  encodeURIComponent: {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent",
    "!doc": 'Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two "surrogate" characters).'
  },
  decodeURI: {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURI",
    "!doc": "Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine."
  },
  decodeURIComponent: {
    "!type": "fn(uri: string) -> string",
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURIComponent",
    "!doc": "Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine."
  },
  Math: {
    E: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/E",
      "!doc": "The base of natural logarithms, e, approximately 2.718."
    },
    LN2: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN2",
      "!doc": "The natural logarithm of 2, approximately 0.693."
    },
    LN10: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN10",
      "!doc": "The natural logarithm of 10, approximately 2.302."
    },
    LOG2E: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG2E",
      "!doc": "The base 2 logarithm of E (approximately 1.442)."
    },
    LOG10E: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG10E",
      "!doc": "The base 10 logarithm of E (approximately 0.434)."
    },
    SQRT1_2: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT1_2",
      "!doc": "The square root of 1/2; equivalently, 1 over the square root of 2, approximately 0.707."
    },
    SQRT2: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT2",
      "!doc": "The square root of 2, approximately 1.414."
    },
    PI: {
      "!type": "number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/PI",
      "!doc": "The ratio of the circumference of a circle to its diameter, approximately 3.14159."
    },
    abs: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/abs",
      "!doc": "Returns the absolute value of a number."
    },
    cos: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/cos",
      "!doc": "Returns the cosine of a number."
    },
    sin: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sin",
      "!doc": "Returns the sine of a number."
    },
    tan: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/tan",
      "!doc": "Returns the tangent of a number."
    },
    acos: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/acos",
      "!doc": "Returns the arccosine (in radians) of a number."
    },
    asin: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/asin",
      "!doc": "Returns the arcsine (in radians) of a number."
    },
    atan: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan",
      "!doc": "Returns the arctangent (in radians) of a number."
    },
    atan2: {
      "!type": "fn(y: number, x: number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan2",
      "!doc": "Returns the arctangent of the quotient of its arguments."
    },
    ceil: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/ceil",
      "!doc": "Returns the smallest integer greater than or equal to a number."
    },
    floor: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/floor",
      "!doc": "Returns the largest integer less than or equal to a number."
    },
    round: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/round",
      "!doc": "Returns the value of a number rounded to the nearest integer."
    },
    exp: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/exp",
      "!doc": "Returns Ex, where x is the argument, and E is Euler's constant, the base of the natural logarithms."
    },
    log: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/log",
      "!doc": "Returns the natural logarithm (base E) of a number."
    },
    sqrt: {
      "!type": "fn(number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sqrt",
      "!doc": "Returns the square root of a number."
    },
    pow: {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/pow",
      "!doc": "Returns base to the exponent power, that is, baseexponent."
    },
    max: {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/max",
      "!doc": "Returns the largest of zero or more numbers."
    },
    min: {
      "!type": "fn(number, number) -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/min",
      "!doc": "Returns the smallest of zero or more numbers."
    },
    random: {
      "!type": "fn() -> number",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random",
      "!doc": "Returns a floating-point, pseudo-random number in the range [0, 1) that is, from 0 (inclusive) up to but not including 1 (exclusive), which you can then scale to your desired range."
    },
    acosh: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.acosh() function returns the hyperbolic arc-cosine of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh"
    },
    asinh: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.asinh() function returns the hyperbolic arcsine of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh"
    },
    atanh: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.atanh() function returns the hyperbolic arctangent of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh"
    },
    cbrt: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.cbrt() function returns the cube root of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt"
    },
    clz32: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.clz32() function returns the number of leading zero bits in the 32-bit binary representation of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32"
    },
    cosh: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.cosh() function returns the hyperbolic cosine of a number, that can be expressed using the constant e:",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh"
    },
    expm1: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.expm1() function returns ex - 1, where x is the argument, and e the base of the natural logarithms.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1"
    },
    fround: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.fround() function returns the nearest single precision float representation of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround"
    },
    hypot: {
      "!type": "fn(value: number) -> number",
      "!doc": "The Math.hypot() function returns the square root of the sum of squares of its arguments.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot"
    },
    imul: {
      "!type": "fn(a: number, b: number) -> number",
      "!doc": "The Math.imul() function returns the result of the C-like 32-bit multiplication of the two parameters.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul"
    },
    log10: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.log10() function returns the base 10 logarithm of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10"
    },
    log1p: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.log1p() function returns the natural logarithm (base e) of 1 + a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p"
    },
    log2: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.log2() function returns the base 2 logarithm of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log2"
    },
    sign: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign"
    },
    sinh: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.sinh() function returns the hyperbolic sine of a number, that can be expressed using the constant e:",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh"
    },
    tanh: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.tanh() function returns the hyperbolic tangent of a number.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh"
    },
    trunc: {
      "!type": "fn(x: number) -> number",
      "!doc": "The Math.trunc() function returns the integral part of a number by removing any fractional digits. It does not round any numbers. The function can be expressed with the floor() and ceil() function:",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc"
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math",
    "!doc": "A built-in object that has properties and methods for mathematical constants and functions."
  },
  JSON: {
    parse: {
      "!type": "fn(json: string, reviver?: fn(key: string, value: ?) -> ?) -> ?",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse",
      "!doc": "Parse a string as JSON, optionally transforming the value produced by parsing."
    },
    stringify: {
      "!type": "fn(value: ?, replacer?: fn(key: string, value: ?) -> ?, space?: string|number) -> string",
      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify",
      "!doc": "Convert a value to JSON, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified."
    },
    "!url": "https://developer.mozilla.org/en-US/docs/JSON",
    "!doc": "JSON (JavaScript Object Notation) is a data-interchange format.  It closely resembles a subset of JavaScript syntax, although it is not a strict subset. (See JSON in the JavaScript Reference for full details.)  It is useful when writing any kind of JavaScript-based application, including websites and browser extensions.  For example, you might store user information in JSON format in a cookie, or you might store extension preferences in JSON in a string-valued browser preference."
  },
  ArrayBuffer: {
    "!type": "fn(length: number)",
    "!doc": "The ArrayBuffer object is used to represent a generic, fixed-length raw binary data buffer.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    isView: {
      "!type": "fn(arg: +ArrayBuffer) -> bool",
      "!doc": "The ArrayBuffer.isView() method returns true if arg is one of the ArrayBuffer views, such as typed array objects or a DataView; false otherwise.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView"
    },
    prototype: {
      byteLength: {
        "!type": "number",
        "!doc": "The byteLength accessor property represents the length of an ArrayBuffer in bytes.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength"
      },
      slice: {
        "!type": "fn(begin: number, end?: number) -> +ArrayBuffer",
        "!doc": "The slice() method returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's bytes from begin, inclusive, up to end, exclusive.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice"
      }
    }
  },
  DataView: {
    "!type": "fn(buffer: +ArrayBuffer, byteOffset?: number, byteLength?: number)",
    "!doc": "The DataView view provides a low-level interface for reading data from and writing it to an ArrayBuffer.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    prototype: {
      buffer: {
        "!type": "+ArrayBuffer",
        "!doc": "The buffer accessor property represents the ArrayBuffer referenced by the DataView at construction time.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/buffer"
      },
      byteLength: {
        "!type": "number",
        "!doc": "The byteLength accessor property represents the length (in bytes) of this view from the start of its ArrayBuffer.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/byteLength"
      },
      byteOffset: {
        "!type": "number",
        "!doc": "The byteOffset accessor property represents the offset (in bytes) of this view from the start of its ArrayBuffer.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/byteOffset"
      },
      getFloat32: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getFloat32() method gets a signed 32-bit integer (float) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat32"
      },
      getFloat64: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getFloat64() method gets a signed 64-bit float (double) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getFloat64"
      },
      getInt16: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getInt16() method gets a signed 16-bit integer (short) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt16"
      },
      getInt32: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getInt32() method gets a signed 32-bit integer (long) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt32"
      },
      getInt8: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getInt8() method gets a signed 8-bit integer (byte) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getInt8"
      },
      getUint16: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getUint16() method gets an unsigned 16-bit integer (unsigned short) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint16"
      },
      getUint32: {
        "!type": "fn(byteOffset: number, littleEndian?: bool) -> number",
        "!doc": "The getUint32() method gets an unsigned 32-bit integer (unsigned long) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32"
      },
      getUint8: {
        "!type": "fn(byteOffset: number) -> number",
        "!doc": "The getUint8() method gets an unsigned 8-bit integer (unsigned byte) at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint8"
      },
      setFloat32: {
        "!type": "fn(byteOffset: number, value: number, littleEndian?: bool)",
        "!doc": "The setFloat32() method stores a signed 32-bit integer (float) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat32"
      },
      setFloat64: {
        "!type": "fn(byteOffset: number, value: number, littleEndian?: bool)",
        "!doc": "The setFloat64() method stores a signed 64-bit integer (double) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setFloat64"
      },
      setInt16: {
        "!type": "fn(byteOffset: number, value: number, littleEndian?: bool)",
        "!doc": "The setInt16() method stores a signed 16-bit integer (short) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt16"
      },
      setInt32: {
        "!type": "fn(byteOffset: number, value: number, littleEndian?: bool)",
        "!doc": "The setInt32() method stores a signed 32-bit integer (long) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt32"
      },
      setInt8: {
        "!type": "fn(byteOffset: number, value: number)",
        "!doc": "The setInt8() method stores a signed 8-bit integer (byte) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setInt8"
      },
      setUint16: {
        "!type": "fn(byteOffset: number, value: number, littleEndian?: bool)",
        "!doc": "The setUint16() method stores an unsigned 16-bit integer (unsigned short) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint16"
      },
      setUint32: {
        "!type": "fn(byteOffset: number, value: number, littleEndian?: bool)",
        "!doc": "The setUint32() method stores an unsigned 32-bit integer (unsigned long) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint32"
      },
      setUint8: {
        "!type": "fn(byteOffset: number, value: number)",
        "!doc": "The setUint8() method stores an unsigned 8-bit integer (byte) value at the specified byte offset from the start of the DataView.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/setUint8"
      }
    }
  },
  Float32Array: "TypedArray",
  Float64Array: "TypedArray",
  Int16Array: "TypedArray",
  Int32Array: "TypedArray",
  Int8Array: "TypedArray",
  Map: {
    "!type": "fn(iterable?: [?])",
    "!doc": "The Map object is a simple key/value map. Any value (both objects and primitive values) may be used as either a key or a value.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    prototype: {
      clear: {
        "!type": "fn()",
        "!doc": "The clear() method removes all elements from a Map object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/clear"
      },
      delete: {
        "!type": "fn(key: ?)",
        "!doc": "The delete() method removes the specified element from a Map object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/delete"
      },
      entries: {
        "!type": "fn() -> +iter[:t=[!this.:key, !this.:value]]",
        "!doc": "The entries() method returns a new Iterator object that contains the [key, value] pairs for each element in the Map object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/entries"
      },
      forEach: {
        "!type": "fn(callback: fn(value: ?, key: ?, map: +Map), thisArg?: ?)",
        "!effects": [
          "call !0 this=!1 !this.:value !this.:key !this"
        ],
        "!doc": "The forEach() method executes a provided function once per each key/value pair in the Map object, in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach"
      },
      get: {
        "!type": "fn(key: ?) -> !this.:value",
        "!doc": "The get() method returns a specified element from a Map object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/get"
      },
      has: {
        "!type": "fn(key: ?) -> bool",
        "!doc": "The has() method returns a boolean indicating whether an element with the specified key exists or not.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/has"
      },
      keys: {
        "!type": "fn() -> +iter[:t=!this.:key]",
        "!doc": "The keys() method returns a new Iterator object that contains the keys for each element in the Map object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/keys"
      },
      set: {
        "!type": "fn(key: ?, value: ?) -> !this",
        "!effects": [
          "propagate !0 !this.:key",
          "propagate !1 !this.:value"
        ],
        "!doc": "The set() method adds a new element with a specified key and value to a Map object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/set"
      },
      size: {
        "!type": "number",
        "!doc": "The size accessor property returns the number of elements in a Map object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size"
      },
      values: {
        "!type": "fn() -> +iter[:t=!this.:value]",
        "!doc": "The values() method returns a new Iterator object that contains the values for each element in the Map object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/values"
      },
      ":Symbol.iterator": {
        "!type": "fn() -> +iter[:t=[!this.:key, !this.:value]]",
        "!doc": "Returns a new Iterator object that contains the [key, value] pairs for each element in the Map object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator"
      }
    }
  },
  Promise: {
    "!type": "fn(executor: fn(resolve: fn(value: ?), reject: fn(reason: ?))) -> !custom:Promise_ctor",
    "!doc": "The Promise object is used for deferred and asynchronous computations. A Promise is in one of the three states:",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    all: {
      "!type": "fn(iterable: [+Promise]) -> +Promise[:t=[!0.<i>.:t]]",
      "!doc": "The Promise.all(iterable) method returns a promise that resolves when all of the promises in the iterable argument have resolved.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"
    },
    race: {
      "!type": "fn(iterable: [+Promise]) -> !0.<i>",
      "!doc": "The Promise.race(iterable) method returns a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"
    },
    reject: "Promise_reject",
    resolve: {
      "!type": "fn(value: ?) -> !custom:Promise_resolve",
      "!doc": "The Promise.resolve(value) method returns a Promise object that is resolved with the given value. If the value is a thenable (i.e. has a then method), the returned promise will 'follow' that thenable, adopting its eventual state; otherwise the returned promise will be fulfilled with the value.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"
    },
    prototype: "Promise.prototype"
  },
  Proxy: {
    "!type": "fn(target: ?, handler: Proxy_handler)",
    "!doc": "The Proxy object is used to define the custom behavior in JavaScript fundamental operation (e.g. property lookup, assignment, enumeration, function invocation, etc).",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    revocable: {
      "!type": "fn(target: ?, handler: Proxy_handler) -> Proxy_revocable",
      "!doc": "The Proxy.revocable() method is used to create a revocable Proxy object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/revocable"
    }
  },
  Reflect: {
    "!doc": "Reflect is a built-in object that provides methods for interceptable JavaScript operations.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    apply: {
      "!type": "fn(target: fn(), thisArg?: ?, argumentList?: [?]) -> !0.!ret",
      "!doc": "Calls a target function with arguments as specified.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply"
    },
    construct: {
      "!type": "fn(target: fn(), argumentList?: [?]) -> ?",
      "!doc": "Acts like the new operator as a function. It is equivalent to calling new target(...args).",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct"
    },
    defineProperty: {
      "!type": "fn(target: ?, property: string, descriptor: propertyDescriptor) -> bool",
      "!doc": "The static Reflect.defineProperty() method is like Object.defineProperty() but returns a Boolean.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/defineProperty"
    },
    deleteProperty: {
      "!type": "fn(target: ?, property: string) -> bool",
      "!doc": "Works like the delete operator as a function.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty"
    },
    enumerate: {
      "!type": "fn(target: ?) -> +iter[:t=string]",
      "!doc": "Returns an iterator with the enumerable own and inherited properties of the target object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/enumerate"
    },
    get: {
      "!type": "fn(target: ?, property: string) -> ?",
      "!doc": "Gets a property from an object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get"
    },
    getOwnPropertyDescriptor: {
      "!type": "fn(target: ?, property: string) -> ?",
      "!doc": "Returns a property descriptor of the given property if it exists on the object, undefined otherwise.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getOwnPropertyDescriptor"
    },
    getPrototypeOf: {
      "!type": "fn(target: ?) -> ?",
      "!doc": "Returns the prototype of the specified object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/getPrototypeOf"
    },
    has: {
      "!type": "fn(target: ?, property: string) -> bool",
      "!doc": "The static Reflect.has() method works like the in operator as a function.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/has"
    },
    isExtensible: {
      "!type": "fn(target: ?) -> bool",
      "!doc": "Determines if an object is extensible (whether it can have new properties added to it).",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/isExtensible"
    },
    ownKeys: {
      "!type": "fn(target: ?) -> [string]",
      "!doc": "Returns an array of the target object's own property keys.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys"
    },
    preventExtensions: {
      "!type": "fn(target: ?) -> bool",
      "!doc": "Prevents new properties from ever being added to an object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/preventExtensions"
    },
    set: {
      "!type": "fn(target: ?, property: string, value: ?) -> bool",
      "!doc": "Set a property on an object.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/set"
    },
    setPrototypeOf: {
      "!type": "fn(target: ?, prototype: ?) -> bool",
      "!doc": "Sets the prototype of a specified object to another object or to null.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/setPrototypeOf"
    }
  },
  Set: {
    "!type": "fn(iterable?: [?])",
    "!doc": "The Set object lets you store unique values of any type, whether primitive values or object references.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    prototype: {
      add: {
        "!type": "fn(value: ?) -> !this",
        "!effects": [
          "propagate !0 !this.:t"
        ],
        "!doc": "The add() method appends a new element with a specified value to the end of a Set object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add"
      },
      clear: {
        "!type": "fn()",
        "!doc": "The clear() method removes all elements from a Set object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/clear"
      },
      delete: {
        "!type": "fn(value: ?) -> bool",
        "!doc": "The delete() method removes the specified element from a Set object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/delete"
      },
      entries: {
        "!type": "fn() -> +iter[:t=[!this.:t]]",
        "!doc": "The entries() method returns a new Iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. For Set objects there is no key like in Map objects. However, to keep the API similar to the Map object, each entry has the same value for its key and value here, so that an array [value, value] is returned.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/entries"
      },
      forEach: {
        "!type": "fn(callback: fn(value: ?, value2: ?, set: +Set), thisArg?: ?)",
        "!effects": [
          "call !0 this=!1 !this.:t number !this"
        ],
        "!doc": "The forEach() method executes a provided function once per each value in the Set object, in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach"
      },
      has: {
        "!type": "fn(value: ?) -> bool",
        "!doc": "The has() method returns a boolean indicating whether an element with the specified value exists in a Set object or not.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has"
      },
      keys: {
        "!type": "fn() -> +iter[:t=!this.:t]",
        "!doc": "The values() method returns a new Iterator object that contains the values for each element in the Set object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/keys"
      },
      size: {
        "!type": "number",
        "!doc": "The size accessor property returns the number of elements in a Set object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/size"
      },
      values: {
        "!type": "fn() -> +iter[:t=!this.:t]",
        "!doc": "The values() method returns a new Iterator object that contains the values for each element in the Set object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/values"
      },
      ":Symbol.iterator": {
        "!type": "fn() -> +iter[:t=!this.:t]",
        "!doc": "Returns a new Iterator object that contains the values for each element in the Set object in insertion order.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/@@iterator"
      }
    }
  },
  Symbol: {
    "!type": "fn(description?: string) -> !custom:getSymbol",
    "!doc": "A symbol is a unique and immutable data type and may be used as an identifier for object properties. The symbol object is an implicit object wrapper for the symbol primitive data type.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    for: {
      "!type": "fn(key: string) -> !custom:getSymbol",
      "!doc": "The Symbol.for(key) method searches for existing symbols in a runtime-wide symbol registry with the given key and returns it if found. Otherwise a new symbol gets created in the global symbol registry with this key.",
      "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for"
    },
    keyFor: ":Symbol.keyFor",
    hasInstance: ":Symbol.hasInstance",
    isConcatSpreadable: ":Symbol.isConcatSpreadable",
    iterator: ":Symbol.iterator",
    match: ":Symbol.match",
    replace: ":Symbol.replace",
    search: ":Symbol.search",
    species: ":Symbol.species",
    split: ":Symbol.split",
    toStringTag: ":Symbol.toStringTag",
    unscopables: ":Symbol.unscopables",
    prototype: {
      "!stdProto": "Symbol"
    }
  },
  Uint16Array: "TypedArray",
  Uint32Array: "TypedArray",
  Uint8Array: "TypedArray",
  Uint8ClampedArray: "TypedArray",
  WeakMap: {
    "!type": "fn(iterable?: [?])",
    "!doc": "The WeakMap object is a collection of key/value pairs in which the keys are objects and the values can be arbitrary values.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    prototype: {
      delete: {
        "!type": "fn(key: ?) -> bool",
        "!doc": "The delete() method removes the specified element from a WeakMap object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/delete"
      },
      get: {
        "!type": "fn(key: ?) -> !this.:value",
        "!doc": "The get() method returns a specified element from a WeakMap object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/get"
      },
      has: {
        "!type": "fn(key: ?) -> bool",
        "!doc": "The has() method returns a boolean indicating whether an element with the specified key exists in the WeakMap object or not.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/has"
      },
      set: {
        "!type": "fn(key: ?, value: ?)",
        "!effects": [
          "propagate !0 !this.:key",
          "propagate !1 !this.:value"
        ],
        "!doc": "The set() method adds a new element with a specified key and value to a WeakMap object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap/set"
      }
    }
  },
  WeakSet: {
    "!type": "fn(iterable?: [?])",
    "!doc": "The WeakSet object lets you store weakly held objects in a collection.",
    "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    prototype: {
      add: {
        "!type": "fn(value: ?)",
        "!doc": "The add() method appends a new object to the end of a WeakSet object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/add"
      },
      delete: {
        "!type": "fn(value: ?) -> bool",
        "!doc": "The delete() method removes the specified element from a WeakSet object.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/delete"
      },
      has: {
        "!type": "fn(value: ?) -> bool",
        "!doc": "The has() method returns a boolean indicating whether an object exists in a WeakSet or not.",
        "!url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/has"
      }
    }
  },
  window: NP,
  uuid: PP,
  numbro: _P,
  Papa: bP
};
var gc = class {
  constructor() {
    Zr(this, "isFunction");
    this.completionSource = this.completionSource.bind(this);
  }
  setIsFunction(t) {
    this.isFunction = t;
  }
};
var CP = [
  // @ts-ignore
  vP
];
var Li = ((e) => (e.OBJECT = "Object", e.NUMBER = "Number", e.ARRAY = "Array", e.FUNCTION = "Function", e.BOOLEAN = "Boolean", e.STRING = "String", e.UNKNOWN = "Unknown", e))(Li || {});
function LP(e) {
  return e === "?" ? "Unknown" : e === "number" ? "Number" : e === "string" ? "String" : e === "bool" ? "Boolean" : e === "array" ? "Array" : /^fn\(/.test(e) ? "Function" : /^\[/.test(e) ? "Array" : "Object";
}
var xP = new IP.Server({
  defs: CP
});
var DP = class extends gc {
  completionSource(t) {
    if (!ic(t, this.isFunction) || t.matchBefore(/\w[\w\.]*/) === null && (this.isFunction || t.matchBefore(/\{\{\s*/) === null))
      return null;
    const i = t.state, a = {
      type: "completions",
      types: true,
      docs: true,
      urls: true,
      origins: true,
      caseInsensitive: true,
      guess: false,
      inLiteral: false,
      includeKeywords: true,
      end: t.pos,
      file: "#0"
    }, s = [{
      type: "full",
      name: "_temp",
      text: i.sliceDoc()
    }], o = {
      query: a,
      files: s
    };
    let l, c;
    if (xP.request(o, (O, d2) => {
      l = O, c = d2;
    }), l || c.completions.length === 0)
      return null;
    const f = [];
    for (const O of c.completions) {
      const d2 = LP(O.type), g = {
        type: d2,
        // icon
        label: O.name,
        detail: d2,
        // short message after label
        // apply,
        // info to add: completion.name, completion.url, completion.type, completion.doc
        info: O.doc === void 0 ? void 0 : (L) => {
          let D = document.createElement("div");
          return D.innerHTML = `
                  <div class="hintDiv" onclick='javascript:window.open("${O.url}")' >
                    <svg width="16px" height="16px" class="hintSvg" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round">
                          <g transform="translate(8.000000, 8.000000) rotate(30.000000) translate(-8.000000, -8.000000) translate(5.000000, 1.500000)" stroke="#4965F2" stroke-width="1.5">
                              <path d="M0,4.5 L0,3 C0,1.34314575 1.34314575,0 3,0 C4.65685425,0 6,1.34314575 6,3 L6,4.5 L6,4.5 M6,8.5 L6,10 C6,11.6568542 4.65685425,13 3,13 C1.34314575,13 0,11.6568542 0,10 L0,8.5 L0,8.5"></path>
                              <line x1="3" y1="4" x2="3" y2="9"></line>
                          </g>
                      </g>
                    </svg>
                    <span class="hintName">${O.name}</span>
                  </div>
                  <span class="hintType">${O.type}</span>
                  <span class="hintDoc">${O.doc}</span>
                  `, D;
        },
        boost: -1
      };
      f.push(g);
    }
    return {
      from: c.start,
      validFor: /^\w*$/,
      options: f
    };
  }
};
var yd = ["value", "selectedRow", "data", "text"];
var UP = ["setValue", "setData"];
var wP = class extends gc {
  constructor() {
    super(...arguments);
    Zr(this, "data");
    Zr(this, "boostExposingData");
  }
  completionSource(r) {
    if (this.data === void 0 || !ic(r, this.isFunction))
      return null;
    const i = r.matchBefore(/(?:[A-Za-z_$][\w$]*(?:\[\s*(?:\d+|(["'])(?:[^\1\\]|\\.)*?\1)\s*\])*\.)*(?:[A-Za-z_$][\w$]*)?/);
    if (!i || i.text.length === 0 && (this.isFunction || r.matchBefore(/\{\{\s*/) === null))
      return null;
    const n = MP(this.data, i.text);
    if (!n)
      return null;
    const [a, s, o] = n, l = Object.keys(a).filter((p) => p.startsWith(o)), c = l.map((p) => {
      var L;
      const O = Id(a[p]), d2 = s === 0 && ((L = this.boostExposingData) == null ? void 0 : L.hasOwnProperty(p));
      return {
        type: h1.lowerCase(O),
        label: p,
        detail: h1.capitalize(O),
        boost: d2 ? 20 : yd.includes(p) ? 3 : UP.includes(p) ? 2 : 1,
        apply: s === 0 ? void 0 : (D, W, x, V) => {
          D.dispatch({
            changes: {
              from: x - 1,
              to: V,
              insert: p.match(/^[A-Za-z_$][\w$]*$/) ? `.${p}` : `['${p.replace(/[\\']/g, (_2) => "\\" + _2)}']`
            }
          });
        }
      };
    });
    return {
      from: i.from + s,
      validFor: /^\w*$/,
      options: kP(a, l).concat(c)
    };
  }
};
function MP(e, t) {
  const r = t.lastIndexOf(".");
  if (r < 0)
    return [e, 0, t];
  try {
    const i = GJ(t.slice(0, r), e);
    if (typeof i == "object" && i && !Array.isArray(i))
      return [i, r + 1, t.slice(r + 1)];
  } catch {
    return;
  }
}
function Id(e) {
  const t = typeof e;
  return t === "number" ? Li.NUMBER : t === "string" ? Li.STRING : t === "boolean" ? Li.BOOLEAN : h1.isArray(e) ? Li.ARRAY : h1.isFunction(e) ? Li.FUNCTION : Li.OBJECT;
}
function kP(e, t) {
  return t.filter((r) => e[r]).flatMap((r) => yd.filter((i) => e[r].hasOwnProperty(i)).map((i) => {
    const n = Id(e[r][i]);
    return {
      type: h1.lowerCase(n),
      label: r + "." + i,
      detail: h1.capitalize(n),
      boost: 10
    };
  }));
}
var QP = "";
var GP = "add after all alter and any as asc before begin between by case cast column count create cross current_timestamp cursor declare default delete desc describe distinct drop else end except exists fetch first from full function group having if in inner insert intersect into is join key last lateral left like limit natural next not on option or order outer prepare primary right select set similar some table then to union unique update using when where with without ";
var VP = h1.fromPairs([...QP.split(" ").map((e) => [
  e,
  1
  /* TYPE */
]), ...GP.split(" ").map((e) => [
  e,
  2
  /* KEYWORD */
])]);
var BP = /* @__PURE__ */ new Set(["select", "distinct", "from", "where", "and", "or", "not", "in", "between", "like", "group", "grouping", "order", "by", "limit", "asc", "desc", "as", "join", "inner", "outer", "intersect", "union", "using", "count", "exists", "having"]);
function $P(e, t, r) {
  var n;
  let i = Object.keys(e).map((a) => ({
    label: t ? a.toUpperCase() : a,
    detail: e[a] === 1 ? "type" : e[a] === 2 ? "keyword" : "variable",
    boost: BP.has(a) ? 2 : -1
  }));
  return r && (i = i.concat((n = Object.keys(r)) == null ? void 0 : n.map((a) => ({
    label: a,
    detail: r[a],
    boost: -1
  })))), Uu(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Ys(i));
}
var YP = class extends gc {
  constructor() {
    super(...arguments);
    Zr(this, "metaData");
  }
  completionSource(r) {
    return FP(r, this.metaData, this.isFunction);
  }
};
function FP(e, t, r) {
  if (ic(e, r))
    return null;
  const i = e.matchBefore(/[\w.]*/);
  return !i || i.text.length === 0 ? null : $P(VP, true, t)(e);
}
var Nd = {};
var Yr = {};
var _l = { exports: {} };
var bl = { exports: {} };
var Na = {};
Object.defineProperty(Na, "__esModule", {
  value: true
});
Na.indentString = WP;
Na.isTabularStyle = XP;
function WP(e) {
  return e.indentStyle === "tabularLeft" || e.indentStyle === "tabularRight" ? " ".repeat(10) : e.useTabs ? "	" : " ".repeat(e.tabWidth);
}
function XP(e) {
  return e.indentStyle === "tabularLeft" || e.indentStyle === "tabularRight";
}
var vl = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  function r(o, l) {
    if (!(o instanceof l))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(o, l) {
    for (var c = 0; c < l.length; c++) {
      var f = l[c];
      f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(o, f.key, f);
    }
  }
  function n(o, l, c) {
    return l && i(o.prototype, l), c && i(o, c), Object.defineProperty(o, "prototype", { writable: false }), o;
  }
  function a(o, l, c) {
    return l in o ? Object.defineProperty(o, l, { value: c, enumerable: true, configurable: true, writable: true }) : o[l] = c, o;
  }
  var s = function() {
    function o(l) {
      r(this, o), a(this, "params", void 0), a(this, "index", void 0), this.params = l, this.index = 0;
    }
    return n(o, [{
      key: "get",
      value: function(c) {
        var f = c.key, p = c.value;
        return this.params ? f ? this.params[f] : this.params[this.index++] : p;
      }
    }]), o;
  }();
  t.default = s, e.exports = t.default;
})(vl, vl.exports);
var jP = vl.exports;
var Cl = { exports: {} };
var it = {};
Object.defineProperty(it, "__esModule", {
  value: true
});
it.testToken = it.isToken = it.isReserved = it.isCommand = it.TokenType = it.EOF_TOKEN = void 0;
var ze;
it.TokenType = ze;
(function(e) {
  e.QUOTED_IDENTIFIER = "QUOTED_IDENTIFIER", e.IDENTIFIER = "IDENTIFIER", e.STRING = "STRING", e.VARIABLE = "VARIABLE", e.RESERVED_KEYWORD = "RESERVED_KEYWORD", e.RESERVED_LOGICAL_OPERATOR = "RESERVED_LOGICAL_OPERATOR", e.RESERVED_DEPENDENT_CLAUSE = "RESERVED_DEPENDENT_CLAUSE", e.RESERVED_BINARY_COMMAND = "RESERVED_BINARY_COMMAND", e.RESERVED_COMMAND = "RESERVED_COMMAND", e.RESERVED_JOIN = "RESERVED_JOIN", e.RESERVED_JOIN_CONDITION = "RESERVED_JOIN_CONDITION", e.RESERVED_CASE_START = "RESERVED_CASE_START", e.RESERVED_CASE_END = "RESERVED_CASE_END", e.OPERATOR = "OPERATOR", e.COMMA = "COMMA", e.OPEN_PAREN = "OPEN_PAREN", e.CLOSE_PAREN = "CLOSE_PAREN", e.LINE_COMMENT = "LINE_COMMENT", e.BLOCK_COMMENT = "BLOCK_COMMENT", e.NUMBER = "NUMBER", e.NAMED_PARAMETER = "NAMED_PARAMETER", e.QUOTED_PARAMETER = "QUOTED_PARAMETER", e.INDEXED_PARAMETER = "INDEXED_PARAMETER", e.POSITIONAL_PARAMETER = "POSITIONAL_PARAMETER", e.DELIMITER = "DELIMITER", e.EOF = "EOF";
})(ze || (it.TokenType = ze = {}));
var ZP = {
  type: ze.EOF,
  text: "EOF",
  value: "EOF"
};
it.EOF_TOKEN = ZP;
var kt = function(t) {
  return function(r) {
    return r.type === t.type && r.value === t.value;
  };
};
it.testToken = kt;
var HP = {
  AS: kt({
    value: "AS",
    type: ze.RESERVED_KEYWORD
  }),
  AND: kt({
    value: "AND",
    type: ze.RESERVED_LOGICAL_OPERATOR
  }),
  ARRAY: kt({
    value: "ARRAY",
    type: ze.RESERVED_KEYWORD
  }),
  BETWEEN: kt({
    value: "BETWEEN",
    type: ze.RESERVED_KEYWORD
  }),
  CASE: kt({
    value: "CASE",
    type: ze.RESERVED_CASE_START
  }),
  CAST: kt({
    value: "CAST",
    type: ze.RESERVED_KEYWORD
  }),
  BY: kt({
    value: "BY",
    type: ze.RESERVED_KEYWORD
  }),
  END: kt({
    value: "END",
    type: ze.RESERVED_CASE_END
  }),
  FROM: kt({
    value: "FROM",
    type: ze.RESERVED_COMMAND
  }),
  LIMIT: kt({
    value: "LIMIT",
    type: ze.RESERVED_COMMAND
  }),
  SELECT: kt({
    value: "SELECT",
    type: ze.RESERVED_COMMAND
  }),
  SET: kt({
    value: "SET",
    type: ze.RESERVED_COMMAND
  }),
  STRUCT: kt({
    value: "STRUCT",
    type: ze.RESERVED_KEYWORD
  }),
  TABLE: kt({
    value: "TABLE",
    type: ze.RESERVED_KEYWORD
  }),
  WINDOW: kt({
    value: "WINDOW",
    type: ze.RESERVED_COMMAND
  }),
  WITH: kt({
    value: "WITH",
    type: ze.RESERVED_COMMAND
  })
};
it.isToken = HP;
var zP = function(t) {
  return t.type === ze.RESERVED_COMMAND || t.type === ze.RESERVED_BINARY_COMMAND;
};
it.isCommand = zP;
var qP = function(t) {
  return t.type === ze.RESERVED_KEYWORD || t.type === ze.RESERVED_LOGICAL_OPERATOR || t.type === ze.RESERVED_DEPENDENT_CLAUSE || t.type === ze.RESERVED_JOIN_CONDITION || t.type === ze.RESERVED_COMMAND || t.type === ze.RESERVED_BINARY_COMMAND || t.type === ze.RESERVED_JOIN || t.type === ze.RESERVED_CASE_START || t.type === ze.RESERVED_CASE_END;
};
it.isReserved = qP;
var ii = {};
Object.defineProperty(ii, "__esModule", {
  value: true
});
ii.isTokenNode = ii.NodeType = void 0;
var Ll;
ii.NodeType = Ll;
(function(e) {
  e.statement = "statement", e.clause = "clause", e.binary_clause = "binary_clause", e.function_call = "function_call", e.array_subscript = "array_subscript", e.parenthesis = "parenthesis", e.between_predicate = "between_predicate", e.limit_clause = "limit_clause", e.all_columns_asterisk = "all_columns_asterisk", e.token = "token";
})(Ll || (ii.NodeType = Ll = {}));
var JP = function(t) {
  return t.type === "token";
};
ii.isTokenNode = JP;
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var r = it, i = ii;
  function n(c, f) {
    if (!(c instanceof f))
      throw new TypeError("Cannot call a class as a function");
  }
  function a(c, f) {
    for (var p = 0; p < f.length; p++) {
      var O = f[p];
      O.enumerable = O.enumerable || false, O.configurable = true, "value" in O && (O.writable = true), Object.defineProperty(c, O.key, O);
    }
  }
  function s(c, f, p) {
    return f && a(c.prototype, f), p && a(c, p), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function o(c, f, p) {
    return f in c ? Object.defineProperty(c, f, { value: p, enumerable: true, configurable: true, writable: true }) : c[f] = p, c;
  }
  var l = function() {
    function c(f) {
      n(this, c), this.tokens = f, o(this, "index", 0);
    }
    return s(c, [{
      key: "parse",
      value: function() {
        for (var p = [], O; O = this.statement(); )
          p.push(O);
        return p;
      }
    }, {
      key: "statement",
      value: function() {
        for (var p = []; ; ) {
          if (this.look().type === r.TokenType.DELIMITER)
            return this.next(), {
              type: i.NodeType.statement,
              children: p,
              hasSemicolon: true
            };
          if (this.look().type === r.TokenType.EOF)
            return p.length > 0 ? {
              type: i.NodeType.statement,
              children: p,
              hasSemicolon: false
            } : void 0;
          p.push(this.expression());
        }
      }
    }, {
      key: "expression",
      value: function() {
        return this.limitClause() || this.clause() || this.binaryClause() || this.functionCall() || this.arraySubscript() || this.parenthesis() || this.betweenPredicate() || this.allColumnsAsterisk() || this.nextTokenNode();
      }
    }, {
      key: "clause",
      value: function() {
        if (this.look().type === r.TokenType.RESERVED_COMMAND) {
          var p = this.next(), O = this.expressionsUntilClauseEnd();
          return {
            type: i.NodeType.clause,
            nameToken: p,
            children: O
          };
        }
      }
    }, {
      key: "binaryClause",
      value: function() {
        if (this.look().type === r.TokenType.RESERVED_BINARY_COMMAND) {
          var p = this.next(), O = this.expressionsUntilClauseEnd();
          return {
            type: i.NodeType.binary_clause,
            nameToken: p,
            children: O
          };
        }
      }
    }, {
      key: "functionCall",
      value: function() {
        if ((this.look().type === r.TokenType.RESERVED_KEYWORD || this.look().type === r.TokenType.IDENTIFIER) && this.look(1).value === "(" && !this.look(1).whitespaceBefore)
          return {
            type: i.NodeType.function_call,
            nameToken: this.next(),
            parenthesis: this.parenthesis()
          };
      }
    }, {
      key: "arraySubscript",
      value: function() {
        if ((this.look().type === r.TokenType.RESERVED_KEYWORD || this.look().type === r.TokenType.IDENTIFIER) && this.look(1).value === "[")
          return {
            type: i.NodeType.array_subscript,
            arrayToken: this.next(),
            parenthesis: this.parenthesis()
          };
      }
    }, {
      key: "parenthesis",
      value: function() {
        if (this.look().type === r.TokenType.OPEN_PAREN) {
          for (var p = [], O = this.next(), d2 = O.value, g = ""; this.look().type !== r.TokenType.CLOSE_PAREN && this.look().type !== r.TokenType.EOF; )
            p.push(this.expression());
          return this.look().type === r.TokenType.CLOSE_PAREN && (g = this.next().value), {
            type: i.NodeType.parenthesis,
            children: p,
            openParen: d2,
            closeParen: g
          };
        }
      }
    }, {
      key: "betweenPredicate",
      value: function() {
        if (r.isToken.BETWEEN(this.look()) && r.isToken.AND(this.look(2)))
          return {
            type: i.NodeType.between_predicate,
            betweenToken: this.next(),
            expr1: this.next(),
            andToken: this.next(),
            expr2: this.next()
          };
      }
    }, {
      key: "limitClause",
      value: function() {
        if (r.isToken.LIMIT(this.look())) {
          var p = this.next(), O = this.expressionsUntilClauseEnd(function(g) {
            return g.type === r.TokenType.COMMA;
          });
          if (this.look().type === r.TokenType.COMMA) {
            this.next();
            var d2 = this.expressionsUntilClauseEnd();
            return {
              type: i.NodeType.limit_clause,
              limitToken: p,
              offset: O,
              count: d2
            };
          } else
            return {
              type: i.NodeType.limit_clause,
              limitToken: p,
              count: O
            };
        }
      }
    }, {
      key: "allColumnsAsterisk",
      value: function() {
        if (this.look().value === "*" && r.isToken.SELECT(this.look(-1)))
          return this.next(), {
            type: i.NodeType.all_columns_asterisk
          };
      }
    }, {
      key: "expressionsUntilClauseEnd",
      value: function() {
        for (var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
          return false;
        }, O = []; this.look().type !== r.TokenType.RESERVED_COMMAND && this.look().type !== r.TokenType.RESERVED_BINARY_COMMAND && this.look().type !== r.TokenType.EOF && this.look().type !== r.TokenType.CLOSE_PAREN && this.look().type !== r.TokenType.DELIMITER && !p(this.look()); )
          O.push(this.expression());
        return O;
      }
      // Returns current token without advancing the pointer
    }, {
      key: "look",
      value: function() {
        var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        return this.tokens[this.index + p] || r.EOF_TOKEN;
      }
      // Returns current token and advances the pointer to next token
    }, {
      key: "next",
      value: function() {
        return this.tokens[this.index++] || r.EOF_TOKEN;
      }
    }, {
      key: "nextTokenNode",
      value: function() {
        return {
          type: i.NodeType.token,
          token: this.next()
        };
      }
    }]), c;
  }();
  t.default = l, e.exports = t.default;
})(Cl, Cl.exports);
var KP = Cl.exports;
var xl = { exports: {} };
var Xe = {};
Object.defineProperty(Xe, "__esModule", {
  value: true
});
Xe.sum = Xe.sortByLengthDesc = Xe.maxLength = Xe.last = Xe.equalizeWhitespace = Xe.dedupe = void 0;
function e_(e, t) {
  var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!r) {
    if (Array.isArray(e) || (r = Pd(e)) || t && e && typeof e.length == "number") {
      r && (e = r);
      var i = 0, n = function() {
      };
      return { s: n, n: function() {
        return i >= e.length ? { done: true } : { done: false, value: e[i++] };
      }, e: function(c) {
        throw c;
      }, f: n };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a = true, s = false, o;
  return { s: function() {
    r = r.call(e);
  }, n: function() {
    var c = r.next();
    return a = c.done, c;
  }, e: function(c) {
    s = true, o = c;
  }, f: function() {
    try {
      !a && r.return != null && r.return();
    } finally {
      if (s)
        throw o;
    }
  } };
}
function t_(e) {
  return n_(e) || i_(e) || Pd(e) || r_();
}
function r_() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Pd(e, t) {
  if (e) {
    if (typeof e == "string")
      return Dl(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set")
      return Array.from(e);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return Dl(e, t);
  }
}
function i_(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function n_(e) {
  if (Array.isArray(e))
    return Dl(e);
}
function Dl(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, i = new Array(t); r < t; r++)
    i[r] = e[r];
  return i;
}
var a_ = function(t) {
  return t_(new Set(t));
};
Xe.dedupe = a_;
var s_ = function(t) {
  return t[t.length - 1];
};
Xe.last = s_;
var o_ = function(t) {
  return t.sort(function(r, i) {
    return i.length - r.length || r.localeCompare(i);
  });
};
Xe.sortByLengthDesc = o_;
var l_ = function(t) {
  return t.reduce(function(r, i) {
    return Math.max(r, i.length);
  }, 0);
};
Xe.maxLength = l_;
var u_ = function(t) {
  return t.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/g, " ");
};
Xe.equalizeWhitespace = u_;
var c_ = function(t) {
  var r = 0, i = e_(t), n;
  try {
    for (i.s(); !(n = i.n()).done; ) {
      var a = n.value;
      r += a;
    }
  } catch (s) {
    i.e(s);
  } finally {
    i.f();
  }
  return r;
};
Xe.sum = c_;
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = f;
  var r = Xe;
  function i(D, W) {
    return l(D) || o(D, W) || a(D, W) || n();
  }
  function n() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function a(D, W) {
    if (D) {
      if (typeof D == "string")
        return s(D, W);
      var x = Object.prototype.toString.call(D).slice(8, -1);
      if (x === "Object" && D.constructor && (x = D.constructor.name), x === "Map" || x === "Set")
        return Array.from(D);
      if (x === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(x))
        return s(D, W);
    }
  }
  function s(D, W) {
    (W == null || W > D.length) && (W = D.length);
    for (var x = 0, V = new Array(W); x < W; x++)
      V[x] = D[x];
    return V;
  }
  function o(D, W) {
    var x = D == null ? null : typeof Symbol < "u" && D[Symbol.iterator] || D["@@iterator"];
    if (x != null) {
      var V = [], _2 = true, $ = false, z, F;
      try {
        for (x = x.call(D); !(_2 = (z = x.next()).done) && (V.push(z.value), !(W && V.length === W)); _2 = true)
          ;
      } catch (ae) {
        $ = true, F = ae;
      } finally {
        try {
          !_2 && x.return != null && x.return();
        } finally {
          if ($)
            throw F;
        }
      }
      return V;
    }
  }
  function l(D) {
    if (Array.isArray(D))
      return D;
  }
  var c = /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/;
  function f(D, W, x) {
    return p(D.split(`
`)).flatMap(function(V) {
      if (V.length === 1)
        return V;
      if (W === "tabular")
        return O(V);
      if (W === "before")
        return d2(V, x);
      throw new Error("Unexpected commaPosition: ".concat(W));
    }).join(`
`);
  }
  function p(D) {
    for (var W = [], x = 0; x < D.length; x++) {
      for (var V = [D[x]]; D[x].match(/.*,$/); )
        x++, V.push(D[x]);
      W.push(V);
    }
    return W;
  }
  function O(D) {
    var W = (0, r.maxLength)(D);
    return L(D).map(function(x, V) {
      return V === D.length - 1 ? x : x + " ".repeat(W - x.length - 1) + ",";
    });
  }
  function d2(D, W) {
    return L(D).map(function(x, V) {
      if (V === 0)
        return x;
      var _2 = x.match(c) || [""], $ = i(_2, 1), z = $[0];
      return g(z, W) + W.replace(/ {2}$/, ", ") + // add comma to the end of last indent
      x.trimStart();
    });
  }
  function g(D, W) {
    return D.replace(new RegExp(W + "$"), "");
  }
  function L(D) {
    return D.map(function(W) {
      return W.replace(/,$/, "");
    });
  }
  e.exports = t.default;
})(xl, xl.exports);
var f_ = xl.exports;
var Ul = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = c;
  var r = Xe;
  function i(f) {
    return o(f) || s(f) || a(f) || n();
  }
  function n() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function a(f, p) {
    if (f) {
      if (typeof f == "string")
        return l(f, p);
      var O = Object.prototype.toString.call(f).slice(8, -1);
      if (O === "Object" && f.constructor && (O = f.constructor.name), O === "Map" || O === "Set")
        return Array.from(f);
      if (O === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(O))
        return l(f, p);
    }
  }
  function s(f) {
    if (typeof Symbol < "u" && f[Symbol.iterator] != null || f["@@iterator"] != null)
      return Array.from(f);
  }
  function o(f) {
    if (Array.isArray(f))
      return l(f);
  }
  function l(f, p) {
    (p == null || p > f.length) && (p = f.length);
    for (var O = 0, d2 = new Array(p); O < p; O++)
      d2[O] = f[O];
    return d2;
  }
  function c(f) {
    for (var p = f.split(`
`), O = [], d2 = 0; d2 < p.length; d2++) {
      if (p[d2].match(/^\s*SELECT/i)) {
        var g = function() {
          var L = [];
          if (p[d2].match(/.*,$/))
            L = [p[d2]];
          else {
            if (O.push(p[d2]), p[d2].match(/^\s*SELECT\s+.+(?!,$)/i))
              return "continue";
            L.push(p[++d2]);
          }
          for (; p[d2++].match(/.*,$/); )
            L.push(p[d2]);
          var D = L.map(function(x) {
            return {
              line: x,
              matches: x.match(/(^.*?\S) (AS )?(\S+,?$)/i)
            };
          }).map(function(x) {
            var V = x.line, _2 = x.matches;
            return _2 ? {
              precedingText: _2[1],
              as: _2[2],
              alias: _2[3]
            } : {
              precedingText: V
            };
          }), W = (0, r.maxLength)(D.map(function(x) {
            var V = x.precedingText;
            return V.replace(/\s*,\s*$/, "");
          }));
          L = D.map(function(x) {
            var V = x.precedingText, _2 = x.as, $ = x.alias;
            return V + ($ ? " ".repeat(W - V.length + 1) + (_2 ?? "") + $ : "");
          }), O = [].concat(i(O), i(L));
        }();
        if (g === "continue")
          continue;
      }
      O.push(p[d2]);
    }
    return O.join(`
`);
  }
  e.exports = t.default;
})(Ul, Ul.exports);
var h_ = Ul.exports;
var wl = { exports: {} };
var Ml = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var r = Xe, i = it, n = ii;
  function a(O, d2) {
    var g = typeof Symbol < "u" && O[Symbol.iterator] || O["@@iterator"];
    if (!g) {
      if (Array.isArray(O) || (g = s(O)) || d2 && O && typeof O.length == "number") {
        g && (O = g);
        var L = 0, D = function() {
        };
        return { s: D, n: function() {
          return L >= O.length ? { done: true } : { done: false, value: O[L++] };
        }, e: function($) {
          throw $;
        }, f: D };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var W = true, x = false, V;
    return { s: function() {
      g = g.call(O);
    }, n: function() {
      var $ = g.next();
      return W = $.done, $;
    }, e: function($) {
      x = true, V = $;
    }, f: function() {
      try {
        !W && g.return != null && g.return();
      } finally {
        if (x)
          throw V;
      }
    } };
  }
  function s(O, d2) {
    if (O) {
      if (typeof O == "string")
        return o(O, d2);
      var g = Object.prototype.toString.call(O).slice(8, -1);
      if (g === "Object" && O.constructor && (g = O.constructor.name), g === "Map" || g === "Set")
        return Array.from(O);
      if (g === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(g))
        return o(O, d2);
    }
  }
  function o(O, d2) {
    (d2 == null || d2 > O.length) && (d2 = O.length);
    for (var g = 0, L = new Array(d2); g < d2; g++)
      L[g] = O[g];
    return L;
  }
  function l(O, d2) {
    if (!(O instanceof d2))
      throw new TypeError("Cannot call a class as a function");
  }
  function c(O, d2) {
    for (var g = 0; g < d2.length; g++) {
      var L = d2[g];
      L.enumerable = L.enumerable || false, L.configurable = true, "value" in L && (L.writable = true), Object.defineProperty(O, L.key, L);
    }
  }
  function f(O, d2, g) {
    return d2 && c(O.prototype, d2), g && c(O, g), Object.defineProperty(O, "prototype", { writable: false }), O;
  }
  var p = function() {
    function O(d2) {
      l(this, O), this.expressionWidth = d2;
    }
    return f(O, [{
      key: "isInlineBlock",
      value: function(g) {
        return this.inlineWidth(g) <= this.expressionWidth;
      }
    }, {
      key: "inlineWidth",
      value: function(g) {
        var L = 2, D = a(g.children), W;
        try {
          for (D.s(); !(W = D.n()).done; ) {
            var x = W.value;
            switch (x.type) {
              case n.NodeType.function_call:
                L += x.nameToken.value.length + this.inlineWidth(x.parenthesis);
                break;
              case n.NodeType.array_subscript:
                L += x.arrayToken.value.length + this.inlineWidth(x.parenthesis);
                break;
              case n.NodeType.parenthesis:
                L += this.inlineWidth(x);
                break;
              case n.NodeType.between_predicate:
                L += this.betweenWidth(x);
                break;
              case n.NodeType.clause:
              case n.NodeType.limit_clause:
              case n.NodeType.binary_clause:
                return 1 / 0;
              case n.NodeType.all_columns_asterisk:
                L += 1;
                break;
              case n.NodeType.token:
                if (L += x.token.value.length, this.isForbiddenToken(x.token))
                  return 1 / 0;
                break;
            }
            if (L > this.expressionWidth)
              return L;
          }
        } catch (V) {
          D.e(V);
        } finally {
          D.f();
        }
        return L;
      }
    }, {
      key: "betweenWidth",
      value: function(g) {
        return (0, r.sum)([g.betweenToken, g.expr1, g.andToken, g.expr2].map(function(L) {
          return L.value.length;
        }));
      }
      // Reserved words that cause newlines, comments and semicolons
      // are not allowed inside inline parentheses block
    }, {
      key: "isForbiddenToken",
      value: function(g) {
        return g.type === i.TokenType.RESERVED_LOGICAL_OPERATOR || g.type === i.TokenType.LINE_COMMENT || g.type === i.TokenType.BLOCK_COMMENT || i.isToken.CASE(g);
      }
    }]), O;
  }();
  t.default = p, e.exports = t.default;
})(Ml, Ml.exports);
var p_ = Ml.exports;
var yc = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: true
  }), e.default = e.WS = void 0;
  var t = Xe;
  function r(c, f) {
    if (!(c instanceof f))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(c, f) {
    for (var p = 0; p < f.length; p++) {
      var O = f[p];
      O.enumerable = O.enumerable || false, O.configurable = true, "value" in O && (O.writable = true), Object.defineProperty(c, O.key, O);
    }
  }
  function n(c, f, p) {
    return f && i(c.prototype, f), p && i(c, p), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function a(c, f, p) {
    return f in c ? Object.defineProperty(c, f, { value: p, enumerable: true, configurable: true, writable: true }) : c[f] = p, c;
  }
  var s;
  e.WS = s, function(c) {
    c[c.SPACE = 0] = "SPACE", c[c.NO_SPACE = 1] = "NO_SPACE", c[c.NEWLINE = 2] = "NEWLINE", c[c.INDENT = 3] = "INDENT", c[c.SINGLE_INDENT = 4] = "SINGLE_INDENT";
  }(s || (e.WS = s = {}));
  var o = function() {
    function c(f) {
      r(this, c), this.indentation = f, a(this, "items", []);
    }
    return n(c, [{
      key: "add",
      value: function() {
        for (var p = arguments.length, O = new Array(p), d2 = 0; d2 < p; d2++)
          O[d2] = arguments[d2];
        for (var g = 0, L = O; g < L.length; g++) {
          var D = L[g];
          switch (D) {
            case s.SPACE:
              this.items.push(s.SPACE);
              break;
            case s.NO_SPACE:
              this.trimHorizontalWhitespace();
              break;
            case s.NEWLINE:
              this.trimHorizontalWhitespace(), this.addNewline();
              break;
            case s.INDENT:
              this.addIndentation();
              break;
            case s.SINGLE_INDENT:
              this.items.push(s.SINGLE_INDENT);
              break;
            default:
              this.items.push(D);
          }
        }
      }
    }, {
      key: "trimHorizontalWhitespace",
      value: function() {
        for (; l((0, t.last)(this.items)); )
          this.items.pop();
      }
    }, {
      key: "addNewline",
      value: function() {
        this.items.length > 0 && (0, t.last)(this.items) !== s.NEWLINE && this.items.push(s.NEWLINE);
      }
    }, {
      key: "addIndentation",
      value: function() {
        for (var p = 0; p < this.indentation.getLevel(); p++)
          this.items.push(s.SINGLE_INDENT);
      }
      /**
       * Returns the final SQL string.
       */
    }, {
      key: "toString",
      value: function() {
        var p = this;
        return this.items.map(function(O) {
          return p.itemToString(O);
        }).join("");
      }
    }, {
      key: "itemToString",
      value: function(p) {
        switch (p) {
          case s.SPACE:
            return " ";
          case s.NEWLINE:
            return `
`;
          case s.SINGLE_INDENT:
            return this.indentation.getSingleIndent();
          default:
            return p;
        }
      }
    }]), c;
  }();
  e.default = o;
  var l = function(f) {
    return f === s.SPACE || f === s.SINGLE_INDENT;
  };
})(yc);
var _d = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: true
  }), e.default = p, e.isTabularToken = O;
  var t = it;
  function r(d2) {
    return n(d2) || c(d2) || o(d2) || i();
  }
  function i() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function n(d2) {
    if (Array.isArray(d2))
      return l(d2);
  }
  function a(d2) {
    return f(d2) || c(d2) || o(d2) || s();
  }
  function s() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function o(d2, g) {
    if (d2) {
      if (typeof d2 == "string")
        return l(d2, g);
      var L = Object.prototype.toString.call(d2).slice(8, -1);
      if (L === "Object" && d2.constructor && (L = d2.constructor.name), L === "Map" || L === "Set")
        return Array.from(d2);
      if (L === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(L))
        return l(d2, g);
    }
  }
  function l(d2, g) {
    (g == null || g > d2.length) && (g = d2.length);
    for (var L = 0, D = new Array(g); L < g; L++)
      D[L] = d2[L];
    return D;
  }
  function c(d2) {
    if (typeof Symbol < "u" && d2[Symbol.iterator] != null || d2["@@iterator"] != null)
      return Array.from(d2);
  }
  function f(d2) {
    if (Array.isArray(d2))
      return d2;
  }
  function p(d2, g) {
    if (g === "standard")
      return d2;
    var L = [];
    if (d2.length >= 10 && d2.includes(" ")) {
      var D = d2.split(" "), W = a(D);
      d2 = W[0], L = W.slice(1);
    }
    return g === "tabularLeft" ? d2 = d2.padEnd(9, " ") : d2 = d2.padStart(9, " "), d2 + [""].concat(r(L)).join(" ");
  }
  function O(d2) {
    return d2.type === t.TokenType.RESERVED_LOGICAL_OPERATOR || d2.type === t.TokenType.RESERVED_DEPENDENT_CLAUSE || d2.type === t.TokenType.RESERVED_COMMAND || d2.type === t.TokenType.RESERVED_BINARY_COMMAND || d2.type === t.TokenType.RESERVED_JOIN;
  }
})(_d);
(function(e, t) {
  function r(x) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
      return typeof V;
    } : function(V) {
      return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V;
    }, r(x);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = Xe, n = Na, a = it, s = ii, o = O(p_), l = yc, c = p(_d);
  function f(x) {
    if (typeof WeakMap != "function")
      return null;
    var V = /* @__PURE__ */ new WeakMap(), _2 = /* @__PURE__ */ new WeakMap();
    return (f = function(z) {
      return z ? _2 : V;
    })(x);
  }
  function p(x, V) {
    if (!V && x && x.__esModule)
      return x;
    if (x === null || r(x) !== "object" && typeof x != "function")
      return { default: x };
    var _2 = f(V);
    if (_2 && _2.has(x))
      return _2.get(x);
    var $ = {}, z = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var F in x)
      if (F !== "default" && Object.prototype.hasOwnProperty.call(x, F)) {
        var ae = z ? Object.getOwnPropertyDescriptor(x, F) : null;
        ae && (ae.get || ae.set) ? Object.defineProperty($, F, ae) : $[F] = x[F];
      }
    return $.default = x, _2 && _2.set(x, $), $;
  }
  function O(x) {
    return x && x.__esModule ? x : { default: x };
  }
  function d2(x, V) {
    if (!(x instanceof V))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(x, V) {
    for (var _2 = 0; _2 < V.length; _2++) {
      var $ = V[_2];
      $.enumerable = $.enumerable || false, $.configurable = true, "value" in $ && ($.writable = true), Object.defineProperty(x, $.key, $);
    }
  }
  function L(x, V, _2) {
    return V && g(x.prototype, V), _2 && g(x, _2), Object.defineProperty(x, "prototype", { writable: false }), x;
  }
  function D(x, V, _2) {
    return V in x ? Object.defineProperty(x, V, { value: _2, enumerable: true, configurable: true, writable: true }) : x[V] = _2, x;
  }
  var W = function() {
    function x(V) {
      var _2 = V.cfg, $ = V.params, z = V.layout, F = V.inline, ae = F === void 0 ? false : F;
      d2(this, x), D(this, "cfg", void 0), D(this, "inlineBlock", void 0), D(this, "params", void 0), D(this, "layout", void 0), D(this, "inline", false), D(this, "nodes", []), D(this, "index", -1), this.cfg = _2, this.inline = ae, this.inlineBlock = new o.default(this.cfg.expressionWidth), this.params = $, this.layout = z;
    }
    return L(x, [{
      key: "format",
      value: function(_2) {
        for (this.nodes = _2, this.index = 0; this.index < this.nodes.length; this.index++) {
          var $ = this.nodes[this.index];
          switch ($.type) {
            case s.NodeType.function_call:
              this.formatFunctionCall($);
              break;
            case s.NodeType.array_subscript:
              this.formatArraySubscript($);
              break;
            case s.NodeType.parenthesis:
              this.formatParenthesis($);
              break;
            case s.NodeType.between_predicate:
              this.formatBetweenPredicate($);
              break;
            case s.NodeType.clause:
              this.formatClause($);
              break;
            case s.NodeType.binary_clause:
              this.formatBinaryClause($);
              break;
            case s.NodeType.limit_clause:
              this.formatLimitClause($);
              break;
            case s.NodeType.all_columns_asterisk:
              this.formatAllColumnsAsterisk($);
              break;
            case s.NodeType.token:
              this.formatToken($.token);
              break;
          }
        }
        return this.layout;
      }
    }, {
      key: "formatFunctionCall",
      value: function(_2) {
        this.layout.add(this.show(_2.nameToken)), this.formatParenthesis(_2.parenthesis);
      }
    }, {
      key: "formatArraySubscript",
      value: function(_2) {
        this.layout.add(this.show(_2.arrayToken)), this.formatParenthesis(_2.parenthesis);
      }
    }, {
      key: "formatParenthesis",
      value: function(_2) {
        var $ = this.inlineBlock.isInlineBlock(_2);
        $ ? (this.layout.add(_2.openParen), this.layout = this.formatSubExpression(_2.children, $), this.layout.add(l.WS.NO_SPACE, _2.closeParen, l.WS.SPACE)) : (this.layout.add(_2.openParen, l.WS.NEWLINE), (0, n.isTabularStyle)(this.cfg) ? (this.layout.add(l.WS.INDENT), this.layout = this.formatSubExpression(_2.children, $)) : (this.layout.indentation.increaseBlockLevel(), this.layout.add(l.WS.INDENT), this.layout = this.formatSubExpression(_2.children, $), this.layout.indentation.decreaseBlockLevel()), this.layout.add(l.WS.NEWLINE, l.WS.INDENT, _2.closeParen, l.WS.SPACE));
      }
    }, {
      key: "formatBetweenPredicate",
      value: function(_2) {
        this.layout.add(this.show(_2.betweenToken), l.WS.SPACE, this.show(_2.expr1), l.WS.SPACE, this.show(_2.andToken), l.WS.SPACE, this.show(_2.expr2), l.WS.SPACE);
      }
    }, {
      key: "formatClause",
      value: function(_2) {
        (0, n.isTabularStyle)(this.cfg) ? this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2.nameToken), l.WS.SPACE) : this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2.nameToken), l.WS.NEWLINE), this.layout.indentation.increaseTopLevel(), (0, n.isTabularStyle)(this.cfg) || this.layout.add(l.WS.INDENT), this.layout = this.formatSubExpression(_2.children), this.layout.indentation.decreaseTopLevel();
      }
    }, {
      key: "formatBinaryClause",
      value: function(_2) {
        this.layout.indentation.decreaseTopLevel(), this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2.nameToken), l.WS.NEWLINE), this.layout.add(l.WS.INDENT), this.layout = this.formatSubExpression(_2.children);
      }
    }, {
      key: "formatLimitClause",
      value: function(_2) {
        this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2.limitToken)), this.layout.indentation.increaseTopLevel(), _2.offset ? (this.layout.add(l.WS.NEWLINE, l.WS.INDENT), this.layout = this.formatSubExpression(_2.offset), this.layout.add(l.WS.NO_SPACE, ",", l.WS.SPACE), this.layout = this.formatSubExpression(_2.count)) : (this.layout.add(l.WS.NEWLINE, l.WS.INDENT), this.layout = this.formatSubExpression(_2.count)), this.layout.indentation.decreaseTopLevel();
      }
    }, {
      key: "formatAllColumnsAsterisk",
      value: function(_2) {
        this.layout.add("*", l.WS.SPACE);
      }
    }, {
      key: "formatSubExpression",
      value: function(_2) {
        var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.inline;
        return new x({
          cfg: this.cfg,
          params: this.params,
          layout: this.layout,
          inline: $
        }).format(_2);
      }
    }, {
      key: "formatToken",
      value: function(_2) {
        switch (_2.type) {
          case a.TokenType.LINE_COMMENT:
            return this.formatLineComment(_2);
          case a.TokenType.BLOCK_COMMENT:
            return this.formatBlockComment(_2);
          case a.TokenType.RESERVED_JOIN:
            return this.formatJoin(_2);
          case a.TokenType.RESERVED_DEPENDENT_CLAUSE:
            return this.formatDependentClause(_2);
          case a.TokenType.RESERVED_JOIN_CONDITION:
            return this.formatJoinCondition(_2);
          case a.TokenType.RESERVED_LOGICAL_OPERATOR:
            return this.formatLogicalOperator(_2);
          case a.TokenType.RESERVED_KEYWORD:
            return this.formatKeyword(_2);
          case a.TokenType.RESERVED_CASE_START:
            return this.formatCaseStart(_2);
          case a.TokenType.RESERVED_CASE_END:
            return this.formatCaseEnd(_2);
          case a.TokenType.NAMED_PARAMETER:
          case a.TokenType.QUOTED_PARAMETER:
          case a.TokenType.INDEXED_PARAMETER:
          case a.TokenType.POSITIONAL_PARAMETER:
            return this.formatParameter(_2);
          case a.TokenType.COMMA:
            return this.formatComma(_2);
          case a.TokenType.OPERATOR:
            return this.formatOperator(_2);
          case a.TokenType.IDENTIFIER:
          case a.TokenType.QUOTED_IDENTIFIER:
          case a.TokenType.STRING:
          case a.TokenType.NUMBER:
          case a.TokenType.VARIABLE:
            return this.formatWord(_2);
          default:
            throw new Error("Unexpected token type: ".concat(_2.type));
        }
      }
      /**
       * Formats ident/string/number/variable tokens
       */
    }, {
      key: "formatWord",
      value: function(_2) {
        this.layout.add(this.show(_2), l.WS.SPACE);
      }
      /** Formats a line comment onto query */
    }, {
      key: "formatLineComment",
      value: function(_2) {
        this.layout.add(this.show(_2), l.WS.NEWLINE, l.WS.INDENT);
      }
      /** Formats a block comment onto query */
    }, {
      key: "formatBlockComment",
      value: function(_2) {
        var $ = this;
        this.splitBlockComment(_2.value).forEach(function(z) {
          $.layout.add(l.WS.NEWLINE, l.WS.INDENT, z);
        }), this.layout.add(l.WS.NEWLINE, l.WS.INDENT);
      }
      // Breaks up block comment to multiple lines.
      // For example this comment (dots representing leading whitespace):
      //
      //   ..../**
      //   .....* Some description here
      //   .....* and here too
      //   .....*/
      //
      // gets broken to this array (note the leading single spaces):
      //
      //   [ '/**',
      //     '.* Some description here',
      //     '.* and here too',
      //     '.*/' ]
      //
    }, {
      key: "splitBlockComment",
      value: function(_2) {
        return _2.split(/\n/).map(function($) {
          return /^\s*\*/.test($) ? " " + $.replace(/^\s*/, "") : $.replace(/^\s*/, "");
        });
      }
    }, {
      key: "formatJoin",
      value: function(_2) {
        (0, n.isTabularStyle)(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2), l.WS.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2), l.WS.SPACE);
      }
      /**
       * Formats a Reserved Keyword onto query
       */
    }, {
      key: "formatKeyword",
      value: function(_2) {
        this.layout.add(this.show(_2), l.WS.SPACE);
      }
      /**
       * Formats a Reserved Dependent Clause token onto query, supporting the keyword that precedes it
       */
    }, {
      key: "formatDependentClause",
      value: function(_2) {
        this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2), l.WS.SPACE);
      }
      // Formats ON and USING keywords
    }, {
      key: "formatJoinCondition",
      value: function(_2) {
        this.layout.add(this.show(_2), l.WS.SPACE);
      }
      /**
       * Formats an Operator onto query, following rules for specific characters
       */
    }, {
      key: "formatOperator",
      value: function(_2) {
        if (_2.value === ":") {
          this.layout.add(l.WS.NO_SPACE, this.show(_2), l.WS.SPACE);
          return;
        } else if (_2.value === "." || _2.value === "::") {
          this.layout.add(l.WS.NO_SPACE, this.show(_2));
          return;
        }
        this.cfg.denseOperators ? this.layout.add(l.WS.NO_SPACE, this.show(_2)) : this.layout.add(this.show(_2), l.WS.SPACE);
      }
      /**
       * Formats a Logical Operator onto query, joining boolean conditions
       */
    }, {
      key: "formatLogicalOperator",
      value: function(_2) {
        this.cfg.logicalOperatorNewline === "before" ? (0, n.isTabularStyle)(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2), l.WS.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2), l.WS.SPACE) : this.layout.add(this.show(_2), l.WS.NEWLINE, l.WS.INDENT);
      }
    }, {
      key: "formatCaseStart",
      value: function(_2) {
        this.layout.indentation.increaseBlockLevel(), this.layout.add(this.show(_2), l.WS.NEWLINE, l.WS.INDENT);
      }
    }, {
      key: "formatCaseEnd",
      value: function(_2) {
        this.formatMultilineBlockEnd(_2);
      }
    }, {
      key: "formatMultilineBlockEnd",
      value: function(_2) {
        this.layout.indentation.decreaseBlockLevel(), this.layout.add(l.WS.NEWLINE, l.WS.INDENT, this.show(_2), l.WS.SPACE);
      }
      /**
       * Formats a parameter placeholder item onto query, to be replaced with the value of the placeholder
       */
    }, {
      key: "formatParameter",
      value: function(_2) {
        this.layout.add(this.params.get(_2), l.WS.SPACE);
      }
      /**
       * Formats a comma Operator onto query, ending line unless in an Inline Block
       */
    }, {
      key: "formatComma",
      value: function(_2) {
        this.inline ? this.layout.add(l.WS.NO_SPACE, this.show(_2), l.WS.SPACE) : this.layout.add(l.WS.NO_SPACE, this.show(_2), l.WS.NEWLINE, l.WS.INDENT);
      }
    }, {
      key: "show",
      value: function(_2) {
        return (0, c.isTabularToken)(_2) ? (0, c.default)(this.showToken(_2), this.cfg.indentStyle) : this.showToken(_2);
      }
      // don't call this directly, always use show() instead.
    }, {
      key: "showToken",
      value: function(_2) {
        if ((0, a.isReserved)(_2))
          switch (this.cfg.keywordCase) {
            case "preserve":
              return (0, i.equalizeWhitespace)(_2.text);
            case "upper":
              return _2.value;
            case "lower":
              return _2.value.toLowerCase();
          }
        else
          return _2.value;
      }
    }]), x;
  }();
  t.default = W, e.exports = t.default;
})(wl, wl.exports);
var O_ = wl.exports;
var kl = { exports: {} };
var Ql = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var r = it;
  function i(l, c) {
    if (!(l instanceof c))
      throw new TypeError("Cannot call a class as a function");
  }
  function n(l, c) {
    for (var f = 0; f < c.length; f++) {
      var p = c[f];
      p.enumerable = p.enumerable || false, p.configurable = true, "value" in p && (p.writable = true), Object.defineProperty(l, p.key, p);
    }
  }
  function a(l, c, f) {
    return c && n(l.prototype, c), f && n(l, f), Object.defineProperty(l, "prototype", { writable: false }), l;
  }
  function s(l, c, f) {
    return c in l ? Object.defineProperty(l, c, { value: f, enumerable: true, configurable: true, writable: true }) : l[c] = f, l;
  }
  var o = function() {
    function l(c) {
      var f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      i(this, l), this.keywordCase = c, s(this, "detectedCase", void 0), this.detectedCase = this.autoDetectCase(f);
    }
    return a(l, [{
      key: "autoDetectCase",
      value: function(f) {
        var p = f.filter(r.isToken.AS), O = p.filter(function(d2) {
          var g = d2.text;
          return g === "AS";
        });
        return O.length > p.length / 2 ? "upper" : "lower";
      }
      /** Returns AS token with either upper- or lowercase text */
    }, {
      key: "token",
      value: function() {
        return {
          type: r.TokenType.RESERVED_KEYWORD,
          value: this.asTokenValue(),
          text: this.asTokenValue()
        };
      }
    }, {
      key: "asTokenValue",
      value: function() {
        var f = this.keywordCase === "preserve" ? this.detectedCase : this.keywordCase;
        return f === "upper" ? "AS" : "as";
      }
    }]), l;
  }();
  t.default = o, e.exports = t.default;
})(Ql, Ql.exports);
var E_ = Ql.exports;
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var r = it, i = n(E_);
  function n(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function a(f, p) {
    if (!(f instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function s(f, p) {
    for (var O = 0; O < p.length; O++) {
      var d2 = p[O];
      d2.enumerable = d2.enumerable || false, d2.configurable = true, "value" in d2 && (d2.writable = true), Object.defineProperty(f, d2.key, d2);
    }
  }
  function o(f, p, O) {
    return p && s(f.prototype, p), O && s(f, O), Object.defineProperty(f, "prototype", { writable: false }), f;
  }
  function l(f, p, O) {
    return p in f ? Object.defineProperty(f, p, { value: O, enumerable: true, configurable: true, writable: true }) : f[p] = O, f;
  }
  var c = function() {
    function f(p, O) {
      a(this, f), l(this, "index", 0), l(this, "tokens", []), l(this, "previousReservedToken", r.EOF_TOKEN), l(this, "previousCommandToken", r.EOF_TOKEN), l(this, "asTokenFactory", void 0), l(this, "aliasAs", void 0), this.aliasAs = p.aliasAs, this.asTokenFactory = new i.default(p.keywordCase, O), this.tokens = O;
    }
    return o(f, [{
      key: "process",
      value: function() {
        var O = [];
        for (this.index = 0; this.index < this.tokens.length; this.index++) {
          var d2 = this.tokens[this.index];
          (0, r.isReserved)(d2) && (this.previousReservedToken = d2, d2.type === r.TokenType.RESERVED_COMMAND && (this.previousCommandToken = d2)), r.isToken.AS(d2) ? this.shouldRemove() || O.push(d2) : d2.type === r.TokenType.IDENTIFIER || d2.type === r.TokenType.NUMBER || d2.type === r.TokenType.STRING || d2.type === r.TokenType.VARIABLE ? (this.shouldAddBefore(d2) && O.push(this.asTokenFactory.token()), O.push(d2), this.shouldAddAfter() && O.push(this.asTokenFactory.token())) : O.push(d2);
        }
        return O;
      }
      /** True when AS keyword should be added *before* current token */
    }, {
      key: "shouldAddBefore",
      value: function(O) {
        return this.isMissingTableAlias(O) || this.isMissingSelectColumnAlias(O);
      }
      // if table alias is missing and should be added
    }, {
      key: "isMissingTableAlias",
      value: function(O) {
        return this.aliasAs === "always" && O.type === r.TokenType.IDENTIFIER && this.lookBehind().value === ")";
      }
      // if select column alias is missing and should be added
    }, {
      key: "isMissingSelectColumnAlias",
      value: function(O) {
        var d2 = this.lookBehind(), g = this.lookAhead();
        return (this.aliasAs === "always" || this.aliasAs === "select") && this.isWithinSelect() && O.type === r.TokenType.IDENTIFIER && (r.isToken.END(d2) || (d2.type === r.TokenType.IDENTIFIER || d2.type === r.TokenType.NUMBER) && (g.type === r.TokenType.COMMA || (0, r.isCommand)(g)));
      }
      /** True when AS keyword should be added *after* current token */
    }, {
      key: "shouldAddAfter",
      value: function() {
        return this.isEdgeCaseCTE() || this.isEdgeCaseCreateTable() || this.isMissingTypeCastAs();
      }
      // checks for CAST(expression [AS] type)
    }, {
      key: "isMissingTypeCastAs",
      value: function() {
        return this.aliasAs === "never" && this.isWithinSelect() && r.isToken.CAST(this.getPreviousReservedToken()) && r.isToken.AS(this.lookAhead()) && (this.lookAhead(2).type === r.TokenType.IDENTIFIER || this.lookAhead(2).type === r.TokenType.RESERVED_KEYWORD) && this.lookAhead(3).value === ")";
      }
      // checks for WITH `table` [AS] (
    }, {
      key: "isEdgeCaseCTE",
      value: function() {
        var O = this.lookAhead();
        return this.aliasAs === "never" && r.isToken.WITH(this.lookBehind()) && (O.value === "(" || r.isToken.AS(O) && this.lookAhead(2).value === "(");
      }
      // checks for CREATE TABLE `table` [AS] WITH (
    }, {
      key: "isEdgeCaseCreateTable",
      value: function() {
        var O = this.lookBehind(), d2 = this.lookAhead();
        return this.aliasAs === "never" && (r.isToken.TABLE(O) || O.value.endsWith("TABLE")) && (r.isToken.WITH(d2) || r.isToken.AS(d2) && r.isToken.WITH(this.lookAhead(2)));
      }
      /* True when the current AS token should be discarded */
    }, {
      key: "shouldRemove",
      value: function() {
        return this.aliasAs === "never" || this.aliasAs === "select" && this.isRemovableNonSelectAs();
      }
    }, {
      key: "isRemovableNonSelectAs",
      value: function() {
        return this.lookBehind().value === ")" && // ) [AS] alias but not SELECT (a) [AS] alpha
        !this.isWithinSelect() && this.lookAhead().value !== "(";
      }
    }, {
      key: "getPreviousReservedToken",
      value: function() {
        return this.previousReservedToken;
      }
    }, {
      key: "isWithinSelect",
      value: function() {
        return r.isToken.SELECT(this.previousCommandToken);
      }
    }, {
      key: "lookBehind",
      value: function() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return this.lookAhead(-O);
      }
    }, {
      key: "lookAhead",
      value: function() {
        var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        return this.tokens[this.index + O] || r.EOF_TOKEN;
      }
    }]), f;
  }();
  t.default = c, e.exports = t.default;
})(kl, kl.exports);
var d_ = kl.exports;
var Gl = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var r = Xe;
  function i(f, p) {
    if (!(f instanceof p))
      throw new TypeError("Cannot call a class as a function");
  }
  function n(f, p) {
    for (var O = 0; O < p.length; O++) {
      var d2 = p[O];
      d2.enumerable = d2.enumerable || false, d2.configurable = true, "value" in d2 && (d2.writable = true), Object.defineProperty(f, d2.key, d2);
    }
  }
  function a(f, p, O) {
    return p && n(f.prototype, p), O && n(f, O), Object.defineProperty(f, "prototype", { writable: false }), f;
  }
  function s(f, p, O) {
    return p in f ? Object.defineProperty(f, p, { value: O, enumerable: true, configurable: true, writable: true }) : f[p] = O, f;
  }
  var o = "top-level", l = "block-level", c = function() {
    function f(p) {
      i(this, f), this.indent = p, s(this, "indentTypes", []);
    }
    return a(f, [{
      key: "getSingleIndent",
      value: function() {
        return this.indent;
      }
      /**
       * Returns current indentation string.
       * @return {string} indentation string based on indentTypes
       */
    }, {
      key: "getIndent",
      value: function() {
        return this.indent.repeat(this.indentTypes.length);
      }
      /**
       * Returns current indentation level
       */
    }, {
      key: "getLevel",
      value: function() {
        return this.indentTypes.length;
      }
      /**
       * Increases indentation by one top-level indent.
       */
    }, {
      key: "increaseTopLevel",
      value: function() {
        this.indentTypes.push(o);
      }
      /**
       * Increases indentation by one block-level indent.
       */
    }, {
      key: "increaseBlockLevel",
      value: function() {
        this.indentTypes.push(l);
      }
      /**
       * Decreases indentation by one top-level indent.
       * Does nothing when the previous indent is not top-level.
       */
    }, {
      key: "decreaseTopLevel",
      value: function() {
        this.indentTypes.length > 0 && (0, r.last)(this.indentTypes) === o && this.indentTypes.pop();
      }
      /**
       * Decreases indentation by one block-level indent.
       * If there are top-level indents within the block-level indent,
       * throws away these as well.
       */
    }, {
      key: "decreaseBlockLevel",
      value: function() {
        for (; this.indentTypes.length > 0; ) {
          var O = this.indentTypes.pop();
          if (O !== o)
            break;
        }
      }
      /** Clears all indentation */
    }, {
      key: "resetIndentation",
      value: function() {
        this.indentTypes = [];
      }
    }]), f;
  }();
  t.default = c, e.exports = t.default;
})(Gl, Gl.exports);
var T_ = Gl.exports;
(function(e, t) {
  function r(_2) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function($) {
      return typeof $;
    } : function($) {
      return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $;
    }, r(_2);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = Na, n = g(jP), a = g(KP), s = g(f_), o = g(h_), l = g(O_), c = g(d_), f = d2(yc), p = g(T_);
  function O(_2) {
    if (typeof WeakMap != "function")
      return null;
    var $ = /* @__PURE__ */ new WeakMap(), z = /* @__PURE__ */ new WeakMap();
    return (O = function(ae) {
      return ae ? z : $;
    })(_2);
  }
  function d2(_2, $) {
    if (!$ && _2 && _2.__esModule)
      return _2;
    if (_2 === null || r(_2) !== "object" && typeof _2 != "function")
      return { default: _2 };
    var z = O($);
    if (z && z.has(_2))
      return z.get(_2);
    var F = {}, ae = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var U in _2)
      if (U !== "default" && Object.prototype.hasOwnProperty.call(_2, U)) {
        var G = ae ? Object.getOwnPropertyDescriptor(_2, U) : null;
        G && (G.get || G.set) ? Object.defineProperty(F, U, G) : F[U] = _2[U];
      }
    return F.default = _2, z && z.set(_2, F), F;
  }
  function g(_2) {
    return _2 && _2.__esModule ? _2 : { default: _2 };
  }
  function L(_2, $) {
    if (!(_2 instanceof $))
      throw new TypeError("Cannot call a class as a function");
  }
  function D(_2, $) {
    for (var z = 0; z < $.length; z++) {
      var F = $[z];
      F.enumerable = F.enumerable || false, F.configurable = true, "value" in F && (F.writable = true), Object.defineProperty(_2, F.key, F);
    }
  }
  function W(_2, $, z) {
    return $ && D(_2.prototype, $), z && D(_2, z), Object.defineProperty(_2, "prototype", { writable: false }), _2;
  }
  function x(_2, $, z) {
    return $ in _2 ? Object.defineProperty(_2, $, { value: z, enumerable: true, configurable: true, writable: true }) : _2[$] = z, _2;
  }
  var V = function() {
    function _2($) {
      L(this, _2), x(this, "cfg", void 0), x(this, "params", void 0), this.cfg = $, this.params = new n.default(this.cfg.params);
    }
    return W(_2, [{
      key: "tokenizer",
      value: function() {
        throw new Error("tokenizer() not implemented by subclass");
      }
      // Cache the tokenizer for each class (each SQL dialect)
      // So we wouldn't need to recreate the tokenizer, which is kinda expensive,
      // for each call to format() function.
    }, {
      key: "cachedTokenizer",
      value: function() {
        var z = this.constructor;
        return z.cachedTokenizer || (z.cachedTokenizer = this.tokenizer()), z.cachedTokenizer;
      }
      /**
       * Formats an SQL query.
       * @param {string} query - The SQL query string to be formatted
       * @return {string} The formatter query
       */
    }, {
      key: "format",
      value: function(z) {
        var F = this.cachedTokenizer().tokenize(z), ae = new c.default(this.cfg, F).process(), U = new a.default(ae).parse(), G = this.formatAst(U), H = this.postFormat(G);
        return H.trimEnd();
      }
    }, {
      key: "formatAst",
      value: function(z) {
        var F = this;
        return z.map(function(ae) {
          return F.formatStatement(ae);
        }).join(`
`.repeat(this.cfg.linesBetweenQueries + 1));
      }
    }, {
      key: "formatStatement",
      value: function(z) {
        var F = new l.default({
          cfg: this.cfg,
          params: this.params,
          layout: new f.default(new p.default((0, i.indentString)(this.cfg)))
        }).format(z.children);
        return z.hasSemicolon && (this.cfg.newlineBeforeSemicolon ? F.add(f.WS.NEWLINE, ";") : F.add(f.WS.NO_SPACE, ";")), F.toString();
      }
    }, {
      key: "postFormat",
      value: function(z) {
        return this.cfg.tabulateAlias && (z = (0, o.default)(z)), (this.cfg.commaPosition === "before" || this.cfg.commaPosition === "tabular") && (z = (0, s.default)(z, this.cfg.commaPosition, (0, i.indentString)(this.cfg))), z;
      }
    }]), _2;
  }();
  t.default = V, e.exports = t.default;
})(bl, bl.exports);
var ur = bl.exports;
var Vl = { exports: {} };
var ft = {};
var Pt = {};
Object.defineProperty(Pt, "__esModule", {
  value: true
});
Pt.withDashes = Pt.toCaseInsensitivePattern = Pt.prefixesPattern = Pt.patternToRegex = Pt.escapeRegExp = Pt.escapeParen = Pt.WHITESPACE_REGEX = Pt.NULL_REGEX = void 0;
var bd = function(t) {
  return t.replace(/[\$\(-\+\.\?\[-\^\{-\}]/g, "\\$&");
};
Pt.escapeRegExp = bd;
var S_ = /^(?!)/;
Pt.NULL_REGEX = S_;
var m_ = new RegExp("([\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+)", "y");
Pt.WHITESPACE_REGEX = m_;
var R_ = function(t) {
  return new RegExp("(?:".concat(t, ")"), "uy");
};
Pt.patternToRegex = R_;
var vd = function(t) {
  return t.split("").map(function(r) {
    return / /g.test(r) ? "\\s+" : "[".concat(r.toUpperCase()).concat(r.toLowerCase(), "]");
  }).join("");
};
Pt.toCaseInsensitivePattern = vd;
var A_ = function(t) {
  return t.length === 1 ? bd(t) : "\\b" + t + "\\b";
};
Pt.escapeParen = A_;
var g_ = function(t) {
  return t + "(?:-" + t + ")*";
};
Pt.withDashes = g_;
var y_ = function(t) {
  var r = t.prefixes, i = t.requirePrefix;
  return "(?:".concat(r.map(vd).join("|")).concat(i ? "" : "|", ")");
};
Pt.prefixesPattern = y_;
Object.defineProperty(ft, "__esModule", {
  value: true
});
ft.variable = ft.stringPattern = ft.string = ft.reservedWord = ft.quotePatterns = ft.parenthesis = ft.parameter = ft.operator = ft.lineComment = ft.identifierPattern = ft.identifier = void 0;
var Cd = Xe;
var Vt = Pt;
var I_ = function(t) {
  return new RegExp("(?:".concat(t.map(Vt.escapeRegExp).join("|"), `).*?(?=\r
|\r|
|$)`), "uy");
};
ft.lineComment = I_;
var N_ = function(t) {
  return (0, Vt.patternToRegex)(t.map(Vt.escapeParen).join("|"));
};
ft.parenthesis = N_;
var P_ = function(t, r) {
  return (0, Vt.patternToRegex)("".concat((0, Cd.sortByLengthDesc)(r).map(Vt.escapeRegExp).join("|"), "|") + "[".concat(t.split("").map(Vt.escapeRegExp).join(""), "]"));
};
ft.operator = P_;
var __ = function(t) {
  var r = t.rest, i = t.dashes;
  return r || i ? "(?![".concat(r || "").concat(i ? "-" : "", "])") : "";
};
var b_ = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (t.length === 0)
    return /^\b$/;
  var i = __(r), n = (0, Cd.sortByLengthDesc)(t).map(Vt.toCaseInsensitivePattern).join("|").replace(/ /g, "\\s+");
  return new RegExp("(?:".concat(n, ")").concat(i, "\\b"), "iuy");
};
ft.reservedWord = b_;
var v_ = function(t, r) {
  if (t.length) {
    var i = t.map(Vt.escapeRegExp).join("|");
    return (0, Vt.patternToRegex)("(?:".concat(i, ")(?:").concat(r, ")"));
  }
};
ft.parameter = v_;
var Bl = {
  "``": "(?:`[^`]*(?:$|`))+",
  "[]": "(?:\\[[^\\]]*(?:$|\\]))(?:\\][^\\]]*(?:$|\\]))*",
  '""': '(?:"[^"\\\\]*(?:\\\\.[^"\\\\]*)*(?:"|$))+',
  "''": "(?:'[^'\\\\]*(?:\\\\.[^'\\\\]*)*(?:'|$))+",
  $$: "(?<tag>\\$\\w*\\$)[\\s\\S]*?(?:\\k<tag>|$)",
  "'''..'''": "'''[^\\\\]*?(?:\\\\.[^\\\\]*?)*?(?:'''|$)",
  '""".."""': '"""[^\\\\]*?(?:\\\\.[^\\\\]*?)*?(?:"""|$)',
  "{}": "(?:\\{[^\\}]*(?:$|\\}))"
};
ft.quotePatterns = Bl;
var Ld = function(t) {
  return typeof t == "string" ? Bl[t] : (0, Vt.prefixesPattern)(t) + Bl[t.quote];
};
var C_ = function(t) {
  return (0, Vt.patternToRegex)(t.map(function(r) {
    return "regex" in r ? r.regex : Ld(r);
  }).join("|"));
};
ft.variable = C_;
var xd = function(t) {
  return t.map(Ld).join("|");
};
ft.stringPattern = xd;
var L_ = function(t) {
  return (0, Vt.patternToRegex)(xd(t));
};
ft.string = L_;
var x_ = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return (0, Vt.patternToRegex)(Dd(t));
};
ft.identifier = x_;
var Dd = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = t.first, i = t.rest, n = t.dashes, a = "\\p{Alphabetic}\\p{Mark}_", s = "\\p{Decimal_Number}", o = (0, Vt.escapeRegExp)(r ?? ""), l = (0, Vt.escapeRegExp)(i ?? ""), c = "[".concat(a).concat(o, "][").concat(a).concat(s).concat(l, "]*");
  return n ? (0, Vt.withDashes)(c) : c;
};
ft.identifierPattern = Dd;
var $l = { exports: {} };
(function(e, t) {
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var r = it, i = Pt;
  function n(p, O) {
    var d2 = Object.keys(p);
    if (Object.getOwnPropertySymbols) {
      var g = Object.getOwnPropertySymbols(p);
      O && (g = g.filter(function(L) {
        return Object.getOwnPropertyDescriptor(p, L).enumerable;
      })), d2.push.apply(d2, g);
    }
    return d2;
  }
  function a(p) {
    for (var O = 1; O < arguments.length; O++) {
      var d2 = arguments[O] != null ? arguments[O] : {};
      O % 2 ? n(Object(d2), true).forEach(function(g) {
        c(p, g, d2[g]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(p, Object.getOwnPropertyDescriptors(d2)) : n(Object(d2)).forEach(function(g) {
        Object.defineProperty(p, g, Object.getOwnPropertyDescriptor(d2, g));
      });
    }
    return p;
  }
  function s(p, O) {
    if (!(p instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(p, O) {
    for (var d2 = 0; d2 < O.length; d2++) {
      var g = O[d2];
      g.enumerable = g.enumerable || false, g.configurable = true, "value" in g && (g.writable = true), Object.defineProperty(p, g.key, g);
    }
  }
  function l(p, O, d2) {
    return O && o(p.prototype, O), d2 && o(p, d2), Object.defineProperty(p, "prototype", { writable: false }), p;
  }
  function c(p, O, d2) {
    return O in p ? Object.defineProperty(p, O, { value: d2, enumerable: true, configurable: true, writable: true }) : p[O] = d2, p;
  }
  var f = function() {
    function p(O) {
      s(this, p), c(this, "rules", void 0), c(this, "input", ""), c(this, "index", 0), this.rules = O;
    }
    return l(p, [{
      key: "tokenize",
      value: function(d2) {
        this.input = d2, this.index = 0;
        for (var g = [], L; this.index < this.input.length; ) {
          var D = this.getWhitespace();
          if (this.index < this.input.length) {
            if (L = this.getNextToken(L), !L)
              throw new Error('Parse error: Unexpected "'.concat(d2.slice(this.index, 100), '"'));
            g.push(a(a({}, L), {}, {
              whitespaceBefore: D
            }));
          }
        }
        return g;
      }
    }, {
      key: "getWhitespace",
      value: function() {
        i.WHITESPACE_REGEX.lastIndex = this.index;
        var d2 = i.WHITESPACE_REGEX.exec(this.input);
        return d2 ? (this.index += d2[0].length, d2[0]) : "";
      }
    }, {
      key: "getNextToken",
      value: function(d2) {
        return this.matchToken(r.TokenType.BLOCK_COMMENT) || this.matchToken(r.TokenType.LINE_COMMENT) || this.matchToken(r.TokenType.COMMA) || this.matchToken(r.TokenType.OPEN_PAREN) || this.matchToken(r.TokenType.CLOSE_PAREN) || this.matchToken(r.TokenType.QUOTED_IDENTIFIER) || this.matchToken(r.TokenType.NUMBER) || this.matchReservedWordToken(d2) || this.matchPlaceholderToken(r.TokenType.NAMED_PARAMETER) || this.matchPlaceholderToken(r.TokenType.QUOTED_PARAMETER) || this.matchPlaceholderToken(r.TokenType.INDEXED_PARAMETER) || this.matchPlaceholderToken(r.TokenType.POSITIONAL_PARAMETER) || this.matchToken(r.TokenType.VARIABLE) || this.matchToken(r.TokenType.STRING) || this.matchToken(r.TokenType.IDENTIFIER) || this.matchToken(r.TokenType.DELIMITER) || this.matchToken(r.TokenType.OPERATOR);
      }
    }, {
      key: "matchPlaceholderToken",
      value: function(d2) {
        if (d2 in this.rules) {
          var g = this.matchToken(d2), L = this.rules[d2];
          if (g)
            return L != null && L.key ? a(a({}, g), {}, {
              key: L.key(g.value)
            }) : g;
        }
      }
    }, {
      key: "matchReservedWordToken",
      value: function(d2) {
        if ((d2 == null ? void 0 : d2.value) !== ".")
          return this.matchToken(r.TokenType.RESERVED_CASE_START) || this.matchToken(r.TokenType.RESERVED_CASE_END) || this.matchToken(r.TokenType.RESERVED_COMMAND) || this.matchToken(r.TokenType.RESERVED_BINARY_COMMAND) || this.matchToken(r.TokenType.RESERVED_DEPENDENT_CLAUSE) || this.matchToken(r.TokenType.RESERVED_JOIN) || this.matchToken(r.TokenType.RESERVED_KEYWORD) || this.matchToken(r.TokenType.RESERVED_LOGICAL_OPERATOR) || this.matchToken(r.TokenType.RESERVED_JOIN_CONDITION);
      }
      // Shorthand for `match` that looks up regex from rules
    }, {
      key: "matchToken",
      value: function(d2) {
        var g = this.rules[d2];
        if (!g)
          throw Error("Unknown token type found: ".concat(d2));
        return this.match({
          type: d2,
          regex: g.regex,
          transform: g.value
        });
      }
      // Attempts to match RegExp at current position in input
    }, {
      key: "match",
      value: function(d2) {
        var g = d2.type, L = d2.regex, D = d2.transform;
        L.lastIndex = this.index;
        var W = L.exec(this.input);
        if (W) {
          var x = W[0];
          return this.index += x.length, {
            type: g,
            text: x,
            value: D ? D(x) : x
          };
        }
      }
    }]), p;
  }();
  t.default = f, e.exports = t.default;
})($l, $l.exports);
var D_ = $l.exports;
(function(e, t) {
  function r(U) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(G) {
      return typeof G;
    } : function(G) {
      return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G;
    }, r(U);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = it, n = c(ft), a = Pt, s = o(D_);
  function o(U) {
    return U && U.__esModule ? U : { default: U };
  }
  function l(U) {
    if (typeof WeakMap != "function")
      return null;
    var G = /* @__PURE__ */ new WeakMap(), H = /* @__PURE__ */ new WeakMap();
    return (l = function(B) {
      return B ? H : G;
    })(U);
  }
  function c(U, G) {
    if (!G && U && U.__esModule)
      return U;
    if (U === null || r(U) !== "object" && typeof U != "function")
      return { default: U };
    var H = l(G);
    if (H && H.has(U))
      return H.get(U);
    var re = {}, B = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var Y in U)
      if (Y !== "default" && Object.prototype.hasOwnProperty.call(U, Y)) {
        var E = B ? Object.getOwnPropertyDescriptor(U, Y) : null;
        E && (E.get || E.set) ? Object.defineProperty(re, Y, E) : re[Y] = U[Y];
      }
    return re.default = U, H && H.set(U, re), re;
  }
  function f(U, G) {
    return d2(U) || O(U, G) || D(U, G) || p();
  }
  function p() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function O(U, G) {
    var H = U == null ? null : typeof Symbol < "u" && U[Symbol.iterator] || U["@@iterator"];
    if (H != null) {
      var re = [], B = true, Y = false, E, m;
      try {
        for (H = H.call(U); !(B = (E = H.next()).done) && (re.push(E.value), !(G && re.length === G)); B = true)
          ;
      } catch (P) {
        Y = true, m = P;
      } finally {
        try {
          !B && H.return != null && H.return();
        } finally {
          if (Y)
            throw m;
        }
      }
      return re;
    }
  }
  function d2(U) {
    if (Array.isArray(U))
      return U;
  }
  function g(U) {
    return x(U) || W(U) || D(U) || L();
  }
  function L() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function D(U, G) {
    if (U) {
      if (typeof U == "string")
        return V(U, G);
      var H = Object.prototype.toString.call(U).slice(8, -1);
      if (H === "Object" && U.constructor && (H = U.constructor.name), H === "Map" || H === "Set")
        return Array.from(U);
      if (H === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(H))
        return V(U, G);
    }
  }
  function W(U) {
    if (typeof Symbol < "u" && U[Symbol.iterator] != null || U["@@iterator"] != null)
      return Array.from(U);
  }
  function x(U) {
    if (Array.isArray(U))
      return V(U);
  }
  function V(U, G) {
    (G == null || G > U.length) && (G = U.length);
    for (var H = 0, re = new Array(G); H < G; H++)
      re[H] = U[H];
    return re;
  }
  function _2(U, G) {
    if (!(U instanceof G))
      throw new TypeError("Cannot call a class as a function");
  }
  function $(U, G) {
    for (var H = 0; H < G.length; H++) {
      var re = G[H];
      re.enumerable = re.enumerable || false, re.configurable = true, "value" in re && (re.writable = true), Object.defineProperty(U, re.key, re);
    }
  }
  function z(U, G, H) {
    return G && $(U.prototype, G), H && $(U, H), Object.defineProperty(U, "prototype", { writable: false }), U;
  }
  function F(U, G, H) {
    return G in U ? Object.defineProperty(U, G, { value: H, enumerable: true, configurable: true, writable: true }) : U[G] = H, U;
  }
  var ae = function() {
    function U(G) {
      var H, re, B, Y, E, m, P, R, A, y2;
      _2(this, U), F(this, "engine", void 0), F(this, "postProcess", void 0);
      var C = this.validRules((y2 = {}, F(y2, i.TokenType.BLOCK_COMMENT, {
        regex: new RegExp("(\\/\\*(?:(?![])[\\s\\S])*?(?:\\*\\/|$))", "y")
      }), F(y2, i.TokenType.LINE_COMMENT, {
        regex: n.lineComment((H = G.lineCommentTypes) !== null && H !== void 0 ? H : ["--"])
      }), F(y2, i.TokenType.COMMA, {
        regex: new RegExp("[,]", "y")
      }), F(y2, i.TokenType.OPEN_PAREN, {
        regex: n.parenthesis((re = G.openParens) !== null && re !== void 0 ? re : ["("])
      }), F(y2, i.TokenType.CLOSE_PAREN, {
        regex: n.parenthesis((B = G.closeParens) !== null && B !== void 0 ? B : [")"])
      }), F(y2, i.TokenType.QUOTED_IDENTIFIER, {
        regex: n.string(G.identTypes)
      }), F(y2, i.TokenType.NUMBER, {
        regex: new RegExp("(?:0x[0-9A-Fa-f]+|0b[01]+|(?:\\x2D[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*)?[0-9]+(?:\\.[0-9]*)?(?:[Ee][\\+\\x2D]?[0-9]+(?:\\.[0-9]+)?)?)", "y")
      }), F(y2, i.TokenType.RESERVED_CASE_START, {
        regex: new RegExp("[Cc][Aa][Ss][Ee]\\b", "y"),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_CASE_END, {
        regex: new RegExp("[Ee][Nn][Dd]\\b", "y"),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_COMMAND, {
        regex: n.reservedWord(G.reservedCommands, G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_BINARY_COMMAND, {
        regex: n.reservedWord(G.reservedBinaryCommands, G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_DEPENDENT_CLAUSE, {
        regex: n.reservedWord(G.reservedDependentClauses, G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_JOIN, {
        regex: n.reservedWord(G.reservedJoins, G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_KEYWORD, {
        regex: n.reservedWord(G.reservedKeywords, G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_LOGICAL_OPERATOR, {
        regex: n.reservedWord((Y = G.reservedLogicalOperators) !== null && Y !== void 0 ? Y : ["AND", "OR"], G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.RESERVED_JOIN_CONDITION, {
        regex: n.reservedWord((E = G.reservedJoinConditions) !== null && E !== void 0 ? E : ["ON", "USING"], G.identChars),
        value: function(w) {
          return w.toUpperCase();
        }
      }), F(y2, i.TokenType.NAMED_PARAMETER, {
        regex: n.parameter((m = G.namedParamTypes) !== null && m !== void 0 ? m : [], n.identifierPattern(G.paramChars || G.identChars)),
        key: function(w) {
          return w.slice(1);
        }
      }), F(y2, i.TokenType.QUOTED_PARAMETER, {
        regex: n.parameter((P = G.quotedParamTypes) !== null && P !== void 0 ? P : [], n.stringPattern(G.identTypes)),
        key: function(w) {
          return function(J) {
            var te = J.tokenKey, se = J.quoteChar;
            return te.replace(new RegExp((0, a.escapeRegExp)("\\" + se), "gu"), se);
          }({
            tokenKey: w.slice(2, -1),
            quoteChar: w.slice(-1)
          });
        }
      }), F(y2, i.TokenType.INDEXED_PARAMETER, {
        regex: n.parameter((R = G.numberedParamTypes) !== null && R !== void 0 ? R : [], "[0-9]+"),
        key: function(w) {
          return w.slice(1);
        }
      }), F(y2, i.TokenType.POSITIONAL_PARAMETER, {
        regex: G.positionalParams ? new RegExp("[?]", "y") : void 0
      }), F(y2, i.TokenType.VARIABLE, {
        regex: G.variableTypes ? n.variable(G.variableTypes) : a.NULL_REGEX
      }), F(y2, i.TokenType.STRING, {
        regex: n.string(G.stringTypes)
      }), F(y2, i.TokenType.IDENTIFIER, {
        regex: n.identifier(G.identChars)
      }), F(y2, i.TokenType.DELIMITER, {
        regex: new RegExp(";", "y")
      }), F(y2, i.TokenType.OPERATOR, {
        regex: n.operator("+-/*%&|^><=.:$@#?~![]{}", ["<>", "<=", ">=", "!="].concat(g((A = G.operators) !== null && A !== void 0 ? A : [])))
      }), y2));
      this.engine = new s.default(C), this.postProcess = G.postProcess;
    }
    return z(U, [{
      key: "validRules",
      value: function(H) {
        return Object.fromEntries(Object.entries(H).filter(function(re) {
          var B = f(re, 2);
          B[0];
          var Y = B[1];
          return Y.regex;
        }));
      }
    }, {
      key: "tokenize",
      value: function(H) {
        var re = this.engine.tokenize(H);
        return this.postProcess ? this.postProcess(re) : re;
      }
    }]), U;
  }();
  t.default = ae, e.exports = t.default;
})(Vl, Vl.exports);
var cr = Vl.exports;
(function(e, t) {
  function r(w) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(J) {
      return typeof J;
    } : function(J) {
      return J && typeof Symbol == "function" && J.constructor === Symbol && J !== Symbol.prototype ? "symbol" : typeof J;
    }, r(w);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = o(ur), n = o(cr), a = it, s = Xe;
  function o(w) {
    return w && w.__esModule ? w : { default: w };
  }
  function l(w, J) {
    var te = Object.keys(w);
    if (Object.getOwnPropertySymbols) {
      var se = Object.getOwnPropertySymbols(w);
      J && (se = se.filter(function(ge) {
        return Object.getOwnPropertyDescriptor(w, ge).enumerable;
      })), te.push.apply(te, se);
    }
    return te;
  }
  function c(w) {
    for (var J = 1; J < arguments.length; J++) {
      var te = arguments[J] != null ? arguments[J] : {};
      J % 2 ? l(Object(te), true).forEach(function(se) {
        G(w, se, te[se]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(w, Object.getOwnPropertyDescriptors(te)) : l(Object(te)).forEach(function(se) {
        Object.defineProperty(w, se, Object.getOwnPropertyDescriptor(te, se));
      });
    }
    return w;
  }
  function f(w) {
    return g(w) || d2(w) || O(w) || p();
  }
  function p() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function O(w, J) {
    if (w) {
      if (typeof w == "string")
        return L(w, J);
      var te = Object.prototype.toString.call(w).slice(8, -1);
      if (te === "Object" && w.constructor && (te = w.constructor.name), te === "Map" || te === "Set")
        return Array.from(w);
      if (te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te))
        return L(w, J);
    }
  }
  function d2(w) {
    if (typeof Symbol < "u" && w[Symbol.iterator] != null || w["@@iterator"] != null)
      return Array.from(w);
  }
  function g(w) {
    if (Array.isArray(w))
      return L(w);
  }
  function L(w, J) {
    (J == null || J > w.length) && (J = w.length);
    for (var te = 0, se = new Array(J); te < J; te++)
      se[te] = w[te];
    return se;
  }
  function D(w, J) {
    if (!(w instanceof J))
      throw new TypeError("Cannot call a class as a function");
  }
  function W(w, J) {
    for (var te = 0; te < J.length; te++) {
      var se = J[te];
      se.enumerable = se.enumerable || false, se.configurable = true, "value" in se && (se.writable = true), Object.defineProperty(w, se.key, se);
    }
  }
  function x(w, J, te) {
    return J && W(w.prototype, J), te && W(w, te), Object.defineProperty(w, "prototype", { writable: false }), w;
  }
  function V(w, J) {
    if (typeof J != "function" && J !== null)
      throw new TypeError("Super expression must either be null or a function");
    w.prototype = Object.create(J && J.prototype, { constructor: { value: w, writable: true, configurable: true } }), Object.defineProperty(w, "prototype", { writable: false }), J && _2(w, J);
  }
  function _2(w, J) {
    return _2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(se, ge) {
      return se.__proto__ = ge, se;
    }, _2(w, J);
  }
  function $(w) {
    var J = ae();
    return function() {
      var se = U(w), ge;
      if (J) {
        var fe = U(this).constructor;
        ge = Reflect.construct(se, arguments, fe);
      } else
        ge = se.apply(this, arguments);
      return z(this, ge);
    };
  }
  function z(w, J) {
    if (J && (r(J) === "object" || typeof J == "function"))
      return J;
    if (J !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return F(w);
  }
  function F(w) {
    if (w === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return w;
  }
  function ae() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function U(w) {
    return U = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(te) {
      return te.__proto__ || Object.getPrototypeOf(te);
    }, U(w);
  }
  function G(w, J, te) {
    return J in w ? Object.defineProperty(w, J, { value: te, enumerable: true, configurable: true, writable: true }) : w[J] = te, w;
  }
  var H = {
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions
    aead: ["KEYS.NEW_KEYSET", "KEYS.ADD_KEY_FROM_RAW_BYTES", "AEAD.DECRYPT_BYTES", "AEAD.DECRYPT_STRING", "AEAD.ENCRYPT", "KEYS.KEYSET_CHAIN", "KEYS.KEYSET_FROM_JSON", "KEYS.KEYSET_TO_JSON", "KEYS.ROTATE_KEYSET", "KEYS.KEYSET_LENGTH"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions
    aggregateAnalytic: ["ANY_VALUE", "ARRAY_AGG", "AVG", "CORR", "COUNT", "COUNTIF", "COVAR_POP", "COVAR_SAMP", "MAX", "MIN", "ST_CLUSTERDBSCAN", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "VAR_POP", "VAR_SAMP"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions
    aggregate: ["ANY_VALUE", "ARRAY_AGG", "ARRAY_CONCAT_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "COUNTIF", "LOGICAL_AND", "LOGICAL_OR", "MAX", "MIN", "STRING_AGG", "SUM"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions
    approximateAggregate: ["APPROX_COUNT_DISTINCT", "APPROX_QUANTILES", "APPROX_TOP_COUNT", "APPROX_TOP_SUM"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions
    array: ["ARRAY", "ARRAY_CONCAT", "ARRAY_LENGTH", "ARRAY_TO_STRING", "GENERATE_ARRAY", "GENERATE_DATE_ARRAY", "GENERATE_TIMESTAMP_ARRAY", "ARRAY_REVERSE", "OFFSET", "SAFE_OFFSET", "ORDINAL", "SAFE_ORDINAL"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/bit_functions
    bitwise: ["BIT_COUNT"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions
    conversion: [
      // 'CASE',
      "PARSE_BIGNUMERIC",
      "PARSE_NUMERIC",
      "SAFE_CAST"
    ],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions
    date: ["CURRENT_DATE", "EXTRACT", "DATE", "DATE_ADD", "DATE_SUB", "DATE_DIFF", "DATE_TRUNC", "DATE_FROM_UNIX_DATE", "FORMAT_DATE", "LAST_DAY", "PARSE_DATE", "UNIX_DATE"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/datetime_functions
    datetime: ["CURRENT_DATETIME", "DATETIME", "EXTRACT", "DATETIME_ADD", "DATETIME_SUB", "DATETIME_DIFF", "DATETIME_TRUNC", "FORMAT_DATETIME", "LAST_DAY", "PARSE_DATETIME"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging_functions
    debugging: ["ERROR"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/federated_query_functions
    federatedQuery: ["EXTERNAL_QUERY"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions
    geography: ["S2_CELLIDFROMPOINT", "S2_COVERINGCELLIDS", "ST_ANGLE", "ST_AREA", "ST_ASBINARY", "ST_ASGEOJSON", "ST_ASTEXT", "ST_AZIMUTH", "ST_BOUNDARY", "ST_BOUNDINGBOX", "ST_BUFFER", "ST_BUFFERWITHTOLERANCE", "ST_CENTROID", "ST_CENTROID_AGG", "ST_CLOSESTPOINT", "ST_CLUSTERDBSCAN", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DUMP", "ST_DWITHIN", "ST_ENDPOINT", "ST_EQUALS", "ST_EXTENT", "ST_EXTERIORRING", "ST_GEOGFROM", "ST_GEOGFROMGEOJSON", "ST_GEOGFROMTEXT", "ST_GEOGFROMWKB", "ST_GEOGPOINT", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOHASH", "ST_GEOMETRYTYPE", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_INTERSECTSBOX", "ST_ISCOLLECTION", "ST_ISEMPTY", "ST_LENGTH", "ST_MAKELINE", "ST_MAKEPOLYGON", "ST_MAKEPOLYGONORIENTED", "ST_MAXDISTANCE", "ST_NPOINTS", "ST_NUMGEOMETRIES", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SIMPLIFY", "ST_SNAPTOGRID", "ST_STARTPOINT", "ST_TOUCHES", "ST_UNION", "ST_UNION_AGG", "ST_WITHIN", "ST_X", "ST_Y"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions
    hash: ["FARM_FINGERPRINT", "MD5", "SHA1", "SHA256", "SHA512"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions
    hll: ["HLL_COUNT.INIT", "HLL_COUNT.MERGE", "HLL_COUNT.MERGE_PARTIAL", "HLL_COUNT.EXTRACT"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/interval_functions
    interval: ["MAKE_INTERVAL", "EXTRACT", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions
    json: ["JSON_EXTRACT", "JSON_QUERY", "JSON_EXTRACT_SCALAR", "JSON_VALUE", "JSON_EXTRACT_ARRAY", "JSON_QUERY_ARRAY", "JSON_EXTRACT_STRING_ARRAY", "JSON_VALUE_ARRAY", "TO_JSON_STRING"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions
    math: ["ABS", "SIGN", "IS_INF", "IS_NAN", "IEEE_DIVIDE", "RAND", "SQRT", "POW", "POWER", "EXP", "LN", "LOG", "LOG10", "GREATEST", "LEAST", "DIV", "SAFE_DIVIDE", "SAFE_MULTIPLY", "SAFE_NEGATE", "SAFE_ADD", "SAFE_SUBTRACT", "MOD", "ROUND", "TRUNC", "CEIL", "CEILING", "FLOOR", "COS", "COSH", "ACOS", "ACOSH", "SIN", "SINH", "ASIN", "ASINH", "TAN", "TANH", "ATAN", "ATANH", "ATAN2", "RANGE_BUCKET"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions
    navigation: ["FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "LEAD", "LAG", "PERCENTILE_CONT", "PERCENTILE_DISC"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/net_functions
    net: ["NET.IP_FROM_STRING", "NET.SAFE_IP_FROM_STRING", "NET.IP_TO_STRING", "NET.IP_NET_MASK", "NET.IP_TRUNC", "NET.IPV4_FROM_INT64", "NET.IPV4_TO_INT64", "NET.HOST", "NET.PUBLIC_SUFFIX", "NET.REG_DOMAIN"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions
    numbering: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "NTILE", "ROW_NUMBER"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/security_functions
    security: ["SESSION_USER"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/statistical_aggregate_functions
    statisticalAggregate: ["CORR", "COVAR_POP", "COVAR_SAMP", "STDDEV_POP", "STDDEV_SAMP", "STDDEV", "VAR_POP", "VAR_SAMP", "VARIANCE"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions
    string: ["ASCII", "BYTE_LENGTH", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CODE_POINTS_TO_BYTES", "CODE_POINTS_TO_STRING", "CONCAT", "CONTAINS_SUBSTR", "ENDS_WITH", "FORMAT", "FROM_BASE32", "FROM_BASE64", "FROM_HEX", "INITCAP", "INSTR", "LEFT", "LENGTH", "LPAD", "LOWER", "LTRIM", "NORMALIZE", "NORMALIZE_AND_CASEFOLD", "OCTET_LENGTH", "REGEXP_CONTAINS", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "REPEAT", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SAFE_CONVERT_BYTES_TO_STRING", "SOUNDEX", "SPLIT", "STARTS_WITH", "STRPOS", "SUBSTR", "SUBSTRING", "TO_BASE32", "TO_BASE64", "TO_CODE_POINTS", "TO_HEX", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/time_functions
    time: ["CURRENT_TIME", "TIME", "EXTRACT", "TIME_ADD", "TIME_SUB", "TIME_DIFF", "TIME_TRUNC", "FORMAT_TIME", "PARSE_TIME"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions
    timestamp: ["CURRENT_TIMESTAMP", "EXTRACT", "STRING", "TIMESTAMP", "TIMESTAMP_ADD", "TIMESTAMP_SUB", "TIMESTAMP_DIFF", "TIMESTAMP_TRUNC", "FORMAT_TIMESTAMP", "PARSE_TIMESTAMP", "TIMESTAMP_SECONDS", "TIMESTAMP_MILLIS", "TIMESTAMP_MICROS", "UNIX_SECONDS", "UNIX_MILLIS", "UNIX_MICROS"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/uuid_functions
    uuid: ["GENERATE_UUID"],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/conditional_expressions
    conditional: ["COALESCE", "IF", "IFNULL", "NULLIF"],
    // https://cloud.google.com/bigquery/docs/reference/legacy-sql
    legacyAggregate: ["AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "EXACT_COUNT_DISTINCT", "FIRST", "GROUP_CONCAT", "GROUP_CONCAT_UNQUOTED", "LAST", "MAX", "MIN", "NEST", "NTH", "QUANTILES", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "TOP", "UNIQUE", "VARIANCE", "VAR_POP", "VAR_SAMP"],
    legacyBitwise: ["BIT_COUNT"],
    legacyCasting: ["BOOLEAN", "BYTES", "CAST", "FLOAT", "HEX_STRING", "INTEGER", "STRING"],
    legacyComparison: [
      // expr 'IN',
      "COALESCE",
      "GREATEST",
      "IFNULL",
      "IS_INF",
      "IS_NAN",
      "IS_EXPLICITLY_DEFINED",
      "LEAST",
      "NVL"
    ],
    legacyDatetime: ["CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE", "DATE_ADD", "DATEDIFF", "DAY", "DAYOFWEEK", "DAYOFYEAR", "FORMAT_UTC_USEC", "HOUR", "MINUTE", "MONTH", "MSEC_TO_TIMESTAMP", "NOW", "PARSE_UTC_USEC", "QUARTER", "SEC_TO_TIMESTAMP", "SECOND", "STRFTIME_UTC_USEC", "TIME", "TIMESTAMP", "TIMESTAMP_TO_MSEC", "TIMESTAMP_TO_SEC", "TIMESTAMP_TO_USEC", "USEC_TO_TIMESTAMP", "UTC_USEC_TO_DAY", "UTC_USEC_TO_HOUR", "UTC_USEC_TO_MONTH", "UTC_USEC_TO_WEEK", "UTC_USEC_TO_YEAR", "WEEK", "YEAR"],
    legacyIp: ["FORMAT_IP", "PARSE_IP", "FORMAT_PACKED_IP", "PARSE_PACKED_IP"],
    legacyJson: ["JSON_EXTRACT", "JSON_EXTRACT_SCALAR"],
    legacyMath: ["ABS", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATANH", "ATAN2", "CEIL", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG2", "LOG10", "PI", "POW", "RADIANS", "RAND", "ROUND", "SIN", "SINH", "SQRT", "TAN", "TANH"],
    legacyRegex: ["REGEXP_MATCH", "REGEXP_EXTRACT", "REGEXP_REPLACE"],
    legacyString: [
      "CONCAT",
      // expr CONTAINS 'str'
      "INSTR",
      "LEFT",
      "LENGTH",
      "LOWER",
      "LPAD",
      "LTRIM",
      "REPLACE",
      "RIGHT",
      "RPAD",
      "RTRIM",
      "SPLIT",
      "SUBSTR",
      "UPPER"
    ],
    legacyTableWildcard: ["TABLE_DATE_RANGE", "TABLE_DATE_RANGE_STRICT", "TABLE_QUERY"],
    legacyUrl: ["HOST", "DOMAIN", "TLD"],
    legacyWindow: ["AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER"],
    legacyMisc: ["CURRENT_USER", "EVERY", "FROM_BASE64", "HASH", "FARM_FINGERPRINT", "IF", "POSITION", "SHA1", "SOME", "TO_BASE64"],
    other: ["BQ.JOBS.CANCEL", "BQ.REFRESH_MATERIALIZED_VIEW"],
    pivot: ["PIVOT", "UNPIVOT"]
  }, re = {
    keywords: [
      "ALL",
      // 'AND',
      "ANY",
      // 'ARRAY',
      "AS",
      "ASC",
      "ASSERT_ROWS_MODIFIED",
      "AT",
      "BETWEEN",
      "BY",
      // 'CASE',
      "CAST",
      "COLLATE",
      "CONTAINS",
      // 'CREATE',
      // 'CROSS',
      "CUBE",
      "CURRENT",
      "DEFAULT",
      "DEFINE",
      "DESC",
      "DISTINCT",
      // 'ELSE',
      // 'END',
      "ENUM",
      "ESCAPE",
      // 'EXCEPT',
      // 'EXCLUDE',
      "EXISTS",
      "EXTRACT",
      "FALSE",
      // 'FETCH',
      "FOLLOWING",
      "FOR",
      // 'FROM',
      "FULL",
      // 'GROUP',
      "GROUPING",
      "GROUPS",
      "HASH",
      // 'HAVING',
      "IF",
      "IGNORE",
      "IN",
      // 'INNER',
      // 'INTERSECT',
      // 'INTERVAL',
      "INTO",
      "IS",
      // 'JOIN',
      // 'LATERAL',
      // 'LEFT',
      "LIKE",
      // 'LIMIT',
      "LOOKUP",
      // 'MERGE',
      // 'NATURAL',
      "NEW",
      "NO",
      "NOT",
      "NULL",
      "NULLS",
      "OF",
      // 'ON',
      // 'OR',
      // 'ORDER',
      // 'OUTER',
      "OVER",
      "PARTITION",
      "PRECEDING",
      "PROTO",
      "RANGE",
      "RECURSIVE",
      "RESPECT",
      // 'RIGHT',
      "ROLLUP",
      "ROWS",
      // 'SELECT',
      // 'SET',
      "SOME",
      // 'STRUCT',
      "TABLE",
      "TABLESAMPLE SYSTEM",
      "THEN",
      "TO",
      "TREAT",
      "TRUE",
      "UNBOUNDED",
      // 'UNION',
      "UNNEST",
      // 'USING',
      // 'WHEN',
      // 'WHERE',
      // 'WINDOW',
      // 'WITH',
      "WITHIN"
    ],
    datatypes: [
      "ARRAY",
      // parametric, ARRAY<T>
      "BOOL",
      "BYTES",
      // parameterised, BYTES(Length)
      "DATE",
      "DATETIME",
      "GEOGRAPHY",
      "INTERVAL",
      "INT64",
      "INT",
      "SMALLINT",
      "INTEGER",
      "BIGINT",
      "TINYINT",
      "BYTEINT",
      "NUMERIC",
      // parameterised, NUMERIC(Precision[, Scale])
      "DECIMAL",
      // parameterised, DECIMAL(Precision[, Scale])
      "BIGNUMERIC",
      // parameterised, BIGNUMERIC(Precision[, Scale])
      "BIGDECIMAL",
      // parameterised, BIGDECIMAL(Precision[, Scale])
      "FLOAT64",
      "STRING",
      // parameterised, STRING(Length)
      "STRUCT",
      // parametric, STRUCT<T>
      "TIME",
      "TIMEZONE"
    ],
    // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions#formatting_syntax
    stringFormat: ["HEX", "BASEX", "BASE64M", "ASCII", "UTF-8", "UTF8"],
    misc: ["SAFE"]
  }, B = [
    // DQL, https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax
    "SELECT",
    "FROM",
    "WHERE",
    "GROUP BY",
    "HAVING",
    "ORDER BY",
    "QUALIFY",
    "WINDOW",
    "PARTITION BY",
    "LIMIT",
    "OFFSET",
    "WITH",
    "OMIT RECORD IF",
    // legacy
    // DML, https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax
    "INSERT",
    "INSERT INTO",
    "VALUES",
    "DELETE",
    "DELETE FROM",
    "TRUNCATE TABLE",
    "UPDATE",
    "MERGE",
    "MERGE INTO",
    // 'USING',
    // DDL, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
    "SET SCHEMA",
    // added
    "CREATE SCHEMA",
    "CREATE TABLE",
    "CREATE TABLE IF NOT EXISTS",
    "CREATE TEMP TABLE",
    "CREATE TEMP TABLE IF NOT EXISTS",
    "CREATE TEMPORARY TABLE",
    "CREATE TEMPORARY TABLE IF NOT EXISTS",
    "CREATE OR REPLACE TABLE",
    "CREATE OR REPLACE TEMP TABLE",
    "CREATE OR REPLACE TEMPORARY TABLE",
    "CREATE TABLE LIKE",
    "CREATE TABLE COPY",
    "CREATE SNAPSHOT TABLE",
    "CREATE TABLE CLONE",
    "CREATE VIEW",
    "CREATE VIEW IF NOT EXISTS",
    "CREATE OR REPLACE VIEW",
    "CREATE MATERIALIZED VIEW",
    "CREATE EXTERNAL TABLE",
    "CREATE FUNCTION",
    "CREATE TABLE FUNCTION",
    "CREATE PROCEDURE",
    "CREATE ROW ACCESS POLICY",
    "ALTER SCHEMA SET OPTIONS",
    "ALTER TABLE SET OPTIONS",
    "ALTER TABLE ADD COLUMN",
    "ALTER TABLE RENAME TO",
    "ALTER TABLE DROP COLUMN",
    "ALTER COLUMN SET OPTIONS",
    "ALTER COLUMN DROP NOT NULL",
    "ALTER COLUMN SET DATA TYPE",
    "ALTER VIEW SET OPTIONS",
    "ALTER MATERIALIZED VIEW SET OPTIONS",
    "DROP SCHEMA",
    "DROP TABLE",
    "DROP SNAPSHOT TABLE",
    "DROP EXTERNAL TABLE",
    "DROP VIEW",
    "DROP MATERIALIZED VIEW",
    "DROP FUNCTION",
    "DROP TABLE FUNCTION",
    "DROP PROCEDURE",
    "DROP ROW ACCESS POLICY",
    // DCL, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-control-language
    "GRANT",
    "REVOKE",
    "CREATE CAPACITY",
    "CREATE RESERVATION",
    "CREATE ASSIGNMENT",
    "DROP CAPACITY",
    "DROP RESERVATION",
    "DROP ASSIGNMENT",
    // Script, https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting
    "DECLARE",
    "SET",
    "EXECUTE IMMEDIATE",
    "LOOP",
    "END LOOP",
    "REPEAT",
    "END REPEAT",
    "WHILE",
    "END WHILE",
    "BREAK",
    "LEAVE",
    "CONTINUE",
    "ITERATE",
    "FOR",
    "END FOR",
    "BEGIN",
    "BEGIN TRANSACTION",
    "COMMIT TRANSACTION",
    "ROLLBACK TRANSACTION",
    "RAISE",
    "RETURN",
    "CALL",
    // Debug, https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging-statements
    "ASSERT",
    // Other, https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements
    "EXPORT DATA"
  ], Y = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT"], E = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN"], m = ["WHEN", "ELSE"], P = function(w) {
    V(te, w);
    var J = $(te);
    function te() {
      return D(this, te), J.apply(this, arguments);
    }
    return x(te, [{
      key: "tokenizer",
      value: (
        // TODO: handle trailing comma in select clause
        function() {
          return new n.default({
            reservedCommands: B,
            reservedBinaryCommands: Y,
            reservedJoins: E,
            reservedDependentClauses: m,
            reservedKeywords: (0, s.dedupe)([].concat(f(Object.values(H).flat()), f(Object.values(re).flat()))),
            openParens: ["(", "["],
            closeParens: [")", "]"],
            stringTypes: [
              // The triple-quoted strings are listed first, so they get matched first.
              // Otherwise the first two quotes of """ will get matched as an empty "" string.
              {
                quote: '""".."""',
                prefixes: ["R", "B", "RB", "BR"]
              },
              {
                quote: "'''..'''",
                prefixes: ["R", "B", "RB", "BR"]
              },
              {
                quote: '""',
                prefixes: ["R", "B", "RB", "BR"]
              },
              {
                quote: "''",
                prefixes: ["R", "B", "RB", "BR"]
              }
            ],
            identTypes: ["``"],
            identChars: {
              dashes: true
            },
            positionalParams: true,
            namedParamTypes: ["@"],
            quotedParamTypes: ["@"],
            lineCommentTypes: ["--", "#"],
            operators: te.operators,
            postProcess: R
          });
        }
      )
    }]), te;
  }(i.default);
  t.default = P, G(P, "operators", ["~", ">>", "<<", "||"]);
  function R(w) {
    return A(y2(w));
  }
  function A(w) {
    var J = a.EOF_TOKEN;
    return w.map(function(te) {
      return te.value === "OFFSET" && J.value === "[" ? (J = te, c(c({}, te), {}, {
        type: a.TokenType.RESERVED_KEYWORD
      })) : (J = te, te);
    });
  }
  function y2(w) {
    for (var J = [], te = 0; te < w.length; te++) {
      var se = w[te], ge = w[te + 1] || a.EOF_TOKEN;
      if ((a.isToken.ARRAY(se) || a.isToken.STRUCT(se)) && ge.value === "<") {
        var fe = j(w, te + 1), et = w.slice(te, fe + 1);
        J.push({
          type: a.TokenType.IDENTIFIER,
          value: et.map(C("value")).join(""),
          text: et.map(C("text")).join("")
        }), te = fe;
      } else
        J.push(se);
    }
    return J;
  }
  var C = function(J) {
    return function(te) {
      return te.type === a.TokenType.IDENTIFIER || te.type === a.TokenType.COMMA ? te[J] + " " : te[J];
    };
  };
  function j(w, J) {
    for (var te = 0, se = J; se < w.length; se++) {
      var ge = w[se];
      if (ge.value === "<" ? te++ : ge.value === ">" ? te-- : ge.value === ">>" && (te -= 2), te === 0)
        return se;
    }
    return w.length - 1;
  }
  e.exports = t.default;
})(_l, _l.exports);
var U_ = _l.exports;
var Yl = { exports: {} };
(function(e, t) {
  function r(E) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(E);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function o(E) {
    return p(E) || f(E) || c(E) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(E, m) {
    if (E) {
      if (typeof E == "string")
        return O(E, m);
      var P = Object.prototype.toString.call(E).slice(8, -1);
      if (P === "Object" && E.constructor && (P = E.constructor.name), P === "Map" || P === "Set")
        return Array.from(E);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return O(E, m);
    }
  }
  function f(E) {
    if (typeof Symbol < "u" && E[Symbol.iterator] != null || E["@@iterator"] != null)
      return Array.from(E);
  }
  function p(E) {
    if (Array.isArray(E))
      return O(E);
  }
  function O(E, m) {
    (m == null || m > E.length) && (m = E.length);
    for (var P = 0, R = new Array(m); P < m; P++)
      R[P] = E[P];
    return R;
  }
  function d2(E, m) {
    if (!(E instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(E, m) {
    for (var P = 0; P < m.length; P++) {
      var R = m[P];
      R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(E, R.key, R);
    }
  }
  function L(E, m, P) {
    return m && g(E.prototype, m), P && g(E, P), Object.defineProperty(E, "prototype", { writable: false }), E;
  }
  function D(E, m) {
    if (typeof m != "function" && m !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(m && m.prototype, { constructor: { value: E, writable: true, configurable: true } }), Object.defineProperty(E, "prototype", { writable: false }), m && W(E, m);
  }
  function W(E, m) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, A) {
      return R.__proto__ = A, R;
    }, W(E, m);
  }
  function x(E) {
    var m = $();
    return function() {
      var R = z(E), A;
      if (m) {
        var y2 = z(this).constructor;
        A = Reflect.construct(R, arguments, y2);
      } else
        A = R.apply(this, arguments);
      return V(this, A);
    };
  }
  function V(E, m) {
    if (m && (r(m) === "object" || typeof m == "function"))
      return m;
    if (m !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(E);
  }
  function _2(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(E) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
      return P.__proto__ || Object.getPrototypeOf(P);
    }, z(E);
  }
  function F(E, m, P) {
    return m in E ? Object.defineProperty(E, m, { value: P, enumerable: true, configurable: true, writable: true }) : E[m] = P, E;
  }
  var ae = {
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-aggregate
    aggregate: ["ARRAY_AGG", "AVG", "CORR", "CORRELATION", "COUNT", "COUNT_BIG", "COVAR_POP", "COVARIANCE", "COVAR", "COVAR_SAMP", "COVARIANCE_SAMP", "CUME_DIST", "GROUPING", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_ICPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV", "STDDEV_SAMP", "SUM", "VAR_POP", "VARIANCE", "VAR", "VAR_SAMP", "VARIANCE_SAMP", "XMLAGG"],
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-scalar
    scalar: ["ABS", "ABSVAL", "ACOS", "ADD_DAYS", "ADD_MONTHS", "ARRAY_DELETE", "ARRAY_FIRST", "ARRAY_LAST", "ARRAY_NEXT", "ARRAY_PRIOR", "ARRAY_TRIM", "ASCII", "ASCII_CHR", "ASCII_STR", "ASCIISTR", "ASIN", "ATAN", "ATANH", "ATAN2", "BIGINT", "BINARY", "BITAND", "BITANDNOT", "BITOR", "BITXOR", "BITNOT", "BLOB", "BTRIM", "CARDINALITY", "CCSID_ENCODING", "CEILING", "CEIL", "CHAR", "CHAR9", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CLOB", "COALESCE", "COLLATION_KEY", "COMPARE_DECFLOAT", "CONCAT", "CONTAINS", "COS", "COSH", "DATE", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEK_ISO", "DAYOFYEAR", "DAYS", "DAYS_BETWEEN", "DBCLOB", "DECFLOAT", "DECFLOAT_FORMAT", "DECFLOAT_SORTKEY", "DECIMAL", "DEC", "DECODE", "DECRYPT_BINARY", "DECRYPT_BIT", "DECRYPT_CHAR", "DECRYPT_DB", "DECRYPT_DATAKEY_BIGINT", "DECRYPT_DATAKEY_BIT", "DECRYPT_DATAKEY_CLOB", "DECRYPT_DATAKEY_DBCLOB", "DECRYPT_DATAKEY_DECIMAL", "DECRYPT_DATAKEY_INTEGER", "DECRYPT_DATAKEY_VARCHAR", "DECRYPT_DATAKEY_VARGRAPHIC", "DEGREES", "DIFFERENCE", "DIGITS", "DOUBLE_PRECISION", "DOUBLE", "DSN_XMLVALIDATE", "EBCDIC_CHR", "EBCDIC_STR", "ENCRYPT_DATAKEY", "ENCRYPT_TDES", "EXP", "EXTRACT", "FLOAT", "FLOOR", "GENERATE_UNIQUE", "GENERATE_UNIQUE_BINARY", "GETHINT", "GETVARIABLE", "GRAPHIC", "GREATEST", "HASH", "HASH_CRC32", "HASH_MD5", "HASH_SHA1", "HASH_SHA256", "HEX", "HOUR", "IDENTITY_VAL_LOCAL", "IFNULL", "INSERT", "INSTR", "INTEGER", "INT", "JULIAN_DAY", "LAST_DAY", "LCASE", "LEAST", "LEFT", "LENGTH", "LN", "LOCATE", "LOCATE_IN_STRING", "LOG10", "LOWER", "LPAD", "LTRIM", "MAX", "MAX_CARDINALITY", "MICROSECOND", "MIDNIGHT_SECONDS", "MIN", "MINUTE", "MOD", "MONTH", "MONTHS_BETWEEN", "MQREAD", "MQREADCLOB", "MQRECEIVE", "MQRECEIVECLOB", "MQSEND", "MULTIPLY_ALT", "NEXT_DAY", "NEXT_MONTH", "NORMALIZE_DECFLOAT", "NORMALIZE_STRING", "NULLIF", "NVL", "OVERLAY", "PACK", "POSITION", "POSSTR", "POWER", "POW", "QUANTIZE", "QUARTER", "RADIANS", "RAISE_ERROR", "RANDOM", "RAND", "REAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "RID", "RIGHT", "ROUND", "ROUND_TIMESTAMP", "ROWID", "RPAD", "RTRIM", "SCORE", "SECOND", "SIGN", "SIN", "SINH", "SMALLINT", "SOUNDEX", "SOAPHTTPC", "SOAPHTTPV", "SOAPHTTPNC", "SOAPHTTPNV", "SPACE", "SQRT", "STRIP", "STRLEFT", "STRPOS", "STRRIGHT", "SUBSTR", "SUBSTRING", "TAN", "TANH", "TIME", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMESTAMP_FORMAT", "TIMESTAMP_ISO", "TIMESTAMP_TZ", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_NUMBER", "TOTALORDER", "TO_TIMESTAMP", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRUNC", "TRUNC_TIMESTAMP", "UCASE", "UNICODE", "UNICODE_STR", "UNISTR", "UPPER", "VALUE", "VARBINARY", "VARCHAR", "VARCHAR9", "VARCHAR_BIT_FORMAT", "VARCHAR_FORMAT", "VARGRAPHIC", "VERIFY_GROUP_FOR_USER", "VERIFY_ROLE_FOR_USER", "VERIFY_TRUSTED_CONTEXT_ROLE_FOR_USER", "WEEK", "WEEK_ISO", "WRAP", "XMLATTRIBUTES", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLMODIFY", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLSERIALIZE", "XMLTEXT", "XMLXSROBJECTID", "XSLTRANSFORM", "YEAR"],
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-table
    table: ["ADMIN_TASK_LIST", "ADMIN_TASK_OUTPUT", "ADMIN_TASK_STATUS", "BLOCKING_THREADS", "MQREADALL", "MQREADALLCLOB", "MQRECEIVEALL", "MQRECEIVEALLCLOB", "XMLTABLE"],
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-row
    row: ["UNPACK"],
    // https://www.ibm.com/docs/en/db2-for-zos/12?topic=expressions-olap-specification
    olap: ["FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "RATIO_TO_REPORT"]
  }, U = {
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=words-reserved#db2z_reservedwords__newresword
    standard: ["ALL", "ALLOCATE", "ALLOW", "ALTERAND", "ANY", "AS", "ARRAY", "ARRAY_EXISTS", "ASENSITIVE", "ASSOCIATE", "ASUTIME", "AT", "AUDIT", "AUX", "AUXILIARY", "BEFORE", "BEGIN", "BETWEEN", "BUFFERPOOL", "BY", "CAPTURE", "CASCADED", "CAST", "CCSID", "CHARACTER", "CHECK", "CLONE", "CLUSTER", "COLLECTION", "COLLID", "COLUMN", "CONDITION", "CONNECTION", "CONSTRAINT", "CONTENT", "CONTINUE", "CREATE", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_LC_CTYPE", "CURRENT_PATH", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRVAL", "CURSOR", "DATA", "DATABASE", "DBINFO", "DECLARE", "DEFAULT", "DESCRIPTOR", "DETERMINISTIC", "DISABLE", "DISALLOW", "DISTINCT", "DO", "DOCUMENT", "DSSIZE", "DYNAMIC", "EDITPROC", "ENCODING", "ENCRYPTION", "ENDING", "END-EXEC", "ERASE", "ESCAPE", "EXCEPTION", "EXISTS", "EXIT", "EXTERNAL", "FENCED", "FIELDPROC", "FINAL", "FIRST", "FOR", "FREE", "FULL", "FUNCTION", "GENERATED", "GET", "GLOBAL", "GOTO", "GROUP", "HANDLER", "HOLD", "HOURS", "IF", "IMMEDIATE", "IN", "INCLUSIVE", "INDEX", "INHERIT", "INNER", "INOUT", "INSENSITIVE", "INTO", "IS", "ISOBID", "ITERATE", "JAR", "KEEP", "KEY", "LANGUAGE", "LAST", "LC_CTYPE", "LEAVE", "LIKE", "LOCAL", "LOCALE", "LOCATOR", "LOCATORS", "LOCK", "LOCKMAX", "LOCKSIZE", "LONG", "LOOP", "MAINTAINED", "MATERIALIZED", "MICROSECONDS", "MINUTEMINUTES", "MODIFIES", "MONTHS", "NEXT", "NEXTVAL", "NO", "NONE", "NOT", "NULL", "NULLS", "NUMPARTS", "OBID", "OF", "OLD", "ON DELETE", "ON UPDATE", "OPTIMIZATION", "OPTIMIZE", "ORDER", "ORGANIZATION", "OUT", "OUTER", "PACKAGE", "PARAMETER", "PART", "PADDED", "PARTITION", "PARTITIONED", "PARTITIONING", "PATH", "PIECESIZE", "PERIOD", "PLAN", "PRECISION", "PREVVAL", "PRIOR", "PRIQTY", "PRIVILEGES", "PROCEDURE", "PROGRAM", "PSID", "PUBLIC", "QUERY", "QUERYNO", "READS", "REFERENCES", "RESIGNAL", "RESTRICT", "RESULT", "RESULT_SET_LOCATOR", "RETURN", "RETURNS", "ROLE", "ROLLUP", "ROUND_CEILING", "ROUND_DOWN", "ROUND_FLOOR", "ROUND_HALF_DOWN", "ROUND_HALF_EVEN", "ROUND_HALF_UP", "ROUND_UP", "ROW", "ROWSET", "SCHEMA", "SCRATCHPAD", "SECONDS", "SECQTY", "SECURITY", "SEQUENCE", "SENSITIVE", "SESSION_USER", "SIMPLE", "SOME", "SOURCE", "SPECIFIC", "STANDARD", "STATIC", "STATEMENT", "STAY", "STOGROUP", "STORES", "STYLE", "SUMMARY", "SYNONYM", "SYSDATE", "SYSTEM", "SYSTIMESTAMP", "TABLE", "TABLESPACE", "THEN", "TO", "TRIGGER", "TYPE", "UNDO", "UNIQUE", "UNTIL", "USER", "VALIDPROC", "VARIABLE", "VARIANT", "VCAT", "VERSIONING", "VIEW", "VOLATILE", "VOLUMES", "WHILE", "WLM", "XMLEXISTS", "XMLCAST", "YEARS", "ZONE"],
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=utilities-db2-online
    onlineUtilies: ["BACKUP SYSTEM", "CATENFM", "CATMAINT", "CHECK DATA", "CHECK INDEX", "CHECK LOB", "COPY", "COPYTOCOPY", "DIAGNOSE", "EXEC SQL", "LISTDEF", "LOAD", "MERGECOPY", "MODIFY RECOVERY", "MODIFY STATISTICS", "OPTIONS", "QUIESCE", "REBUILD INDEX", "RECOVER", "REORG INDEX", "REORG TABLESPACE", "REPAIR", "REPORT", "RESTORE SYSTEM", "RUNSTATS", "STOSPACE", "TEMPLATE", "UNLOAD"],
    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=db2-commands
    commands: ["ABEND", "ACCESS DATABASE", "ALTER BUFFERPOOL", "ALTER GROUPBUFFERPOOL", "ALTER UTILITY", "ARCHIVE LOG", "BIND PACKAGE", "BIND PLAN", "BIND QUERY", "BIND SERVICE", "BIND", "REBIND", "CANCEL THREAD", "DCLGEN", "DISPLAY ACCEL", "DISPLAY ARCHIVE", "DISPLAY BLOCKERS", "DISPLAY BUFFERPOOL", "DISPLAY DATABASE", "DISPLAY DDF", "DISPLAY FUNCTION SPECIFIC", "DISPLAY GROUP", "DISPLAY GROUPBUFFERPOOL", "DISPLAY LOCATION", "DISPLAY LOG", "DISPLAY PROCEDURE", "DISPLAY PROFILE", "DISPLAY RLIMIT", "DISPLAY RESTSVC", "DISPLAY THREAD", "DISPLAY TRACE", "DISPLAY UTILITY", "DSN", "DSNH", "FREE PACKAGE", "FREE PLAN", "FREE QUERY", "FREE SERVICE", "MODIFY admtproc,APPL=SHUTDOWN", "MODIFY admtproc,APPL=TRACE", "MODIFY DDF", "MODIFY irlmproc,ABEND", "MODIFY irlmproc,DIAG", "MODIFY irlmproc,PURGE", "MODIFY irlmproc,SET", "MODIFY irlmproc,STATUS", "MODIFY TRACE", "REBIND PACKAGE", "REBIND PLAN", "REBIND TRIGGER PACKAGE", "RECOVER BSDS", "RECOVER INDOUBT", "RECOVER POSTPONED", "REFRESH DB2,EARLY", "RESET GENERICLU", "RESET INDOUBT", "RUN", "SET ARCHIVE", "SET LOG", "SET SYSPARM", "SPUFI", "START ACCEL", "START admtproc", "START CDDS", "START DATABASE", "START DB2", "START DDF", "START FUNCTION SPECIFIC", "START irlmproc", "START PROCEDURE", "START PROFILE", "START RLIMIT", "START RESTSVC", "START TRACE", "STOP ACCEL", "STOP admtproc", "STOP CDDS", "STOP DATABASE", "STOP DB2", "STOP DDF", "STOP FUNCTION SPECIFIC", "STOP irlmproc", "STOP PROCEDURE", "STOP PROFILE", "STOP RLIMIT", "STOP RESTSVC", "STOP TRACE", "TERM UTILITY", "TRACE CT"]
  }, G = [
    "ALLOCATE CURSOR",
    "ALTER DATABASE",
    "ALTER FUNCTION",
    "ALTER INDEX",
    "ALTER MASK",
    "ALTER PERMISSION",
    "ALTER PROCEDURE",
    "ALTER SEQUENCE",
    "ALTER STOGROUP",
    "ALTER TABLE",
    "ALTER TABLESPACE",
    "ALTER TRIGGER",
    "ALTER TRUSTED CONTEXT",
    "ALTER VIEW",
    "ASSOCIATE LOCATORS",
    "BEGIN DECLARE SECTION",
    "CALL",
    "CLOSE",
    "COMMENT",
    "COMMIT",
    "CONNECT",
    "CREATE ALIAS",
    "CREATE AUXILIARY TABLE",
    "CREATE DATABASE",
    "CREATE FUNCTION",
    "CREATE GLOBAL TEMPORARY TABLE",
    "CREATE INDEX",
    "CREATE LOB TABLESPACE",
    "CREATE MASK",
    "CREATE PERMISSION",
    "CREATE PROCEDURE",
    "CREATE ROLE",
    "CREATE SEQUENCE",
    "CREATE STOGROUP",
    "CREATE SYNONYM",
    "CREATE TABLE",
    "CREATE TABLESPACE",
    "CREATE TRIGGER",
    "CREATE TRUSTED CONTEXT",
    "CREATE TYPE",
    "CREATE VARIABLE",
    "CREATE VIEW",
    "DECLARE CURSOR",
    "DECLARE GLOBAL TEMPORARY TABLE",
    "DECLARE STATEMENT",
    "DECLARE TABLE",
    "DECLARE VARIABLE",
    "DELETE",
    "DELETE FROM",
    "DESCRIBE CURSOR",
    "DESCRIBE INPUT",
    "DESCRIBE OUTPUT",
    "DESCRIBE PROCEDURE",
    "DESCRIBE TABLE",
    "DROP",
    "END DECLARE SECTION",
    "EXCHANGE",
    "EXECUTE",
    "EXECUTE IMMEDIATE",
    "EXPLAIN",
    "FETCH",
    "FREE LOCATOR",
    "GET DIAGNOSTICS",
    "GRANT",
    "HOLD LOCATOR",
    "INCLUDE",
    "INSERT",
    "LABEL",
    "LOCK TABLE",
    "MERGE",
    "OPEN",
    "PREPARE",
    "REFRESH",
    "RELEASE",
    "RELEASE SAVEPOINT",
    "RENAME",
    "REVOKE",
    "ROLLBACK",
    "SAVEPOINT",
    "SELECT",
    "SELECT INTO",
    "SET CONNECTION",
    "SET",
    "SET CURRENT ACCELERATOR",
    "SET CURRENT APPLICATION COMPATIBILITY",
    "SET CURRENT APPLICATION ENCODING SCHEME",
    "SET CURRENT DEBUG MODE",
    "SET CURRENT DECFLOAT ROUNDING MODE",
    "SET CURRENT DEGREE",
    "SET CURRENT EXPLAIN MODE",
    "SET CURRENT GET_ACCEL_ARCHIVE",
    "SET CURRENT LOCALE LC_CTYPE",
    "SET CURRENT MAINTAINED TABLE TYPES FOR OPTIMIZATION",
    "SET CURRENT OPTIMIZATION HINT",
    "SET CURRENT PACKAGE PATH",
    "SET CURRENT PACKAGESET",
    "SET CURRENT PRECISION",
    "SET CURRENT QUERY ACCELERATION",
    "SET CURRENT QUERY ACCELERATION WAITFORDATA",
    "SET CURRENT REFRESH AGE",
    "SET CURRENT ROUTINE VERSION",
    "SET CURRENT RULES",
    "SET CURRENT SQLID",
    "SET CURRENT TEMPORAL BUSINESS_TIME",
    "SET CURRENT TEMPORAL SYSTEM_TIME",
    "SET ENCRYPTION PASSWORD",
    "SET PATH",
    "SET SCHEMA",
    "SET SESSION TIME ZONE",
    "SIGNAL",
    "TRUNCATE",
    "UPDATE",
    "VALUES",
    "VALUES INTO",
    "WHENEVER",
    // other
    "ADD",
    "ALTER COLUMN",
    // verify
    "AFTER",
    "DROP TABLE",
    // verify
    "FETCH FIRST",
    "FROM",
    "GROUP BY",
    "GO",
    "HAVING",
    "INSERT INTO",
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "SELECT",
    "SET CURRENT SCHEMA",
    "WHERE",
    "WITH"
  ], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT"], re = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN", "NATURAL JOIN"], B = ["WHEN", "ELSE", "ELSEIF"], Y = function(E) {
    D(P, E);
    var m = x(P);
    function P() {
      return d2(this, P), m.apply(this, arguments);
    }
    return L(P, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: G,
          reservedBinaryCommands: H,
          reservedJoins: re,
          reservedDependentClauses: B,
          reservedKeywords: (0, a.dedupe)([].concat(o(Object.values(ae).flat()), o(Object.values(U).flat()))),
          stringTypes: [{
            quote: "''",
            prefixes: ["X", "G", "N", "GX", "UX", "U&"]
          }],
          identTypes: ['""'],
          positionalParams: true,
          namedParamTypes: [":"],
          paramChars: {
            first: "@#$",
            rest: "@#$"
          },
          operators: P.operators
        });
      }
    }]), P;
  }(i.default);
  t.default = Y, F(Y, "operators", ["**", "=", ">", "<", "!>", "!<", "||"]), e.exports = t.default;
})(Yl, Yl.exports);
var w_ = Yl.exports;
var Fl = { exports: {} };
(function(e, t) {
  function r(E) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(E);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function o(E) {
    return p(E) || f(E) || c(E) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(E, m) {
    if (E) {
      if (typeof E == "string")
        return O(E, m);
      var P = Object.prototype.toString.call(E).slice(8, -1);
      if (P === "Object" && E.constructor && (P = E.constructor.name), P === "Map" || P === "Set")
        return Array.from(E);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return O(E, m);
    }
  }
  function f(E) {
    if (typeof Symbol < "u" && E[Symbol.iterator] != null || E["@@iterator"] != null)
      return Array.from(E);
  }
  function p(E) {
    if (Array.isArray(E))
      return O(E);
  }
  function O(E, m) {
    (m == null || m > E.length) && (m = E.length);
    for (var P = 0, R = new Array(m); P < m; P++)
      R[P] = E[P];
    return R;
  }
  function d2(E, m) {
    if (!(E instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(E, m) {
    for (var P = 0; P < m.length; P++) {
      var R = m[P];
      R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(E, R.key, R);
    }
  }
  function L(E, m, P) {
    return m && g(E.prototype, m), P && g(E, P), Object.defineProperty(E, "prototype", { writable: false }), E;
  }
  function D(E, m) {
    if (typeof m != "function" && m !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(m && m.prototype, { constructor: { value: E, writable: true, configurable: true } }), Object.defineProperty(E, "prototype", { writable: false }), m && W(E, m);
  }
  function W(E, m) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, A) {
      return R.__proto__ = A, R;
    }, W(E, m);
  }
  function x(E) {
    var m = $();
    return function() {
      var R = z(E), A;
      if (m) {
        var y2 = z(this).constructor;
        A = Reflect.construct(R, arguments, y2);
      } else
        A = R.apply(this, arguments);
      return V(this, A);
    };
  }
  function V(E, m) {
    if (m && (r(m) === "object" || typeof m == "function"))
      return m;
    if (m !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(E);
  }
  function _2(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(E) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
      return P.__proto__ || Object.getPrototypeOf(P);
    }, z(E);
  }
  function F(E, m, P) {
    return m in E ? Object.defineProperty(E, m, { value: P, enumerable: true, configurable: true, writable: true }) : E[m] = P, E;
  }
  var ae = {
    math: [
      "ABS",
      "ACOS",
      "ASIN",
      "ATAN",
      "BIN",
      "BROUND",
      "CBRT",
      "CEIL",
      "CEILING",
      "CONV",
      "COS",
      "DEGREES",
      // 'E',
      "EXP",
      "FACTORIAL",
      "FLOOR",
      "GREATEST",
      "HEX",
      "LEAST",
      "LN",
      "LOG",
      "LOG10",
      "LOG2",
      "NEGATIVE",
      "PI",
      "PMOD",
      "POSITIVE",
      "POW",
      "POWER",
      "RADIANS",
      "RAND",
      "ROUND",
      "SHIFTLEFT",
      "SHIFTRIGHT",
      "SHIFTRIGHTUNSIGNED",
      "SIGN",
      "SIN",
      "SQRT",
      "TAN",
      "UNHEX",
      "WIDTH_BUCKET"
    ],
    array: ["ARRAY_CONTAINS", "MAP_KEYS", "MAP_VALUES", "SIZE", "SORT_ARRAY"],
    conversion: ["BINARY", "CAST"],
    date: ["ADD_MONTHS", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "QUARTER", "SECOND", "TIMESTAMP", "TO_DATE", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_TIMESTAMP", "WEEKOFYEAR", "YEAR"],
    conditional: ["ASSERT_TRUE", "COALESCE", "IF", "ISNOTNULL", "ISNULL", "NULLIF", "NVL"],
    string: ["ASCII", "BASE64", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "CONTEXT_NGRAMS", "DECODE", "ELT", "ENCODE", "FIELD", "FIND_IN_SET", "FORMAT_NUMBER", "GET_JSON_OBJECT", "IN_FILE", "INITCAP", "INSTR", "LCASE", "LENGTH", "LEVENSHTEIN", "LOCATE", "LOWER", "LPAD", "LTRIM", "NGRAMS", "OCTET_LENGTH", "PARSE_URL", "PRINTF", "QUOTE", "REGEXP_EXTRACT", "REGEXP_REPLACE", "REPEAT", "REVERSE", "RPAD", "RTRIM", "SENTENCES", "SOUNDEX", "SPACE", "SPLIT", "STR_TO_MAP", "SUBSTR", "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UNBASE64", "UPPER"],
    masking: ["MASK", "MASK_FIRST_N", "MASK_HASH", "MASK_LAST_N", "MASK_SHOW_FIRST_N", "MASK_SHOW_LAST_N"],
    misc: ["AES_DECRYPT", "AES_ENCRYPT", "CRC32", "CURRENT_DATABASE", "CURRENT_USER", "HASH", "JAVA_METHOD", "LOGGED_IN_USER", "MD5", "REFLECT", "SHA", "SHA1", "SHA2", "SURROGATE_KEY", "VERSION"],
    aggregate: ["AVG", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "HISTOGRAM_NUMERIC", "MAX", "MIN", "NTILE", "PERCENTILE", "PERCENTILE_APPROX", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
    table: ["EXPLODE", "INLINE", "JSON_TUPLE", "PARSE_URL_TUPLE", "POSEXPLODE", "STACK"]
  }, U = {
    // Non-reserved keywords have proscribed meanings in. HiveQL, but can still be used as table or column names
    nonReserved: [
      "ADD",
      "ADMIN",
      "AFTER",
      "ANALYZE",
      "ARCHIVE",
      "ASC",
      "BEFORE",
      "BUCKET",
      "BUCKETS",
      "CASCADE",
      "CHANGE",
      "CLUSTER",
      "CLUSTERED",
      "CLUSTERSTATUS",
      "COLLECTION",
      "COLUMNS",
      "COMMENT",
      "COMPACT",
      "COMPACTIONS",
      "COMPUTE",
      "CONCATENATE",
      "CONTINUE",
      "DATA",
      "DATABASES",
      "DATETIME",
      "DAY",
      "DBPROPERTIES",
      "DEFERRED",
      "DEFINED",
      "DELIMITED",
      "DEPENDENCY",
      "DESC",
      "DIRECTORIES",
      "DIRECTORY",
      "DISABLE",
      "DISTRIBUTE",
      "ELEM_TYPE",
      "ENABLE",
      "ESCAPED",
      "EXCLUSIVE",
      "EXPLAIN",
      "EXPORT",
      "FIELDS",
      "FILE",
      "FILEFORMAT",
      "FIRST",
      "FORMAT",
      "FORMATTED",
      "FUNCTIONS",
      "HOLD_DDLTIME",
      "HOUR",
      "IDXPROPERTIES",
      "IGNORE",
      "INDEX",
      "INDEXES",
      "INPATH",
      "INPUTDRIVER",
      "INPUTFORMAT",
      "ITEMS",
      "JAR",
      "KEYS",
      "KEY_TYPE",
      "LIMIT",
      "LINES",
      "LOAD",
      "LOCATION",
      "LOCK",
      "LOCKS",
      "LOGICAL",
      "LONG",
      "MAPJOIN",
      "MATERIALIZED",
      "METADATA",
      "MINUS",
      "MINUTE",
      "MONTH",
      "MSCK",
      "NOSCAN",
      "NO_DROP",
      "OFFLINE",
      "OPTION",
      "OUTPUTDRIVER",
      "OUTPUTFORMAT",
      "OVERWRITE",
      "OWNER",
      "PARTITIONED",
      "PARTITIONS",
      "PLUS",
      "PRETTY",
      "PRINCIPALS",
      "PROTECTION",
      "PURGE",
      "READ",
      "READONLY",
      "REBUILD",
      "RECORDREADER",
      "RECORDWRITER",
      "RELOAD",
      "RENAME",
      "REPAIR",
      "REPLACE",
      "REPLICATION",
      "RESTRICT",
      "REWRITE",
      "ROLE",
      "ROLES",
      "SCHEMA",
      "SCHEMAS",
      "SECOND",
      "SEMI",
      "SERDE",
      "SERDEPROPERTIES",
      "SERVER",
      "SETS",
      "SHARED",
      "SHOW",
      "SHOW_DATABASE",
      "SKEWED",
      "SORT",
      "SORTED",
      "SSL",
      "STATISTICS",
      "STORED",
      "STREAMTABLE",
      "STRING",
      "STRUCT",
      "TABLES",
      "TBLPROPERTIES",
      "TEMPORARY",
      "TERMINATED",
      "TINYINT",
      "TOUCH",
      "TRANSACTIONS",
      "UNARCHIVE",
      "UNDO",
      "UNIONTYPE",
      "UNLOCK",
      "UNSET",
      "UNSIGNED",
      "URI",
      // 'USE',
      "UTC",
      "UTCTIMESTAMP",
      "VALUE_TYPE",
      "VIEW",
      "WHILE",
      "YEAR",
      "AUTOCOMMIT",
      "ISOLATION",
      "LEVEL",
      "OFFSET",
      "SNAPSHOT",
      "TRANSACTION",
      "WORK",
      "WRITE",
      "ABORT",
      "KEY",
      "LAST",
      "NORELY",
      "NOVALIDATE",
      "NULLS",
      "RELY",
      "VALIDATE",
      "DETAIL",
      "DOW",
      "EXPRESSION",
      "OPERATOR",
      "QUARTER",
      "SUMMARY",
      "VECTORIZATION",
      "WEEK",
      "YEARS",
      "MONTHS",
      "WEEKS",
      "DAYS",
      "HOURS",
      "MINUTES",
      "SECONDS",
      "TIMESTAMPTZ",
      "ZONE"
    ],
    reserved: [
      // reserved
      "ALL",
      // 'ALTER',
      // 'AND',
      "ARRAY",
      "AS",
      "AUTHORIZATION",
      "BETWEEN",
      "BIGINT",
      "BINARY",
      "BOOLEAN",
      "BOTH",
      "BY",
      // 'CASE',
      "CAST",
      "CHAR",
      "COLUMN",
      "CONF",
      // 'CREATE',
      "CROSS",
      "CUBE",
      "CURRENT",
      "CURRENT_DATE",
      "CURRENT_TIMESTAMP",
      "CURSOR",
      "DATABASE",
      "DATE",
      "DECIMAL",
      "DELETE",
      // 'DESCRIBE',
      "DISTINCT",
      "DOUBLE",
      // 'DROP',
      // 'ELSE',
      // 'END',
      "EXCHANGE",
      "EXISTS",
      "EXTENDED",
      "EXTERNAL",
      "FALSE",
      // 'FETCH',
      "FLOAT",
      "FOLLOWING",
      "FOR",
      // 'FROM',
      "FULL",
      "FUNCTION",
      "GRANT",
      // 'GROUP',
      "GROUPING",
      // 'HAVING',
      "IF",
      "IMPORT",
      "IN",
      "INNER",
      // 'INSERT',
      "INT",
      // 'INTERSECT',
      "INTERVAL",
      "INTO",
      "IS",
      // 'JOIN',
      "LATERAL",
      "LEFT",
      "LESS",
      "LIKE",
      "LOCAL",
      "MACRO",
      "MAP",
      "MORE",
      "NONE",
      "NOT",
      "NULL",
      "OF",
      // 'ON',
      // 'OR',
      "ORDER",
      "OUT",
      "OUTER",
      "OVER",
      "PARTIALSCAN",
      "PARTITION",
      "PERCENT",
      "PRECEDING",
      "PRESERVE",
      "PROCEDURE",
      "RANGE",
      "READS",
      "REDUCE",
      "REVOKE",
      "RIGHT",
      "ROLLUP",
      "ROW",
      "ROWS",
      // 'SELECT',
      "SET",
      "SMALLINT",
      "TABLE",
      "TABLESAMPLE",
      "THEN",
      "TIMESTAMP",
      "TO",
      "TRANSFORM",
      "TRIGGER",
      "TRUE",
      // 'TRUNCATE',
      "UNBOUNDED",
      // 'UNION',
      "UNIQUEJOIN",
      // 'UPDATE',
      "USER",
      "UTC_TMESTAMP",
      // 'VALUES',
      "VARCHAR",
      // 'WHEN',
      // 'WHERE',
      "WINDOW",
      // 'WITH',
      "COMMIT",
      "ONLY",
      "REGEXP",
      "RLIKE",
      "ROLLBACK",
      "START",
      "CACHE",
      "CONSTRAINT",
      "FOREIGN",
      "PRIMARY",
      "REFERENCES",
      "DAYOFWEEK",
      "EXTRACT",
      "FLOOR",
      "INTEGER",
      "PRECISION",
      "VIEWS",
      "TIME",
      "NUMERIC",
      "SYNC"
    ],
    fileTypes: ["TEXTFILE", "SEQUENCEFILE", "ORC", "CSV", "TSV", "PARQUET", "AVRO", "RCFILE", "JSONFILE", "INPUTFORMAT", "OUTPUTFORMAT"]
  }, G = [
    // commands
    "ALTER",
    "ALTER COLUMN",
    // added
    "ALTER TABLE",
    // added
    "CREATE",
    "CREATE TABLE",
    // added
    "USE",
    "DESCRIBE",
    "DROP",
    "DROP TABLE",
    // added
    "FETCH",
    "FROM",
    "GROUP BY",
    "HAVING",
    "INSERT",
    "INSERT INTO",
    // added
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "SELECT",
    "SET",
    "SET SCHEMA",
    // added
    "SHOW",
    "SORT BY",
    "TRUNCATE",
    "UPDATE",
    "VALUES",
    "WHERE",
    "WITH",
    "WINDOW",
    "PARTITION BY",
    // newline keywords
    "STORED AS",
    "STORED BY",
    "ROW FORMAT"
  ], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT"], re = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN"], B = ["WHEN", "ELSE"], Y = function(E) {
    D(P, E);
    var m = x(P);
    function P() {
      return d2(this, P), m.apply(this, arguments);
    }
    return L(P, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: G,
          reservedBinaryCommands: H,
          reservedJoins: re,
          reservedDependentClauses: B,
          reservedKeywords: (0, a.dedupe)([].concat(o(Object.values(ae).flat()), o(Object.values(U).flat()))),
          openParens: ["(", "["],
          closeParens: [")", "]"],
          stringTypes: ['""', "''"],
          identTypes: ["``"],
          variableTypes: [{
            quote: "{}",
            prefixes: ["$"],
            requirePrefix: true
          }],
          operators: P.operators
        });
      }
    }]), P;
  }(i.default);
  t.default = Y, F(Y, "operators", ["<=>", "==", "||"]), e.exports = t.default;
})(Fl, Fl.exports);
var M_ = Fl.exports;
var Wl = { exports: {} };
(function(e, t) {
  function r(B) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
      return typeof Y;
    } : function(Y) {
      return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y;
    }, r(B);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = o(ur), n = o(cr), a = it, s = Xe;
  function o(B) {
    return B && B.__esModule ? B : { default: B };
  }
  function l(B, Y) {
    var E = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(B);
      Y && (m = m.filter(function(P) {
        return Object.getOwnPropertyDescriptor(B, P).enumerable;
      })), E.push.apply(E, m);
    }
    return E;
  }
  function c(B) {
    for (var Y = 1; Y < arguments.length; Y++) {
      var E = arguments[Y] != null ? arguments[Y] : {};
      Y % 2 ? l(Object(E), true).forEach(function(m) {
        _2(B, m, E[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(E)) : l(Object(E)).forEach(function(m) {
        Object.defineProperty(B, m, Object.getOwnPropertyDescriptor(E, m));
      });
    }
    return B;
  }
  function f(B, Y) {
    if (!(B instanceof Y))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(B, Y) {
    for (var E = 0; E < Y.length; E++) {
      var m = Y[E];
      m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(B, m.key, m);
    }
  }
  function O(B, Y, E) {
    return Y && p(B.prototype, Y), E && p(B, E), Object.defineProperty(B, "prototype", { writable: false }), B;
  }
  function d2(B, Y) {
    if (typeof Y != "function" && Y !== null)
      throw new TypeError("Super expression must either be null or a function");
    B.prototype = Object.create(Y && Y.prototype, { constructor: { value: B, writable: true, configurable: true } }), Object.defineProperty(B, "prototype", { writable: false }), Y && g(B, Y);
  }
  function g(B, Y) {
    return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, P) {
      return m.__proto__ = P, m;
    }, g(B, Y);
  }
  function L(B) {
    var Y = x();
    return function() {
      var m = V(B), P;
      if (Y) {
        var R = V(this).constructor;
        P = Reflect.construct(m, arguments, R);
      } else
        P = m.apply(this, arguments);
      return D(this, P);
    };
  }
  function D(B, Y) {
    if (Y && (r(Y) === "object" || typeof Y == "function"))
      return Y;
    if (Y !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return W(B);
  }
  function W(B) {
    if (B === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return B;
  }
  function x() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function V(B) {
    return V = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(E) {
      return E.__proto__ || Object.getPrototypeOf(E);
    }, V(B);
  }
  function _2(B, Y, E) {
    return Y in B ? Object.defineProperty(B, Y, { value: E, enumerable: true, configurable: true, writable: true }) : B[Y] = E, B;
  }
  var $ = ["ADDDATE", "ADD_MONTHS", "BIT_AND", "BIT_OR", "BIT_XOR", "CAST", "COUNT", "CUME_DIST", "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", "DATE_FORMAT", "DECODE", "DENSE_RANK", "EXTRACT", "FIRST_VALUE", "GROUP_CONCAT", "JSON_ARRAYAGG", "JSON_OBJECTAGG", "LAG", "LEAD", "MAX", "MEDIAN", "MID", "MIN", "NOW", "NTH_VALUE", "NTILE", "POSITION", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "ROW_NUMBER", "SESSION_USER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUBDATE", "SUBSTR", "SUBSTRING", "SUM", "SYSTEM_USER", "TRIM", "TRIM_ORACLE", "VARIANCE", "VAR_POP", "VAR_SAMP", "ABS", "ACOS", "ADDTIME", "AES_DECRYPT", "AES_ENCRYPT", "ASIN", "ATAN", "ATAN2", "BENCHMARK", "BIN", "BINLOG_GTID_POS", "BIT_COUNT", "BIT_LENGTH", "CEIL", "CEILING", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "COERCIBILITY", "COLUMN_CHECK", "COLUMN_EXISTS", "COLUMN_LIST", "COLUMN_JSON", "COMPRESS", "CONCAT", "CONCAT_OPERATOR_ORACLE", "CONCAT_WS", "CONNECTION_ID", "CONV", "CONVERT_TZ", "COS", "COT", "CRC32", "DATEDIFF", "DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DEGREES", "DECODE_HISTOGRAM", "DECODE_ORACLE", "DES_DECRYPT", "DES_ENCRYPT", "ELT", "ENCODE", "ENCRYPT", "EXP", "EXPORT_SET", "EXTRACTVALUE", "FIELD", "FIND_IN_SET", "FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", "GET_LOCK", "GREATEST", "HEX", "IFNULL", "INSTR", "ISNULL", "IS_FREE_LOCK", "IS_USED_LOCK", "JSON_ARRAY", "JSON_ARRAY_APPEND", "JSON_ARRAY_INSERT", "JSON_COMPACT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", "JSON_DETAILED", "JSON_EXISTS", "JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_LOOSE", "JSON_MERGE", "JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_QUERY", "JSON_QUOTE", "JSON_OBJECT", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_SEARCH", "JSON_TYPE", "JSON_UNQUOTE", "JSON_VALID", "JSON_VALUE", "LAST_DAY", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", "LENGTHB", "LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LPAD_ORACLE", "LTRIM", "LTRIM_ORACLE", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_GTID_WAIT", "MASTER_POS_WAIT", "MD5", "MONTHNAME", "NAME_CONST", "NVL", "NVL2", "NULLIF", "OCT", "OCTET_LENGTH", "ORD", "PERIOD_ADD", "PERIOD_DIFF", "PI", "POW", "POWER", "QUOTE", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "RADIANS", "RAND", "RELEASE_ALL_LOCKS", "RELEASE_LOCK", "REPLACE_ORACLE", "REVERSE", "ROUND", "RPAD", "RPAD_ORACLE", "RTRIM", "RTRIM_ORACLE", "SEC_TO_TIME", "SHA", "SHA1", "SHA2", "SIGN", "SIN", "SLEEP", "SOUNDEX", "SPACE", "SQRT", "STRCMP", "STR_TO_DATE", "SUBSTR_ORACLE", "SUBSTRING_INDEX", "SUBTIME", "SYS_GUID", "TAN", "TIMEDIFF", "TIME_FORMAT", "TIME_TO_SEC", "TO_BASE64", "TO_CHAR", "TO_DAYS", "TO_SECONDS", "UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", "UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VERSION", "WEEKDAY", "WEEKOFYEAR", "WSREP_LAST_WRITTEN_GTID", "WSREP_LAST_SEEN_GTID", "WSREP_SYNC_WAIT_UPTO_GTID", "YEARWEEK"], z = [
    "ACCESSIBLE",
    "ACCOUNT",
    "ACTION",
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALL",
    "ALGORITHM",
    "ALTER",
    "ALWAYS",
    "ANY",
    "AS",
    "ASC",
    "ASCII",
    "ASENSITIVE",
    "AT",
    "ATOMIC",
    "AUTHORS",
    "AUTO_INCREMENT",
    "AUTOEXTEND_SIZE",
    "AUTO",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BIT",
    "BLOB",
    "BLOCK",
    "BODY",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    "BTREE",
    "BY",
    "BYTE",
    "CACHE",
    "CASCADE",
    "CASCADED",
    "CATALOG_NAME",
    "CHAIN",
    "CHANGE",
    "CHANGED",
    "CHAR",
    "CHARACTER",
    "CHARACTER SET",
    "CHARSET",
    "CHECK",
    "CHECKPOINT",
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    "COLLATION",
    "COLUMN",
    "COLUMN_NAME",
    "COLUMNS",
    "COLUMN_ADD",
    "COLUMN_CREATE",
    "COLUMN_DELETE",
    "COLUMN_GET",
    "COMMENT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPRESSED",
    "CONCURRENT",
    "CONDITION",
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    "CONTRIBUTORS",
    "CONVERT",
    "CPU",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_POS",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURSOR",
    "CURSOR_NAME",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    "DAY_MICROSECOND",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINER",
    "DELAYED",
    "DELAY_KEY_WRITE",
    "DELETE_DOMAIN_ID",
    "DES_KEY_FILE",
    "DESC",
    "DETERMINISTIC",
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    "DISTINCTROW",
    "DIV",
    "DOUBLE",
    "DO_DOMAIN_IDS",
    "DROP",
    "DUAL",
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    "EMPTY",
    "ENABLE",
    "ENCLOSED",
    "ENDS",
    "ENGINE",
    "ENGINES",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXAMINED",
    "EXCHANGE",
    "EXCLUDE",
    "EXCEPTION",
    "EXISTS",
    "EXIT",
    "EXPANSION",
    "EXPIRE",
    "EXPORT",
    "EXTENDED",
    "EXTENT_SIZE",
    "FALSE",
    "FAST",
    "FAULTS",
    "FEDERATED",
    "FETCH",
    "FIELDS",
    "FILE",
    "FIRST",
    "FIXED",
    "FLOAT",
    "FLOAT4",
    "FLOAT8",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FOUND",
    "FULL",
    "FULLTEXT",
    "FUNCTION",
    "GENERAL",
    "GENERATED",
    "GET_FORMAT",
    "GET",
    "GLOBAL",
    "GOTO",
    "GRANTS",
    "GROUP",
    "HARD",
    "HASH",
    "HIGH_PRIORITY",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    // 'ID',
    "IDENTIFIED",
    "IF",
    "IGNORE",
    "IGNORED",
    "IGNORE_DOMAIN_IDS",
    "IGNORE_SERVER_IDS",
    "IMMEDIATE",
    "IMPORT",
    "IN",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INFILE",
    "INITIAL_SIZE",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT_METHOD",
    "INSTALL",
    "INT",
    "INT1",
    "INT2",
    "INT3",
    "INT4",
    "INT8",
    "INTEGER",
    "INTERVAL",
    "INVISIBLE",
    "INTO",
    "IO",
    "IO_THREAD",
    "IPC",
    "IS",
    "ISOLATION",
    "ISOPEN",
    "ISSUER",
    "ITERATE",
    "INVOKER",
    "JSON",
    "JSON_TABLE",
    "KEY",
    "KEYS",
    "KEY_BLOCK_SIZE",
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    "LASTVAL",
    "LEADING",
    "LEAVE",
    "LEAVES",
    "LEFT",
    "LESS",
    "LEVEL",
    "LIKE",
    "LINEAR",
    "LINES",
    "LIST",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCK",
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    "LONGBLOB",
    "LONGTEXT",
    "LOOP",
    "LOW_PRIORITY",
    "MASTER",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_GTID_POS",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_SERVER_ID",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    "MASTER_USER",
    "MASTER_USE_GTID",
    "MASTER_HEARTBEAT_PERIOD",
    "MATCH",
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_STATEMENT_TIME",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MAXVALUE",
    "MEDIUM",
    "MEDIUMBLOB",
    "MEDIUMINT",
    "MEDIUMTEXT",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    "MIGRATE",
    "MINUS",
    "MINUTE",
    "MINUTE_MICROSECOND",
    "MINUTE_SECOND",
    "MINVALUE",
    "MIN_ROWS",
    "MOD",
    "MODE",
    "MODIFIES",
    "MODIFY",
    "MONITOR",
    "MONTH",
    "MUTEX",
    "MYSQL",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NESTED",
    "NEVER",
    "NEW",
    "NEXT",
    "NEXTVAL",
    "NO",
    "NOMAXVALUE",
    "NOMINVALUE",
    "NOCACHE",
    "NOCYCLE",
    "NO_WAIT",
    "NOWAIT",
    "NODEGROUP",
    "NONE",
    "NOT",
    "NOTFOUND",
    "NO_WRITE_TO_BINLOG",
    "NULL",
    "NUMBER",
    "NUMERIC",
    "NVARCHAR",
    "OF",
    "OFFSET",
    "OLD_PASSWORD",
    "ON DELETE",
    "ON UPDATE",
    "ONE",
    "ONLINE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    "OPTIONS",
    "OPTION",
    "OPTIONALLY",
    "ORDER",
    "ORDINALITY",
    "OTHERS",
    "OUT",
    "OUTER",
    "OUTFILE",
    "OVER",
    "OVERLAPS",
    "OWNER",
    "PACKAGE",
    "PACK_KEYS",
    "PAGE",
    "PAGE_CHECKSUM",
    "PARSER",
    "PARSE_VCOL_EXPR",
    "PATH",
    "PERIOD",
    "PARTIAL",
    "PARTITION",
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PERSISTENT",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PORT",
    "PORTION",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    "PRESERVE",
    "PREV",
    "PREVIOUS",
    "PRIMARY",
    "PRIVILEGES",
    "PROCEDURE",
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    "QUARTER",
    "QUERY",
    "QUICK",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "READ_ONLY",
    "READ_WRITE",
    "READS",
    "REAL",
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    "REDO_BUFFER_SIZE",
    "REDOFILE",
    "REDUNDANT",
    "REFERENCES",
    "REGEXP",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    "RELOAD",
    "REMOVE",
    "RENAME",
    "REORGANIZE",
    "REPAIR",
    "REPEATABLE",
    "REPLAY",
    "REPLICA",
    "REPLICAS",
    "REPLICA_POS",
    "REPLICATION",
    "REPEAT",
    "REQUIRE",
    "RESET",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    "RESUME",
    "RETURNED_SQLSTATE",
    "RETURN",
    "RETURNS",
    "REUSE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLLUP",
    "ROUTINE",
    "ROW",
    "ROWCOUNT",
    "ROWNUM",
    "ROWS",
    "ROWTYPE",
    "ROW_COUNT",
    "ROW_FORMAT",
    "RTREE",
    "SCHEDULE",
    "SCHEMA",
    "SCHEMA_NAME",
    "SCHEMAS",
    "SECOND",
    "SECOND_MICROSECOND",
    "SECURITY",
    "SENSITIVE",
    "SEPARATOR",
    "SEQUENCE",
    "SERIAL",
    "SERIALIZABLE",
    "SESSION",
    "SERVER",
    "SETVAL",
    "SHARE",
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLAVES",
    "SLAVE_POS",
    "SLOW",
    "SNAPSHOT",
    "SMALLINT",
    "SOCKET",
    "SOFT",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "STAGE",
    "STORED",
    "SPATIAL",
    "SPECIFIC",
    "REF_SYSTEM_ID",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "SQL_BIG_RESULT",
    "SQL_BUFFER_RESULT",
    "SQL_CACHE",
    "SQL_CALC_FOUND_ROWS",
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    "SQL_THREAD",
    "SQL_TSI_SECOND",
    "SQL_TSI_MINUTE",
    "SQL_TSI_HOUR",
    "SQL_TSI_DAY",
    "SQL_TSI_WEEK",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_YEAR",
    "SSL",
    "START",
    "STARTING",
    "STARTS",
    "STATEMENT",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSDATE",
    "SYSTEM",
    "SYSTEM_TIME",
    "TABLE",
    "TABLE_NAME",
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    "TEXT",
    "THAN",
    "THEN",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    "TINYINT",
    "TINYTEXT",
    "TO",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONAL",
    "THREADS",
    "TRIGGER",
    "TRIGGERS",
    "TRUE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO_BUFFER_SIZE",
    "UNDOFILE",
    "UNDO",
    "UNICODE",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNINSTALL",
    "UNSIGNED",
    "UNTIL",
    "UPGRADE",
    "USAGE",
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "VALUE",
    "VARBINARY",
    "VARCHAR",
    "VARCHARACTER",
    "VARCHAR2",
    "VARIABLES",
    "VARYING",
    "VIA",
    "VIEW",
    "VIRTUAL",
    "VISIBLE",
    "VERSIONING",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHILE",
    "WINDOW",
    "WITHIN",
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    "X509",
    "XA",
    "XML",
    "YEAR",
    "YEAR_MONTH",
    "ZEROFILL"
  ], F = [
    "ALTER DATABASE",
    "ALTER DATABASE COMMENT",
    "ALTER EVENT",
    "ALTER FUNCTION",
    "ALTER PROCEDURE",
    "ALTER SCHEMA",
    "ALTER SCHEMA COMMENT",
    "ALTER SEQUENCE",
    "ALTER SERVER",
    "ALTER TABLE",
    "ALTER USER",
    "ALTER VIEW",
    "ANALYZE",
    "ANALYZE TABLE",
    "BACKUP LOCK",
    "BACKUP STAGE",
    "BACKUP UNLOCK",
    "BEGIN",
    "BINLOG",
    "CACHE INDEX",
    "CALL",
    "CHANGE MASTER TO",
    "CHECK TABLE",
    "CHECK VIEW",
    "CHECKSUM TABLE",
    "COMMIT",
    "CREATE AGGREGATE FUNCTION",
    "CREATE DATABASE",
    "CREATE EVENT",
    "CREATE FUNCTION",
    "CREATE INDEX",
    "CREATE PROCEDURE",
    "CREATE ROLE",
    "CREATE SEQUENCE",
    "CREATE SERVER",
    "CREATE SPATIAL INDEX",
    "CREATE TABLE",
    "CREATE TRIGGER",
    "CREATE UNIQUE INDEX",
    "CREATE USER",
    "CREATE VIEW",
    "DEALLOCATE PREPARE",
    "DELETE",
    "DELETE FROM",
    "DESCRIBE",
    "DO",
    "DROP DATABASE",
    "DROP EVENT",
    "DROP FUNCTION",
    "DROP INDEX",
    "DROP PREPARE",
    "DROP PROCEDURE",
    "DROP ROLE",
    "DROP SEQUENCE",
    "DROP SERVER",
    "DROP TABLE",
    "DROP TRIGGER",
    "DROP USER",
    "DROP VIEW",
    "EXECUTE",
    "EXPLAIN",
    "FLUSH",
    "GET DIAGNOSTICS",
    "GET DIAGNOSTICS CONDITION",
    "GRANT",
    "HANDLER",
    "HELP",
    "INSERT",
    "INSTALL PLUGIN",
    "INSTALL SONAME",
    "KILL",
    "LOAD DATA INFILE",
    "LOAD INDEX INTO CACHE",
    "LOAD XML INFILE",
    "LOCK TABLE",
    "OPTIMIZE TABLE",
    "PREPARE",
    "PURGE BINARY LOGS",
    "PURGE MASTER LOGS",
    "RELEASE SAVEPOINT",
    "RENAME TABLE",
    "RENAME USER",
    "REPAIR TABLE",
    "REPAIR VIEW",
    "REPLACE",
    "RESET MASTER",
    "RESET QUERY CACHE",
    "RESET REPLICA",
    "RESET SLAVE",
    "RESIGNAL",
    "RETURNING",
    "REVOKE",
    "ROLLBACK",
    "SAVEPOINT",
    "SELECT",
    "SET",
    "SET CHARACTER SET",
    "SET DEFAULT ROLE",
    "SET GLOBAL TRANSACTION",
    "SET NAMES",
    "SET PASSWORD",
    "SET ROLE",
    "SET STATEMENT",
    "SET TRANSACTION",
    "SHOW",
    "SHOW ALL REPLICAS STATUS",
    "SHOW ALL SLAVES STATUS",
    "SHOW AUTHORS",
    "SHOW BINARY LOGS",
    "SHOW BINLOG EVENTS",
    "SHOW BINLOG STATUS",
    "SHOW CHARACTER SET",
    "SHOW CLIENT_STATISTICS",
    "SHOW COLLATION",
    "SHOW COLUMNS",
    "SHOW CONTRIBUTORS",
    "SHOW CREATE DATABASE",
    "SHOW CREATE EVENT",
    "SHOW CREATE FUNCTION",
    "SHOW CREATE PACKAGE",
    "SHOW CREATE PACKAGE BODY",
    "SHOW CREATE PROCEDURE",
    "SHOW CREATE SEQUENCE",
    "SHOW CREATE TABLE",
    "SHOW CREATE TRIGGER",
    "SHOW CREATE USER",
    "SHOW CREATE VIEW",
    "SHOW DATABASES",
    "SHOW ENGINE",
    "SHOW ENGINE INNODB STATUS",
    "SHOW ENGINES",
    "SHOW ERRORS",
    "SHOW EVENTS",
    "SHOW EXPLAIN",
    "SHOW FUNCTION CODE",
    "SHOW FUNCTION STATUS",
    "SHOW GRANTS",
    "SHOW INDEX",
    "SHOW INDEXES",
    "SHOW INDEX_STATISTICS",
    "SHOW KEYS",
    "SHOW LOCALES",
    "SHOW MASTER LOGS",
    "SHOW MASTER STATUS",
    "SHOW OPEN TABLES",
    "SHOW PACKAGE BODY CODE",
    "SHOW PACKAGE BODY STATUS",
    "SHOW PACKAGE STATUS",
    "SHOW PLUGINS",
    "SHOW PLUGINS SONAME",
    "SHOW PRIVILEGES",
    "SHOW PROCEDURE CODE",
    "SHOW PROCEDURE STATUS",
    "SHOW PROCESSLIST",
    "SHOW PROFILE",
    "SHOW PROFILES",
    "SHOW QUERY_RESPONSE_TIME",
    "SHOW RELAYLOG EVENTS",
    "SHOW REPLICA",
    "SHOW REPLICA HOSTS",
    "SHOW REPLICA STATUS",
    "SHOW SCHEMAS",
    "SHOW SLAVE",
    "SHOW SLAVE HOSTS",
    "SHOW SLAVE STATUS",
    "SHOW STATUS",
    "SHOW STORAGE ENGINES",
    "SHOW TABLE STATUS",
    "SHOW TABLES",
    "SHOW TRIGGERS",
    "SHOW USER_STATISTICS",
    "SHOW VARIABLES",
    "SHOW WARNINGS",
    "SHOW WSREP_MEMBERSHIP",
    "SHOW WSREP_STATUS",
    "SHUTDOWN",
    "SIGNAL",
    "START ALL REPLICAS",
    "START ALL SLAVES",
    "START REPLICA",
    "START SLAVE",
    "START TRANSACTION",
    "STOP ALL REPLICAS",
    "STOP ALL SLAVES",
    "STOP REPLICA",
    "STOP SLAVE",
    "TRUNCATE",
    "TRUNCATE TABLE",
    "UNINSTALL PLUGIN",
    "UNINSTALL SONAME",
    "UNLOCK TABLE",
    "UPDATE",
    "USE",
    "WITH",
    "XA BEGIN",
    "XA COMMIT",
    "XA END",
    "XA PREPARE",
    "XA RECOVER",
    "XA ROLLBACK",
    "XA START",
    // other
    "ADD",
    "ALTER COLUMN",
    "FROM",
    "GROUP BY",
    "HAVING",
    "INSERT INTO",
    "INSERT",
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "SELECT",
    "VALUES",
    "WHERE"
  ], ae = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT", "MINUS", "MINUS ALL", "MINUS DISTINCT"], U = [
    "JOIN",
    "INNER JOIN",
    "LEFT JOIN",
    "LEFT OUTER JOIN",
    "RIGHT JOIN",
    "RIGHT OUTER JOIN",
    "CROSS JOIN",
    "NATURAL JOIN",
    // non-standard joins
    "STRAIGHT_JOIN",
    "NATURAL LEFT JOIN",
    "NATURAL LEFT OUTER JOIN",
    "NATURAL RIGHT JOIN",
    "NATURAL RIGHT OUTER JOIN"
  ], G = ["WHEN", "ELSE", "ELSEIF", "ELSIF"], H = function(B) {
    d2(E, B);
    var Y = L(E);
    function E() {
      return f(this, E), Y.apply(this, arguments);
    }
    return O(E, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: F,
          reservedBinaryCommands: ae,
          reservedJoins: U,
          reservedDependentClauses: G,
          reservedLogicalOperators: ["AND", "OR", "XOR"],
          reservedKeywords: (0, s.dedupe)([].concat(z, $)),
          stringTypes: ['""', {
            quote: "''",
            prefixes: ["X"]
          }],
          identTypes: ["``"],
          identChars: {
            first: "$",
            rest: "$"
          },
          variableTypes: [{
            regex: "@[A-Za-z0-9_.$]+"
          }, {
            quote: '""',
            prefixes: ["@"],
            requirePrefix: true
          }, {
            quote: "''",
            prefixes: ["@"],
            requirePrefix: true
          }, {
            quote: "``",
            prefixes: ["@"],
            requirePrefix: true
          }],
          positionalParams: true,
          lineCommentTypes: ["--", "#"],
          operators: E.operators,
          postProcess: re
        });
      }
    }]), E;
  }(i.default);
  t.default = H, _2(H, "operators", [":=", "<<", ">>", "<=>", "&&", "||"]);
  function re(B) {
    return B.map(function(Y, E) {
      var m = B[E + 1] || a.EOF_TOKEN;
      return a.isToken.SET(Y) && m.value === "(" ? c(c({}, Y), {}, {
        type: a.TokenType.RESERVED_KEYWORD
      }) : Y;
    });
  }
  e.exports = t.default;
})(Wl, Wl.exports);
var k_ = Wl.exports;
var Xl = { exports: {} };
(function(e, t) {
  function r(B) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
      return typeof Y;
    } : function(Y) {
      return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y;
    }, r(B);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = o(ur), n = o(cr), a = it, s = Xe;
  function o(B) {
    return B && B.__esModule ? B : { default: B };
  }
  function l(B, Y) {
    var E = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(B);
      Y && (m = m.filter(function(P) {
        return Object.getOwnPropertyDescriptor(B, P).enumerable;
      })), E.push.apply(E, m);
    }
    return E;
  }
  function c(B) {
    for (var Y = 1; Y < arguments.length; Y++) {
      var E = arguments[Y] != null ? arguments[Y] : {};
      Y % 2 ? l(Object(E), true).forEach(function(m) {
        _2(B, m, E[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(E)) : l(Object(E)).forEach(function(m) {
        Object.defineProperty(B, m, Object.getOwnPropertyDescriptor(E, m));
      });
    }
    return B;
  }
  function f(B, Y) {
    if (!(B instanceof Y))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(B, Y) {
    for (var E = 0; E < Y.length; E++) {
      var m = Y[E];
      m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(B, m.key, m);
    }
  }
  function O(B, Y, E) {
    return Y && p(B.prototype, Y), E && p(B, E), Object.defineProperty(B, "prototype", { writable: false }), B;
  }
  function d2(B, Y) {
    if (typeof Y != "function" && Y !== null)
      throw new TypeError("Super expression must either be null or a function");
    B.prototype = Object.create(Y && Y.prototype, { constructor: { value: B, writable: true, configurable: true } }), Object.defineProperty(B, "prototype", { writable: false }), Y && g(B, Y);
  }
  function g(B, Y) {
    return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, P) {
      return m.__proto__ = P, m;
    }, g(B, Y);
  }
  function L(B) {
    var Y = x();
    return function() {
      var m = V(B), P;
      if (Y) {
        var R = V(this).constructor;
        P = Reflect.construct(m, arguments, R);
      } else
        P = m.apply(this, arguments);
      return D(this, P);
    };
  }
  function D(B, Y) {
    if (Y && (r(Y) === "object" || typeof Y == "function"))
      return Y;
    if (Y !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return W(B);
  }
  function W(B) {
    if (B === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return B;
  }
  function x() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function V(B) {
    return V = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(E) {
      return E.__proto__ || Object.getPrototypeOf(E);
    }, V(B);
  }
  function _2(B, Y, E) {
    return Y in B ? Object.defineProperty(B, Y, { value: E, enumerable: true, configurable: true, writable: true }) : B[Y] = E, B;
  }
  var $ = [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    // 'AND',
    "ANY_VALUE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BENCHMARK",
    "BIN",
    "BIN_TO_UUID",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_LENGTH",
    "BIT_OR",
    "BIT_XOR",
    "CAN_ACCESS_COLUMN",
    "CAN_ACCESS_DATABASE",
    "CAN_ACCESS_TABLE",
    "CAN_ACCESS_USER",
    "CAN_ACCESS_VIEW",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COMPRESS",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CRC32",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATEDIFF",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "ELT",
    "EXP",
    "EXPORT_SET",
    "EXTRACT",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FORMAT_BYTES",
    "FORMAT_PICO_TIME",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOMCOLLECTION",
    "GEOMETRYCOLLECTION",
    "GET_DD_COLUMN_PRIVILEGES",
    "GET_DD_CREATE_OPTIONS",
    "GET_DD_INDEX_SUB_PART_LENGTH",
    "GET_FORMAT",
    "GET_LOCK",
    "GREATEST",
    "GROUP_CONCAT",
    "GROUPING",
    "GTID_SUBSET",
    "GTID_SUBTRACT",
    "HEX",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    "IN",
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INSERT",
    "INSTR",
    "INTERNAL_AUTO_INCREMENT",
    "INTERNAL_AVG_ROW_LENGTH",
    "INTERNAL_CHECK_TIME",
    "INTERNAL_CHECKSUM",
    "INTERNAL_DATA_FREE",
    "INTERNAL_DATA_LENGTH",
    "INTERNAL_DD_CHAR_LENGTH",
    "INTERNAL_GET_COMMENT_OR_ERROR",
    "INTERNAL_GET_ENABLED_ROLE_JSON",
    "INTERNAL_GET_HOSTNAME",
    "INTERNAL_GET_USERNAME",
    "INTERNAL_GET_VIEW_WARNING_OR_ERROR",
    "INTERNAL_INDEX_COLUMN_CARDINALITY",
    "INTERNAL_INDEX_LENGTH",
    "INTERNAL_IS_ENABLED_ROLE",
    "INTERNAL_IS_MANDATORY_ROLE",
    "INTERNAL_KEYS_DISABLED",
    "INTERNAL_MAX_DATA_LENGTH",
    "INTERNAL_TABLE_ROWS",
    "INTERNAL_UPDATE_TIME",
    "INTERVAL",
    "IS",
    "IS_FREE_LOCK",
    "IS_IPV4",
    "IS_IPV4_COMPAT",
    "IS_IPV4_MAPPED",
    "IS_IPV6",
    "IS NOT",
    "IS NOT NULL",
    "IS NULL",
    "IS_USED_LOCK",
    "IS_UUID",
    "ISNULL",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_ARRAYAGG",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_OBJECT",
    "JSON_OBJECTAGG",
    "JSON_OVERLAPS",
    "JSON_PRETTY",
    "JSON_QUOTE",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SCHEMA_VALID",
    "JSON_SCHEMA_VALIDATION_REPORT",
    "JSON_SEARCH",
    "JSON_SET",
    "JSON_STORAGE_FREE",
    "JSON_STORAGE_SIZE",
    "JSON_TABLE",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAG",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LINESTRING",
    "LN",
    "LOAD_FILE",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAKE_SET",
    "MAKEDATE",
    "MAKETIME",
    "MASTER_POS_WAIT",
    "MATCH",
    "MAX",
    "MBRCONTAINS",
    "MBRCOVEREDBY",
    "MBRCOVERS",
    "MBRDISJOINT",
    "MBREQUALS",
    "MBRINTERSECTS",
    "MBROVERLAPS",
    "MBRTOUCHES",
    "MBRWITHIN",
    "MD5",
    "MEMBER OF",
    "MICROSECOND",
    "MID",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "NAME_CONST",
    "NOT",
    "NOT IN",
    "NOT LIKE",
    "NOT REGEXP",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCT",
    "OCTET_LENGTH",
    // 'OR',
    "ORD",
    "PERCENT_RANK",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POINT",
    "POLYGON",
    "POSITION",
    "POW",
    "POWER",
    "PS_CURRENT_THREAD_ID",
    "PS_THREAD_ID",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANDOM_BYTES",
    "RANK",
    "REGEXP",
    "REGEXP_INSTR",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROLES_GRAPHML",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCHEMA",
    "SEC_TO_TIME",
    "SECOND",
    "SESSION_USER",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "ST_AREA",
    "ST_ASBINARY",
    "ST_ASGEOJSON",
    "ST_ASTEXT",
    "ST_BUFFER",
    "ST_BUFFER_STRATEGY",
    "ST_CENTROID",
    "ST_COLLECT",
    "ST_CONTAINS",
    "ST_CONVEXHULL",
    "ST_CROSSES",
    "ST_DIFFERENCE",
    "ST_DIMENSION",
    "ST_DISJOINT",
    "ST_DISTANCE",
    "ST_DISTANCE_SPHERE",
    "ST_ENDPOINT",
    "ST_ENVELOPE",
    "ST_EQUALS",
    "ST_EXTERIORRING",
    "ST_FRECHETDISTANCE",
    "ST_GEOHASH",
    "ST_GEOMCOLLFROMTEXT",
    "ST_GEOMCOLLFROMWKB",
    "ST_GEOMETRYN",
    "ST_GEOMETRYTYPE",
    "ST_GEOMFROMGEOJSON",
    "ST_GEOMFROMTEXT",
    "ST_GEOMFROMWKB",
    "ST_HAUSDORFFDISTANCE",
    "ST_INTERIORRINGN",
    "ST_INTERSECTION",
    "ST_INTERSECTS",
    "ST_ISCLOSED",
    "ST_ISEMPTY",
    "ST_ISSIMPLE",
    "ST_ISVALID",
    "ST_LATFROMGEOHASH",
    "ST_LATITUDE",
    "ST_LENGTH",
    "ST_LINEFROMTEXT",
    "ST_LINEFROMWKB",
    "ST_LINEINTERPOLATEPOINT",
    "ST_LINEINTERPOLATEPOINTS",
    "ST_LONGFROMGEOHASH",
    "ST_LONGITUDE",
    "ST_MAKEENVELOPE",
    "ST_MLINEFROMTEXT",
    "ST_MLINEFROMWKB",
    "ST_MPOINTFROMTEXT",
    "ST_MPOINTFROMWKB",
    "ST_MPOLYFROMTEXT",
    "ST_MPOLYFROMWKB",
    "ST_NUMGEOMETRIES",
    "ST_NUMINTERIORRING",
    "ST_NUMPOINTS",
    "ST_OVERLAPS",
    "ST_POINTATDISTANCE",
    "ST_POINTFROMGEOHASH",
    "ST_POINTFROMTEXT",
    "ST_POINTFROMWKB",
    "ST_POINTN",
    "ST_POLYFROMTEXT",
    "ST_POLYFROMWKB",
    "ST_SIMPLIFY",
    "ST_SRID",
    "ST_STARTPOINT",
    "ST_SWAPXY",
    "ST_SYMDIFFERENCE",
    "ST_TOUCHES",
    "ST_TRANSFORM",
    "ST_UNION",
    "ST_VALIDATE",
    "ST_WITHIN",
    "ST_X",
    "ST_Y",
    "STATEMENT_DIGEST",
    "STATEMENT_DIGEST_TEXT",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "STRCMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SUM",
    "SYSDATE",
    "SYSTEM_USER",
    "TAN",
    "TIME",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TIMEDIFF",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TO_BASE64",
    "TO_DAYS",
    "TO_SECONDS",
    "TRIM",
    "TRUNCATE",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "UUID_SHORT",
    "UUID_TO_BIN",
    "VALIDATE_PASSWORD_STRENGTH",
    "VALUES",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE",
    "VERSION",
    "WAIT_FOR_EXECUTED_GTID_SET",
    "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WEIGHT_STRING",
    // 'XOR',
    "YEAR",
    "YEARWEEK"
  ], z = ["ACCESSIBLE", "ACCOUNT", "ACTION", "ACTIVE", "ADMIN", "AFTER", "AGAINST", "AGGREGATE", "ALGORITHM", "ALL", "ALTER", "ALWAYS", "ANALYSE", "ANALYZE", "ANY", "ARRAY", "AS", "ASC", "ASENSITIVE", "AT", "ATTRIBUTE", "AUTHENTICATION", "AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH", "BACKUP", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", "BIT", "BLOB", "BLOCK", "BOOL", "BOOLEAN", "BOTH", "BTREE", "BUCKETS", "BY", "BYTE", "CACHE", "CASCADE", "CASCADED", "CATALOG_NAME", "CHAIN", "CHALLENGE_RESPONSE", "CHANGE", "CHANGED", "CHANNEL", "CHARACTER", "CHARACTER SET", "CHECK", "CHECKSUM", "CIPHER", "CLASS_ORIGIN", "CLIENT", "CLOSE", "CODE", "COLLATE", "COLUMN", "COLUMNS", "COLUMN_FORMAT", "COLUMN_NAME", "COMMENT", "COMMITTED", "COMPACT", "COMPLETION", "COMPONENT", "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONDITION", "CONNECTION", "CONSISTENT", "CONSTRAINT", "CONSTRAINT_CATALOG", "CONSTRAINT_NAME", "CONSTRAINT_SCHEMA", "CONTAINS", "CONTEXT", "CONTINUE", "CPU", "CREATE", "CROSS", "CUBE", "CURRENT", "CURSOR", "CURSOR_NAME", "DATA", "DATABASES", "DATAFILE", "DATETIME", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT_AUTH", "DEFINER", "DEFINITION", "DELAYED", "DELAY_KEY_WRITE", "DESC", "DESCRIPTION", "DES_KEY_FILE", "DETERMINISTIC", "DIAGNOSTICS", "DIRECTORY", "DISABLE", "DISCARD", "DISK", "DISTINCT", "DISTINCTROW", "DOUBLE", "DROP", "DUAL", "DUMPFILE", "DUPLICATE", "DYNAMIC", "EACH", "EMPTY", "ENABLE", "ENCLOSED", "ENCRYPTION", "ENDS", "ENFORCED", "ENGINE", "ENGINES", "ENGINE_ATTRIBUTE", "ENUM", "ERROR", "ERRORS", "ESCAPE", "ESCAPED", "EVENT", "EVENTS", "EVERY", "EXCHANGE", "EXCLUDE", "EXISTS", "EXIT", "EXPANSION", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", "FACTOR", "FAILED_LOGIN_ATTEMPTS", "FALSE", "FAST", "FAULTS", "FETCH", "FIELDS", "FILE", "FILE_BLOCK_SIZE", "FILTER", "FINISH", "FIRST", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "FOLLOWING", "FOLLOWS", "FOR", "FORCE", "FOREIGN", "FOUND", "FULL", "FULLTEXT", "FUNCTION", "GENERAL", "GENERATED", "GEOMCOLLECTION", "GEOMETRY", "GEOMETRYCOLLECTION", "GET", "GET_MASTER_PUBLIC_KEY", "GET_SOURCE_PUBLIC_KEY", "GLOBAL", "@@GLOBAL", "GRANTS", "GROUP", "GROUPS", "GROUP_REPLICATION", "GTID_ONLY", "HASH", "HIGH_PRIORITY", "HISTOGRAM", "HISTORY", "HOST", "HOSTS", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IDENTIFIED", "IGNORE", "IGNORE_SERVER_IDS", "IMPORT", "INACTIVE", "INDEX", "INDEXES", "INFILE", "INITIAL", "INITIAL_SIZE", "INITIATE", "INNER", "INOUT", "INSENSITIVE", "INSERT_METHOD", "INSTALL", "INSTANCE", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "INTO", "INVISIBLE", "INVOKER", "IO", "IO_AFTER_GTIDS", "IO_BEFORE_GTIDS", "IO_THREAD", "IPC", "ISOLATION", "ISSUER", "ITERATE", "JSON", "KEY", "KEYRING", "KEYS", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", "LATERAL", "LEADING", "LEAVE", "LEAVES", "LESS", "LEVEL", "LINEAR", "LINES", "LINESTRING", "LIST", "LOAD", "LOCAL", "LOCK", "LOCKED", "LOCKS", "LOGFILE", "LOGS", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "MASTER", "MASTER_AUTO_POSITION", "MASTER_BIND", "MASTER_COMPRESSION_ALGORITHMS", "MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", "MASTER_HOST", "MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", "MASTER_PORT", "MASTER_PUBLIC_KEY_PATH", "MASTER_RETRY_COUNT", "MASTER_SERVER_ID", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", "MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", "MASTER_SSL_KEY", "MASTER_SSL_VERIFY_SERVER_CERT", "MASTER_TLS_CIPHERSUITES", "MASTER_TLS_VERSION", "MASTER_USER", "MASTER_ZSTD_COMPRESSION_LEVEL", "MAXVALUE", "MAX_CONNECTIONS_PER_HOUR", "MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", "MAX_USER_CONNECTIONS", "MEDIUM", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MEMORY", "MERGE", "MESSAGE_TEXT", "MIDDLEINT", "MIGRATE", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MIN_ROWS", "MODE", "MODIFIES", "MODIFY", "MULTILINESTRING", "MULTIPOINT", "MULTIPOLYGON", "MUTEX", "MYSQL_ERRNO", "NAME", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NDB", "NDBCLUSTER", "NESTED", "NETWORK_NAMESPACE", "NEVER", "NEW", "NEXT", "NO", "NODEGROUP", "NONE", "NOWAIT", "NO_WAIT", "NO_WRITE_TO_BINLOG", "NULL", "NULLS", "NUMBER", "NUMERIC", "NVARCHAR", "OF", "OFF", "OFFSET", "OJ", "OLD", "ON DELETE", "ON UPDATE", "ONE", "ONLY", "OPEN", "OPTIMIZE", "OPTIMIZER_COSTS", "OPTION", "OPTIONAL", "OPTIONALLY", "OPTIONS", "ORDER", "ORDINALITY", "ORGANIZATION", "OTHERS", "OUT", "OUTER", "OUTFILE", "OVER", "OWNER", "PACK_KEYS", "PAGE", "PARSER", "PARSE_GCOL_EXPR", "PARTIAL", "PARTITION", "PARTITIONING", "PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PATH", "PERSIST", "@@PERSIST", "PERSIST_ONLY", "@@PERSIST_ONLY", "PHASE", "PLUGIN", "PLUGINS", "PLUGIN_DIR", "POINT", "POLYGON", "PORT", "PRECEDES", "PRECEDING", "PRECISION", "PRESERVE", "PREV", "PRIMARY", "PRIVILEGES", "PRIVILEGE_CHECKS_USER", "PROCEDURE", "PROCESS", "PROCESSLIST", "PROFILE", "PROFILES", "PROXY", "PURGE", "QUERY", "QUICK", "RANDOM", "RANGE", "READ", "READS", "READ_ONLY", "READ_WRITE", "REAL", "REBUILD", "RECOVER", "RECURSIVE", "REDOFILE", "REDO_BUFFER_SIZE", "REDUNDANT", "REFERENCE", "REFERENCES", "REGISTRATION", "RELAY", "RELAYLOG", "RELAY_LOG_FILE", "RELAY_LOG_POS", "RELAY_THREAD", "RELEASE", "RELOAD", "REMOTE", "REMOVE", "RENAME", "REORGANIZE", "REPAIR", "REPEATABLE", "REPLICA", "REPLICAS", "REPLICATE_DO_DB", "REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", "REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", "REPLICATION", "REQUIRE", "REQUIRE_ROW_FORMAT", "RESIGNAL", "RESOURCE", "RESPECT", "RESTORE", "RESTRICT", "RESUME", "RETAIN", "RETURN", "RETURNED_SQLSTATE", "RETURNING", "RETURNS", "REUSE", "ROLE", "ROLLUP", "ROTATE", "ROUTINE", "ROW", "ROWS", "ROW_FORMAT", "RTREE", "SCHEDULE", "SCHEMAS", "SCHEMA_NAME", "SECONDARY", "SECONDARY_ENGINE", "SECONDARY_ENGINE_ATTRIBUTE", "SECONDARY_LOAD", "SECONDARY_UNLOAD", "SECOND_MICROSECOND", "SECURITY", "SENSITIVE", "SEPARATOR", "SERIAL", "SERIALIZABLE", "SERVER", "SESSION", "@@SESSION", "SHARE", "SIGNAL", "SIGNED", "SIMPLE", "SKIP", "SLAVE", "SLOW", "SMALLINT", "SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SOURCE_AUTO_POSITION", "SOURCE_BIND", "SOURCE_COMPRESSION_ALGORITHMS", "SOURCE_CONNECT_RETRY", "SOURCE_DELAY", "SOURCE_HEARTBEAT_PERIOD", "SOURCE_HOST", "SOURCE_LOG_FILE", "SOURCE_LOG_POS", "SOURCE_PASSWORD", "SOURCE_PORT", "SOURCE_PUBLIC_KEY_PATH", "SOURCE_RETRY_COUNT", "SOURCE_SSL", "SOURCE_SSL_CA", "SOURCE_SSL_CAPATH", "SOURCE_SSL_CERT", "SOURCE_SSL_CIPHER", "SOURCE_SSL_CRL", "SOURCE_SSL_CRLPATH", "SOURCE_SSL_KEY", "SOURCE_SSL_VERIFY_SERVER_CERT", "SOURCE_TLS_CIPHERSUITES", "SOURCE_TLS_VERSION", "SOURCE_USER", "SOURCE_ZSTD_COMPRESSION_LEVEL", "SPATIAL", "SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_AFTER_GTIDS", "SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", "SQL_BIG_RESULT", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS", "SQL_NO_CACHE", "SQL_SMALL_RESULT", "SQL_THREAD", "SQL_TSI_DAY", "SQL_TSI_HOUR", "SQL_TSI_MINUTE", "SQL_TSI_MONTH", "SQL_TSI_QUARTER", "SQL_TSI_SECOND", "SQL_TSI_WEEK", "SQL_TSI_YEAR", "SRID", "SSL", "STACKED", "START", "STARTING", "STARTS", "STATS_AUTO_RECALC", "STATS_PERSISTENT", "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", "STORED", "STREAM", "STRING", "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", "SUPER", "SUSPEND", "SWAPS", "SWITCHES", "SYSTEM", "TABLES", "TABLESPACE", "TABLE_CHECKSUM", "TABLE_NAME", "TEMPORARY", "TEMPTABLE", "TERMINATED", "TEXT", "THAN", "THEN", "THREAD_PRIORITY", "TIES", "TINYBLOB", "TINYINT", "TINYTEXT", "TLS", "TO", "TRAILING", "TRANSACTION", "TRIGGER", "TRIGGERS", "TRUE", "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNDEFINED", "UNDO", "UNDOFILE", "UNDO_BUFFER_SIZE", "UNICODE", "UNINSTALL", "UNIQUE", "UNKNOWN", "UNLOCK", "UNREGISTER", "UNSIGNED", "UNTIL", "UPGRADE", "USAGE", "USER_RESOURCES", "USE_FRM", "VALIDATION", "VALUE", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARIABLES", "VARYING", "VCPU", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", "WARNINGS", "WHILE", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "WRITE", "X509", "XID", "XML", "YEAR_MONTH", "ZEROFILL", "ZONE"], F = [
    "ALTER DATABASE",
    "ALTER EVENT",
    "ALTER FUNCTION",
    "ALTER INSTANCE",
    "ALTER LOGFILE GROUP",
    "ALTER PROCEDURE",
    "ALTER RESOURCE GROUP",
    "ALTER SERVER",
    "ALTER TABLE",
    "ALTER TABLESPACE",
    "ALTER USER",
    "ALTER VIEW",
    "ANALYZE TABLE",
    "BINLOG",
    "CACHE INDEX",
    "CALL",
    "CHANGE MASTER TO",
    "CHANGE REPLICATION FILTER",
    "CHANGE REPLICATION SOURCE TO",
    "CHECK TABLE",
    "CHECKSUM TABLE",
    "CLONE",
    "COMMIT",
    "CREATE DATABASE",
    "CREATE EVENT",
    "CREATE FUNCTION",
    "CREATE FUNCTION",
    "CREATE INDEX",
    "CREATE LOGFILE GROUP",
    "CREATE PROCEDURE",
    "CREATE RESOURCE GROUP",
    "CREATE ROLE",
    "CREATE SERVER",
    "CREATE SPATIAL REFERENCE SYSTEM",
    "CREATE TABLE",
    "CREATE TABLESPACE",
    "CREATE TRIGGER",
    "CREATE USER",
    "CREATE VIEW",
    "DEALLOCATE PREPARE",
    "DELETE",
    "DELETE FROM",
    "DESCRIBE",
    "DO",
    "DROP DATABASE",
    "DROP EVENT",
    "DROP FUNCTION",
    "DROP FUNCTION",
    "DROP INDEX",
    "DROP LOGFILE GROUP",
    "DROP PROCEDURE",
    "DROP RESOURCE GROUP",
    "DROP ROLE",
    "DROP SERVER",
    "DROP SPATIAL REFERENCE SYSTEM",
    "DROP TABLE",
    "DROP TABLESPACE",
    "DROP TRIGGER",
    "DROP USER",
    "DROP VIEW",
    "EXECUTE",
    "EXPLAIN",
    "FLUSH",
    "GRANT",
    "HANDLER",
    "HELP",
    "IMPORT TABLE",
    "INSERT",
    "INSTALL COMPONENT",
    "INSTALL PLUGIN",
    "KILL",
    "LOAD DATA",
    "LOAD INDEX INTO CACHE",
    "LOAD XML",
    "LOCK INSTANCE FOR BACKUP",
    "LOCK TABLES",
    "MASTER_POS_WAIT",
    "OPTIMIZE TABLE",
    "PREPARE",
    "PURGE BINARY LOGS",
    "RELEASE SAVEPOINT",
    "RENAME TABLE",
    "RENAME USER",
    "REPAIR TABLE",
    "REPLACE",
    "RESET",
    "RESET MASTER",
    "RESET PERSIST",
    "RESET REPLICA",
    "RESET SLAVE",
    "RESTART",
    "REVOKE",
    "ROLLBACK",
    "ROLLBACK TO SAVEPOINT",
    "SAVEPOINT",
    "SELECT",
    "SET",
    "SET CHARACTER SET",
    "SET DEFAULT ROLE",
    "SET NAMES",
    "SET PASSWORD",
    "SET RESOURCE GROUP",
    "SET ROLE",
    "SET TRANSACTION",
    "SHOW",
    "SHOW BINARY LOGS",
    "SHOW BINLOG EVENTS",
    "SHOW CHARACTER SET",
    "SHOW COLLATION",
    "SHOW COLUMNS",
    "SHOW CREATE DATABASE",
    "SHOW CREATE EVENT",
    "SHOW CREATE FUNCTION",
    "SHOW CREATE PROCEDURE",
    "SHOW CREATE TABLE",
    "SHOW CREATE TRIGGER",
    "SHOW CREATE USER",
    "SHOW CREATE VIEW",
    "SHOW DATABASES",
    "SHOW ENGINE",
    "SHOW ENGINES",
    "SHOW ERRORS",
    "SHOW EVENTS",
    "SHOW FUNCTION CODE",
    "SHOW FUNCTION STATUS",
    "SHOW GRANTS",
    "SHOW INDEX",
    "SHOW MASTER STATUS",
    "SHOW OPEN TABLES",
    "SHOW PLUGINS",
    "SHOW PRIVILEGES",
    "SHOW PROCEDURE CODE",
    "SHOW PROCEDURE STATUS",
    "SHOW PROCESSLIST",
    "SHOW PROFILE",
    "SHOW PROFILES",
    "SHOW RELAYLOG EVENTS",
    "SHOW REPLICA STATUS",
    "SHOW REPLICAS",
    "SHOW SLAVE",
    "SHOW SLAVE HOSTS",
    "SHOW STATUS",
    "SHOW TABLE STATUS",
    "SHOW TABLES",
    "SHOW TRIGGERS",
    "SHOW VARIABLES",
    "SHOW WARNINGS",
    "SHUTDOWN",
    "SOURCE_POS_WAIT",
    "START GROUP_REPLICATION",
    "START REPLICA",
    "START SLAVE",
    "START TRANSACTION",
    "STOP GROUP_REPLICATION",
    "STOP REPLICA",
    "STOP SLAVE",
    "TABLE",
    "TRUNCATE TABLE",
    "UNINSTALL COMPONENT",
    "UNINSTALL PLUGIN",
    "UNLOCK INSTANCE",
    "UNLOCK TABLES",
    "UPDATE",
    "USE",
    "VALUES",
    "WITH",
    "XA",
    // flow control
    // 'IF',
    "ITERATE",
    "LEAVE",
    "LOOP",
    "REPEAT",
    "RETURN",
    "WHILE",
    // other
    "ADD",
    "ALTER COLUMN",
    "FROM",
    "GROUP BY",
    "HAVING",
    "INSERT INTO",
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "WHERE",
    "WINDOW",
    "PARTITION BY"
  ], ae = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT"], U = [
    "JOIN",
    "INNER JOIN",
    "LEFT JOIN",
    "LEFT OUTER JOIN",
    "RIGHT JOIN",
    "RIGHT OUTER JOIN",
    "CROSS JOIN",
    "NATURAL JOIN",
    // non-standard joins
    "STRAIGHT_JOIN",
    "NATURAL LEFT JOIN",
    "NATURAL LEFT OUTER JOIN",
    "NATURAL RIGHT JOIN",
    "NATURAL RIGHT OUTER JOIN"
  ], G = ["WHEN", "ELSE", "ELSEIF"], H = function(B) {
    d2(E, B);
    var Y = L(E);
    function E() {
      return f(this, E), Y.apply(this, arguments);
    }
    return O(E, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: F,
          reservedBinaryCommands: ae,
          reservedJoins: U,
          reservedDependentClauses: G,
          reservedLogicalOperators: ["AND", "OR", "XOR"],
          reservedKeywords: (0, s.dedupe)([].concat(z, $)),
          stringTypes: ['""', {
            quote: "''",
            prefixes: ["X"]
          }],
          identTypes: ["``"],
          identChars: {
            first: "$",
            rest: "$"
          },
          variableTypes: [{
            regex: "@[A-Za-z0-9_.$]+"
          }, {
            quote: '""',
            prefixes: ["@"],
            requirePrefix: true
          }, {
            quote: "''",
            prefixes: ["@"],
            requirePrefix: true
          }, {
            quote: "``",
            prefixes: ["@"],
            requirePrefix: true
          }],
          positionalParams: true,
          lineCommentTypes: ["--", "#"],
          operators: E.operators,
          postProcess: re
        });
      }
    }]), E;
  }(i.default);
  t.default = H, _2(H, "operators", ["~", ":=", "<<", ">>", "<=>", "&&", "||", "->", "->>"]);
  function re(B) {
    return B.map(function(Y, E) {
      var m = B[E + 1] || a.EOF_TOKEN;
      return a.isToken.SET(Y) && m.value === "(" ? c(c({}, Y), {}, {
        type: a.TokenType.RESERVED_KEYWORD
      }) : Y;
    });
  }
  e.exports = t.default;
})(Xl, Xl.exports);
var Q_ = Xl.exports;
var jl = { exports: {} };
(function(e, t) {
  function r(U) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(G) {
      return typeof G;
    } : function(G) {
      return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G;
    }, r(U);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(U) {
    return U && U.__esModule ? U : { default: U };
  }
  function o(U, G) {
    if (!(U instanceof G))
      throw new TypeError("Cannot call a class as a function");
  }
  function l(U, G) {
    for (var H = 0; H < G.length; H++) {
      var re = G[H];
      re.enumerable = re.enumerable || false, re.configurable = true, "value" in re && (re.writable = true), Object.defineProperty(U, re.key, re);
    }
  }
  function c(U, G, H) {
    return G && l(U.prototype, G), H && l(U, H), Object.defineProperty(U, "prototype", { writable: false }), U;
  }
  function f(U, G) {
    if (typeof G != "function" && G !== null)
      throw new TypeError("Super expression must either be null or a function");
    U.prototype = Object.create(G && G.prototype, { constructor: { value: U, writable: true, configurable: true } }), Object.defineProperty(U, "prototype", { writable: false }), G && p(U, G);
  }
  function p(U, G) {
    return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(re, B) {
      return re.__proto__ = B, re;
    }, p(U, G);
  }
  function O(U) {
    var G = L();
    return function() {
      var re = D(U), B;
      if (G) {
        var Y = D(this).constructor;
        B = Reflect.construct(re, arguments, Y);
      } else
        B = re.apply(this, arguments);
      return d2(this, B);
    };
  }
  function d2(U, G) {
    if (G && (r(G) === "object" || typeof G == "function"))
      return G;
    if (G !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return g(U);
  }
  function g(U) {
    if (U === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U;
  }
  function L() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function D(U) {
    return D = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(H) {
      return H.__proto__ || Object.getPrototypeOf(H);
    }, D(U);
  }
  function W(U, G, H) {
    return G in U ? Object.defineProperty(U, G, { value: H, enumerable: true, configurable: true, writable: true }) : U[G] = H, U;
  }
  var x = [
    "ABORT",
    "ABS",
    "ACOS",
    "ADVISOR",
    "ARRAY_AGG",
    "ARRAY_AGG",
    "ARRAY_APPEND",
    "ARRAY_AVG",
    "ARRAY_BINARY_SEARCH",
    "ARRAY_CONCAT",
    "ARRAY_CONTAINS",
    "ARRAY_COUNT",
    "ARRAY_DISTINCT",
    "ARRAY_EXCEPT",
    "ARRAY_FLATTEN",
    "ARRAY_IFNULL",
    "ARRAY_INSERT",
    "ARRAY_INTERSECT",
    "ARRAY_LENGTH",
    "ARRAY_MAX",
    "ARRAY_MIN",
    "ARRAY_MOVE",
    "ARRAY_POSITION",
    "ARRAY_PREPEND",
    "ARRAY_PUT",
    "ARRAY_RANGE",
    "ARRAY_REMOVE",
    "ARRAY_REPEAT",
    "ARRAY_REPLACE",
    "ARRAY_REVERSE",
    "ARRAY_SORT",
    "ARRAY_STAR",
    "ARRAY_SUM",
    "ARRAY_SYMDIFF",
    "ARRAY_SYMDIFF1",
    "ARRAY_SYMDIFFN",
    "ARRAY_UNION",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BASE64",
    "BASE64_DECODE",
    "BASE64_ENCODE",
    "BITAND ",
    "BITCLEAR ",
    "BITNOT ",
    "BITOR ",
    "BITSET ",
    "BITSHIFT ",
    "BITTEST ",
    "BITXOR ",
    "CEIL",
    "CLOCK_LOCAL",
    "CLOCK_MILLIS",
    "CLOCK_STR",
    "CLOCK_TZ",
    "CLOCK_UTC",
    "COALESCE",
    "CONCAT",
    "CONCAT2",
    "CONTAINS",
    "CONTAINS_TOKEN",
    "CONTAINS_TOKEN_LIKE",
    "CONTAINS_TOKEN_REGEXP",
    "COS",
    "COUNT",
    "COUNT",
    "COUNTN",
    "CUME_DIST",
    "CURL",
    "DATE_ADD_MILLIS",
    "DATE_ADD_STR",
    "DATE_DIFF_MILLIS",
    "DATE_DIFF_STR",
    "DATE_FORMAT_STR",
    "DATE_PART_MILLIS",
    "DATE_PART_STR",
    "DATE_RANGE_MILLIS",
    "DATE_RANGE_STR",
    "DATE_TRUNC_MILLIS",
    "DATE_TRUNC_STR",
    "DECODE",
    "DECODE_JSON",
    "DEGREES",
    "DENSE_RANK",
    "DURATION_TO_STR",
    // 'E',
    "ENCODED_SIZE",
    "ENCODE_JSON",
    "EXP",
    "FIRST_VALUE",
    "FLOOR",
    "GREATEST",
    "HAS_TOKEN",
    "IFINF",
    "IFMISSING",
    "IFMISSINGORNULL",
    "IFNAN",
    "IFNANORINF",
    "IFNULL",
    "INITCAP",
    "ISARRAY",
    "ISATOM",
    "ISBITSET",
    "ISBOOLEAN",
    "ISNUMBER",
    "ISOBJECT",
    "ISSTRING",
    "LAG",
    "LAST_VALUE",
    "LEAD",
    "LEAST",
    "LENGTH",
    "LN",
    "LOG",
    "LOWER",
    "LTRIM",
    "MAX",
    "MEAN",
    "MEDIAN",
    "META",
    "MILLIS",
    "MILLIS_TO_LOCAL",
    "MILLIS_TO_STR",
    "MILLIS_TO_TZ",
    "MILLIS_TO_UTC",
    "MILLIS_TO_ZONE_NAME",
    "MIN",
    "MISSINGIF",
    "NANIF",
    "NEGINFIF",
    "NOW_LOCAL",
    "NOW_MILLIS",
    "NOW_STR",
    "NOW_TZ",
    "NOW_UTC",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "NVL",
    "NVL2",
    "OBJECT_ADD",
    "OBJECT_CONCAT",
    "OBJECT_INNER_PAIRS",
    "OBJECT_INNER_VALUES",
    "OBJECT_LENGTH",
    "OBJECT_NAMES",
    "OBJECT_PAIRS",
    "OBJECT_PUT",
    "OBJECT_REMOVE",
    "OBJECT_RENAME",
    "OBJECT_REPLACE",
    "OBJECT_UNWRAP",
    "OBJECT_VALUES",
    "PAIRS",
    "PERCENT_RANK",
    "PI",
    "POLY_LENGTH",
    "POSINFIF",
    "POSITION",
    "POWER",
    "RADIANS",
    "RANDOM",
    "RANK",
    "RATIO_TO_REPORT",
    "REGEXP_CONTAINS",
    "REGEXP_LIKE",
    "REGEXP_MATCHES",
    "REGEXP_POSITION",
    "REGEXP_REPLACE",
    "REGEXP_SPLIT",
    "REGEX_CONTAINS",
    "REGEX_LIKE",
    "REGEX_MATCHES",
    "REGEX_POSITION",
    "REGEX_REPLACE",
    "REGEX_SPLIT",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "ROUND",
    "ROW_NUMBER",
    "RTRIM",
    "SEARCH",
    "SEARCH_META",
    "SEARCH_SCORE",
    "SIGN",
    "SIN",
    "SPLIT",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DURATION",
    "STR_TO_MILLIS",
    "STR_TO_TZ",
    "STR_TO_UTC",
    "STR_TO_ZONE_NAME",
    "SUBSTR",
    "SUFFIXES",
    "SUM",
    "TAN",
    "TITLE",
    "TOARRAY",
    "TOATOM",
    "TOBOOLEAN",
    "TOKENS",
    "TOKENS",
    "TONUMBER",
    "TOOBJECT",
    "TOSTRING",
    "TRIM",
    "TRUNC",
    // 'TYPE', // disabled
    "UPPER",
    "UUID",
    "VARIANCE",
    "VARIANCE_POP",
    "VARIANCE_SAMP",
    "VAR_POP",
    "VAR_SAMP",
    "WEEKDAY_MILLIS",
    "WEEKDAY_STR"
  ], V = [
    "ALL",
    "ALTER",
    "ANALYZE",
    "ANY",
    "ARRAY",
    "AS",
    "ASC",
    "AT",
    "BEGIN",
    "BETWEEN",
    "BINARY",
    "BOOLEAN",
    "BREAK",
    "BUCKET",
    "BUILD",
    "BY",
    "CALL",
    "CAST",
    "CHAR",
    // verify
    "CLUSTER",
    "COLLATE",
    "COLLECTION",
    "COMMIT",
    "COMMITTED",
    "CONNECT",
    "CONTINUE",
    "CORRELATE",
    "CORRELATED",
    "COVER",
    "CREATE",
    "CURRENT",
    "DATABASE",
    "DATASET",
    "DATASTORE",
    "DECLARE",
    "DECREMENT",
    "DERIVED",
    "DESC",
    "DESCRIBE",
    "DISTINCT",
    "DO",
    "DROP",
    "EACH",
    "ELEMENT",
    "EVERY",
    "EXCLUDE",
    "EXISTS",
    "FALSE",
    "FETCH",
    "FILTER",
    "FIRST",
    "FLATTEN",
    "FLUSH",
    "FOLLOWING",
    "FOR",
    "FORCE",
    "FTS",
    "FUNCTION",
    "GOLANG",
    "GROUP",
    "GROUPS",
    "GSI",
    "HASH",
    "IF",
    "IGNORE",
    "ILIKE",
    "IN",
    "INCLUDE",
    "INCREMENT",
    "INDEX",
    "INLINE",
    "INNER",
    "INTO",
    "IS",
    "ISOLATION",
    "JAVASCRIPT",
    "KEY",
    "KEYS",
    "KEYSPACE",
    "KNOWN",
    "LANGUAGE",
    "LAST",
    "LEFT",
    "LETTING",
    "LEVEL",
    "LIKE",
    "LSM",
    "MAP",
    "MAPPING",
    "MATCHED",
    "MATERIALIZED",
    "MISSING",
    "NAMESPACE",
    "NL",
    "NO",
    "NOT",
    "NULL",
    "NULLS",
    "NUMBER",
    "OBJECT",
    "OFFSET",
    "OPTION",
    "OPTIONS",
    "ORDER",
    "OTHERS",
    "OUTER",
    "OVER",
    "PARSE",
    "PARTITION",
    "PASSWORD",
    "PATH",
    "POOL",
    "PRECEDING",
    "PRIMARY",
    "PRIVATE",
    "PRIVILEGE",
    "PROBE",
    "PROCEDURE",
    "PUBLIC",
    "RANGE",
    "RAW",
    "REALM",
    "REDUCE",
    "RENAME",
    "RESPECT",
    "RETURN",
    "RIGHT",
    "ROLE",
    "ROLLBACK",
    "ROW",
    "ROWS",
    "SATISFIES",
    "SCHEMA",
    "SCOPE",
    "SELF",
    "SEMI",
    "SOME",
    "START",
    "STATISTICS",
    "STRING",
    "SYSTEM",
    "THEN",
    "TIES",
    "TO",
    "TRAN",
    "TRANSACTION",
    "TRIGGER",
    "TRUE",
    "TRUNCATE",
    "UNBOUNDED",
    "UNDER",
    "UNIQUE",
    "UNKNOWN",
    "UNSET",
    "USE",
    "USER",
    "VALIDATE",
    "VALUE",
    "VALUED",
    "VIA",
    "VIEW",
    "WHILE",
    "WINDOW",
    "WITHIN",
    "WORK"
  ], _2 = [
    "ADVISE",
    "ALTER INDEX",
    "BEGIN TRANSACTION",
    "BUILD INDEX",
    "COMMIT TRANSACTION",
    "CREATE COLLECTION",
    "CREATE FUNCTION",
    "CREATE INDEX",
    "CREATE PRIMARY INDEX",
    "CREATE SCOPE",
    "CREATE TABLE",
    // verify
    "DELETE",
    "DELETE FROM",
    "DROP COLLECTION",
    "DROP FUNCTION",
    "DROP INDEX",
    "DROP PRIMARY INDEX",
    "DROP SCOPE",
    "EXECUTE",
    "EXECUTE FUNCTION",
    "EXPLAIN",
    "GRANT",
    "INFER",
    "INSERT",
    "MERGE",
    "PREPARE",
    "RETURNING",
    "REVOKE",
    "ROLLBACK TRANSACTION",
    "SAVEPOINT",
    "SELECT",
    "SET TRANSACTION",
    "UPDATE",
    "UPDATE STATISTICS",
    "UPSERT",
    // other
    "DROP TABLE",
    // verify,
    "FROM",
    "GROUP BY",
    "HAVING",
    "INSERT INTO",
    "LET",
    "LIMIT",
    "OFFSET",
    "NEST",
    "ORDER BY",
    "SET CURRENT SCHEMA",
    "SET SCHEMA",
    "SET",
    "SHOW",
    "UNNEST",
    "USE KEYS",
    "VALUES",
    "WHERE",
    "WITH",
    "WINDOW",
    "PARTITION BY"
  ], $ = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT", "MINUS", "MINUS ALL", "MINUS DISTINCT"], z = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN"], F = ["WHEN", "ELSE"], ae = function(U) {
    f(H, U);
    var G = O(H);
    function H() {
      return o(this, H), G.apply(this, arguments);
    }
    return c(H, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: _2,
          reservedBinaryCommands: $,
          reservedJoins: z,
          reservedDependentClauses: F,
          reservedLogicalOperators: ["AND", "OR", "XOR"],
          reservedKeywords: (0, a.dedupe)([].concat(V, x)),
          // NOTE: single quotes are actually not supported in N1QL,
          // but we support them anyway as all other SQL dialects do,
          // which simplifies writing tests that are shared between all dialects.
          stringTypes: ['""', "''"],
          identTypes: ["``"],
          openParens: ["(", "[", "{"],
          closeParens: [")", "]", "}"],
          positionalParams: true,
          numberedParamTypes: ["$"],
          namedParamTypes: ["$"],
          lineCommentTypes: ["#", "--"],
          operators: H.operators
        });
      }
    }]), H;
  }(i.default);
  t.default = ae, W(ae, "operators", ["==", "||"]), e.exports = t.default;
})(jl, jl.exports);
var G_ = jl.exports;
var Zl = { exports: {} };
(function(e, t) {
  function r(A) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y2) {
      return typeof y2;
    } : function(y2) {
      return y2 && typeof Symbol == "function" && y2.constructor === Symbol && y2 !== Symbol.prototype ? "symbol" : typeof y2;
    }, r(A);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = o(ur), n = o(cr), a = it, s = Xe;
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function l(A, y2) {
    var C = Object.keys(A);
    if (Object.getOwnPropertySymbols) {
      var j = Object.getOwnPropertySymbols(A);
      y2 && (j = j.filter(function(w) {
        return Object.getOwnPropertyDescriptor(A, w).enumerable;
      })), C.push.apply(C, j);
    }
    return C;
  }
  function c(A) {
    for (var y2 = 1; y2 < arguments.length; y2++) {
      var C = arguments[y2] != null ? arguments[y2] : {};
      y2 % 2 ? l(Object(C), true).forEach(function(j) {
        G(A, j, C[j]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(C)) : l(Object(C)).forEach(function(j) {
        Object.defineProperty(A, j, Object.getOwnPropertyDescriptor(C, j));
      });
    }
    return A;
  }
  function f(A) {
    return g(A) || d2(A) || O(A) || p();
  }
  function p() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function O(A, y2) {
    if (A) {
      if (typeof A == "string")
        return L(A, y2);
      var C = Object.prototype.toString.call(A).slice(8, -1);
      if (C === "Object" && A.constructor && (C = A.constructor.name), C === "Map" || C === "Set")
        return Array.from(A);
      if (C === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C))
        return L(A, y2);
    }
  }
  function d2(A) {
    if (typeof Symbol < "u" && A[Symbol.iterator] != null || A["@@iterator"] != null)
      return Array.from(A);
  }
  function g(A) {
    if (Array.isArray(A))
      return L(A);
  }
  function L(A, y2) {
    (y2 == null || y2 > A.length) && (y2 = A.length);
    for (var C = 0, j = new Array(y2); C < y2; C++)
      j[C] = A[C];
    return j;
  }
  function D(A, y2) {
    if (!(A instanceof y2))
      throw new TypeError("Cannot call a class as a function");
  }
  function W(A, y2) {
    for (var C = 0; C < y2.length; C++) {
      var j = y2[C];
      j.enumerable = j.enumerable || false, j.configurable = true, "value" in j && (j.writable = true), Object.defineProperty(A, j.key, j);
    }
  }
  function x(A, y2, C) {
    return y2 && W(A.prototype, y2), C && W(A, C), Object.defineProperty(A, "prototype", { writable: false }), A;
  }
  function V(A, y2) {
    if (typeof y2 != "function" && y2 !== null)
      throw new TypeError("Super expression must either be null or a function");
    A.prototype = Object.create(y2 && y2.prototype, { constructor: { value: A, writable: true, configurable: true } }), Object.defineProperty(A, "prototype", { writable: false }), y2 && _2(A, y2);
  }
  function _2(A, y2) {
    return _2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(j, w) {
      return j.__proto__ = w, j;
    }, _2(A, y2);
  }
  function $(A) {
    var y2 = ae();
    return function() {
      var j = U(A), w;
      if (y2) {
        var J = U(this).constructor;
        w = Reflect.construct(j, arguments, J);
      } else
        w = j.apply(this, arguments);
      return z(this, w);
    };
  }
  function z(A, y2) {
    if (y2 && (r(y2) === "object" || typeof y2 == "function"))
      return y2;
    if (y2 !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return F(A);
  }
  function F(A) {
    if (A === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return A;
  }
  function ae() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function U(A) {
    return U = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(C) {
      return C.__proto__ || Object.getPrototypeOf(C);
    }, U(A);
  }
  function G(A, y2, C) {
    return y2 in A ? Object.defineProperty(A, y2, { value: C, enumerable: true, configurable: true, writable: true }) : A[y2] = C, A;
  }
  var H = {
    numeric: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "BITAND", "CEIL", "COS", "COSH", "EXP", "FLOOR", "LN", "LOG", "MOD", "NANVL", "POWER", "REMAINDER", "ROUND", "SIGN", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC", "WIDTH_BUCKET"],
    character: ["CHR", "CONCAT", "INITCAP", "LOWER", "LPAD", "LTRIM", "NLS_INITCAP", "NLS_LOWER", "NLSSORT", "NLS_UPPER", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "RPAD", "RTRIM", "SOUNDEX", "SUBSTR", "TRANSLATE", "TREAT", "TRIM", "UPPER", "NLS_CHARSET_DECL_LEN", "NLS_CHARSET_ID", "NLS_CHARSET_NAME", "ASCII", "INSTR", "LENGTH", "REGEXP_INSTR"],
    datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_TIMESTAMP", "DBTIMEZONE", "EXTRACT", "FROM_TZ", "LAST_DAY", "LOCALTIMESTAMP", "MONTHS_BETWEEN", "NEW_TIME", "NEXT_DAY", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "ROUND", "SESSIONTIMEZONE", "SYS_EXTRACT_UTC", "SYSDATE", "SYSTIMESTAMP", "TO_CHAR", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_DSINTERVAL", "TO_YMINTERVAL", "TRUNC", "TZ_OFFSET"],
    comparison: ["GREATEST", "LEAST"],
    conversion: ["ASCIISTR", "BIN_TO_NUM", "CAST", "CHARTOROWID", "COMPOSE", "CONVERT", "DECOMPOSE", "HEXTORAW", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "RAWTOHEX", "RAWTONHEX", "ROWIDTOCHAR", "ROWIDTONCHAR", "SCN_TO_TIMESTAMP", "TIMESTAMP_TO_SCN", "TO_BINARY_DOUBLE", "TO_BINARY_FLOAT", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_DSINTERVAL", "TO_LOB", "TO_MULTI_BYTE", "TO_NCHAR", "TO_NCLOB", "TO_NUMBER", "TO_DSINTERVAL", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_YMINTERVAL", "TO_YMINTERVAL", "TRANSLATE", "UNISTR"],
    largeObject: ["BFILENAME", "EMPTY_BLOB,", "EMPTY_CLOB"],
    collection: ["CARDINALITY", "COLLECT", "POWERMULTISET", "POWERMULTISET_BY_CARDINALITY", "SET"],
    hierarchical: ["SYS_CONNECT_BY_PATH"],
    dataMining: ["CLUSTER_ID", "CLUSTER_PROBABILITY", "CLUSTER_SET", "FEATURE_ID", "FEATURE_SET", "FEATURE_VALUE", "PREDICTION", "PREDICTION_COST", "PREDICTION_DETAILS", "PREDICTION_PROBABILITY", "PREDICTION_SET"],
    xml: ["APPENDCHILDXML", "DELETEXML", "DEPTH", "EXTRACT", "EXISTSNODE", "EXTRACTVALUE", "INSERTCHILDXML", "INSERTXMLBEFORE", "PATH", "SYS_DBURIGEN", "SYS_XMLAGG", "SYS_XMLGEN", "UPDATEXML", "XMLAGG", "XMLCDATA", "XMLCOLATTVAL", "XMLCOMMENT", "XMLCONCAT", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", "XMLSEQUENCE", "XMLSERIALIZE", "XMLTABLE", "XMLTRANSFORM"],
    encoding: ["DECODE", "DUMP", "ORA_HASH", "VSIZE"],
    nullRelated: ["COALESCE", "LNNVL", "NULLIF", "NVL", "NVL2"],
    env: ["SYS_CONTEXT", "SYS_GUID", "SYS_TYPEID", "UID", "USER", "USERENV"],
    aggregate: ["AVG", "COLLECT", "CORR", "CORR_S", "CORR_K", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "FIRST", "GROUP_ID", "GROUPING", "GROUPING_ID", "LAST", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANK", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "STATS_BINOMIAL_TEST", "STATS_CROSSTAB", "STATS_F_TEST", "STATS_KS_TEST", "STATS_MODE", "STATS_MW_TEST", "STATS_ONE_WAY_ANOVA", "STATS_T_TEST_ONE", "STATS_T_TEST_PAIRED", "STATS_T_TEST_INDEP", "STATS_T_TEST_INDEPU", "STATS_WSR_TEST", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
    // Windowing functions (minus the ones already listed in aggregates)
    window: ["FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTILE", "RATIO_TO_REPORT", "ROW_NUMBER"],
    objectReference: ["DEREF", "MAKE_REF", "REF", "REFTOHEX", "VALUE"],
    model: ["CV", "ITERATION_NUMBER", "PRESENTNNV", "PRESENTV", "PREVIOUS"]
  }, re = [
    // 'A',
    "ACCESSIBLE",
    "AGENT",
    "AGGREGATE",
    "ALL",
    "ALTER",
    "ANY",
    "ARRAY",
    "AS",
    "ASC",
    "AT",
    "ATTRIBUTE",
    "AUTHID",
    "AVG",
    "BETWEEN",
    "BFILE_BASE",
    "BINARY",
    "BINARY_INTEGER",
    "BLOB_BASE",
    "BLOCK",
    "BODY",
    "BOOLEAN",
    "BOTH",
    "BOUND",
    "BREADTH",
    "BULK",
    "BY",
    "BYTE",
    // 'C',
    "CALL",
    "CALLING",
    "CASCADE",
    "CAST",
    "CHAR",
    "CHARACTER",
    "CHARSET",
    "CHARSETFORM",
    "CHARSETID",
    "CHAR_BASE",
    "CHECK",
    "CLOB_BASE",
    "CLONE",
    "CLOSE",
    "CLUSTER",
    "CLUSTERS",
    "COALESCE",
    "COLAUTH",
    "COLLECT",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPILED",
    "COMPRESS",
    "CONNECT",
    "CONSTANT",
    "CONSTRUCTOR",
    "CONTEXT",
    "CONTINUE",
    "CONVERT",
    "COUNT",
    "CRASH",
    "CREATE",
    "CREDENTIAL",
    "CURRENT",
    "CURRVAL",
    "CURSOR",
    "CUSTOMDATUM",
    "DANGLING",
    "DATA",
    "DATE",
    "DATE_BASE",
    "DAY",
    "DECIMAL",
    "DEFAULT",
    "DEFINE",
    "DEPTH",
    "DESC",
    "DETERMINISTIC",
    "DIRECTORY",
    "DISTINCT",
    "DO",
    "DOUBLE",
    "DROP",
    "DURATION",
    "ELEMENT",
    "ELSIF",
    "EMPTY",
    "ESCAPE",
    "EXCEPTIONS",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    "EXIT",
    "EXTENDS",
    "EXTERNAL",
    "EXTRACT",
    "FALSE",
    "FETCH",
    "FINAL",
    "FIRST",
    "FIXED",
    "FLOAT",
    "FOR",
    "FORALL",
    "FORCE",
    "FUNCTION",
    "GENERAL",
    "GOTO",
    "GRANT",
    "GROUP",
    "HASH",
    "HEAP",
    "HIDDEN",
    "HOUR",
    "IDENTIFIED",
    "IF",
    "IMMEDIATE",
    "IN",
    "INCLUDING",
    "INDEX",
    "INDEXES",
    "INDICATOR",
    "INDICES",
    "INFINITE",
    "INSTANTIABLE",
    "INT",
    "INTEGER",
    "INTERFACE",
    "INTERVAL",
    "INTO",
    "INVALIDATE",
    "IS",
    "ISOLATION",
    "JAVA",
    "LANGUAGE",
    "LARGE",
    "LEADING",
    "LENGTH",
    "LEVEL",
    "LIBRARY",
    "LIKE",
    "LIKE2",
    "LIKE4",
    "LIKEC",
    "LIMITED",
    "LOCAL",
    "LOCK",
    "LONG",
    "MAP",
    "MAX",
    "MAXLEN",
    "MEMBER",
    "MERGE",
    "MIN",
    "MINUTE",
    "MLSLABEL",
    "MOD",
    "MODE",
    "MONTH",
    "MULTISET",
    "NAME",
    "NAN",
    "NATIONAL",
    "NATIVE",
    "NATURAL",
    "NATURALN",
    "NCHAR",
    "NEW",
    "NEXTVAL",
    "NOCOMPRESS",
    "NOCOPY",
    "NOT",
    "NOWAIT",
    "NULL",
    "NULLIF",
    "NUMBER",
    "NUMBER_BASE",
    "OBJECT",
    "OCICOLL",
    "OCIDATE",
    "OCIDATETIME",
    "OCIDURATION",
    "OCIINTERVAL",
    "OCILOBLOCATOR",
    "OCINUMBER",
    "OCIRAW",
    "OCIREF",
    "OCIREFCURSOR",
    "OCIROWID",
    "OCISTRING",
    "OCITYPE",
    "OF",
    "OLD",
    "ON DELETE",
    "ON UPDATE",
    "ONLY",
    "OPAQUE",
    "OPEN",
    "OPERATOR",
    "OPTION",
    "ORACLE",
    "ORADATA",
    "ORDER",
    "ORGANIZATION",
    "ORLANY",
    "ORLVARY",
    "OTHERS",
    "OUT",
    "OVERLAPS",
    "OVERRIDING",
    "PACKAGE",
    "PARALLEL_ENABLE",
    "PARAMETER",
    "PARAMETERS",
    "PARENT",
    "PARTITION",
    "PASCAL",
    "PCTFREE",
    "PIPE",
    "PIPELINED",
    "PLS_INTEGER",
    "PLUGGABLE",
    "POSITIVE",
    "POSITIVEN",
    "PRAGMA",
    "PRECISION",
    "PRIOR",
    "PRIVATE",
    "PROCEDURE",
    "PUBLIC",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "REAL",
    "RECORD",
    "REF",
    "REFERENCE",
    "RELEASE",
    "RELIES_ON",
    "REM",
    "REMAINDER",
    "RENAME",
    "RESOURCE",
    "RESULT",
    "RESULT_CACHE",
    "RETURN",
    "REVERSE",
    "REVOKE",
    "ROLLBACK",
    "ROW",
    "ROWID",
    "ROWNUM",
    "ROWTYPE",
    "SAMPLE",
    "SAVE",
    "SAVEPOINT",
    "SB1",
    "SB2",
    "SB4",
    "SEARCH",
    "SECOND",
    "SEGMENT",
    "SELF",
    "SEPARATE",
    "SEQUENCE",
    "SERIALIZABLE",
    "SHARE",
    "SHORT",
    "SIZE",
    "SIZE_T",
    "SMALLINT",
    "SOME",
    "SPACE",
    "SPARSE",
    "SQL",
    "SQLCODE",
    "SQLDATA",
    "SQLERRM",
    "SQLNAME",
    "SQLSTATE",
    "STANDARD",
    "START",
    "STATIC",
    "STDDEV",
    "STORED",
    "STRING",
    "STRUCT",
    "STYLE",
    "SUBMULTISET",
    "SUBPARTITION",
    "SUBSTITUTABLE",
    "SUBTYPE",
    "SUCCESSFUL",
    "SUM",
    "SYNONYM",
    "SYSDATE",
    "TABAUTH",
    "TABLE",
    "TDO",
    "THE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_ABBR",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TIMEZONE_REGION",
    "TO",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONAL",
    "TRIGGER",
    "TRUE",
    "TRUSTED",
    "TYPE",
    "UB1",
    "UB2",
    "UB4",
    "UID",
    "UNDER",
    "UNIQUE",
    "UNPLUG",
    "UNSIGNED",
    "UNTRUSTED",
    "USE",
    "USER",
    "VALIDATE",
    "VALIST",
    "VALUE",
    "VARCHAR",
    "VARCHAR2",
    "VARIABLE",
    "VARIANCE",
    "VARRAY",
    "VARYING",
    "VIEW",
    "VIEWS",
    "VOID",
    "WHENEVER",
    "WHILE",
    "WORK",
    "WRAPPED",
    "WRITE",
    "YEAR",
    "ZONE"
  ], B = [
    "ADD",
    "ALTER COLUMN",
    "ALTER TABLE",
    "BEGIN",
    "CONNECT BY",
    "CREATE TABLE",
    // verify
    "DROP TABLE",
    // verify
    "DECLARE",
    "DELETE",
    "DELETE FROM",
    "EXCEPT",
    "EXCEPTION",
    "FETCH FIRST",
    "FROM",
    "GROUP BY",
    "HAVING",
    "INSERT INTO",
    "INSERT",
    "LIMIT",
    "OFFSET",
    "LOOP",
    "MODIFY",
    "ORDER BY",
    "RETURNING",
    "SELECT",
    "SET CURRENT SCHEMA",
    "SET SCHEMA",
    "SET",
    "START WITH",
    "UPDATE",
    "VALUES",
    "WHERE",
    "WITH"
  ], Y = [
    // set booleans
    "INTERSECT",
    "INTERSECT ALL",
    "INTERSECT DISTINCT",
    "UNION",
    "UNION ALL",
    "UNION DISTINCT",
    "EXCEPT",
    "EXCEPT ALL",
    "EXCEPT DISTINCT",
    "MINUS",
    "MINUS ALL",
    "MINUS DISTINCT",
    // apply
    "CROSS APPLY",
    "OUTER APPLY"
  ], E = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN", "NATURAL JOIN"], m = ["WHEN", "ELSE"], P = function(A) {
    V(C, A);
    var y2 = $(C);
    function C() {
      return D(this, C), y2.apply(this, arguments);
    }
    return x(C, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: B,
          reservedBinaryCommands: Y,
          reservedJoins: E,
          reservedDependentClauses: m,
          reservedLogicalOperators: ["AND", "OR", "XOR"],
          reservedKeywords: (0, s.dedupe)([].concat(re, f(Object.values(H).flat()))),
          // TODO: support custom-delimited strings: Q'{..}' q'<..>' etc
          stringTypes: [{
            quote: "''",
            prefixes: ["N"]
          }],
          identTypes: ['""'],
          identChars: {
            rest: "$#"
          },
          variableTypes: [{
            regex: "&{1,2}[A-Za-z][A-Za-z0-9_$#]*"
          }],
          numberedParamTypes: [":"],
          namedParamTypes: [":"],
          paramChars: {},
          // Empty object used on purpose to not allow $ and # chars as specified in identChars
          operators: C.operators,
          postProcess: R
        });
      }
    }]), C;
  }(i.default);
  t.default = P, G(P, "operators", [
    "||",
    "**",
    ":=",
    "~=",
    "^=",
    ">>",
    "<<",
    "=>"
    //  '..' // breaks operator test, handled by .
  ]);
  function R(A) {
    var y2 = a.EOF_TOKEN;
    return A.map(function(C) {
      return a.isToken.SET(C) && a.isToken.BY(y2) ? c(c({}, C), {}, {
        type: a.TokenType.RESERVED_KEYWORD
      }) : ((0, a.isReserved)(C) && (y2 = C), C);
    });
  }
  e.exports = t.default;
})(Zl, Zl.exports);
var V_ = Zl.exports;
var Hl = { exports: {} };
(function(e, t) {
  function r(m) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(P) {
      return typeof P;
    } : function(P) {
      return P && typeof Symbol == "function" && P.constructor === Symbol && P !== Symbol.prototype ? "symbol" : typeof P;
    }, r(m);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function o(m) {
    return p(m) || f(m) || c(m) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(m, P) {
    if (m) {
      if (typeof m == "string")
        return O(m, P);
      var R = Object.prototype.toString.call(m).slice(8, -1);
      if (R === "Object" && m.constructor && (R = m.constructor.name), R === "Map" || R === "Set")
        return Array.from(m);
      if (R === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(R))
        return O(m, P);
    }
  }
  function f(m) {
    if (typeof Symbol < "u" && m[Symbol.iterator] != null || m["@@iterator"] != null)
      return Array.from(m);
  }
  function p(m) {
    if (Array.isArray(m))
      return O(m);
  }
  function O(m, P) {
    (P == null || P > m.length) && (P = m.length);
    for (var R = 0, A = new Array(P); R < P; R++)
      A[R] = m[R];
    return A;
  }
  function d2(m, P) {
    if (!(m instanceof P))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(m, P) {
    for (var R = 0; R < P.length; R++) {
      var A = P[R];
      A.enumerable = A.enumerable || false, A.configurable = true, "value" in A && (A.writable = true), Object.defineProperty(m, A.key, A);
    }
  }
  function L(m, P, R) {
    return P && g(m.prototype, P), R && g(m, R), Object.defineProperty(m, "prototype", { writable: false }), m;
  }
  function D(m, P) {
    if (typeof P != "function" && P !== null)
      throw new TypeError("Super expression must either be null or a function");
    m.prototype = Object.create(P && P.prototype, { constructor: { value: m, writable: true, configurable: true } }), Object.defineProperty(m, "prototype", { writable: false }), P && W(m, P);
  }
  function W(m, P) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(A, y2) {
      return A.__proto__ = y2, A;
    }, W(m, P);
  }
  function x(m) {
    var P = $();
    return function() {
      var A = z(m), y2;
      if (P) {
        var C = z(this).constructor;
        y2 = Reflect.construct(A, arguments, C);
      } else
        y2 = A.apply(this, arguments);
      return V(this, y2);
    };
  }
  function V(m, P) {
    if (P && (r(P) === "object" || typeof P == "function"))
      return P;
    if (P !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(m);
  }
  function _2(m) {
    if (m === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return m;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(m) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(R) {
      return R.__proto__ || Object.getPrototypeOf(R);
    }, z(m);
  }
  function F(m, P, R) {
    return P in m ? Object.defineProperty(m, P, { value: R, enumerable: true, configurable: true, writable: true }) : m[P] = R, m;
  }
  var ae = {
    // https://www.postgresql.org/docs/14/functions-math.html
    math: ["ABS", "ACOS", "ACOSD", "ACOSH", "ASIN", "ASIND", "ASINH", "ATAN", "ATAN2", "ATAN2D", "ATAND", "ATANH", "CBRT", "CEIL", "CEILING", "COS", "COSD", "COSH", "COT", "COTD", "DEGREES", "DIV", "EXP", "FACTORIAL", "FLOOR", "GCD", "LCM", "LN", "LOG", "LOG10", "MIN_SCALE", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SCALE", "SETSEED", "SIGN", "SIN", "SIND", "SINH", "SQRT", "TAN", "TAND", "TANH", "TRIM_SCALE", "TRUNC", "WIDTH_BUCKET"],
    // https://www.postgresql.org/docs/14/functions-string.html
    string: ["ABS", "ASCII", "BIT_LENGTH", "BTRIM", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "FORMAT", "INITCAP", "LEFT", "LENGTH", "LOWER", "LPAD", "LTRIM", "MD5", "NORMALIZE", "OCTET_LENGTH", "OVERLAY", "PARSE_IDENT", "PG_CLIENT_ENCODING", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "QUOTE_NULLABLE", "REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SPLIT_PART", "SPRINTF", "STARTS_WITH", "STRING_AGG", "STRING_TO_ARRAY", "STRING_TO_TABLE", "STRPOS", "SUBSTR", "SUBSTRING", "TO_ASCII", "TO_HEX", "TRANSLATE", "TRIM", "UNISTR", "UPPER"],
    // https://www.postgresql.org/docs/14/functions-binarystring.html
    binary: ["BIT_COUNT", "BIT_LENGTH", "BTRIM", "CONVERT", "CONVERT_FROM", "CONVERT_TO", "DECODE", "ENCODE", "GET_BIT", "GET_BYTE", "LENGTH", "LTRIM", "MD5", "OCTET_LENGTH", "OVERLAY", "POSITION", "RTRIM", "SET_BIT", "SET_BYTE", "SHA224", "SHA256", "SHA384", "SHA512", "STRING_AGG", "SUBSTR", "SUBSTRING", "TRIM"],
    // https://www.postgresql.org/docs/14/functions-bitstring.html
    bitstring: ["BIT_COUNT", "BIT_LENGTH", "GET_BIT", "LENGTH", "OCTET_LENGTH", "OVERLAY", "POSITION", "SET_BIT", "SUBSTRING"],
    // https://www.postgresql.org/docs/14/functions-matching.html
    pattern: ["REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE"],
    // https://www.postgresql.org/docs/14/functions-formatting.html
    datatype: ["TO_CHAR", "TO_DATE", "TO_NUMBER", "TO_TIMESTAMP"],
    // https://www.postgresql.org/docs/14/functions-datetime.html
    datetime: [
      // 'AGE',
      "CLOCK_TIMESTAMP",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "DATE_BIN",
      "DATE_PART",
      "DATE_TRUNC",
      "EXTRACT",
      "ISFINITE",
      "JUSTIFY_DAYS",
      "JUSTIFY_HOURS",
      "JUSTIFY_INTERVAL",
      "LOCALTIME",
      "LOCALTIMESTAMP",
      "MAKE_DATE",
      "MAKE_INTERVAL",
      "MAKE_TIME",
      "MAKE_TIMESTAMP",
      "MAKE_TIMESTAMPTZ",
      "NOW",
      "PG_SLEEP",
      "PG_SLEEP_FOR",
      "PG_SLEEP_UNTIL",
      "STATEMENT_TIMESTAMP",
      "TIMEOFDAY",
      "TO_TIMESTAMP",
      "TRANSACTION_TIMESTAMP"
    ],
    // https://www.postgresql.org/docs/14/functions-enum.html
    enum: ["ENUM_FIRST", "ENUM_LAST", "ENUM_RANGE"],
    // https://www.postgresql.org/docs/14/functions-geometry.html
    geometry: ["AREA", "BOUND_BOX", "BOX", "CENTER", "CIRCLE", "DIAGONAL", "DIAMETER", "HEIGHT", "ISCLOSED", "ISOPEN", "LENGTH", "LINE", "LSEG", "NPOINTS", "PATH", "PCLOSE", "POINT", "POLYGON", "POPEN", "RADIUS", "SLOPE", "WIDTH"],
    // https://www.postgresql.org/docs/14/functions-net.html
    network: ["ABBREV", "BROADCAST", "FAMILY", "HOST", "HOSTMASK", "INET_MERGE", "INET_SAME_FAMILY", "MACADDR8_SET7BIT", "MASKLEN", "NETMASK", "NETWORK", "SET_MASKLEN", "TEXT", "TRUNC"],
    // https://www.postgresql.org/docs/14/functions-textsearch.html
    textsearch: ["ARRAY_TO_TSVECTOR", "GET_CURRENT_TS_CONFIG", "JSONB_TO_TSVECTOR", "JSON_TO_TSVECTOR", "LENGTH", "NUMNODE", "PHRASETO_TSQUERY", "PLAINTO_TSQUERY", "QUERYTREE", "SETWEIGHT", "STRIP", "TO_TSQUERY", "TO_TSVECTOR", "TSQUERY_PHRASE", "TSVECTOR_TO_ARRAY", "TS_DEBUG", "TS_DELETE", "TS_FILTER", "TS_HEADLINE", "TS_LEXIZE", "TS_PARSE", "TS_RANK", "TS_RANK_CD", "TS_REWRITE", "TS_STAT", "TS_TOKEN_TYPE", "WEBSEARCH_TO_TSQUERY"],
    // https://www.postgresql.org/docs/14/functions-uuid.html
    uuid: ["UUID"],
    // https://www.postgresql.org/docs/14/functions-xml.html
    xml: ["CURSOR_TO_XML", "CURSOR_TO_XMLSCHEMA", "DATABASE_TO_XML", "DATABASE_TO_XMLSCHEMA", "DATABASE_TO_XML_AND_XMLSCHEMA", "NEXTVAL", "QUERY_TO_XML", "QUERY_TO_XMLSCHEMA", "QUERY_TO_XML_AND_XMLSCHEMA", "SCHEMA_TO_XML", "SCHEMA_TO_XMLSCHEMA", "SCHEMA_TO_XML_AND_XMLSCHEMA", "STRING", "TABLE_TO_XML", "TABLE_TO_XMLSCHEMA", "TABLE_TO_XML_AND_XMLSCHEMA", "XMLAGG", "XMLCOMMENT", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "XML_IS_WELL_FORMED", "XML_IS_WELL_FORMED_CONTENT", "XML_IS_WELL_FORMED_DOCUMENT", "XPATH", "XPATH_EXISTS"],
    // https://www.postgresql.org/docs/14/functions-json.html
    json: ["ARRAY_TO_JSON", "JSONB_AGG", "JSONB_ARRAY_ELEMENTS", "JSONB_ARRAY_ELEMENTS_TEXT", "JSONB_ARRAY_LENGTH", "JSONB_BUILD_ARRAY", "JSONB_BUILD_OBJECT", "JSONB_EACH", "JSONB_EACH_TEXT", "JSONB_EXTRACT_PATH", "JSONB_EXTRACT_PATH_TEXT", "JSONB_INSERT", "JSONB_OBJECT", "JSONB_OBJECT_AGG", "JSONB_OBJECT_KEYS", "JSONB_PATH_EXISTS", "JSONB_PATH_EXISTS_TZ", "JSONB_PATH_MATCH", "JSONB_PATH_MATCH_TZ", "JSONB_PATH_QUERY", "JSONB_PATH_QUERY_ARRAY", "JSONB_PATH_QUERY_ARRAY_TZ", "JSONB_PATH_QUERY_FIRST", "JSONB_PATH_QUERY_FIRST_TZ", "JSONB_PATH_QUERY_TZ", "JSONB_POPULATE_RECORD", "JSONB_POPULATE_RECORDSET", "JSONB_PRETTY", "JSONB_SET", "JSONB_SET_LAX", "JSONB_STRIP_NULLS", "JSONB_TO_RECORD", "JSONB_TO_RECORDSET", "JSONB_TYPEOF", "JSON_AGG", "JSON_ARRAY_ELEMENTS", "JSON_ARRAY_ELEMENTS_TEXT", "JSON_ARRAY_LENGTH", "JSON_BUILD_ARRAY", "JSON_BUILD_OBJECT", "JSON_EACH", "JSON_EACH_TEXT", "JSON_EXTRACT_PATH", "JSON_EXTRACT_PATH_TEXT", "JSON_OBJECT", "JSON_OBJECT_AGG", "JSON_OBJECT_KEYS", "JSON_POPULATE_RECORD", "JSON_POPULATE_RECORDSET", "JSON_STRIP_NULLS", "JSON_TO_RECORD", "JSON_TO_RECORDSET", "JSON_TYPEOF", "ROW_TO_JSON", "TO_JSON", "TO_JSONB", "TO_TIMESTAMP"],
    // https://www.postgresql.org/docs/14/functions-sequence.html
    sequence: ["CURRVAL", "LASTVAL", "NEXTVAL", "SETVAL"],
    // https://www.postgresql.org/docs/14/functions-conditional.html
    conditional: [
      // 'CASE',
      "COALESCE",
      "GREATEST",
      "LEAST",
      "NULLIF"
    ],
    // https://www.postgresql.org/docs/14/functions-array.html
    array: ["ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_DIMS", "ARRAY_FILL", "ARRAY_LENGTH", "ARRAY_LOWER", "ARRAY_NDIMS", "ARRAY_POSITION", "ARRAY_POSITIONS", "ARRAY_PREPEND", "ARRAY_REMOVE", "ARRAY_REPLACE", "ARRAY_TO_STRING", "ARRAY_UPPER", "CARDINALITY", "STRING_TO_ARRAY", "TRIM_ARRAY", "UNNEST"],
    // https://www.postgresql.org/docs/14/functions-range.html
    range: ["ISEMPTY", "LOWER", "LOWER_INC", "LOWER_INF", "MULTIRANGE", "RANGE_MERGE", "UPPER", "UPPER_INC", "UPPER_INF"],
    // https://www.postgresql.org/docs/14/functions-aggregate.html
    aggregate: ["ANY", "ARRAY_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_OR", "COALESCE", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "EVERY", "GROUPING", "JSONB_AGG", "JSONB_OBJECT_AGG", "JSON_AGG", "JSON_OBJECT_AGG", "MAX", "MIN", "MODE", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANGE_AGG", "RANGE_INTERSECT_AGG", "RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "SOME", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "TO_JSON", "TO_JSONB", "VARIANCE", "VAR_POP", "VAR_SAMP", "XMLAGG"],
    // https://www.postgresql.org/docs/14/functions-window.html
    window: ["CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
    // https://www.postgresql.org/docs/14/functions-srf.html
    set: ["GENERATE_SERIES", "GENERATE_SUBSCRIPTS"],
    // https://www.postgresql.org/docs/14/functions-info.html
    sysInfo: ["ACLDEFAULT", "ACLEXPLODE", "COL_DESCRIPTION", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_QUERY", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "FORMAT_TYPE", "HAS_ANY_COLUMN_PRIVILEGE", "HAS_COLUMN_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE", "HAS_FUNCTION_PRIVILEGE", "HAS_LANGUAGE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_SEQUENCE_PRIVILEGE", "HAS_SERVER_PRIVILEGE", "HAS_TABLESPACE_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "HAS_TYPE_PRIVILEGE", "INET_CLIENT_ADDR", "INET_CLIENT_PORT", "INET_SERVER_ADDR", "INET_SERVER_PORT", "MAKEACLITEM", "OBJ_DESCRIPTION", "PG_BACKEND_PID", "PG_BLOCKING_PIDS", "PG_COLLATION_IS_VISIBLE", "PG_CONF_LOAD_TIME", "PG_CONTROL_CHECKPOINT", "PG_CONTROL_INIT", "PG_CONTROL_SYSTEM", "PG_CONVERSION_IS_VISIBLE", "PG_CURRENT_LOGFILE", "PG_CURRENT_SNAPSHOT", "PG_CURRENT_XACT_ID", "PG_CURRENT_XACT_ID_IF_ASSIGNED", "PG_DESCRIBE_OBJECT", "PG_FUNCTION_IS_VISIBLE", "PG_GET_CATALOG_FOREIGN_KEYS", "PG_GET_CONSTRAINTDEF", "PG_GET_EXPR", "PG_GET_FUNCTIONDEF", "PG_GET_FUNCTION_ARGUMENTS", "PG_GET_FUNCTION_IDENTITY_ARGUMENTS", "PG_GET_FUNCTION_RESULT", "PG_GET_INDEXDEF", "PG_GET_KEYWORDS", "PG_GET_OBJECT_ADDRESS", "PG_GET_OWNED_SEQUENCE", "PG_GET_RULEDEF", "PG_GET_SERIAL_SEQUENCE", "PG_GET_STATISTICSOBJDEF", "PG_GET_TRIGGERDEF", "PG_GET_USERBYID", "PG_GET_VIEWDEF", "PG_HAS_ROLE", "PG_IDENTIFY_OBJECT", "PG_IDENTIFY_OBJECT_AS_ADDRESS", "PG_INDEXAM_HAS_PROPERTY", "PG_INDEX_COLUMN_HAS_PROPERTY", "PG_INDEX_HAS_PROPERTY", "PG_IS_OTHER_TEMP_SCHEMA", "PG_JIT_AVAILABLE", "PG_LAST_COMMITTED_XACT", "PG_LISTENING_CHANNELS", "PG_MY_TEMP_SCHEMA", "PG_NOTIFICATION_QUEUE_USAGE", "PG_OPCLASS_IS_VISIBLE", "PG_OPERATOR_IS_VISIBLE", "PG_OPFAMILY_IS_VISIBLE", "PG_OPTIONS_TO_TABLE", "PG_POSTMASTER_START_TIME", "PG_SAFE_SNAPSHOT_BLOCKING_PIDS", "PG_SNAPSHOT_XIP", "PG_SNAPSHOT_XMAX", "PG_SNAPSHOT_XMIN", "PG_STATISTICS_OBJ_IS_VISIBLE", "PG_TABLESPACE_DATABASES", "PG_TABLESPACE_LOCATION", "PG_TABLE_IS_VISIBLE", "PG_TRIGGER_DEPTH", "PG_TS_CONFIG_IS_VISIBLE", "PG_TS_DICT_IS_VISIBLE", "PG_TS_PARSER_IS_VISIBLE", "PG_TS_TEMPLATE_IS_VISIBLE", "PG_TYPEOF", "PG_TYPE_IS_VISIBLE", "PG_VISIBLE_IN_SNAPSHOT", "PG_XACT_COMMIT_TIMESTAMP", "PG_XACT_COMMIT_TIMESTAMP_ORIGIN", "PG_XACT_STATUS", "PQSERVERVERSION", "ROW_SECURITY_ACTIVE", "SESSION_USER", "SHOBJ_DESCRIPTION", "TO_REGCLASS", "TO_REGCOLLATION", "TO_REGNAMESPACE", "TO_REGOPER", "TO_REGOPERATOR", "TO_REGPROC", "TO_REGPROCEDURE", "TO_REGROLE", "TO_REGTYPE", "TXID_CURRENT", "TXID_CURRENT_IF_ASSIGNED", "TXID_CURRENT_SNAPSHOT", "TXID_SNAPSHOT_XIP", "TXID_SNAPSHOT_XMAX", "TXID_SNAPSHOT_XMIN", "TXID_STATUS", "TXID_VISIBLE_IN_SNAPSHOT", "USER", "VERSION"],
    // https://www.postgresql.org/docs/14/functions-admin.html
    sysAdmin: ["BRIN_DESUMMARIZE_RANGE", "BRIN_SUMMARIZE_NEW_VALUES", "BRIN_SUMMARIZE_RANGE", "CONVERT_FROM", "CURRENT_SETTING", "GIN_CLEAN_PENDING_LIST", "PG_ADVISORY_LOCK", "PG_ADVISORY_LOCK_SHARED", "PG_ADVISORY_UNLOCK", "PG_ADVISORY_UNLOCK_ALL", "PG_ADVISORY_UNLOCK_SHARED", "PG_ADVISORY_XACT_LOCK", "PG_ADVISORY_XACT_LOCK_SHARED", "PG_BACKUP_START_TIME", "PG_CANCEL_BACKEND", "PG_COLLATION_ACTUAL_VERSION", "PG_COLUMN_COMPRESSION", "PG_COLUMN_SIZE", "PG_COPY_LOGICAL_REPLICATION_SLOT", "PG_COPY_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_LOGICAL_REPLICATION_SLOT", "PG_CREATE_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_RESTORE_POINT", "PG_CURRENT_WAL_FLUSH_LSN", "PG_CURRENT_WAL_INSERT_LSN", "PG_CURRENT_WAL_LSN", "PG_DATABASE_SIZE", "PG_DROP_REPLICATION_SLOT", "PG_EXPORT_SNAPSHOT", "PG_FILENODE_RELATION", "PG_GET_WAL_REPLAY_PAUSE_STATE", "PG_IMPORT_SYSTEM_COLLATIONS", "PG_INDEXES_SIZE", "PG_IS_IN_BACKUP", "PG_IS_IN_RECOVERY", "PG_IS_WAL_REPLAY_PAUSED", "PG_LAST_WAL_RECEIVE_LSN", "PG_LAST_WAL_REPLAY_LSN", "PG_LAST_XACT_REPLAY_TIMESTAMP", "PG_LOGICAL_EMIT_MESSAGE", "PG_LOGICAL_SLOT_GET_BINARY_CHANGES", "PG_LOGICAL_SLOT_GET_CHANGES", "PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES", "PG_LOGICAL_SLOT_PEEK_CHANGES", "PG_LOG_BACKEND_MEMORY_CONTEXTS", "PG_LS_ARCHIVE_STATUSDIR", "PG_LS_DIR", "PG_LS_LOGDIR", "PG_LS_TMPDIR", "PG_LS_WALDIR", "PG_PARTITION_ANCESTORS", "PG_PARTITION_ROOT", "PG_PARTITION_TREE", "PG_PROMOTE", "PG_READ_BINARY_FILE", "PG_READ_FILE", "PG_RELATION_FILENODE", "PG_RELATION_FILEPATH", "PG_RELATION_SIZE", "PG_RELOAD_CONF", "PG_REPLICATION_ORIGIN_ADVANCE", "PG_REPLICATION_ORIGIN_CREATE", "PG_REPLICATION_ORIGIN_DROP", "PG_REPLICATION_ORIGIN_OID", "PG_REPLICATION_ORIGIN_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_IS_SETUP", "PG_REPLICATION_ORIGIN_SESSION_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_RESET", "PG_REPLICATION_ORIGIN_SESSION_SETUP", "PG_REPLICATION_ORIGIN_XACT_RESET", "PG_REPLICATION_ORIGIN_XACT_SETUP", "PG_REPLICATION_SLOT_ADVANCE", "PG_ROTATE_LOGFILE", "PG_SIZE_BYTES", "PG_SIZE_PRETTY", "PG_START_BACKUP", "PG_STAT_FILE", "PG_STOP_BACKUP", "PG_SWITCH_WAL", "PG_TABLESPACE_SIZE", "PG_TABLE_SIZE", "PG_TERMINATE_BACKEND", "PG_TOTAL_RELATION_SIZE", "PG_TRY_ADVISORY_LOCK", "PG_TRY_ADVISORY_LOCK_SHARED", "PG_TRY_ADVISORY_XACT_LOCK", "PG_TRY_ADVISORY_XACT_LOCK_SHARED", "PG_WALFILE_NAME", "PG_WALFILE_NAME_OFFSET", "PG_WAL_LSN_DIFF", "PG_WAL_REPLAY_PAUSE", "PG_WAL_REPLAY_RESUME", "SET_CONFIG"],
    // https://www.postgresql.org/docs/14/functions-trigger.html
    trigger: ["SUPPRESS_REDUNDANT_UPDATES_TRIGGER", "TSVECTOR_UPDATE_TRIGGER", "TSVECTOR_UPDATE_TRIGGER_COLUMN"],
    // https://www.postgresql.org/docs/14/functions-event-triggers.html
    eventTrigger: ["PG_EVENT_TRIGGER_DDL_COMMANDS", "PG_EVENT_TRIGGER_DROPPED_OBJECTS", "PG_EVENT_TRIGGER_TABLE_REWRITE_OID", "PG_EVENT_TRIGGER_TABLE_REWRITE_REASON", "PG_GET_OBJECT_ADDRESS"],
    // https://www.postgresql.org/docs/14/functions-statistics.html
    stats: ["PG_MCV_LIST_ITEMS"]
  }, U = [
    "ABSENT",
    "ABSOLUTE",
    "ACCESS",
    "ACCORDING",
    "ACTION",
    "ADA",
    "ADMIN",
    "AGGREGATE",
    "ALL",
    "ALLOCATE",
    "ALSO",
    "ALTER",
    "ALWAYS",
    "ANALYSE",
    "ARE",
    "ARRAY",
    "ARRAY_MAX_CARDINALITY",
    "AS",
    "ASC",
    "ASENSITIVE",
    "ASSERTION",
    "ASSIGNMENT",
    "ASYMMETRIC",
    "AT",
    "ATOMIC",
    "ATTACH",
    "ATTRIBUTE",
    "ATTRIBUTES",
    "AUTHORIZATION",
    "BACKWARD",
    "BASE64",
    "BEFORE",
    "BEGIN_FRAME",
    "BEGIN_PARTITION",
    "BERNOULLI",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BIT",
    "BLOB",
    "BLOCKED",
    "BOM",
    "BOOLEAN",
    "BOTH",
    "BREADTH",
    "BY",
    "CACHE",
    "CALLED",
    "CASCADE",
    "CASCADED",
    "CAST",
    "CATALOG",
    "CATALOG_NAME",
    "CHAIN",
    "CHAINING",
    "CHAR",
    "CHARACTER",
    "CHARACTERISTICS",
    "CHARACTERS",
    "CHARACTER_SET_CATALOG",
    "CHARACTER_SET_NAME",
    "CHARACTER_SET_SCHEMA",
    "CHECK",
    "CLASS",
    "CLASSIFIER",
    "CLASS_ORIGIN",
    "CLOB",
    "COBOL",
    "COLLATE",
    "COLLATION",
    "COLLATION_CATALOG",
    "COLLATION_NAME",
    "COLLATION_SCHEMA",
    "COLLECT",
    "COLUMN",
    "COLUMNS",
    "COLUMN_NAME",
    "COMMAND_FUNCTION",
    "COMMAND_FUNCTION_CODE",
    "COMMENTS",
    "COMMITTED",
    "COMPRESSION",
    "CONCURRENTLY",
    "CONDITION",
    "CONDITIONAL",
    "CONDITION_NUMBER",
    "CONFIGURATION",
    "CONFLICT",
    "CONNECT",
    "CONNECTION",
    "CONNECTION_NAME",
    "CONSTRAINT",
    "CONSTRAINTS",
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONSTRUCTOR",
    "CONTAINS",
    "CONTENT",
    "CONTINUE",
    "CONTROL",
    "CONVERSION",
    "CORRESPONDING",
    "COST",
    "CREATE",
    "CROSS",
    "CSV",
    "CUBE",
    "CURRENT",
    "CURRENT_DEFAULT_TRANSFORM_GROUP",
    "CURRENT_PATH",
    "CURRENT_ROW",
    "CURRENT_TRANSFORM_GROUP_FOR_TYPE",
    "CURSOR",
    "CURSOR_NAME",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DATALINK",
    "DATE",
    "DATETIME_INTERVAL_CODE",
    "DATETIME_INTERVAL_PRECISION",
    "DAY",
    "DB",
    "DEC",
    "DECFLOAT",
    "DECIMAL",
    "DEFAULT",
    "DEFAULTS",
    "DEFERRABLE",
    "DEFERRED",
    "DEFINE",
    "DEFINED",
    "DEFINER",
    "DEGREE",
    "DELIMITER",
    "DELIMITERS",
    "DEPENDS",
    "DEPTH",
    "DEREF",
    "DERIVED",
    "DESC",
    "DESCRIBE",
    "DESCRIPTOR",
    "DETACH",
    "DETERMINISTIC",
    "DIAGNOSTICS",
    "DICTIONARY",
    "DISABLE",
    "DISCONNECT",
    "DISPATCH",
    "DISTINCT",
    "DLNEWCOPY",
    "DLPREVIOUSCOPY",
    "DLURLCOMPLETE",
    "DLURLCOMPLETEONLY",
    "DLURLCOMPLETEWRITE",
    "DLURLPATH",
    "DLURLPATHONLY",
    "DLURLPATHWRITE",
    "DLURLSCHEME",
    "DLURLSERVER",
    "DLVALUE",
    "DOCUMENT",
    "DOMAIN",
    "DOUBLE",
    "DROP",
    "DYNAMIC",
    "DYNAMIC_FUNCTION",
    "DYNAMIC_FUNCTION_CODE",
    "EACH",
    "ELEMENT",
    "EMPTY",
    "ENABLE",
    "ENCODING",
    "ENCRYPTED",
    "END-EXEC",
    "END_FRAME",
    "END_PARTITION",
    "ENFORCED",
    "ENUM",
    "EQUALS",
    "ERROR",
    "ESCAPE",
    "EVENT",
    "EXCEPTION",
    "EXCLUDE",
    "EXCLUDING",
    "EXCLUSIVE",
    "EXEC",
    "EXISTS",
    "EXPRESSION",
    "EXTENSION",
    "EXTERNAL",
    "FALSE",
    "FILE",
    "FILTER",
    "FINAL",
    "FINALIZE",
    "FINISH",
    "FIRST",
    "FLAG",
    "FLOAT",
    "FOLLOWING",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FORTRAN",
    "FORWARD",
    "FOUND",
    "FRAME_ROW",
    "FREE",
    "FREEZE",
    "FS",
    "FULFILL",
    "FULL",
    "FUNCTION",
    "FUNCTIONS",
    "FUSION",
    "GENERAL",
    "GENERATED",
    "GET",
    "GLOBAL",
    "GO",
    "GOTO",
    "GRANTED",
    "GROUP",
    "GROUPS",
    "HANDLER",
    "HEADER",
    "HEX",
    "HIERARCHY",
    "HOLD",
    "HOUR",
    // 'ID',
    "IDENTITY",
    "IF",
    "IGNORE",
    "ILIKE",
    "IMMEDIATE",
    "IMMEDIATELY",
    "IMMUTABLE",
    "IMPLEMENTATION",
    "IMPLICIT",
    "IMPORT",
    "IN",
    "INCLUDE",
    "INCLUDING",
    "INCREMENT",
    "INDENT",
    "INDEX",
    "INDEXES",
    "INDICATOR",
    "INHERIT",
    "INHERITS",
    "INITIAL",
    "INITIALLY",
    "INLINE",
    "INNER",
    "INOUT",
    "INPUT",
    "INSENSITIVE",
    "INSTANCE",
    "INSTANTIABLE",
    "INSTEAD",
    "INT",
    "INTEGER",
    "INTEGRITY",
    "INTERSECTION",
    "INTERVAL",
    "INTO",
    "INVOKER",
    "IS",
    "ISNULL",
    "ISOLATION",
    "JSON",
    "JSON_ARRAY",
    "JSON_ARRAYAGG",
    "JSON_EXISTS",
    "JSON_OBJECTAGG",
    "JSON_QUERY",
    "JSON_TABLE",
    "JSON_TABLE_PRIMITIVE",
    "JSON_VALUE",
    "KEEP",
    "KEY",
    "KEYS",
    "KEY_MEMBER",
    "KEY_TYPE",
    "LABEL",
    "LANGUAGE",
    "LARGE",
    "LAST",
    "LATERAL",
    "LEADING",
    "LEAKPROOF",
    "LEVEL",
    "LIBRARY",
    "LIKE",
    "LIKE_REGEX",
    "LINK",
    "LISTAGG",
    "LOCAL",
    "LOCATION",
    "LOCATOR",
    "LOCKED",
    "LOGGED",
    "MAP",
    "MAPPING",
    "MATCH",
    "MATCHED",
    "MATCHES",
    "MATCH_NUMBER",
    "MATCH_RECOGNIZE",
    "MATERIALIZED",
    "MAXVALUE",
    "MEASURES",
    "MEMBER",
    "MERGE",
    "MESSAGE_LENGTH",
    "MESSAGE_OCTET_LENGTH",
    "MESSAGE_TEXT",
    "METHOD",
    "MINUTE",
    "MINVALUE",
    "MODIFIES",
    "MODULE",
    "MONTH",
    "MORE",
    "MULTISET",
    "MUMPS",
    "NAME",
    "NAMES",
    "NAMESPACE",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NCLOB",
    "NESTED",
    "NESTING",
    "NEW",
    "NEXT",
    "NFC",
    "NFD",
    "NFKC",
    "NFKD",
    "NIL",
    "NO",
    "NONE",
    "NORMALIZED",
    "NOT",
    "NOTHING",
    "NOTNULL",
    "NOWAIT",
    "NULL",
    "NULLABLE",
    "NULLS",
    "NUMBER",
    "NUMERIC",
    "OBJECT",
    "OCCURRENCES_REGEX",
    "OCTETS",
    "OF",
    "OFF",
    "OFFSET",
    "OIDS",
    "OLD",
    "OMIT",
    "ON COMMIT",
    "ON DELETE",
    "ON UPDATE",
    "ONE",
    "ONLY",
    "OPEN",
    "OPERATOR",
    "OPTION",
    "OPTIONS",
    "ORDER",
    "ORDERING",
    "ORDINALITY",
    "OTHERS",
    "OUT",
    "OUTER",
    "OUTPUT",
    "OVER",
    "OVERFLOW",
    "OVERLAPS",
    "OVERRIDING",
    "OWNED",
    "OWNER",
    "PAD",
    "PARALLEL",
    "PARAMETER",
    "PARAMETER_MODE",
    "PARAMETER_NAME",
    "PARAMETER_ORDINAL_POSITION",
    "PARAMETER_SPECIFIC_CATALOG",
    "PARAMETER_SPECIFIC_NAME",
    "PARAMETER_SPECIFIC_SCHEMA",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    "PASCAL",
    "PASS",
    "PASSING",
    "PASSTHROUGH",
    "PASSWORD",
    "PAST",
    "PATTERN",
    "PER",
    "PERCENT",
    "PERIOD",
    "PERMISSION",
    "PERMUTE",
    "PLACING",
    "PLAN",
    "PLANS",
    "PLI",
    "POLICY",
    "PORTION",
    "POSITION_REGEX",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    "PREPARED",
    "PRESERVE",
    "PRIMARY",
    "PRIOR",
    "PRIVATE",
    "PRIVILEGES",
    "PROCEDURAL",
    "PROCEDURE",
    "PROCEDURES",
    "PROGRAM",
    "PRUNE",
    "PTF",
    "PUBLIC",
    "PUBLICATION",
    "QUOTE",
    "QUOTES",
    "RANGE",
    "READ",
    "READS",
    "REAL",
    "REASSIGN",
    "RECHECK",
    "RECOVERY",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    "REFERENCING",
    "REFRESH",
    "RELATIVE",
    "RELEASE",
    "RENAME",
    "REPEATABLE",
    "REPLICA",
    "REQUIRING",
    "RESPECT",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    "RESULT",
    "RETURN",
    "RETURNED_CARDINALITY",
    "RETURNED_LENGTH",
    "RETURNED_OCTET_LENGTH",
    "RETURNED_SQLSTATE",
    "RETURNS",
    "ROLE",
    "ROLLUP",
    "ROUTINE",
    "ROUTINES",
    "ROUTINE_CATALOG",
    "ROUTINE_NAME",
    "ROUTINE_SCHEMA",
    "ROW",
    "ROWS",
    "ROW_COUNT",
    "RULE",
    "RUNNING",
    "SCALAR",
    "SCHEMA",
    "SCHEMAS",
    "SCHEMA_NAME",
    "SCOPE",
    "SCOPE_CATALOG",
    "SCOPE_NAME",
    "SCOPE_SCHEMA",
    "SCROLL",
    "SEARCH",
    "SECOND",
    "SECTION",
    "SECURITY",
    "SEEK",
    "SELECTIVE",
    "SELF",
    "SENSITIVE",
    "SEQUENCE",
    "SEQUENCES",
    "SERIALIZABLE",
    "SERVER",
    "SERVER_NAME",
    "SESSION",
    "SETOF",
    "SETS",
    "SHARE",
    "SIMILAR",
    "SIMPLE",
    "SIZE",
    "SKIP",
    "SMALLINT",
    "SNAPSHOT",
    "SOURCE",
    "SPACE",
    "SPECIFIC",
    "SPECIFICTYPE",
    "SPECIFIC_NAME",
    "SQL",
    "SQLCODE",
    "SQLERROR",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "STABLE",
    "STANDALONE",
    "START",
    "STATE",
    "STATEMENT",
    "STATIC",
    "STATISTICS",
    "STDIN",
    "STDOUT",
    "STORAGE",
    "STORED",
    "STRICT",
    "STRUCTURE",
    "STYLE",
    "SUBCLASS_ORIGIN",
    "SUBMULTISET",
    "SUBSCRIPTION",
    "SUBSET",
    "SUBSTRING_REGEX",
    "SUCCEEDS",
    "SUPPORT",
    "SYMMETRIC",
    "SYSID",
    "SYSTEM",
    "SYSTEM_TIME",
    "SYSTEM_USER",
    "TABLE",
    "TABLES",
    "TABLESAMPLE",
    "TABLESPACE",
    "TABLE_NAME",
    "TEMP",
    "TEMPLATE",
    "TEMPORARY",
    "THEN",
    "THROUGH",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TO",
    "TOKEN",
    "TOP_LEVEL_COUNT",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONS_COMMITTED",
    "TRANSACTIONS_ROLLED_BACK",
    "TRANSACTION_ACTIVE",
    "TRANSFORM",
    "TRANSFORMS",
    "TRANSLATE_REGEX",
    "TRANSLATION",
    "TREAT",
    "TRIGGER",
    "TRIGGER_CATALOG",
    "TRIGGER_NAME",
    "TRIGGER_SCHEMA",
    "TRUE",
    "TRUSTED",
    "TYPE",
    "TYPES",
    "UESCAPE",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNCONDITIONAL",
    "UNDER",
    "UNENCRYPTED",
    "UNIQUE",
    "UNKNOWN",
    "UNLINK",
    "UNLOGGED",
    "UNMATCHED",
    "UNNAMED",
    "UNTIL",
    "UNTYPED",
    "URI",
    "USAGE",
    "USER_DEFINED_TYPE_CATALOG",
    "USER_DEFINED_TYPE_CODE",
    "USER_DEFINED_TYPE_NAME",
    "USER_DEFINED_TYPE_SCHEMA",
    "UTF16",
    "UTF32",
    "UTF8",
    "VALID",
    "VALIDATE",
    "VALIDATOR",
    "VALUE",
    "VALUE_OF",
    "VARBINARY",
    "VARCHAR",
    "VARIADIC",
    "VARYING",
    "VERBOSE",
    "VERSIONING",
    "VIEW",
    "VIEWS",
    "VOLATILE",
    "WHENEVER",
    "WHITESPACE",
    "WINDOW",
    "WITHIN",
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    "XML",
    "XMLATTRIBUTES",
    "XMLBINARY",
    "XMLCAST",
    "XMLDECLARATION",
    "XMLDOCUMENT",
    "XMLITERATE",
    "XMLNAMESPACES",
    "XMLQUERY",
    "XMLSCHEMA",
    "XMLTEXT",
    "XMLVALIDATE",
    "YEAR",
    "YES",
    "ZONE"
  ], G = [
    "ABORT",
    "ALTER AGGREGATE",
    "ALTER COLLATION",
    "ALTER CONVERSION",
    "ALTER DATABASE",
    "ALTER DEFAULT PRIVILEGES",
    "ALTER DOMAIN",
    "ALTER EVENT TRIGGER",
    "ALTER EXTENSION",
    "ALTER FOREIGN DATA WRAPPER",
    "ALTER FOREIGN TABLE",
    "ALTER FUNCTION",
    "ALTER GROUP",
    "ALTER INDEX",
    "ALTER LANGUAGE",
    "ALTER LARGE OBJECT",
    "ALTER MATERIALIZED VIEW",
    "ALTER OPERATOR",
    "ALTER OPERATOR CLASS",
    "ALTER OPERATOR FAMILY",
    "ALTER POLICY",
    "ALTER PROCEDURE",
    "ALTER PUBLICATION",
    "ALTER ROLE",
    "ALTER ROUTINE",
    "ALTER RULE",
    "ALTER SCHEMA",
    "ALTER SEQUENCE",
    "ALTER SERVER",
    "ALTER STATISTICS",
    "ALTER SUBSCRIPTION",
    "ALTER SYSTEM",
    "ALTER TABLE",
    "ALTER TABLESPACE",
    "ALTER TEXT SEARCH CONFIGURATION",
    "ALTER TEXT SEARCH DICTIONARY",
    "ALTER TEXT SEARCH PARSER",
    "ALTER TEXT SEARCH TEMPLATE",
    "ALTER TRIGGER",
    "ALTER TYPE",
    "ALTER USER",
    "ALTER USER MAPPING",
    "ALTER VIEW",
    "ANALYZE",
    "BEGIN",
    "CALL",
    "CHECKPOINT",
    "CLOSE",
    "CLUSTER",
    "COMMENT",
    "COMMIT",
    "COMMIT PREPARED",
    "COPY",
    "CREATE ACCESS METHOD",
    "CREATE AGGREGATE",
    "CREATE CAST",
    "CREATE COLLATION",
    "CREATE CONVERSION",
    "CREATE DATABASE",
    "CREATE DOMAIN",
    "CREATE EVENT TRIGGER",
    "CREATE EXTENSION",
    "CREATE FOREIGN DATA WRAPPER",
    "CREATE FOREIGN TABLE",
    "CREATE FUNCTION",
    "CREATE GROUP",
    "CREATE INDEX",
    "CREATE LANGUAGE",
    "CREATE MATERIALIZED VIEW",
    "CREATE OPERATOR",
    "CREATE OPERATOR CLASS",
    "CREATE OPERATOR FAMILY",
    "CREATE POLICY",
    "CREATE PROCEDURE",
    "CREATE PUBLICATION",
    "CREATE ROLE",
    "CREATE RULE",
    "CREATE SCHEMA",
    "CREATE SEQUENCE",
    "CREATE SERVER",
    "CREATE STATISTICS",
    "CREATE SUBSCRIPTION",
    "CREATE TABLE",
    "CREATE TABLE AS",
    "CREATE TABLESPACE",
    "CREATE TEXT SEARCH CONFIGURATION",
    "CREATE TEXT SEARCH DICTIONARY",
    "CREATE TEXT SEARCH PARSER",
    "CREATE TEXT SEARCH TEMPLATE",
    "CREATE TRANSFORM",
    "CREATE TRIGGER",
    "CREATE TYPE",
    "CREATE USER",
    "CREATE USER MAPPING",
    "CREATE VIEW",
    "DEALLOCATE",
    "DECLARE",
    "DELETE",
    "DELETE FROM",
    "DISCARD",
    "DO",
    "DROP ACCESS METHOD",
    "DROP AGGREGATE",
    "DROP CAST",
    "DROP COLLATION",
    "DROP CONVERSION",
    "DROP DATABASE",
    "DROP DOMAIN",
    "DROP EVENT TRIGGER",
    "DROP EXTENSION",
    "DROP FOREIGN DATA WRAPPER",
    "DROP FOREIGN TABLE",
    "DROP FUNCTION",
    "DROP GROUP",
    "DROP INDEX",
    "DROP LANGUAGE",
    "DROP MATERIALIZED VIEW",
    "DROP OPERATOR",
    "DROP OPERATOR CLASS",
    "DROP OPERATOR FAMILY",
    "DROP OWNED",
    "DROP POLICY",
    "DROP PROCEDURE",
    "DROP PUBLICATION",
    "DROP ROLE",
    "DROP ROUTINE",
    "DROP RULE",
    "DROP SCHEMA",
    "DROP SEQUENCE",
    "DROP SERVER",
    "DROP STATISTICS",
    "DROP SUBSCRIPTION",
    "DROP TABLE",
    "DROP TABLESPACE",
    "DROP TEXT SEARCH CONFIGURATION",
    "DROP TEXT SEARCH DICTIONARY",
    "DROP TEXT SEARCH PARSER",
    "DROP TEXT SEARCH TEMPLATE",
    "DROP TRANSFORM",
    "DROP TRIGGER",
    "DROP TYPE",
    "DROP USER",
    "DROP USER MAPPING",
    "DROP VIEW",
    "EXECUTE",
    "EXPLAIN",
    "FETCH",
    "GRANT",
    "IMPORT FOREIGN SCHEMA",
    "INSERT",
    "LISTEN",
    "LOAD",
    "LOCK",
    "MOVE",
    "NOTIFY",
    "PREPARE",
    "PREPARE TRANSACTION",
    "REASSIGN OWNED",
    "REFRESH MATERIALIZED VIEW",
    "REINDEX",
    "RELEASE SAVEPOINT",
    "RESET",
    "RETURNING",
    "REVOKE",
    "ROLLBACK",
    "ROLLBACK PREPARED",
    "ROLLBACK TO SAVEPOINT",
    "SAVEPOINT",
    "SECURITY LABEL",
    "SELECT",
    "SELECT INTO",
    "SET",
    "SET CONSTRAINTS",
    "SET ROLE",
    "SET SESSION AUTHORIZATION",
    "SET TRANSACTION",
    "SHOW",
    "START TRANSACTION",
    "TRUNCATE",
    "UNLISTEN",
    "UPDATE",
    "VACUUM",
    "VALUES",
    // other
    "ADD",
    "AFTER",
    "ALTER COLUMN",
    "INSERT INTO",
    // verify
    "SET SCHEMA",
    // verify
    "FROM",
    "GROUP BY",
    "HAVING",
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "WHERE",
    "WITH",
    "WINDOW",
    "PARTITION BY"
  ], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT", "MINUS", "MINUS ALL", "MINUS DISTINCT"], re = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN", "NATURAL JOIN"], B = ["WHEN", "ELSE"], Y = [
    // Math Operators
    "<<",
    ">>",
    "|/",
    "||/",
    "!!",
    // String Operators
    "||",
    // Pattern Matching Operators
    "~~",
    "~~*",
    "!~~",
    "!~~*",
    // POSIX RegExp operators
    "~",
    "~*",
    "!~",
    "!~*",
    // Similarity Operators
    "<%",
    "<<%",
    "%>",
    "%>>",
    // Byte Comparison Operators
    "~>~",
    "~<~",
    "~>=~",
    "~<=~",
    // Geometric operators
    "@-@",
    "@@",
    "#",
    "##",
    "<->",
    "&&",
    "&<",
    "&>",
    "<<|",
    "&<|",
    "|>>",
    "|&>",
    "<^",
    "^>",
    "?#",
    "?-",
    "?|",
    "?-|",
    "?||",
    "@>",
    "<@",
    "~=",
    // Network Address operators
    ">>=",
    "<<=",
    // Text Search Operators
    "@@@",
    // JSON Operators
    "?",
    "@?",
    "?&",
    "->",
    "->>",
    "#>",
    "#>>",
    "#-",
    // Other Operators
    ":=",
    "::",
    "=>",
    "-|-"
  ], E = function(m) {
    D(R, m);
    var P = x(R);
    function R() {
      return d2(this, R), P.apply(this, arguments);
    }
    return L(R, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: G,
          reservedBinaryCommands: H,
          reservedJoins: re,
          reservedDependentClauses: B,
          reservedKeywords: (0, a.dedupe)([].concat(U, o(Object.values(ae).flat()))),
          openParens: ["(", "["],
          closeParens: [")", "]"],
          stringTypes: [{
            quote: "''",
            prefixes: ["U&", "E", "X", "B"]
          }, "$$"],
          identTypes: [{
            quote: '""',
            prefixes: ["U&"]
          }],
          identChars: {
            rest: "$"
          },
          numberedParamTypes: ["$"],
          operators: R.operators
        });
      }
    }]), R;
  }(i.default);
  t.default = E, F(E, "operators", Y), e.exports = t.default;
})(Hl, Hl.exports);
var B_ = Hl.exports;
var zl = { exports: {} };
(function(e, t) {
  function r(E) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(E);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function o(E) {
    return p(E) || f(E) || c(E) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(E, m) {
    if (E) {
      if (typeof E == "string")
        return O(E, m);
      var P = Object.prototype.toString.call(E).slice(8, -1);
      if (P === "Object" && E.constructor && (P = E.constructor.name), P === "Map" || P === "Set")
        return Array.from(E);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return O(E, m);
    }
  }
  function f(E) {
    if (typeof Symbol < "u" && E[Symbol.iterator] != null || E["@@iterator"] != null)
      return Array.from(E);
  }
  function p(E) {
    if (Array.isArray(E))
      return O(E);
  }
  function O(E, m) {
    (m == null || m > E.length) && (m = E.length);
    for (var P = 0, R = new Array(m); P < m; P++)
      R[P] = E[P];
    return R;
  }
  function d2(E, m) {
    if (!(E instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(E, m) {
    for (var P = 0; P < m.length; P++) {
      var R = m[P];
      R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(E, R.key, R);
    }
  }
  function L(E, m, P) {
    return m && g(E.prototype, m), P && g(E, P), Object.defineProperty(E, "prototype", { writable: false }), E;
  }
  function D(E, m) {
    if (typeof m != "function" && m !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(m && m.prototype, { constructor: { value: E, writable: true, configurable: true } }), Object.defineProperty(E, "prototype", { writable: false }), m && W(E, m);
  }
  function W(E, m) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, A) {
      return R.__proto__ = A, R;
    }, W(E, m);
  }
  function x(E) {
    var m = $();
    return function() {
      var R = z(E), A;
      if (m) {
        var y2 = z(this).constructor;
        A = Reflect.construct(R, arguments, y2);
      } else
        A = R.apply(this, arguments);
      return V(this, A);
    };
  }
  function V(E, m) {
    if (m && (r(m) === "object" || typeof m == "function"))
      return m;
    if (m !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(E);
  }
  function _2(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(E) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
      return P.__proto__ || Object.getPrototypeOf(P);
    }, z(E);
  }
  function F(E, m, P) {
    return m in E ? Object.defineProperty(E, m, { value: P, enumerable: true, configurable: true, writable: true }) : E[m] = P, E;
  }
  var ae = {
    // https://docs.aws.amazon.com/redshift/latest/dg/c_Aggregate_Functions.html
    aggregate: ["ANY_VALUE", "APPROXIMATE PERCENTILE_DISC", "AVG", "COUNT", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
    // https://docs.aws.amazon.com/redshift/latest/dg/c_Array_Functions.html
    array: ["array", "array_concat", "array_flatten", "get_array_length", "split_to_array", "subarray"],
    // https://docs.aws.amazon.com/redshift/latest/dg/c_bitwise_aggregate_functions.html
    bitwise: ["BIT_AND", "BIT_OR", "BOOL_AND", "BOOL_OR"],
    // https://docs.aws.amazon.com/redshift/latest/dg/c_conditional_expressions.html
    conditional: ["COALESCE", "DECODE", "GREATEST", "LEAST", "NVL", "NVL2", "NULLIF"],
    // https://docs.aws.amazon.com/redshift/latest/dg/Date_functions_header.html
    dateTime: ["ADD_MONTHS", "AT TIME ZONE", "CONVERT_TIMEZONE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE_CMP", "DATE_CMP_TIMESTAMP", "DATE_CMP_TIMESTAMPTZ", "DATE_PART_YEAR", "DATEADD", "DATEDIFF", "DATE_PART", "DATE_TRUNC", "EXTRACT", "GETDATE", "INTERVAL_CMP", "LAST_DAY", "MONTHS_BETWEEN", "NEXT_DAY", "SYSDATE", "TIMEOFDAY", "TIMESTAMP_CMP", "TIMESTAMP_CMP_DATE", "TIMESTAMP_CMP_TIMESTAMPTZ", "TIMESTAMPTZ_CMP", "TIMESTAMPTZ_CMP_DATE", "TIMESTAMPTZ_CMP_TIMESTAMP", "TIMEZONE", "TO_TIMESTAMP", "TRUNC"],
    // https://docs.aws.amazon.com/redshift/latest/dg/geospatial-functions.html
    spatial: ["AddBBox", "DropBBox", "GeometryType", "ST_AddPoint", "ST_Angle", "ST_Area", "ST_AsBinary", "ST_AsEWKB", "ST_AsEWKT", "ST_AsGeoJSON", "ST_AsText", "ST_Azimuth", "ST_Boundary", "ST_Collect", "ST_Contains", "ST_ContainsProperly", "ST_ConvexHull", "ST_CoveredBy", "ST_Covers", "ST_Crosses", "ST_Dimension", "ST_Disjoint", "ST_Distance", "ST_DistanceSphere", "ST_DWithin", "ST_EndPoint", "ST_Envelope", "ST_Equals", "ST_ExteriorRing", "ST_Force2D", "ST_Force3D", "ST_Force3DM", "ST_Force3DZ", "ST_Force4D", "ST_GeometryN", "ST_GeometryType", "ST_GeomFromEWKB", "ST_GeomFromEWKT", "ST_GeomFromText", "ST_GeomFromWKB", "ST_InteriorRingN", "ST_Intersects", "ST_IsPolygonCCW", "ST_IsPolygonCW", "ST_IsClosed", "ST_IsCollection", "ST_IsEmpty", "ST_IsSimple", "ST_IsValid", "ST_Length", "ST_LengthSphere", "ST_Length2D", "ST_LineFromMultiPoint", "ST_LineInterpolatePoint", "ST_M", "ST_MakeEnvelope", "ST_MakeLine", "ST_MakePoint", "ST_MakePolygon", "ST_MemSize", "ST_MMax", "ST_MMin", "ST_Multi", "ST_NDims", "ST_NPoints", "ST_NRings", "ST_NumGeometries", "ST_NumInteriorRings", "ST_NumPoints", "ST_Perimeter", "ST_Perimeter2D", "ST_Point", "ST_PointN", "ST_Points", "ST_Polygon", "ST_RemovePoint", "ST_Reverse", "ST_SetPoint", "ST_SetSRID", "ST_Simplify", "ST_SRID", "ST_StartPoint", "ST_Touches", "ST_Within", "ST_X", "ST_XMax", "ST_XMin", "ST_Y", "ST_YMax", "ST_YMin", "ST_Z", "ST_ZMax", "ST_ZMin", "SupportsBBox"],
    // https://docs.aws.amazon.com/redshift/latest/dg/hash-functions.html
    hash: ["CHECKSUM", "FUNC_SHA1", "FNV_HASH", "MD5", "SHA", "SHA1", "SHA2"],
    // https://docs.aws.amazon.com/redshift/latest/dg/hyperloglog-functions.html
    hyperLogLog: ["HLL", "HLL_CREATE_SKETCH", "HLL_CARDINALITY", "HLL_COMBINE"],
    // https://docs.aws.amazon.com/redshift/latest/dg/json-functions.html
    json: ["IS_VALID_JSON", "IS_VALID_JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_EXTRACT_ARRAY_ELEMENT_TEXT", "JSON_EXTRACT_PATH_TEXT", "JSON_PARSE", "JSON_SERIALIZE"],
    // https://docs.aws.amazon.com/redshift/latest/dg/Math_functions.html
    math: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CBRT", "CEILING", "CEIL", "COS", "COT", "DEGREES", "DEXP", "DLOG1", "DLOG10", "EXP", "FLOOR", "LN", "LOG", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SIN", "SIGN", "SQRT", "TAN", "TO_HEX", "TRUNC"],
    // https://docs.aws.amazon.com/redshift/latest/dg/ml-function.html
    machineLearning: ["EXPLAIN_MODEL"],
    // https://docs.aws.amazon.com/redshift/latest/dg/String_functions_header.html
    string: ["ASCII", "BPCHARCMP", "BTRIM", "BTTEXT_PATTERN_CMP", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARINDEX", "CHR", "COLLATE", "CONCAT", "CRC32", "DIFFERENCE", "INITCAP", "LEFT", "RIGHT", "LEN", "LENGTH", "LOWER", "LPAD", "RPAD", "LTRIM", "OCTETINDEX", "OCTET_LENGTH", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "REPLICATE", "REVERSE", "RTRIM", "SOUNDEX", "SPLIT_PART", "STRPOS", "STRTOL", "SUBSTRING", "TEXTLEN", "TRANSLATE", "TRIM", "UPPER"],
    // https://docs.aws.amazon.com/redshift/latest/dg/c_Type_Info_Functions.html
    superType: ["decimal_precision", "decimal_scale", "is_array", "is_bigint", "is_boolean", "is_char", "is_decimal", "is_float", "is_integer", "is_object", "is_scalar", "is_smallint", "is_varchar", "json_typeof"],
    // https://docs.aws.amazon.com/redshift/latest/dg/c_Window_functions.html
    window: ["AVG", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAST_VALUE", "LAG", "LEAD", "LISTAGG", "MAX", "MEDIAN", "MIN", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
    // https://docs.aws.amazon.com/redshift/latest/dg/r_Data_type_formatting.html
    dataType: ["CAST", "CONVERT", "TO_CHAR", "TO_DATE", "TO_NUMBER", "TEXT_TO_INT_ALT", "TEXT_TO_NUMERIC_ALT"],
    // https://docs.aws.amazon.com/redshift/latest/dg/r_System_administration_functions.html
    sysAdmin: ["CHANGE_QUERY_PRIORITY", "CHANGE_SESSION_PRIORITY", "CHANGE_USER_PRIORITY", "CURRENT_SETTING", "PG_CANCEL_BACKEND", "PG_TERMINATE_BACKEND", "REBOOT_CLUSTER", "SET_CONFIG"],
    // https://docs.aws.amazon.com/redshift/latest/dg/r_System_information_functions.html
    sysInfo: ["CURRENT_AWS_ACCOUNT", "CURRENT_DATABASE", "CURRENT_NAMESPACE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "CURRENT_USER_ID", "HAS_ASSUMEROLE_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "PG_BACKEND_PID", "PG_GET_COLS", "PG_GET_GRANTEE_BY_IAM_ROLE", "PG_GET_IAM_ROLE_BY_USER", "PG_GET_LATE_BINDING_VIEW_COLS", "PG_LAST_COPY_COUNT", "PG_LAST_COPY_ID", "PG_LAST_UNLOAD_ID", "PG_LAST_QUERY_ID", "PG_LAST_UNLOAD_COUNT", "SESSION_USER", "SLICE_NUM", "USER", "VERSION"]
  }, U = {
    // https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html
    standard: ["AES128", "AES256", "ALL", "ALLOWOVERWRITE", "ANY", "ARRAY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BETWEEN", "BINARY", "BOTH", "CHECK", "COLUMN", "CONSTRAINT", "CREATE", "CROSS", "DEFAULT", "DEFERRABLE", "DEFLATE", "DEFRAG", "DESC", "DISABLE", "DISTINCT", "DO", "ENABLE", "ENCODE", "ENCRYPT", "ENCRYPTION", "EXPLICIT", "FALSE", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GLOBALDICT256", "GLOBALDICT64K", "GROUP", "IDENTITY", "IGNORE", "ILIKE", "IN", "INITIALLY", "INNER", "INTO", "IS", "ISNULL", "LANGUAGE", "LEADING", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LUN", "LUNS", "MINUS", "NATURAL", "NEW", "NOT", "NOTNULL", "NULL", "NULLS", "OFF", "OFFLINE", "OFFSET", "OID", "OLD", "ONLY", "OPEN", "ORDER", "OUTER", "OVERLAPS", "PARALLEL", "PARTITION", "PERCENT", "PERMISSIONS", "PLACING", "PRIMARY", "RECOVER", "REFERENCES", "REJECTLOG", "RESORT", "RESPECT", "RESTORE", "SIMILAR", "SNAPSHOT", "SOME", "SYSTEM", "TABLE", "TAG", "TDES", "THEN", "TIMESTAMP", "TO", "TOP", "TRAILING", "TRUE", "UNIQUE", "VERBOSE", "WALLET", "WITHOUT"],
    // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
    dataConversionParams: ["ACCEPTANYDATE", "ACCEPTINVCHARS", "BLANKSASNULL", "DATEFORMAT", "EMPTYASNULL", "ENCODING", "ESCAPE", "EXPLICIT_IDS", "FILLRECORD", "IGNOREBLANKLINES", "IGNOREHEADER", "NULL AS", "REMOVEQUOTES", "ROUNDEC", "TIMEFORMAT", "TRIMBLANKS", "TRUNCATECOLUMNS"],
    // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-load.html
    dataLoadParams: ["COMPROWS", "COMPUPDATE", "MAXERROR", "NOLOAD", "STATUPDATE"],
    // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-format.html
    dataFormatParams: ["FORMAT", "CSV", "DELIMITER", "FIXEDWIDTH", "SHAPEFILE", "AVRO", "JSON", "PARQUET", "ORC"],
    // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-authorization.html
    copyAuthParams: ["ACCESS_KEY_ID", "CREDENTIALS", "ENCRYPTED", "IAM_ROLE", "MASTER_SYMMETRIC_KEY", "SECRET_ACCESS_KEY", "SESSION_TOKEN"],
    // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-file-compression.html
    copyCompressionParams: ["BZIP2", "GZIP", "LZOP", "ZSTD"],
    // https://docs.aws.amazon.com/redshift/latest/dg/r_COPY-alphabetical-parm-list.html
    copyMiscParams: ["MANIFEST", "READRATIO", "REGION", "SSH"],
    // https://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html
    compressionEncodings: ["RAW", "AZ64", "BYTEDICT", "DELTA", "DELTA32K", "LZO", "MOSTLY8", "MOSTLY16", "MOSTLY32", "RUNLENGTH", "TEXT255", "TEXT32K"],
    misc: [
      // CREATE EXTERNAL SCHEMA (https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html)
      "CATALOG_ROLE",
      "SECRET_ARN",
      "EXTERNAL",
      "HIVE METASTORE",
      // https://docs.aws.amazon.com/redshift/latest/dg/c-spectrum-external-schemas.html
      // https://docs.aws.amazon.com/redshift/latest/dg/c_choosing_dist_sort.html
      "AUTO",
      "EVEN",
      "KEY",
      "PREDICATE",
      // ANALYZE | ANALYSE (https://docs.aws.amazon.com/redshift/latest/dg/r_ANALYZE.html)
      // unknown
      "COMPRESSION",
      "DATA CATALOG"
    ],
    /**
     * Other keywords not included:
     * STL: https://docs.aws.amazon.com/redshift/latest/dg/c_intro_STL_tables.html
     * SVCS: https://docs.aws.amazon.com/redshift/latest/dg/svcs_views.html
     * SVL: https://docs.aws.amazon.com/redshift/latest/dg/svl_views.html
     * SVV: https://docs.aws.amazon.com/redshift/latest/dg/svv_views.html
     */
    dataTypes: ["CHAR", "CHARACTER", "NCHAR", "VARCHAR", "CHARACTER VARYING", "NVARCHAR", "BPCHAR", "TEXT"]
  }, G = [
    "ABORT",
    "ALTER DATABASE",
    "ALTER DATASHARE",
    "ALTER DEFAULT PRIVILEGES",
    "ALTER GROUP",
    "ALTER MATERIALIZED VIEW",
    "ALTER PROCEDURE",
    "ALTER SCHEMA",
    "ALTER TABLE",
    "ALTER TABLE APPEND",
    "ALTER USER",
    "ANALYSE",
    "ANALYZE",
    "ANALYSE COMPRESSION",
    "ANALYZE COMPRESSION",
    "BEGIN",
    "CALL",
    "CANCEL",
    "CLOSE",
    "COMMENT",
    "COMMIT",
    "COPY",
    "CREATE DATABASE",
    "CREATE DATASHARE",
    "CREATE EXTERNAL FUNCTION",
    "CREATE EXTERNAL SCHEMA",
    "CREATE EXTERNAL TABLE",
    "CREATE FUNCTION",
    "CREATE GROUP",
    "CREATE LIBRARY",
    "CREATE MATERIALIZED VIEW",
    "CREATE MODEL",
    "CREATE PROCEDURE",
    "CREATE SCHEMA",
    "CREATE TABLE",
    "CREATE TABLE AS",
    "CREATE USER",
    "CREATE VIEW",
    "DEALLOCATE",
    "DECLARE",
    "DELETE",
    "DELETE FROM",
    "DESC DATASHARE",
    "DROP DATABASE",
    "DROP DATASHARE",
    "DROP FUNCTION",
    "DROP GROUP",
    "DROP LIBRARY",
    "DROP MODEL",
    "DROP MATERIALIZED VIEW",
    "DROP PROCEDURE",
    "DROP SCHEMA",
    "DROP TABLE",
    "DROP USER",
    "DROP VIEW",
    "DROP",
    "EXECUTE",
    "EXPLAIN",
    "FETCH",
    "FROM",
    "GRANT",
    "HAVING",
    "INSERT",
    "LOCK",
    "PREPARE",
    "REFRESH MATERIALIZED VIEW",
    "RESET",
    "REVOKE",
    "ROLLBACK",
    "SELECT",
    "SELECT INTO",
    "SET",
    "SET SESSION AUTHORIZATION",
    "SET SESSION CHARACTERISTICS",
    "SHOW",
    "SHOW EXTERNAL TABLE",
    "SHOW MODEL",
    "SHOW DATASHARES",
    "SHOW PROCEDURE",
    "SHOW TABLE",
    "SHOW VIEW",
    "START TRANSACTION",
    "TRUNCATE",
    "UNLOAD",
    "UPDATE",
    "VACUUM",
    "WHERE",
    "WITH",
    // other
    "GROUP BY",
    "ORDER BY",
    "LIMIT",
    "OFFSET",
    "VALUES",
    "MODIFY",
    // verify
    "INSERT INTO",
    // verify
    "ALTER COLUMN",
    // verify
    "SET SCHEMA"
    // verify
  ], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT"], re = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN", "NATURAL JOIN"], B = ["WHEN", "ELSE"], Y = function(E) {
    D(P, E);
    var m = x(P);
    function P() {
      return d2(this, P), m.apply(this, arguments);
    }
    return L(P, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: G,
          reservedBinaryCommands: H,
          reservedJoins: re,
          reservedDependentClauses: B,
          reservedKeywords: (0, a.dedupe)([].concat(o(Object.values(U).flat()), o(Object.values(ae).flat()))),
          stringTypes: ["''"],
          identTypes: ['""'],
          numberedParamTypes: ["$"],
          operators: P.operators
        });
      }
    }]), P;
  }(i.default);
  t.default = Y, F(Y, "operators", ["~", "|/", "||/", "<<", ">>", "||"]), e.exports = t.default;
})(zl, zl.exports);
var $_ = zl.exports;
var ql = { exports: {} };
(function(e, t) {
  function r(A) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(y2) {
      return typeof y2;
    } : function(y2) {
      return y2 && typeof Symbol == "function" && y2.constructor === Symbol && y2 !== Symbol.prototype ? "symbol" : typeof y2;
    }, r(A);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = o(ur), n = o(cr), a = it, s = Xe;
  function o(A) {
    return A && A.__esModule ? A : { default: A };
  }
  function l(A, y2) {
    var C = Object.keys(A);
    if (Object.getOwnPropertySymbols) {
      var j = Object.getOwnPropertySymbols(A);
      y2 && (j = j.filter(function(w) {
        return Object.getOwnPropertyDescriptor(A, w).enumerable;
      })), C.push.apply(C, j);
    }
    return C;
  }
  function c(A) {
    for (var y2 = 1; y2 < arguments.length; y2++) {
      var C = arguments[y2] != null ? arguments[y2] : {};
      y2 % 2 ? l(Object(C), true).forEach(function(j) {
        G(A, j, C[j]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(C)) : l(Object(C)).forEach(function(j) {
        Object.defineProperty(A, j, Object.getOwnPropertyDescriptor(C, j));
      });
    }
    return A;
  }
  function f(A) {
    return g(A) || d2(A) || O(A) || p();
  }
  function p() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function O(A, y2) {
    if (A) {
      if (typeof A == "string")
        return L(A, y2);
      var C = Object.prototype.toString.call(A).slice(8, -1);
      if (C === "Object" && A.constructor && (C = A.constructor.name), C === "Map" || C === "Set")
        return Array.from(A);
      if (C === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(C))
        return L(A, y2);
    }
  }
  function d2(A) {
    if (typeof Symbol < "u" && A[Symbol.iterator] != null || A["@@iterator"] != null)
      return Array.from(A);
  }
  function g(A) {
    if (Array.isArray(A))
      return L(A);
  }
  function L(A, y2) {
    (y2 == null || y2 > A.length) && (y2 = A.length);
    for (var C = 0, j = new Array(y2); C < y2; C++)
      j[C] = A[C];
    return j;
  }
  function D(A, y2) {
    if (!(A instanceof y2))
      throw new TypeError("Cannot call a class as a function");
  }
  function W(A, y2) {
    for (var C = 0; C < y2.length; C++) {
      var j = y2[C];
      j.enumerable = j.enumerable || false, j.configurable = true, "value" in j && (j.writable = true), Object.defineProperty(A, j.key, j);
    }
  }
  function x(A, y2, C) {
    return y2 && W(A.prototype, y2), C && W(A, C), Object.defineProperty(A, "prototype", { writable: false }), A;
  }
  function V(A, y2) {
    if (typeof y2 != "function" && y2 !== null)
      throw new TypeError("Super expression must either be null or a function");
    A.prototype = Object.create(y2 && y2.prototype, { constructor: { value: A, writable: true, configurable: true } }), Object.defineProperty(A, "prototype", { writable: false }), y2 && _2(A, y2);
  }
  function _2(A, y2) {
    return _2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(j, w) {
      return j.__proto__ = w, j;
    }, _2(A, y2);
  }
  function $(A) {
    var y2 = ae();
    return function() {
      var j = U(A), w;
      if (y2) {
        var J = U(this).constructor;
        w = Reflect.construct(j, arguments, J);
      } else
        w = j.apply(this, arguments);
      return z(this, w);
    };
  }
  function z(A, y2) {
    if (y2 && (r(y2) === "object" || typeof y2 == "function"))
      return y2;
    if (y2 !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return F(A);
  }
  function F(A) {
    if (A === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return A;
  }
  function ae() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function U(A) {
    return U = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(C) {
      return C.__proto__ || Object.getPrototypeOf(C);
    }, U(A);
  }
  function G(A, y2, C) {
    return y2 in A ? Object.defineProperty(A, y2, { value: C, enumerable: true, configurable: true, writable: true }) : A[y2] = C, A;
  }
  var H = {
    // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#aggregate-functions
    aggregate: ["ANY", "APPROX_COUNT_DISTINCT", "APPROX_PERCENTILE", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "BOOL_AND", "BOOL_OR", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COUNT", "COUNT", "COUNT_IF", "COUNT_MIN_SKETCH", "COVAR_POP", "COVAR_SAMP", "EVERY", "FIRST", "FIRST_VALUE", "GROUPING", "GROUPING_ID", "KURTOSIS", "LAST", "LAST_VALUE", "MAX", "MAX_BY", "MEAN", "MIN", "MIN_BY", "PERCENTILE", "PERCENTILE", "PERCENTILE_APPROX", "SKEWNESS", "SOME", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
    // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#window-functions
    window: ["CUME_DIST", "DENSE_RANK", "LAG", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
    // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#array-functions
    array: ["ARRAY", "ARRAY_CONTAINS", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_REPEAT", "ARRAY_UNION", "ARRAYS_OVERLAP", "ARRAYS_ZIP", "FLATTEN", "SEQUENCE", "SHUFFLE", "SLICE", "SORT_ARRAY"],
    // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#map-functions
    map: ["ELEMENT_AT", "ELEMENT_AT", "MAP", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FROM_ARRAYS", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_VALUES", "STR_TO_MAP"],
    // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date-and-timestamp-functions
    datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "DATE_ADD", "DATE_FORMAT", "DATE_FROM_UNIX_DATE", "DATE_PART", "DATE_SUB", "DATE_TRUNC", "DATEDIFF", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MAKE_DATE", "MAKE_DT_INTERVAL", "MAKE_INTERVAL", "MAKE_TIMESTAMP", "MAKE_YM_INTERVAL", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "NOW", "QUARTER", "SECOND", "SESSION_WINDOW", "TIMESTAMP_MICROS", "TIMESTAMP_MILLIS", "TIMESTAMP_SECONDS", "TO_DATE", "TO_TIMESTAMP", "TO_UNIX_TIMESTAMP", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_DATE", "UNIX_MICROS", "UNIX_MILLIS", "UNIX_SECONDS", "UNIX_TIMESTAMP", "WEEKDAY", "WEEKOFYEAR", "WINDOW", "YEAR"],
    // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#json-functions
    json: ["FROM_JSON", "GET_JSON_OBJECT", "JSON_ARRAY_LENGTH", "JSON_OBJECT_KEYS", "JSON_TUPLE", "SCHEMA_OF_JSON", "TO_JSON"],
    // http://spark.apache.org/docs/latest/api/sql/index.html
    misc: [
      "ABS",
      "ACOS",
      "ACOSH",
      "AGGREGATE",
      "ARRAY_SORT",
      "ASCII",
      "ASIN",
      "ASINH",
      "ASSERT_TRUE",
      "ATAN",
      "ATAN2",
      "ATANH",
      "BASE64",
      "BIGINT",
      "BIN",
      "BINARY",
      "BIT_COUNT",
      "BIT_GET",
      "BIT_LENGTH",
      "BOOLEAN",
      "BROUND",
      "BTRIM",
      "CARDINALITY",
      "CBRT",
      "CEIL",
      "CEILING",
      "CHAR",
      "CHAR_LENGTH",
      "CHARACTER_LENGTH",
      "CHR",
      "CONCAT",
      "CONCAT_WS",
      "CONV",
      "COS",
      "COSH",
      "COT",
      "CRC32",
      "CURRENT_CATALOG",
      "CURRENT_DATABASE",
      "CURRENT_USER",
      "DATE",
      "DECIMAL",
      "DEGREES",
      "DOUBLE",
      // 'E',
      "ELT",
      "EXP",
      "EXPM1",
      "FACTORIAL",
      "FIND_IN_SET",
      "FLOAT",
      "FLOOR",
      "FORALL",
      "FORMAT_NUMBER",
      "FORMAT_STRING",
      "FROM_CSV",
      "GETBIT",
      "HASH",
      "HEX",
      "HYPOT",
      "INITCAP",
      "INLINE",
      "INLINE_OUTER",
      "INPUT_FILE_BLOCK_LENGTH",
      "INPUT_FILE_BLOCK_START",
      "INPUT_FILE_NAME",
      "INSTR",
      "INT",
      "ISNAN",
      "ISNOTNULL",
      "ISNULL",
      "JAVA_METHOD",
      "LCASE",
      "LEFT",
      "LENGTH",
      "LEVENSHTEIN",
      "LN",
      "LOCATE",
      "LOG",
      "LOG10",
      "LOG1P",
      "LOG2",
      "LOWER",
      "LPAD",
      "LTRIM",
      "MAP_FILTER",
      "MAP_ZIP_WITH",
      "MD5",
      "MOD",
      "MONOTONICALLY_INCREASING_ID",
      "NAMED_STRUCT",
      "NANVL",
      "NEGATIVE",
      "NVL",
      "NVL2",
      "OCTET_LENGTH",
      "OVERLAY",
      "PARSE_URL",
      "PI",
      "PMOD",
      "POSEXPLODE",
      "POSEXPLODE_OUTER",
      "POSITION",
      "POSITIVE",
      "POW",
      "POWER",
      "PRINTF",
      "RADIANS",
      "RAISE_ERROR",
      "RAND",
      "RANDN",
      "RANDOM",
      "REFLECT",
      "REGEXP_EXTRACT",
      "REGEXP_EXTRACT_ALL",
      "REGEXP_LIKE",
      "REGEXP_REPLACE",
      "REPEAT",
      "REPLACE",
      "REVERSE",
      "RIGHT",
      "RINT",
      "ROUND",
      "RPAD",
      "RTRIM",
      "SCHEMA_OF_CSV",
      "SENTENCES",
      "SHA",
      "SHA1",
      "SHA2",
      "SHIFTLEFT",
      "SHIFTRIGHT",
      "SHIFTRIGHTUNSIGNED",
      "SIGN",
      "SIGNUM",
      "SIN",
      "SINH",
      "SMALLINT",
      "SOUNDEX",
      "SPACE",
      "SPARK_PARTITION_ID",
      "SPLIT",
      "SQRT",
      "STACK",
      "SUBSTR",
      "SUBSTRING",
      "SUBSTRING_INDEX",
      "TAN",
      "TANH",
      "TIMESTAMP",
      "TINYINT",
      "TO_CSV",
      "TRANSFORM_KEYS",
      "TRANSFORM_VALUES",
      "TRANSLATE",
      "TRIM",
      "TRY_ADD",
      "TRY_DIVIDE",
      "TYPEOF",
      "UCASE",
      "UNBASE64",
      "UNHEX",
      "UPPER",
      "UUID",
      "VERSION",
      "WIDTH_BUCKET",
      "XPATH",
      "XPATH_BOOLEAN",
      "XPATH_DOUBLE",
      "XPATH_FLOAT",
      "XPATH_INT",
      "XPATH_LONG",
      "XPATH_NUMBER",
      "XPATH_SHORT",
      "XPATH_STRING",
      "XXHASH64",
      "ZIP_WITH"
    ]
  }, re = [
    "ADD",
    "AFTER",
    "ALL",
    "ALTER",
    "ANALYZE",
    // 'AND',
    "ANTI",
    "ANY",
    "ARCHIVE",
    "ARRAY",
    "AS",
    "ASC",
    "AT",
    "AUTHORIZATION",
    "BETWEEN",
    "BOTH",
    "BUCKET",
    "BUCKETS",
    "BY",
    "CACHE",
    "CASCADE",
    "CAST",
    "CHANGE",
    "CHECK",
    "CLEAR",
    "CLUSTER",
    "CLUSTERED",
    "CODEGEN",
    "COLLATE",
    "COLLECTION",
    "COLUMN",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMPACT",
    "COMPACTIONS",
    "COMPUTE",
    "CONCATENATE",
    "CONSTRAINT",
    "COST",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DAY",
    "DBPROPERTIES",
    "DEFINED",
    "DELETE",
    "DELIMITED",
    "DESC",
    "DESCRIBE",
    "DFS",
    "DIRECTORIES",
    "DIRECTORY",
    "DISTINCT",
    "DISTRIBUTE",
    "DIV",
    "DROP",
    "ESCAPE",
    "ESCAPED",
    "EXCEPT",
    "EXCHANGE",
    "EXISTS",
    "EXPORT",
    "EXTENDED",
    "EXTERNAL",
    "EXTRACT",
    "FALSE",
    "FETCH",
    "FIELDS",
    "FILTER",
    "FILEFORMAT",
    "FIRST",
    "FIRST_VALUE",
    "FOLLOWING",
    "FOR",
    "FOREIGN",
    "FORMAT",
    "FORMATTED",
    "FULL",
    "FUNCTION",
    "FUNCTIONS",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "GROUPING",
    "HOUR",
    "IF",
    "IGNORE",
    "IMPORT",
    "IN",
    "INDEX",
    "INDEXES",
    "INNER",
    "INPATH",
    "INPUTFORMAT",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "ITEMS",
    "KEYS",
    "LAST",
    "LAST_VALUE",
    "LATERAL",
    "LAZY",
    "LEADING",
    "LEFT",
    "LIKE",
    "LINES",
    "LIST",
    "LOCAL",
    "LOCATION",
    "LOCK",
    "LOCKS",
    "LOGICAL",
    "MACRO",
    "MAP",
    "MATCHED",
    "MERGE",
    "MINUTE",
    "MONTH",
    "MSCK",
    "NAMESPACE",
    "NAMESPACES",
    "NATURAL",
    "NO",
    "NOT",
    "NULL",
    "NULLS",
    "OF",
    "ONLY",
    "OPTION",
    "OPTIONS",
    // 'OR',
    "ORDER",
    "OUT",
    "OUTER",
    "OUTPUTFORMAT",
    "OVER",
    "OVERLAPS",
    "OVERLAY",
    "OVERWRITE",
    "OWNER",
    "PARTITION",
    "PARTITIONED",
    "PARTITIONS",
    "PERCENT",
    "PLACING",
    "POSITION",
    "PRECEDING",
    "PRIMARY",
    "PRINCIPALS",
    "PROPERTIES",
    "PURGE",
    "QUERY",
    "RANGE",
    "RECORDREADER",
    "RECORDWRITER",
    "RECOVER",
    "REDUCE",
    "REFERENCES",
    "RENAME",
    "REPAIR",
    "REPLACE",
    "RESPECT",
    "RESTRICT",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLES",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SCHEMA",
    "SECOND",
    "SELECT",
    "SEMI",
    "SEPARATED",
    "SERDE",
    "SERDEPROPERTIES",
    "SESSION_USER",
    "SETS",
    "SHOW",
    "SKEWED",
    "SOME",
    "SORT",
    "SORTED",
    "START",
    "STATISTICS",
    "STORED",
    "STRATIFY",
    "STRUCT",
    "SUBSTR",
    "SUBSTRING",
    "TABLE",
    "TABLES",
    "TBLPROPERTIES",
    "TEMPORARY",
    "TERMINATED",
    "THEN",
    "TO",
    "TOUCH",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONS",
    "TRIM",
    "TRUE",
    "TRUNCATE",
    "UNARCHIVE",
    "UNBOUNDED",
    "UNCACHE",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNSET",
    "USE",
    "USER",
    "VIEW",
    "WINDOW",
    "YEAR",
    // other
    "ANALYSE",
    "ARRAY_ZIP",
    "COALESCE",
    "CONTAINS",
    "CONVERT",
    "CURRENT ROW",
    "DAYS",
    "DAY_HOUR",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DECODE",
    "DEFAULT",
    "DISTINCTROW",
    "ENCODE",
    "EXPLODE",
    "EXPLODE_OUTER",
    "FIXED",
    "GREATEST",
    "GROUP_CONCAT",
    "HOURS",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    "IFNULL",
    "LEAST",
    "LEVEL",
    "MINUTE_SECOND",
    "NULLIF",
    "OFFSET",
    "ON DELETE",
    "ON UPDATE",
    "OPTIMIZE",
    "REGEXP",
    "SEPARATOR",
    "SIZE",
    "STRING",
    "TYPE",
    "TYPES",
    "UNSIGNED",
    "VARIABLES",
    "YEAR_MONTH"
  ], B = [
    // DDL
    "ALTER COLUMN",
    "ALTER DATABASE",
    "ALTER TABLE",
    "ALTER VIEW",
    "CREATE DATABASE",
    "CREATE FUNCTION",
    "CREATE TABLE",
    "CREATE VIEW",
    "DROP DATABASE",
    "DROP FUNCTION",
    "DROP TABLE",
    "DROP VIEW",
    "REPAIR TABLE",
    "TRUNCATE TABLE",
    "USE DATABASE",
    // DML
    "INSERT INTO",
    "INSERT OVERWRITE",
    "INSERT OVERWRITE DIRECTORY",
    "LOAD",
    // Data Retrieval
    "SELECT",
    "WITH",
    "CLUSTER BY",
    "DISTRIBUTE BY",
    "GROUP BY",
    "HAVING",
    "VALUES",
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "SORT BY",
    "TABLESAMPLE",
    "WHERE",
    "PIVOT",
    "TRANSFORM",
    "EXPLAIN",
    // Auxiliary
    "ADD FILE",
    "ADD JAR",
    "ANALYZE TABLE",
    "CACHE TABLE",
    "CLEAR CACHE",
    "DESCRIBE DATABASE",
    "DESCRIBE FUNCTION",
    "DESCRIBE QUERY",
    "DESCRIBE TABLE",
    "LIST FILE",
    "LIST JAR",
    "REFRESH",
    "REFRESH TABLE",
    "REFRESH FUNCTION",
    "RESET",
    "SET",
    "SET SCHEMA",
    // verify
    "SHOW COLUMNS",
    "SHOW CREATE TABLE",
    "SHOW DATABASES",
    "SHOW FUNCTIONS",
    "SHOW PARTITIONS",
    "SHOW TABLE EXTENDED",
    "SHOW TABLES",
    "SHOW TBLPROPERTIES",
    "SHOW VIEWS",
    "UNCACHE TABLE",
    // other
    "FROM",
    "INSERT",
    "LATERAL VIEW",
    "UPDATE",
    "WINDOW"
  ], Y = [
    // set booleans
    "INTERSECT",
    "INTERSECT ALL",
    "INTERSECT DISTINCT",
    "UNION",
    "UNION ALL",
    "UNION DISTINCT",
    "EXCEPT",
    "EXCEPT ALL",
    "EXCEPT DISTINCT",
    "MINUS",
    "MINUS ALL",
    "MINUS DISTINCT",
    // apply
    "CROSS APPLY",
    "OUTER APPLY"
  ], E = [
    "JOIN",
    "INNER JOIN",
    "LEFT JOIN",
    "LEFT OUTER JOIN",
    "RIGHT JOIN",
    "RIGHT OUTER JOIN",
    "FULL JOIN",
    "FULL OUTER JOIN",
    "CROSS JOIN",
    "NATURAL JOIN",
    // non-standard-joins
    "ANTI JOIN",
    "SEMI JOIN",
    "LEFT ANTI JOIN",
    "LEFT SEMI JOIN",
    "RIGHT OUTER JOIN",
    "RIGHT SEMI JOIN",
    "NATURAL ANTI JOIN",
    "NATURAL FULL OUTER JOIN",
    "NATURAL INNER JOIN",
    "NATURAL LEFT ANTI JOIN",
    "NATURAL LEFT OUTER JOIN",
    "NATURAL LEFT SEMI JOIN",
    "NATURAL OUTER JOIN",
    "NATURAL RIGHT OUTER JOIN",
    "NATURAL RIGHT SEMI JOIN",
    "NATURAL SEMI JOIN"
  ], m = ["WHEN", "ELSE"], P = function(A) {
    V(C, A);
    var y2 = $(C);
    function C() {
      return D(this, C), y2.apply(this, arguments);
    }
    return x(C, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: B,
          reservedBinaryCommands: Y,
          reservedJoins: E,
          reservedDependentClauses: m,
          reservedLogicalOperators: ["AND", "OR", "XOR"],
          reservedKeywords: (0, s.dedupe)([].concat(re, f(Object.values(H).flat()))),
          openParens: ["(", "["],
          closeParens: [")", "]"],
          stringTypes: [{
            quote: "''",
            prefixes: ["X"]
          }],
          identTypes: ["``"],
          variableTypes: [{
            quote: "{}",
            prefixes: ["$"],
            requirePrefix: true
          }],
          operators: C.operators,
          postProcess: R
        });
      }
    }]), C;
  }(i.default);
  t.default = P, G(P, "operators", ["~", "<=>", "&&", "||", "==", "->"]);
  function R(A) {
    return A.map(function(y2, C) {
      var j = A[C - 1] || a.EOF_TOKEN, w = A[C + 1] || a.EOF_TOKEN;
      return a.isToken.WINDOW(y2) && w.type === a.TokenType.OPEN_PAREN ? c(c({}, y2), {}, {
        type: a.TokenType.RESERVED_KEYWORD
      }) : y2.value === "ITEMS" && y2.type === a.TokenType.RESERVED_KEYWORD && !(j.value === "COLLECTION" && w.value === "TERMINATED") ? {
        type: a.TokenType.IDENTIFIER,
        text: y2.text,
        value: y2.text
      } : y2;
    });
  }
  e.exports = t.default;
})(ql, ql.exports);
var Y_ = ql.exports;
var Jl = { exports: {} };
(function(e, t) {
  function r(E) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(E);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function o(E) {
    return p(E) || f(E) || c(E) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(E, m) {
    if (E) {
      if (typeof E == "string")
        return O(E, m);
      var P = Object.prototype.toString.call(E).slice(8, -1);
      if (P === "Object" && E.constructor && (P = E.constructor.name), P === "Map" || P === "Set")
        return Array.from(E);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return O(E, m);
    }
  }
  function f(E) {
    if (typeof Symbol < "u" && E[Symbol.iterator] != null || E["@@iterator"] != null)
      return Array.from(E);
  }
  function p(E) {
    if (Array.isArray(E))
      return O(E);
  }
  function O(E, m) {
    (m == null || m > E.length) && (m = E.length);
    for (var P = 0, R = new Array(m); P < m; P++)
      R[P] = E[P];
    return R;
  }
  function d2(E, m) {
    if (!(E instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(E, m) {
    for (var P = 0; P < m.length; P++) {
      var R = m[P];
      R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(E, R.key, R);
    }
  }
  function L(E, m, P) {
    return m && g(E.prototype, m), P && g(E, P), Object.defineProperty(E, "prototype", { writable: false }), E;
  }
  function D(E, m) {
    if (typeof m != "function" && m !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(m && m.prototype, { constructor: { value: E, writable: true, configurable: true } }), Object.defineProperty(E, "prototype", { writable: false }), m && W(E, m);
  }
  function W(E, m) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, A) {
      return R.__proto__ = A, R;
    }, W(E, m);
  }
  function x(E) {
    var m = $();
    return function() {
      var R = z(E), A;
      if (m) {
        var y2 = z(this).constructor;
        A = Reflect.construct(R, arguments, y2);
      } else
        A = R.apply(this, arguments);
      return V(this, A);
    };
  }
  function V(E, m) {
    if (m && (r(m) === "object" || typeof m == "function"))
      return m;
    if (m !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(E);
  }
  function _2(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(E) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
      return P.__proto__ || Object.getPrototypeOf(P);
    }, z(E);
  }
  function F(E, m, P) {
    return m in E ? Object.defineProperty(E, m, { value: P, enumerable: true, configurable: true, writable: true }) : E[m] = P, E;
  }
  var ae = {
    // https://www.sqlite.org/lang_corefunc.html
    scalar: ["ABS", "CHANGES", "CHAR", "COALESCE", "FORMAT", "GLOB", "HEX", "IFNULL", "IIF", "INSTR", "LAST_INSERT_ROWID", "LENGTH", "LIKE", "LIKELIHOOD", "LIKELY", "LOAD_EXTENSION", "LOWER", "LTRIM", "NULLIF", "PRINTF", "QUOTE", "RANDOM", "RANDOMBLOB", "REPLACE", "ROUND", "RTRIM", "SIGN", "SOUNDEX", "SQLITE_COMPILEOPTION_GET", "SQLITE_COMPILEOPTION_USED", "SQLITE_OFFSET", "SQLITE_SOURCE_ID", "SQLITE_VERSION", "SUBSTR", "SUBSTRING", "TOTAL_CHANGES", "TRIM", "TYPEOF", "UNICODE", "UNLIKELY", "UPPER", "ZEROBLOB"],
    // https://www.sqlite.org/lang_aggfunc.html
    aggregate: ["AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "SUM", "TOTAL"],
    // https://www.sqlite.org/lang_datefunc.html
    datetime: ["DATE", "TIME", "DATETIME", "JULIANDAY", "UNIXEPOCH", "STRFTIME"]
  }, U = [
    "ABORT",
    "ACTION",
    "ADD",
    "AFTER",
    "ALL",
    "ALTER",
    // 'AND',
    "ANY",
    "ARE",
    "ARRAY",
    "ALWAYS",
    "ANALYZE",
    "AS",
    "ASC",
    "ATTACH",
    "AUTOINCREMENT",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    "BY",
    "CASCADE",
    "CASE",
    "CAST",
    "CHECK",
    "COLLATE",
    "COLUMN",
    "COMMIT",
    "CONFLICT",
    "CONSTRAINT",
    "CREATE",
    "CROSS",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "DATABASE",
    "DEFAULT",
    "DEFERRABLE",
    "DEFERRED",
    "DELETE",
    "DESC",
    "DETACH",
    "DISTINCT",
    "DO",
    "DROP",
    "EACH",
    "ELSE",
    "END",
    "ESCAPE",
    "EXCEPT",
    "EXCLUDE",
    "EXCLUSIVE",
    "EXISTS",
    "EXPLAIN",
    "FAIL",
    "FILTER",
    "FIRST",
    "FOLLOWING",
    "FOR",
    "FOREIGN",
    "FROM",
    "FULL",
    "GENERATED",
    "GLOB",
    "GROUP",
    "GROUPS",
    "HAVING",
    "IF",
    "IGNORE",
    "IMMEDIATE",
    "IN",
    "INDEX",
    "INDEXED",
    "INITIALLY",
    "INNER",
    "INSERT",
    "INSTEAD",
    "INTERSECT",
    "INTO",
    "IS",
    "ISNULL",
    "JOIN",
    "KEY",
    "LAST",
    "LEFT",
    "LIKE",
    "LIMIT",
    "MATCH",
    "MATERIALIZED",
    "NATURAL",
    "NO",
    "NOT",
    "NOTHING",
    "NOTNULL",
    "NULL",
    "NULLS",
    "OF",
    "OFFSET",
    "ON DELETE",
    "ON UPDATE",
    "ONLY",
    "OPEN",
    // 'OR',
    "ORDER",
    "OTHERS",
    "OUTER",
    "OVER",
    "PARTITION",
    "PLAN",
    "PRAGMA",
    "PRECEDING",
    "PRIMARY",
    "QUERY",
    "RAISE",
    "RANGE",
    "RECURSIVE",
    "REFERENCES",
    "REGEXP",
    "REINDEX",
    "RELEASE",
    "RENAME",
    "REPLACE",
    "RESTRICT",
    "RETURNING",
    "RIGHT",
    "ROLLBACK",
    "ROW",
    "ROWS",
    "SAVEPOINT",
    "SELECT",
    "SET",
    "TABLE",
    "TEMP",
    "TEMPORARY",
    "THEN",
    "TIES",
    "TO",
    "TRANSACTION",
    "TRIGGER",
    "UNBOUNDED",
    "UNION",
    "UNIQUE",
    "UPDATE",
    "USING",
    "VACUUM",
    "VALUES",
    "VIEW",
    "VIRTUAL",
    "WHEN",
    "WHERE",
    "WINDOW",
    "WITH",
    "WITHOUT"
  ], G = ["ADD", "ALTER COLUMN", "ALTER TABLE", "CREATE TABLE", "DROP TABLE", "DELETE", "DELETE FROM", "FETCH FIRST", "FETCH NEXT", "FETCH PRIOR", "FETCH LAST", "FETCH ABSOLUTE", "FETCH RELATIVE", "FROM", "GROUP BY", "HAVING", "INSERT INTO", "LIMIT", "OFFSET", "ORDER BY", "SELECT", "SET SCHEMA", "SET", "UPDATE", "VALUES", "WHERE", "WITH", "WINDOW", "PARTITION BY"], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT"], re = ["JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "INNER JOIN", "CROSS JOIN", "NATURAL JOIN", "NATURAL LEFT JOIN", "NATURAL LEFT OUTER JOIN", "NATURAL INNER JOIN", "NATURAL CROSS JOIN"], B = ["WHEN", "ELSE"], Y = function(E) {
    D(P, E);
    var m = x(P);
    function P() {
      return d2(this, P), m.apply(this, arguments);
    }
    return L(P, [{
      key: "tokenizer",
      value: (
        // https://www.sqlite.org/lang_expr.html
        function() {
          return new n.default({
            reservedCommands: G,
            reservedBinaryCommands: H,
            reservedJoins: re,
            reservedDependentClauses: B,
            reservedKeywords: (0, a.dedupe)([].concat(U, o(Object.values(ae).flat()))),
            stringTypes: [{
              quote: "''",
              prefixes: ["X"]
            }],
            identTypes: ['""', "``", "[]"],
            // https://www.sqlite.org/lang_expr.html#parameters
            positionalParams: true,
            numberedParamTypes: ["?"],
            namedParamTypes: [":", "@", "$"],
            operators: P.operators
          });
        }
      )
    }]), P;
  }(i.default);
  t.default = Y, F(Y, "operators", ["~", "->", "->>", "||", "<<", ">>", "=="]), e.exports = t.default;
})(Jl, Jl.exports);
var F_ = Jl.exports;
var Kl = { exports: {} };
(function(e, t) {
  function r(E) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(E);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function o(E) {
    return p(E) || f(E) || c(E) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(E, m) {
    if (E) {
      if (typeof E == "string")
        return O(E, m);
      var P = Object.prototype.toString.call(E).slice(8, -1);
      if (P === "Object" && E.constructor && (P = E.constructor.name), P === "Map" || P === "Set")
        return Array.from(E);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return O(E, m);
    }
  }
  function f(E) {
    if (typeof Symbol < "u" && E[Symbol.iterator] != null || E["@@iterator"] != null)
      return Array.from(E);
  }
  function p(E) {
    if (Array.isArray(E))
      return O(E);
  }
  function O(E, m) {
    (m == null || m > E.length) && (m = E.length);
    for (var P = 0, R = new Array(m); P < m; P++)
      R[P] = E[P];
    return R;
  }
  function d2(E, m) {
    if (!(E instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(E, m) {
    for (var P = 0; P < m.length; P++) {
      var R = m[P];
      R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(E, R.key, R);
    }
  }
  function L(E, m, P) {
    return m && g(E.prototype, m), P && g(E, P), Object.defineProperty(E, "prototype", { writable: false }), E;
  }
  function D(E, m) {
    if (typeof m != "function" && m !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(m && m.prototype, { constructor: { value: E, writable: true, configurable: true } }), Object.defineProperty(E, "prototype", { writable: false }), m && W(E, m);
  }
  function W(E, m) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, A) {
      return R.__proto__ = A, R;
    }, W(E, m);
  }
  function x(E) {
    var m = $();
    return function() {
      var R = z(E), A;
      if (m) {
        var y2 = z(this).constructor;
        A = Reflect.construct(R, arguments, y2);
      } else
        A = R.apply(this, arguments);
      return V(this, A);
    };
  }
  function V(E, m) {
    if (m && (r(m) === "object" || typeof m == "function"))
      return m;
    if (m !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(E);
  }
  function _2(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(E) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
      return P.__proto__ || Object.getPrototypeOf(P);
    }, z(E);
  }
  function F(E, m, P) {
    return m in E ? Object.defineProperty(E, m, { value: P, enumerable: true, configurable: true, writable: true }) : E[m] = P, E;
  }
  var ae = {
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_9_set_function_specification
    set: ["GROUPING"],
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_10_window_function
    window: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "ROW_NUMBER"],
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_27_numeric_value_function
    numeric: ["POSITION", "OCCURRENCES_REGEX", "POSITION_REGEX", "EXTRACT", "CHAR_LENGTH", "CHARACTER_LENGTH", "OCTET_LENGTH", "CARDINALITY", "ABS", "MOD", "LN", "EXP", "POWER", "SQRT", "FLOOR", "CEIL", "CEILING", "WIDTH_BUCKET"],
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_29_string_value_function
    string: ["SUBSTRING", "SUBSTRING_REGEX", "UPPER", "LOWER", "CONVERT", "TRANSLATE", "TRANSLATE_REGEX", "TRIM", "OVERLAY", "NORMALIZE", "SPECIFICTYPE"],
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_31_datetime_value_function
    datetime: ["CURRENT_DATE", "CURRENT_TIME", "LOCALTIME", "CURRENT_TIMESTAMP", "LOCALTIMESTAMP"],
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_38_multiset_value_function
    // SET serves multiple roles: a SET() function and a SET keyword e.g. in UPDATE table SET ...
    // multiset: ['SET'], (disabled for now)
    // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_10_9_aggregate_function
    aggregate: ["COUNT", "AVG", "MAX", "MIN", "SUM", "EVERY", "ANY", "SOME", "STDDEV_POP", "STDDEV_SAMP", "VAR_SAMP", "VAR_POP", "COLLECT", "FUSION", "INTERSECTION", "COVAR_POP", "COVAR_SAMP", "CORR", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "PERCENTILE_CONT", "PERCENTILE_DISC"]
    // CAST is a pretty complex case, involving multiple forms:
    // - CAST(col AS int)
    // - CAST(...) WITH ...
    // - CAST FROM int
    // - CREATE CAST(mycol AS int) WITH ...
    // cast: ['CAST'], (disabled for now)
  }, U = ["ALL", "ALLOCATE", "ALTER", "ARE", "ARRAY", "AS", "ASENSITIVE", "ASYMMETRIC", "AT", "ATOMIC", "AUTHORIZATION", "BEGIN", "BETWEEN", "BIGINT", "BINARY", "BLOB", "BOOLEAN", "BOTH", "BY", "CALL", "CALLED", "CASCADED", "CAST", "CHAR", "CHARACTER", "CHECK", "CLOB", "CLOSE", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "CONDITION", "CONNECT", "CONSTRAINT", "CORRESPONDING", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_CATALOG", "CURRENT_DEFAULT_TRANSFORM_GROUP", "CURRENT_PATH", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TRANSFORM_GROUP_FOR_TYPE", "CURRENT_USER", "CURSOR", "CYCLE", "DATE", "DAY", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DELETE", "DEREF", "DESCRIBE", "DETERMINISTIC", "DISCONNECT", "DISTINCT", "DOUBLE", "DROP", "DYNAMIC", "EACH", "ELEMENT", "END-EXEC", "ESCAPE", "EXCEPT", "EXEC", "EXECUTE", "EXISTS", "EXTERNAL", "FALSE", "FETCH", "FILTER", "FLOAT", "FOR", "FOREIGN", "FREE", "FROM", "FULL", "FUNCTION", "GET", "GLOBAL", "GRANT", "GROUP", "HAVING", "HOLD", "HOUR", "IDENTITY", "IN", "INDICATOR", "INNER", "INOUT", "INSENSITIVE", "INSERT", "INT", "INTEGER", "INTERSECT", "INTERVAL", "INTO", "IS", "LANGUAGE", "LARGE", "LATERAL", "LEADING", "LEFT", "LIKE", "LIKE_REGEX", "LOCAL", "MATCH", "MEMBER", "MERGE", "METHOD", "MINUTE", "MODIFIES", "MODULE", "MONTH", "MULTISET", "NATIONAL", "NATURAL", "NCHAR", "NCLOB", "NEW", "NO", "NONE", "NOT", "NULL", "NULLIF", "NUMERIC", "OF", "OLD", "ON DELETE", "ON UPDATE", "ONLY", "OPEN", "ORDER", "OUT", "OUTER", "OVER", "OVERLAPS", "PARAMETER", "PARTITION", "PRECISION", "PREPARE", "PRIMARY", "PROCEDURE", "RANGE", "READS", "REAL", "RECURSIVE", "REF", "REFERENCES", "REFERENCING", "RELEASE", "RESULT", "RETURN", "RETURNS", "REVOKE", "RIGHT", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SAVEPOINT", "SCOPE", "SCROLL", "SEARCH", "SECOND", "SELECT", "SENSITIVE", "SESSION_USER", "SET", "SIMILAR", "SMALLINT", "SPECIFIC", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "START", "STATIC", "SUBMULTISET", "SYMMETRIC", "SYSTEM", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "THEN", "TIME", "TIMESTAMP", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO", "TRAILING", "TRANSLATION", "TREAT", "TRIGGER", "TRUE", "UESCAPE", "UNION", "UNIQUE", "UNKNOWN", "UNNEST", "UPDATE", "USER", "VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARYING", "WHENEVER", "WINDOW", "WITHIN", "WITHOUT", "YEAR"], G = ["ADD", "ALTER COLUMN", "ALTER TABLE", "CREATE TABLE", "DROP TABLE", "DELETE FROM", "FETCH FIRST", "FETCH NEXT", "FETCH PRIOR", "FETCH LAST", "FETCH ABSOLUTE", "FETCH RELATIVE", "FROM", "GROUP BY", "HAVING", "INSERT INTO", "LIMIT", "OFFSET", "ORDER BY", "SELECT", "SET SCHEMA", "SET", "UPDATE", "VALUES", "WHERE", "WITH", "WINDOW", "PARTITION BY"], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT"], re = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN", "NATURAL JOIN"], B = ["WHEN", "ELSE"], Y = function(E) {
    D(P, E);
    var m = x(P);
    function P() {
      return d2(this, P), m.apply(this, arguments);
    }
    return L(P, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: G,
          reservedBinaryCommands: H,
          reservedJoins: re,
          reservedDependentClauses: B,
          reservedKeywords: (0, a.dedupe)([].concat(U, o(Object.values(ae).flat()))),
          stringTypes: [{
            quote: "''",
            prefixes: ["X"]
          }],
          identTypes: ['""', "``"],
          positionalParams: true
        });
      }
    }]), P;
  }(i.default);
  t.default = Y, F(Y, "operators", []), e.exports = t.default;
})(Kl, Kl.exports);
var W_ = Kl.exports;
var eu = { exports: {} };
(function(e, t) {
  function r(E) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, r(E);
  }
  Object.defineProperty(t, "__esModule", {
    value: true
  }), t.default = void 0;
  var i = s(ur), n = s(cr), a = Xe;
  function s(E) {
    return E && E.__esModule ? E : { default: E };
  }
  function o(E) {
    return p(E) || f(E) || c(E) || l();
  }
  function l() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function c(E, m) {
    if (E) {
      if (typeof E == "string")
        return O(E, m);
      var P = Object.prototype.toString.call(E).slice(8, -1);
      if (P === "Object" && E.constructor && (P = E.constructor.name), P === "Map" || P === "Set")
        return Array.from(E);
      if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
        return O(E, m);
    }
  }
  function f(E) {
    if (typeof Symbol < "u" && E[Symbol.iterator] != null || E["@@iterator"] != null)
      return Array.from(E);
  }
  function p(E) {
    if (Array.isArray(E))
      return O(E);
  }
  function O(E, m) {
    (m == null || m > E.length) && (m = E.length);
    for (var P = 0, R = new Array(m); P < m; P++)
      R[P] = E[P];
    return R;
  }
  function d2(E, m) {
    if (!(E instanceof m))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(E, m) {
    for (var P = 0; P < m.length; P++) {
      var R = m[P];
      R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(E, R.key, R);
    }
  }
  function L(E, m, P) {
    return m && g(E.prototype, m), P && g(E, P), Object.defineProperty(E, "prototype", { writable: false }), E;
  }
  function D(E, m) {
    if (typeof m != "function" && m !== null)
      throw new TypeError("Super expression must either be null or a function");
    E.prototype = Object.create(m && m.prototype, { constructor: { value: E, writable: true, configurable: true } }), Object.defineProperty(E, "prototype", { writable: false }), m && W(E, m);
  }
  function W(E, m) {
    return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, A) {
      return R.__proto__ = A, R;
    }, W(E, m);
  }
  function x(E) {
    var m = $();
    return function() {
      var R = z(E), A;
      if (m) {
        var y2 = z(this).constructor;
        A = Reflect.construct(R, arguments, y2);
      } else
        A = R.apply(this, arguments);
      return V(this, A);
    };
  }
  function V(E, m) {
    if (m && (r(m) === "object" || typeof m == "function"))
      return m;
    if (m !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return _2(E);
  }
  function _2(E) {
    if (E === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return E;
  }
  function $() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return false;
    if (typeof Proxy == "function")
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch {
      return false;
    }
  }
  function z(E) {
    return z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(P) {
      return P.__proto__ || Object.getPrototypeOf(P);
    }, z(E);
  }
  function F(E, m, P) {
    return m in E ? Object.defineProperty(E, m, { value: P, enumerable: true, configurable: true, writable: true }) : E[m] = P, E;
  }
  var ae = {
    aggregate: ["APPROX_COUNT_DISTINCT", "AVG", "CHECKSUM_AGG", "COUNT", "COUNT_BIG", "GROUPING", "GROUPING_ID", "MAX", "MIN", "STDEV", "STDEVP", "SUM", "VAR", "VARP"],
    analytic: ["CUME_DIST", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "Collation - COLLATIONPROPERTY", "Collation - TERTIARY_WEIGHTS"],
    configuration: ["@@DBTS", "@@LANGID", "@@LANGUAGE", "@@LOCK_TIMEOUT", "@@MAX_CONNECTIONS", "@@MAX_PRECISION", "@@NESTLEVEL", "@@OPTIONS", "@@REMSERVER", "@@SERVERNAME", "@@SERVICENAME", "@@SPID", "@@TEXTSIZE", "@@VERSION"],
    conversion: ["CAST", "CONVERT", "PARSE", "TRY_CAST", "TRY_CONVERT", "TRY_PARSE"],
    cryptographic: ["ASYMKEY_ID", "ASYMKEYPROPERTY", "CERTPROPERTY", "CERT_ID", "CRYPT_GEN_RANDOM", "DECRYPTBYASYMKEY", "DECRYPTBYCERT", "DECRYPTBYKEY", "DECRYPTBYKEYAUTOASYMKEY", "DECRYPTBYKEYAUTOCERT", "DECRYPTBYPASSPHRASE", "ENCRYPTBYASYMKEY", "ENCRYPTBYCERT", "ENCRYPTBYKEY", "ENCRYPTBYPASSPHRASE", "HASHBYTES", "IS_OBJECTSIGNED", "KEY_GUID", "KEY_ID", "KEY_NAME", "SIGNBYASYMKEY", "SIGNBYCERT", "SYMKEYPROPERTY", "VERIFYSIGNEDBYCERT", "VERIFYSIGNEDBYASYMKEY"],
    cursor: ["@@CURSOR_ROWS", "@@FETCH_STATUS", "CURSOR_STATUS"],
    dataType: ["DATALENGTH", "IDENT_CURRENT", "IDENT_INCR", "IDENT_SEED", "IDENTITY", "SQL_VARIANT_PROPERTY"],
    datetime: ["@@DATEFIRST", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_TIMEZONE_ID", "DATEADD", "DATEDIFF", "DATEDIFF_BIG", "DATEFROMPARTS", "DATENAME", "DATEPART", "DATETIME2FROMPARTS", "DATETIMEFROMPARTS", "DATETIMEOFFSETFROMPARTS", "DAY", "EOMONTH", "GETDATE", "GETUTCDATE", "ISDATE", "MONTH", "SMALLDATETIMEFROMPARTS", "SWITCHOFFSET", "SYSDATETIME", "SYSDATETIMEOFFSET", "SYSUTCDATETIME", "TIMEFROMPARTS", "TODATETIMEOFFSET", "YEAR", "JSON", "ISJSON", "JSON_VALUE", "JSON_QUERY", "JSON_MODIFY"],
    mathematical: ["ABS", "ACOS", "ASIN", "ATAN", "ATN2", "CEILING", "COS", "COT", "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "PI", "POWER", "RADIANS", "RAND", "ROUND", "SIGN", "SIN", "SQRT", "SQUARE", "TAN", "CHOOSE", "GREATEST", "IIF", "LEAST"],
    metadata: ["@@PROCID", "APP_NAME", "APPLOCK_MODE", "APPLOCK_TEST", "ASSEMBLYPROPERTY", "COL_LENGTH", "COL_NAME", "COLUMNPROPERTY", "DATABASEPROPERTYEX", "DB_ID", "DB_NAME", "FILE_ID", "FILE_IDEX", "FILE_NAME", "FILEGROUP_ID", "FILEGROUP_NAME", "FILEGROUPPROPERTY", "FILEPROPERTY", "FILEPROPERTYEX", "FULLTEXTCATALOGPROPERTY", "FULLTEXTSERVICEPROPERTY", "INDEX_COL", "INDEXKEY_PROPERTY", "INDEXPROPERTY", "NEXT VALUE FOR", "OBJECT_DEFINITION", "OBJECT_ID", "OBJECT_NAME", "OBJECT_SCHEMA_NAME", "OBJECTPROPERTY", "OBJECTPROPERTYEX", "ORIGINAL_DB_NAME", "PARSENAME", "SCHEMA_ID", "SCHEMA_NAME", "SCOPE_IDENTITY", "SERVERPROPERTY", "STATS_DATE", "TYPE_ID", "TYPE_NAME", "TYPEPROPERTY"],
    ranking: ["DENSE_RANK", "NTILE", "RANK", "ROW_NUMBER", "PUBLISHINGSERVERNAME"],
    security: ["CERTENCODED", "CERTPRIVATEKEY", "CURRENT_USER", "DATABASE_PRINCIPAL_ID", "HAS_DBACCESS", "HAS_PERMS_BY_NAME", "IS_MEMBER", "IS_ROLEMEMBER", "IS_SRVROLEMEMBER", "LOGINPROPERTY", "ORIGINAL_LOGIN", "PERMISSIONS", "PWDENCRYPT", "PWDCOMPARE", "SESSION_USER", "SESSIONPROPERTY", "SUSER_ID", "SUSER_NAME", "SUSER_SID", "SUSER_SNAME", "SYSTEM_USER", "USER", "USER_ID", "USER_NAME"],
    string: ["ASCII", "CHAR", "CHARINDEX", "CONCAT", "CONCAT_WS", "DIFFERENCE", "FORMAT", "LEFT", "LEN", "LOWER", "LTRIM", "NCHAR", "PATINDEX", "QUOTENAME", "REPLACE", "REPLICATE", "REVERSE", "RIGHT", "RTRIM", "SOUNDEX", "SPACE", "STR", "STRING_AGG", "STRING_ESCAPE", "STUFF", "SUBSTRING", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
    system: ["$PARTITION", "@@ERROR", "@@IDENTITY", "@@PACK_RECEIVED", "@@ROWCOUNT", "@@TRANCOUNT", "BINARY_CHECKSUM", "CHECKSUM", "COMPRESS", "CONNECTIONPROPERTY", "CONTEXT_INFO", "CURRENT_REQUEST_ID", "CURRENT_TRANSACTION_ID", "DECOMPRESS", "ERROR_LINE", "ERROR_MESSAGE", "ERROR_NUMBER", "ERROR_PROCEDURE", "ERROR_SEVERITY", "ERROR_STATE", "FORMATMESSAGE", "GET_FILESTREAM_TRANSACTION_CONTEXT", "GETANSINULL", "HOST_ID", "HOST_NAME", "ISNULL", "ISNUMERIC", "MIN_ACTIVE_ROWVERSION", "NEWID", "NEWSEQUENTIALID", "ROWCOUNT_BIG", "SESSION_CONTEXT", "XACT_STATE"],
    statistical: ["@@CONNECTIONS", "@@CPU_BUSY", "@@IDLE", "@@IO_BUSY", "@@PACK_SENT", "@@PACKET_ERRORS", "@@TIMETICKS", "@@TOTAL_ERRORS", "@@TOTAL_READ", "@@TOTAL_WRITE", "TEXTPTR", "TEXTVALID"],
    trigger: ["COLUMNS_UPDATED", "EVENTDATA", "TRIGGER_NESTLEVEL", "UPDATE"]
  }, U = {
    standard: [
      "ADD",
      "ALL",
      "ALTER",
      // 'AND',
      "ANY",
      "AS",
      "ASC",
      "AUTHORIZATION",
      "BACKUP",
      "BEGIN",
      "BETWEEN",
      "BREAK",
      "BROWSE",
      "BULK",
      "BY",
      "CASCADE",
      "CHECK",
      "CHECKPOINT",
      "CLOSE",
      "CLUSTERED",
      "COALESCE",
      "COLLATE",
      "COLUMN",
      "COMMIT",
      "COMPUTE",
      "CONSTRAINT",
      "CONTAINS",
      "CONTAINSTABLE",
      "CONTINUE",
      "CONVERT",
      "CREATE",
      "CROSS",
      "CURRENT",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "CURRENT_USER",
      "CURSOR",
      "DATABASE",
      "DBCC",
      "DEALLOCATE",
      "DECLARE",
      "DEFAULT",
      "DELETE",
      "DENY",
      "DESC",
      "DISK",
      "DISTINCT",
      "DISTRIBUTED",
      "DOUBLE",
      "DROP",
      "DUMP",
      "ERRLVL",
      "ESCAPE",
      "EXEC",
      "EXECUTE",
      "EXISTS",
      "EXIT",
      "EXTERNAL",
      "FETCH",
      "FILE",
      "FILLFACTOR",
      "FOR",
      "FOREIGN",
      "FREETEXT",
      "FREETEXTTABLE",
      "FROM",
      "FULL",
      "FUNCTION",
      "GOTO",
      "GRANT",
      "GROUP",
      "HAVING",
      "HOLDLOCK",
      "IDENTITY",
      "IDENTITYCOL",
      "IDENTITY_INSERT",
      "IF",
      "IN",
      "INDEX",
      "INNER",
      "INSERT",
      "INTERSECT",
      "INTO",
      "IS",
      "JOIN",
      "KEY",
      "KILL",
      "LEFT",
      "LIKE",
      "LINENO",
      "LOAD",
      "MERGE",
      "NATIONAL",
      "NOCHECK",
      "NONCLUSTERED",
      "NOT",
      "NULL",
      "NULLIF",
      "OF",
      "OFF",
      "OFFSETS",
      "ON DELETE",
      "ON UPDATE",
      "OPEN",
      "OPENDATASOURCE",
      "OPENQUERY",
      "OPENROWSET",
      "OPENXML",
      "OPTION",
      // 'OR',
      "ORDER",
      "OUTER",
      "OVER",
      "PERCENT",
      "PIVOT",
      "PLAN",
      "PRECISION",
      "PRIMARY",
      "PRINT",
      "PROC",
      "PROCEDURE",
      "PUBLIC",
      "RAISERROR",
      "READ",
      "READTEXT",
      "RECONFIGURE",
      "REFERENCES",
      "REPLICATION",
      "RESTORE",
      "RESTRICT",
      "RETURN",
      "REVERT",
      "REVOKE",
      "RIGHT",
      "ROLLBACK",
      "ROWCOUNT",
      "ROWGUIDCOL",
      "RULE",
      "SAVE",
      "SCHEMA",
      "SECURITYAUDIT",
      "SELECT",
      "SEMANTICKEYPHRASETABLE",
      "SEMANTICSIMILARITYDETAILSTABLE",
      "SEMANTICSIMILARITYTABLE",
      "SESSION_USER",
      "SET",
      "SETUSER",
      "SHUTDOWN",
      "SOME",
      "STATISTICS",
      "SYSTEM_USER",
      "TABLE",
      "TABLESAMPLE",
      "TEXTSIZE",
      "THEN",
      "TO",
      "TOP",
      "TRAN",
      "TRANSACTION",
      "TRIGGER",
      "TRUNCATE",
      "TRY_CONVERT",
      "TSEQUAL",
      "UNION",
      "UNIQUE",
      "UNPIVOT",
      "UPDATE",
      "UPDATETEXT",
      "USE",
      "USER",
      "VALUES",
      "VARYING",
      "VIEW",
      "WAITFOR",
      "WHERE",
      "WHILE",
      "WITH",
      "WITHIN GROUP",
      "WRITETEXT"
    ],
    odbc: [
      "ABSOLUTE",
      "ACTION",
      "ADA",
      "ADD",
      "ALL",
      "ALLOCATE",
      "ALTER",
      // 'AND',
      "ANY",
      "ARE",
      "AS",
      "ASC",
      "ASSERTION",
      "AT",
      "AUTHORIZATION",
      "AVG",
      "BEGIN",
      "BETWEEN",
      "BIT",
      "BIT_LENGTH",
      "BOTH",
      "BY",
      "CASCADE",
      "CASCADED",
      "CAST",
      "CATALOG",
      "CHAR",
      "CHARACTER",
      "CHARACTER_LENGTH",
      "CHAR_LENGTH",
      "CHECK",
      "CLOSE",
      "COALESCE",
      "COLLATE",
      "COLLATION",
      "COLUMN",
      "COMMIT",
      "CONNECT",
      "CONNECTION",
      "CONSTRAINT",
      "CONSTRAINTS",
      "CONTINUE",
      "CONVERT",
      "CORRESPONDING",
      "COUNT",
      "CREATE",
      "CROSS",
      "CURRENT",
      "CURRENT_DATE",
      "CURRENT_TIME",
      "CURRENT_TIMESTAMP",
      "CURRENT_USER",
      "CURSOR",
      "DATE",
      "DAY",
      "DEALLOCATE",
      "DEC",
      "DECIMAL",
      "DECLARE",
      "DEFAULT",
      "DEFERRABLE",
      "DEFERRED",
      "DELETE",
      "DESC",
      "DESCRIBE",
      "DESCRIPTOR",
      "DIAGNOSTICS",
      "DISCONNECT",
      "DISTINCT",
      "DOMAIN",
      "DOUBLE",
      "DROP",
      "END-EXEC",
      "ESCAPE",
      "EXCEPTION",
      "EXEC",
      "EXECUTE",
      "EXISTS",
      "EXTERNAL",
      "EXTRACT",
      "FALSE",
      "FETCH",
      "FIRST",
      "FLOAT",
      "FOR",
      "FOREIGN",
      "FORTRAN",
      "FOUND",
      "FROM",
      "FULL",
      "GET",
      "GLOBAL",
      "GO",
      "GOTO",
      "GRANT",
      "GROUP",
      "HAVING",
      "HOUR",
      "IDENTITY",
      "IMMEDIATE",
      "IN",
      "INCLUDE",
      "INDEX",
      "INDICATOR",
      "INITIALLY",
      "INNER",
      "INPUT",
      "INSENSITIVE",
      "INSERT",
      "INT",
      "INTEGER",
      "INTERSECT",
      "INTERVAL",
      "INTO",
      "IS",
      "ISOLATION",
      "JOIN",
      "KEY",
      "LANGUAGE",
      "LAST",
      "LEADING",
      "LEFT",
      "LEVEL",
      "LIKE",
      "LOCAL",
      "LOWER",
      "MATCH",
      "MAX",
      "MIN",
      "MINUTE",
      "MODULE",
      "MONTH",
      "NAMES",
      "NATIONAL",
      "NATURAL",
      "NCHAR",
      "NEXT",
      "NO",
      "NONE",
      "NOT",
      "NULL",
      "NULLIF",
      "NUMERIC",
      "OCTET_LENGTH",
      "OF",
      "ONLY",
      "OPEN",
      "OPTION",
      // 'OR',
      "ORDER",
      "OUTER",
      "OUTPUT",
      "OVERLAPS",
      "PAD",
      "PARTIAL",
      "PASCAL",
      "POSITION",
      "PRECISION",
      "PREPARE",
      "PRESERVE",
      "PRIMARY",
      "PRIOR",
      "PRIVILEGES",
      "PROCEDURE",
      "PUBLIC",
      "READ",
      "REAL",
      "REFERENCES",
      "RELATIVE",
      "RESTRICT",
      "REVOKE",
      "RIGHT",
      "ROLLBACK",
      "ROWS",
      "SCHEMA",
      "SCROLL",
      "SECOND",
      "SECTION",
      "SELECT",
      "SESSION",
      "SESSION_USER",
      "SET",
      "SIZE",
      "SMALLINT",
      "SOME",
      "SPACE",
      "SQL",
      "SQLCA",
      "SQLCODE",
      "SQLERROR",
      "SQLSTATE",
      "SQLWARNING",
      "SUBSTRING",
      "SUM",
      "SYSTEM_USER",
      "TABLE",
      "TEMPORARY",
      "TIME",
      "TIMESTAMP",
      "TIMEZONE_HOUR",
      "TIMEZONE_MINUTE",
      "TO",
      "TRAILING",
      "TRANSACTION",
      "TRANSLATE",
      "TRANSLATION",
      "TRIM",
      "TRUE",
      "UNION",
      "UNIQUE",
      "UNKNOWN",
      "UPDATE",
      "UPPER",
      "USAGE",
      "USER",
      "VALUE",
      "VALUES",
      "VARCHAR",
      "VARYING",
      "VIEW",
      "WHENEVER",
      "WHERE",
      "WITH",
      "WORK",
      "WRITE",
      "YEAR",
      "ZONE"
    ],
    future: ["ABSOLUTE", "ACTION", "ADMIN", "AFTER", "AGGREGATE", "ALIAS", "ALLOCATE", "ARE", "ARRAY", "ASENSITIVE", "ASSERTION", "ASYMMETRIC", "AT", "ATOMIC", "BEFORE", "BINARY", "BIT", "BLOB", "BOOLEAN", "BOTH", "BREADTH", "CALL", "CALLED", "CARDINALITY", "CASCADED", "CAST", "CATALOG", "CHAR", "CHARACTER", "CLASS", "CLOB", "COLLATION", "COLLECT", "COMPLETION", "CONDITION", "CONNECT", "CONNECTION", "CONSTRAINTS", "CONSTRUCTOR", "CORR", "CORRESPONDING", "COVAR_POP", "COVAR_SAMP", "CUBE", "CUME_DIST", "CURRENT_CATALOG", "CURRENT_DEFAULT_TRANSFORM_GROUP", "CURRENT_PATH", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_TRANSFORM_GROUP_FOR_TYPE", "CYCLE", "DATA", "DATE", "DAY", "DEC", "DECIMAL", "DEFERRABLE", "DEFERRED", "DEPTH", "DEREF", "DESCRIBE", "DESCRIPTOR", "DESTROY", "DESTRUCTOR", "DETERMINISTIC", "DIAGNOSTICS", "DICTIONARY", "DISCONNECT", "DOMAIN", "DYNAMIC", "EACH", "ELEMENT", "END-EXEC", "EQUALS", "EVERY", "FALSE", "FILTER", "FIRST", "FLOAT", "FOUND", "FREE", "FULLTEXTTABLE", "FUSION", "GENERAL", "GET", "GLOBAL", "GO", "GROUPING", "HOLD", "HOST", "HOUR", "IGNORE", "IMMEDIATE", "INDICATOR", "INITIALIZE", "INITIALLY", "INOUT", "INPUT", "INT", "INTEGER", "INTERSECTION", "INTERVAL", "ISOLATION", "ITERATE", "LANGUAGE", "LARGE", "LAST", "LATERAL", "LEADING", "LESS", "LEVEL", "LIKE_REGEX", "LIMIT", "LN", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATOR", "MAP", "MATCH", "MEMBER", "METHOD", "MINUTE", "MOD", "MODIFIES", "MODIFY", "MODULE", "MONTH", "MULTISET", "NAMES", "NATURAL", "NCHAR", "NCLOB", "NEW", "NEXT", "NO", "NONE", "NORMALIZE", "NUMERIC", "OBJECT", "OCCURRENCES_REGEX", "OLD", "ONLY", "OPERATION", "ORDINALITY", "OUT", "OUTPUT", "OVERLAY", "PAD", "PARAMETER", "PARAMETERS", "PARTIAL", "PARTITION", "PATH", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "POSITION_REGEX", "POSTFIX", "PREFIX", "PREORDER", "PREPARE", "PRESERVE", "PRIOR", "PRIVILEGES", "RANGE", "READS", "REAL", "RECURSIVE", "REF", "REFERENCING", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "RELATIVE", "RELEASE", "RESULT", "RETURNS", "ROLE", "ROLLUP", "ROUTINE", "ROW", "ROWS", "SAVEPOINT", "SCOPE", "SCROLL", "SEARCH", "SECOND", "SECTION", "SENSITIVE", "SEQUENCE", "SESSION", "SETS", "SIMILAR", "SIZE", "SMALLINT", "SPACE", "SPECIFIC", "SPECIFICTYPE", "SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "START", "STATE", "STATEMENT", "STATIC", "STDDEV_POP", "STDDEV_SAMP", "STRUCTURE", "SUBMULTISET", "SUBSTRING_REGEX", "SYMMETRIC", "SYSTEM", "TEMPORARY", "TERMINATE", "THAN", "TIME", "TIMESTAMP", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TRAILING", "TRANSLATE_REGEX", "TRANSLATION", "TREAT", "TRUE", "UESCAPE", "UNDER", "UNKNOWN", "UNNEST", "USAGE", "USING", "VALUE", "VARCHAR", "VARIABLE", "VAR_POP", "VAR_SAMP", "WHENEVER", "WIDTH_BUCKET", "WINDOW", "WITHIN", "WITHOUT", "WORK", "WRITE", "XMLAGG", "XMLATTRIBUTES", "XMLBINARY", "XMLCAST", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLITERATE", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLSERIALIZE", "XMLTABLE", "XMLTEXT", "XMLVALIDATE", "YEAR", "ZONE"]
  }, G = [
    "ADD SENSITIVITY CLASSIFICATION",
    "ADD SIGNATURE",
    "AGGREGATE",
    "ANSI_DEFAULTS",
    "ANSI_NULLS",
    "ANSI_NULL_DFLT_OFF",
    "ANSI_NULL_DFLT_ON",
    "ANSI_PADDING",
    "ANSI_WARNINGS",
    "APPLICATION ROLE",
    "ARITHABORT",
    "ARITHIGNORE",
    "ASSEMBLY",
    "ASYMMETRIC KEY",
    "AUTHORIZATION",
    "AVAILABILITY GROUP",
    "BACKUP",
    "BACKUP CERTIFICATE",
    "BACKUP MASTER KEY",
    "BACKUP SERVICE MASTER KEY",
    "BEGIN CONVERSATION TIMER",
    "BEGIN DIALOG CONVERSATION",
    "BROKER PRIORITY",
    "BULK INSERT",
    "CERTIFICATE",
    "CLOSE MASTER KEY",
    "CLOSE SYMMETRIC KEY",
    "COLLATE",
    "COLUMN ENCRYPTION KEY",
    "COLUMN MASTER KEY",
    "COLUMNSTORE INDEX",
    "CONCAT_NULL_YIELDS_NULL",
    "CONTEXT_INFO",
    "CONTRACT",
    "CREDENTIAL",
    "CRYPTOGRAPHIC PROVIDER",
    "CURSOR_CLOSE_ON_COMMIT",
    "DATABASE",
    "DATABASE AUDIT SPECIFICATION",
    "DATABASE ENCRYPTION KEY",
    "DATABASE HADR",
    "DATABASE SCOPED CONFIGURATION",
    "DATABASE SCOPED CREDENTIAL",
    "DATABASE SET",
    "DATEFIRST",
    "DATEFORMAT",
    "DEADLOCK_PRIORITY",
    "DEFAULT",
    "DELETE",
    "DELETE FROM",
    "DENY",
    "DENY XML",
    "DISABLE TRIGGER",
    "ENABLE TRIGGER",
    "END CONVERSATION",
    "ENDPOINT",
    "EVENT NOTIFICATION",
    "EVENT SESSION",
    "EXECUTE AS",
    "EXTERNAL DATA SOURCE",
    "EXTERNAL FILE FORMAT",
    "EXTERNAL LANGUAGE",
    "EXTERNAL LIBRARY",
    "EXTERNAL RESOURCE POOL",
    "EXTERNAL TABLE",
    "FIPS_FLAGGER",
    "FMTONLY",
    "FORCEPLAN",
    "FULLTEXT CATALOG",
    "FULLTEXT INDEX",
    "FULLTEXT STOPLIST",
    "FUNCTION",
    "GET CONVERSATION GROUP",
    "GET_TRANSMISSION_STATUS",
    "GRANT",
    "GRANT XML",
    "IDENTITY_INSERT",
    "IMPLICIT_TRANSACTIONS",
    "INDEX",
    "INSERT",
    "LANGUAGE",
    "LOCK_TIMEOUT",
    "LOGIN",
    "MASTER KEY",
    "MERGE",
    "MESSAGE TYPE",
    "MOVE CONVERSATION",
    "NOCOUNT",
    "NOEXEC",
    "NUMERIC_ROUNDABORT",
    "OFFSETS",
    "OPEN MASTER KEY",
    "OPEN SYMMETRIC KEY",
    "PARSEONLY",
    "PARTITION FUNCTION",
    "PARTITION SCHEME",
    "PROCEDURE",
    "QUERY_GOVERNOR_COST_LIMIT",
    "QUEUE",
    "QUOTED_IDENTIFIER",
    "RECEIVE",
    "REMOTE SERVICE BINDING",
    "REMOTE_PROC_TRANSACTIONS",
    "RESOURCE GOVERNOR",
    "RESOURCE POOL",
    "RESTORE",
    "RESTORE FILELISTONLY",
    "RESTORE HEADERONLY",
    "RESTORE LABELONLY",
    "RESTORE MASTER KEY",
    "RESTORE REWINDONLY",
    "RESTORE SERVICE MASTER KEY",
    "RESTORE VERIFYONLY",
    "REVERT",
    "REVOKE",
    "REVOKE XML",
    "ROLE",
    "ROUTE",
    "ROWCOUNT",
    "RULE",
    "SCHEMA",
    "SEARCH PROPERTY LIST",
    "SECURITY POLICY",
    "SELECTIVE XML INDEX",
    "SEND",
    "SENSITIVITY CLASSIFICATION",
    "SEQUENCE",
    "SERVER AUDIT",
    "SERVER AUDIT SPECIFICATION",
    "SERVER CONFIGURATION",
    "SERVER ROLE",
    "SERVICE",
    "SERVICE MASTER KEY",
    "SET",
    "SETUSER",
    "SHOWPLAN_ALL",
    "SHOWPLAN_TEXT",
    "SHOWPLAN_XML",
    "SIGNATURE",
    "SPATIAL INDEX",
    "STATISTICS",
    "STATISTICS IO",
    "STATISTICS PROFILE",
    "STATISTICS TIME",
    "STATISTICS XML",
    "SYMMETRIC KEY",
    "SYNONYM",
    "TABLE",
    "TABLE IDENTITY",
    "TEXTSIZE",
    "TRANSACTION ISOLATION LEVEL",
    "TRIGGER",
    "TRUNCATE TABLE",
    "TYPE",
    "UPDATE",
    "UPDATE STATISTICS",
    "USER",
    "VIEW",
    "WORKLOAD GROUP",
    "XACT_ABORT",
    "XML INDEX",
    "XML SCHEMA COLLECTION",
    // other
    "ALTER COLUMN",
    "ALTER TABLE",
    "CREATE TABLE",
    "FROM",
    "GROUP BY",
    "HAVING",
    "INSERT INTO",
    // verify
    "DROP TABLE",
    // verify
    "SET SCHEMA",
    // verify
    "LIMIT",
    "OFFSET",
    "ORDER BY",
    "SELECT",
    "VALUES",
    "WHERE",
    "WITH",
    "WINDOW",
    "PARTITION BY"
  ], H = ["INTERSECT", "INTERSECT ALL", "INTERSECT DISTINCT", "UNION", "UNION ALL", "UNION DISTINCT", "EXCEPT", "EXCEPT ALL", "EXCEPT DISTINCT", "MINUS", "MINUS ALL", "MINUS DISTINCT"], re = ["JOIN", "INNER JOIN", "LEFT JOIN", "LEFT OUTER JOIN", "RIGHT JOIN", "RIGHT OUTER JOIN", "FULL JOIN", "FULL OUTER JOIN", "CROSS JOIN"], B = ["WHEN", "ELSE"], Y = function(E) {
    D(P, E);
    var m = x(P);
    function P() {
      return d2(this, P), m.apply(this, arguments);
    }
    return L(P, [{
      key: "tokenizer",
      value: function() {
        return new n.default({
          reservedCommands: G,
          reservedBinaryCommands: H,
          reservedJoins: re,
          reservedDependentClauses: B,
          reservedKeywords: (0, a.dedupe)([].concat(o(Object.values(U).flat()), o(Object.values(ae).flat()))),
          stringTypes: [{
            quote: "''",
            prefixes: ["N"]
          }],
          identTypes: ['""', "[]"],
          identChars: {
            first: "#@",
            rest: "#@$"
          },
          namedParamTypes: ["@"],
          quotedParamTypes: ["@"],
          operators: P.operators
          // TODO: Support for money constants
        });
      }
    }]), P;
  }(i.default);
  t.default = Y, F(Y, "operators", ["~", "!<", "!>", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "::"]), e.exports = t.default;
})(eu, eu.exports);
var X_ = eu.exports;
Object.defineProperty(Yr, "__esModule", {
  value: true
});
Yr.supportedDialects = Yr.formatters = Yr.format = Yr.ConfigError = void 0;
var j_ = fr(U_);
var Z_ = fr(w_);
var H_ = fr(M_);
var z_ = fr(k_);
var q_ = fr(Q_);
var J_ = fr(G_);
var K_ = fr(V_);
var eb = fr(B_);
var tb = fr($_);
var rb = fr(Y_);
var ib = fr(F_);
var nb = fr(W_);
var ab = fr(X_);
function fr(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ah(e, t) {
  for (var r = 0; r < t.length; r++) {
    var i = t[r];
    i.enumerable = i.enumerable || false, i.configurable = true, "value" in i && (i.writable = true), Object.defineProperty(e, i.key, i);
  }
}
function sb(e, t, r) {
  return t && Ah(e.prototype, t), r && Ah(e, r), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function ob(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lb(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: true, configurable: true } }), Object.defineProperty(e, "prototype", { writable: false }), t && ha(e, t);
}
function ub(e) {
  var t = Ud();
  return function() {
    var i = pa(e), n;
    if (t) {
      var a = pa(this).constructor;
      n = Reflect.construct(i, arguments, a);
    } else
      n = i.apply(this, arguments);
    return cb(this, n);
  };
}
function cb(e, t) {
  if (t && (Ms(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return fb(e);
}
function fb(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function tu2(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return tu2 = function(i) {
    if (i === null || !hb(i))
      return i;
    if (typeof i != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(i))
        return t.get(i);
      t.set(i, n);
    }
    function n() {
      return ns(i, arguments, pa(this).constructor);
    }
    return n.prototype = Object.create(i.prototype, { constructor: { value: n, enumerable: false, writable: true, configurable: true } }), ha(n, i);
  }, tu2(e);
}
function ns(e, t, r) {
  return Ud() ? ns = Reflect.construct.bind() : ns = function(n, a, s) {
    var o = [null];
    o.push.apply(o, a);
    var l = Function.bind.apply(n, o), c = new l();
    return s && ha(c, s.prototype), c;
  }, ns.apply(null, arguments);
}
function Ud() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return false;
  if (typeof Proxy == "function")
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function hb(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function ha(e, t) {
  return ha = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, n) {
    return i.__proto__ = n, i;
  }, ha(e, t);
}
function pa(e) {
  return pa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, pa(e);
}
function gh(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function yh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gh(Object(r), true).forEach(function(i) {
      pb(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : gh(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function pb(e, t, r) {
  return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
}
function Ms(e) {
  "@babel/helpers - typeof";
  return Ms = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ms(e);
}
var Ic = {
  bigquery: j_.default,
  db2: Z_.default,
  hive: H_.default,
  mariadb: z_.default,
  mysql: q_.default,
  n1ql: J_.default,
  plsql: K_.default,
  postgresql: eb.default,
  redshift: tb.default,
  spark: rb.default,
  sql: nb.default,
  sqlite: ib.default,
  tsql: ab.default
};
Yr.formatters = Ic;
var wd = Object.keys(Ic);
Yr.supportedDialects = wd;
var Ob = {
  language: "sql",
  tabWidth: 2,
  useTabs: false,
  keywordCase: "preserve",
  indentStyle: "standard",
  logicalOperatorNewline: "before",
  aliasAs: "preserve",
  tabulateAlias: false,
  commaPosition: "after",
  expressionWidth: 50,
  linesBetweenQueries: 1,
  denseOperators: false,
  newlineBeforeSemicolon: false
};
var Eb = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof t != "string")
    throw new Error("Invalid query argument. Expected string, instead got " + Ms(t));
  var i = db(yh(yh({}, Ob), r)), n = Ic[i.language];
  return new n(i).format(t);
};
Yr.format = Eb;
var Hr = function(e) {
  lb(r, e);
  var t = ub(r);
  function r() {
    return ob(this, r), t.apply(this, arguments);
  }
  return sb(r);
}(tu2(Error));
Yr.ConfigError = Hr;
function db(e) {
  if (!wd.includes(e.language))
    throw new Hr("Unsupported SQL dialect: ".concat(e.language));
  if ("multilineLists" in e)
    throw new Hr("multilineLists config is no more supported.");
  if ("newlineBeforeOpenParen" in e)
    throw new Hr("newlineBeforeOpenParen config is no more supported.");
  if ("newlineBeforeCloseParen" in e)
    throw new Hr("newlineBeforeCloseParen config is no more supported.");
  if (e.expressionWidth <= 0)
    throw new Hr("expressionWidth config must be positive number. Received ".concat(e.expressionWidth, " instead."));
  if (e.commaPosition === "before" && e.useTabs)
    throw new Hr("commaPosition: before does not work when tabs are used for indentation.");
  if (e.language === "hive" && e.params !== void 0)
    throw new Hr('Unexpected "params" option. Prepared statement placeholders not supported for Hive.');
  if (e.language === "spark" && e.params !== void 0)
    throw new Hr('Unexpected "params" option. Prepared statement placeholders not supported for Spark.');
  return e.params && !Tb(e.params) && console.warn('WARNING: All "params" option values should be strings.'), e;
}
function Tb(e) {
  var t = e instanceof Array ? e : Object.values(e);
  return t.every(function(r) {
    return typeof r == "string";
  });
}
var Md = {};
Object.defineProperty(Md, "__esModule", {
  value: true
});
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: true
  });
  var t = Yr;
  Object.keys(t).forEach(function(i) {
    i === "default" || i === "__esModule" || i in e && e[i] === t[i] || Object.defineProperty(e, i, {
      enumerable: true,
      get: function() {
        return t[i];
      }
    });
  });
  var r = Md;
  Object.keys(r).forEach(function(i) {
    i === "default" || i === "__esModule" || i in e && e[i] === r[i] || Object.defineProperty(e, i, {
      enumerable: true,
      get: function() {
        return r[i];
      }
    });
  });
})(Nd);
async function Sb(e) {
  const t = await require_standalone(), r = await require_postcss();
  return (await t.format(e, {
    parser: "css",
    plugins: [r],
    semi: false
  })).trim();
}
async function mb(e) {
  const t = await require_standalone(), r = await require_html();
  return (await t.format(e, {
    parser: "html",
    plugins: [r],
    semi: false
  })).trim();
}
async function kd() {
  const e = await require_standalone(), t = await require_babel();
  return async (r) => (await e.format(r, {
    parser: "babel",
    plugins: [t],
    semi: false
  })).trim();
}
async function Rb() {
  const e = await require_standalone(), t = await require_babel();
  return async (r) => (await e.format(r, {
    parser: "json",
    plugins: [t]
  })).trim();
}
async function Ab(e, t) {
  try {
    const r = await e(t);
    return r.startsWith(";") ? r.slice(1) : r;
  } catch (r) {
    try {
      const i = await e(`return (${t}
);`);
      return i.startsWith("return ") ? i.slice(7) : i;
    } catch {
      throw r;
    }
  }
}
async function Nc() {
  const e = await kd();
  return async (t) => "{{" + Ab(e, t.slice(2, -2)) + "}}";
}
async function Qd(e) {
  const t = await Nc();
  return Ux(e).map((r) => Ff(r) ? t(r) : r).join("");
}
async function gb(e) {
  if (!e)
    return "";
  const t = await Nc(), r = [];
  let i = Ux(e).map((l) => Ff(l) ? (r.push(l), "{ { " + (r.length - 1) + " } }") : l).join("");
  if (i = Nd.format(i), r.length === 0)
    return i;
  const n = [], a = i.replace(/{ { \d+ } }/g, (l) => {
    const c = parseInt(l.slice(4, -4));
    if (c >= 0 && c < r.length) {
      const f = t(r[c]);
      return n.push(f), l;
    }
    return l;
  }), s = await Promise.all(n);
  let o = a;
  return s.forEach((l, c) => {
    o = o.replace(`{ { ${c} } }`, l);
  }), o;
}
async function yb(e) {
  if (!e || e.trim().length === 0)
    return "";
  const t = await Rb(), r = await Nc(), i = Ux(e), n = i.map((l, c) => Ff(l) ? "\\{\\{" + c + "\\}\\}" : l).join(""), a = PDe(n, false), s = t(a.replace(/\\{\\{\d+\\}\\}/g, (l) => "\\\\{\\\\{" + l.slice(4, -4) + "\\\\}\\\\}")), o = await Promise.all(i.map(async (l) => Ff(l) ? await r(l) : l));
  return (await s).replace(/("{{\d+}}")|({{\d+}})|(\\\\{\\\\{\d+\\\\}\\\\})/g, (l) => {
    const c = parseInt(l.startsWith('"{{') ? l.slice(3, -3) : l.startsWith("{{") ? l.slice(2, -2) : l.slice(6, -6));
    return c >= 0 && c < o.length ? o[c] : l;
  });
}
async function Ib(e) {
  try {
    return await yb(e);
  } catch {
    return Qd(e);
  }
}
function Nb(e, t) {
  if (t)
    switch (t) {
      case "JSON":
      case "PureJSON":
        return Ib;
      case "Function":
        return (r) => kd().then((i) => i(r));
    }
  else
    switch (e) {
      case "css":
        return Sb;
      case "html":
        return mb;
      case "sql":
        return gb;
      case "javascript":
        return Qd;
    }
}
var Pb = /* @__PURE__ */ new Set(["uuid", "numbro", "Papa"]);
var _b = Ao.mark({
  class: "cm-success-highlight"
});
var bb = Ao.mark({
  class: "cm-error-highlight"
});
var vb = {
  ".cm-success-highlight": {
    background: "#EFF9F6"
  },
  ".cm-error-highlight": {
    background: "#FFF3F1"
  }
};
function Ih(e, t) {
  if (!t || t.length === 0)
    return Ao.none;
  const r = e.state.doc.toString();
  if (!r)
    return Ao.none;
  let i = [], n = 0;
  for (const a of t) {
    const s = r.indexOf(a.value, n);
    s >= 0 && (n = s + a.value.length, i.push((a.success ? _b : bb).range(s, n)));
  }
  return Ao.set(i);
}
function Cb(e, t) {
  const r = e === "Function", i = (0, import_react.useRef)(t);
  return i.current = t, (0, import_react.useMemo)(() => r ? [] : k0.fromClass(class {
    constructor(n) {
      Zr(this, "decoration");
      this.decoration = Ih(n, i.current);
    }
    update(n) {
      this.decoration = Ih(n.view, i.current);
    }
  }, {
    decorations: (n) => n.decoration
  }), [r]);
}
var Gd = Tn.define();
function Fo(e) {
  return e.facet(Gd);
}
function Lb(e) {
  const t = Ux(e.state.doc.toString()), r = [];
  let i = 0;
  for (const n of t)
    Ff(n) && r.push({
      from: i + 2,
      to: i + n.length - 2
    }), i += n.length;
  return r;
}
function xb(e, t, r) {
  for (const i of r)
    if (e >= i.from && t <= i.to)
      return true;
  return false;
}
var Db = class {
  constructor(t, r) {
    Zr(this, "markCache");
    Zr(this, "tree");
    Zr(this, "decorations");
    this.filterJs = r, this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ot(t.state), this.decorations = this.buildDeco(t, Fo(t.state));
  }
  update(t) {
    const r = Ot(t.state), i = Fo(t.state), n = i !== Fo(t.startState);
    r.length < t.view.viewport.to && !n && r.type === this.tree.type ? this.decorations = this.decorations.map(t.changes) : (r !== this.tree || t.viewportChanged || n) && (this.tree = r, this.decorations = this.buildDeco(t.view, i));
  }
  buildDeco(t, r) {
    if (!r || !this.tree.length)
      return Ao.none;
    const i = this.filterJs ? Lb(t) : void 0;
    if (i && i.length === 0)
      return Ao.none;
    const n = new Bw();
    for (const a of t.visibleRanges)
      vS(this.tree, r, (s, o, l) => {
        (!i || xb(s, o, i)) && n.add(s, o, this.markCache[l] || (this.markCache[l] = Ao.mark({
          class: l
        })));
      }, a.from, a.to);
    return n.finish();
  }
};
function Ub(e, t) {
  const r = [GP1.high(k0.define((i) => new Db(i, t), {
    decorations: (i) => i.decorations
  }))];
  return e.module && r.push(ua.styleModule.of(e.module)), r.push(Gd.of(e)), r;
}
function wb(e, t) {
  return Ub(am2, e === "javascript" && t === void 0);
}
var Mb = [
  //lineNumbers(),
  //highlightActiveLineGutter(),
  plr(),
  gy(),
  // Undo & Redo
  //foldGutter(),
  //drawSelection(),
  mlr(),
  //EditorState.allowMultipleSelections.of(true),
  FS(),
  // auto-indent
  hm(),
  Jm(),
  //autocompletion(),
  Clr(),
  ylr(),
  // match up rectangularSelection
  //highlightActiveLine(),
  bI(),
  ua.lineWrapping,
  qXn.of([
    ...rR,
    ...gI,
    ...jI,
    ...Ly,
    // Undo & Redo
    ...KS,
    // fold code
    //...completionKeymap,
    ...aN
  ])
];
var Nh = {
  "word-wrap": "break-word",
  "word-break": "break-all",
  "white-space": "pre-wrap",
  "font-size": "13px",
  "line-height": "13px"
};
var kb = ua.theme({
  ".cm-content, .cm-gutter": {
    height: "100%"
  },
  "&.cm-editor": {
    backgroundColor: "#ffffff",
    width: "100%",
    // height: "100%",
    "font-size": "13px",
    transition: "all .4s ease",
    outline: "none",
    "min-height": "30px"
  },
  "& .cm-line": {
    "padding-left": "8px"
  },
  ".cm-scroller": {
    "line-height": "22px",
    "font-family": "RobotoMono"
  },
  ".cm-scroller::-webkit-scrollbar": {
    width: "16px"
  },
  ".cm-scroller::-webkit-scrollbar-thumb": {
    border: "5px solid transparent",
    "background-clip": "content-box",
    "border-radius": "9999px",
    "background-color": "rgba(139, 143, 163, 0.2)",
    "min-height": "30px"
  },
  ".cm-scroller::-webkit-scrollbar-thumb:hover": {
    "background-color": "rgba(139, 143, 163, 0.5)"
  },
  "&.cm-editor:hover": {
    transition: "all .4s ease",
    outline: "none"
  },
  "&.cm-editor.cm-focused": {
    outline: "none"
  },
  // matching brackets
  "&.cm-editor .cm-scroller .cm-content[contenteditable=true] .cm-line .cm-matchingBracket": {
    color: "#40A072",
    backgroundColor: "#e9f4e6"
  },
  // line number
  "& .cm-gutters": {
    "flex-shrink": 0,
    width: "40px",
    "background-color": "#f5f5f6",
    color: "#8B8FA3",
    "border-radius": "4px 0px 0px 4px",
    "border-right": "none",
    padding: "0 2px 0 4px",
    "user-select": "none"
  },
  "& .cm-lineNumbers": {
    "flex-grow": 1
  },
  "& .cm-lineNumbers .cm-gutterElement": {
    "min-width": "unset",
    width: "100%",
    "text-align": "center",
    padding: "0",
    ...Nh,
    "line-height": "22px"
  },
  "&  .cm-activeLineGutter": {
    "background-color": "unset",
    color: "#222222"
  },
  "& .cm-lineNumbers .cm-activeLineGutter": {
    ...Nh,
    "line-height": "22px",
    "font-weight": 500
  },
  ".cm-placeholder": {
    height: 0
  },
  ...vb
});
var Qb = [
  Mlr(),
  // display line number
  zlr(),
  xu({
    placeholderDOM: () => {
      const e = document.createElement("div");
      return e.innerHTML = `
                <svg width="23px" height="13px" viewBox="0 0 23 13" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <rect fill="#D7D9E0" x="0" y="0" width="23" height="13" rx="3"></rect>
                        <g transform="translate(4.000000, 5.000000)" fill="#FFFFFF">
                            <circle cx="1.5" cy="1.5" r="1.5"></circle>
                            <circle cx="7.5" cy="1.5" r="1.5"></circle>
                            <circle cx="13.5" cy="1.5" r="1.5"></circle>
                        </g>
                    </g>
                </svg>`, e.style.display = "inline-flex", e.style.margin = "4.5px 4px 0", e.style.verticalAlign = "top", e;
    }
  }),
  im({
    markerDOM: (e) => {
      const t = document.createElement("div");
      return t.style.cursor = "pointer", t.innerHTML = "test", e ? (t.innerHTML = `
                  <svg width="12px" height="22px" viewBox="0 0 12 12" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <path d="M6.78086881,5.47608601 L8.70024396,7.87530495 C9.04525351,8.30656689 8.97533214,8.93585926 8.5440702,9.28086881 C8.36675715,9.42271925 8.14644665,9.5 7.91937515,9.5 L4.08062485,9.5 C3.5283401,9.5 3.08062485,9.05228475 3.08062485,8.5 C3.08062485,8.2729285 3.1579056,8.052618 3.29975604,7.87530495 L5.21913119,5.47608601 C5.56414074,5.04482408 6.19343311,4.9749027 6.62469505,5.31991225 C6.68235975,5.36604401 6.73473705,5.41842131 6.78086881,5.47608601 Z" fill="#B8B9BF" transform="translate(6.000000, 7.000000) scale(1, -1) translate(-6.000000, -7.000000) "></path>
                      </g>
                  </svg>`, t) : (t.innerHTML = `
                  <svg width="12px" height="22px" viewBox="0 0 12 12" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <path d="M7.28086881,4.97608601 L9.20024396,7.37530495 C9.54525351,7.80656689 9.47533214,8.43585926 9.0440702,8.78086881 C8.86675715,8.92271925 8.64644665,9 8.41937515,9 L4.58062485,9 C4.0283401,9 3.58062485,8.55228475 3.58062485,8 C3.58062485,7.7729285 3.6579056,7.552618 3.79975604,7.37530495 L5.71913119,4.97608601 C6.06414074,4.54482408 6.69343311,4.4749027 7.12469505,4.81991225 C7.18235975,4.86604401 7.23473705,4.91842131 7.28086881,4.97608601 Z" fill="#B8B9BF" transform="translate(6.500000, 6.500000) scale(1, -1) rotate(90.000000) translate(-6.500000, -6.500000) "></path>
                      </g>
                  </svg>`, t);
    }
  })
  // highlightActiveLine(),
];
var Gb = {
  javascript: zp(),
  sql: jA(),
  css: sO(),
  html: fy(),
  json: sA()
};
var Vb = GP1.highest(qXn.of([
  // {key: "Ctrl-Space", run: startCompletion},
  {
    key: "Escape",
    run: ku
  },
  {
    key: "ArrowDown",
    run: kr(true)
  },
  {
    key: "Ctrl-n",
    run: kr(true)
  },
  {
    key: "ArrowUp",
    run: kr(false)
  },
  {
    key: "Ctrl-p",
    run: kr(false)
  },
  {
    key: "PageDown",
    run: kr(true, "page")
  },
  {
    key: "PageUp",
    run: kr(false, "page")
  },
  {
    key: "Tab",
    run: ol
  },
  {
    key: "Enter",
    run: ol
  }
]));
function Bb(e) {
  const [t, r] = (0, import_react.useState)(false), i = (0, import_react.useRef)();
  return i.current = e, [(0, import_react.useMemo)(() => ua.updateListener.of((a) => {
    var s;
    if (a.focusChanged) {
      const o = a.view.hasFocus;
      r(o), (s = i.current) == null || s.call(i, o), o || ku(a.view);
    }
  }), []), t];
}
function $b(e) {
  return e ?? true ? qXn.of([yI]) : [];
}
function Yb(e) {
  return e ? Qb : [];
}
function Fb(e) {
  return e ? glr(e) : [];
}
function Wb(e, t) {
  const r = (0, import_react.useRef)();
  return r.current = t ? (i) => {
    e == null || e(i), t(i);
  } : e, (0, import_react.useMemo)(() => {
    const i = (n) => {
      var a;
      n.docChanged && ((a = r.current) == null || a.call(r, n.state));
    };
    return ua.updateListener.of(i);
  }, []);
}
function Xb(e) {
  const {
    language: t,
    codeType: r,
    exposingData: i,
    boostExposingData: n,
    enableMetaCompletion: a
  } = e, s = (0, import_react.useContext)(kM), o = (0, import_react.useMemo)(() => new wP(), []), l = (0, import_react.useMemo)(() => s != null && s.disableJSCompletion ? void 0 : new DP(), []), c = (0, import_react.useMemo)(() => new YP(), []);
  (0, import_react.useEffect)(() => {
    o.data = i, o.boostExposingData = n;
  }, [o, i, n]);
  const f = (0, import_react.useContext)(lir);
  return (0, import_react.useEffect)(() => {
    c.metaData = f;
  }, [c, f]), (0, import_react.useMemo)(() => {
    const O = [];
    return t === "css" || (O.push(o), l && O.push(l)), a && O.push(c), O.map((d2) => (d2.setIsFunction(r === "Function"), d2.completionSource));
  }, [a, t, r, o, l, c]);
}
function jb(e) {
  const t = Xb(e);
  return (0, import_react.useMemo)(() => [uR({
    override: t,
    defaultKeymap: false
  }), Vb], [t]);
}
function Zb(e, t) {
  const r = e ?? "javascript", i = qXn.of([{
    key: "Mod-l",
    run: (n) => {
      const a = Nb(r, t);
      if (a) {
        const s = n.state.doc.toString();
        a(s).then((o) => {
          o !== s && n.dispatch({
            changes: {
              from: 0,
              to: s.length,
              insert: o
            }
          });
        }).catch((o) => {
          Ct.error(o instanceof Error ? o.message : o);
        });
      } else
        Ct.warning(_("codeEditor.notSupportAutoFormat"));
      return true;
    }
  }]);
  return [Gb[r], wb(r, t), i];
}
function Hb(e) {
  return blr({
    position: "absolute",
    parent: e || document.querySelector(`${Dc}`) || document.body
  });
}
var zb = async (e) => {
  const r = (await import("./a9ee5852-YRVZZJXA.js")).default, i = new r(), n = {
    parserOptions: {
      ecmaVersion: "latest",
      sourceType: "script"
    },
    env: {
      browser: true,
      node: true,
      es2021: true
    },
    rules: {
      // https://github.com/mysticatea/eslint4b/issues/17
      "no-useless-escape": "off"
    }
  };
  return i.getRules().forEach((a, s) => {
    a.meta.docs.recommended && !(s in n.rules) && (n.rules[s] = "error");
  }), KR(i, n)(e);
};
function qb(e, t) {
  return e === "PureJSON" ? [uh(iA())] : e !== "Function" ? [] : [uh(zb, {
    markerFilter: (i) => i.filter((n) => {
      if (n.message.endsWith("' is not defined.") && n.message.startsWith("'")) {
        const a = n.message.slice(1, -17);
        if (t.current.hasOwnProperty(a) || Pb.has(a))
          return false;
      }
      return true;
    }).map((n) => ({
      ...n,
      source: void 0,
      actions: void 0
    }))
  })];
}
var Qn = [];
function Jb(e) {
  const {
    showLineNum: t,
    placeholder: r,
    language: i,
    codeType: n,
    indentWithTab: a,
    tooltipContainer: s
  } = e, o = (0, import_react.useRef)({});
  o.current = e.exposingData ?? {};
  const l = Cb(n, e.segments), c = jb(e), [f, p] = Bb(e.onFocus), O = (0, import_react.useMemo)(() => Yb(t), [t]), d2 = (0, import_react.useMemo)(() => Zb(i, n), [i, n]), g = Wb(e.onChange, e.extraOnChange), L = (0, import_react.useMemo)(() => Fb(r), [r]), D = (0, import_react.useMemo)(() => $b(a), [a]), W = (0, import_react.useMemo)(() => Hb(s), [s]), x = (0, import_react.useMemo)(() => qb(n, o), [n]), V = (0, import_react.useMemo)(() => klr(e.enableIcon), [e.enableIcon]), _2 = (0, import_react.useMemo)(() => [Mb, kb, l, c, f, O, d2, g, L, D, W, x, V], [l, c, f, O, d2, g, L, D, W, x, V]), $ = (0, import_react.useMemo)(() => {
    for (let F = Qn.length; F < _2.length; ++F)
      Qn.push(new LA());
    return _2.map((F, ae) => Qn[ae].of(F));
  }, [_2]), z = (0, import_react.useCallback)((F) => {
    if (F) {
      const ae = [];
      _2.forEach((U, G) => {
        Qn[G].get(F.state) !== U && (St.log("reconfigure", G), ae.push(Qn[G].reconfigure(U)));
      }), ae.length > 0 && F.dispatch({
        effects: ae
      });
    }
  }, [_2]);
  return {
    extensions: $,
    reconfigure: z,
    isFocus: p
  };
}
var Vd = function(t) {
  return +setTimeout(t, 16);
};
var Bd = function(t) {
  return clearTimeout(t);
};
typeof window < "u" && "requestAnimationFrame" in window && (Vd = function(t) {
  return window.requestAnimationFrame(t);
}, Bd = function(t) {
  return window.cancelAnimationFrame(t);
});
var Ph = 0;
var co = /* @__PURE__ */ new Map();
function $d(e) {
  co.delete(e);
}
var Wr = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  Ph += 1;
  var i = Ph;
  function n(a) {
    if (a === 0)
      $d(i), t();
    else {
      var s = Vd(function() {
        n(a - 1);
      });
      co.set(i, s);
    }
  }
  return n(r), i;
};
Wr.cancel = function(e) {
  var t = co.get(e);
  return $d(e), Bd(t);
};
Wr.ids = function() {
  return co;
};
function Wo(e, t) {
  if (!e)
    return false;
  if (e.contains)
    return e.contains(t);
  for (var r = t; r; ) {
    if (r === e)
      return true;
    r = r.parentNode;
  }
  return false;
}
function Kb(e) {
  return e instanceof HTMLElement || e instanceof SVGElement;
}
function Yd(e) {
  return Kb(e) ? e : e instanceof import_react.default.Component ? import_react_dom.default.findDOMNode(e) : null;
}
function Fd(e, t) {
  typeof e == "function" ? e(t) : It(e) === "object" && e && "current" in e && (e.current = t);
}
function ev() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i = t.filter(function(n) {
    return n;
  });
  return i.length <= 1 ? i[0] : function(n) {
    t.forEach(function(a) {
      Fd(a, n);
    });
  };
}
function Wd(e) {
  var t, r, i = us.isMemo(e) ? e.type.type : e.type;
  return !(typeof i == "function" && !((t = i.prototype) !== null && t !== void 0 && t.render) && i.$$typeof !== us.ForwardRef || typeof e == "function" && !((r = e.prototype) !== null && r !== void 0 && r.render) && e.$$typeof !== us.ForwardRef);
}
function Fa(e, t, r, i) {
  var n = import_react_dom.default.unstable_batchedUpdates ? function(s) {
    import_react_dom.default.unstable_batchedUpdates(r, s);
  } : r;
  return e != null && e.addEventListener && e.addEventListener(t, n, i), {
    remove: function() {
      e != null && e.removeEventListener && e.removeEventListener(t, n, i);
    }
  };
}
function Pa2() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var tv = (0, import_react.forwardRef)(function(e, t) {
  var r = e.didUpdate, i = e.getContainer, n = e.children, a = (0, import_react.useRef)(), s = (0, import_react.useRef)();
  (0, import_react.useImperativeHandle)(t, function() {
    return {};
  });
  var o = (0, import_react.useRef)(false);
  return !o.current && Pa2() && (s.current = i(), a.current = s.current.parentNode, o.current = true), (0, import_react.useEffect)(function() {
    r == null || r(e);
  }), (0, import_react.useEffect)(function() {
    return s.current.parentNode === null && a.current !== null && a.current.appendChild(s.current), function() {
      var l;
      (l = s.current) === null || l === void 0 || (l = l.parentNode) === null || l === void 0 || l.removeChild(s.current);
    };
  }, []), s.current ? import_react_dom.default.createPortal(n, s.current) : null;
});
function rv(e, t, r) {
  return r ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function iv(e, t, r) {
  var i = e[t] || {};
  return Ye(Ye({}, i), r);
}
function nv(e, t, r, i) {
  for (var n = r.points, a = Object.keys(e), s = 0; s < a.length; s += 1) {
    var o = a[s];
    if (rv(e[o].points, n, i))
      return "".concat(t, "-placement-").concat(o);
  }
  return "";
}
var av = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return false;
  var e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substr(0, 4));
};
var sv = _e2.createContext({});
var ov = function(e) {
  g4(r, e);
  var t = T0(r);
  function r() {
    return Da(this, r), t.apply(this, arguments);
  }
  return Pa(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(_e2.Component);
function jn(e) {
  var t = _e2.useRef(false), r = _e2.useState(e), i = c1(r, 2), n = i[0], a = i[1];
  _e2.useEffect(function() {
    return t.current = false, function() {
      t.current = true;
    };
  }, []);
  function s(o, l) {
    l && t.current || a(o);
  }
  return [n, s];
}
var xi = "none";
var Wa = "appear";
var Xa = "enter";
var ja = "leave";
var _h = "none";
var _r = "prepare";
var nn = "start";
var an = "active";
var Pc = "end";
var Xd = "prepared";
function bh(e, t) {
  var r = {};
  return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit".concat(e)] = "webkit".concat(t), r["Moz".concat(e)] = "moz".concat(t), r["ms".concat(e)] = "MS".concat(t), r["O".concat(e)] = "o".concat(t.toLowerCase()), r;
}
function lv(e, t) {
  var r = {
    animationend: bh("Animation", "AnimationEnd"),
    transitionend: bh("Transition", "TransitionEnd")
  };
  return e && ("AnimationEvent" in t || delete r.animationend.animation, "TransitionEvent" in t || delete r.transitionend.transition), r;
}
var uv = lv(Pa2(), typeof window < "u" ? window : {});
var jd = {};
if (Pa2()) {
  cv = document.createElement("div");
  jd = cv.style;
}
var cv;
var Za = {};
function Zd(e) {
  if (Za[e])
    return Za[e];
  var t = uv[e];
  if (t)
    for (var r = Object.keys(t), i = r.length, n = 0; n < i; n += 1) {
      var a = r[n];
      if (Object.prototype.hasOwnProperty.call(t, a) && a in jd)
        return Za[e] = t[a], Za[e];
    }
  return "";
}
var Hd = Zd("animationend");
var zd = Zd("transitionend");
var qd = !!(Hd && zd);
var vh = Hd || "animationend";
var Ch = zd || "transitionend";
function Lh(e, t) {
  if (!e)
    return null;
  if (It(e) === "object") {
    var r = t.replace(/-\w/g, function(i) {
      return i[1].toUpperCase();
    });
    return e[r];
  }
  return "".concat(e, "-").concat(t);
}
var fv = function(e) {
  var t = (0, import_react.useRef)(), r = (0, import_react.useRef)(e);
  r.current = e;
  var i = _e2.useCallback(function(s) {
    r.current(s);
  }, []);
  function n(s) {
    s && (s.removeEventListener(Ch, i), s.removeEventListener(vh, i));
  }
  function a(s) {
    t.current && t.current !== s && n(t.current), s && s !== t.current && (s.addEventListener(Ch, i), s.addEventListener(vh, i), t.current = s);
  }
  return _e2.useEffect(function() {
    return function() {
      n(t.current);
    };
  }, []), [a, n];
};
var Jd = Pa2() ? import_react.useLayoutEffect : import_react.useEffect;
var hv = function() {
  var e = _e2.useRef(null);
  function t() {
    Wr.cancel(e.current);
  }
  function r(i) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    t();
    var a = Wr(function() {
      n <= 1 ? i({
        isCanceled: function() {
          return a !== e.current;
        }
      }) : r(i, n - 1);
    });
    e.current = a;
  }
  return _e2.useEffect(function() {
    return function() {
      t();
    };
  }, []), [r, t];
};
var pv = [_r, nn, an, Pc];
var Ov = [_r, Xd];
var Kd = false;
var Ev = true;
function eT(e) {
  return e === an || e === Pc;
}
var dv = function(e, t, r) {
  var i = jn(_h), n = c1(i, 2), a = n[0], s = n[1], o = hv(), l = c1(o, 2), c = l[0], f = l[1];
  function p() {
    s(_r, true);
  }
  var O = t ? Ov : pv;
  return Jd(function() {
    if (a !== _h && a !== Pc) {
      var d2 = O.indexOf(a), g = O[d2 + 1], L = r(a);
      L === Kd ? s(g, true) : g && c(function(D) {
        function W() {
          D.isCanceled() || s(g, true);
        }
        L === true ? W() : Promise.resolve(L).then(W);
      });
    }
  }, [e, a]), _e2.useEffect(function() {
    return function() {
      f();
    };
  }, []), [p, a];
};
function Tv(e, t, r, i) {
  var n = i.motionEnter, a = n === void 0 ? true : n, s = i.motionAppear, o = s === void 0 ? true : s, l = i.motionLeave, c = l === void 0 ? true : l, f = i.motionDeadline, p = i.motionLeaveImmediately, O = i.onAppearPrepare, d2 = i.onEnterPrepare, g = i.onLeavePrepare, L = i.onAppearStart, D = i.onEnterStart, W = i.onLeaveStart, x = i.onAppearActive, V = i.onEnterActive, _2 = i.onLeaveActive, $ = i.onAppearEnd, z = i.onEnterEnd, F = i.onLeaveEnd, ae = i.onVisibleChanged, U = jn(), G = c1(U, 2), H = G[0], re = G[1], B = jn(xi), Y = c1(B, 2), E = Y[0], m = Y[1], P = jn(null), R = c1(P, 2), A = R[0], y2 = R[1], C = (0, import_react.useRef)(false), j = (0, import_react.useRef)(null);
  function w() {
    return r();
  }
  var J = (0, import_react.useRef)(false);
  function te() {
    m(xi, true), y2(null, true);
  }
  function se(It2) {
    var tt = w();
    if (!(It2 && !It2.deadline && It2.target !== tt)) {
      var St2 = J.current, lt;
      E === Wa && St2 ? lt = $ == null ? void 0 : $(tt, It2) : E === Xa && St2 ? lt = z == null ? void 0 : z(tt, It2) : E === ja && St2 && (lt = F == null ? void 0 : F(tt, It2)), E !== xi && St2 && lt !== false && te();
    }
  }
  var ge = fv(se), fe = c1(ge, 1), et = fe[0], yt = function(tt) {
    var St2, lt, vt;
    switch (tt) {
      case Wa:
        return St2 = {}, Be(St2, _r, O), Be(St2, nn, L), Be(St2, an, x), St2;
      case Xa:
        return lt = {}, Be(lt, _r, d2), Be(lt, nn, D), Be(lt, an, V), lt;
      case ja:
        return vt = {}, Be(vt, _r, g), Be(vt, nn, W), Be(vt, an, _2), vt;
      default:
        return {};
    }
  }, De = _e2.useMemo(function() {
    return yt(E);
  }, [E]), Ce = dv(E, !e, function(It2) {
    if (It2 === _r) {
      var tt = De[_r];
      return tt ? tt(w()) : Kd;
    }
    if (Je in De) {
      var St2;
      y2(((St2 = De[Je]) === null || St2 === void 0 ? void 0 : St2.call(De, w(), null)) || null);
    }
    return Je === an && (et(w()), f > 0 && (clearTimeout(j.current), j.current = setTimeout(function() {
      se({
        deadline: true
      });
    }, f))), Je === Xd && te(), Ev;
  }), Ee = c1(Ce, 2), ut = Ee[0], Je = Ee[1], q = eT(Je);
  J.current = q, Jd(function() {
    re(t);
    var It2 = C.current;
    C.current = true;
    var tt;
    !It2 && t && o && (tt = Wa), It2 && t && a && (tt = Xa), (It2 && !t && c || !It2 && p && !t && c) && (tt = ja);
    var St2 = yt(tt);
    tt && (e || St2[_r]) ? (m(tt), ut()) : m(xi);
  }, [t]), (0, import_react.useEffect)(function() {
    (E === Wa && !o || // Cancel enter
    E === Xa && !a || // Cancel leave
    E === ja && !c) && m(xi);
  }, [o, a, c]), (0, import_react.useEffect)(function() {
    return function() {
      C.current = false, clearTimeout(j.current);
    };
  }, []);
  var ot = _e2.useRef(false);
  (0, import_react.useEffect)(function() {
    H && (ot.current = true), H !== void 0 && E === xi && ((ot.current || H) && (ae == null || ae(H)), ot.current = true);
  }, [H, E]);
  var $t = A;
  return De[_r] && Je === nn && ($t = Ye({
    transition: "none"
  }, $t)), [E, Je, $t, H ?? t];
}
function Sv(e) {
  var t = e;
  It(e) === "object" && (t = e.transitionSupport);
  function r(n, a) {
    return !!(n.motionName && t && a !== false);
  }
  var i = _e2.forwardRef(function(n, a) {
    var s = n.visible, o = s === void 0 ? true : s, l = n.removeOnLeave, c = l === void 0 ? true : l, f = n.forceRender, p = n.children, O = n.motionName, d2 = n.leavedClassName, g = n.eventProps, L = _e2.useContext(sv), D = L.motion, W = r(n, D), x = (0, import_react.useRef)(), V = (0, import_react.useRef)();
    function _2() {
      try {
        return x.current instanceof HTMLElement ? x.current : Yd(V.current);
      } catch {
        return null;
      }
    }
    var $ = Tv(W, o, _2, n), z = c1($, 4), F = z[0], ae = z[1], U = z[2], G = z[3], H = _e2.useRef(G);
    G && (H.current = true);
    var re = _e2.useCallback(function(y2) {
      x.current = y2, Fd(a, y2);
    }, [a]), B, Y = Ye(Ye({}, g), {}, {
      visible: o
    });
    if (!p)
      B = null;
    else if (F === xi)
      G ? B = p(Ye({}, Y), re) : !c && H.current && d2 ? B = p(Ye(Ye({}, Y), {}, {
        className: d2
      }), re) : f || !c && !d2 ? B = p(Ye(Ye({}, Y), {}, {
        style: {
          display: "none"
        }
      }), re) : B = null;
    else {
      var E, m;
      ae === _r ? m = "prepare" : eT(ae) ? m = "active" : ae === nn && (m = "start");
      var P = Lh(O, "".concat(F, "-").concat(m));
      B = p(Ye(Ye({}, Y), {}, {
        className: _e(Lh(O, F), (E = {}, Be(E, P, P && m), Be(E, O, typeof O == "string"), E)),
        style: U
      }), re);
    }
    if (_e2.isValidElement(B) && Wd(B)) {
      var R = B, A = R.ref;
      A || (B = _e2.cloneElement(B, {
        ref: re
      }));
    }
    return d(ov, {
      ref: V,
      children: B
    });
  });
  return i.displayName = "CSSMotion", i;
}
var fo = Sv(qd);
var ru = "add";
var iu = "keep";
var nu = "remove";
var Xo = "removed";
function mv(e) {
  var t;
  return e && It(e) === "object" && "key" in e ? t = e : t = {
    key: e
  }, Ye(Ye({}, t), {}, {
    key: String(t.key)
  });
}
function au() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return e.map(mv);
}
function Rv() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = [], i = 0, n = t.length, a = au(e), s = au(t);
  a.forEach(function(c) {
    for (var f = false, p = i; p < n; p += 1) {
      var O = s[p];
      if (O.key === c.key) {
        i < p && (r = r.concat(s.slice(i, p).map(function(d2) {
          return Ye(Ye({}, d2), {}, {
            status: ru
          });
        })), i = p), r.push(Ye(Ye({}, O), {}, {
          status: iu
        })), i += 1, f = true;
        break;
      }
    }
    f || r.push(Ye(Ye({}, c), {}, {
      status: nu
    }));
  }), i < n && (r = r.concat(s.slice(i).map(function(c) {
    return Ye(Ye({}, c), {}, {
      status: ru
    });
  })));
  var o = {};
  r.forEach(function(c) {
    var f = c.key;
    o[f] = (o[f] || 0) + 1;
  });
  var l = Object.keys(o).filter(function(c) {
    return o[c] > 1;
  });
  return l.forEach(function(c) {
    r = r.filter(function(f) {
      var p = f.key, O = f.status;
      return p !== c || O !== nu;
    }), r.forEach(function(f) {
      f.key === c && (f.status = iu);
    });
  }), r;
}
var Av = ["component", "children", "onVisibleChanged", "onAllRemoved"];
var gv = ["status"];
var yv = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function Iv(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fo, r = function(i) {
    g4(a, i);
    var n = T0(a);
    function a() {
      var s;
      Da(this, a);
      for (var o = arguments.length, l = new Array(o), c = 0; c < o; c++)
        l[c] = arguments[c];
      return s = n.call.apply(n, [this].concat(l)), Be(J1(s), "state", {
        keyEntities: []
      }), Be(J1(s), "removeKey", function(f) {
        var p = s.state.keyEntities, O = p.map(function(d2) {
          return d2.key !== f ? d2 : Ye(Ye({}, d2), {}, {
            status: Xo
          });
        });
        return s.setState({
          keyEntities: O
        }), O.filter(function(d2) {
          var g = d2.status;
          return g !== Xo;
        }).length;
      }), s;
    }
    return Pa(a, [{
      key: "render",
      value: function() {
        var o = this, l = this.state.keyEntities, c = this.props, f = c.component, p = c.children, O = c.onVisibleChanged, d2 = c.onAllRemoved, g = Gt(c, Av), L = f || _e2.Fragment, D = {};
        return yv.forEach(function(W) {
          D[W] = g[W], delete g[W];
        }), delete g.keys, d(L, {
          ...g,
          children: l.map(function(W, x) {
            var V = W.status, _2 = Gt(W, gv), $ = V === ru || V === iu;
            return (0, import_react.createElement)(t, {
              ...D,
              key: _2.key,
              visible: $,
              eventProps: _2,
              onVisibleChanged: function(F) {
                if (O == null || O(F, {
                  key: _2.key
                }), !F) {
                  var ae = o.removeKey(_2.key);
                  ae === 0 && d2 && d2();
                }
              }
            }, function(z, F) {
              return p(Ye(Ye({}, z), {}, {
                index: x
              }), F);
            });
          })
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(o, l) {
        var c = o.keys, f = l.keyEntities, p = au(c), O = Rv(f, p);
        return {
          keyEntities: O.filter(function(d2) {
            var g = f.find(function(L) {
              var D = L.key;
              return d2.key === D;
            });
            return !(g && g.status === Xo && d2.status === nu);
          })
        };
      }
    }]), a;
  }(_e2.Component);
  return Be(r, "defaultProps", {
    component: "div"
  }), r;
}
Iv(qd);
function tT(e) {
  var t = e.prefixCls, r = e.motion, i = e.animation, n = e.transitionName;
  return r || (i ? {
    motionName: "".concat(t, "-").concat(i)
  } : n ? {
    motionName: n
  } : null);
}
function Nv(e) {
  var t = e.prefixCls, r = e.visible, i = e.zIndex, n = e.mask, a = e.maskMotion, s = e.maskAnimation, o = e.maskTransitionName;
  if (!n)
    return null;
  var l = {};
  return (a || o || s) && (l = Ye({
    motionAppear: true
  }, tT({
    motion: a,
    prefixCls: t,
    transitionName: o,
    animation: s
  }))), d(fo, {
    ...l,
    visible: r,
    removeOnLeave: true,
    children: function(c) {
      var f = c.className;
      return d("div", {
        style: {
          zIndex: i
        },
        className: _e("".concat(t, "-mask"), f)
      });
    }
  });
}
function xh(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(e, n).enumerable;
    })), r.push.apply(r, i);
  }
  return r;
}
function Dh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xh(Object(r), true).forEach(function(i) {
      Pv(e, i, r[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : xh(Object(r)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
    });
  }
  return e;
}
function su(e) {
  "@babel/helpers - typeof";
  return su = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, su(e);
}
function Pv(e, t, r) {
  return t in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = r, e;
}
var Gn;
var _v = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function ks() {
  if (Gn !== void 0)
    return Gn;
  Gn = "";
  var e = document.createElement("p").style, t = "Transform";
  for (var r in _v)
    r + t in e && (Gn = r);
  return Gn;
}
function rT() {
  return ks() ? "".concat(ks(), "TransitionProperty") : "transitionProperty";
}
function ho() {
  return ks() ? "".concat(ks(), "Transform") : "transform";
}
function Uh(e, t) {
  var r = rT();
  r && (e.style[r] = t, r !== "transitionProperty" && (e.style.transitionProperty = t));
}
function jo(e, t) {
  var r = ho();
  r && (e.style[r] = t, r !== "transform" && (e.style.transform = t));
}
function bv(e) {
  return e.style.transitionProperty || e.style[rT()];
}
function vv(e) {
  var t = window.getComputedStyle(e, null), r = t.getPropertyValue("transform") || t.getPropertyValue(ho());
  if (r && r !== "none") {
    var i = r.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(i[12] || i[4], 0),
      y: parseFloat(i[13] || i[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var Cv = /matrix\((.*)\)/;
var Lv = /matrix3d\((.*)\)/;
function xv(e, t) {
  var r = window.getComputedStyle(e, null), i = r.getPropertyValue("transform") || r.getPropertyValue(ho());
  if (i && i !== "none") {
    var n, a = i.match(Cv);
    if (a)
      a = a[1], n = a.split(",").map(function(o) {
        return parseFloat(o, 10);
      }), n[4] = t.x, n[5] = t.y, jo(e, "matrix(".concat(n.join(","), ")"));
    else {
      var s = i.match(Lv)[1];
      n = s.split(",").map(function(o) {
        return parseFloat(o, 10);
      }), n[12] = t.x, n[13] = t.y, jo(e, "matrix3d(".concat(n.join(","), ")"));
    }
  } else
    jo(e, "translateX(".concat(t.x, "px) translateY(").concat(t.y, "px) translateZ(0)"));
}
var Dv = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var _a;
function wh(e) {
  var t = e.style.display;
  e.style.display = "none", e.offsetHeight, e.style.display = t;
}
function un(e, t, r) {
  var i = r;
  if (su(t) === "object") {
    for (var n in t)
      t.hasOwnProperty(n) && un(e, n, t[n]);
    return;
  }
  if (typeof i < "u") {
    typeof i == "number" && (i = "".concat(i, "px")), e.style[t] = i;
    return;
  }
  return _a(e, t);
}
function Uv(e) {
  var t, r, i, n = e.ownerDocument, a = n.body, s = n && n.documentElement;
  return t = e.getBoundingClientRect(), r = Math.floor(t.left), i = Math.floor(t.top), r -= s.clientLeft || a.clientLeft || 0, i -= s.clientTop || a.clientTop || 0, {
    left: r,
    top: i
  };
}
function iT(e, t) {
  var r = e["page".concat(t ? "Y" : "X", "Offset")], i = "scroll".concat(t ? "Top" : "Left");
  if (typeof r != "number") {
    var n = e.document;
    r = n.documentElement[i], typeof r != "number" && (r = n.body[i]);
  }
  return r;
}
function nT(e) {
  return iT(e);
}
function aT(e) {
  return iT(e, true);
}
function Oa(e) {
  var t = Uv(e), r = e.ownerDocument, i = r.defaultView || r.parentWindow;
  return t.left += nT(i), t.top += aT(i), t;
}
function _c(e) {
  return e != null && e == e.window;
}
function sT(e) {
  return _c(e) ? e.document : e.nodeType === 9 ? e : e.ownerDocument;
}
function wv(e, t, r) {
  var i = r, n = "", a = sT(e);
  return i = i || a.defaultView.getComputedStyle(e, null), i && (n = i.getPropertyValue(t) || i[t]), n;
}
var Mv = new RegExp("^(".concat(Dv, ")(?!px)[a-z%]+$"), "i");
var kv = /^(top|right|bottom|left)$/;
var Zo = "currentStyle";
var Ho = "runtimeStyle";
var vi = "left";
var Qv = "px";
function Gv(e, t) {
  var r = e[Zo] && e[Zo][t];
  if (Mv.test(r) && !kv.test(t)) {
    var i = e.style, n = i[vi], a = e[Ho][vi];
    e[Ho][vi] = e[Zo][vi], i[vi] = t === "fontSize" ? "1em" : r || 0, r = i.pixelLeft + Qv, i[vi] = n, e[Ho][vi] = a;
  }
  return r === "" ? "auto" : r;
}
typeof window < "u" && (_a = window.getComputedStyle ? wv : Gv);
function Ha(e, t) {
  return e === "left" ? t.useCssRight ? "right" : e : t.useCssBottom ? "bottom" : e;
}
function Mh(e) {
  if (e === "left")
    return "right";
  if (e === "right")
    return "left";
  if (e === "top")
    return "bottom";
  if (e === "bottom")
    return "top";
}
function kh(e, t, r) {
  un(e, "position") === "static" && (e.style.position = "relative");
  var i = -999, n = -999, a = Ha("left", r), s = Ha("top", r), o = Mh(a), l = Mh(s);
  a !== "left" && (i = 999), s !== "top" && (n = 999);
  var c = "", f = Oa(e);
  ("left" in t || "top" in t) && (c = bv(e) || "", Uh(e, "none")), "left" in t && (e.style[o] = "", e.style[a] = "".concat(i, "px")), "top" in t && (e.style[l] = "", e.style[s] = "".concat(n, "px")), wh(e);
  var p = Oa(e), O = {};
  for (var d2 in t)
    if (t.hasOwnProperty(d2)) {
      var g = Ha(d2, r), L = d2 === "left" ? i : n, D = f[d2] - p[d2];
      g === d2 ? O[g] = L + D : O[g] = L - D;
    }
  un(e, O), wh(e), ("left" in t || "top" in t) && Uh(e, c);
  var W = {};
  for (var x in t)
    if (t.hasOwnProperty(x)) {
      var V = Ha(x, r), _2 = t[x] - f[x];
      x === V ? W[V] = O[V] + _2 : W[V] = O[V] - _2;
    }
  un(e, W);
}
function Vv(e, t) {
  var r = Oa(e), i = vv(e), n = {
    x: i.x,
    y: i.y
  };
  "left" in t && (n.x = i.x + t.left - r.left), "top" in t && (n.y = i.y + t.top - r.top), xv(e, n);
}
function Bv(e, t, r) {
  if (r.ignoreShake) {
    var i = Oa(e), n = i.left.toFixed(0), a = i.top.toFixed(0), s = t.left.toFixed(0), o = t.top.toFixed(0);
    if (n === s && a === o)
      return;
  }
  r.useCssRight || r.useCssBottom ? kh(e, t, r) : r.useCssTransform && ho() in document.body.style ? Vv(e, t) : kh(e, t, r);
}
function bc(e, t) {
  for (var r = 0; r < e.length; r++)
    t(e[r]);
}
function oT(e) {
  return _a(e, "boxSizing") === "border-box";
}
var $v = ["margin", "border", "padding"];
var ou = -1;
var Yv = 2;
var lu = 1;
var Fv = 0;
function Wv(e, t, r) {
  var i = {}, n = e.style, a;
  for (a in t)
    t.hasOwnProperty(a) && (i[a] = n[a], n[a] = t[a]);
  r.call(e);
  for (a in t)
    t.hasOwnProperty(a) && (n[a] = i[a]);
}
function $n(e, t, r) {
  var i = 0, n, a, s;
  for (a = 0; a < t.length; a++)
    if (n = t[a], n)
      for (s = 0; s < r.length; s++) {
        var o = void 0;
        n === "border" ? o = "".concat(n).concat(r[s], "Width") : o = n + r[s], i += parseFloat(_a(e, o)) || 0;
      }
  return i;
}
var Fr = {
  getParent: function(t) {
    var r = t;
    do
      r.nodeType === 11 && r.host ? r = r.host : r = r.parentNode;
    while (r && r.nodeType !== 1 && r.nodeType !== 9);
    return r;
  }
};
bc(["Width", "Height"], function(e) {
  Fr["doc".concat(e)] = function(t) {
    var r = t.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      r.documentElement["scroll".concat(e)],
      // quirks : documentElement.scrollHeight 
      r.body["scroll".concat(e)],
      Fr["viewport".concat(e)](r)
    );
  }, Fr["viewport".concat(e)] = function(t) {
    var r = "client".concat(e), i = t.document, n = i.body, a = i.documentElement, s = a[r];
    return i.compatMode === "CSS1Compat" && s || n && n[r] || s;
  };
});
function Qh(e, t, r) {
  var i = r;
  if (_c(e))
    return t === "width" ? Fr.viewportWidth(e) : Fr.viewportHeight(e);
  if (e.nodeType === 9)
    return t === "width" ? Fr.docWidth(e) : Fr.docHeight(e);
  var n = t === "width" ? ["Left", "Right"] : ["Top", "Bottom"], a = Math.floor(t === "width" ? e.getBoundingClientRect().width : e.getBoundingClientRect().height), s = oT(e), o = 0;
  (a == null || a <= 0) && (a = void 0, o = _a(e, t), (o == null || Number(o) < 0) && (o = e.style[t] || 0), o = Math.floor(parseFloat(o)) || 0), i === void 0 && (i = s ? lu : ou);
  var l = a !== void 0 || s, c = a || o;
  return i === ou ? l ? c - $n(e, ["border", "padding"], n) : o : l ? i === lu ? c : c + (i === Yv ? -$n(e, ["border"], n) : $n(e, ["margin"], n)) : o + $n(e, $v.slice(i), n);
}
var Xv = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function Gh() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i, n = t[0];
  return n.offsetWidth !== 0 ? i = Qh.apply(void 0, t) : Wv(n, Xv, function() {
    i = Qh.apply(void 0, t);
  }), i;
}
bc(["width", "height"], function(e) {
  var t = e.charAt(0).toUpperCase() + e.slice(1);
  Fr["outer".concat(t)] = function(i, n) {
    return i && Gh(i, e, n ? Fv : lu);
  };
  var r = e === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  Fr[e] = function(i, n) {
    var a = n;
    if (a !== void 0) {
      if (i) {
        var s = oT(i);
        return s && (a += $n(i, ["padding", "border"], r)), un(i, e, a);
      }
      return;
    }
    return i && Gh(i, e, ou);
  };
});
function lT(e, t) {
  for (var r in t)
    t.hasOwnProperty(r) && (e[r] = t[r]);
  return e;
}
var Ne = {
  getWindow: function(t) {
    if (t && t.document && t.setTimeout)
      return t;
    var r = t.ownerDocument || t;
    return r.defaultView || r.parentWindow;
  },
  getDocument: sT,
  offset: function(t, r, i) {
    if (typeof r < "u")
      Bv(t, r, i || {});
    else
      return Oa(t);
  },
  isWindow: _c,
  each: bc,
  css: un,
  clone: function(t) {
    var r, i = {};
    for (r in t)
      t.hasOwnProperty(r) && (i[r] = t[r]);
    var n = t.overflow;
    if (n)
      for (r in t)
        t.hasOwnProperty(r) && (i.overflow[r] = t.overflow[r]);
    return i;
  },
  mix: lT,
  getWindowScrollLeft: function(t) {
    return nT(t);
  },
  getWindowScrollTop: function(t) {
    return aT(t);
  },
  merge: function() {
    for (var t = {}, r = 0; r < arguments.length; r++)
      Ne.mix(t, r < 0 || arguments.length <= r ? void 0 : arguments[r]);
    return t;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
lT(Ne, Fr);
var zo = Ne.getParent;
function uu(e) {
  if (Ne.isWindow(e) || e.nodeType === 9)
    return null;
  var t = Ne.getDocument(e), r = t.body, i, n = Ne.css(e, "position"), a = n === "fixed" || n === "absolute";
  if (!a)
    return e.nodeName.toLowerCase() === "html" ? null : zo(e);
  for (i = zo(e); i && i !== r && i.nodeType !== 9; i = zo(i))
    if (n = Ne.css(i, "position"), n !== "static")
      return i;
  return null;
}
var Vh = Ne.getParent;
function jv(e) {
  if (Ne.isWindow(e) || e.nodeType === 9)
    return false;
  var t = Ne.getDocument(e), r = t.body, i = null;
  for (
    i = Vh(e);
    //  document.documentElement 
    i && i !== r && i !== t;
    i = Vh(i)
  ) {
    var n = Ne.css(i, "position");
    if (n === "fixed")
      return true;
  }
  return false;
}
function vc(e, t) {
  for (var r = {
    left: 0,
    right: 1 / 0,
    top: 0,
    bottom: 1 / 0
  }, i = uu(e), n = Ne.getDocument(e), a = n.defaultView || n.parentWindow, s = n.body, o = n.documentElement; i; ) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || i.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    i !== s && i !== o && Ne.css(i, "overflow") !== "visible") {
      var l = Ne.offset(i);
      l.left += i.clientLeft, l.top += i.clientTop, r.top = Math.max(r.top, l.top), r.right = Math.min(
        r.right,
        // consider area without scrollBar
        l.left + i.clientWidth
      ), r.bottom = Math.min(r.bottom, l.top + i.clientHeight), r.left = Math.max(r.left, l.left);
    } else if (i === s || i === o)
      break;
    i = uu(i);
  }
  var c = null;
  if (!Ne.isWindow(e) && e.nodeType !== 9) {
    c = e.style.position;
    var f = Ne.css(e, "position");
    f === "absolute" && (e.style.position = "fixed");
  }
  var p = Ne.getWindowScrollLeft(a), O = Ne.getWindowScrollTop(a), d2 = Ne.viewportWidth(a), g = Ne.viewportHeight(a), L = o.scrollWidth, D = o.scrollHeight, W = window.getComputedStyle(s);
  if (W.overflowX === "hidden" && (L = a.innerWidth), W.overflowY === "hidden" && (D = a.innerHeight), e.style && (e.style.position = c), t || jv(e))
    r.left = Math.max(r.left, p), r.top = Math.max(r.top, O), r.right = Math.min(r.right, p + d2), r.bottom = Math.min(r.bottom, O + g);
  else {
    var x = Math.max(L, p + d2);
    r.right = Math.min(r.right, x);
    var V = Math.max(D, O + g);
    r.bottom = Math.min(r.bottom, V);
  }
  return r.top >= 0 && r.left >= 0 && r.bottom > r.top && r.right > r.left ? r : null;
}
function Zv(e, t, r, i) {
  var n = Ne.clone(e), a = {
    width: t.width,
    height: t.height
  };
  return i.adjustX && n.left < r.left && (n.left = r.left), i.resizeWidth && n.left >= r.left && n.left + a.width > r.right && (a.width -= n.left + a.width - r.right), i.adjustX && n.left + a.width > r.right && (n.left = Math.max(r.right - a.width, r.left)), i.adjustY && n.top < r.top && (n.top = r.top), i.resizeHeight && n.top >= r.top && n.top + a.height > r.bottom && (a.height -= n.top + a.height - r.bottom), i.adjustY && n.top + a.height > r.bottom && (n.top = Math.max(r.bottom - a.height, r.top)), Ne.mix(n, a);
}
function Cc(e) {
  var t, r, i;
  if (!Ne.isWindow(e) && e.nodeType !== 9)
    t = Ne.offset(e), r = Ne.outerWidth(e), i = Ne.outerHeight(e);
  else {
    var n = Ne.getWindow(e);
    t = {
      left: Ne.getWindowScrollLeft(n),
      top: Ne.getWindowScrollTop(n)
    }, r = Ne.viewportWidth(n), i = Ne.viewportHeight(n);
  }
  return t.width = r, t.height = i, t;
}
function Bh(e, t) {
  var r = t.charAt(0), i = t.charAt(1), n = e.width, a = e.height, s = e.left, o = e.top;
  return r === "c" ? o += a / 2 : r === "b" && (o += a), i === "c" ? s += n / 2 : i === "r" && (s += n), {
    left: s,
    top: o
  };
}
function za(e, t, r, i, n) {
  var a = Bh(t, r[1]), s = Bh(e, r[0]), o = [s.left - a.left, s.top - a.top];
  return {
    left: Math.round(e.left - o[0] + i[0] - n[0]),
    top: Math.round(e.top - o[1] + i[1] - n[1])
  };
}
function $h(e, t, r) {
  return e.left < r.left || e.left + t.width > r.right;
}
function Yh2(e, t, r) {
  return e.top < r.top || e.top + t.height > r.bottom;
}
function Hv(e, t, r) {
  return e.left > r.right || e.left + t.width < r.left;
}
function zv(e, t, r) {
  return e.top > r.bottom || e.top + t.height < r.top;
}
function qa(e, t, r) {
  var i = [];
  return Ne.each(e, function(n) {
    i.push(n.replace(t, function(a) {
      return r[a];
    }));
  }), i;
}
function Ja(e, t) {
  return e[t] = -e[t], e;
}
function Fh(e, t) {
  var r;
  return /%$/.test(e) ? r = parseInt(e.substring(0, e.length - 1), 10) / 100 * t : r = parseInt(e, 10), r || 0;
}
function Wh(e, t) {
  e[0] = Fh(e[0], t.width), e[1] = Fh(e[1], t.height);
}
function uT(e, t, r, i) {
  var n = r.points, a = r.offset || [0, 0], s = r.targetOffset || [0, 0], o = r.overflow, l = r.source || e;
  a = [].concat(a), s = [].concat(s), o = o || {};
  var c = {}, f = 0, p = !!(o && o.alwaysByViewport), O = vc(l, p), d2 = Cc(l);
  Wh(a, d2), Wh(s, t);
  var g = za(d2, t, n, a, s), L = Ne.merge(d2, g);
  if (O && (o.adjustX || o.adjustY) && i) {
    if (o.adjustX && $h(g, d2, O)) {
      var D = qa(n, /[lr]/gi, {
        l: "r",
        r: "l"
      }), W = Ja(a, 0), x = Ja(s, 0), V = za(d2, t, D, W, x);
      Hv(V, d2, O) || (f = 1, n = D, a = W, s = x);
    }
    if (o.adjustY && Yh2(g, d2, O)) {
      var _2 = qa(n, /[tb]/gi, {
        t: "b",
        b: "t"
      }), $ = Ja(a, 1), z = Ja(s, 1), F = za(d2, t, _2, $, z);
      zv(F, d2, O) || (f = 1, n = _2, a = $, s = z);
    }
    f && (g = za(d2, t, n, a, s), Ne.mix(L, g));
    var ae = $h(g, d2, O), U = Yh2(g, d2, O);
    if (ae || U) {
      var G = n;
      ae && (G = qa(n, /[lr]/gi, {
        l: "r",
        r: "l"
      })), U && (G = qa(n, /[tb]/gi, {
        t: "b",
        b: "t"
      })), n = G, a = r.offset || [0, 0], s = r.targetOffset || [0, 0];
    }
    c.adjustX = o.adjustX && ae, c.adjustY = o.adjustY && U, (c.adjustX || c.adjustY) && (L = Zv(g, d2, O, c));
  }
  return L.width !== d2.width && Ne.css(l, "width", Ne.width(l) + L.width - d2.width), L.height !== d2.height && Ne.css(l, "height", Ne.height(l) + L.height - d2.height), Ne.offset(l, {
    left: L.left,
    top: L.top
  }, {
    useCssRight: r.useCssRight,
    useCssBottom: r.useCssBottom,
    useCssTransform: r.useCssTransform,
    ignoreShake: r.ignoreShake
  }), {
    points: n,
    offset: a,
    targetOffset: s,
    overflow: c
  };
}
function qv(e, t) {
  var r = vc(e, t), i = Cc(e);
  return !r || i.left + i.width <= r.left || i.top + i.height <= r.top || i.left >= r.right || i.top >= r.bottom;
}
function Lc(e, t, r) {
  var i = r.target || t, n = Cc(i), a = !qv(i, r.overflow && r.overflow.alwaysByViewport);
  return uT(e, n, r, a);
}
Lc.__getOffsetParent = uu;
Lc.__getVisibleRectForElement = vc;
function Jv(e, t, r) {
  var i, n, a = Ne.getDocument(e), s = a.defaultView || a.parentWindow, o = Ne.getWindowScrollLeft(s), l = Ne.getWindowScrollTop(s), c = Ne.viewportWidth(s), f = Ne.viewportHeight(s);
  "pageX" in t ? i = t.pageX : i = o + t.clientX, "pageY" in t ? n = t.pageY : n = l + t.clientY;
  var p = {
    left: i,
    top: n,
    width: 0,
    height: 0
  }, O = i >= 0 && i <= o + c && n >= 0 && n <= l + f, d2 = [r.points[0], "cc"];
  return uT(e, p, Dh(Dh({}, r), {}, {
    points: d2
  }), O);
}
var cu = {};
var xc = [];
var Kv = function(t) {
  xc.push(t);
};
function eC(e, t) {
  if (!e && console !== void 0) {
    var r = xc.reduce(function(i, n) {
      return n(i ?? "", "warning");
    }, t);
    r && console.error("Warning: ".concat(r));
  }
}
function tC(e, t) {
  if (!e && console !== void 0) {
    var r = xc.reduce(function(i, n) {
      return n(i ?? "", "note");
    }, t);
    r && console.warn("Note: ".concat(r));
  }
}
function rC() {
  cu = {};
}
function cT(e, t, r) {
  !t && !cu[r] && (e(false, r), cu[r] = true);
}
function po(e, t) {
  cT(eC, e, t);
}
function iC(e, t) {
  cT(tC, e, t);
}
po.preMessage = Kv;
po.resetWarned = rC;
po.noteOnce = iC;
function nC(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, i = /* @__PURE__ */ new Set();
  function n(a, s) {
    var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, l = i.has(a);
    if (po(!l, "Warning: There may be circular references"), l)
      return false;
    if (a === s)
      return true;
    if (r && o > 1)
      return false;
    i.add(a);
    var c = o + 1;
    if (Array.isArray(a)) {
      if (!Array.isArray(s) || a.length !== s.length)
        return false;
      for (var f = 0; f < a.length; f++)
        if (!n(a[f], s[f], c))
          return false;
      return true;
    }
    if (a && s && It(a) === "object" && It(s) === "object") {
      var p = Object.keys(a);
      return p.length !== Object.keys(s).length ? false : p.every(function(O) {
        return n(a[O], s[O], c);
      });
    }
    return false;
  }
  return n(e, t);
}
function aC(e, t, r, i) {
  var n = import_react_dom.default.unstable_batchedUpdates ? function(s) {
    import_react_dom.default.unstable_batchedUpdates(r, s);
  } : r;
  return e != null && e.addEventListener && e.addEventListener(t, n, i), {
    remove: function() {
      e != null && e.removeEventListener && e.removeEventListener(t, n, i);
    }
  };
}
var sC = function(e) {
  if (!e)
    return false;
  if (e instanceof Element) {
    if (e.offsetParent)
      return true;
    if (e.getBBox) {
      var t = e.getBBox(), r = t.width, i = t.height;
      if (r || i)
        return true;
    }
    if (e.getBoundingClientRect) {
      var n = e.getBoundingClientRect(), a = n.width, s = n.height;
      if (a || s)
        return true;
    }
  }
  return false;
};
function oC() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
var Xh = oC() ? _e2.useLayoutEffect : _e2.useEffect;
var lC = function(t, r) {
  var i = _e2.useRef(true);
  Xh(function() {
    return t(i.current);
  }, r), Xh(function() {
    return i.current = false, function() {
      i.current = true;
    };
  }, []);
};
function uC(e, t) {
  typeof e == "function" ? e(t) : It(e) === "object" && e && "current" in e && (e.current = t);
}
function cC() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var i = t.filter(function(n) {
    return n;
  });
  return i.length <= 1 ? i[0] : function(n) {
    t.forEach(function(a) {
      uC(a, n);
    });
  };
}
var fC = function(e, t) {
  var r = import_react.default.useRef(false), i = import_react.default.useRef(null);
  function n() {
    window.clearTimeout(i.current);
  }
  function a(s) {
    if (n(), !r.current || s === true) {
      if (e(s) === false)
        return;
      r.current = true, i.current = window.setTimeout(function() {
        r.current = false;
      }, t);
    } else
      i.current = window.setTimeout(function() {
        r.current = false, a();
      }, t);
  }
  return [a, function() {
    r.current = false, n();
  }];
};
function hC(e, t) {
  if (!e)
    return false;
  if (e.contains)
    return e.contains(t);
  for (var r = t; r; ) {
    if (r === e)
      return true;
    r = r.parentNode;
  }
  return false;
}
function pC(e, t) {
  return e === t ? true : !e || !t ? false : "pageX" in t && "pageY" in t ? e.pageX === t.pageX && e.pageY === t.pageY : "clientX" in t && "clientY" in t ? e.clientX === t.clientX && e.clientY === t.clientY : false;
}
function OC(e, t) {
  e !== document.activeElement && hC(t, e) && typeof e.focus == "function" && e.focus();
}
function jh(e, t) {
  var r = null, i = null;
  function n(s) {
    var o = c1(s, 1), l = o[0].target;
    if (document.documentElement.contains(l)) {
      var c = l.getBoundingClientRect(), f = c.width, p = c.height, O = Math.floor(f), d2 = Math.floor(p);
      (r !== O || i !== d2) && Promise.resolve().then(function() {
        t({
          width: O,
          height: d2
        });
      }), r = O, i = d2;
    }
  }
  var a = new nSe(n);
  return e && a.observe(e), function() {
    a.disconnect();
  };
}
function Zh(e) {
  return typeof e != "function" ? null : e();
}
function Hh(e) {
  return It(e) !== "object" || !e ? null : e;
}
var EC = function(t, r) {
  var i = t.children, n = t.disabled, a = t.target, s = t.align, o = t.onAlign, l = t.monitorWindowResize, c = t.monitorBufferTime, f = c === void 0 ? 0 : c, p = import_react.default.useRef({}), O = import_react.default.useRef(), d2 = import_react.default.Children.only(i), g = import_react.default.useRef({});
  g.current.disabled = n, g.current.target = a, g.current.align = s, g.current.onAlign = o;
  var L = fC(function() {
    var H = g.current, re = H.disabled, B = H.target, Y = H.align, E = H.onAlign, m = O.current;
    if (!re && B && m) {
      var P, R = Zh(B), A = Hh(B);
      p.current.element = R, p.current.point = A, p.current.align = Y;
      var y2 = document, C = y2.activeElement;
      return R && sC(R) ? P = Lc(m, R, Y) : A && (P = Jv(m, A, Y)), OC(C, m), E && P && E(m, P), true;
    }
    return false;
  }, f), D = c1(L, 2), W = D[0], x = D[1], V = import_react.default.useState(), _2 = c1(V, 2), $ = _2[0], z = _2[1], F = import_react.default.useState(), ae = c1(F, 2), U = ae[0], G = ae[1];
  return lC(function() {
    z(Zh(a)), G(Hh(a));
  }), import_react.default.useEffect(function() {
    (p.current.element !== $ || !pC(p.current.point, U) || !nC(p.current.align, s)) && W();
  }), import_react.default.useEffect(function() {
    var H = jh(O.current, W);
    return H;
  }, [O.current]), import_react.default.useEffect(function() {
    var H = jh($, W);
    return H;
  }, [$]), import_react.default.useEffect(function() {
    n ? x() : W();
  }, [n]), import_react.default.useEffect(function() {
    if (l) {
      var H = aC(window, "resize", W);
      return H.remove;
    }
  }, [l]), import_react.default.useEffect(function() {
    return function() {
      x();
    };
  }, []), import_react.default.useImperativeHandle(r, function() {
    return {
      forceAlign: function() {
        return W(true);
      }
    };
  }), import_react.default.isValidElement(d2) && (d2 = import_react.default.cloneElement(d2, {
    ref: cC(d2.ref, O)
  })), d2;
};
var fT = import_react.default.forwardRef(EC);
fT.displayName = "Align";
var zh = Pa2() ? _e2.useLayoutEffect : _e2.useEffect;
var qh = function(t, r) {
  var i = _e2.useRef(true);
  zh(function() {
    return t(i.current);
  }, r), zh(function() {
    return i.current = false, function() {
      i.current = true;
    };
  }, []);
};
var Jh = ["measure", "alignPre", "align", null, "motion"];
var dC = function(e, t) {
  var r = jn(null), i = c1(r, 2), n = i[0], a = i[1], s = (0, import_react.useRef)();
  function o(f) {
    a(f, true);
  }
  function l() {
    Wr.cancel(s.current);
  }
  function c(f) {
    l(), s.current = Wr(function() {
      o(function(p) {
        switch (n) {
          case "align":
            return "motion";
          case "motion":
            return "stable";
        }
        return p;
      }), f == null || f();
    });
  }
  return (0, import_react.useEffect)(function() {
    o("measure");
  }, [e]), (0, import_react.useEffect)(function() {
    switch (n) {
      case "measure":
        t();
        break;
    }
    n && (s.current = Wr(RY(_f().mark(function f() {
      var p, O;
      return _f().wrap(function(g) {
        for (; ; )
          switch (g.prev = g.next) {
            case 0:
              p = Jh.indexOf(n), O = Jh[p + 1], O && p !== -1 && o(O);
            case 3:
            case "end":
              return g.stop();
          }
      }, f);
    }))));
  }, [n]), (0, import_react.useEffect)(function() {
    return function() {
      l();
    };
  }, []), [n, c];
};
var TC = function(e) {
  var t = _e2.useState({
    width: 0,
    height: 0
  }), r = c1(t, 2), i = r[0], n = r[1];
  function a(o) {
    var l = o.offsetWidth, c = o.offsetHeight, f = o.getBoundingClientRect(), p = f.width, O = f.height;
    Math.abs(l - p) < 1 && Math.abs(c - O) < 1 && (l = p, c = O), n({
      width: l,
      height: c
    });
  }
  var s = _e2.useMemo(function() {
    var o = {};
    if (e) {
      var l = i.width, c = i.height;
      e.indexOf("height") !== -1 && c ? o.height = c : e.indexOf("minHeight") !== -1 && c && (o.minHeight = c), e.indexOf("width") !== -1 && l ? o.width = l : e.indexOf("minWidth") !== -1 && l && (o.minWidth = l);
    }
    return o;
  }, [e, i]);
  return [s, a];
};
var hT = _e2.forwardRef(function(e, t) {
  var r = e.visible, i = e.prefixCls, n = e.className, a = e.style, s = e.children, o = e.zIndex, l = e.stretch, c = e.destroyPopupOnHide, f = e.forceRender, p = e.align, O = e.point, d2 = e.getRootDomNode, g = e.getClassNameFromAlign, L = e.onAlign, D = e.onMouseEnter, W = e.onMouseLeave, x = e.onMouseDown, V = e.onTouchStart, _2 = e.onClick, $ = (0, import_react.useRef)(), z = (0, import_react.useRef)(), F = (0, import_react.useState)(), ae = c1(F, 2), U = ae[0], G = ae[1], H = TC(l), re = c1(H, 2), B = re[0], Y = re[1];
  function E() {
    l && Y(d2());
  }
  var m = dC(r, E), P = c1(m, 2), R = P[0], A = P[1], y2 = (0, import_react.useState)(0), C = c1(y2, 2), j = C[0], w = C[1], J = (0, import_react.useRef)();
  qh(function() {
    R === "alignPre" && w(0);
  }, [R]);
  function te() {
    return O || d2;
  }
  function se() {
    var Ee;
    (Ee = $.current) === null || Ee === void 0 || Ee.forceAlign();
  }
  function ge(Ee, ut) {
    var Je = g(ut);
    U !== Je && G(Je), w(function(q) {
      return q + 1;
    }), R === "align" && (L == null || L(Ee, ut));
  }
  qh(function() {
    R === "align" && (j < 3 ? se() : A(function() {
      var Ee;
      (Ee = J.current) === null || Ee === void 0 || Ee.call(J);
    }));
  }, [j]);
  var fe = Ye({}, tT(e));
  ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(Ee) {
    var ut = fe[Ee];
    fe[Ee] = function(Je, q) {
      return A(), ut == null ? void 0 : ut(Je, q);
    };
  });
  function et() {
    return new Promise(function(Ee) {
      J.current = Ee;
    });
  }
  _e2.useEffect(function() {
    !fe.motionName && R === "motion" && A();
  }, [fe.motionName, R]), _e2.useImperativeHandle(t, function() {
    return {
      forceAlign: se,
      getElement: function() {
        return z.current;
      }
    };
  });
  var yt = Ye(Ye({}, B), {}, {
    zIndex: o,
    opacity: R === "motion" || R === "stable" || !r ? void 0 : 0,
    // Cannot interact with disappearing elements
    // https://github.com/ant-design/ant-design/issues/35051#issuecomment-1101340714
    pointerEvents: !r && R !== "stable" ? "none" : void 0
  }, a), De = true;
  p != null && p.points && (R === "align" || R === "stable") && (De = false);
  var Ce = s;
  return _e2.Children.count(s) > 1 && (Ce = d("div", {
    className: "".concat(i, "-content"),
    children: s
  })), d(fo, {
    visible: r,
    ref: z,
    leavedClassName: "".concat(i, "-hidden"),
    ...fe,
    onAppearPrepare: et,
    onEnterPrepare: et,
    removeOnLeave: c,
    forceRender: f,
    children: function(Ee, ut) {
      var Je = Ee.className, q = Ee.style, ot = _e(i, n, U, Je);
      return d(fT, {
        target: te(),
        ref: $,
        monitorWindowResize: true,
        disabled: De,
        align: p,
        onAlign: ge,
        children: d("div", {
          ref: ut,
          className: ot,
          onMouseEnter: D,
          onMouseLeave: W,
          onMouseDownCapture: x,
          onTouchStartCapture: V,
          onClick: _2,
          style: Ye(Ye({}, q), yt),
          children: Ce
        })
      }, "popup");
    }
  });
});
hT.displayName = "PopupInner";
var pT = _e2.forwardRef(function(e, t) {
  var r = e.prefixCls, i = e.visible, n = e.zIndex, a = e.children, s = e.mobile;
  s = s === void 0 ? {} : s;
  var o = s.popupClassName, l = s.popupStyle, c = s.popupMotion, f = c === void 0 ? {} : c, p = s.popupRender, O = e.onClick, d2 = _e2.useRef();
  _e2.useImperativeHandle(t, function() {
    return {
      forceAlign: function() {
      },
      getElement: function() {
        return d2.current;
      }
    };
  });
  var g = Ye({
    zIndex: n
  }, l), L = a;
  return _e2.Children.count(a) > 1 && (L = d("div", {
    className: "".concat(r, "-content"),
    children: a
  })), p && (L = p(L)), d(fo, {
    visible: i,
    ref: d2,
    removeOnLeave: true,
    ...f,
    children: function(D, W) {
      var x = D.className, V = D.style, _2 = _e(r, o, x);
      return d("div", {
        ref: W,
        className: _2,
        onClick: O,
        style: Ye(Ye({}, V), g),
        children: L
      });
    }
  });
});
pT.displayName = "MobilePopupInner";
var SC = ["visible", "mobile"];
var OT = _e2.forwardRef(function(e, t) {
  var r = e.visible, i = e.mobile, n = Gt(e, SC), a = (0, import_react.useState)(r), s = c1(a, 2), o = s[0], l = s[1], c = (0, import_react.useState)(false), f = c1(c, 2), p = f[0], O = f[1], d2 = Ye(Ye({}, n), {}, {
    visible: o
  });
  (0, import_react.useEffect)(function() {
    l(r), r && i && O(av());
  }, [r, i]);
  var g = p ? d(pT, {
    ...d2,
    mobile: i,
    ref: t
  }) : d(hT, {
    ...d2,
    ref: t
  });
  return N("div", {
    children: [d(Nv, {
      ...d2
    }), g]
  });
});
OT.displayName = "Popup";
var Kh = _e2.createContext(null);
function qo() {
}
function mC() {
  return "";
}
function RC(e) {
  return e ? e.ownerDocument : window.document;
}
var AC = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function gC(e) {
  var t = function(r) {
    g4(n, r);
    var i = T0(n);
    function n(a) {
      var s;
      Da(this, n), s = i.call(this, a), Be(J1(s), "popupRef", _e2.createRef()), Be(J1(s), "triggerRef", _e2.createRef()), Be(J1(s), "portalContainer", void 0), Be(J1(s), "attachId", void 0), Be(J1(s), "clickOutsideHandler", void 0), Be(J1(s), "touchOutsideHandler", void 0), Be(J1(s), "contextMenuOutsideHandler1", void 0), Be(J1(s), "contextMenuOutsideHandler2", void 0), Be(J1(s), "mouseDownTimeout", void 0), Be(J1(s), "focusTime", void 0), Be(J1(s), "preClickTime", void 0), Be(J1(s), "preTouchTime", void 0), Be(J1(s), "delayTimer", void 0), Be(J1(s), "hasPopupMouseDown", void 0), Be(J1(s), "onMouseEnter", function(l) {
        var c = s.props.mouseEnterDelay;
        s.fireEvents("onMouseEnter", l), s.delaySetPopupVisible(true, c, c ? null : l);
      }), Be(J1(s), "onMouseMove", function(l) {
        s.fireEvents("onMouseMove", l), s.setPoint(l);
      }), Be(J1(s), "onMouseLeave", function(l) {
        s.fireEvents("onMouseLeave", l), s.delaySetPopupVisible(false, s.props.mouseLeaveDelay);
      }), Be(J1(s), "onPopupMouseEnter", function() {
        s.clearDelayTimer();
      }), Be(J1(s), "onPopupMouseLeave", function(l) {
        var c;
        l.relatedTarget && !l.relatedTarget.setTimeout && Wo((c = s.popupRef.current) === null || c === void 0 ? void 0 : c.getElement(), l.relatedTarget) || s.delaySetPopupVisible(false, s.props.mouseLeaveDelay);
      }), Be(J1(s), "onFocus", function(l) {
        s.fireEvents("onFocus", l), s.clearDelayTimer(), s.isFocusToShow() && (s.focusTime = Date.now(), s.delaySetPopupVisible(true, s.props.focusDelay));
      }), Be(J1(s), "onMouseDown", function(l) {
        s.fireEvents("onMouseDown", l), s.preClickTime = Date.now();
      }), Be(J1(s), "onTouchStart", function(l) {
        s.fireEvents("onTouchStart", l), s.preTouchTime = Date.now();
      }), Be(J1(s), "onBlur", function(l) {
        s.fireEvents("onBlur", l), s.clearDelayTimer(), s.isBlurToHide() && s.delaySetPopupVisible(false, s.props.blurDelay);
      }), Be(J1(s), "onContextMenu", function(l) {
        l.preventDefault(), s.fireEvents("onContextMenu", l), s.setPopupVisible(true, l);
      }), Be(J1(s), "onContextMenuClose", function() {
        s.isContextMenuToShow() && s.close();
      }), Be(J1(s), "onClick", function(l) {
        if (s.fireEvents("onClick", l), s.focusTime) {
          var c;
          if (s.preClickTime && s.preTouchTime ? c = Math.min(s.preClickTime, s.preTouchTime) : s.preClickTime ? c = s.preClickTime : s.preTouchTime && (c = s.preTouchTime), Math.abs(c - s.focusTime) < 20)
            return;
          s.focusTime = 0;
        }
        s.preClickTime = 0, s.preTouchTime = 0, s.isClickToShow() && (s.isClickToHide() || s.isBlurToHide()) && l && l.preventDefault && l.preventDefault();
        var f = !s.state.popupVisible;
        (s.isClickToHide() && !f || f && s.isClickToShow()) && s.setPopupVisible(!s.state.popupVisible, l);
      }), Be(J1(s), "onPopupMouseDown", function() {
        if (s.hasPopupMouseDown = true, clearTimeout(s.mouseDownTimeout), s.mouseDownTimeout = window.setTimeout(function() {
          s.hasPopupMouseDown = false;
        }, 0), s.context) {
          var l;
          (l = s.context).onPopupMouseDown.apply(l, arguments);
        }
      }), Be(J1(s), "onDocumentClick", function(l) {
        if (!(s.props.mask && !s.props.maskClosable)) {
          var c = l.target, f = s.getRootDomNode(), p = s.getPopupDomNode();
          (!Wo(f, c) || s.isContextMenuOnly()) && !Wo(p, c) && !s.hasPopupMouseDown && s.close();
        }
      }), Be(J1(s), "getRootDomNode", function() {
        var l = s.props.getTriggerDOMNode;
        if (l)
          return l(s.triggerRef.current);
        try {
          var c = Yd(s.triggerRef.current);
          if (c)
            return c;
        } catch {
        }
        return import_react_dom.default.findDOMNode(J1(s));
      }), Be(J1(s), "getPopupClassNameFromAlign", function(l) {
        var c = [], f = s.props, p = f.popupPlacement, O = f.builtinPlacements, d2 = f.prefixCls, g = f.alignPoint, L = f.getPopupClassNameFromAlign;
        return p && O && c.push(nv(O, d2, l, g)), L && c.push(L(l)), c.join(" ");
      }), Be(J1(s), "getComponent", function() {
        var l = s.props, c = l.prefixCls, f = l.destroyPopupOnHide, p = l.popupClassName, O = l.onPopupAlign, d2 = l.popupMotion, g = l.popupAnimation, L = l.popupTransitionName, D = l.popupStyle, W = l.mask, x = l.maskAnimation, V = l.maskTransitionName, _2 = l.maskMotion, $ = l.zIndex, z = l.popup, F = l.stretch, ae = l.alignPoint, U = l.mobile, G = l.forceRender, H = l.onPopupClick, re = s.state, B = re.popupVisible, Y = re.point, E = s.getPopupAlign(), m = {};
        return s.isMouseEnterToShow() && (m.onMouseEnter = s.onPopupMouseEnter), s.isMouseLeaveToHide() && (m.onMouseLeave = s.onPopupMouseLeave), m.onMouseDown = s.onPopupMouseDown, m.onTouchStart = s.onPopupMouseDown, d(OT, {
          prefixCls: c,
          destroyPopupOnHide: f,
          visible: B,
          point: ae && Y,
          className: p,
          align: E,
          onAlign: O,
          animation: g,
          getClassNameFromAlign: s.getPopupClassNameFromAlign,
          ...m,
          stretch: F,
          getRootDomNode: s.getRootDomNode,
          style: D,
          mask: W,
          zIndex: $,
          transitionName: L,
          maskAnimation: x,
          maskTransitionName: V,
          maskMotion: _2,
          ref: s.popupRef,
          motion: d2,
          mobile: U,
          forceRender: G,
          onClick: H,
          children: typeof z == "function" ? z() : z
        });
      }), Be(J1(s), "attachParent", function(l) {
        Wr.cancel(s.attachId);
        var c = s.props, f = c.getPopupContainer, p = c.getDocument, O = s.getRootDomNode(), d2;
        f ? (O || f.length === 0) && (d2 = f(O)) : d2 = p(s.getRootDomNode()).body, d2 ? d2.appendChild(l) : s.attachId = Wr(function() {
          s.attachParent(l);
        });
      }), Be(J1(s), "getContainer", function() {
        if (!s.portalContainer) {
          var l = s.props.getDocument, c = l(s.getRootDomNode()).createElement("div");
          c.style.position = "absolute", c.style.top = "0", c.style.left = "0", c.style.width = "100%", s.portalContainer = c;
        }
        return s.attachParent(s.portalContainer), s.portalContainer;
      }), Be(J1(s), "setPoint", function(l) {
        var c = s.props.alignPoint;
        !c || !l || s.setState({
          point: {
            pageX: l.pageX,
            pageY: l.pageY
          }
        });
      }), Be(J1(s), "handlePortalUpdate", function() {
        s.state.prevPopupVisible !== s.state.popupVisible && s.props.afterPopupVisibleChange(s.state.popupVisible);
      }), Be(J1(s), "triggerContextValue", {
        onPopupMouseDown: s.onPopupMouseDown
      });
      var o;
      return "popupVisible" in a ? o = !!a.popupVisible : o = !!a.defaultPopupVisible, s.state = {
        prevPopupVisible: o,
        popupVisible: o
      }, AC.forEach(function(l) {
        s["fire".concat(l)] = function(c) {
          s.fireEvents(l, c);
        };
      }), s;
    }
    return Pa(n, [{
      key: "componentDidMount",
      value: function() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function() {
        var s = this.props, o = this.state;
        if (o.popupVisible) {
          var l;
          !this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow()) && (l = s.getDocument(this.getRootDomNode()), this.clickOutsideHandler = Fa(l, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (l = l || s.getDocument(this.getRootDomNode()), this.touchOutsideHandler = Fa(l, "touchstart", this.onDocumentClick)), !this.contextMenuOutsideHandler1 && this.isContextMenuToShow() && (l = l || s.getDocument(this.getRootDomNode()), this.contextMenuOutsideHandler1 = Fa(l, "scroll", this.onContextMenuClose)), !this.contextMenuOutsideHandler2 && this.isContextMenuToShow() && (this.contextMenuOutsideHandler2 = Fa(window, "blur", this.onContextMenuClose));
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), Wr.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function() {
        var s;
        return ((s = this.popupRef.current) === null || s === void 0 ? void 0 : s.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function() {
        var s = this.props, o = s.popupPlacement, l = s.popupAlign, c = s.builtinPlacements;
        return o && c ? iv(c, o, l) : l;
      }
    }, {
      key: "setPopupVisible",
      value: (
        /**
         * @param popupVisible    Show or not the popup element
         * @param event           SyntheticEvent, used for `pointAlign`
         */
        function(s, o) {
          var l = this.props.alignPoint, c = this.state.popupVisible;
          this.clearDelayTimer(), c !== s && ("popupVisible" in this.props || this.setState({
            popupVisible: s,
            prevPopupVisible: c
          }), this.props.onPopupVisibleChange(s)), l && o && s && this.setPoint(o);
        }
      )
    }, {
      key: "delaySetPopupVisible",
      value: function(s, o, l) {
        var c = this, f = o * 1e3;
        if (this.clearDelayTimer(), f) {
          var p = l ? {
            pageX: l.pageX,
            pageY: l.pageY
          } : null;
          this.delayTimer = window.setTimeout(function() {
            c.setPopupVisible(s, p), c.clearDelayTimer();
          }, f);
        } else
          this.setPopupVisible(s, l);
      }
    }, {
      key: "clearDelayTimer",
      value: function() {
        this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null);
      }
    }, {
      key: "clearOutsideHandler",
      value: function() {
        this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextMenuOutsideHandler1 && (this.contextMenuOutsideHandler1.remove(), this.contextMenuOutsideHandler1 = null), this.contextMenuOutsideHandler2 && (this.contextMenuOutsideHandler2.remove(), this.contextMenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
      }
    }, {
      key: "createTwoChains",
      value: function(s) {
        var o = this.props.children.props, l = this.props;
        return o[s] && l[s] ? this["fire".concat(s)] : o[s] || l[s];
      }
    }, {
      key: "isClickToShow",
      value: function() {
        var s = this.props, o = s.action, l = s.showAction;
        return o.indexOf("click") !== -1 || l.indexOf("click") !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function() {
        var s = this.props.action;
        return s === "contextMenu" || s.length === 1 && s[0] === "contextMenu";
      }
    }, {
      key: "isContextMenuToShow",
      value: function() {
        var s = this.props, o = s.action, l = s.showAction;
        return o.indexOf("contextMenu") !== -1 || l.indexOf("contextMenu") !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function() {
        var s = this.props, o = s.action, l = s.hideAction;
        return o.indexOf("click") !== -1 || l.indexOf("click") !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function() {
        var s = this.props, o = s.action, l = s.showAction;
        return o.indexOf("hover") !== -1 || l.indexOf("mouseEnter") !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function() {
        var s = this.props, o = s.action, l = s.hideAction;
        return o.indexOf("hover") !== -1 || l.indexOf("mouseLeave") !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function() {
        var s = this.props, o = s.action, l = s.showAction;
        return o.indexOf("focus") !== -1 || l.indexOf("focus") !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function() {
        var s = this.props, o = s.action, l = s.hideAction;
        return o.indexOf("focus") !== -1 || l.indexOf("blur") !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function() {
        if (this.state.popupVisible) {
          var s;
          (s = this.popupRef.current) === null || s === void 0 || s.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function(s, o) {
        var l = this.props.children.props[s];
        l && l(o);
        var c = this.props[s];
        c && c(o);
      }
    }, {
      key: "close",
      value: function() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function() {
        var s = this.state.popupVisible, o = this.props, l = o.children, c = o.forceRender, f = o.alignPoint, p = o.className, O = o.autoDestroy, d2 = _e2.Children.only(l), g = {
          key: "trigger"
        };
        this.isContextMenuToShow() ? g.onContextMenu = this.onContextMenu : g.onContextMenu = this.createTwoChains("onContextMenu"), this.isClickToHide() || this.isClickToShow() ? (g.onClick = this.onClick, g.onMouseDown = this.onMouseDown, g.onTouchStart = this.onTouchStart) : (g.onClick = this.createTwoChains("onClick"), g.onMouseDown = this.createTwoChains("onMouseDown"), g.onTouchStart = this.createTwoChains("onTouchStart")), this.isMouseEnterToShow() ? (g.onMouseEnter = this.onMouseEnter, f && (g.onMouseMove = this.onMouseMove)) : g.onMouseEnter = this.createTwoChains("onMouseEnter"), this.isMouseLeaveToHide() ? g.onMouseLeave = this.onMouseLeave : g.onMouseLeave = this.createTwoChains("onMouseLeave"), this.isFocusToShow() || this.isBlurToHide() ? (g.onFocus = this.onFocus, g.onBlur = this.onBlur) : (g.onFocus = this.createTwoChains("onFocus"), g.onBlur = this.createTwoChains("onBlur"));
        var L = _e(d2 && d2.props && d2.props.className, p);
        L && (g.className = L);
        var D = Ye({}, g);
        Wd(d2) && (D.ref = ev(this.triggerRef, d2.ref));
        var W = _e2.cloneElement(d2, D), x;
        return (s || this.popupRef.current || c) && (x = d(e, {
          getContainer: this.getContainer,
          didUpdate: this.handlePortalUpdate,
          children: this.getComponent()
        }, "portal")), !s && O && (x = null), N(Kh.Provider, {
          value: this.triggerContextValue,
          children: [W, x]
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(s, o) {
        var l = s.popupVisible, c = {};
        return l !== void 0 && o.popupVisible !== l && (c.popupVisible = l, c.prevPopupVisible = o.popupVisible), c;
      }
    }]), n;
  }(_e2.Component);
  return Be(t, "contextType", Kh), Be(t, "defaultProps", {
    prefixCls: "rc-trigger-popup",
    getPopupClassNameFromAlign: mC,
    getDocument: RC,
    onPopupVisibleChange: qo,
    afterPopupVisibleChange: qo,
    onPopupAlign: qo,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  }), t;
}
var yC = gC(tv);
var IC = de.div`
  max-width: 60vw;
  max-height: 70vh;
  position: fixed;
  z-index: ${gs.codeEditorPanel};
  top: 35%;
  left: 50%;
  border-radius: 8px;
  background: #ffffff;
  box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.1);
`;
var NC = de.div`
  height: 40px;
  cursor: move;
  padding: 0 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid #e1e3eb;
`;
var PC = de.div`
  display: flex;
  align-items: center;
  font-weight: 500;
  font-size: 16px;
  line-height: 16px;
  color: #222222;
  //margin-bottom: 16px;
`;
var _C = de(lH)`
  margin-right: 8px;
`;
var bC = de.div`
  height: calc(100% - 40px);
`;
var vC = de.div`
  position: absolute;
  height: 16px;
  width: 16px;
  border: 1px solid #d7d9e0;
  border-radius: 4px;
  z-index: 1;
  bottom: 8px;
  right: 8px;
  cursor: pointer;
  display: none;
  background-color: #ffffff;

  svg {
    height: 100%;
    display: block;
    margin: auto;
  }

  &:hover {
    svg g g {
      stroke: #222222;
    }
  }
`;
var CC = de.div`
    display: flex;
    justify-content: space-between;
    align-items: center;
`;
var LC = de.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 60px;
  height: 26px;
  background: #ffffff;
  border: 1px solid #d7d9e0;
  border-radius: 4px;

  font-size: 13px;
  color: #333333;
  padding: 6px 8px 5px;
  //margin-bottom: auto;
  cursor: pointer;

  &:hover {
    background: #f5f5f6;

    svg g g {
      stroke: #222222;
    }
  }
`;
var xC = de.div`
    width: 32px;
    height: 26px;
    border: 1px solid #d7d9e0;
    border-radius: 4px;
    color: #333333;
    padding: 2px ;
    cursor: pointer;

    &:hover {
        background: #f5f5f6;

        svg g g {
            stroke: #222222;
        }
    }

    // fixes the icon when there's no text in the container
    svg {
        width: 100%;
        height: 100%;
        fill: currentColor; 
    }
`;
var DC = (e) => {
  const t = (0, import_react.useRef)(null), [r, i] = (0, import_react.useState)(true), [n, a] = (0, import_react.useState)(false), [s, o] = (0, import_react.useState)({
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  }), l = (0, import_react.useMemo)(() => ZXe(), [e.editor]), [c, f] = (0, import_react.useState)({
    w: l.codeEditor.w,
    h: l.codeEditor.h
  }), [p, O] = (0, import_react.useState)(false), d2 = (0, import_react.useContext)(Yh);
  return d(yC, {
    popupVisible: p,
    action: ["click"],
    zIndex: gs.codeEditorPanel,
    popupStyle: {
      opacity: 1,
      display: p ? "block" : "none"
    },
    maskClosable: !n,
    mask: true,
    onPopupVisibleChange: (g) => O(g),
    afterPopupVisibleChange: (g) => e.onVisibleChange(g),
    getPopupContainer: (g) => g.parentNode.parentNode,
    popup: () => d(pee, {
      positionOffset: {
        x: "-50%",
        y: "-50%"
      },
      disabled: r,
      bounds: s,
      onStart: (g, L) => {
        var V;
        const {
          clientWidth: D,
          clientHeight: W
        } = window.document.documentElement, x = (V = t.current) == null ? void 0 : V.getBoundingClientRect();
        x && o({
          left: -x.left + L.x,
          right: D - (x.right - L.x),
          top: -x.top + L.y,
          bottom: W - (x.bottom - L.y)
        });
      },
      children: d(Iee, {
        width: c.w,
        height: c.h,
        onResize: (g, {
          size: L
        }) => f({
          w: L.width,
          h: L.height
        }),
        onResizeStop: () => B6n({
          ...l,
          codeEditor: {
            w: c.w,
            h: c.h
          }
        }),
        handle: i8n,
        resizeHandles: ["s", "n", "w", "e", "sw", "nw", "se", "ne"],
        minConstraints: [480, 360],
        children: N(IC, {
          ref: t,
          style: {
            width: c.w + "px",
            height: c.h + "px"
          },
          children: [N(NC, {
            onMouseOver: () => i(false),
            onMouseOut: () => i(true),
            children: [N(PC, {
              children: [d(_C, {}), [d2, ...e.breadcrumb ?? []].filter((g) => !o2.isEmpty(g)).join(" / ")]
            }), N(CC, {
              children: [d(xC, {
                onClick: () => a(!n),
                children: n ? d(if2, {}) : d(cf2, {})
              }), N(LC, {
                onClick: () => O(false),
                children: [d(nf2, {}), _("codeEditor.fold")]
              })]
            })]
          }), d(bC, {
            children: e.editor
          })]
        })
      })
    }),
    children: d(vC, {
      className: "code-editor-panel-open-button",
      onClick: () => O(true),
      children: d(af2, {})
    })
  });
};
var UC2 = {
  medium: {
    minHeight: "90px",
    maxHeight: "440px",
    showLineNum: true
  },
  higher: {
    minHeight: "auto",
    maxHeight: "256px"
  },
  window: {
    minHeight: "320px",
    maxHeight: "320px",
    showLineNum: true
  }
};
var Vn = T2`
  word-wrap: break-word;
  word-break: break-all;
  white-space: pre-wrap;
  font-size: 13px;
  line-height: 13px;
`;
var Dc = de.div`
  // tooltip common
  .cm-tooltip {
    border: 1px solid #d7d9e0;
    padding: 5px !important;
    margin-top: 5px !important;
    height: 120px;
  }
  // make sure antd popover in the code editor available
  .ant-popover {
    z-index: ${gs.codeEditorTooltip};
  }

  // lint tooltip style
  .cm-tooltip .cm-tooltip-lint {
    background-color: #2c2c2c;
    border-radius: 4px;
    box-shadow: 0 3px 6px -4px rgb(0 0 0 / 12%), 0 6px 16px 0 rgb(0 0 0 / 8%),
      0 9px 28px 8px rgb(0 0 0 / 5%);
    color: #ffffff;
    padding: 3px 0px;
  }
  .cm-tooltip .cm-diagnostic {
    padding: 3px 8px;
  }
  .cm-tooltip .cm-diagnostic-error {
    border: none;
  }

  // auto-completion tooltip
  // main tooltip
  .cm-tooltip.cm-tooltip-autocomplete {
    min-width: 280px;
    padding: 16px 4px 16px 8px;
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.1);
    transform: translate(-16px, 10px);
    z-index: ${gs.codeEditorTooltip};
  }

  // left minor tooltip
  .cm-tooltip > .cm-completionInfo {
    top: 0 !important;
    right: calc(100% + 4px);
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 0 10px 0 rgba(0, 0, 0, 0.1);
    border: none;
    padding: 16px;
  }

  // the right tooltip's gap with the main tooltip
  .cm-completionInfo.cm-completionInfo-right {
    left: calc(100% + 4px);
  }

  .cm-tooltip > .cm-completionInfo .hintDiv {
    display: inline-flex;
    align-items: baseline;
    cursor: pointer;
    color: #4965f2;
    ${Vn};
    font-weight: 600;
    z-index: ${gs.codeEditorTooltip};
  }

  .cm-tooltip > .cm-completionInfo .hintDiv:hover {
    color: #3377ff;
  }

  .cm-tooltip > .cm-completionInfo .hintDiv:hover .hintSvg g {
    stroke: #3377ff;
  }

  .cm-tooltip > .cm-completionInfo .hintName {
    display: inline-block;
    margin-bottom: 4px;
  }

  .cm-tooltip > .cm-completionInfo .hintType {
    color: #8b8fa3;
    display: block;
    margin: 8px 0;
    ${Vn};
  }

  .cm-tooltip > .cm-completionInfo .hintDoc {
    color: #333333;
    ${Vn};
  }

  .cm-tooltip > .cm-completionInfo .hintSvg {
    transform: translateY(3px);
    cursor: pointer;
  }

  // set the min-width of the dropdown
  .cm-tooltip.cm-tooltip-autocomplete > ul {
    min-width: 200px;
    scrollbar-gutter: stable;
    font-family: RobotoMono;
  }

  // each li style
  .cm-tooltip.cm-tooltip-autocomplete > ul > li {
    ${Vn};
    color: #333333;
    padding: 6px 0;
    display: flex;
    align-items: center;
  }

  // hover in each line
  .cm-tooltip.cm-tooltip-autocomplete > ul > li:hover {
    background-color: rgba(242, 247, 252, 0.7);
    border-radius: 4px;
  }

  // textStyle in each line
  .cm-tooltip.cm-tooltip-autocomplete > ul > li > span:last-child {
    margin-left: auto;
    font-style: normal;
    color: #8b8fa3;
    padding-right: 8px;
    padding-left: 6px;
    ${Vn};
  }

  // selected line
  .cm-tooltip.cm-tooltip-autocomplete > ul > li[aria-selected] {
    background-color: #f2f7fc;
    border-radius: 4px;
    font-weight: 600;
  }

  // scrollbar
  .cm-tooltip.cm-tooltip-autocomplete > ul::-webkit-scrollbar {
    width: 4px;
  }

  .cm-tooltip.cm-tooltip-autocomplete > ul::-webkit-scrollbar-thumb {
    background-clip: content-box;
    border-radius: 9999px;
    background-color: rgba(139, 143, 163, 0.12);
    height: 50px;
    min-height: 50px;
    max-height: 50px;
  }

  .cm-tooltip.cm-tooltip-autocomplete > ul::-webkit-scrollbar-thumb:hover {
    background-color: rgba(139, 143, 163, 0.36);
  }
`;
function Yn(e) {
  return e ? UC2[e] : {
    minHeight: "auto",
    maxHeight: "180px"
  };
}
function wC(e, t) {
  const {
    value: r,
    onChange: i
  } = e, n = (0, import_react.useRef)(), a = (0, import_react.useRef)(0), s = e.showLineNum ?? Yn(e.styleName).showLineNum, o = (0, import_react.useCallback)(o2.debounce((p) => {
    window.clearTimeout(a.current), a.current = window.setTimeout(() => a.current = 0, 100), i == null || i(p);
  }, 1e3), [i]), {
    extensions: l,
    reconfigure: c,
    isFocus: f
  } = Jb({
    ...e,
    showLineNum: s,
    onChange: o,
    tooltipContainer: t.current
  });
  return (0, import_react.useEffect)(() => c(n.current), [c]), (0, import_react.useEffect)(() => {
    const p = n.current;
    if (!p || !a.current && r !== p.state.doc.toString()) {
      const O = i3.create({
        doc: r,
        extensions: l
      });
      p ? p.setState(O) : n.current = new ua({
        state: O,
        parent: t.current
      });
    }
  }, [t, r, l]), y(n.current, r, e.codeType, e.exposingData), (0, import_react.useEffect)(() => () => {
    var p;
    (p = n.current) == null || p.destroy();
  }, []), {
    view: n.current,
    isFocus: f
  };
}
function ET(e) {
  if (e)
    return T2`
      .cm-click-comp-name:hover {
        cursor: pointer;
        text-decoration: underline;
      }
    `;
}
var MC = de.div`
  height: 100%;
  max-height: 100%;
  min-height: 100%;
  overflow: auto;
  border-bottom-right-radius: 8px;
  border-bottom-left-radius: 8px;
  ::-webkit-scrollbar {
    width: 16px;
  }

  ::-webkit-scrollbar-thumb {
    border: 5px solid transparent;
    background-clip: content-box;
    border-radius: 9999px;
    background-color: rgba(139, 143, 163, 0.2);
    min-height: 30px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background-color: rgba(139, 143, 163, 0.5);
  }

  .cm-content {
    padding-top: 12px;
    padding-bottom: 0;
    height: auto;
  }

  .cm-gutters {
    border-top-left-radius: 0;
    height: auto;
  }

  .cm-editor,
  .cm-scroller {
    border-bottom-left-radius: 8px;
    border-bottom-right-radius: 8px;
  }

  .cm-scroller {
    align-items: stretch !important;
    flex-grow: 1;
  }

  .cm-editor {
    min-height: 100%;
    height: fit-content;
  }

  .cm-line {
    padding-right: 16px;
  }

  ${(e) => ET(e.$enableClickCompName)}
`;
var kC = de.div`
  height: 100%;
`;
function QC(e) {
  return !e.disableCard && (e.codeType !== "Function" || e.hasError);
}
function dT(e) {
  var c, f;
  const {
    editor: t,
    children: r,
    disabled: i,
    cardStyle: n,
    onClick: a,
    ...s
  } = e, {
    view: o,
    isFocus: l
  } = wC(s, t);
  return N(kC, {
    onClick: a ? (p) => o && a(p, o) : void 0,
    children: [!i && o && ((c = e.widgetPopup) == null ? void 0 : c.call(e, o)), r, d(TS, {
      cardStyle: n,
      editorFocus: !i && l && QC(e),
      title: e.cardTitle,
      content: e.cardContent,
      richContent: (f = e.cardRichContent) == null ? void 0 : f.call(e, e.cardContent ?? ""),
      tips: e.cardTips,
      hasError: e.hasError
    })]
  });
}
function GC(e) {
  const t = (0, import_react.useRef)();
  return d(dT, {
    ...e,
    editor: t,
    cardStyle: {
      borderRadius: "8px"
    },
    children: d(MC, {
      $styleName: e.styleName,
      ref: t,
      $enableClickCompName: e.enableClickCompName
    })
  });
}
function VC(e) {
  const t = (0, import_react.useRef)(), {
    expandable: r = true,
    ...i
  } = e, [n, a] = (0, import_react.useState)(false);
  return d(Dc, {
    children: d(dT, {
      ...i,
      editor: t,
      disabled: n,
      children: d(BC, {
        $styleName: e.styleName,
        $bordered: e.bordered,
        disabled: n,
        $error: e.hasError,
        ref: t,
        $enableClickCompName: e.enableClickCompName,
        children: r && d(DC, {
          breadcrumb: [e.label ?? ""],
          editor: d(GC, {
            ...e,
            styleName: "window",
            showLineNum: true
          }),
          onVisibleChange: (s) => a(s)
        })
      })
    })
  });
}
var BC = de.div`
  position: relative;
  height: 100%;

  &:hover {
    .code-editor-panel-open-button {
      display: block;
    }
  }

  .cm-editor:hover {
    border: 1px solid ${(e) => e.$error ? "#f73131" : "#8B8FA3"};
  }

  .cm-editor.cm-focused {
    border: 1px solid ${(e) => e.$error ? "#f73131" : "#3377ff"};
    box-shadow: 0 0 0 2px ${(e) => e.$error ? "#feeaea" : "#d6e4ff"};
  }

  .cm-editor {
    border: 1px solid ${(e) => e.$error ? "#f73131" : "#d7d9e0"};
    border-radius: ${(e) => e.$bordered ? "4px" : ""};
  }

  .cm-line {
    padding-right: 8px;
  }

  .cm-editor {
    min-height: ${(e) => Yn(e.$styleName).minHeight};
  }
  .cm-content,
  .cm-gutter {
    min-height: ${(e) => Yn(e.$styleName).minHeight};
    min-height: calc(${(e) => Yn(e.$styleName).minHeight} - 2px);
  }

  .cm-editor {
    overflow: hidden;
    max-height: ${(e) => Yn(e.$styleName).maxHeight};
  }

  ${(e) => {
  if (e.disabled)
    return T2`
        pointer-events: none;

        .cm-editor {
          background-color: #f5f5f6;
          color: #b8b9bf;
        }
      `;
}}
  ${(e) => ET(e.$enableClickCompName)}
`;
var zC = Object.freeze(Object.defineProperty({
  __proto__: null,
  CodeEditor: VC,
  CodeEditorTooltipContainer: Dc
}, Symbol.toStringTag, { value: "Module" }));

export {
  Jb,
  zC
};
//# sourceMappingURL=chunk-6C7C6SYL.js.map
