import {
  g
} from "./chunk-7D6HIZFR.js";
import {
  A$e,
  Be,
  Ct,
  Da,
  Fa,
  J1,
  Jh,
  N,
  Ot,
  Pa,
  Q9,
  Ree,
  St,
  U4,
  _,
  a2,
  b3,
  bv,
  c1,
  cS,
  d,
  d1e,
  de,
  g4,
  h1,
  h2e,
  h4,
  j4,
  lH,
  nY,
  p1,
  qd,
  sn,
  v1,
  w6e,
  y3,
  zG1,
  zr
} from "./chunk-2ZELARZW.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/6c369ea4.js
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
function re(t) {
  for (var n = 1; n < arguments.length; n++) {
    var r = arguments[n] != null ? Object(arguments[n]) : {}, o = Object.keys(r);
    typeof Object.getOwnPropertySymbols == "function" && o.push.apply(o, Object.getOwnPropertySymbols(r).filter(function(l) {
      return Object.getOwnPropertyDescriptor(r, l).enumerable;
    })), o.forEach(function(l) {
      Be(t, l, r[l]);
    });
  }
  return t;
}
var ht = function(t, n, r, o, l, s, d2, e) {
  if (n === void 0)
    throw new Error("invariant requires an error message argument");
  if (!t) {
    var f;
    if (n === void 0)
      f = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var i = [r, o, l, s, d2, e], c = 0;
      f = new Error(
        n.replace(/%s/g, function() {
          return i[c++];
        })
      ), f.name = "Invariant Violation";
    }
    throw f.framesToPop = 1, f;
  }
};
var ft = ht;
var F = sn(ft);
var pt = function() {
  function t() {
    Da(this, t), Be(this, "refs", {});
  }
  return Pa(t, [{
    key: "add",
    value: function(r, o) {
      this.refs[r] || (this.refs[r] = []), this.refs[r].push(o);
    }
  }, {
    key: "remove",
    value: function(r, o) {
      var l = this.getIndex(r, o);
      l !== -1 && this.refs[r].splice(l, 1);
    }
  }, {
    key: "isActive",
    value: function() {
      return this.active;
    }
  }, {
    key: "getActive",
    value: function() {
      var r = this;
      return this.refs[this.active.collection].find(function(o) {
        var l = o.node;
        return l.sortableInfo.index == r.active.index;
      });
    }
  }, {
    key: "getIndex",
    value: function(r, o) {
      return this.refs[r].indexOf(o);
    }
  }, {
    key: "getOrderedRefs",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.active.collection;
      return this.refs[r].sort(mt);
    }
  }]), t;
}();
function mt(t, n) {
  var r = t.node.sortableInfo.index, o = n.node.sortableInfo.index;
  return r - o;
}
function gt(t, n, r) {
  return typeof console < "u" && console.warn("Deprecation warning: arrayMove will no longer be exported by 'react-sortable-hoc' in the next major release. Please install the `array-move` package locally instead. https://www.npmjs.com/package/array-move"), t = t.slice(), t.splice(r < 0 ? t.length + r : r, 0, t.splice(n, 1)[0]), t;
}
function Re(t, n) {
  return Object.keys(t).reduce(function(r, o) {
    return n.indexOf(o) === -1 && (r[o] = t[o]), r;
  }, {});
}
var G = {
  end: ["touchend", "touchcancel", "mouseup"],
  move: ["touchmove", "mousemove"],
  start: ["touchstart", "mousedown"]
};
var Ne = function() {
  if (typeof window > "u" || typeof document > "u")
    return "";
  var t = window.getComputedStyle(document.documentElement, "") || ["-moz-hidden-iframe"], n = (Array.prototype.slice.call(t).join("").match(/-(moz|webkit|ms)-/) || t.OLink === "" && ["", "o"])[1];
  switch (n) {
    case "ms":
      return "ms";
    default:
      return n && n.length ? n[0].toUpperCase() + n.substr(1) : "";
  }
}();
function Z(t, n) {
  Object.keys(n).forEach(function(r) {
    t.style[r] = n[r];
  });
}
function _2(t, n) {
  t.style["".concat(Ne, "Transform")] = n == null ? "" : "translate3d(".concat(n.x, "px,").concat(n.y, "px,0)");
}
function ie(t, n) {
  t.style["".concat(Ne, "TransitionDuration")] = n == null ? "" : "".concat(n, "ms");
}
function X(t, n) {
  for (; t; ) {
    if (n(t))
      return t;
    t = t.parentNode;
  }
  return null;
}
function we(t, n, r) {
  return Math.max(t, Math.min(r, n));
}
function j(t) {
  return t.substr(-2) === "px" ? parseFloat(t) : 0;
}
function vt(t) {
  var n = window.getComputedStyle(t);
  return {
    bottom: j(n.marginBottom),
    left: j(n.marginLeft),
    right: j(n.marginRight),
    top: j(n.marginTop)
  };
}
function ve(t, n) {
  var r = n.displayName || n.name;
  return r ? "".concat(t, "(").concat(r, ")") : t;
}
function oe(t, n) {
  var r = t.getBoundingClientRect();
  return {
    top: r.top + n.top,
    left: r.left + n.left
  };
}
function V(t) {
  return t.touches && t.touches.length ? {
    x: t.touches[0].pageX,
    y: t.touches[0].pageY
  } : t.changedTouches && t.changedTouches.length ? {
    x: t.changedTouches[0].pageX,
    y: t.changedTouches[0].pageY
  } : {
    x: t.pageX,
    y: t.pageY
  };
}
function xt(t) {
  return t.touches && t.touches.length || t.changedTouches && t.changedTouches.length;
}
function ee(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    left: 0,
    top: 0
  };
  if (t) {
    var o = {
      left: r.left + t.offsetLeft,
      top: r.top + t.offsetTop
    };
    return t.parentNode === n ? o : ee(t.parentNode, n, o);
  }
}
function yt(t, n, r) {
  return t < r && t > n ? t - 1 : t > r && t < n ? t + 1 : t;
}
function Ce(t) {
  var n = t.lockOffset, r = t.width, o = t.height, l = n, s = n, d2 = "px";
  if (typeof n == "string") {
    var e = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(n);
    F(e !== null, 'lockOffset value should be a number or a string of a number followed by "px" or "%". Given %s', n), l = parseFloat(n), s = parseFloat(n), d2 = e[1];
  }
  return F(isFinite(l) && isFinite(s), "lockOffset value should be a finite. Given %s", n), d2 === "%" && (l = l * r / 100, s = s * o / 100), {
    x: l,
    y: s
  };
}
function bt(t) {
  var n = t.height, r = t.width, o = t.lockOffset, l = Array.isArray(o) ? o : [o, o];
  F(l.length === 2, "lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given %s", o);
  var s = c1(l, 2), d2 = s[0], e = s[1];
  return [Ce({
    height: n,
    lockOffset: d2,
    width: r
  }), Ce({
    height: n,
    lockOffset: e,
    width: r
  })];
}
function wt(t) {
  var n = window.getComputedStyle(t), r = /(auto|scroll)/, o = ["overflow", "overflowX", "overflowY"];
  return o.find(function(l) {
    return r.test(n[l]);
  });
}
function Ae(t) {
  return t instanceof HTMLElement ? wt(t) ? t : Ae(t.parentNode) : null;
}
function Ct2(t) {
  var n = window.getComputedStyle(t);
  return n.display === "grid" ? {
    x: j(n.gridColumnGap),
    y: j(n.gridRowGap)
  } : {
    x: 0,
    y: 0
  };
}
var B = {
  TAB: 9,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
var H = {
  Anchor: "A",
  Button: "BUTTON",
  Canvas: "CANVAS",
  Input: "INPUT",
  Option: "OPTION",
  Textarea: "TEXTAREA",
  Select: "SELECT"
};
function St2(t) {
  var n = "input, textarea, select, canvas, [contenteditable]", r = t.querySelectorAll(n), o = t.cloneNode(true), l = Ot(o.querySelectorAll(n));
  return l.forEach(function(s, d2) {
    if (s.type !== "file" && (s.value = r[d2].value), s.type === "radio" && s.name && (s.name = "__sortableClone__".concat(s.name)), s.tagName === H.Canvas && r[d2].width > 0 && r[d2].height > 0) {
      var e = s.getContext("2d");
      e.drawImage(r[d2], 0, 0);
    }
  }), o;
}
function Tt(t) {
  var n, r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    withRef: false
  };
  return r = n = function(l) {
    g4(s, l);
    function s() {
      var d2, e;
      Da(this, s);
      for (var f = arguments.length, i = new Array(f), c = 0; c < f; c++)
        i[c] = arguments[c];
      return e = nY(this, (d2 = bv(s)).call.apply(d2, [this].concat(i))), Be(J1(J1(e)), "wrappedInstance", (0, import_react.createRef)()), e;
    }
    return Pa(s, [{
      key: "componentDidMount",
      value: function() {
        var e = (0, import_react_dom.findDOMNode)(this);
        e.sortableHandle = true;
      }
    }, {
      key: "getWrappedInstance",
      value: function() {
        return F(o.withRef, "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call"), this.wrappedInstance.current;
      }
    }, {
      key: "render",
      value: function() {
        var e = o.withRef ? this.wrappedInstance : null;
        return (0, import_react.createElement)(t, y3({
          ref: e
        }, this.props));
      }
    }]), s;
  }(import_react.Component), Be(n, "displayName", ve("sortableHandle", t)), r;
}
function Se(t) {
  return t.sortableHandle != null;
}
var It = function() {
  function t(n, r) {
    Da(this, t), this.container = n, this.onScrollCallback = r;
  }
  return Pa(t, [{
    key: "clear",
    value: function() {
      this.interval != null && (clearInterval(this.interval), this.interval = null);
    }
  }, {
    key: "update",
    value: function(r) {
      var o = this, l = r.translate, s = r.minTranslate, d2 = r.maxTranslate, e = r.width, f = r.height, i = {
        x: 0,
        y: 0
      }, c = {
        x: 1,
        y: 1
      }, h = {
        x: 10,
        y: 10
      }, u = this.container, a = u.scrollTop, g2 = u.scrollLeft, x = u.scrollHeight, R = u.scrollWidth, C = u.clientHeight, E = u.clientWidth, T = a === 0, y = x - a - C === 0, S = g2 === 0, N2 = R - g2 - E === 0;
      l.y >= d2.y - f / 2 && !y ? (i.y = 1, c.y = h.y * Math.abs((d2.y - f / 2 - l.y) / f)) : l.x >= d2.x - e / 2 && !N2 ? (i.x = 1, c.x = h.x * Math.abs((d2.x - e / 2 - l.x) / e)) : l.y <= s.y + f / 2 && !T ? (i.y = -1, c.y = h.y * Math.abs((l.y - f / 2 - s.y) / f)) : l.x <= s.x + e / 2 && !S && (i.x = -1, c.x = h.x * Math.abs((l.x - e / 2 - s.x) / e)), this.interval && (this.clear(), this.isAutoScrolling = false), (i.x !== 0 || i.y !== 0) && (this.interval = setInterval(function() {
        o.isAutoScrolling = true;
        var b = {
          left: c.x * i.x,
          top: c.y * i.y
        };
        o.container.scrollTop += b.top, o.container.scrollLeft += b.left, o.onScrollCallback(b);
      }, 5));
    }
  }]), t;
}();
function Et(t) {
  var n = t.node;
  return {
    height: n.offsetHeight,
    width: n.offsetWidth
  };
}
function kt(t) {
  var n = [H.Input, H.Textarea, H.Select, H.Option, H.Button];
  return !!(n.indexOf(t.target.tagName) !== -1 || X(t.target, function(r) {
    return r.contentEditable === "true";
  }));
}
var We = {
  axis: v1.oneOf(["x", "y", "xy"]),
  contentWindow: v1.any,
  disableAutoscroll: v1.bool,
  distance: v1.number,
  getContainer: v1.func,
  getHelperDimensions: v1.func,
  helperClass: v1.string,
  helperContainer: v1.oneOfType([v1.func, typeof HTMLElement > "u" ? v1.any : v1.instanceOf(HTMLElement)]),
  hideSortableGhost: v1.bool,
  keyboardSortingTransitionDuration: v1.number,
  lockAxis: v1.string,
  lockOffset: v1.oneOfType([v1.number, v1.string, v1.arrayOf(v1.oneOfType([v1.number, v1.string]))]),
  lockToContainerEdges: v1.bool,
  onSortEnd: v1.func,
  onSortMove: v1.func,
  onSortOver: v1.func,
  onSortStart: v1.func,
  pressDelay: v1.number,
  pressThreshold: v1.number,
  keyCodes: v1.shape({
    lift: v1.arrayOf(v1.number),
    drop: v1.arrayOf(v1.number),
    cancel: v1.arrayOf(v1.number),
    up: v1.arrayOf(v1.number),
    down: v1.arrayOf(v1.number)
  }),
  shouldCancelStart: v1.func,
  transitionDuration: v1.number,
  updateBeforeSortStart: v1.func,
  useDragHandle: v1.bool,
  useWindowAsScrollContainer: v1.bool
};
var Pe = {
  lift: [B.SPACE],
  drop: [B.SPACE],
  cancel: [B.ESC],
  up: [B.UP, B.LEFT],
  down: [B.DOWN, B.RIGHT]
};
var Ot2 = {
  axis: "y",
  disableAutoscroll: false,
  distance: 0,
  getHelperDimensions: Et,
  hideSortableGhost: true,
  lockOffset: "50%",
  lockToContainerEdges: false,
  pressDelay: 0,
  pressThreshold: 5,
  keyCodes: Pe,
  shouldCancelStart: kt,
  transitionDuration: 300,
  useWindowAsScrollContainer: false
};
var Dt = Object.keys(We);
function Rt(t) {
  F(!(t.distance && t.pressDelay), "Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.");
}
function Nt(t, n) {
  try {
    var r = t();
  } catch (o) {
    return n(true, o);
  }
  return r && r.then ? r.then(n.bind(null, false), n.bind(null, true)) : n(false, value);
}
var Me = (0, import_react.createContext)({
  manager: {}
});
function At(t) {
  var n, r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    withRef: false
  };
  return r = n = function(l) {
    g4(s, l);
    function s(d2) {
      var e;
      Da(this, s), e = nY(this, bv(s).call(this, d2)), Be(J1(J1(e)), "state", {}), Be(J1(J1(e)), "handleStart", function(i) {
        var c = e.props, h = c.distance, u = c.shouldCancelStart;
        if (!(i.button === 2 || u(i))) {
          e.touched = true, e.position = V(i);
          var a = X(i.target, function(T) {
            return T.sortableInfo != null;
          });
          if (a && a.sortableInfo && e.nodeIsChild(a) && !e.state.sorting) {
            var g2 = e.props.useDragHandle, x = a.sortableInfo, R = x.index, C = x.collection, E = x.disabled;
            if (E || g2 && !X(i.target, Se))
              return;
            e.manager.active = {
              collection: C,
              index: R
            }, !xt(i) && i.target.tagName === H.Anchor && i.preventDefault(), h || (e.props.pressDelay === 0 ? e.handlePress(i) : e.pressTimer = setTimeout(function() {
              return e.handlePress(i);
            }, e.props.pressDelay));
          }
        }
      }), Be(J1(J1(e)), "nodeIsChild", function(i) {
        return i.sortableInfo.manager === e.manager;
      }), Be(J1(J1(e)), "handleMove", function(i) {
        var c = e.props, h = c.distance, u = c.pressThreshold;
        if (!e.state.sorting && e.touched && !e._awaitingUpdateBeforeSortStart) {
          var a = V(i), g2 = {
            x: e.position.x - a.x,
            y: e.position.y - a.y
          }, x = Math.abs(g2.x) + Math.abs(g2.y);
          e.delta = g2, !h && (!u || x >= u) ? (clearTimeout(e.cancelTimer), e.cancelTimer = setTimeout(e.cancel, 0)) : h && x >= h && e.manager.isActive() && e.handlePress(i);
        }
      }), Be(J1(J1(e)), "handleEnd", function() {
        e.touched = false, e.cancel();
      }), Be(J1(J1(e)), "cancel", function() {
        var i = e.props.distance, c = e.state.sorting;
        c || (i || clearTimeout(e.pressTimer), e.manager.active = null);
      }), Be(J1(J1(e)), "handlePress", function(i) {
        try {
          var c = e.manager.getActive(), h = function() {
            if (c) {
              var u = function() {
                var k = S.sortableInfo.index, I = vt(S), W = Ct2(e.container), P = e.scrollContainer.getBoundingClientRect(), $ = x({
                  index: k,
                  node: S,
                  collection: N2
                });
                if (e.node = S, e.margin = I, e.gridGap = W, e.width = $.width, e.height = $.height, e.marginOffset = {
                  x: e.margin.left + e.margin.right + e.gridGap.x,
                  y: Math.max(e.margin.top, e.margin.bottom, e.gridGap.y)
                }, e.boundingClientRect = S.getBoundingClientRect(), e.containerBoundingRect = P, e.index = k, e.newIndex = k, e.axis = {
                  x: g2.indexOf("x") >= 0,
                  y: g2.indexOf("y") >= 0
                }, e.offsetEdge = ee(S, e.container), b ? e.initialOffset = V(re({}, i, {
                  pageX: e.boundingClientRect.left,
                  pageY: e.boundingClientRect.top
                })) : e.initialOffset = V(i), e.initialScroll = {
                  left: e.scrollContainer.scrollLeft,
                  top: e.scrollContainer.scrollTop
                }, e.initialWindowScroll = {
                  left: window.pageXOffset,
                  top: window.pageYOffset
                }, e.helper = e.helperContainer.appendChild(St2(S)), Z(e.helper, {
                  boxSizing: "border-box",
                  height: "".concat(e.height, "px"),
                  left: "".concat(e.boundingClientRect.left - I.left, "px"),
                  pointerEvents: "none",
                  position: "fixed",
                  top: "".concat(e.boundingClientRect.top - I.top, "px"),
                  width: "".concat(e.width, "px")
                }), b && e.helper.focus(), C && (e.sortableGhost = S, Z(S, {
                  opacity: 0,
                  visibility: "hidden"
                })), e.minTranslate = {}, e.maxTranslate = {}, b) {
                  var J = y ? {
                    top: 0,
                    left: 0,
                    width: e.contentWindow.innerWidth,
                    height: e.contentWindow.innerHeight
                  } : e.containerBoundingRect, xe = J.top, ye = J.left, $e = J.width, Ue = J.height, Ve = xe + Ue, ze = ye + $e;
                  e.axis.x && (e.minTranslate.x = ye - e.boundingClientRect.left, e.maxTranslate.x = ze - (e.boundingClientRect.left + e.width)), e.axis.y && (e.minTranslate.y = xe - e.boundingClientRect.top, e.maxTranslate.y = Ve - (e.boundingClientRect.top + e.height));
                } else
                  e.axis.x && (e.minTranslate.x = (y ? 0 : P.left) - e.boundingClientRect.left - e.width / 2, e.maxTranslate.x = (y ? e.contentWindow.innerWidth : P.left + P.width) - e.boundingClientRect.left - e.width / 2), e.axis.y && (e.minTranslate.y = (y ? 0 : P.top) - e.boundingClientRect.top - e.height / 2, e.maxTranslate.y = (y ? e.contentWindow.innerHeight : P.top + P.height) - e.boundingClientRect.top - e.height / 2);
                R && R.split(" ").forEach(function(U) {
                  return e.helper.classList.add(U);
                }), e.listenerNode = i.touches ? i.target : e.contentWindow, b ? (e.listenerNode.addEventListener("wheel", e.handleKeyEnd, true), e.listenerNode.addEventListener("mousedown", e.handleKeyEnd, true), e.listenerNode.addEventListener("keydown", e.handleKeyDown)) : (G.move.forEach(function(U) {
                  return e.listenerNode.addEventListener(U, e.handleSortMove, false);
                }), G.end.forEach(function(U) {
                  return e.listenerNode.addEventListener(U, e.handleSortEnd, false);
                })), e.setState({
                  sorting: true,
                  sortingIndex: k
                }), T && T({
                  node: S,
                  index: k,
                  collection: N2,
                  isKeySorting: b,
                  nodes: e.manager.getOrderedRefs(),
                  helper: e.helper
                }, i), b && e.keyMove(0);
              }, a = e.props, g2 = a.axis, x = a.getHelperDimensions, R = a.helperClass, C = a.hideSortableGhost, E = a.updateBeforeSortStart, T = a.onSortStart, y = a.useWindowAsScrollContainer, S = c.node, N2 = c.collection, b = e.manager.isKeySorting, A = function() {
                if (typeof E == "function") {
                  e._awaitingUpdateBeforeSortStart = true;
                  var L = Nt(function() {
                    var k = S.sortableInfo.index;
                    return Promise.resolve(E({
                      collection: N2,
                      index: k,
                      node: S,
                      isKeySorting: b
                    }, i)).then(function() {
                    });
                  }, function(k, I) {
                    if (e._awaitingUpdateBeforeSortStart = false, k)
                      throw I;
                    return I;
                  });
                  if (L && L.then)
                    return L.then(function() {
                    });
                }
              }();
              return A && A.then ? A.then(u) : u(A);
            }
          }();
          return Promise.resolve(h && h.then ? h.then(function() {
          }) : void 0);
        } catch (u) {
          return Promise.reject(u);
        }
      }), Be(J1(J1(e)), "handleSortMove", function(i) {
        var c = e.props.onSortMove;
        typeof i.preventDefault == "function" && i.cancelable && i.preventDefault(), e.updateHelperPosition(i), e.animateNodes(), e.autoscroll(), c && c(i);
      }), Be(J1(J1(e)), "handleSortEnd", function(i) {
        var c = e.props, h = c.hideSortableGhost, u = c.onSortEnd, a = e.manager, g2 = a.active.collection, x = a.isKeySorting, R = e.manager.getOrderedRefs();
        e.listenerNode && (x ? (e.listenerNode.removeEventListener("wheel", e.handleKeyEnd, true), e.listenerNode.removeEventListener("mousedown", e.handleKeyEnd, true), e.listenerNode.removeEventListener("keydown", e.handleKeyDown)) : (G.move.forEach(function(S) {
          return e.listenerNode.removeEventListener(S, e.handleSortMove);
        }), G.end.forEach(function(S) {
          return e.listenerNode.removeEventListener(S, e.handleSortEnd);
        }))), e.helper.parentNode.removeChild(e.helper), h && e.sortableGhost && Z(e.sortableGhost, {
          opacity: "",
          visibility: ""
        });
        for (var C = 0, E = R.length; C < E; C++) {
          var T = R[C], y = T.node;
          T.edgeOffset = null, T.boundingClientRect = null, _2(y, null), ie(y, null), T.translate = null;
        }
        e.autoScroller.clear(), e.manager.active = null, e.manager.isKeySorting = false, e.setState({
          sorting: false,
          sortingIndex: null
        }), typeof u == "function" && u({
          collection: g2,
          newIndex: e.newIndex,
          oldIndex: e.index,
          isKeySorting: x,
          nodes: R
        }, i), e.touched = false;
      }), Be(J1(J1(e)), "autoscroll", function() {
        var i = e.props.disableAutoscroll, c = e.manager.isKeySorting;
        if (i) {
          e.autoScroller.clear();
          return;
        }
        if (c) {
          var h = re({}, e.translate), u = 0, a = 0;
          e.axis.x && (h.x = Math.min(e.maxTranslate.x, Math.max(e.minTranslate.x, e.translate.x)), u = e.translate.x - h.x), e.axis.y && (h.y = Math.min(e.maxTranslate.y, Math.max(e.minTranslate.y, e.translate.y)), a = e.translate.y - h.y), e.translate = h, _2(e.helper, e.translate), e.scrollContainer.scrollLeft += u, e.scrollContainer.scrollTop += a;
          return;
        }
        e.autoScroller.update({
          height: e.height,
          maxTranslate: e.maxTranslate,
          minTranslate: e.minTranslate,
          translate: e.translate,
          width: e.width
        });
      }), Be(J1(J1(e)), "onAutoScroll", function(i) {
        e.translate.x += i.left, e.translate.y += i.top, e.animateNodes();
      }), Be(J1(J1(e)), "handleKeyDown", function(i) {
        var c = i.keyCode, h = e.props, u = h.shouldCancelStart, a = h.keyCodes, g2 = a === void 0 ? {} : a, x = re({}, Pe, g2);
        e.manager.active && !e.manager.isKeySorting || !e.manager.active && (!x.lift.includes(c) || u(i) || !e.isValidSortingTarget(i)) || (i.stopPropagation(), i.preventDefault(), x.lift.includes(c) && !e.manager.active ? e.keyLift(i) : x.drop.includes(c) && e.manager.active ? e.keyDrop(i) : x.cancel.includes(c) ? (e.newIndex = e.manager.active.index, e.keyDrop(i)) : x.up.includes(c) ? e.keyMove(-1) : x.down.includes(c) && e.keyMove(1));
      }), Be(J1(J1(e)), "keyLift", function(i) {
        var c = i.target, h = X(c, function(x) {
          return x.sortableInfo != null;
        }), u = h.sortableInfo, a = u.index, g2 = u.collection;
        e.initialFocusedNode = c, e.manager.isKeySorting = true, e.manager.active = {
          index: a,
          collection: g2
        }, e.handlePress(i);
      }), Be(J1(J1(e)), "keyMove", function(i) {
        var c = e.manager.getOrderedRefs(), h = c[c.length - 1].node.sortableInfo.index, u = e.newIndex + i, a = e.newIndex;
        if (!(u < 0 || u > h)) {
          e.prevIndex = a, e.newIndex = u;
          var g2 = yt(e.newIndex, e.prevIndex, e.index), x = c.find(function(b) {
            var A = b.node;
            return A.sortableInfo.index === g2;
          }), R = x.node, C = e.containerScrollDelta, E = x.boundingClientRect || oe(R, C), T = x.translate || {
            x: 0,
            y: 0
          }, y = {
            top: E.top + T.y - C.top,
            left: E.left + T.x - C.left
          }, S = a < u, N2 = {
            x: S && e.axis.x ? R.offsetWidth - e.width : 0,
            y: S && e.axis.y ? R.offsetHeight - e.height : 0
          };
          e.handleSortMove({
            pageX: y.left + N2.x,
            pageY: y.top + N2.y,
            ignoreTransition: i === 0
          });
        }
      }), Be(J1(J1(e)), "keyDrop", function(i) {
        e.handleSortEnd(i), e.initialFocusedNode && e.initialFocusedNode.focus();
      }), Be(J1(J1(e)), "handleKeyEnd", function(i) {
        e.manager.active && e.keyDrop(i);
      }), Be(J1(J1(e)), "isValidSortingTarget", function(i) {
        var c = e.props.useDragHandle, h = i.target, u = X(h, function(a) {
          return a.sortableInfo != null;
        });
        return u && u.sortableInfo && !u.sortableInfo.disabled && (c ? Se(h) : h.sortableInfo);
      });
      var f = new pt();
      return Rt(d2), e.manager = f, e.wrappedInstance = (0, import_react.createRef)(), e.sortableContextValue = {
        manager: f
      }, e.events = {
        end: e.handleEnd,
        move: e.handleMove,
        start: e.handleStart
      }, e;
    }
    return Pa(s, [{
      key: "componentDidMount",
      value: function() {
        var e = this, f = this.props.useWindowAsScrollContainer, i = this.getContainer();
        Promise.resolve(i).then(function(c) {
          e.container = c, e.document = e.container.ownerDocument || document;
          var h = e.props.contentWindow || e.document.defaultView || window;
          e.contentWindow = typeof h == "function" ? h() : h, e.scrollContainer = f ? e.document.scrollingElement || e.document.documentElement : Ae(e.container) || e.container, e.autoScroller = new It(e.scrollContainer, e.onAutoScroll), Object.keys(e.events).forEach(function(u) {
            return G[u].forEach(function(a) {
              return e.container.addEventListener(a, e.events[u], false);
            });
          }), e.container.addEventListener("keydown", e.handleKeyDown);
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        var e = this;
        this.helper && this.helper.parentNode && this.helper.parentNode.removeChild(this.helper), this.container && (Object.keys(this.events).forEach(function(f) {
          return G[f].forEach(function(i) {
            return e.container.removeEventListener(i, e.events[f]);
          });
        }), this.container.removeEventListener("keydown", this.handleKeyDown));
      }
    }, {
      key: "updateHelperPosition",
      value: function(e) {
        var f = this.props, i = f.lockAxis, c = f.lockOffset, h = f.lockToContainerEdges, u = f.transitionDuration, a = f.keyboardSortingTransitionDuration, g2 = a === void 0 ? u : a, x = this.manager.isKeySorting, R = e.ignoreTransition, C = V(e), E = {
          x: C.x - this.initialOffset.x,
          y: C.y - this.initialOffset.y
        };
        if (E.y -= window.pageYOffset - this.initialWindowScroll.top, E.x -= window.pageXOffset - this.initialWindowScroll.left, this.translate = E, h) {
          var T = bt({
            height: this.height,
            lockOffset: c,
            width: this.width
          }), y = c1(T, 2), S = y[0], N2 = y[1], b = {
            x: this.width / 2 - S.x,
            y: this.height / 2 - S.y
          }, A = {
            x: this.width / 2 - N2.x,
            y: this.height / 2 - N2.y
          };
          E.x = we(this.minTranslate.x + b.x, this.maxTranslate.x - A.x, E.x), E.y = we(this.minTranslate.y + b.y, this.maxTranslate.y - A.y, E.y);
        }
        i === "x" ? E.y = 0 : i === "y" && (E.x = 0), x && g2 && !R && ie(this.helper, g2), _2(this.helper, E);
      }
    }, {
      key: "animateNodes",
      value: function() {
        var e = this.props, f = e.transitionDuration, i = e.hideSortableGhost, c = e.onSortOver, h = this.containerScrollDelta, u = this.windowScrollDelta, a = this.manager.getOrderedRefs(), g2 = {
          left: this.offsetEdge.left + this.translate.x + h.left,
          top: this.offsetEdge.top + this.translate.y + h.top
        }, x = this.manager.isKeySorting, R = this.newIndex;
        this.newIndex = null;
        for (var C = 0, E = a.length; C < E; C++) {
          var T = a[C].node, y = T.sortableInfo.index, S = T.offsetWidth, N2 = T.offsetHeight, b = {
            height: this.height > N2 ? N2 / 2 : this.height / 2,
            width: this.width > S ? S / 2 : this.width / 2
          }, A = x && y > this.index && y <= R, L = x && y < this.index && y >= R, k = {
            x: 0,
            y: 0
          }, I = a[C].edgeOffset;
          I || (I = ee(T, this.container), a[C].edgeOffset = I, x && (a[C].boundingClientRect = oe(T, h)));
          var W = C < a.length - 1 && a[C + 1], P = C > 0 && a[C - 1];
          if (W && !W.edgeOffset && (W.edgeOffset = ee(W.node, this.container), x && (W.boundingClientRect = oe(W.node, h))), y === this.index) {
            i && (this.sortableGhost = T, Z(T, {
              opacity: 0,
              visibility: "hidden"
            }));
            continue;
          }
          f && ie(T, f), this.axis.x ? this.axis.y ? L || y < this.index && (g2.left + u.left - b.width <= I.left && g2.top + u.top <= I.top + b.height || g2.top + u.top + b.height <= I.top) ? (k.x = this.width + this.marginOffset.x, I.left + k.x > this.containerBoundingRect.width - b.width && W && (k.x = W.edgeOffset.left - I.left, k.y = W.edgeOffset.top - I.top), this.newIndex === null && (this.newIndex = y)) : (A || y > this.index && (g2.left + u.left + b.width >= I.left && g2.top + u.top + b.height >= I.top || g2.top + u.top + b.height >= I.top + N2)) && (k.x = -(this.width + this.marginOffset.x), I.left + k.x < this.containerBoundingRect.left + b.width && P && (k.x = P.edgeOffset.left - I.left, k.y = P.edgeOffset.top - I.top), this.newIndex = y) : A || y > this.index && g2.left + u.left + b.width >= I.left ? (k.x = -(this.width + this.marginOffset.x), this.newIndex = y) : (L || y < this.index && g2.left + u.left <= I.left + b.width) && (k.x = this.width + this.marginOffset.x, this.newIndex == null && (this.newIndex = y)) : this.axis.y && (A || y > this.index && g2.top + u.top + b.height >= I.top ? (k.y = -(this.height + this.marginOffset.y), this.newIndex = y) : (L || y < this.index && g2.top + u.top <= I.top + b.height) && (k.y = this.height + this.marginOffset.y, this.newIndex == null && (this.newIndex = y))), _2(T, k), a[C].translate = k;
        }
        this.newIndex == null && (this.newIndex = this.index), x && (this.newIndex = R);
        var $ = x ? this.prevIndex : R;
        c && this.newIndex !== $ && c({
          collection: this.manager.active.collection,
          index: this.index,
          newIndex: this.newIndex,
          oldIndex: $,
          isKeySorting: x,
          nodes: a,
          helper: this.helper
        });
      }
    }, {
      key: "getWrappedInstance",
      value: function() {
        return F(o.withRef, "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call"), this.wrappedInstance.current;
      }
    }, {
      key: "getContainer",
      value: function() {
        var e = this.props.getContainer;
        return typeof e != "function" ? (0, import_react_dom.findDOMNode)(this) : e(o.withRef ? this.getWrappedInstance() : void 0);
      }
    }, {
      key: "render",
      value: function() {
        var e = o.withRef ? this.wrappedInstance : null;
        return (0, import_react.createElement)(Me.Provider, {
          value: this.sortableContextValue
        }, (0, import_react.createElement)(t, y3({
          ref: e
        }, Re(this.props, Dt))));
      }
    }, {
      key: "helperContainer",
      get: function() {
        var e = this.props.helperContainer;
        return typeof e == "function" ? e() : this.props.helperContainer || this.document.body;
      }
    }, {
      key: "containerScrollDelta",
      get: function() {
        var e = this.props.useWindowAsScrollContainer;
        return e ? {
          left: 0,
          top: 0
        } : {
          left: this.scrollContainer.scrollLeft - this.initialScroll.left,
          top: this.scrollContainer.scrollTop - this.initialScroll.top
        };
      }
    }, {
      key: "windowScrollDelta",
      get: function() {
        return {
          left: this.contentWindow.pageXOffset - this.initialWindowScroll.left,
          top: this.contentWindow.pageYOffset - this.initialWindowScroll.top
        };
      }
    }]), s;
  }(import_react.Component), Be(n, "displayName", ve("sortableList", t)), Be(n, "defaultProps", Ot2), Be(n, "propTypes", We), r;
}
var Le = {
  index: v1.number.isRequired,
  collection: v1.oneOfType([v1.number, v1.string]),
  disabled: v1.bool
};
var Wt = Object.keys(Le);
function Pt(t) {
  var n, r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    withRef: false
  };
  return r = n = function(l) {
    g4(s, l);
    function s() {
      var d2, e;
      Da(this, s);
      for (var f = arguments.length, i = new Array(f), c = 0; c < f; c++)
        i[c] = arguments[c];
      return e = nY(this, (d2 = bv(s)).call.apply(d2, [this].concat(i))), Be(J1(J1(e)), "wrappedInstance", (0, import_react.createRef)()), e;
    }
    return Pa(s, [{
      key: "componentDidMount",
      value: function() {
        this.register();
      }
    }, {
      key: "componentDidUpdate",
      value: function(e) {
        this.node && (e.index !== this.props.index && (this.node.sortableInfo.index = this.props.index), e.disabled !== this.props.disabled && (this.node.sortableInfo.disabled = this.props.disabled)), e.collection !== this.props.collection && (this.unregister(e.collection), this.register());
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.unregister();
      }
    }, {
      key: "register",
      value: function() {
        var e = this.props, f = e.collection, i = e.disabled, c = e.index, h = (0, import_react_dom.findDOMNode)(this);
        h.sortableInfo = {
          collection: f,
          disabled: i,
          index: c,
          manager: this.context.manager
        }, this.node = h, this.ref = {
          node: h
        }, this.context.manager.add(f, this.ref);
      }
    }, {
      key: "unregister",
      value: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.collection;
        this.context.manager.remove(e, this.ref);
      }
    }, {
      key: "getWrappedInstance",
      value: function() {
        return F(o.withRef, "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call"), this.wrappedInstance.current;
      }
    }, {
      key: "render",
      value: function() {
        var e = o.withRef ? this.wrappedInstance : null;
        return (0, import_react.createElement)(t, y3({
          ref: e
        }, Re(this.props, Wt)));
      }
    }]), s;
  }(import_react.Component), Be(n, "displayName", ve("sortableElement", t)), Be(n, "contextType", Me), Be(n, "propTypes", Le), Be(n, "defaultProps", {
    collection: 0
  }), r;
}
var Mt = de.span`
  &:hover {
    cursor: pointer;
  }

  color: #4965f2;
`;
var Be2 = de.div`
  width: 100%;
  display: flex;
  align-items: center;
`;
var Lt = de.div`
  display: flex;
  align-items: center;
  padding-left: 16px;
  padding-right: 8px;
`;
var Bt = de.div`
  display: flex;
  align-items: center;
  padding-left: 16px;
  padding-right: 8px;
`;
var ce = de(j4)`
  .ant-select .ant-select-selector .ant-select-selection-item {
    padding-right: 20px;
  }
`;
var Te = de.label`
  ${Fa};
  user-select: text;
  margin-right: 8px;
  max-width: 100px;
  white-space: nowrap;
`;
var Ie = de.div`
  display: inline-block;
  width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
`;
var Ht = de.div`
  display: flex;
  width: 100%;
  align-items: center;
`;
var K = de(A$e)`
  margin: 0;
  line-height: 13px;
  width: 100%;

  .ant-form-item-explain {
    font-size: 12px;
  }

  .ant-form-item-control-input {
    min-height: auto;
  }
`;
var Ft = de.div`
  font-size: 13px;
  color: #b8b9bf;
  text-align: center;
  line-height: 13px;
  height: 276px;
  display: flex;
  align-items: center;
  justify-content: center;
`;
var Gt = de.div`
  display: flex;
  align-items: center;
  margin-top: 16px;
  width: 100%;
  height: 36px;
  background: #f5f5f6;
  font-weight: 500;
  font-size: 13px;
  color: #222222;
  line-height: 13px;
`;
var jt = de.div`
  overflow: auto;
  height: 263px;

  &::-webkit-scrollbar {
    width: 14px;
  }

  &::-webkit-scrollbar-thumb {
    border: 4px solid transparent;
    background-clip: content-box;
    border-radius: 9999px;
    background-color: rgba(139, 143, 163, 0.12);
  }
`;
var Kt = de.div`
  display: flex;
  align-items: center;
  width: 100%;
  height: 43px;
  z-index: 2000;
  vertical-align: middle;
  border-bottom: 1px solid #f0f0f0;
  background: ${(t) => t.disabled ? "#FAFAFA" : "#ffffff"};

  font-size: 13px;
  color: ${(t) => t.disabled ? "#B8B9BF" : "#333333"};
  line-height: 13px;
`;
var He = de.div`
  width: 176px;
  padding-left: ${(t) => t.$head ? "16px" : "10px"};
`;
var Fe = de.div`
  width: 128px;
  padding-left: 16px;
`;
var Ge = de.div`
  width: 104px;
  padding-left: ${(t) => t.$head ? "16px" : "10px"};
`;
var je = de.div`
  width: 126px;
  padding-left: 16px;
`;
var Ke = de.div`
  /* width: 52px; */
  padding-left: 16px;
`;
var $t = de(lH)`
  cursor: grab;
  width: 16px;
  height: 16px;
`;
var Ee = de.div`
  width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`;
var Ut = de.div`
  .taco-edit-text-wrapper {
    width: 94px;
    height: 24px;
    padding: 0 6px;
    margin: 0;
    border-radius: 4px;

    font-size: 13px;
    color: ${(t) => t.disabled ? "#B8B9BF" : "#333333"};
    line-height: 13px;

    &:hover {
      background-color: #f5f5f6;
    }
  }

  .taco-edit-text-body {
    height: auto;
  }

  .taco-edit-text-icon {
    margin: 0;
  }

  .taco-edit-text-input {
    width: 94px;
    height: 24px;
    padding: 0 6px;
    margin: 0;
    border-radius: 4px;

    font-size: 13px;
    color: #333333;
    line-height: 13px;
    background-color: #ffffff;
    border: 1px solid #315efb;

    &:focus {
      border-color: #315efb;
      box-shadow: 0 0 0 2px #d6e4ff;
    }
  }
`;
var Vt = de(K)`
  .ant-select {
    font-size: 13px;
    color: #333333;
    line-height: 13px;

    &:hover {
      color: #315efb;
    }
  }
`;
var zt = de(d1e)`
  .ant-checkbox-checked {
    .ant-checkbox-inner::after {
      border: 2px solid ${(t) => t.disabled ? "#B8B9BF" : "#4965f2"};
      border-top: 0;
      border-left: 0;
    }
  }
`;
function Xt(t, n) {
  const r = t.getCompSelection(n);
  if (!r) {
    St.error(_("formComp.compSelectionError"), t.type, n);
    return;
  }
  const o = [];
  if (r.comps.forEach((s) => {
    var e;
    const d2 = (e = Jh[s.type]) == null ? void 0 : e.name;
    if (!d2) {
      St.error(_("formComp.compTypeNameError"), s.type, n);
      return;
    }
    o.push({
      comp: s,
      compTypeName: d2
    });
  }), o.length === 0)
    return;
  let l = r.defaultCompType;
  return o.find(({
    comp: s
  }) => s.type === l) || (l = o[0].comp.type), {
    compItems: o,
    defaultCompType: l
  };
}
function Yt(t, n) {
  var l;
  const r = [], o = {};
  return (l = n == null ? void 0 : n.columns) == null || l.forEach(({
    name: s,
    type: d2,
    isAutogenerated: e
  }) => {
    if (t && s && d2) {
      const f = Xt(t, d2);
      f && (r.push({
        columnName: s,
        columnType: d2,
        compItems: f.compItems
      }), o[s] = {
        enabled: !e,
        label: s.split("_").map(h1.upperFirst).join(" "),
        compType: f.defaultCompType,
        required: true
      });
    }
  }), {
    initItems: r,
    initColumns: o
  };
}
function qt(t, n, r, o, l) {
  if (!t.dataSourceId || !n) {
    l(_("formComp.noDataSourceSelected"));
    return;
  }
  if (!t.tableName) {
    l(_("formComp.noTableSelected"));
    return;
  }
  if (!t.columns || Object.keys(t.columns).length === 0) {
    l(_("formComp.noColumn"));
    return;
  }
  const s = [];
  if (r.map(({
    columnName: d2,
    columnType: e,
    compItems: f
  }) => {
    var c;
    const i = (c = t.columns) == null ? void 0 : c[d2];
    if (i && i.enabled) {
      const h = f.find(({
        comp: u
      }) => u.type === i.compType);
      h && s.push({
        type: e,
        name: d2,
        comp: h.comp,
        label: i.label,
        required: !!i.required
      });
    }
  }), s.length === 0) {
    l(_("formComp.noColumnSelected"));
    return;
  }
  return o({
    dataSourceId: t.dataSourceId,
    dataSourceTypeConfig: n,
    tableName: t.tableName,
    columns: s
  }).then((d2) => l(d2));
}
function Jt(t, n, r, o) {
  t.validateFields().then((l) => qt(l, n, r, o, (s) => {
    s ? Ct.error(s) : Ct.success(_("formComp.success"));
  })).catch((l) => {
    Ct.error(JSON.stringify(l));
  });
}
var Qt = (t) => d(Ut, {
  disabled: t.disabled,
  children: d(cS, {
    text: t.value ?? "",
    onChange: (n) => {
      var r;
      n && ((r = t.onChange) == null || r.call(t, n));
    },
    onFinish: () => {
    },
    disabled: t.disabled
  })
});
var Zt = Tt(() => d($t, {}));
var _t = Pt((t) => {
  const {
    item: n,
    form: r
  } = t, {
    columnName: o,
    columnType: l,
    compItems: s
  } = n, d2 = !qd.useWatch(["columns", o, "enabled"], r);
  return N(Kt, {
    disabled: d2,
    children: [d(He, {
      children: N(Be2, {
        children: [d(Zt, {}), d(K, {
          name: ["columns", o, "enabled"],
          valuePropName: "checked",
          style: {
            width: "auto",
            marginLeft: "4px",
            marginRight: "8px"
          },
          children: d(d1e, {})
        }), d(Ee, {
          title: o,
          children: o
        })]
      })
    }), d(Fe, {
      children: d(Ee, {
        title: l,
        children: l
      })
    }), d(Ge, {
      children: d(K, {
        name: ["columns", o, "label"],
        children: d(Qt, {
          disabled: d2
        })
      })
    }), d(je, {
      children: d(Vt, {
        name: ["columns", o, "compType"],
        children: d(ce, {
          placeholder: _("formComp.selectCompType"),
          border: true,
          disabled: d2,
          children: s.map(({
            comp: e,
            compTypeName: f
          }) => d(h4.Option, {
            value: e.type,
            children: f
          }, e.type))
        })
      })
    }), d(Ke, {
      children: d(K, {
        name: ["columns", o, "required"],
        valuePropName: "checked",
        children: d(zt, {
          disabled: d2
        })
      })
    })]
  });
});
var en = At((t) => d(jt, {
  children: t.items.map((n, r) => d(_t, {
    index: r,
    item: n,
    form: t.form
  }, n.columnName))
}));
function tn(t, n, r) {
  return t === 0 ? _("formComp.noDataSourceFound") : n === 0 ? _("formComp.noTableFound") : r === 0 ? _("formComp.noColumnFound") : "";
}
function nn() {
  const t = a2(h2e), n = a2(Q9), r = {};
  t == null || t.forEach(({
    id: l
  }) => {
    const s = g(l);
    s && (r[l] = s);
  });
  const o = [];
  return n == null || n.forEach(({
    datasource: l
  }) => {
    const s = r[l.type];
    s && o.push({
      dataSource: l,
      typeConfig: s
    });
  }), o;
}
function rn(t) {
  const n = a2((r) => r.entities.datasource.structure);
  return t && n ? (n[t] ?? []).filter((r) => r.type === "TABLE") : [];
}
var on = (t) => {
  const [n] = qd.useForm(), r = qd.useWatch("dataSourceId", n), o = nn(), l = o.find((a) => a.dataSource.id === r);
  (0, import_react.useEffect)(() => {
    if (!l) {
      const a = o.length > 0 ? o[0].dataSource.id : void 0;
      n.setFieldsValue({
        dataSourceId: a
      });
    }
  }, [o]);
  const s = b3();
  (0, import_react.useEffect)(() => {
    r && s(zG1({
      datasourceId: r
    }));
  }, [r]);
  const d2 = qd.useWatch("tableName", n), e = rn(r), f = e.find((a) => a.name === d2);
  (0, import_react.useEffect)(() => {
    if (!f) {
      const a = e.length > 0 ? e[0].name : void 0;
      n.setFieldsValue({
        tableName: a
      });
    }
  }, [e]);
  const [i, c] = (0, import_react.useState)([]), h = l == null ? void 0 : l.typeConfig;
  (0, import_react.useEffect)(() => {
    const {
      initItems: a,
      initColumns: g2
    } = Yt(h, f);
    n.setFieldsValue({
      columns: g2
    }), c(a);
  }, [h, f]);
  const u = tn(o.length, e.length, i.length);
  return d(p1, {
    children: N(qd, {
      form: n,
      preserve: false,
      children: [N(Be2, {
        children: [N(Lt, {
          children: [d(Te, {
            children: _("formComp.dataSource")
          }), d(K, {
            name: "dataSourceId",
            children: d(ce, {
              style: {
                width: "208px"
              },
              placeholder: _("formComp.selectSource"),
              children: o.map(({
                dataSource: a
              }) => d(h4.Option, {
                value: a.id,
                children: N(Ht, {
                  children: [a.type && d(w6e, {
                    dataSourceType: a.type
                  }), d(Ie, {
                    title: a.name,
                    children: a.name
                  })]
                })
              }, a.id))
            })
          })]
        }), N(Bt, {
          children: [d(Te, {
            children: _("formComp.table")
          }), d(K, {
            name: "tableName",
            children: d(ce, {
              style: {
                width: "208px"
              },
              placeholder: _("formComp.selectTable"),
              showSearch: true,
              children: e.map((a) => d(h4.Option, {
                value: a.name,
                children: d(Ie, {
                  title: a.name,
                  children: a.name + " (" + a.columns.length + ")"
                })
              }, a.name))
            })
          })]
        })]
      }), u ? d(Ft, {
        children: u
      }) : N(p1, {
        children: [N(Gt, {
          children: [d(He, {
            $head: true,
            children: _("formComp.columnName")
          }), d(Fe, {
            $head: true,
            children: _("formComp.dataType")
          }), d(Ge, {
            $head: true,
            children: _("label")
          }), d(je, {
            $head: true,
            children: _("formComp.compType")
          }), d(Ke, {
            $head: true,
            children: _("formComp.required")
          })]
        }), d(en, {
          items: i,
          form: n,
          useDragHandle: true,
          onSortEnd: ({
            oldIndex: a,
            newIndex: g2
          }) => {
            a !== g2 && c(gt(i, a, g2));
          }
        }), d(Ree, {
          children: d(zr, {
            buttonType: "primary",
            loading: false,
            onClick: () => Jt(n, h, i, t.onCreate),
            children: _("formComp.generateForm")
          })
        })]
      })]
    })
  });
};
var gn = (t) => {
  const [n, r] = (0, import_react.useState)(false);
  return N(p1, {
    children: [d(Mt, {
      onMouseDown: (o) => {
        r(true), o.stopPropagation();
      },
      children: _("formComp.openDialogButton")
    }), d("div", {
      onKeyDown: (o) => o.stopPropagation(),
      onMouseDown: (o) => o.stopPropagation(),
      onClick: (o) => o.stopPropagation(),
      children: d(U4, {
        open: n,
        destroyOnClose: true,
        title: _("formComp.generateForm"),
        footer: null,
        onCancel: () => r(false),
        width: "600px",
        children: d(on, {
          ...t
        }),
        styles: {
          body: {
            padding: 0
          }
        }
      })
    })]
  });
};

export {
  gn
};
//# sourceMappingURL=chunk-ZT6JYGF3.js.map
