import {
  dt as dt2
} from "./chunk-73LN4UPC.js";
import "./chunk-6QEPQE7Z.js";
import "./chunk-EKQL2BCI.js";
import "./chunk-MKBWIDPH.js";
import "./chunk-WX2SP7KE.js";
import "./chunk-BVDJWWQT.js";
import {
  dt
} from "./chunk-NCDKRTSH.js";
import "./chunk-DUBJU634.js";
import "./chunk-AYAGYW5Z.js";
import "./chunk-FYFEE5MO.js";
import "./chunk-PJT5DRVG.js";
import "./chunk-3KC2BSDX.js";
import "./chunk-AOVWTW27.js";
import "./chunk-MEZEKXQL.js";
import "./chunk-35OR5TC6.js";
import "./chunk-TU5ZXGQL.js";
import "./chunk-MCIUU3OK.js";
import "./chunk-XHYKILBN.js";
import "./chunk-UJOKFOHB.js";
import "./chunk-BFA4XLEP.js";
import "./chunk-FB47X7C3.js";
import "./chunk-U3BV2XWB.js";
import "./chunk-ZJJZ7KCT.js";
import "./chunk-UD6GF23N.js";
import "./chunk-JNTGN7JA.js";
import "./chunk-DTUB3P6T.js";
import "./chunk-FJZ2UJYE.js";
import "./chunk-MYGL7TQR.js";
import "./chunk-4PBCAFGZ.js";
import "./chunk-Y7AE76OL.js";
import "./chunk-YT7XWS54.js";
import "./chunk-2B5JEFTZ.js";
import "./chunk-3Y5I3OZJ.js";
import "./chunk-3GBVGJ5V.js";
import "./chunk-5IAS3Q6R.js";
import "./chunk-PPPGPJTG.js";
import "./chunk-6F5TAIKV.js";
import "./chunk-5PD5AN2J.js";
import "./chunk-APJJAOFL.js";
import "./chunk-KGJNSQSZ.js";
import "./chunk-A3UAJ3XR.js";
import "./chunk-QUWBOWXT.js";
import {
  PL,
  h1,
  mC,
  tg
} from "./chunk-2ZELARZW.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/820c7816.js
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var c = (a, r) => {
  const t = a.children.columns.getView().map((i) => i.getView());
  expect(r.length).toEqual(t.length), r.forEach((i) => {
    const e = t.find((o) => o.dataIndex === i.dataIndex);
    if (!e)
      throw new Error(`expect column: ${JSON.stringify(i)}, but not found.`);
    Object.keys(i).forEach((o) => {
      const s = e[o], n = i[o];
      if (n !== void 0 && !h1.isEqual(s, n))
        throw new Error(`ColumnKey:${o}, expect: "${n}", but found: "${s}"`);
    });
  });
  const d = a.children.dynamicColumnConfig.getView();
  if ((d == null ? void 0 : d.length) > 0) {
    const i = (o) => {
    }, e = dt(t, a.children.sort.getView(), a.children.toolbar.getView().columnSetting, a.children.size.getView(), a.children.dynamicColumn.getView(), d, a.columnAggrData, a.children.editModeClicks.getView(), i);
    expect(t.length).toBeGreaterThanOrEqual(e.length), e.forEach((o) => {
      const s = o.dataIndex, n = t.find((f) => f.dataIndex === s);
      if (!n)
        throw new Error(`Error, column should not be undefined, column: ${JSON.stringify(o)}`);
      const m = n.isCustom ? n.title : n.dataIndex;
      if (!d.includes(m))
        throw new Error(`dynamic config test fail: unexpect column: ${m}`);
    });
  }
};
function q() {
  const a = {
    query1: mC({
      data: [{
        q1: 1
      }]
    }),
    query2: mC({
      data: [{
        q2: 2
      }]
    })
  };
  return {
    tableData: {
      data: JSON.stringify([{
        a: 1
      }]),
      columns: [{
        dataIndex: "a",
        title: "a",
        hide: true
      }, {
        title: "custom",
        dataIndex: "custom1",
        isCustom: true
      }]
    },
    exposingInfo: a,
    initColumns: [{
      dataIndex: "a",
      hide: true,
      title: "a"
    }, {
      dataIndex: "custom1",
      hide: false,
      title: "custom",
      isCustom: true
    }]
  };
}
async function x() {
  await new Promise((a) => setTimeout(a, 20));
}
test("test table dynamic columns: Change unEvalValue", async () => {
  const {
    initColumns: a,
    tableData: r,
    exposingInfo: p
  } = q();
  let t = new dt2({
    dispatch: (i) => {
      t = PL(t.reduce(i), p);
    },
    value: r
  });
  t = PL(t), c(t, a), t = PL(t.reduce(t.changeChildAction("data", JSON.stringify([{
    a: 1,
    c: 2,
    d: 3
  }])))), await x();
  const d = [...a, {
    dataIndex: "c",
    hide: false,
    title: "c"
  }, {
    dataIndex: "d",
    title: "d"
  }];
  c(t, d), t = PL(t.reduce(t.changeChildAction("data", JSON.stringify([{
    c: 2,
    d: 3
  }])))), await x(), c(t, d.filter((i) => i.dataIndex !== "a"));
}, 1e3);
async function u(a, r, p) {
  const {
    initColumns: t,
    tableData: d,
    exposingInfo: i
  } = q();
  let e = new dt2({
    dispatch: (h) => {
      let w;
      r ? w = tg({
        readOnly: r
      }, () => e.reduce(h)) : w = e.reduce(h), e = PL(w, i);
    },
    value: {
      ...d,
      dynamicColumn: a,
      ...a && p && {
        dynamicColumnConfig: JSON.stringify(p)
      }
    }
  });
  e = PL(e);
  const o = async () => {
    e = PL(e.reduce(e.changeChildAction("data", "{{query1.data}}")), i), await x();
  }, s = [{
    dataIndex: "q1",
    title: "q1"
  }, {
    dataIndex: "custom1",
    title: "custom",
    isCustom: true
  }];
  await o(), !a && r ? c(e, t) : c(e, s);
  const n = [{
    q1: 1,
    a: 2
  }];
  i.query1 = mC({
    data: n
  }), await o();
  const m = [...s, {
    dataIndex: "a",
    title: "a"
  }];
  expect(e.children.data.getView()).toEqual(n), !a && r ? c(e, t) : c(e, m);
  const f = [{
    a: 2
  }];
  i.query1 = mC({
    data: f
  }), await o(), expect(e.children.data.getView()).toEqual(f), a ? c(e, m.filter((h) => h.dataIndex !== "q1")) : r ? c(e, t) : c(e, m);
}
test("test table dynamic columns", async () => {
  await u(false, false), await u(false, true), await u(true, false), await u(true, true), await u(true, false, ["custom", "q1"]), await u(true, true, ["custom", "q1"]);
}, 2e3);
//# sourceMappingURL=820c7816-ARLGYU2H.js.map
