import {
  $e,
  Ba,
  Er,
  G,
  Je as Je2,
  Pa,
  R,
  Sa,
  V,
  Xe,
  _,
  be,
  j,
  pr,
  st,
  yt
} from "./chunk-LMSFAF37.js";
import {
  Oa,
  fa,
  ie,
  ka,
  la,
  re
} from "./chunk-SR2L3AZF.js";
import {
  $s,
  As,
  J,
  Je,
  Me,
  Us,
  Vr,
  Xr,
  Y,
  an,
  cr,
  ge,
  hr,
  nr,
  nt,
  q as q2,
  sn,
  vs,
  ws
} from "./chunk-FXWJ52WH.js";
import {
  h
} from "./chunk-AVJEXRAA.js";
import {
  m
} from "./chunk-IDFCZB5I.js";
import {
  A as A2,
  y
} from "./chunk-6HL2NPY5.js";
import {
  A,
  E,
  c,
  q,
  z
} from "./chunk-IRR3YWAF.js";
import {
  x as x2
} from "./chunk-BYNTL4HL.js";
import {
  S as S3
} from "./chunk-UVUWFVSJ.js";
import {
  N
} from "./chunk-VUKG4NOS.js";
import {
  S as S2
} from "./chunk-CA4GYSFB.js";
import {
  x
} from "./chunk-QAAOKTDR.js";
import {
  S
} from "./chunk-ED2LVFD3.js";
import {
  E7,
  Fj1,
  G$,
  H0,
  HQe,
  Hv,
  KRe,
  KX,
  LS,
  N as N2,
  N0,
  Ote,
  Ov,
  Q2,
  VS,
  Vr as Vr2,
  Wte,
  YW1,
  _ as _2,
  _c,
  _e,
  ao,
  b0,
  d,
  de,
  e2e,
  ene,
  fl,
  gh,
  h4,
  hQ,
  iQ,
  j$,
  ka as ka2,
  l9,
  nc,
  nn,
  p1,
  qd,
  r2r,
  rq1,
  s2e,
  sa,
  sn as sn2,
  v0r,
  yQ,
  ya
} from "./chunk-2ZELARZW.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/ab9066e0.js
var Ln = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
function Se(e) {
  return typeof File < "u" && e instanceof File || typeof Date < "u" && e instanceof Date ? false : typeof e == "object" && e !== null && !Array.isArray(e);
}
function Tf(e) {
  return e.additionalItems === true && console.warn("additionalItems=true is currently not supported"), Se(e.additionalItems);
}
function mo(e) {
  if (e === "")
    return;
  if (e === null)
    return null;
  if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
    return e;
  const t = Number(e);
  return typeof t == "number" && !Number.isNaN(t) ? t : e;
}
var Dr = "__additional_property";
var Ji = "additionalProperties";
var fn = "allOf";
var pt = "anyOf";
var Ll = "const";
var Nf = "default";
var pi = "dependencies";
var Df = "enum";
var ot = "__errors";
var Mt = "$id";
var Ff = "if";
var Ut = "items";
var kf = "_$junk_option_schema_id$_";
var Bn = "$name";
var et = "oneOf";
var Oe = "properties";
var Rf = "required";
var Zn = "submitButtonOptions";
var Te = "$ref";
var Ia = "__rjsf_additionalProperties";
var Bl = "__rjsf_rootSchema";
var Mf = "ui:field";
var Ta = "ui:widget";
var nr2 = "ui:options";
var jf = "ui:globalOptions";
function oe(e = {}, t = {}) {
  return Object.keys(e).filter((r) => r.indexOf("ui:") === 0).reduce((r, n) => {
    const i = e[n];
    return n === Ta && Se(i) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), r) : n === nr2 && Se(i) ? { ...r, ...i } : { ...r, [n.substring(3)]: i };
  }, { ...t });
}
function ql(e, t = {}, r) {
  if (!e.additionalProperties)
    return false;
  const { expandable: n = true } = oe(t);
  return n === false ? n : e.maxProperties !== void 0 && r ? Object.keys(r).length < e.maxProperties : true;
}
var Uf = q;
var Vf = G;
var xf = z;
var Lf = "[object Object]";
var Bf = Function.prototype;
var qf = Object.prototype;
var Kl = Bf.toString;
var Kf = qf.hasOwnProperty;
var zf = Kl.call(Object);
function Wf(e) {
  if (!xf(e) || Uf(e) != Lf)
    return false;
  var t = Vf(e);
  if (t === null)
    return true;
  var r = Kf.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r instanceof r && Kl.call(r) == zf;
}
var Fr = Wf;
var Na = sn2(Fr);
function Xi(e) {
  const t = {
    // We store the list of errors for this node in a property named __errors
    // to avoid name collision with a possible sub schema field named
    // 'errors' (see `utils.toErrorSchema`).
    [ot]: [],
    addError(r) {
      this[ot].push(r);
    }
  };
  if (Array.isArray(e))
    return e.reduce((r, n, i) => ({ ...r, [i]: Xi(n) }), t);
  if (Na(e)) {
    const r = e;
    return Object.keys(r).reduce((n, i) => ({ ...n, [i]: Xi(r[i]) }), t);
  }
  return t;
}
var Gf = ka;
function Hf(e, t, r) {
  r = typeof r == "function" ? r : void 0;
  var n = r ? r(e, t) : void 0;
  return n === void 0 ? Gf(e, t, void 0, r) : !!n;
}
var Yf = Hf;
var Jf = sn2(Yf);
function Be(e, t) {
  return Jf(e, t, (r, n) => {
    if (typeof r == "function" && typeof n == "function")
      return true;
  });
}
var Xf = J;
var Zf = y;
var Qf = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var eh = /^\w*$/;
function th(e, t) {
  if (Xf(e))
    return false;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || Zf(e) ? true : eh.test(e) || !Qf.test(e) || t != null && e in Object(t);
}
var Da = th;
var zl = ge;
var rh = "Expected a function";
function Fa(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(rh);
  var r = function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = e.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (Fa.Cache || zl)(), r;
}
Fa.Cache = zl;
var nh = Fa;
var ih = nh;
var ah = 500;
function sh(e) {
  var t = ih(e, function(n) {
    return r.size === ah && r.clear(), n;
  }), r = t.cache;
  return t;
}
var oh = sh;
var lh = oh;
var ch = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var uh = /\\(\\)?/g;
var dh = lh(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(ch, function(r, n, i, a) {
    t.push(i ? a.replace(uh, "$1") : n || r);
  }), t;
});
var Wl = dh;
function fh(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
var Pt = fh;
var po = c;
var hh = Pt;
var mh = J;
var ph = y;
var yh = 1 / 0;
var yo = po ? po.prototype : void 0;
var go = yo ? yo.toString : void 0;
function Gl(e) {
  if (typeof e == "string")
    return e;
  if (mh(e))
    return hh(e, Gl) + "";
  if (ph(e))
    return go ? go.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -yh ? "-0" : t;
}
var gh2 = Gl;
var vh = gh2;
function $h(e) {
  return e == null ? "" : vh(e);
}
var Hl = $h;
var _h = J;
var bh = Da;
var Sh = Wl;
var wh = Hl;
function Eh(e, t) {
  return _h(e) ? e : bh(e, t) ? [e] : Sh(wh(e));
}
var kr = Eh;
var Oh = y;
var Ch = 1 / 0;
function Ah(e) {
  if (typeof e == "string" || Oh(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -Ch ? "-0" : t;
}
var ur = Ah;
var Ph = kr;
var Ih = ur;
function Th(e, t) {
  t = Ph(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[Ih(t[r++])];
  return r && r == n ? e : void 0;
}
var hn = Th;
var Nh = hn;
function Dh(e, t, r) {
  var n = e == null ? void 0 : Nh(e, t);
  return n === void 0 ? r : n;
}
var Yl = Dh;
var G2 = sn2(Yl);
var Fh = $s;
var kh = sn;
var Rh = nr;
var Mh = J;
var jh = As;
var Uh = cr;
var Vh = vs;
var xh = Xr;
var Lh = "[object Map]";
var Bh = "[object Set]";
var qh = Object.prototype;
var Kh = qh.hasOwnProperty;
function zh(e) {
  if (e == null)
    return true;
  if (jh(e) && (Mh(e) || typeof e == "string" || typeof e.splice == "function" || Uh(e) || xh(e) || Rh(e)))
    return !e.length;
  var t = kh(e);
  if (t == Lh || t == Bh)
    return !e.size;
  if (Vh(e))
    return !Fh(e).length;
  for (var r in e)
    if (Kh.call(e, r))
      return false;
  return true;
}
var Wh = zh;
var xt = sn2(Wh);
var yi = {};
var Gh = /~/;
var Hh = /~[01]/g;
function Yh(e) {
  switch (e) {
    case "~1":
      return "/";
    case "~0":
      return "~";
  }
  throw new Error("Invalid tilde escape: " + e);
}
function Jl(e) {
  return Gh.test(e) ? e.replace(Hh, Yh) : e;
}
function Jh(e, t, r) {
  for (var n, i, a = 1, s = t.length; a < s; ) {
    if (t[a] === "constructor" || t[a] === "prototype" || t[a] === "__proto__")
      return e;
    if (n = Jl(t[a++]), i = s > a, typeof e[n] > "u" && (Array.isArray(e) && n === "-" && (n = e.length), i && (t[a] !== "" && t[a] < 1 / 0 || t[a] === "-" ? e[n] = [] : e[n] = {})), !i)
      break;
    e = e[n];
  }
  var o = e[n];
  return r === void 0 ? delete e[n] : e[n] = r, o;
}
function ka3(e) {
  if (typeof e == "string") {
    if (e = e.split("/"), e[0] === "")
      return e;
    throw new Error("Invalid JSON pointer.");
  } else if (Array.isArray(e)) {
    for (const t of e)
      if (typeof t != "string" && typeof t != "number")
        throw new Error("Invalid JSON pointer. Must be of type string or number.");
    return e;
  }
  throw new Error("Invalid JSON pointer.");
}
function Xl(e, t) {
  if (typeof e != "object")
    throw new Error("Invalid input object.");
  t = ka3(t);
  var r = t.length;
  if (r === 1)
    return e;
  for (var n = 1; n < r; ) {
    if (e = e[Jl(t[n++])], r === n)
      return e;
    if (typeof e != "object" || e === null)
      return;
  }
}
function Zl(e, t, r) {
  if (typeof e != "object")
    throw new Error("Invalid input object.");
  if (t = ka3(t), t.length === 0)
    throw new Error("Invalid JSON pointer for set.");
  return Jh(e, t, r);
}
function Xh(e) {
  var t = ka3(e);
  return {
    get: function(r) {
      return Xl(r, t);
    },
    set: function(r, n) {
      return Zl(r, t, n);
    }
  };
}
yi.get = Xl;
yi.set = Zl;
yi.compile = Xh;
function Zh(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var Ql = Zh;
function Qh(e, t, r) {
  var n = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), r = r > i ? i : r, r < 0 && (r += i), i = t > r ? 0 : r - t >>> 0, t >>>= 0;
  for (var a = Array(i); ++n < i; )
    a[n] = e[n + t];
  return a;
}
var em = Qh;
var tm = hn;
var rm = em;
function nm(e, t) {
  return t.length < 2 ? e : tm(e, rm(t, 0, -1));
}
var im = nm;
var am = kr;
var sm = Ql;
var om = im;
var lm = ur;
function cm(e, t) {
  return t = am(t, e), e = om(e, t), e == null || delete e[lm(sm(t))];
}
var ec = cm;
var um = Fr;
function dm(e) {
  return um(e) ? void 0 : e;
}
var fm = dm;
var vo = c;
var hm = nr;
var mm = J;
var $o = vo ? vo.isConcatSpreadable : void 0;
function pm(e) {
  return mm(e) || hm(e) || !!($o && e && e[$o]);
}
var ym = pm;
var gm = Me;
var vm = ym;
function tc(e, t, r, n, i) {
  var a = -1, s = e.length;
  for (r || (r = vm), i || (i = []); ++a < s; ) {
    var o = e[a];
    t > 0 && r(o) ? t > 1 ? tc(o, t - 1, r, n, i) : gm(i, o) : n || (i[i.length] = o);
  }
  return i;
}
var gi = tc;
var $m = gi;
function _m(e) {
  var t = e == null ? 0 : e.length;
  return t ? $m(e, 1) : [];
}
var Ra = _m;
function bm(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
var rc = bm;
var Sm = rc;
var _o = Math.max;
function wm(e, t, r) {
  return t = _o(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var n = arguments, i = -1, a = _o(n.length - t, 0), s = Array(a); ++i < a; )
      s[i] = n[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = n[i];
    return o[t] = r(s), Sm(e, this, o);
  };
}
var nc2 = wm;
function Em(e) {
  return function() {
    return e;
  };
}
var Om = Em;
function Cm(e) {
  return e;
}
var mn = Cm;
var Am = Om;
var bo = $e;
var Pm = mn;
var Im = bo ? function(e, t) {
  return bo(e, "toString", {
    configurable: true,
    enumerable: false,
    value: Am(t),
    writable: true
  });
} : Pm;
var Tm = Im;
var Nm = 800;
var Dm = 16;
var Fm = Date.now;
function km(e) {
  var t = 0, r = 0;
  return function() {
    var n = Fm(), i = Dm - (n - r);
    if (r = n, i > 0) {
      if (++t >= Nm)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var Rm = km;
var Mm = Tm;
var jm = Rm;
var Um = jm(Mm);
var ic = Um;
var Vm = Ra;
var xm = nc2;
var Lm = ic;
function Bm(e) {
  return Lm(xm(e, void 0, Vm), e + "");
}
var ac = Bm;
var qm = Pt;
var Km = Sa;
var zm = ec;
var Wm = kr;
var Gm = _;
var Hm = fm;
var Ym = ac;
var Jm = pr;
var Xm = 1;
var Zm = 2;
var Qm = 4;
var ep = Ym(function(e, t) {
  var r = {};
  if (e == null)
    return r;
  var n = false;
  t = qm(t, function(a) {
    return a = Wm(a, e), n || (n = a.length > 1), a;
  }), Gm(e, Jm(e), r), n && (r = Km(r, Xm | Zm | Qm, Hm));
  for (var i = t.length; i--; )
    zm(r, t[i]);
  return r;
});
var tp = ep;
var Qn = sn2(tp);
function Ma(e, t) {
  const r = t[e];
  return [Qn(t, [e]), r];
}
function sc(e, t = {}, r = []) {
  const n = e || "";
  let i;
  if (n.startsWith("#"))
    i = decodeURIComponent(n.substring(1));
  else
    throw new Error(`Could not find a definition for ${e}.`);
  const a = yi.get(t, i);
  if (a === void 0)
    throw new Error(`Could not find a definition for ${e}.`);
  const s = a[Te];
  if (s) {
    if (r.includes(s)) {
      if (r.length === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const [u, ...f] = r, p = [...f, n, u].join(" -> ");
      throw new Error(`Definition for ${u} contains a circular reference through ${p}`);
    }
    const [o, l] = Ma(Te, a), c2 = sc(l, t, [...r, n]);
    return Object.keys(o).length > 0 ? { ...o, ...c2 } : c2;
  }
  return a;
}
function oc(e, t = {}) {
  return sc(e, t, []);
}
var rp = Object.prototype;
var np = rp.hasOwnProperty;
function ip(e, t) {
  return e != null && np.call(e, t);
}
var ap = ip;
var sp = kr;
var op = nr;
var lp = J;
var cp = hr;
var up = Y;
var dp = ur;
function fp(e, t, r) {
  t = sp(t, e);
  for (var n = -1, i = t.length, a = false; ++n < i; ) {
    var s = dp(t[n]);
    if (!(a = e != null && r(e, s)))
      break;
    e = e[s];
  }
  return a || ++n != i ? a : (i = e == null ? 0 : e.length, !!i && up(i) && cp(s, i) && (lp(e) || op(e)));
}
var lc = fp;
var hp = ap;
var mp = lc;
function pp(e, t) {
  return e != null && mp(e, t, hp);
}
var yp = pp;
var Le = sn2(yp);
var gp = q;
var vp = z;
var $p = "[object Number]";
function _p(e) {
  return typeof e == "number" || vp(e) && gp(e) == $p;
}
var bp = _p;
var ja = sn2(bp);
var Sp = q;
var wp = J;
var Ep = z;
var Op = "[object String]";
function Cp(e) {
  return typeof e == "string" || !wp(e) && Ep(e) && Sp(e) == Op;
}
var Ap = Cp;
var ir = sn2(Ap);
function Pp(e, t, r, n) {
  var i = -1, a = e == null ? 0 : e.length;
  for (n && a && (r = e[++i]); ++i < a; )
    r = t(r, e[i], i, e);
  return r;
}
var Ip = Pp;
function Tp(e) {
  return function(t, r, n) {
    for (var i = -1, a = Object(t), s = n(t), o = s.length; o--; ) {
      var l = s[e ? o : ++i];
      if (r(a[l], l, a) === false)
        break;
    }
    return t;
  };
}
var Np = Tp;
var Dp = Np;
var Fp = Dp();
var cc = Fp;
var kp = cc;
var Rp = ws;
function Mp(e, t) {
  return e && kp(e, t, Rp);
}
var uc = Mp;
var jp = As;
function Up(e, t) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!jp(r))
      return e(r, n);
    for (var i = r.length, a = t ? i : -1, s = Object(r); (t ? a-- : ++a < i) && n(s[a], a, s) !== false; )
      ;
    return r;
  };
}
var Vp = Up;
var xp = uc;
var Lp = Vp;
var Bp = Lp(xp);
var Ua = Bp;
var qp = an;
var Kp = ka;
var zp = 1;
var Wp = 2;
function Gp(e, t, r, n) {
  var i = r.length, a = i, s = !n;
  if (e == null)
    return !a;
  for (e = Object(e); i--; ) {
    var o = r[i];
    if (s && o[2] ? o[1] !== e[o[0]] : !(o[0] in e))
      return false;
  }
  for (; ++i < a; ) {
    o = r[i];
    var l = o[0], c2 = e[l], u = o[1];
    if (s && o[2]) {
      if (c2 === void 0 && !(l in e))
        return false;
    } else {
      var f = new qp();
      if (n)
        var p = n(c2, u, l, e, t, f);
      if (!(p === void 0 ? Kp(u, c2, zp | Wp, n, f) : p))
        return false;
    }
  }
  return true;
}
var Hp = Gp;
var Yp = E;
function Jp(e) {
  return e === e && !Yp(e);
}
var dc = Jp;
var Xp = dc;
var Zp = ws;
function Qp(e) {
  for (var t = Zp(e), r = t.length; r--; ) {
    var n = t[r], i = e[n];
    t[r] = [n, i, Xp(i)];
  }
  return t;
}
var ey = Qp;
function ty(e, t) {
  return function(r) {
    return r == null ? false : r[e] === t && (t !== void 0 || e in Object(r));
  };
}
var fc = ty;
var ry = Hp;
var ny = ey;
var iy = fc;
function ay(e) {
  var t = ny(e);
  return t.length == 1 && t[0][2] ? iy(t[0][0], t[0][1]) : function(r) {
    return r === e || ry(r, e, t);
  };
}
var sy = ay;
function oy(e, t) {
  return e != null && t in Object(e);
}
var ly = oy;
var cy = ly;
var uy = lc;
function dy(e, t) {
  return e != null && uy(e, t, cy);
}
var hc = dy;
var fy = ka;
var hy = Yl;
var my = hc;
var py = Da;
var yy = dc;
var gy = fc;
var vy = ur;
var $y = 1;
var _y = 2;
function by(e, t) {
  return py(e) && yy(t) ? gy(vy(e), t) : function(r) {
    var n = hy(r, e);
    return n === void 0 && n === t ? my(r, e) : fy(t, n, $y | _y);
  };
}
var Sy = by;
function wy(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var Ey = wy;
var Oy = hn;
function Cy(e) {
  return function(t) {
    return Oy(t, e);
  };
}
var Ay = Cy;
var Py = Ey;
var Iy = Ay;
var Ty = Da;
var Ny = ur;
function Dy(e) {
  return Ty(e) ? Py(Ny(e)) : Iy(e);
}
var Fy = Dy;
var ky = sy;
var Ry = Sy;
var My = mn;
var jy = J;
var Uy = Fy;
function Vy(e) {
  return typeof e == "function" ? e : e == null ? My : typeof e == "object" ? jy(e) ? Ry(e[0], e[1]) : ky(e) : Uy(e);
}
var Va = Vy;
function xy(e, t, r, n, i) {
  return i(e, function(a, s, o) {
    r = n ? (n = false, a) : t(r, a, s, o);
  }), r;
}
var Ly = xy;
var By = Ip;
var qy = Ua;
var Ky = Va;
var zy = Ly;
var Wy = J;
function Gy(e, t, r) {
  var n = Wy(e) ? By : zy, i = arguments.length < 3;
  return n(e, Ky(t), r, i, qy);
}
var Hy = Gy;
var Yy = sn2(Hy);
var Jy = mn;
function Xy(e) {
  return typeof e == "function" ? e : Jy;
}
var mc = Xy;
var Zy = A2;
var So = 1 / 0;
var Qy = 17976931348623157e292;
function eg(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Zy(e), e === So || e === -So) {
    var t = e < 0 ? -1 : 1;
    return t * Qy;
  }
  return e === e ? e : 0;
}
var tg = eg;
var rg = tg;
function ng(e) {
  var t = rg(e), r = t % 1;
  return t === t ? r ? t - r : t : 0;
}
var ig = ng;
var ag = Je;
var sg = mc;
var og = ig;
var lg = 9007199254740991;
var Ni = 4294967295;
var cg = Math.min;
function ug(e, t) {
  if (e = og(e), e < 1 || e > lg)
    return [];
  var r = Ni, n = cg(e, Ni);
  t = sg(t), e -= Ni;
  for (var i = ag(n, t); ++r < e; )
    t(r);
  return i;
}
var dg = ug;
var pc = sn2(dg);
function yc(e, t, r) {
  var n;
  if (e && r) {
    const i = G2(e, r);
    if (i === void 0)
      return;
    for (let a = 0; a < t.length; a++) {
      const s = t[a], o = G2(s, [Oe, r], {});
      if (!(o.type === "object" || o.type === "array") && (o.const === i || !((n = o.enum) === null || n === void 0) && n.includes(i)))
        return a;
    }
  }
}
function gc(e, t, r, n, i) {
  if (t === void 0)
    return 0;
  const a = yc(t, r, i);
  if (ja(a))
    return a;
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    if (i && Le(o, [Oe, i])) {
      const l = G2(t, i), c2 = G2(o, [Oe, i], {});
      if (e.isValid(c2, l, n))
        return s;
    } else if (o[Oe]) {
      const l = {
        anyOf: Object.keys(o[Oe]).map((u) => ({
          required: [u]
        }))
      };
      let c2;
      if (o.anyOf) {
        const { ...u } = o;
        u.allOf ? u.allOf = u.allOf.slice() : u.allOf = [], u.allOf.push(l), c2 = u;
      } else
        c2 = Object.assign({}, o, l);
      if (delete c2.required, e.isValid(c2, t, n))
        return s;
    } else if (e.isValid(o, t, n))
      return s;
  }
  return 0;
}
function xa(e, t, r, n, i) {
  return gc(e, t, r, n, i);
}
var fg = R;
var hg = kr;
var mg = hr;
var wo = E;
var pg = ur;
function yg(e, t, r, n) {
  if (!wo(e))
    return e;
  t = hg(t, e);
  for (var i = -1, a = t.length, s = a - 1, o = e; o != null && ++i < a; ) {
    var l = pg(t[i]), c2 = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (i != s) {
      var u = o[l];
      c2 = n ? n(u, l, o) : void 0, c2 === void 0 && (c2 = wo(u) ? u : mg(t[i + 1]) ? [] : {});
    }
    fg(o, l, c2), o = o[l];
  }
  return e;
}
var vc = yg;
var gg = vc;
function vg(e, t, r) {
  return e == null ? e : gg(e, t, r);
}
var $g = vg;
var je = sn2($g);
var _g = be;
var bg = st;
var Sg = uc;
var wg = Va;
var Eg = G;
var Og = J;
var Cg = cr;
var Ag = q2;
var Pg = E;
var Ig = Xr;
function Tg(e, t, r) {
  var n = Og(e), i = n || Cg(e) || Ig(e);
  if (t = wg(t), r == null) {
    var a = e && e.constructor;
    i ? r = n ? new a() : [] : Pg(e) ? r = Ag(a) ? bg(Eg(e)) : {} : r = {};
  }
  return (i ? _g : Sg)(e, function(s, o, l) {
    return t(r, s, o, l);
  }), r;
}
var Ng = Tg;
var Dg = sn2(Ng);
var Fg = V;
var kg = nt;
function Rg(e, t, r) {
  (r !== void 0 && !kg(e[t], r) || r === void 0 && !(t in e)) && Fg(e, t, r);
}
var $c = Rg;
var Mg = As;
var jg = z;
function Ug(e) {
  return jg(e) && Mg(e);
}
var vi = Ug;
function Vg(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
var _c2 = Vg;
var xg = _;
var Lg = j;
function Bg(e) {
  return xg(e, Lg(e));
}
var qg = Bg;
var Eo = $c;
var Kg = Je2;
var zg = Er;
var Wg = Xe;
var Gg = yt;
var Oo = nr;
var Co = J;
var Hg = vi;
var Yg = cr;
var Jg = q2;
var Xg = E;
var Zg = Fr;
var Qg = Xr;
var Ao = _c2;
var ev = qg;
function tv(e, t, r, n, i, a, s) {
  var o = Ao(e, r), l = Ao(t, r), c2 = s.get(l);
  if (c2) {
    Eo(e, r, c2);
    return;
  }
  var u = a ? a(o, l, r + "", e, t, s) : void 0, f = u === void 0;
  if (f) {
    var p = Co(l), d2 = !p && Yg(l), m2 = !p && !d2 && Qg(l);
    u = l, p || d2 || m2 ? Co(o) ? u = o : Hg(o) ? u = Wg(o) : d2 ? (f = false, u = Kg(l, true)) : m2 ? (f = false, u = zg(l, true)) : u = [] : Zg(l) || Oo(l) ? (u = o, Oo(o) ? u = ev(o) : (!Xg(o) || Jg(o)) && (u = Gg(l))) : f = false;
  }
  f && (s.set(l, u), i(u, l, n, a, s), s.delete(l)), Eo(e, r, u);
}
var rv = tv;
var nv = an;
var iv = $c;
var av = cc;
var sv = rv;
var ov = E;
var lv = j;
var cv = _c2;
function bc(e, t, r, n, i) {
  e !== t && av(t, function(a, s) {
    if (i || (i = new nv()), ov(a))
      sv(e, t, s, r, bc, n, i);
    else {
      var o = n ? n(cv(e, s), a, s + "", e, t, i) : void 0;
      o === void 0 && (o = a), iv(e, s, o);
    }
  }, lv);
}
var La = bc;
var uv = mn;
var dv = nc2;
var fv = ic;
function hv(e, t) {
  return fv(dv(e, t, uv), e + "");
}
var Bt = hv;
var mv = nt;
var pv = As;
var yv = hr;
var gv = E;
function vv(e, t, r) {
  if (!gv(r))
    return false;
  var n = typeof t;
  return (n == "number" ? pv(r) && yv(t, r.length) : n == "string" && t in r) ? mv(r[t], e) : false;
}
var Ba2 = vv;
var $v = Bt;
var _v = Ba2;
function bv(e) {
  return $v(function(t, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = e.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && _v(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), t = Object(t); ++n < i; ) {
      var o = r[n];
      o && e(t, o, n, a);
    }
    return t;
  });
}
var Sc = bv;
var Sv = La;
var wv = Sc;
var Ev = wv(function(e, t, r) {
  Sv(e, t, r);
});
var Ov2 = Ev;
var Cv = sn2(Ov2);
var Av = gi;
var Pv = 1 / 0;
function Iv(e) {
  var t = e == null ? 0 : e.length;
  return t ? Av(e, Pv) : [];
}
var qa = Iv;
var Tv = sn2(qa);
function Nv(e, t, r, n) {
  for (var i = e.length, a = r + (n ? 1 : -1); n ? a-- : ++a < i; )
    if (t(e[a], a, e))
      return a;
  return -1;
}
var Dv = Nv;
function Fv(e) {
  return e !== e;
}
var kv = Fv;
function Rv(e, t, r) {
  for (var n = r - 1, i = e.length; ++n < i; )
    if (e[n] === t)
      return n;
  return -1;
}
var Mv = Rv;
var jv = Dv;
var Uv = kv;
var Vv = Mv;
function xv(e, t, r) {
  return t === t ? Vv(e, t, r) : jv(e, Uv, r);
}
var wc = xv;
var Lv = wc;
function Bv(e, t) {
  var r = e == null ? 0 : e.length;
  return !!r && Lv(e, t, 0) > -1;
}
var Ka = Bv;
function qv(e, t, r) {
  for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
    if (r(t, e[n]))
      return true;
  return false;
}
var za = qv;
function Kv() {
}
var zv = Kv;
var Di = Us;
var Wv = zv;
var Gv = Oa;
var Hv2 = 1 / 0;
var Yv = Di && 1 / Gv(new Di([, -0]))[1] == Hv2 ? function(e) {
  return new Di(e);
} : Wv;
var Jv = Yv;
var Xv = fa;
var Zv = Ka;
var Qv = za;
var e$ = la;
var t$ = Jv;
var r$ = Oa;
var n$ = 200;
function i$(e, t, r) {
  var n = -1, i = Zv, a = e.length, s = true, o = [], l = o;
  if (r)
    s = false, i = Qv;
  else if (a >= n$) {
    var c2 = t ? null : t$(e);
    if (c2)
      return r$(c2);
    s = false, i = e$, l = new Xv();
  } else
    l = t ? [] : o;
  e:
    for (; ++n < a; ) {
      var u = e[n], f = t ? t(u) : u;
      if (u = r || u !== 0 ? u : 0, s && f === f) {
        for (var p = l.length; p--; )
          if (l[p] === f)
            continue e;
        t && l.push(f), o.push(u);
      } else
        i(l, f, r) || (l !== o && l.push(f), o.push(u));
    }
  return o;
}
var Wa = i$;
var a$ = Wa;
function s$(e) {
  return e && e.length ? a$(e) : [];
}
var $i = s$;
var o$ = sn2($i);
var l$ = Ua;
var c$ = As;
function u$(e, t) {
  var r = -1, n = c$(e) ? Array(e.length) : [];
  return l$(e, function(i, a, s) {
    n[++r] = t(i, a, s);
  }), n;
}
var d$ = u$;
function f$(e, t) {
  var r = e.length;
  for (e.sort(t); r--; )
    e[r] = e[r].value;
  return e;
}
var h$ = f$;
var Po = y;
function m$(e, t) {
  if (e !== t) {
    var r = e !== void 0, n = e === null, i = e === e, a = Po(e), s = t !== void 0, o = t === null, l = t === t, c2 = Po(t);
    if (!o && !c2 && !a && e > t || a && s && l && !o && !c2 || n && s && l || !r && l || !i)
      return 1;
    if (!n && !a && !c2 && e < t || c2 && r && i && !n && !a || o && r && i || !s && i || !l)
      return -1;
  }
  return 0;
}
var p$ = m$;
var y$ = p$;
function g$(e, t, r) {
  for (var n = -1, i = e.criteria, a = t.criteria, s = i.length, o = r.length; ++n < s; ) {
    var l = y$(i[n], a[n]);
    if (l) {
      if (n >= o)
        return l;
      var c2 = r[n];
      return l * (c2 == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
var v$ = g$;
var Fi = Pt;
var $$ = hn;
var _$ = Va;
var b$ = d$;
var S$ = h$;
var w$ = Vr;
var E$ = v$;
var O$ = mn;
var C$ = J;
function A$(e, t, r) {
  t.length ? t = Fi(t, function(a) {
    return C$(a) ? function(s) {
      return $$(s, a.length === 1 ? a[0] : a);
    } : a;
  }) : t = [O$];
  var n = -1;
  t = Fi(t, w$(_$));
  var i = b$(e, function(a, s, o) {
    var l = Fi(t, function(c2) {
      return c2(a);
    });
    return { criteria: l, index: ++n, value: a };
  });
  return S$(i, function(a, s) {
    return E$(a, s, r);
  });
}
var P$ = A$;
var I$ = gi;
var T$ = P$;
var N$ = Bt;
var Io = Ba2;
var D$ = N$(function(e, t) {
  if (e == null)
    return [];
  var r = t.length;
  return r > 1 && Io(e, t[0], t[1]) ? t = [] : r > 2 && Io(t[0], t[1], t[2]) && (t = [t[0]]), T$(e, I$(t, 1), []);
});
var Ec = D$;
var F$ = Wa;
function k$(e, t) {
  return t = typeof t == "function" ? t : void 0, e && e.length ? F$(e, void 0, t) : [];
}
var Ga = k$;
var R$ = Bt;
var M$ = nt;
var j$2 = Ba2;
var U$ = j;
var Oc = Object.prototype;
var V$ = Oc.hasOwnProperty;
var x$ = R$(function(e, t) {
  e = Object(e);
  var r = -1, n = t.length, i = n > 2 ? t[2] : void 0;
  for (i && j$2(t[0], t[1], i) && (n = 1); ++r < n; )
    for (var a = t[r], s = U$(a), o = -1, l = s.length; ++o < l; ) {
      var c2 = s[o], u = e[c2];
      (u === void 0 || M$(u, Oc[c2]) && !V$.call(e, c2)) && (e[c2] = a[c2]);
    }
  return e;
});
var L$ = x$;
var B$ = fa;
var q$ = Ka;
var K$ = za;
var z$ = Pt;
var W$ = Vr;
var To = la;
var G$2 = Math.min;
function H$(e, t, r) {
  for (var n = r ? K$ : q$, i = e[0].length, a = e.length, s = a, o = Array(a), l = 1 / 0, c2 = []; s--; ) {
    var u = e[s];
    s && t && (u = z$(u, W$(t))), l = G$2(u.length, l), o[s] = !r && (t || i >= 120 && u.length >= 120) ? new B$(s && u) : void 0;
  }
  u = e[0];
  var f = -1, p = o[0];
  e:
    for (; ++f < i && c2.length < l; ) {
      var d2 = u[f], m2 = t ? t(d2) : d2;
      if (d2 = r || d2 !== 0 ? d2 : 0, !(p ? To(p, m2) : n(c2, m2, r))) {
        for (s = a; --s; ) {
          var h2 = o[s];
          if (!(h2 ? To(h2, m2) : n(e[s], m2, r)))
            continue e;
        }
        p && p.push(m2), c2.push(d2);
      }
    }
  return c2;
}
var Cc = H$;
var Y$ = vi;
function J$(e) {
  return Y$(e) ? e : [];
}
var Ac = J$;
var X$ = Pt;
var Z$ = Cc;
var Q$ = Bt;
var e0 = Ac;
var t0 = Ql;
var r0 = Q$(function(e) {
  var t = t0(e), r = X$(e, e0);
  return t = typeof t == "function" ? t : void 0, t && r.pop(), r.length && r[0] === e[0] ? Z$(r, void 0, t) : [];
});
var Pc = r0;
var n0 = q;
var i0 = z;
var a0 = "[object Boolean]";
function s0(e) {
  return e === true || e === false || i0(e) && n0(e) == a0;
}
var o0 = s0;
var ct = re;
var l0 = Ec;
var Ha = $i;
var No = Ga;
var c0 = L$;
var u0 = Pc;
var ei = Fr;
var ki = o0;
var Do = (e) => Array.isArray(e) ? e : [e];
var tt = (e) => e === void 0;
var Nn = (e) => ei(e) || Array.isArray(e) ? Object.keys(e) : [];
var _r = (e, t) => e.hasOwnProperty(t);
var Cr = (e) => l0(Ha(e));
var Fo = (e) => tt(e) || Array.isArray(e) && e.length === 0;
var d0 = (e, t, r, n) => t && _r(t, r) && e && _r(e, r) && n(e[r], t[r]);
var Ri = (e, t) => tt(e) && t === 0 || tt(t) && e === 0 || ct(e, t);
var f0 = (e, t) => tt(e) && t === false || tt(t) && e === false || ct(e, t);
var ko = (e) => tt(e) || ct(e, {}) || e === true;
var Dn = (e) => tt(e) || ct(e, {});
var Ro = (e) => tt(e) || ei(e) || e === true || e === false;
function Mo(e, t) {
  return Fo(e) && Fo(t) ? true : ct(Cr(e), Cr(t));
}
function h0(e, t) {
  return e = Do(e), t = Do(t), ct(Cr(e), Cr(t));
}
function qn(e, t, r, n) {
  var i = Ha(Nn(e).concat(Nn(t)));
  return Dn(e) && Dn(t) ? true : Dn(e) && Nn(t).length || Dn(t) && Nn(e).length ? false : i.every(function(a) {
    var s = e[a], o = t[a];
    return Array.isArray(s) && Array.isArray(o) ? ct(Cr(e), Cr(t)) : Array.isArray(s) && !Array.isArray(o) || Array.isArray(o) && !Array.isArray(s) ? false : d0(e, t, a, n);
  });
}
function m0(e, t, r, n) {
  return ei(e) && ei(t) ? n(e, t) : Array.isArray(e) && Array.isArray(t) ? qn(e, t, r, n) : ct(e, t);
}
function Mi(e, t, r, n) {
  var i = No(e, n), a = No(t, n), s = u0(i, a, n);
  return s.length === Math.max(i.length, a.length);
}
var p0 = {
  title: ct,
  uniqueItems: f0,
  minLength: Ri,
  minItems: Ri,
  minProperties: Ri,
  required: Mo,
  enum: Mo,
  type: h0,
  items: m0,
  anyOf: Mi,
  allOf: Mi,
  oneOf: Mi,
  properties: qn,
  patternProperties: qn,
  dependencies: qn
};
var y0 = [
  "properties",
  "patternProperties",
  "dependencies",
  "uniqueItems",
  "minLength",
  "minItems",
  "minProperties",
  "required"
];
var g0 = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
function Zi(e, t, r) {
  if (r = c0(r, {
    ignore: []
  }), ko(e) && ko(t))
    return true;
  if (!Ro(e) || !Ro(t))
    throw new Error("Either of the values are not a JSON schema.");
  if (e === t)
    return true;
  if (ki(e) && ki(t))
    return e === t;
  if (e === void 0 && t === false || t === void 0 && e === false || tt(e) && !tt(t) || !tt(e) && tt(t))
    return false;
  var n = Ha(Object.keys(e).concat(Object.keys(t)));
  if (r.ignore.length && (n = n.filter((a) => r.ignore.indexOf(a) === -1)), !n.length)
    return true;
  function i(a, s) {
    return Zi(a, s, r);
  }
  return n.every(function(a) {
    var s = e[a], o = t[a];
    if (g0.indexOf(a) !== -1)
      return Zi(s, o, r);
    var l = p0[a];
    if (l || (l = ct), ct(s, o))
      return true;
    if (y0.indexOf(a) === -1 && (!_r(e, a) && _r(t, a) || _r(e, a) && !_r(t, a)))
      return s === o;
    var c2 = l(s, o, a, i);
    if (!ki(c2))
      throw new Error("Comparer must return true or false");
    return c2;
  });
}
var Ya = Zi;
function v0(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}
var Ja = Array.isArray || v0;
function $0(e) {
  return (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]") && e.valueOf() === e.valueOf();
}
var _0 = $0;
var b02 = _0;
function S0(e) {
  return b02(e) && e % 1 === 0;
}
var w0 = S0;
var E0 = Ja;
var O0 = w0;
function C0(e) {
  var t;
  if (!E0(e) || (t = e.length, !t))
    return false;
  for (var r = 0; r < t; r++)
    if (!O0(e[r]))
      return false;
  return true;
}
var Ic = C0;
function A0(e) {
  return typeof e == "function";
}
var Tc = A0;
var P0 = Ja;
var jo = Ic;
var I0 = Tc;
var Fn = Math.pow(2, 31) - 1;
function Uo(e, t) {
  var r = 1, n;
  if (e === 0)
    return t;
  if (t === 0)
    return e;
  for (; e % 2 === 0 && t % 2 === 0; )
    e = e / 2, t = t / 2, r = r * 2;
  for (; e % 2 === 0; )
    e = e / 2;
  for (; t; ) {
    for (; t % 2 === 0; )
      t = t / 2;
    e > t && (n = t, t = e, e = n), t = t - e;
  }
  return r * e;
}
function Vo(e, t) {
  var r = 0, n;
  if (e === 0)
    return t;
  if (t === 0)
    return e;
  for (; !(e & 1) && !(t & 1); )
    e >>>= 1, t >>>= 1, r++;
  for (; !(e & 1); )
    e >>>= 1;
  for (; t; ) {
    for (; !(t & 1); )
      t >>>= 1;
    e > t && (n = t, t = e, e = n), t = t - e;
  }
  return e << r;
}
function T0() {
  var e = arguments.length, t, r, n, i, a, s, o;
  for (t = new Array(e), o = 0; o < e; o++)
    t[o] = arguments[o];
  if (jo(t)) {
    if (e === 2)
      return a = t[0], s = t[1], a < 0 && (a = -a), s < 0 && (s = -s), a <= Fn && s <= Fn ? Vo(a, s) : Uo(a, s);
    n = t;
  } else if (P0(t[0]))
    if (e > 1) {
      if (n = t[0], r = t[1], !I0(r))
        throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + r + "`.");
    } else
      n = t[0];
  else
    throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + t[0] + "`.");
  if (i = n.length, i < 2)
    return null;
  if (r) {
    for (a = new Array(i), o = 0; o < i; o++)
      a[o] = r(n[o], o);
    n = a;
  }
  if (e < 3 && !jo(n))
    throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + n + "`.");
  for (o = 0; o < i; o++)
    a = n[o], a < 0 && (n[o] = -a);
  for (a = n[0], o = 1; o < i; o++)
    s = n[o], s <= Fn && a <= Fn ? a = Vo(a, s) : a = Uo(a, s);
  return a;
}
var N02 = T0;
var xo = N02;
var D0 = Ja;
var Lo = Ic;
var F0 = Tc;
function k0() {
  var e = arguments.length, t, r, n, i, a, s, o;
  for (t = new Array(e), o = 0; o < e; o++)
    t[o] = arguments[o];
  if (Lo(t)) {
    if (e === 2)
      return a = t[0], s = t[1], a < 0 && (a = -a), s < 0 && (s = -s), a === 0 || s === 0 ? 0 : a / xo(a, s) * s;
    n = t;
  } else if (D0(t[0]))
    if (e > 1) {
      if (n = t[0], r = t[1], !F0(r))
        throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + r + "`.");
    } else
      n = t[0];
  else
    throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + t[0] + "`.");
  if (i = n.length, i < 2)
    return null;
  if (r) {
    for (a = new Array(i), o = 0; o < i; o++)
      a[o] = r(n[o], o);
    n = a;
  }
  if (e < 3 && !Lo(n))
    throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + n + "`.");
  for (o = 0; o < i; o++)
    a = n[o], a < 0 && (n[o] = -a);
  for (a = n[0], o = 1; o < i; o++) {
    if (s = n[o], a === 0 || s === 0)
      return 0;
    a = a / xo(a, s) * s;
  }
  return a;
}
var R0 = k0;
var M0 = La;
var Bo = E;
function Nc(e, t, r, n, i, a) {
  return Bo(e) && Bo(t) && (a.set(t, e), M0(e, t, void 0, Nc, a), a.delete(t)), e;
}
var j0 = Nc;
var U0 = La;
var V0 = Sc;
var x0 = V0(function(e, t, r, n) {
  U0(e, t, r, n);
});
var L0 = x0;
var B0 = rc;
var q0 = Bt;
var K0 = j0;
var z0 = L0;
var W0 = q0(function(e) {
  return e.push(void 0, K0), B0(z0, void 0, e);
});
var G0 = W0;
var H02 = Pt;
var Y0 = Cc;
var J0 = Bt;
var X0 = Ac;
var Z0 = J0(function(e) {
  var t = H02(e, X0);
  return t.length && t[0] === e[0] ? Y0(t) : [];
});
var Q0 = Z0;
function e_(e, t, r, n) {
  for (var i = r - 1, a = e.length; ++i < a; )
    if (n(e[i], t))
      return i;
  return -1;
}
var t_ = e_;
var r_ = Pt;
var n_ = wc;
var i_ = t_;
var a_ = Vr;
var s_ = Xe;
var o_ = Array.prototype;
var qo = o_.splice;
function l_(e, t, r, n) {
  var i = n ? i_ : n_, a = -1, s = t.length, o = e;
  for (e === t && (t = s_(t)), r && (o = r_(e, a_(r))); ++a < s; )
    for (var l = 0, c2 = t[a], u = r ? r(c2) : c2; (l = i(o, u, l, n)) > -1; )
      o !== e && qo.call(o, l, 1), qo.call(e, l, 1);
  return e;
}
var c_ = l_;
var u_ = c_;
function d_(e, t) {
  return e && e.length && t && t.length ? u_(e, t) : e;
}
var f_ = d_;
var h_ = be;
var m_ = Ua;
var p_ = mc;
var y_ = J;
function g_(e, t) {
  var r = y_(e) ? h_ : m_;
  return r(e, p_(t));
}
var Dc = g_;
var v_ = fa;
var $_ = Ka;
var __ = za;
var b_ = Pt;
var S_ = Vr;
var w_ = la;
var E_ = 200;
function O_(e, t, r, n) {
  var i = -1, a = $_, s = true, o = e.length, l = [], c2 = t.length;
  if (!o)
    return l;
  r && (t = b_(t, S_(r))), n ? (a = __, s = false) : t.length >= E_ && (a = w_, s = false, t = new v_(t));
  e:
    for (; ++i < o; ) {
      var u = e[i], f = r == null ? u : r(u);
      if (u = n || u !== 0 ? u : 0, s && f === f) {
        for (var p = c2; p--; )
          if (t[p] === f)
            continue e;
        l.push(u);
      } else
        a(t, f, n) || l.push(u);
    }
  return l;
}
var C_ = O_;
var A_ = C_;
var P_ = Bt;
var I_ = vi;
var T_ = P_(function(e, t) {
  return I_(e) ? A_(e, t) : [];
});
var N_ = T_;
var D_ = Ra;
var F_ = qa;
var Fc = Fr;
var k_ = $i;
var R_ = Ga;
var M_ = N_;
function j_(e) {
  for (const t in e)
    kc(e, t) && Rc(e[t]) && delete e[t];
  return e;
}
var U_ = (e) => k_(F_(e.map(Xa)));
var V_ = (e, t) => e.map((r) => r && r[t]);
var kc = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
var Xa = (e) => Fc(e) || Array.isArray(e) ? Object.keys(e) : [];
var x_ = (e) => e !== void 0;
var L_ = (e) => Fc(e) || e === true || e === false;
var Rc = (e) => !Xa(e).length && e !== false && e !== true;
var B_ = (e, ...t) => M_.apply(null, [e].concat(D_(t)));
var Mc = {
  allUniqueKeys: U_,
  deleteUndefinedProps: j_,
  getValues: V_,
  has: kc,
  isEmptySchema: Rc,
  isSchema: L_,
  keys: Xa,
  notUndefined: x_,
  uniqWith: R_,
  withoutArr: B_
};
var q_ = Ya;
var K_ = Dc;
var {
  allUniqueKeys: z_,
  deleteUndefinedProps: W_,
  getValues: G_,
  keys: zr,
  notUndefined: H_,
  uniqWith: Y_,
  withoutArr: Ko
} = Mc;
function J_(e) {
  K_(e, function(t, r) {
    t === false && delete e[r];
  });
}
function zo(e, t) {
  return z_(e).reduce(function(n, i) {
    const a = G_(e, i), s = Y_(a.filter(H_), q_);
    return n[i] = t(s, i), n;
  }, {});
}
var X_ = {
  keywords: ["properties", "patternProperties", "additionalProperties"],
  resolver(e, t, r, n) {
    n.ignoreAdditionalProperties || (e.forEach(function(a) {
      const s = e.filter((u) => u !== a), o = zr(a.properties), c2 = zr(a.patternProperties).map((u) => new RegExp(u));
      s.forEach(function(u) {
        const f = zr(u.properties), p = f.filter((m2) => c2.some((h2) => h2.test(m2)));
        Ko(f, o, p).forEach(function(m2) {
          u.properties[m2] = r.properties([
            u.properties[m2],
            a.additionalProperties
          ], m2);
        });
      });
    }), e.forEach(function(a) {
      const s = e.filter((l) => l !== a), o = zr(a.patternProperties);
      a.additionalProperties === false && s.forEach(function(l) {
        const c2 = zr(l.patternProperties);
        Ko(c2, o).forEach((f) => delete l.patternProperties[f]);
      });
    }));
    const i = {
      additionalProperties: r.additionalProperties(e.map((a) => a.additionalProperties)),
      patternProperties: zo(e.map((a) => a.patternProperties), r.patternProperties),
      properties: zo(e.map((a) => a.properties), r.properties)
    };
    return i.additionalProperties === false && J_(i.properties), W_(i);
  }
};
var Z_ = Ya;
var Q_ = Dc;
var {
  allUniqueKeys: eb,
  deleteUndefinedProps: tb,
  has: rb,
  isSchema: jc,
  notUndefined: Uc,
  uniqWith: nb
} = Mc;
function ib(e) {
  Q_(e, function(t, r) {
    t === false && e.splice(r, 1);
  });
}
function ab(e, t) {
  return e.map(function(r) {
    if (r)
      if (Array.isArray(r.items)) {
        const n = r.items[t];
        if (jc(n))
          return n;
        if (rb(r, "additionalItems"))
          return r.additionalItems;
      } else
        return r.items;
  });
}
function sb(e) {
  return e.map(function(t) {
    if (t)
      return Array.isArray(t.items) ? t.additionalItems : t.items;
  });
}
function ob(e, t, r) {
  return eb(r).reduce(function(i, a) {
    const s = ab(e, a), o = nb(s.filter(Uc), Z_);
    return i[a] = t(o, a), i;
  }, []);
}
var lb = {
  keywords: ["items", "additionalItems"],
  resolver(e, t, r) {
    const n = e.map((o) => o.items), i = n.filter(Uc), a = {};
    i.every(jc) ? a.items = r.items(n) : a.items = ob(e, r.items, n);
    let s;
    return i.every(Array.isArray) ? s = e.map((o) => o.additionalItems) : i.some(Array.isArray) && (s = sb(e)), s && (a.additionalItems = r.additionalItems(s)), a.additionalItems === false && Array.isArray(a.items) && ib(a.items), tb(a);
  }
};
var Vc = Pa;
var ti = Ya;
var cb = R0;
var ub = G0;
var xc = Ra;
var Za = qa;
var db = Q0;
var fb = Pc;
var Qi = re;
var Ar = Fr;
var hb = f_;
var Lc = Ec;
var Qa = $i;
var br = Ga;
var Bc = X_;
var qc = lb;
var kn = (e, t) => e.indexOf(t) !== -1;
var mb = (e) => Ar(e) || e === true || e === false;
var pb = (e) => e === false;
var Kc = (e) => e === true;
var _i = (e, t, r) => r(e);
var zc = (e) => Lc(Qa(Za(e)));
var ri = (e) => e !== void 0;
var Wc = (e) => Qa(Za(e.map(bb)));
var Rr = (e) => e[0];
var yb = (e) => zc(e);
var pn = (e) => Math.max.apply(Math, e);
var yn = (e) => Math.min.apply(Math, e);
var gb = (e) => e.some(Kc);
var vb = (e) => br(xc(e), Qi);
function $b(e) {
  return function(t, r) {
    return ti({
      [e]: t
    }, { [e]: r });
  };
}
function Gc(e) {
  let { allOf: t = [], ...r } = e;
  return r = Ar(e) ? r : e, [r, ...t.map(Gc)];
}
function Hc(e, t) {
  return e.map((r) => r && r[t]);
}
function _b(e, t) {
  return e.map(function(r, n) {
    try {
      return t(r, n);
    } catch {
      return;
    }
  }).filter(ri);
}
function bb(e) {
  return Ar(e) || Array.isArray(e) ? Object.keys(e) : [];
}
function ea(e, t) {
  if (t = t || [], !e.length)
    return t;
  const r = e.slice(0).shift(), n = e.slice(1);
  return t.length ? ea(n, xc(t.map((i) => r.map((a) => [a].concat(i))))) : ea(n, r.map((i) => i));
}
function Yc(e, t) {
  let r;
  try {
    r = e.map(function(n) {
      return JSON.stringify(n, null, 2);
    }).join(`
`);
  } catch {
    r = e.join(", ");
  }
  throw new Error('Could not resolve values for path:"' + t.join(".") + `". They are probably incompatible. Values: 
` + r);
}
function Sb(e, t, r, n, i, a) {
  if (e.length) {
    const s = i.complexResolvers[t];
    if (!s || !s.resolver)
      throw new Error("No resolver found for " + t);
    const o = r.map((f) => e.reduce((p, d2) => (f[d2] !== void 0 && (p[d2] = f[d2]), p), {})), l = br(o, ti), c2 = s.keywords.reduce((f, p) => ({
      ...f,
      [p]: (d2, m2 = []) => n(d2, null, a.concat(p, m2))
    }), {}), u = s.resolver(l, a.concat(t), c2, i);
    return Ar(u) || Yc(l, a.concat(t)), u;
  }
}
function wb(e) {
  return { required: e };
}
var Eb = ["properties", "patternProperties", "definitions", "dependencies"];
var Ob = ["anyOf", "oneOf"];
var Cb = [
  "additionalProperties",
  "additionalItems",
  "contains",
  "propertyNames",
  "not",
  "items"
];
var he = {
  type(e) {
    if (e.some(Array.isArray)) {
      const t = e.map(function(n) {
        return Array.isArray(n) ? n : [n];
      }), r = db.apply(null, t);
      if (r.length === 1)
        return r[0];
      if (r.length > 1)
        return Qa(r);
    }
  },
  dependencies(e, t, r) {
    return Wc(e).reduce(function(i, a) {
      const s = Hc(e, a);
      let o = br(s.filter(ri), Qi);
      const l = o.filter(Array.isArray);
      if (l.length) {
        if (l.length === o.length)
          i[a] = zc(o);
        else {
          const c2 = o.filter(mb), u = l.map(wb);
          i[a] = r(c2.concat(u), a);
        }
        return i;
      }
      return o = br(o, ti), i[a] = r(o, a), i;
    }, {});
  },
  oneOf(e, t, r) {
    const n = ea(Vc(e)), i = _b(n, r), a = br(i, ti);
    if (a.length)
      return a;
  },
  not(e) {
    return { anyOf: e };
  },
  pattern(e) {
    return e.map((t) => "(?=" + t + ")").join("");
  },
  multipleOf(e) {
    let t = e.slice(0), r = 1;
    for (; t.some((n) => !Number.isInteger(n)); )
      t = t.map((n) => n * 10), r = r * 10;
    return cb(t) / r;
  },
  enum(e) {
    const t = fb.apply(null, e.concat(Qi));
    if (t.length)
      return Lc(t);
  }
};
he.$id = Rr;
he.$ref = Rr;
he.$schema = Rr;
he.additionalItems = _i;
he.additionalProperties = _i;
he.anyOf = he.oneOf;
he.contains = _i;
he.default = Rr;
he.definitions = he.dependencies;
he.description = Rr;
he.examples = vb;
he.exclusiveMaximum = yn;
he.exclusiveMinimum = pn;
he.items = qc;
he.maximum = yn;
he.maxItems = yn;
he.maxLength = yn;
he.maxProperties = yn;
he.minimum = pn;
he.minItems = pn;
he.minLength = pn;
he.minProperties = pn;
he.properties = Bc;
he.propertyNames = _i;
he.required = yb;
he.title = Rr;
he.uniqueItems = gb;
var Ab = {
  properties: Bc,
  items: qc
};
function es(e, t, r) {
  t = ub(t, {
    ignoreAdditionalProperties: false,
    resolvers: he,
    complexResolvers: Ab,
    deep: true
  });
  const n = Object.entries(t.complexResolvers);
  function i(o, l, c2) {
    o = Vc(o.filter(ri)), c2 = c2 || [];
    const u = Ar(l) ? l : {};
    if (!o.length)
      return;
    if (o.some(pb))
      return false;
    if (o.every(Kc))
      return true;
    o = o.filter(Ar);
    const f = Wc(o);
    if (t.deep && kn(f, "allOf"))
      return es({
        allOf: o
      }, t);
    const p = n.map(([d2, m2]) => f.filter((h2) => m2.keywords.includes(h2)));
    return p.forEach((d2) => hb(f, d2)), f.forEach(function(d2) {
      const m2 = Hc(o, d2), h2 = br(m2.filter(ri), $b(d2));
      if (h2.length === 1 && kn(Ob, d2))
        u[d2] = h2[0].map((g) => i([g], g));
      else if (h2.length === 1 && !kn(Eb, d2) && !kn(Cb, d2))
        u[d2] = h2[0];
      else {
        const g = t.resolvers[d2] || t.resolvers.defaultResolver;
        if (!g)
          throw new Error("No resolver found for key " + d2 + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
        const y2 = (v, b = []) => i(v, null, c2.concat(d2, b));
        u[d2] = g(h2, c2.concat(d2), y2, t), u[d2] === void 0 ? Yc(h2, c2.concat(d2)) : u[d2] === void 0 && delete u[d2];
      }
    }), n.reduce((d2, [m2, h2], g) => ({
      ...d2,
      ...Sb(p[g], m2, o, i, t, c2)
    }), u);
  }
  const a = Za(Gc(e));
  return i(a);
}
es.options = {
  resolvers: he
};
var Pb = es;
var Ib = sn2(Pb);
function Pr(e) {
  let t;
  const r = G2(e, "discriminator.propertyName", void 0);
  return ir(r) ? t = r : r !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof r}" instead`), t;
}
function rn(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
}
var Tb = gi;
var Nb = Bt;
var Db = Wa;
var Fb = vi;
var kb = Nb(function(e) {
  return Db(Tb(e, 1, Fb, true));
});
var Rb = kb;
var Mb = sn2(Rb);
function Lt(e) {
  let { type: t } = e;
  return !t && e.const ? rn(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((r) => r !== "null") : t = t[0]), t);
}
function At(e, t) {
  const r = Object.assign({}, e);
  return Object.keys(t).reduce((n, i) => {
    const a = e ? e[i] : {}, s = t[i];
    return e && i in e && Se(s) ? n[i] = At(a, s) : e && t && (Lt(e) === "object" || Lt(t) === "object") && i === Rf && Array.isArray(a) && Array.isArray(s) ? n[i] = Mb(a, s) : n[i] = s, n;
  }, r);
}
function Ge(e, t, r = {}, n) {
  return yt2(e, t, r, n)[0];
}
function jb(e, t, r, n, i, a) {
  const { if: s, then: o, else: l, ...c2 } = t, u = e.isValid(s, a || {}, r);
  let f = [c2], p = [];
  if (n)
    o && typeof o != "boolean" && (p = p.concat(yt2(e, o, r, a, n, i))), l && typeof l != "boolean" && (p = p.concat(yt2(e, l, r, a, n, i)));
  else {
    const d2 = u ? o : l;
    d2 && typeof d2 != "boolean" && (p = p.concat(yt2(e, d2, r, a, n, i)));
  }
  return p.length && (f = p.map((d2) => At(c2, d2))), f.flatMap((d2) => yt2(e, d2, r, a, n, i));
}
function Jc(e) {
  return e.reduce(
    (r, n) => n.length > 1 ? n.flatMap((i) => pc(r.length, (a) => [...r[a]].concat(i))) : (r.forEach((i) => i.push(n[0])), r),
    [[]]
    // Start with an empty list
  );
}
function Ub(e, t, r, n, i, a) {
  const s = Xc(e, t, r, n, i, a);
  if (s.length > 1 || s[0] !== t)
    return s;
  if (pi in t)
    return Zc(e, t, r, n, i, a).flatMap((l) => yt2(e, l, r, a, n, i));
  if (fn in t && Array.isArray(t.allOf)) {
    const o = t.allOf.map((c2) => yt2(e, c2, r, a, n, i));
    return Jc(o).map((c2) => ({ ...t, allOf: c2 }));
  }
  return [t];
}
function Xc(e, t, r, n, i, a) {
  const s = nn2(t, r, i);
  return s !== t ? yt2(e, s, r, a, n, i) : [t];
}
function nn2(e, t, r) {
  if (!Se(e))
    return e;
  let n = e;
  if (Te in n) {
    const { $ref: i, ...a } = n;
    if (r.includes(i))
      return n;
    r.push(i), n = { ...oc(i, t), ...a };
  }
  if (Oe in n) {
    const i = [], a = Dg(n[Oe], (s, o, l) => {
      const c2 = [...r];
      s[l] = nn2(o, t, c2), i.push(c2);
    }, {});
    Cv(r, o$(Tv(i))), n = { ...n, [Oe]: a };
  }
  return Ut in n && !Array.isArray(n.items) && typeof n.items != "boolean" && (n = {
    ...n,
    items: nn2(n.items, t, r)
  }), ie(e, n) ? e : n;
}
function Vb(e, t, r, n) {
  const i = {
    ...t,
    properties: { ...t.properties }
  }, a = n && Se(n) ? n : {};
  return Object.keys(a).forEach((s) => {
    if (s in i.properties)
      return;
    let o = {};
    typeof i.additionalProperties != "boolean" ? Te in i.additionalProperties ? o = Ge(e, { $ref: G2(i.additionalProperties, [Te]) }, r, a) : "type" in i.additionalProperties ? o = { ...i.additionalProperties } : pt in i.additionalProperties || et in i.additionalProperties ? o = {
      type: "object",
      ...i.additionalProperties
    } : o = { type: rn(G2(a, [s])) } : o = { type: rn(G2(a, [s])) }, i.properties[s] = o, je(i.properties, [s, Dr], true);
  }), i;
}
function yt2(e, t, r, n, i = false, a = []) {
  return Se(t) ? Ub(e, t, r, i, a, n).flatMap((o) => {
    let l = o;
    if (Ff in l)
      return jb(e, l, r, i, a, n);
    if (fn in l) {
      if (i) {
        const { allOf: u, ...f } = l;
        return [...u, f];
      }
      try {
        l = Ib(l, {
          deep: false
        });
      } catch (u) {
        console.warn(`could not merge subschemas in allOf:
`, u);
        const { allOf: f, ...p } = l;
        return p;
      }
    }
    return Ji in l && l.additionalProperties !== false ? Vb(e, l, r, n) : l;
  }) : [{}];
}
function xb(e, t, r, n, i) {
  let a;
  const { oneOf: s, anyOf: o, ...l } = t;
  if (Array.isArray(s) ? a = s : Array.isArray(o) && (a = o), a) {
    const c2 = i === void 0 && n ? {} : i, u = Pr(t);
    a = a.map((p) => nn2(p, r, []));
    const f = xa(e, c2, a, r, u);
    if (n)
      return a.map((p) => At(l, p));
    t = At(l, a[f]);
  }
  return [t];
}
function Zc(e, t, r, n, i, a) {
  const { dependencies: s, ...o } = t;
  return xb(e, o, r, n, a).flatMap((c2) => Qc(e, s, c2, r, n, i, a));
}
function Qc(e, t, r, n, i, a, s) {
  let o = [r];
  for (const l in t) {
    if (!i && G2(s, [l]) === void 0 || r.properties && !(l in r.properties))
      continue;
    const [c2, u] = Ma(l, t);
    return Array.isArray(u) ? o[0] = Lb(r, u) : Se(u) && (o = Bb(e, r, n, l, u, i, a, s)), o.flatMap((f) => Qc(e, c2, f, n, i, a, s));
  }
  return o;
}
function Lb(e, t) {
  if (!t)
    return e;
  const r = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
  return { ...e, required: r };
}
function Bb(e, t, r, n, i, a, s, o) {
  return yt2(e, i, r, o, a, s).flatMap((c2) => {
    const { oneOf: u, ...f } = c2;
    if (t = At(t, f), u === void 0)
      return t;
    const p = u.map((m2) => typeof m2 == "boolean" || !(Te in m2) ? [m2] : Xc(e, m2, r, a, s, o));
    return Jc(p).flatMap((m2) => qb(e, t, r, n, m2, a, s, o));
  });
}
function qb(e, t, r, n, i, a, s, o) {
  const l = i.filter((c2) => {
    if (typeof c2 == "boolean" || !c2 || !c2.properties)
      return false;
    const { [n]: u } = c2.properties;
    if (u) {
      const f = {
        type: "object",
        properties: {
          [n]: u
        }
      };
      return e.isValid(f, o, r) || a;
    }
    return false;
  });
  return !a && l.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : l.flatMap((c2) => {
    const u = c2, [f] = Ma(n, u.properties), p = { ...u, properties: f };
    return yt2(e, p, r, o, a, s).map((m2) => At(t, m2));
  });
}
var Kb = {
  type: "object",
  $id: kf,
  properties: {
    __not_really_there__: {
      type: "number"
    }
  }
};
function ta(e, t, r, n = {}) {
  let i = 0;
  return r && (A(r.properties) ? i += Yy(r.properties, (a, s, o) => {
    const l = G2(n, o);
    if (typeof s == "boolean")
      return a;
    if (Le(s, Te)) {
      const c2 = Ge(e, s, t, l);
      return a + ta(e, t, c2, l || {});
    }
    if ((Le(s, et) || Le(s, pt)) && l) {
      const c2 = Le(s, et) ? et : pt, u = Pr(s);
      return a + an2(e, t, l, G2(s, c2), -1, u);
    }
    if (s.type === "object")
      return a + ta(e, t, s, l || {});
    if (s.type === rn(l)) {
      let c2 = a + 1;
      return s.default ? c2 += l === s.default ? 1 : -1 : s.const && (c2 += l === s.const ? 1 : -1), c2;
    }
    return a;
  }, 0) : ir(r.type) && r.type === rn(n) && (i += 1)), i;
}
function an2(e, t, r, n, i = -1, a) {
  const s = n.map((f) => nn2(f, t, [])), o = yc(r, n, a);
  if (ja(o))
    return o;
  const l = s.reduce((f, p, d2) => (xa(e, r, [Kb, p], t, a) === 1 && f.push(d2), f), []);
  if (l.length === 1)
    return l[0];
  l.length || pc(s.length, (f) => l.push(f));
  const c2 = /* @__PURE__ */ new Set(), { bestIndex: u } = l.reduce((f, p) => {
    const { bestScore: d2 } = f, m2 = s[p], h2 = ta(e, t, m2, r);
    return c2.add(h2), h2 > d2 ? { bestIndex: p, bestScore: h2 } : f;
  }, { bestIndex: i, bestScore: 0 });
  return c2.size === 1 && i >= 0 ? i : u;
}
function ra(e) {
  return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => Se(t));
}
function ni(e, t, r = false) {
  if (Array.isArray(t)) {
    const n = Array.isArray(e) ? e : [], i = t.map((a, s) => n[s] ? ni(n[s], a, r) : a);
    return r && i.length < n.length && i.push(...n.slice(i.length)), i;
  }
  if (Se(t)) {
    const n = Object.assign({}, e);
    return Object.keys(t).reduce((i, a) => (i[a] = ni(e ? G2(e, a) : {}, G2(t, a), r), i), n);
  }
  return t;
}
function Mr(e, t, r = false) {
  return Object.keys(t).reduce((n, i) => {
    const a = e ? e[i] : {}, s = t[i];
    if (e && i in e && Se(s))
      n[i] = Mr(a, s, r);
    else if (r && Array.isArray(a) && Array.isArray(s)) {
      let o = s;
      r === "preventDuplicates" && (o = s.reduce((l, c2) => (a.includes(c2) || l.push(c2), l), [])), n[i] = a.concat(o);
    } else
      n[i] = s;
    return n;
  }, Object.assign({}, e));
}
function zb(e) {
  return Array.isArray(e.enum) && e.enum.length === 1 || Ll in e;
}
function eu(e, t, r = {}) {
  const n = Ge(e, t, r, void 0), i = n.oneOf || n.anyOf;
  return Array.isArray(n.enum) ? true : Array.isArray(i) ? i.every((a) => typeof a != "boolean" && zb(a)) : false;
}
function ts(e, t, r) {
  return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? false : eu(e, t.items, r);
}
var Ir;
(function(e) {
  e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
})(Ir || (Ir = {}));
function ji(e, t = Ir.Ignore, r = -1) {
  if (r >= 0) {
    if (Array.isArray(e.items) && r < e.items.length) {
      const n = e.items[r];
      if (typeof n != "boolean")
        return n;
    }
  } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
    return e.items;
  return t !== Ir.Ignore && Se(e.additionalItems) ? e.additionalItems : {};
}
function Wo(e, t, r, n, i, a = [], s = {}) {
  const { emptyObjectFields: o = "populateAllDefaults" } = s;
  if (n)
    e[t] = r;
  else if (o !== "skipDefaults")
    if (Se(r)) {
      const l = i === void 0 ? a.includes(t) : i;
      o === "skipEmptyDefaults" ? xt(r) || (e[t] = r) : (!xt(r) || a.includes(t)) && (l || o !== "populateRequiredDefaults") && (e[t] = r);
    } else
      r !== void 0 && (o === "populateAllDefaults" || o === "skipEmptyDefaults" || a.includes(t)) && (e[t] = r);
}
function Rt(e, t, { parentDefaults: r, rawFormData: n, rootSchema: i = {}, includeUndefinedValues: a = false, _recurseList: s = [], experimental_defaultFormStateBehavior: o = void 0, required: l } = {}) {
  var c2, u, f, p;
  const d2 = Se(n) ? n : {}, m2 = Se(t) ? t : {};
  let h2 = r, g = null, y2 = s;
  if (Se(h2) && Se(m2.default))
    h2 = Mr(h2, m2.default);
  else if (Nf in m2)
    h2 = m2.default;
  else if (Te in m2) {
    const v = m2[Te];
    s.includes(v) || (y2 = s.concat(v), g = oc(v, i));
  } else if (pi in m2)
    g = Zc(e, m2, i, false, [], d2)[0];
  else if (ra(m2))
    h2 = m2.items.map((v, b) => Rt(e, v, {
      rootSchema: i,
      includeUndefinedValues: a,
      _recurseList: s,
      experimental_defaultFormStateBehavior: o,
      parentDefaults: Array.isArray(r) ? r[b] : void 0,
      rawFormData: d2,
      required: l
    }));
  else if (et in m2) {
    const { oneOf: v, ...b } = m2;
    if (v.length === 0)
      return;
    const w = Pr(m2);
    g = v[an2(e, i, xt(d2) ? void 0 : d2, v, 0, w)], g = At(b, g);
  } else if (pt in m2) {
    const { anyOf: v, ...b } = m2;
    if (v.length === 0)
      return;
    const w = Pr(m2);
    g = v[an2(e, i, xt(d2) ? void 0 : d2, v, 0, w)], g = At(b, g);
  }
  if (g)
    return Rt(e, g, {
      rootSchema: i,
      includeUndefinedValues: a,
      _recurseList: y2,
      experimental_defaultFormStateBehavior: o,
      parentDefaults: h2,
      rawFormData: d2,
      required: l
    });
  switch (h2 === void 0 && (h2 = m2.default), Lt(m2)) {
    case "object": {
      const v = (o == null ? void 0 : o.allOf) === "populateDefaults" && fn in m2 ? Ge(e, m2, i, d2) : m2, b = Object.keys(v.properties || {}).reduce((w, C) => {
        var E2;
        const _3 = Rt(e, G2(v, [Oe, C]), {
          rootSchema: i,
          _recurseList: s,
          experimental_defaultFormStateBehavior: o,
          includeUndefinedValues: a === true,
          parentDefaults: G2(h2, [C]),
          rawFormData: G2(d2, [C]),
          required: (E2 = v.required) === null || E2 === void 0 ? void 0 : E2.includes(C)
        });
        return Wo(w, C, _3, a, l, v.required, o), w;
      }, {});
      if (v.additionalProperties) {
        const w = Se(v.additionalProperties) ? v.additionalProperties : {}, C = /* @__PURE__ */ new Set();
        Se(h2) && Object.keys(h2).filter((_3) => !v.properties || !v.properties[_3]).forEach((_3) => C.add(_3));
        const E2 = [];
        Object.keys(d2).filter((_3) => !v.properties || !v.properties[_3]).forEach((_3) => {
          C.add(_3), E2.push(_3);
        }), C.forEach((_3) => {
          var T;
          const F = Rt(e, w, {
            rootSchema: i,
            _recurseList: s,
            experimental_defaultFormStateBehavior: o,
            includeUndefinedValues: a === true,
            parentDefaults: G2(h2, [_3]),
            rawFormData: G2(d2, [_3]),
            required: (T = v.required) === null || T === void 0 ? void 0 : T.includes(_3)
          });
          Wo(b, _3, F, a, l, E2);
        });
      }
      return b;
    }
    case "array": {
      const v = ((c2 = o == null ? void 0 : o.arrayMinItems) === null || c2 === void 0 ? void 0 : c2.populate) === "never", b = ((u = o == null ? void 0 : o.arrayMinItems) === null || u === void 0 ? void 0 : u.populate) === "requiredOnly", w = (o == null ? void 0 : o.emptyObjectFields) === "skipEmptyDefaults", C = (p = (f = o == null ? void 0 : o.arrayMinItems) === null || f === void 0 ? void 0 : f.computeSkipPopulate) !== null && p !== void 0 ? p : () => false, E2 = w ? void 0 : [];
      if (Array.isArray(h2) && (h2 = h2.map((U, W) => {
        const z2 = ji(m2, Ir.Fallback, W);
        return Rt(e, z2, {
          rootSchema: i,
          _recurseList: s,
          experimental_defaultFormStateBehavior: o,
          parentDefaults: U,
          required: l
        });
      })), Array.isArray(n)) {
        const U = ji(m2);
        v ? h2 = n : h2 = n.map((W, z2) => Rt(e, U, {
          rootSchema: i,
          _recurseList: s,
          experimental_defaultFormStateBehavior: o,
          rawFormData: W,
          parentDefaults: G2(h2, [z2]),
          required: l
        }));
      }
      if (v)
        return h2 ?? E2;
      if (b && !l)
        return h2 || void 0;
      const _3 = Array.isArray(h2) ? h2.length : 0;
      if (!m2.minItems || ts(e, m2, i) || C(e, m2, i) || m2.minItems <= _3)
        return h2 || E2;
      const T = h2 || [], F = ji(m2, Ir.Invert), j2 = F.default, L = new Array(m2.minItems - _3).fill(Rt(e, F, {
        parentDefaults: j2,
        rootSchema: i,
        _recurseList: s,
        experimental_defaultFormStateBehavior: o,
        required: l
      }));
      return T.concat(L);
    }
  }
  return h2;
}
function tu(e, t, r, n, i = false, a) {
  if (!Se(t))
    throw new Error("Invalid schema: " + t);
  const s = Ge(e, t, n, r), o = Rt(e, s, {
    rootSchema: n,
    includeUndefinedValues: i,
    experimental_defaultFormStateBehavior: a,
    rawFormData: r
  });
  if (r == null || typeof r == "number" && isNaN(r))
    return o;
  const { mergeExtraDefaults: l } = (a == null ? void 0 : a.arrayMinItems) || {};
  return Se(r) || Array.isArray(r) ? ni(o, r, l) : r;
}
function ru(e = {}) {
  return (
    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
    "widget" in oe(e) && oe(e).widget !== "hidden"
  );
}
function nu(e, t, r = {}, n) {
  if (r[Ta] === "files")
    return true;
  if (t.items) {
    const i = Ge(e, t.items, n);
    return i.type === "string" && i.format === "data-url";
  }
  return false;
}
function Wb(e, t, r = {}, n, i) {
  const a = oe(r, i), { label: s = true } = a;
  let o = !!s;
  const l = Lt(t);
  return l === "array" && (o = ts(e, t, n) || nu(e, t, r, n) || ru(r)), l === "object" && (o = false), l === "boolean" && !r[Ta] && (o = false), r[Mf] && (o = false), o;
}
function Gb(e, t, r) {
  if (!r)
    return t;
  const { errors: n, errorSchema: i } = t;
  let a = e.toErrorList(r), s = r;
  return xt(i) || (s = Mr(i, r, true), a = [...n].concat(a)), { errorSchema: s, errors: a };
}
var pr2 = Symbol("no Value");
function na(e, t, r, n, i = {}) {
  let a;
  if (Le(r, Oe)) {
    const s = {};
    if (Le(n, Oe)) {
      const c2 = G2(n, Oe, {});
      Object.keys(c2).forEach((u) => {
        Le(i, u) && (s[u] = void 0);
      });
    }
    const o = Object.keys(G2(r, Oe, {})), l = {};
    o.forEach((c2) => {
      const u = G2(i, c2);
      let f = G2(n, [Oe, c2], {}), p = G2(r, [Oe, c2], {});
      Le(f, Te) && (f = Ge(e, f, t, u)), Le(p, Te) && (p = Ge(e, p, t, u));
      const d2 = G2(f, "type"), m2 = G2(p, "type");
      if (!d2 || d2 === m2)
        if (Le(s, c2) && delete s[c2], m2 === "object" || m2 === "array" && Array.isArray(u)) {
          const h2 = na(e, t, p, f, u);
          (h2 !== void 0 || m2 === "array") && (l[c2] = h2);
        } else {
          const h2 = G2(p, "default", pr2), g = G2(f, "default", pr2);
          h2 !== pr2 && h2 !== u && (g === u ? s[c2] = h2 : G2(p, "readOnly") === true && (s[c2] = void 0));
          const y2 = G2(p, "const", pr2), v = G2(f, "const", pr2);
          y2 !== pr2 && y2 !== u && (s[c2] = v === u ? y2 : void 0);
        }
    }), a = {
      ...typeof i == "string" || Array.isArray(i) ? void 0 : i,
      ...s,
      ...l
    };
  } else if (G2(n, "type") === "array" && G2(r, "type") === "array" && Array.isArray(i)) {
    let s = G2(n, "items"), o = G2(r, "items");
    if (typeof s == "object" && typeof o == "object" && !Array.isArray(s) && !Array.isArray(o)) {
      Le(s, Te) && (s = Ge(e, s, t, i)), Le(o, Te) && (o = Ge(e, o, t, i));
      const l = G2(s, "type"), c2 = G2(o, "type");
      if (!l || l === c2) {
        const u = G2(r, "maxItems", -1);
        c2 === "object" ? a = i.reduce((f, p) => {
          const d2 = na(e, t, o, s, p);
          return d2 !== void 0 && (u < 0 || f.length < u) && f.push(d2), f;
        }, []) : a = u > 0 && i.length > u ? i.slice(0, u) : i;
      }
    } else
      typeof s == "boolean" && typeof o == "boolean" && s === o && (a = i);
  }
  return a;
}
function Kn(e, t, r, n, i, a, s, o = []) {
  if (Te in t || pi in t || fn in t) {
    const u = Ge(e, t, a, s);
    if (o.findIndex((p) => ie(p, u)) === -1)
      return Kn(e, u, r, n, i, a, s, o.concat(u));
  }
  if (Ut in t && !G2(t, [Ut, Te]))
    return Kn(e, G2(t, Ut), r, n, i, a, s, o);
  const c2 = { $id: i || r };
  if (Lt(t) === "object" && Oe in t)
    for (const u in t.properties) {
      const f = G2(t, [Oe, u]), p = c2[Mt] + n + u;
      c2[u] = Kn(
        e,
        Se(f) ? f : {},
        r,
        n,
        p,
        a,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        G2(s, [u]),
        o
      );
    }
  return c2;
}
function Hb(e, t, r, n, i, a = "root", s = "_") {
  return Kn(e, t, a, s, r, n, i);
}
function Zt(e, t, r, n, i, a = []) {
  if (Te in t || pi in t || fn in t) {
    const o = Ge(e, t, n, i);
    if (a.findIndex((c2) => ie(c2, o)) === -1)
      return Zt(e, o, r, n, i, a.concat(o));
  }
  let s = {
    [Bn]: r.replace(/^\./, "")
  };
  if (et in t || pt in t) {
    const o = et in t ? t.oneOf : t.anyOf, l = Pr(t), c2 = an2(e, n, i, o, 0, l), u = o[c2];
    s = {
      ...s,
      ...Zt(e, u, r, n, i, a)
    };
  }
  if (Ji in t && t[Ji] !== false && je(s, Ia, true), Ut in t && Array.isArray(i)) {
    const { items: o, additionalItems: l } = t;
    Array.isArray(o) ? i.forEach((c2, u) => {
      o[u] ? s[u] = Zt(e, o[u], `${r}.${u}`, n, c2, a) : l ? s[u] = Zt(e, l, `${r}.${u}`, n, c2, a) : console.warn(`Unable to generate path schema for "${r}.${u}". No schema defined for it`);
    }) : i.forEach((c2, u) => {
      s[u] = Zt(e, o, `${r}.${u}`, n, c2, a);
    });
  } else if (Oe in t)
    for (const o in t.properties) {
      const l = G2(t, [Oe, o]);
      s[o] = Zt(
        e,
        l,
        `${r}.${o}`,
        n,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        G2(i, [o]),
        a
      );
    }
  return s;
}
function Yb(e, t, r = "", n, i) {
  return Zt(e, t, r, n, i);
}
var Jb = class {
  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
   * @param rootSchema - The root schema that will be forwarded to all the APIs
   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
   */
  constructor(t, r, n) {
    this.rootSchema = r, this.validator = t, this.experimental_defaultFormStateBehavior = n;
  }
  /** Returns the `ValidatorType` in the `SchemaUtilsType`
   *
   * @returns - The `ValidatorType`
   */
  getValidator() {
    return this.validator;
  }
  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
   * of a new `SchemaUtilsType` with incomplete properties.
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
   * @param rootSchema - The root schema that will be compared against the current one
   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
   */
  doesSchemaUtilsDiffer(t, r, n = {}) {
    return !t || !r ? false : this.validator !== t || !Be(this.rootSchema, r) || !Be(this.experimental_defaultFormStateBehavior, n);
  }
  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
   * computed to have defaults provided in the `schema`.
   *
   * @param schema - The schema for which the default state is desired
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
   *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
   *          object properties.
   * @returns - The resulting `formData` with all the defaults provided
   */
  getDefaultFormState(t, r, n = false) {
    return tu(this.validator, t, r, this.rootSchema, n, this.experimental_defaultFormStateBehavior);
  }
  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
   * should be displayed in a UI.
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [uiSchema] - The UI schema from which to derive potentially displayable information
   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
   * @returns - True if the label should be displayed or false if it should not
   */
  getDisplayLabel(t, r, n) {
    return Wb(this.validator, t, r, this.rootSchema, n);
  }
  /** Determines which of the given `options` provided most closely matches the `formData`.
   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
   *
   * The closest match is determined using the number of matching properties, and more heavily favors options with
   * matching readOnly, default, or const values.
   *
   * @param formData - The form data associated with the schema
   * @param options - The list of options that can be selected from
   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
   */
  getClosestMatchingOption(t, r, n, i) {
    return an2(this.validator, this.rootSchema, t, r, n, i);
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
   * Always returns the first option if there is nothing that matches.
   *
   * @param formData - The current formData, if any, used to figure out a match
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The firstindex of the matched option or 0 if none is available
   */
  getFirstMatchingOption(t, r, n) {
    return xa(this.validator, t, r, this.rootSchema, n);
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.
   * Deprecated, use `getFirstMatchingOption()` instead.
   *
   * @param formData - The current formData, if any, onto which to provide any missing defaults
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the matched option or 0 if none is available
   * @deprecated
   */
  getMatchingOption(t, r, n) {
    return gc(this.validator, t, r, this.rootSchema, n);
  }
  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
   *
   * @param schema - The schema for which check for array of files flag is desired
   * @param [uiSchema] - The UI schema from which to check the widget
   * @returns - True if schema/uiSchema contains an array of files, otherwise false
   */
  isFilesArray(t, r) {
    return nu(this.validator, t, r, this.rootSchema);
  }
  /** Checks to see if the `schema` combination represents a multi-select
   *
   * @param schema - The schema for which check for a multi-select flag is desired
   * @returns - True if schema contains a multi-select, otherwise false
   */
  isMultiSelect(t) {
    return ts(this.validator, t, this.rootSchema);
  }
  /** Checks to see if the `schema` combination represents a select
   *
   * @param schema - The schema for which check for a select flag is desired
   * @returns - True if schema contains a select, otherwise false
   */
  isSelect(t) {
    return eu(this.validator, t, this.rootSchema);
  }
  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in
   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling
   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,
   * then `validationData` is returned.
   *
   * @param validationData - The current `ValidationData` into which to merge the additional errors
   * @param [additionalErrorSchema] - The additional set of errors
   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.
   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be
   *        removed in the next major release.
   */
  mergeValidationData(t, r) {
    return Gb(this.validator, t, r);
  }
  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
   * recursive resolution.
   *
   * @param schema - The schema for which retrieving a schema is desired
   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
   * @returns - The schema having its conditions, additional properties, references and dependencies resolved
   */
  retrieveSchema(t, r) {
    return Ge(this.validator, t, this.rootSchema, r);
  }
  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
   * old schemas that are non-existent in the new schema are set to `undefined`.
   *
   * @param [newSchema] - The new schema for which the data is being sanitized
   * @param [oldSchema] - The old schema from which the data originated
   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
   * @returns - The new form data, with all the fields uniquely associated with the old schema set
   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
   */
  sanitizeDataForNewSchema(t, r, n) {
    return na(this.validator, this.rootSchema, t, r, n);
  }
  /** Generates an `IdSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [id] - The base id for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [idPrefix='root'] - The prefix to use for the id
   * @param [idSeparator='_'] - The separator to use for the path segments in the id
   * @returns - The `IdSchema` object for the `schema`
   */
  toIdSchema(t, r, n, i = "root", a = "_") {
    return Hb(this.validator, t, r, this.rootSchema, n, i, a);
  }
  /** Generates an `PathSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [name] - The base name for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @returns - The `PathSchema` object for the `schema`
   */
  toPathSchema(t, r, n) {
    return Yb(this.validator, t, r, this.rootSchema, n);
  }
};
function Xb(e, t, r = {}) {
  return new Jb(e, t, r);
}
function Zb(e) {
  var t;
  if (e.indexOf("data:") === -1)
    throw new Error("File is invalid: URI must be a dataURI");
  const n = e.slice(5).split(";base64,");
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [i, a] = n, [s, ...o] = i.split(";"), l = s || "", c2 = decodeURI(
    // parse the parameters into key-value pairs, find a key, and extract a value
    // if no key is found, then the name is unknown
    ((t = o.map((u) => u.split("=")).find(([u]) => u === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
  );
  try {
    const u = atob(a), f = new Array(u.length);
    for (let d2 = 0; d2 < u.length; d2++)
      f[d2] = u.charCodeAt(d2);
    return { blob: new window.Blob([new Uint8Array(f)], { type: l }), name: c2 };
  } catch (u) {
    throw new Error("File is invalid: " + u.message);
  }
}
function Qb(e, t) {
  let r = e;
  if (Array.isArray(t)) {
    const n = r.split(/(%\d)/);
    t.forEach((i, a) => {
      const s = n.findIndex((o) => o === `%${a + 1}`);
      s >= 0 && (n[s] = i);
    }), r = n.join("");
  }
  return r;
}
function e1(e, t) {
  return Qb(e, t);
}
function Ne(e, t = [], r) {
  if (Array.isArray(e))
    return e.map((a) => Ne(a, t)).filter((a) => a !== r);
  const n = e === "" || e === null ? -1 : Number(e), i = t[n];
  return i ? i.value : r;
}
function t1(e, t, r = []) {
  const n = Ne(e, r);
  return Array.isArray(t) ? t.filter((i) => !ie(i, n)) : ie(n, t) ? void 0 : t;
}
function rs(e, t) {
  return Array.isArray(t) ? t.some((r) => ie(r, e)) : ie(t, e);
}
function bi(e, t = [], r = false) {
  const n = t.map((i, a) => rs(i.value, e) ? String(a) : void 0).filter((i) => typeof i < "u");
  return r ? n : n[0];
}
function r1(e) {
  return e == null;
}
var n1 = r1;
var i1 = sn2(n1);
function a1(e, t, r = []) {
  const n = Ne(e, r);
  if (!i1(n)) {
    const i = r.findIndex((o) => n === o.value), a = r.map(({ value: o }) => o);
    return t.slice(0, i).concat(n, t.slice(i)).sort((o, l) => +(a.indexOf(o) > a.indexOf(l)));
  }
  return t;
}
var s1 = class {
  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   */
  constructor(t) {
    this.errorSchema = {}, this.resetAllErrors(t);
  }
  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
   */
  get ErrorSchema() {
    return this.errorSchema;
  }
  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The error block for the given `pathOfError` or the root if not provided
   * @private
   */
  getOrCreateErrorBlock(t) {
    let n = Array.isArray(t) && t.length > 0 || typeof t == "string" ? G2(this.errorSchema, t) : this.errorSchema;
    return !n && t && (n = {}, je(this.errorSchema, t, n)), n;
  }
  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  resetAllErrors(t) {
    return this.errorSchema = t ? Ba(t) : {}, this;
  }
  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
   * the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  addErrors(t, r) {
    const n = this.getOrCreateErrorBlock(r);
    let i = G2(n, ot);
    return Array.isArray(i) || (i = [], n[ot] = i), Array.isArray(t) ? i.push(...t) : i.push(t), this;
  }
  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
   * within the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  setErrors(t, r) {
    const n = this.getOrCreateErrorBlock(r), i = Array.isArray(t) ? [...t] : [t];
    return je(n, ot, i), this;
  }
  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
   * the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  clearErrors(t) {
    const r = this.getOrCreateErrorBlock(t);
    return je(r, ot, []), this;
  }
};
function iu(e, t, r = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], n = "YMD") {
  const { day: i, month: a, year: s, hour: o, minute: l, second: c2 } = e, u = { type: "day", range: [1, 31], value: i }, f = { type: "month", range: [1, 12], value: a }, p = { type: "year", range: r, value: s }, d2 = [];
  switch (n) {
    case "MDY":
      d2.push(f, u, p);
      break;
    case "DMY":
      d2.push(u, f, p);
      break;
    case "YMD":
    default:
      d2.push(p, f, u);
  }
  return t && d2.push({ type: "hour", range: [0, 23], value: o }, { type: "minute", range: [0, 59], value: l }, { type: "second", range: [0, 59], value: c2 }), d2;
}
function au(e) {
  const t = {};
  return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
}
function su(e, t, r = {}, n = true) {
  const i = {
    type: t || "text",
    ...au(e)
  };
  return r.inputType ? i.type = r.inputType : t || (e.type === "number" ? (i.type = "number", n && i.step === void 0 && (i.step = "any")) : e.type === "integer" && (i.type = "number", i.step === void 0 && (i.step = 1))), r.autocomplete && (i.autoComplete = r.autocomplete), i;
}
var Go = {
  props: {
    disabled: false
  },
  submitText: "Submit",
  norender: false
};
function ou(e = {}) {
  const t = oe(e);
  if (t && t[Zn]) {
    const r = t[Zn];
    return { ...Go, ...r };
  }
  return Go;
}
function ce(e, t, r = {}) {
  const { templates: n } = t;
  return e === "ButtonTemplates" ? n[e] : (
    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
    // To avoid that, we cast uiOptions to `any` before accessing the name field
    r[e] || n[e]
  );
}
var Ui = {
  boolean: {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    time: "TimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
function o1(e) {
  let t = G2(e, "MergedWidget");
  if (!t) {
    const r = e.defaultProps && e.defaultProps.options || {};
    t = ({ options: n, ...i }) => d(e, { options: { ...r, ...n }, ...i }), je(e, "MergedWidget", t);
  }
  return t;
}
function Et(e, t, r = {}) {
  const n = Lt(e);
  if (typeof t == "function" || t && v0r.isForwardRef((0, import_react.createElement)(t)) || v0r.isMemo(t))
    return o1(t);
  if (typeof t != "string")
    throw new Error(`Unsupported widget definition: ${typeof t}`);
  if (t in r) {
    const i = r[t];
    return Et(e, i, r);
  }
  if (typeof n == "string") {
    if (!(n in Ui))
      throw new Error(`No widget for type '${n}'`);
    if (t in Ui[n]) {
      const i = r[Ui[n][t]];
      return Et(e, i, r);
    }
  }
  throw new Error(`No widget '${t}' for type '${n}'`);
}
function l1(e) {
  let t = 0;
  for (let r = 0; r < e.length; r += 1) {
    const n = e.charCodeAt(r);
    t = (t << 5) - t + n, t = t & t;
  }
  return t.toString(16);
}
function c1(e) {
  const t = /* @__PURE__ */ new Set();
  return JSON.stringify(e, (r, n) => (t.add(r), n)), l1(JSON.stringify(e, Array.from(t).sort()));
}
function u1(e, t, r = {}) {
  try {
    return Et(e, t, r), true;
  } catch (n) {
    const i = n;
    if (i.message && (i.message.startsWith("No widget") || i.message.startsWith("Unsupported widget")))
      return false;
    throw n;
  }
}
function gn(e, t) {
  return `${ir(e) ? e : e[Mt]}__${t}`;
}
function jr(e) {
  return gn(e, "description");
}
function ns(e) {
  return gn(e, "error");
}
function Sr(e) {
  return gn(e, "examples");
}
function lu(e) {
  return gn(e, "help");
}
function is(e) {
  return gn(e, "title");
}
function De(e, t = false) {
  const r = t ? ` ${Sr(e)}` : "";
  return `${ns(e)} ${jr(e)} ${lu(e)}${r}`;
}
function Si(e, t) {
  return `${e}-${t}`;
}
function cu(e, t, r) {
  return t ? r : e;
}
function d1(e) {
  return e ? new Date(e).toJSON() : void 0;
}
function f1(e) {
  if (Df in e && Array.isArray(e.enum) && e.enum.length === 1)
    return e.enum[0];
  if (Ll in e)
    return e.const;
  throw new Error("schema cannot be inferred as a constant");
}
function ii(e) {
  const t = e;
  if (t.enumNames && true && console.warn("The enumNames property is deprecated and may be removed in a future major release."), e.enum)
    return e.enum.map((n, i) => ({ label: t.enumNames && t.enumNames[i] || String(n), value: n }));
  const r = e.oneOf || e.anyOf;
  return r && r.map((n) => {
    const i = n, a = f1(i), s = i.title || String(a);
    return {
      schema: i,
      label: s,
      value: a
    };
  });
}
function h1(e, t) {
  if (!Array.isArray(t))
    return e;
  const r = (u) => u.reduce((f, p) => (f[p] = true, f), {}), n = (u) => u.length > 1 ? `properties '${u.join("', '")}'` : `property '${u[0]}'`, i = r(e), a = t.filter((u) => u === "*" || i[u]), s = r(a), o = e.filter((u) => !s[u]), l = a.indexOf("*");
  if (l === -1) {
    if (o.length)
      throw new Error(`uiSchema order list does not contain ${n(o)}`);
    return a;
  }
  if (l !== a.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  const c2 = [...a];
  return c2.splice(l, 1, ...o), c2;
}
function St(e, t) {
  let r = String(e);
  for (; r.length < t; )
    r = "0" + r;
  return r;
}
function wr(e, t = true) {
  if (!e)
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: t ? -1 : 0,
      minute: t ? -1 : 0,
      second: t ? -1 : 0
    };
  const r = new Date(e);
  if (Number.isNaN(r.getTime()))
    throw new Error("Unable to parse date " + e);
  return {
    year: r.getUTCFullYear(),
    month: r.getUTCMonth() + 1,
    day: r.getUTCDate(),
    hour: t ? r.getUTCHours() : 0,
    minute: t ? r.getUTCMinutes() : 0,
    second: t ? r.getUTCSeconds() : 0
  };
}
function zn(e) {
  if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === true)
    return true;
  if (e.anyOf && e.anyOf.length === 1)
    return zn(e.anyOf[0]);
  if (e.oneOf && e.oneOf.length === 1)
    return zn(e.oneOf[0]);
  if (e.allOf) {
    const t = (r) => zn(r);
    return e.allOf.some(t);
  }
  return false;
}
function m1(e, t, r) {
  const { props: n, state: i } = e;
  return !Be(n, t) || !Be(i, r);
}
function ai(e, t = true) {
  const { year: r, month: n, day: i, hour: a = 0, minute: s = 0, second: o = 0 } = e, l = Date.UTC(r, n - 1, i, a, s, o), c2 = new Date(l).toJSON();
  return t ? c2 : c2.slice(0, 10);
}
function sn3(e, t = []) {
  if (!e)
    return [];
  let r = [];
  return ot in e && (r = r.concat(e[ot].map((n) => {
    const i = `.${t.join(".")}`;
    return {
      property: i,
      message: n,
      stack: `${i} ${n}`
    };
  }))), Object.keys(e).reduce((n, i) => {
    if (i !== ot) {
      const a = e[i];
      Na(a) && (n = n.concat(sn3(a, [...t, i])));
    }
    return n;
  }, r);
}
var p12 = Pt;
var y1 = Xe;
var g1 = J;
var v1 = y;
var $1 = Wl;
var _1 = ur;
var b1 = Hl;
function S1(e) {
  return g1(e) ? p12(e, _1) : v1(e) ? [e] : y1($1(b1(e)));
}
var w1 = S1;
var uu = sn2(w1);
function E1(e) {
  const t = new s1();
  return e.length && e.forEach((r) => {
    const { property: n, message: i } = r, a = n === "." ? [] : uu(n);
    a.length > 0 && a[0] === "" && a.splice(0, 1), i && t.addErrors(i, a);
  }), t.ErrorSchema;
}
function du(e) {
  return Object.keys(e).reduce((t, r) => {
    if (r === "addError")
      return t;
    {
      const n = e[r];
      return Na(n) ? {
        ...t,
        [r]: du(n)
      } : { ...t, [r]: n };
    }
  }, {});
}
function O1(e) {
  if (!e)
    return "";
  const t = new Date(e), r = St(t.getFullYear(), 4), n = St(t.getMonth() + 1, 2), i = St(t.getDate(), 2), a = St(t.getHours(), 2), s = St(t.getMinutes(), 2), o = St(t.getSeconds(), 2), l = St(t.getMilliseconds(), 3);
  return `${r}-${n}-${i}T${a}:${s}:${o}.${l}`;
}
function Wn(e, t) {
  if (!t)
    return e;
  const { errors: r, errorSchema: n } = e;
  let i = sn3(t), a = t;
  return xt(n) || (a = Mr(n, t, true), i = [...r].concat(i)), { errorSchema: a, errors: i };
}
function C1(e) {
  for (const t in e) {
    const r = e, n = r[t];
    t === Te && typeof n == "string" && n.startsWith("#") ? r[t] = Bl + n : r[t] = as(n);
  }
  return e;
}
function A1(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = as(e[t]);
  return e;
}
function as(e) {
  return Array.isArray(e) ? A1([...e]) : A(e) ? C1({ ...e }) : e;
}
var le;
(function(e) {
  e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: <em>%2</em>.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field <code>%1</code>.", e.UnsupportedFieldWithReason = "Unsupported field schema: <em>%1</em>.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field <code>%1</code>: <em>%2</em>.", e.FilesInfo = "**%1** (%2, %3 bytes)";
})(le || (le = {}));
var P1 = hn;
var I1 = vc;
var T1 = kr;
function N1(e, t, r) {
  for (var n = -1, i = t.length, a = {}; ++n < i; ) {
    var s = t[n], o = P1(e, s);
    r(o, s) && I1(a, T1(s, e), o);
  }
  return a;
}
var D1 = N1;
var F1 = D1;
var k1 = hc;
function R1(e, t) {
  return F1(e, t, function(r, n) {
    return k1(e, n);
  });
}
var M1 = R1;
var j1 = M1;
var U1 = ac;
var V1 = U1(function(e, t) {
  return e == null ? {} : j1(e, t);
});
var x1 = V1;
var L1 = sn2(x1);
var B1 = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, r) => (r &= 63, r < 36 ? t += r.toString(36) : r < 62 ? t += (r - 26).toString(36).toUpperCase() : r > 62 ? t += "-" : t += "_", t), "");
function ia() {
  return B1();
}
function Ho(e) {
  return Array.isArray(e) ? e.map((t) => ({
    key: ia(),
    item: t
  })) : [];
}
function Wr(e) {
  return Array.isArray(e) ? e.map((t) => t.item) : [];
}
var q1 = class extends import_react.Component {
  /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(t) {
    super(t), this._getNewFormDataRow = () => {
      const { schema: i, registry: a } = this.props, { schemaUtils: s } = a;
      let o = i.items;
      return ra(i) && Tf(i) && (o = i.additionalItems), s.getDefaultFormState(o);
    }, this.onAddClick = (i) => {
      this._handleAddClick(i);
    }, this.onAddIndexClick = (i) => (a) => {
      this._handleAddClick(a, i);
    }, this.onCopyIndexClick = (i) => (a) => {
      a && a.preventDefault();
      const { onChange: s, errorSchema: o } = this.props, { keyedFormData: l } = this.state;
      let c2;
      if (o) {
        c2 = {};
        for (const p in o) {
          const d2 = parseInt(p);
          d2 <= i ? je(c2, [d2], o[p]) : d2 > i && je(c2, [d2 + 1], o[p]);
        }
      }
      const u = {
        key: ia(),
        item: Ba(l[i].item)
      }, f = [...l];
      i !== void 0 ? f.splice(i + 1, 0, u) : f.push(u), this.setState({
        keyedFormData: f,
        updatedKeyedFormData: true
      }, () => s(Wr(f), c2));
    }, this.onDropIndexClick = (i) => (a) => {
      a && a.preventDefault();
      const { onChange: s, errorSchema: o } = this.props, { keyedFormData: l } = this.state;
      let c2;
      if (o) {
        c2 = {};
        for (const f in o) {
          const p = parseInt(f);
          p < i ? je(c2, [p], o[f]) : p > i && je(c2, [p - 1], o[f]);
        }
      }
      const u = l.filter((f, p) => p !== i);
      this.setState({
        keyedFormData: u,
        updatedKeyedFormData: true
      }, () => s(Wr(u), c2));
    }, this.onReorderClick = (i, a) => (s) => {
      s && (s.preventDefault(), s.currentTarget.blur());
      const { onChange: o, errorSchema: l } = this.props;
      let c2;
      if (l) {
        c2 = {};
        for (const d2 in l) {
          const m2 = parseInt(d2);
          m2 == i ? je(c2, [a], l[i]) : m2 == a ? je(c2, [i], l[a]) : je(c2, [d2], l[m2]);
        }
      }
      const { keyedFormData: u } = this.state;
      function f() {
        const d2 = u.slice();
        return d2.splice(i, 1), d2.splice(a, 0, u[i]), d2;
      }
      const p = f();
      this.setState({
        keyedFormData: p
      }, () => o(Wr(p), c2));
    }, this.onChangeForIndex = (i) => (a, s, o) => {
      const { formData: l, onChange: c2, errorSchema: u } = this.props, p = (Array.isArray(l) ? l : []).map((d2, m2) => i === m2 ? typeof a > "u" ? null : a : d2);
      c2(p, u && u && {
        ...u,
        [i]: s
      }, o);
    }, this.onSelectChange = (i) => {
      const { onChange: a, idSchema: s } = this.props;
      a(i, void 0, s && s.$id);
    };
    const { formData: r = [] } = t, n = Ho(r);
    this.state = {
      keyedFormData: n,
      updatedKeyedFormData: false
    };
  }
  /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It
   * regenerates the keyed form data and returns it
   *
   * @param nextProps - The next set of props data
   * @param prevState - The previous set of state data
   */
  static getDerivedStateFromProps(t, r) {
    if (r.updatedKeyedFormData)
      return {
        updatedKeyedFormData: false
      };
    const n = Array.isArray(t.formData) ? t.formData : [], i = r.keyedFormData || [];
    return {
      keyedFormData: n.length === i.length ? i.map((s, o) => ({
        key: s.key,
        item: n[o]
      })) : Ho(n)
    };
  }
  /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to
   * the description from the schema.items, and finally the string "Item"
   */
  get itemTitle() {
    const { schema: t, registry: r } = this.props, { translateString: n } = r;
    return G2(t, [Ut, "title"], G2(t, [Ut, "description"], n(le.ArrayItemTitle)));
  }
  /** Determines whether the item described in the schema is always required, which is determined by whether any item
   * may be null.
   *
   * @param itemSchema - The schema for the item
   * @return - True if the item schema type does not contain the "null" type
   */
  isItemRequired(t) {
    return Array.isArray(t.type) ? !t.type.includes("null") : t.type !== "null";
  }
  /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding
   * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the
   * `formData` matches that value, then false is returned, otherwise true is returned.
   *
   * @param formItems - The list of items in the form
   * @returns - True if the item is addable otherwise false
   */
  canAddItem(t) {
    const { schema: r, uiSchema: n, registry: i } = this.props;
    let { addable: a } = oe(n, i.globalUiOptions);
    return a !== false && (r.maxItems !== void 0 ? a = t.length < r.maxItems : a = true), a;
  }
  /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data
   * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into
   * the state, and then returning `onChange()` with the plain form data converted from the keyed data
   *
   * @param event - The event for the click
   * @param [index] - The optional index at which to add the new data
   */
  _handleAddClick(t, r) {
    t && t.preventDefault();
    const { onChange: n, errorSchema: i } = this.props, { keyedFormData: a } = this.state;
    let s;
    if (i) {
      s = {};
      for (const c2 in i) {
        const u = parseInt(c2);
        r === void 0 || u < r ? je(s, [u], i[c2]) : u >= r && je(s, [u + 1], i[c2]);
      }
    }
    const o = {
      key: ia(),
      item: this._getNewFormDataRow()
    }, l = [...a];
    r !== void 0 ? l.splice(r, 0, o) : l.push(o), this.setState({
      keyedFormData: l,
      updatedKeyedFormData: true
    }, () => n(Wr(l), s));
  }
  /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements
   */
  render() {
    const { schema: t, uiSchema: r, idSchema: n, registry: i } = this.props, { schemaUtils: a, translateString: s } = i;
    if (!(Ut in t)) {
      const o = oe(r), l = ce("UnsupportedFieldTemplate", i, o);
      return d(l, { schema: t, idSchema: n, reason: s(le.MissingItems), registry: i });
    }
    return a.isMultiSelect(t) ? this.renderMultiSelect() : ru(r) ? this.renderCustomWidget() : ra(t) ? this.renderFixedArray() : a.isFilesArray(t, r) ? this.renderFiles() : this.renderNormalArray();
  }
  /** Renders a normal array without any limitations of length
   */
  renderNormalArray() {
    const { schema: t, uiSchema: r = {}, errorSchema: n, idSchema: i, name: a, title: s, disabled: o = false, readonly: l = false, autofocus: c2 = false, required: u = false, registry: f, onBlur: p, onFocus: d2, idPrefix: m2, idSeparator: h2 = "_", rawErrors: g } = this.props, { keyedFormData: y2 } = this.state, v = t.title || s || a, { schemaUtils: b, formContext: w } = f, C = oe(r), E2 = A(t.items) ? t.items : {}, _3 = b.retrieveSchema(E2), T = Wr(this.state.keyedFormData), F = this.canAddItem(T), j2 = {
      canAdd: F,
      items: y2.map((U, W) => {
        const { key: z2, item: q3 } = U, ue = q3, me = b.retrieveSchema(E2, ue), ie2 = n ? n[W] : void 0, Y2 = i.$id + h2 + W, V2 = b.toIdSchema(me, Y2, ue, m2, h2);
        return this.renderArrayFieldItem({
          key: z2,
          index: W,
          name: a && `${a}-${W}`,
          title: v ? `${v}-${W + 1}` : void 0,
          canAdd: F,
          canMoveUp: W > 0,
          canMoveDown: W < T.length - 1,
          itemSchema: me,
          itemIdSchema: V2,
          itemErrorSchema: ie2,
          itemData: ue,
          itemUiSchema: r.items,
          autofocus: c2 && W === 0,
          onBlur: p,
          onFocus: d2,
          rawErrors: g,
          totalItems: y2.length
        });
      }),
      className: `field field-array field-array-of-${_3.type}`,
      disabled: o,
      idSchema: i,
      uiSchema: r,
      onAddClick: this.onAddClick,
      readonly: l,
      required: u,
      schema: t,
      title: v,
      formContext: w,
      formData: T,
      rawErrors: g,
      registry: f
    }, L = ce("ArrayFieldTemplate", f, C);
    return d(L, { ...j2 });
  }
  /** Renders an array using the custom widget provided by the user in the `uiSchema`
   */
  renderCustomWidget() {
    var t;
    const { schema: r, idSchema: n, uiSchema: i, disabled: a = false, readonly: s = false, autofocus: o = false, required: l = false, hideError: c2, placeholder: u, onBlur: f, onFocus: p, formData: d2 = [], registry: m2, rawErrors: h2, name: g } = this.props, { widgets: y2, formContext: v, globalUiOptions: b, schemaUtils: w } = m2, { widget: C, title: E2, ..._3 } = oe(i, b), T = Et(r, C, y2), F = (t = E2 ?? r.title) !== null && t !== void 0 ? t : g, j2 = w.getDisplayLabel(r, i, b);
    return d(T, { id: n.$id, name: g, multiple: true, onChange: this.onSelectChange, onBlur: f, onFocus: p, options: _3, schema: r, uiSchema: i, registry: m2, value: d2, disabled: a, readonly: s, hideError: c2, required: l, label: F, hideLabel: !j2, placeholder: u, formContext: v, autofocus: o, rawErrors: h2 });
  }
  /** Renders an array as a set of checkboxes
   */
  renderMultiSelect() {
    var t;
    const { schema: r, idSchema: n, uiSchema: i, formData: a = [], disabled: s = false, readonly: o = false, autofocus: l = false, required: c2 = false, placeholder: u, onBlur: f, onFocus: p, registry: d2, rawErrors: m2, name: h2 } = this.props, { widgets: g, schemaUtils: y2, formContext: v, globalUiOptions: b } = d2, w = y2.retrieveSchema(r.items, a), C = ii(w), { widget: E2 = "select", title: _3, ...T } = oe(i, b), F = Et(r, E2, g), j2 = (t = _3 ?? r.title) !== null && t !== void 0 ? t : h2, L = y2.getDisplayLabel(r, i, b);
    return d(F, { id: n.$id, name: h2, multiple: true, onChange: this.onSelectChange, onBlur: f, onFocus: p, options: { ...T, enumOptions: C }, schema: r, uiSchema: i, registry: d2, value: a, disabled: s, readonly: o, required: c2, label: j2, hideLabel: !L, placeholder: u, formContext: v, autofocus: l, rawErrors: m2 });
  }
  /** Renders an array of files using the `FileWidget`
   */
  renderFiles() {
    var t;
    const { schema: r, uiSchema: n, idSchema: i, name: a, disabled: s = false, readonly: o = false, autofocus: l = false, required: c2 = false, onBlur: u, onFocus: f, registry: p, formData: d2 = [], rawErrors: m2 } = this.props, { widgets: h2, formContext: g, globalUiOptions: y2, schemaUtils: v } = p, { widget: b = "files", title: w, ...C } = oe(n, y2), E2 = Et(r, b, h2), _3 = (t = w ?? r.title) !== null && t !== void 0 ? t : a, T = v.getDisplayLabel(r, n, y2);
    return d(E2, { options: C, id: i.$id, name: a, multiple: true, onChange: this.onSelectChange, onBlur: u, onFocus: f, schema: r, uiSchema: n, value: d2, disabled: s, readonly: o, required: c2, registry: p, formContext: g, autofocus: l, rawErrors: m2, label: _3, hideLabel: !T });
  }
  /** Renders an array that has a maximum limit of items
   */
  renderFixedArray() {
    const { schema: t, uiSchema: r = {}, formData: n = [], errorSchema: i, idPrefix: a, idSeparator: s = "_", idSchema: o, name: l, title: c2, disabled: u = false, readonly: f = false, autofocus: p = false, required: d2 = false, registry: m2, onBlur: h2, onFocus: g, rawErrors: y2 } = this.props, { keyedFormData: v } = this.state;
    let { formData: b = [] } = this.props;
    const w = t.title || c2 || l, C = oe(r), { schemaUtils: E2, formContext: _3 } = m2, F = (A(t.items) ? t.items : []).map((z2, q3) => E2.retrieveSchema(z2, n[q3])), j2 = A(t.additionalItems) ? E2.retrieveSchema(t.additionalItems, n) : null;
    (!b || b.length < F.length) && (b = b || [], b = b.concat(new Array(F.length - b.length)));
    const L = this.canAddItem(b) && !!j2, U = {
      canAdd: L,
      className: "field field-array field-array-fixed-items",
      disabled: u,
      idSchema: o,
      formData: n,
      items: v.map((z2, q3) => {
        const { key: ue, item: me } = z2, ie2 = me, Y2 = q3 >= F.length, V2 = (Y2 && A(t.additionalItems) ? E2.retrieveSchema(t.additionalItems, ie2) : F[q3]) || {}, N3 = o.$id + s + q3, x3 = E2.toIdSchema(V2, N3, ie2, a, s), D = Y2 ? r.additionalItems || {} : Array.isArray(r.items) ? r.items[q3] : r.items || {}, $ = i ? i[q3] : void 0;
        return this.renderArrayFieldItem({
          key: ue,
          index: q3,
          name: l && `${l}-${q3}`,
          title: w ? `${w}-${q3 + 1}` : void 0,
          canAdd: L,
          canRemove: Y2,
          canMoveUp: q3 >= F.length + 1,
          canMoveDown: Y2 && q3 < b.length - 1,
          itemSchema: V2,
          itemData: ie2,
          itemUiSchema: D,
          itemIdSchema: x3,
          itemErrorSchema: $,
          autofocus: p && q3 === 0,
          onBlur: h2,
          onFocus: g,
          rawErrors: y2,
          totalItems: v.length
        });
      }),
      onAddClick: this.onAddClick,
      readonly: f,
      required: d2,
      registry: m2,
      schema: t,
      uiSchema: r,
      title: w,
      formContext: _3,
      errorSchema: i,
      rawErrors: y2
    }, W = ce("ArrayFieldTemplate", m2, C);
    return d(W, { ...U });
  }
  /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send
   * back to the `ArrayFieldItemTemplate`.
   *
   * @param props - The props for the individual array item to be rendered
   */
  renderArrayFieldItem(t) {
    const { key: r, index: n, name: i, canAdd: a, canRemove: s = true, canMoveUp: o, canMoveDown: l, itemSchema: c2, itemData: u, itemUiSchema: f, itemIdSchema: p, itemErrorSchema: d2, autofocus: m2, onBlur: h2, onFocus: g, rawErrors: y2, totalItems: v, title: b } = t, { disabled: w, hideError: C, idPrefix: E2, idSeparator: _3, readonly: T, uiSchema: F, registry: j2, formContext: L } = this.props, { fields: { ArraySchemaField: U, SchemaField: W }, globalUiOptions: z2 } = j2, q3 = U || W, { orderable: ue = true, removable: me = true, copyable: ie2 = false } = oe(F, z2), Y2 = {
      moveUp: ue && o,
      moveDown: ue && l,
      copy: ie2 && a,
      remove: me && s,
      toolbar: false
    };
    return Y2.toolbar = Object.keys(Y2).some((V2) => Y2[V2]), {
      children: d(q3, { name: i, title: b, index: n, schema: c2, uiSchema: f, formData: u, formContext: L, errorSchema: d2, idPrefix: E2, idSeparator: _3, idSchema: p, required: this.isItemRequired(c2), onChange: this.onChangeForIndex(n), onBlur: h2, onFocus: g, registry: j2, disabled: w, readonly: T, hideError: C, autofocus: m2, rawErrors: y2 }),
      className: "array-item",
      disabled: w,
      canAdd: a,
      hasCopy: Y2.copy,
      hasToolbar: Y2.toolbar,
      hasMoveUp: Y2.moveUp,
      hasMoveDown: Y2.moveDown,
      hasRemove: Y2.remove,
      index: n,
      totalItems: v,
      key: r,
      onAddIndexClick: this.onAddIndexClick,
      onCopyIndexClick: this.onCopyIndexClick,
      onDropIndexClick: this.onDropIndexClick,
      onReorderClick: this.onReorderClick,
      readonly: T,
      registry: j2,
      schema: c2,
      uiSchema: f
    };
  }
};
function K1(e) {
  var t, r, n;
  const { schema: i, name: a, uiSchema: s, idSchema: o, formData: l, registry: c2, required: u, disabled: f, readonly: p, hideError: d2, autofocus: m2, title: h2, onChange: g, onFocus: y2, onBlur: v, rawErrors: b } = e, { title: w } = i, { widgets: C, formContext: E2, translateString: _3, globalUiOptions: T } = c2, {
    widget: F = "checkbox",
    title: j2,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: L = true,
    ...U
  } = oe(s, T), W = Et(i, F, C), z2 = _3(le.YesLabel), q3 = _3(le.NoLabel);
  let ue;
  const me = (r = (t = j2 ?? w) !== null && t !== void 0 ? t : h2) !== null && r !== void 0 ? r : a;
  if (Array.isArray(i.oneOf))
    ue = ii({
      oneOf: i.oneOf.map((ie2) => {
        if (A(ie2))
          return {
            ...ie2,
            title: ie2.title || (ie2.const === true ? z2 : q3)
          };
      }).filter((ie2) => ie2)
      // cast away the error that typescript can't grok is fixed
    });
  else {
    const ie2 = i, Y2 = (n = i.enum) !== null && n !== void 0 ? n : [true, false];
    !ie2.enumNames && Y2.length === 2 && Y2.every((V2) => typeof V2 == "boolean") ? ue = [
      {
        value: Y2[0],
        label: Y2[0] ? z2 : q3
      },
      {
        value: Y2[1],
        label: Y2[1] ? z2 : q3
      }
    ] : ue = ii({
      enum: Y2,
      // NOTE: enumNames is deprecated, but still supported for now.
      enumNames: ie2.enumNames
    });
  }
  return d(W, { options: { ...U, enumOptions: ue }, schema: i, uiSchema: s, id: o.$id, name: a, onChange: g, onFocus: y2, onBlur: v, label: me, hideLabel: !L, value: l, required: u, disabled: f, readonly: p, hideError: d2, registry: c2, formContext: E2, autofocus: m2, rawErrors: b });
}
var Yo = class extends import_react.Component {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(t) {
    super(t), this.onOptionChange = (s) => {
      const { selectedOption: o, retrievedOptions: l } = this.state, { formData: c2, onChange: u, registry: f } = this.props, { schemaUtils: p } = f, d2 = s !== void 0 ? parseInt(s, 10) : -1;
      if (d2 === o)
        return;
      const m2 = d2 >= 0 ? l[d2] : void 0, h2 = o >= 0 ? l[o] : void 0;
      let g = p.sanitizeDataForNewSchema(m2, h2, c2);
      g && m2 && (g = p.getDefaultFormState(m2, g, "excludeObjectChildren")), u(g, void 0, this.getFieldId()), this.setState({ selectedOption: d2 });
    };
    const { formData: r, options: n, registry: { schemaUtils: i } } = this.props, a = n.map((s) => i.retrieveSchema(s, r));
    this.state = {
      retrievedOptions: a,
      selectedOption: this.getMatchingOption(0, r, a)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(t, r) {
    const { formData: n, options: i, idSchema: a } = this.props, { selectedOption: s } = this.state;
    let o = this.state;
    if (!Be(t.options, i)) {
      const { registry: { schemaUtils: l } } = this.props, c2 = i.map((u) => l.retrieveSchema(u, n));
      o = { selectedOption: s, retrievedOptions: c2 };
    }
    if (!Be(n, t.formData) && a.$id === t.idSchema.$id) {
      const { retrievedOptions: l } = o, c2 = this.getMatchingOption(s, n, l);
      r && c2 !== s && (o = { selectedOption: c2, retrievedOptions: l });
    }
    o !== this.state && this.setState(o);
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(t, r, n) {
    const { schema: i, registry: { schemaUtils: a } } = this.props, s = Pr(i);
    return a.getClosestMatchingOption(r, n, t, s);
  }
  getFieldId() {
    const { idSchema: t, schema: r } = this.props;
    return `${t.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const { name: t, disabled: r = false, errorSchema: n = {}, formContext: i, onBlur: a, onFocus: s, registry: o, schema: l, uiSchema: c2 } = this.props, { widgets: u, fields: f, translateString: p, globalUiOptions: d2, schemaUtils: m2 } = o, { SchemaField: h2 } = f, { selectedOption: g, retrievedOptions: y2 } = this.state, { widget: v = "select", placeholder: b, autofocus: w, autocomplete: C, title: E2 = l.title, ..._3 } = oe(c2, d2), T = Et({ type: "number" }, v, u), F = G2(n, ot, []), j2 = Qn(n, [ot]), L = m2.getDisplayLabel(l, c2, d2), U = g >= 0 && y2[g] || null;
    let W;
    if (U) {
      const { required: Y2 } = l;
      W = Y2 ? At({ required: Y2 }, U) : U;
    }
    let z2 = [];
    et in l && c2 && et in c2 ? Array.isArray(c2[et]) ? z2 = c2[et] : console.warn(`uiSchema.oneOf is not an array for "${E2 || t}"`) : pt in l && c2 && pt in c2 && (Array.isArray(c2[pt]) ? z2 = c2[pt] : console.warn(`uiSchema.anyOf is not an array for "${E2 || t}"`));
    let q3 = c2;
    g >= 0 && z2.length > g && (q3 = z2[g]);
    const ue = E2 ? le.TitleOptionPrefix : le.OptionPrefix, me = E2 ? [E2] : [], ie2 = y2.map((Y2, V2) => {
      const { title: N3 = Y2.title } = oe(z2[V2]);
      return {
        label: N3 || p(ue, me.concat(String(V2 + 1))),
        value: V2
      };
    });
    return N2("div", { className: "panel panel-default panel-body", children: [d("div", { className: "form-group", children: d(T, { id: this.getFieldId(), name: `${t}${l.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: a, onFocus: s, disabled: r || xt(ie2), multiple: false, rawErrors: F, errorSchema: j2, value: g >= 0 ? g : void 0, options: { enumOptions: ie2, ..._3 }, registry: o, formContext: i, placeholder: b, autocomplete: C, autofocus: w, label: E2 ?? t, hideLabel: !L }) }), W && d(h2, { ...this.props, schema: W, uiSchema: q3 })] });
  }
};
var z1 = /\.([0-9]*0)*$/;
var W1 = /[0.]0*$/;
function G1(e) {
  const { registry: t, onChange: r, formData: n, value: i } = e, [a, s] = (0, import_react.useState)(i), { StringField: o } = t.fields;
  let l = n;
  const c2 = (0, import_react.useCallback)((u) => {
    s(u), `${u}`.charAt(0) === "." && (u = `0${u}`);
    const f = typeof u == "string" && u.match(z1) ? mo(u.replace(W1, "")) : mo(u);
    r(f);
  }, [r]);
  if (typeof a == "string" && typeof l == "number") {
    const u = new RegExp(`^(${String(l).replace(".", "\\.")})?\\.?0*$`);
    a.match(u) && (l = a);
  }
  return d(o, { ...e, formData: l, onChange: c2 });
}
function Qt() {
  return Qt = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Qt.apply(this, arguments);
}
var H1 = ["children", "options"];
var Jo;
var Xo;
(function(e) {
  e.blockQuote = "0", e.breakLine = "1", e.breakThematic = "2", e.codeBlock = "3", e.codeFenced = "4", e.codeInline = "5", e.footnote = "6", e.footnoteReference = "7", e.gfmTask = "8", e.heading = "9", e.headingSetext = "10", e.htmlBlock = "11", e.htmlComment = "12", e.htmlSelfClosing = "13", e.image = "14", e.link = "15", e.linkAngleBraceStyleDetector = "16", e.linkBareUrlDetector = "17", e.linkMailtoDetector = "18", e.newlineCoalescer = "19", e.orderedList = "20", e.paragraph = "21", e.ref = "22", e.refImage = "23", e.refLink = "24", e.table = "25", e.tableSeparator = "26", e.text = "27", e.textBolded = "28", e.textEmphasized = "29", e.textEscaped = "30", e.textMarked = "31", e.textStrikethroughed = "32", e.unorderedList = "33";
})(Jo || (Jo = {})), function(e) {
  e[e.MAX = 0] = "MAX", e[e.HIGH = 1] = "HIGH", e[e.MED = 2] = "MED", e[e.LOW = 3] = "LOW", e[e.MIN = 4] = "MIN";
}(Xo || (Xo = {}));
var Zo = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "className", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { for: "htmlFor" });
var Qo = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" };
var Y1 = ["style", "script"];
var J1 = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi;
var X1 = /mailto:/i;
var Z1 = /\n{2,}$/;
var fu = /^(\s*>[\s\S]*?)(?=\n{2,})/;
var Q1 = /^ *> ?/gm;
var eS = /^ {2,}\n/;
var tS = /^(?:( *[-*_])){3,} *(?:\n *)+\n/;
var hu = /^\s*(`{3,}|~{3,}) *(\S+)?([^\n]*?)?\n([\s\S]+?)\s*\1 *(?:\n *)*\n?/;
var mu = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/;
var rS = /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/;
var nS = /^(?:\n *)*\n/;
var iS = /\r\n?/g;
var aS = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/;
var sS = /^\[\^([^\]]+)]/;
var oS = /\f/g;
var lS = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/;
var cS = /^\s*?\[(x|\s)\]/;
var pu = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/;
var yu = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/;
var gu = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/;
var aa = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i;
var uS = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;
var vu = /^<!--[\s\S]*?(?:-->)/;
var dS = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/;
var sa2 = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i;
var fS = /^\{.*\}$/;
var hS = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/;
var mS = /^<([^ >]+@[^ >]+)>/;
var pS = /^<([^ >]+:\/[^ >]+)>/;
var yS = /-([a-z])?/gi;
var $u = /^(.*\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/;
var gS = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/;
var vS = /^!\[([^\]]*)\] ?\[([^\]]*)\]/;
var $S = /^\[([^\]]*)\] ?\[([^\]]*)\]/;
var _S = /(\[|\])/g;
var bS = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/;
var SS = /\t/g;
var wS = /(^ *\||\| *$)/g;
var ES = /^ *:-+: *$/;
var OS = /^ *:-+ *$/;
var CS = /^ *-+: *$/;
var wi = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~~.*?~~|==.*?==|.|\\n)*?)";
var AS = new RegExp(`^([*_])\\1${wi}\\1\\1(?!\\1)`);
var PS = new RegExp(`^([*_])${wi}\\1(?!\\1|\\w)`);
var IS = new RegExp(`^==${wi}==`);
var TS = new RegExp(`^~~${wi}~~`);
var NS = /^\\([^0-9A-Za-z\s])/;
var DS = /^[\s\S]+?(?=[^0-9A-Z\s\u00c0-\uffff&#;.()'"]|\d+\.|\n\n| {2,}\n|\w+:\S|$)/i;
var FS = /^\n+/;
var kS = /^([ \t]*)/;
var RS = /\\([^\\])/g;
var el = / *\n+$/;
var MS = /(?:^|\n)( *)$/;
var ss = "(?:\\d+\\.)";
var os = "(?:[*+-])";
function _u(e) {
  return "( *)(" + (e === 1 ? ss : os) + ") +";
}
var bu = _u(1);
var Su = _u(2);
function wu(e) {
  return new RegExp("^" + (e === 1 ? bu : Su));
}
var jS = wu(1);
var US = wu(2);
function Eu(e) {
  return new RegExp("^" + (e === 1 ? bu : Su) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? ss : os) + " )[^\\n]*)*(\\n|$)", "gm");
}
var Ou = Eu(1);
var Cu = Eu(2);
function Au(e) {
  const t = e === 1 ? ss : os;
  return new RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
}
var Pu = Au(1);
var Iu = Au(2);
function tl(e, t) {
  const r = t === 1, n = r ? Pu : Iu, i = r ? Ou : Cu, a = r ? jS : US;
  return { match(s, o, l) {
    const c2 = MS.exec(l);
    return c2 && (o.list || !o.inline && !o.simple) ? n.exec(s = c2[1] + s) : null;
  }, order: 1, parse(s, o, l) {
    const c2 = r ? +s[2] : void 0, u = s[0].replace(Z1, `
`).match(i);
    let f = false;
    return { items: u.map(function(p, d2) {
      const m2 = a.exec(p)[0].length, h2 = new RegExp("^ {1," + m2 + "}", "gm"), g = p.replace(h2, "").replace(a, ""), y2 = d2 === u.length - 1, v = g.indexOf(`

`) !== -1 || y2 && f;
      f = v;
      const b = l.inline, w = l.list;
      let C;
      l.list = true, v ? (l.inline = false, C = g.replace(el, `

`)) : (l.inline = true, C = g.replace(el, ""));
      const E2 = o(C, l);
      return l.inline = b, l.list = w, E2;
    }), ordered: r, start: c2 };
  }, render: (s, o, l) => e(s.ordered ? "ol" : "ul", { key: l.key, start: s.type === "20" ? s.start : void 0 }, s.items.map(function(c2, u) {
    return e("li", { key: u }, o(c2, l));
  })) };
}
var VS2 = new RegExp(`^\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`);
var xS = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
var Tu = [fu, hu, mu, pu, gu, yu, vu, $u, Ou, Pu, Cu, Iu];
var LS2 = [...Tu, /^[^\n]+(?:  \n|\n{2,})/, aa, sa2];
function BS(e) {
  return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function qS(e) {
  return CS.test(e) ? "right" : ES.test(e) ? "center" : OS.test(e) ? "left" : null;
}
function rl(e, t, r, n) {
  const i = r.inTable;
  r.inTable = true;
  let a = e.trim().split(/( *(?:`[^`]*`|<.*?>.*?<\/.*?>(?!<\/.*?>)|\\\||\|) *)/).reduce((o, l) => (l.trim() === "|" ? o.push(n ? { type: "26" } : { type: "27", text: l }) : l !== "" && o.push.apply(o, t(l, r)), o), []);
  r.inTable = i;
  let s = [[]];
  return a.forEach(function(o, l) {
    o.type === "26" ? l !== 0 && l !== a.length - 1 && s.push([]) : (o.type !== "27" || a[l + 1] != null && a[l + 1].type !== "26" || (o.text = o.text.trimEnd()), s[s.length - 1].push(o));
  }), s;
}
function KS(e, t, r) {
  r.inline = true;
  const n = e[2] ? e[2].replace(wS, "").split("|").map(qS) : [], i = e[3] ? function(s, o, l) {
    return s.trim().split(`
`).map(function(c2) {
      return rl(c2, o, l, true);
    });
  }(e[3], t, r) : [], a = rl(e[1], t, r, !!i.length);
  return r.inline = false, i.length ? { align: n, cells: i, header: a, type: "25" } : { children: a, type: "21" };
}
function nl(e, t) {
  return e.align[t] == null ? {} : { textAlign: e.align[t] };
}
function Nt(e) {
  return function(t, r) {
    return r.inline ? e.exec(t) : null;
  };
}
function Dt(e) {
  return function(t, r) {
    return r.inline || r.simple ? e.exec(t) : null;
  };
}
function bt(e) {
  return function(t, r) {
    return r.inline || r.simple ? null : e.exec(t);
  };
}
function Gr(e) {
  return function(t) {
    return e.exec(t);
  };
}
function zS(e, t, r) {
  if (t.inline || t.simple || r && !r.endsWith(`
`))
    return null;
  let n = "";
  e.split(`
`).every((a) => !Tu.some((s) => s.test(a)) && (n += a + `
`, a.trim()));
  const i = n.trimEnd();
  return i == "" ? null : [n, i];
}
function yr(e) {
  try {
    if (decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "").match(/^\s*(javascript|vbscript|data(?!:image)):/i))
      return;
  } catch {
    return null;
  }
  return e;
}
function il(e) {
  return e.replace(RS, "$1");
}
function Gn(e, t, r) {
  const n = r.inline || false, i = r.simple || false;
  r.inline = true, r.simple = true;
  const a = e(t, r);
  return r.inline = n, r.simple = i, a;
}
function WS(e, t, r) {
  const n = r.inline || false, i = r.simple || false;
  r.inline = false, r.simple = true;
  const a = e(t, r);
  return r.inline = n, r.simple = i, a;
}
function GS(e, t, r) {
  const n = r.inline || false;
  r.inline = false;
  const i = e(t, r);
  return r.inline = n, i;
}
var Vi = (e, t, r) => ({ children: Gn(t, e[1], r) });
function xi() {
  return {};
}
function Li() {
  return null;
}
function HS(...e) {
  return e.filter(Boolean).join(" ");
}
function Bi(e, t, r) {
  let n = e;
  const i = t.split(".");
  for (; i.length && (n = n[i[0]], n !== void 0); )
    i.shift();
  return n || r;
}
function YS(e = "", t = {}) {
  t.overrides = t.overrides || {}, t.slugify = t.slugify || BS, t.namedCodesToUnicode = t.namedCodesToUnicode ? Qt({}, Qo, t.namedCodesToUnicode) : Qo;
  const r = t.createElement || Ln.createElement;
  function n(d2, m2, ...h2) {
    const g = Bi(t.overrides, `${d2}.props`, {});
    return r(function(y2, v) {
      const b = Bi(v, y2);
      return b ? typeof b == "function" || typeof b == "object" && "render" in b ? b : Bi(v, `${y2}.component`, y2) : y2;
    }(d2, t.overrides), Qt({}, m2, g, { className: HS(m2 == null ? void 0 : m2.className, g.className) || void 0 }), ...h2);
  }
  function i(d2) {
    d2 = d2.replace(lS, "");
    let m2 = false;
    t.forceInline ? m2 = true : t.forceBlock || (m2 = bS.test(d2) === false);
    const h2 = u(c2(m2 ? d2 : `${d2.trimEnd().replace(FS, "")}

`, { inline: m2 }));
    for (; typeof h2[h2.length - 1] == "string" && !h2[h2.length - 1].trim(); )
      h2.pop();
    if (t.wrapper === null)
      return h2;
    const g = t.wrapper || (m2 ? "span" : "div");
    let y2;
    if (h2.length > 1 || t.forceWrapper)
      y2 = h2;
    else {
      if (h2.length === 1)
        return y2 = h2[0], typeof y2 == "string" ? n("span", { key: "outer" }, y2) : y2;
      y2 = null;
    }
    return Ln.createElement(g, { key: "outer" }, y2);
  }
  function a(d2) {
    const m2 = d2.match(J1);
    return m2 ? m2.reduce(function(h2, g, y2) {
      const v = g.indexOf("=");
      if (v !== -1) {
        const b = function(_3) {
          return _3.indexOf("-") !== -1 && _3.match(dS) === null && (_3 = _3.replace(yS, function(T, F) {
            return F.toUpperCase();
          })), _3;
        }(g.slice(0, v)).trim(), w = function(_3) {
          const T = _3[0];
          return (T === '"' || T === "'") && _3.length >= 2 && _3[_3.length - 1] === T ? _3.slice(1, -1) : _3;
        }(g.slice(v + 1).trim()), C = Zo[b] || b, E2 = h2[C] = function(_3, T) {
          return _3 === "style" ? T.split(/;\s?/).reduce(function(F, j2) {
            const L = j2.slice(0, j2.indexOf(":"));
            return F[L.trim().replace(/(-[a-z])/g, (U) => U[1].toUpperCase())] = j2.slice(L.length + 1).trim(), F;
          }, {}) : _3 === "href" || _3 === "src" ? yr(T) : (T.match(fS) && (T = T.slice(1, T.length - 1)), T === "true" || T !== "false" && T);
        }(b, w);
        typeof E2 == "string" && (aa.test(E2) || sa2.test(E2)) && (h2[C] = Ln.cloneElement(i(E2.trim()), { key: y2 }));
      } else
        g !== "style" && (h2[Zo[g] || g] = true);
      return h2;
    }, {}) : null;
  }
  const s = [], o = {}, l = { 0: { match: bt(fu), order: 1, parse: (d2, m2, h2) => ({ children: m2(d2[0].replace(Q1, ""), h2) }), render: (d2, m2, h2) => n("blockquote", { key: h2.key }, m2(d2.children, h2)) }, 1: { match: Gr(eS), order: 1, parse: xi, render: (d2, m2, h2) => n("br", { key: h2.key }) }, 2: { match: bt(tS), order: 1, parse: xi, render: (d2, m2, h2) => n("hr", { key: h2.key }) }, 3: { match: bt(mu), order: 0, parse: (d2) => ({ lang: void 0, text: d2[0].replace(/^ {4}/gm, "").replace(/\n+$/, "") }), render: (d2, m2, h2) => n("pre", { key: h2.key }, n("code", Qt({}, d2.attrs, { className: d2.lang ? `lang-${d2.lang}` : "" }), d2.text)) }, 4: { match: bt(hu), order: 0, parse: (d2) => ({ attrs: a(d2[3] || ""), lang: d2[2] || void 0, text: d2[4], type: "3" }) }, 5: { match: Dt(rS), order: 3, parse: (d2) => ({ text: d2[2] }), render: (d2, m2, h2) => n("code", { key: h2.key }, d2.text) }, 6: { match: bt(aS), order: 0, parse: (d2) => (s.push({ footnote: d2[2], identifier: d2[1] }), {}), render: Li }, 7: { match: Nt(sS), order: 1, parse: (d2) => ({ target: `#${t.slugify(d2[1])}`, text: d2[1] }), render: (d2, m2, h2) => n("a", { key: h2.key, href: yr(d2.target) }, n("sup", { key: h2.key }, d2.text)) }, 8: { match: Nt(cS), order: 1, parse: (d2) => ({ completed: d2[1].toLowerCase() === "x" }), render: (d2, m2, h2) => n("input", { checked: d2.completed, key: h2.key, readOnly: true, type: "checkbox" }) }, 9: { match: bt(t.enforceAtxHeadings ? yu : pu), order: 1, parse: (d2, m2, h2) => ({ children: Gn(m2, d2[2], h2), id: t.slugify(d2[2]), level: d2[1].length }), render: (d2, m2, h2) => n(`h${d2.level}`, { id: d2.id, key: h2.key }, m2(d2.children, h2)) }, 10: { match: bt(gu), order: 0, parse: (d2, m2, h2) => ({ children: Gn(m2, d2[1], h2), level: d2[2] === "=" ? 1 : 2, type: "9" }) }, 11: { match: Gr(aa), order: 1, parse(d2, m2, h2) {
    const [, g] = d2[3].match(kS), y2 = new RegExp(`^${g}`, "gm"), v = d2[3].replace(y2, ""), b = (w = v, LS2.some((T) => T.test(w)) ? GS : Gn);
    var w;
    const C = d2[1].toLowerCase(), E2 = Y1.indexOf(C) !== -1, _3 = { attrs: a(d2[2]), noInnerParse: E2, tag: (E2 ? C : d2[1]).trim() };
    return h2.inAnchor = h2.inAnchor || C === "a", E2 ? _3.text = d2[3] : _3.children = b(m2, v, h2), h2.inAnchor = false, _3;
  }, render: (d2, m2, h2) => n(d2.tag, Qt({ key: h2.key }, d2.attrs), d2.text || m2(d2.children, h2)) }, 13: { match: Gr(sa2), order: 1, parse: (d2) => ({ attrs: a(d2[2] || ""), tag: d2[1].trim() }), render: (d2, m2, h2) => n(d2.tag, Qt({}, d2.attrs, { key: h2.key })) }, 12: { match: Gr(vu), order: 1, parse: () => ({}), render: Li }, 14: { match: Dt(xS), order: 1, parse: (d2) => ({ alt: d2[1], target: il(d2[2]), title: d2[3] }), render: (d2, m2, h2) => n("img", { key: h2.key, alt: d2.alt || void 0, title: d2.title || void 0, src: yr(d2.target) }) }, 15: { match: Nt(VS2), order: 3, parse: (d2, m2, h2) => ({ children: WS(m2, d2[1], h2), target: il(d2[2]), title: d2[3] }), render: (d2, m2, h2) => n("a", { key: h2.key, href: yr(d2.target), title: d2.title }, m2(d2.children, h2)) }, 16: { match: Nt(pS), order: 0, parse: (d2) => ({ children: [{ text: d2[1], type: "27" }], target: d2[1], type: "15" }) }, 17: { match: (d2, m2) => m2.inAnchor ? null : Nt(hS)(d2, m2), order: 0, parse: (d2) => ({ children: [{ text: d2[1], type: "27" }], target: d2[1], title: void 0, type: "15" }) }, 18: { match: Nt(mS), order: 0, parse(d2) {
    let m2 = d2[1], h2 = d2[1];
    return X1.test(h2) || (h2 = "mailto:" + h2), { children: [{ text: m2.replace("mailto:", ""), type: "27" }], target: h2, type: "15" };
  } }, 20: tl(n, 1), 33: tl(n, 2), 19: { match: bt(nS), order: 3, parse: xi, render: () => `
` }, 21: { match: zS, order: 3, parse: Vi, render: (d2, m2, h2) => n("p", { key: h2.key }, m2(d2.children, h2)) }, 22: { match: Nt(gS), order: 0, parse: (d2) => (o[d2[1]] = { target: d2[2], title: d2[4] }, {}), render: Li }, 23: { match: Dt(vS), order: 0, parse: (d2) => ({ alt: d2[1] || void 0, ref: d2[2] }), render: (d2, m2, h2) => o[d2.ref] ? n("img", { key: h2.key, alt: d2.alt, src: yr(o[d2.ref].target), title: o[d2.ref].title }) : null }, 24: { match: Nt($S), order: 0, parse: (d2, m2, h2) => ({ children: m2(d2[1], h2), fallbackChildren: m2(d2[0].replace(_S, "\\$1"), h2), ref: d2[2] }), render: (d2, m2, h2) => o[d2.ref] ? n("a", { key: h2.key, href: yr(o[d2.ref].target), title: o[d2.ref].title }, m2(d2.children, h2)) : n("span", { key: h2.key }, m2(d2.fallbackChildren, h2)) }, 25: { match: bt($u), order: 1, parse: KS, render(d2, m2, h2) {
    const g = d2;
    return n("table", { key: h2.key }, n("thead", null, n("tr", null, g.header.map(function(y2, v) {
      return n("th", { key: v, style: nl(g, v) }, m2(y2, h2));
    }))), n("tbody", null, g.cells.map(function(y2, v) {
      return n("tr", { key: v }, y2.map(function(b, w) {
        return n("td", { key: w, style: nl(g, w) }, m2(b, h2));
      }));
    })));
  } }, 27: { match: Gr(DS), order: 4, parse: (d2) => ({ text: d2[0].replace(uS, (m2, h2) => t.namedCodesToUnicode[h2] ? t.namedCodesToUnicode[h2] : m2) }), render: (d2) => d2.text }, 28: { match: Dt(AS), order: 2, parse: (d2, m2, h2) => ({ children: m2(d2[2], h2) }), render: (d2, m2, h2) => n("strong", { key: h2.key }, m2(d2.children, h2)) }, 29: { match: Dt(PS), order: 3, parse: (d2, m2, h2) => ({ children: m2(d2[2], h2) }), render: (d2, m2, h2) => n("em", { key: h2.key }, m2(d2.children, h2)) }, 30: { match: Dt(NS), order: 1, parse: (d2) => ({ text: d2[1], type: "27" }) }, 31: { match: Dt(IS), order: 3, parse: Vi, render: (d2, m2, h2) => n("mark", { key: h2.key }, m2(d2.children, h2)) }, 32: { match: Dt(TS), order: 3, parse: Vi, render: (d2, m2, h2) => n("del", { key: h2.key }, m2(d2.children, h2)) } };
  t.disableParsingRawHTML === true && (delete l[11], delete l[13]);
  const c2 = function(d2) {
    let m2 = Object.keys(d2);
    function h2(g, y2) {
      let v = [], b = "";
      for (; g; ) {
        let w = 0;
        for (; w < m2.length; ) {
          const C = m2[w], E2 = d2[C], _3 = E2.match(g, y2, b);
          if (_3) {
            const T = _3[0];
            g = g.substring(T.length);
            const F = E2.parse(_3, h2, y2);
            F.type == null && (F.type = C), v.push(F), b = T;
            break;
          }
          w++;
        }
      }
      return v;
    }
    return m2.sort(function(g, y2) {
      let v = d2[g].order, b = d2[y2].order;
      return v !== b ? v - b : g < y2 ? -1 : 1;
    }), function(g, y2) {
      return h2(function(v) {
        return v.replace(iS, `
`).replace(oS, "").replace(SS, "    ");
      }(g), y2);
    };
  }(l), u = (f = /* @__PURE__ */ function(d2, m2) {
    return function(h2, g, y2) {
      const v = d2[h2.type].render;
      return m2 ? m2(() => v(h2, g, y2), h2, g, y2) : v(h2, g, y2);
    };
  }(l, t.renderRule), function d2(m2, h2 = {}) {
    if (Array.isArray(m2)) {
      const g = h2.key, y2 = [];
      let v = false;
      for (let b = 0; b < m2.length; b++) {
        h2.key = b;
        const w = d2(m2[b], h2), C = typeof w == "string";
        C && v ? y2[y2.length - 1] += w : w !== null && y2.push(w), v = C;
      }
      return h2.key = g, y2;
    }
    return f(m2, d2, h2);
  });
  var f;
  const p = i(e);
  return s.length ? n("div", null, p, n("footer", { key: "footer" }, s.map(function(d2) {
    return n("div", { id: t.slugify(d2.identifier), key: d2.identifier }, d2.identifier, u(c2(d2.footnote, { inline: true })));
  }))) : p;
}
var Ei = (e) => {
  let { children: t = "", options: r } = e, n = function(i, a) {
    if (i == null)
      return {};
    var s, o, l = {}, c2 = Object.keys(i);
    for (o = 0; o < c2.length; o++)
      a.indexOf(s = c2[o]) >= 0 || (l[s] = i[s]);
    return l;
  }(e, H1);
  return Ln.cloneElement(YS(t, r), n);
};
var JS = ec;
function XS(e, t) {
  return e == null ? true : JS(e, t);
}
var ZS = XS;
var QS = sn2(ZS);
var ew = class extends import_react.Component {
  constructor() {
    super(...arguments), this.state = {
      wasPropertyKeyModified: false,
      additionalProperties: {}
    }, this.onPropertyChange = (t, r = false) => (n, i, a) => {
      const { formData: s, onChange: o, errorSchema: l } = this.props;
      n === void 0 && r && (n = "");
      const c2 = { ...s, [t]: n };
      o(c2, l && l && {
        ...l,
        [t]: i
      }, a);
    }, this.onDropPropertyClick = (t) => (r) => {
      r.preventDefault();
      const { onChange: n, formData: i } = this.props, a = { ...i };
      QS(a, t), n(a);
    }, this.getAvailableKey = (t, r) => {
      const { uiSchema: n, registry: i } = this.props, { duplicateKeySuffixSeparator: a = "-" } = oe(n, i.globalUiOptions);
      let s = 0, o = t;
      for (; Le(r, o); )
        o = `${t}${a}${++s}`;
      return o;
    }, this.onKeyChange = (t) => (r, n) => {
      if (t === r)
        return;
      const { formData: i, onChange: a, errorSchema: s } = this.props;
      r = this.getAvailableKey(r, i);
      const o = {
        ...i
      }, l = { [t]: r }, c2 = Object.keys(o).map((f) => ({ [l[f] || f]: o[f] })), u = Object.assign({}, ...c2);
      this.setState({ wasPropertyKeyModified: true }), a(u, s && s && {
        ...s,
        [r]: n
      });
    }, this.handleAddClick = (t) => () => {
      if (!t.additionalProperties)
        return;
      const { formData: r, onChange: n, registry: i } = this.props, a = { ...r };
      let s, o;
      if (A(t.additionalProperties)) {
        s = t.additionalProperties.type, o = t.additionalProperties.default;
        let c2 = t.additionalProperties;
        if (Te in c2) {
          const { schemaUtils: u } = i;
          c2 = u.retrieveSchema({ $ref: c2[Te] }, r), s = c2.type, o = c2.default;
        }
        !s && (pt in c2 || et in c2) && (s = "object");
      }
      const l = this.getAvailableKey("newKey", a);
      je(a, l, o ?? this.getDefaultValue(s)), n(a);
    };
  }
  /** Returns a flag indicating whether the `name` field is required in the object schema
   *
   * @param name - The name of the field to check for required-ness
   * @returns - True if the field `name` is required, false otherwise
   */
  isRequired(t) {
    const { schema: r } = this.props;
    return Array.isArray(r.required) && r.required.indexOf(t) !== -1;
  }
  /** Returns a default value to be used for a new additional schema property of the given `type`
   *
   * @param type - The type of the new additional schema property
   */
  getDefaultValue(t) {
    const { registry: { translateString: r } } = this.props;
    switch (t) {
      case "array":
        return [];
      case "boolean":
        return false;
      case "null":
        return null;
      case "number":
        return 0;
      case "object":
        return {};
      case "string":
      default:
        return r(le.NewStringDefault);
    }
  }
  /** Renders the `ObjectField` from the given props
   */
  render() {
    var t, r, n, i;
    const { schema: a, uiSchema: s = {}, formData: o, errorSchema: l, idSchema: c2, name: u, required: f = false, disabled: p, readonly: d2, hideError: m2, idPrefix: h2, idSeparator: g, onBlur: y2, onFocus: v, registry: b, title: w } = this.props, { fields: C, formContext: E2, schemaUtils: _3, translateString: T, globalUiOptions: F } = b, { SchemaField: j2 } = C, L = _3.retrieveSchema(a, o), U = oe(s, F), { properties: W = {} } = L, z2 = (n = (r = (t = U.title) !== null && t !== void 0 ? t : L.title) !== null && r !== void 0 ? r : w) !== null && n !== void 0 ? n : u, q3 = (i = U.description) !== null && i !== void 0 ? i : L.description;
    let ue;
    try {
      const Y2 = Object.keys(W);
      ue = h1(Y2, U.order);
    } catch (Y2) {
      return N2("div", { children: [d("p", { className: "config-error", style: { color: "red" }, children: d(Ei, { children: T(le.InvalidObjectField, [u || "root", Y2.message]) }) }), d("pre", { children: JSON.stringify(L) })] });
    }
    const me = ce("ObjectFieldTemplate", b, U), ie2 = {
      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
      title: U.label === false ? "" : z2,
      description: U.label === false ? void 0 : q3,
      properties: ue.map((Y2) => {
        const V2 = Le(L, [Oe, Y2, Dr]), N3 = V2 ? s.additionalProperties : s[Y2], x3 = oe(N3).widget === "hidden", D = G2(c2, [Y2], {});
        return {
          content: d(j2, { name: Y2, required: this.isRequired(Y2), schema: G2(L, [Oe, Y2], {}), uiSchema: N3, errorSchema: G2(l, Y2), idSchema: D, idPrefix: h2, idSeparator: g, formData: G2(o, Y2), formContext: E2, wasPropertyKeyModified: this.state.wasPropertyKeyModified, onKeyChange: this.onKeyChange(Y2), onChange: this.onPropertyChange(Y2, V2), onBlur: y2, onFocus: v, registry: b, disabled: p, readonly: d2, hideError: m2, onDropPropertyClick: this.onDropPropertyClick }, Y2),
          name: Y2,
          readonly: d2,
          disabled: p,
          required: f,
          hidden: x3
        };
      }),
      readonly: d2,
      disabled: p,
      required: f,
      idSchema: c2,
      uiSchema: s,
      errorSchema: l,
      schema: L,
      formData: o,
      formContext: E2,
      registry: b
    };
    return d(me, { ...ie2, onAddClick: this.handleAddClick });
  }
};
var tw = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function rw(e, t, r, n) {
  const i = t.field, { fields: a, translateString: s } = n;
  if (typeof i == "function")
    return i;
  if (typeof i == "string" && i in a)
    return a[i];
  const o = Lt(e), l = Array.isArray(o) ? o[0] : o || "", c2 = e.$id;
  let u = tw[l];
  return c2 && c2 in a && (u = c2), !u && (e.anyOf || e.oneOf) ? () => null : u in a ? a[u] : () => {
    const f = ce("UnsupportedFieldTemplate", n, t);
    return d(f, { schema: e, idSchema: r, reason: s(le.UnknownFieldType, [String(e.type)]), registry: n });
  };
}
function nw(e) {
  var t, r, n, i, a;
  const { schema: s, idSchema: o, uiSchema: l, formData: c2, errorSchema: u, idPrefix: f, idSeparator: p, name: d2, onChange: m2, onKeyChange: h2, onDropPropertyClick: g, required: y2, registry: v, wasPropertyKeyModified: b = false } = e, { formContext: w, schemaUtils: C, globalUiOptions: E2 } = v, _3 = oe(l, E2), T = ce("FieldTemplate", v, _3), F = ce("DescriptionFieldTemplate", v, _3), j2 = ce("FieldHelpTemplate", v, _3), L = ce("FieldErrorTemplate", v, _3), U = C.retrieveSchema(s, c2), W = o[Mt], z2 = Mr(C.toIdSchema(U, W, c2, f, p), o), q3 = (0, import_react.useCallback)((qe, Wt, Ye) => m2(qe, Wt, Ye || W), [W, m2]), ue = rw(U, _3, z2, v), me = !!((t = _3.disabled) !== null && t !== void 0 ? t : e.disabled), ie2 = !!((i = (n = (r = _3.readonly) !== null && r !== void 0 ? r : e.readonly) !== null && n !== void 0 ? n : e.schema.readOnly) !== null && i !== void 0 ? i : U.readOnly), Y2 = _3.hideError, V2 = Y2 === void 0 ? e.hideError : !!Y2, N3 = !!((a = _3.autofocus) !== null && a !== void 0 ? a : e.autofocus);
  if (Object.keys(U).length === 0)
    return null;
  const x3 = C.getDisplayLabel(U, l, E2), { __errors: D, ...$ } = u || {}, P = Qn(l, ["ui:classNames", "classNames", "ui:style"]);
  nr2 in P && (P[nr2] = Qn(P[nr2], ["classNames", "style"]));
  const M = d(ue, { ...e, onChange: q3, idSchema: z2, schema: U, uiSchema: P, disabled: me, readonly: ie2, hideError: V2, autofocus: N3, errorSchema: $, formContext: w, rawErrors: D }), B = z2[Mt];
  let K;
  b ? K = d2 : K = Dr in U ? d2 : _3.title || e.schema.title || U.title || e.title || d2;
  const te = _3.description || e.schema.description || U.description || "", ae = _3.enableMarkdownInDescription ? d(Ei, { children: te }) : te, pe = _3.help, He = _3.widget === "hidden", rt = ["form-group", "field", `field-${Lt(U)}`];
  !V2 && D && D.length > 0 && rt.push("field-error has-error has-danger"), l != null && l.classNames && (console.warn("'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead."), rt.push(l.classNames)), _3.classNames && rt.push(_3.classNames);
  const qt = d(j2, { help: pe, idSchema: z2, schema: U, uiSchema: l, hasErrors: !V2 && D && D.length > 0, registry: v }), Kt = V2 || (U.anyOf || U.oneOf) && !C.isSelect(U) ? void 0 : d(L, { errors: D, errorSchema: u, idSchema: z2, schema: U, uiSchema: l, registry: v }), Ue = {
    description: d(F, { id: jr(B), description: ae, schema: U, uiSchema: l, registry: v }),
    rawDescription: te,
    help: qt,
    rawHelp: typeof pe == "string" ? pe : void 0,
    errors: Kt,
    rawErrors: V2 ? void 0 : D,
    id: B,
    label: K,
    hidden: He,
    onChange: m2,
    onKeyChange: h2,
    onDropPropertyClick: g,
    required: y2,
    disabled: me,
    readonly: ie2,
    hideError: V2,
    displayLabel: x3,
    classNames: rt.join(" ").trim(),
    style: _3.style,
    formContext: w,
    formData: c2,
    schema: U,
    uiSchema: l,
    registry: v
  }, zt = v.fields.AnyOfField, It = v.fields.OneOfField, $t = (l == null ? void 0 : l["ui:field"]) && (l == null ? void 0 : l["ui:fieldReplacesAnyOrOneOf"]) === true;
  return d(T, { ...Ue, children: N2(p1, { children: [M, U.anyOf && !$t && !C.isSelect(U) && d(zt, { name: d2, disabled: me, readonly: ie2, hideError: V2, errorSchema: u, formData: c2, formContext: w, idPrefix: f, idSchema: z2, idSeparator: p, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: U.anyOf.map((qe) => C.retrieveSchema(A(qe) ? qe : {}, c2)), registry: v, schema: U, uiSchema: l }), U.oneOf && !$t && !C.isSelect(U) && d(It, { name: d2, disabled: me, readonly: ie2, hideError: V2, errorSchema: u, formData: c2, formContext: w, idPrefix: f, idSchema: z2, idSeparator: p, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: U.oneOf.map((qe) => C.retrieveSchema(A(qe) ? qe : {}, c2)), registry: v, schema: U, uiSchema: l })] }) });
}
var iw = class extends import_react.Component {
  shouldComponentUpdate(t) {
    return !Be(this.props, t);
  }
  render() {
    return d(nw, { ...this.props });
  }
};
function aw(e) {
  var t;
  const { schema: r, name: n, uiSchema: i, idSchema: a, formData: s, required: o, disabled: l = false, readonly: c2 = false, autofocus: u = false, onChange: f, onBlur: p, onFocus: d2, registry: m2, rawErrors: h2, hideError: g } = e, { title: y2, format: v } = r, { widgets: b, formContext: w, schemaUtils: C, globalUiOptions: E2 } = m2, _3 = C.isSelect(r) ? ii(r) : void 0;
  let T = _3 ? "select" : "text";
  v && u1(r, v, b) && (T = v);
  const { widget: F = T, placeholder: j2 = "", title: L, ...U } = oe(i), W = C.getDisplayLabel(r, i, E2), z2 = (t = L ?? y2) !== null && t !== void 0 ? t : n, q3 = Et(r, F, b);
  return d(q3, { options: { ...U, enumOptions: _3 }, schema: r, uiSchema: i, id: a.$id, name: n, label: z2, hideLabel: !W, hideError: g, value: s, onChange: f, onBlur: p, onFocus: d2, required: o, disabled: l, readonly: c2, formContext: w, autofocus: u, registry: m2, placeholder: j2, rawErrors: h2 });
}
function sw(e) {
  const { formData: t, onChange: r } = e;
  return (0, import_react.useEffect)(() => {
    t === void 0 && r(null);
  }, [t, r]), null;
}
function ow() {
  return {
    AnyOfField: Yo,
    ArrayField: q1,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: K1,
    NumberField: G1,
    ObjectField: ew,
    OneOfField: Yo,
    SchemaField: iw,
    StringField: aw,
    NullField: sw
  };
}
function lw(e) {
  const { idSchema: t, description: r, registry: n, schema: i, uiSchema: a } = e, s = oe(a, n.globalUiOptions), { label: o = true } = s;
  if (!r || !o)
    return null;
  const l = ce("DescriptionFieldTemplate", n, s);
  return d(l, { id: jr(t), description: r, schema: i, uiSchema: a, registry: n });
}
function cw(e) {
  const { children: t, className: r, disabled: n, hasToolbar: i, hasMoveDown: a, hasMoveUp: s, hasRemove: o, hasCopy: l, index: c2, onCopyIndexClick: u, onDropIndexClick: f, onReorderClick: p, readonly: d2, registry: m2, uiSchema: h2 } = e, { CopyButton: g, MoveDownButton: y2, MoveUpButton: v, RemoveButton: b } = m2.templates.ButtonTemplates, w = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  return N2("div", { className: r, children: [d("div", { className: i ? "col-xs-9" : "col-xs-12", children: t }), i && d("div", { className: "col-xs-3 array-item-toolbox", children: N2("div", { className: "btn-group", style: {
    display: "flex",
    justifyContent: "space-around"
  }, children: [(s || a) && d(v, { style: w, disabled: n || d2 || !s, onClick: p(c2, c2 - 1), uiSchema: h2, registry: m2 }), (s || a) && d(y2, { style: w, disabled: n || d2 || !a, onClick: p(c2, c2 + 1), uiSchema: h2, registry: m2 }), l && d(g, { style: w, disabled: n || d2, onClick: u(c2), uiSchema: h2, registry: m2 }), o && d(b, { style: w, disabled: n || d2, onClick: f(c2), uiSchema: h2, registry: m2 })] }) })] });
}
function uw(e) {
  const { canAdd: t, className: r, disabled: n, idSchema: i, uiSchema: a, items: s, onAddClick: o, readonly: l, registry: c2, required: u, schema: f, title: p } = e, d2 = oe(a), m2 = ce("ArrayFieldDescriptionTemplate", c2, d2), h2 = ce("ArrayFieldItemTemplate", c2, d2), g = ce("ArrayFieldTitleTemplate", c2, d2), { ButtonTemplates: { AddButton: y2 } } = c2.templates;
  return N2("fieldset", { className: r, id: i.$id, children: [d(g, { idSchema: i, title: d2.title || p, required: u, schema: f, uiSchema: a, registry: c2 }), d(m2, { idSchema: i, description: d2.description || f.description, schema: f, uiSchema: a, registry: c2 }), d("div", { className: "row array-item-list", children: s && s.map(({ key: v, ...b }) => d(h2, { ...b }, v)) }), t && d(y2, { className: "array-item-add", onClick: o, disabled: n || l, uiSchema: a, registry: c2 })] });
}
function dw(e) {
  const { idSchema: t, title: r, schema: n, uiSchema: i, required: a, registry: s } = e, o = oe(i, s.globalUiOptions), { label: l = true } = o;
  if (!r || !l)
    return null;
  const c2 = ce("TitleFieldTemplate", s, o);
  return d(c2, { id: is(t), title: r, required: a, schema: n, uiSchema: i, registry: s });
}
function fw(e) {
  const {
    id: t,
    name: r,
    // remove this from ...rest
    value: n,
    readonly: i,
    disabled: a,
    autofocus: s,
    onBlur: o,
    onFocus: l,
    onChange: c2,
    onChangeOverride: u,
    options: f,
    schema: p,
    uiSchema: d2,
    formContext: m2,
    registry: h2,
    rawErrors: g,
    type: y2,
    hideLabel: v,
    // remove this from ...rest
    hideError: b,
    // remove this from ...rest
    ...w
  } = e;
  if (!t)
    throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
  const C = {
    ...w,
    ...su(p, y2, f)
  };
  let E2;
  C.type === "number" || C.type === "integer" ? E2 = n || n === 0 ? n : "" : E2 = n ?? "";
  const _3 = (0, import_react.useCallback)(({ target: { value: j2 } }) => c2(j2 === "" ? f.emptyValue : j2), [c2, f]), T = (0, import_react.useCallback)(({ target: j2 }) => o(t, j2 && j2.value), [o, t]), F = (0, import_react.useCallback)(({ target: j2 }) => l(t, j2 && j2.value), [l, t]);
  return N2(p1, { children: [d("input", { id: t, name: t, className: "form-control", readOnly: i, disabled: a, autoFocus: s, value: E2, ...C, list: p.examples ? Sr(t) : void 0, onChange: u || _3, onBlur: T, onFocus: F, "aria-describedby": De(t, !!p.examples) }), Array.isArray(p.examples) && d("datalist", { id: Sr(t), children: p.examples.concat(p.default && !p.examples.includes(p.default) ? [p.default] : []).map((j2) => d("option", { value: j2 }, j2)) }, `datalist_${t}`)] });
}
function hw({ uiSchema: e }) {
  const { submitText: t, norender: r, props: n = {} } = ou(e);
  return r ? null : d("div", { children: d("button", { type: "submit", ...n, className: `btn btn-info ${n.className || ""}`, children: t }) });
}
function vn(e) {
  const { iconType: t = "default", icon: r, className: n, uiSchema: i, registry: a, ...s } = e;
  return d("button", { type: "button", className: `btn btn-${t} ${n}`, ...s, children: d("i", { className: `glyphicon glyphicon-${r}` }) });
}
function mw(e) {
  const { registry: { translateString: t } } = e;
  return d(vn, { title: t(le.CopyButton), className: "array-item-copy", ...e, icon: "copy" });
}
function pw(e) {
  const { registry: { translateString: t } } = e;
  return d(vn, { title: t(le.MoveDownButton), className: "array-item-move-down", ...e, icon: "arrow-down" });
}
function yw(e) {
  const { registry: { translateString: t } } = e;
  return d(vn, { title: t(le.MoveUpButton), className: "array-item-move-up", ...e, icon: "arrow-up" });
}
function gw(e) {
  const { registry: { translateString: t } } = e;
  return d(vn, { title: t(le.RemoveButton), className: "array-item-remove", ...e, iconType: "danger", icon: "remove" });
}
function vw({ className: e, onClick: t, disabled: r, registry: n }) {
  const { translateString: i } = n;
  return d("div", { className: "row", children: d("p", { className: `col-xs-3 col-xs-offset-9 text-right ${e}`, children: d(vn, { iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: i(le.AddButton), onClick: t, disabled: r, registry: n }) }) });
}
function $w() {
  return {
    SubmitButton: hw,
    AddButton: vw,
    CopyButton: mw,
    MoveDownButton: pw,
    MoveUpButton: yw,
    RemoveButton: gw
  };
}
function _w(e) {
  const { id: t, description: r } = e;
  return r ? typeof r == "string" ? d("p", { id: t, className: "field-description", children: r }) : d("div", { id: t, className: "field-description", children: r }) : null;
}
function bw({ errors: e, registry: t }) {
  const { translateString: r } = t;
  return N2("div", { className: "panel panel-danger errors", children: [d("div", { className: "panel-heading", children: d("h3", { className: "panel-title", children: r(le.ErrorsLabel) }) }), d("ul", { className: "list-group", children: e.map((n, i) => d("li", { className: "list-group-item text-danger", children: n.stack }, i)) })] });
}
var Sw = "*";
function Nu(e) {
  const { label: t, required: r, id: n } = e;
  return t ? N2("label", { className: "control-label", htmlFor: n, children: [t, r && d("span", { className: "required", children: Sw })] }) : null;
}
function ww(e) {
  const { id: t, label: r, children: n, errors: i, help: a, description: s, hidden: o, required: l, displayLabel: c2, registry: u, uiSchema: f } = e, p = oe(f), d2 = ce("WrapIfAdditionalTemplate", u, p);
  return o ? d("div", { className: "hidden", children: n }) : N2(d2, { ...e, children: [c2 && d(Nu, { label: r, required: l, id: t }), c2 && s ? s : null, n, i, a] });
}
function Ew(e) {
  const { errors: t = [], idSchema: r } = e;
  if (t.length === 0)
    return null;
  const n = ns(r);
  return d("div", { children: d("ul", { id: n, className: "error-detail bs-callout bs-callout-info", children: t.filter((i) => !!i).map((i, a) => d("li", { className: "text-danger", children: i }, a)) }) });
}
function Ow(e) {
  const { idSchema: t, help: r } = e;
  if (!r)
    return null;
  const n = lu(t);
  return typeof r == "string" ? d("p", { id: n, className: "help-block", children: r }) : d("div", { id: n, className: "help-block", children: r });
}
function Cw(e) {
  const { description: t, disabled: r, formData: n, idSchema: i, onAddClick: a, properties: s, readonly: o, registry: l, required: c2, schema: u, title: f, uiSchema: p } = e, d2 = oe(p), m2 = ce("TitleFieldTemplate", l, d2), h2 = ce("DescriptionFieldTemplate", l, d2), { ButtonTemplates: { AddButton: g } } = l.templates;
  return N2("fieldset", { id: i.$id, children: [f && d(m2, { id: is(i), title: f, required: c2, schema: u, uiSchema: p, registry: l }), t && d(h2, { id: jr(i), description: t, schema: u, uiSchema: p, registry: l }), s.map((y2) => y2.content), ql(u, p, n) && d(g, { className: "object-property-expand", onClick: a(u), disabled: r || o, uiSchema: p, registry: l })] });
}
var Aw = "*";
function Pw(e) {
  const { id: t, title: r, required: n } = e;
  return N2("legend", { id: t, children: [r, n && d("span", { className: "required", children: Aw })] });
}
function Iw(e) {
  const { schema: t, idSchema: r, reason: n, registry: i } = e, { translateString: a } = i;
  let s = le.UnsupportedField;
  const o = [];
  return r && r.$id && (s = le.UnsupportedFieldWithId, o.push(r.$id)), n && (s = s === le.UnsupportedField ? le.UnsupportedFieldWithReason : le.UnsupportedFieldWithIdAndReason, o.push(n)), N2("div", { className: "unsupported-field", children: [d("p", { children: d(Ei, { children: a(s, o) }) }), t && d("pre", { children: JSON.stringify(t, null, 2) })] });
}
function Tw(e) {
  const { id: t, classNames: r, style: n, disabled: i, label: a, onKeyChange: s, onDropPropertyClick: o, readonly: l, required: c2, schema: u, children: f, uiSchema: p, registry: d2 } = e, { templates: m2, translateString: h2 } = d2, { RemoveButton: g } = m2.ButtonTemplates, y2 = h2(le.KeyLabel, [a]);
  return Dr in u ? d("div", { className: r, style: n, children: N2("div", { className: "row", children: [d("div", { className: "col-xs-5 form-additional", children: N2("div", { className: "form-group", children: [d(Nu, { label: y2, required: c2, id: `${t}-key` }), d("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: ({ target: b }) => s(b && b.value), defaultValue: a })] }) }), d("div", { className: "form-additional form-group col-xs-5", children: f }), d("div", { className: "col-xs-2", children: d(g, { className: "array-item-remove btn-block", style: { border: "0" }, disabled: i || l, onClick: o(a), uiSchema: p, registry: d2 }) })] }) }) : d("div", { className: r, style: n, children: f });
}
function Nw() {
  return {
    ArrayFieldDescriptionTemplate: lw,
    ArrayFieldItemTemplate: cw,
    ArrayFieldTemplate: uw,
    ArrayFieldTitleTemplate: dw,
    ButtonTemplates: $w(),
    BaseInputTemplate: fw,
    DescriptionFieldTemplate: _w,
    ErrorListTemplate: bw,
    FieldTemplate: ww,
    FieldErrorTemplate: Ew,
    FieldHelpTemplate: Ow,
    ObjectFieldTemplate: Cw,
    TitleFieldTemplate: Pw,
    UnsupportedFieldTemplate: Iw,
    WrapIfAdditionalTemplate: Tw
  };
}
function Dw(e, t) {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push({ value: n, label: St(n, 2) });
  return r;
}
function Fw(e) {
  return Object.values(e).every((t) => t !== -1);
}
function kw({ type: e, range: t, value: r, select: n, rootId: i, name: a, disabled: s, readonly: o, autofocus: l, registry: c2, onBlur: u, onFocus: f }) {
  const p = i + "_" + e, { SelectWidget: d2 } = c2.widgets;
  return d(d2, { schema: { type: "integer" }, id: p, name: a, className: "form-control", options: { enumOptions: Dw(t[0], t[1]) }, placeholder: e, value: r, disabled: s, readonly: o, autofocus: l, onChange: (m2) => n(e, m2), onBlur: u, onFocus: f, registry: c2, label: "", "aria-describedby": De(i) });
}
function Rw({ time: e = false, disabled: t = false, readonly: r = false, autofocus: n = false, options: i, id: a, name: s, registry: o, onBlur: l, onFocus: c2, onChange: u, value: f }) {
  const { translateString: p } = o, [d2, m2] = (0, import_react.useState)(f), [h2, g] = (0, import_react.useReducer)((w, C) => ({ ...w, ...C }), wr(f, e));
  (0, import_react.useEffect)(() => {
    const w = ai(h2, e);
    Fw(h2) && w !== f ? u(w) : d2 !== f && (m2(f), g(wr(f, e)));
  }, [e, f, u, h2, d2]);
  const y2 = (0, import_react.useCallback)((w, C) => {
    g({ [w]: C });
  }, []), v = (0, import_react.useCallback)((w) => {
    if (w.preventDefault(), t || r)
      return;
    const C = wr((/* @__PURE__ */ new Date()).toJSON(), e);
    u(ai(C, e));
  }, [t, r, e]), b = (0, import_react.useCallback)((w) => {
    w.preventDefault(), !(t || r) && u(void 0);
  }, [t, r, u]);
  return N2("ul", { className: "list-inline", children: [iu(h2, e, i.yearsRange, i.format).map((w, C) => d("li", { className: "list-inline-item", children: d(kw, { rootId: a, name: s, select: y2, ...w, disabled: t, readonly: r, registry: o, onBlur: l, onFocus: c2, autofocus: n && C === 0 }) }, C)), (i.hideNowButton !== "undefined" ? !i.hideNowButton : true) && d("li", { className: "list-inline-item", children: d("a", { href: "#", className: "btn btn-info btn-now", onClick: v, children: p(le.NowLabel) }) }), (i.hideClearButton !== "undefined" ? !i.hideClearButton : true) && d("li", { className: "list-inline-item", children: d("a", { href: "#", className: "btn btn-warning btn-clear", onClick: b, children: p(le.ClearLabel) }) })] });
}
function Mw({ time: e = true, ...t }) {
  const { AltDateWidget: r } = t.registry.widgets;
  return d(r, { time: e, ...t });
}
function jw({ schema: e, uiSchema: t, options: r, id: n, value: i, disabled: a, readonly: s, label: o, hideLabel: l, autofocus: c2 = false, onBlur: u, onFocus: f, onChange: p, registry: d2 }) {
  var m2;
  const h2 = ce("DescriptionFieldTemplate", d2, r), g = zn(e), y2 = (0, import_react.useCallback)((C) => p(C.target.checked), [p]), v = (0, import_react.useCallback)((C) => u(n, C.target.checked), [u, n]), b = (0, import_react.useCallback)((C) => f(n, C.target.checked), [f, n]), w = (m2 = r.description) !== null && m2 !== void 0 ? m2 : e.description;
  return N2("div", { className: `checkbox ${a || s ? "disabled" : ""}`, children: [!l && !!w && d(h2, { id: jr(n), description: w, schema: e, uiSchema: t, registry: d2 }), N2("label", { children: [d("input", { type: "checkbox", id: n, name: n, checked: typeof i > "u" ? false : i, required: g, disabled: a || s, autoFocus: c2, onChange: y2, onBlur: v, onFocus: b, "aria-describedby": De(n) }), cu(d("span", { children: o }), l)] })] });
}
function Uw({ id: e, disabled: t, options: { inline: r = false, enumOptions: n, enumDisabled: i, emptyValue: a }, value: s, autofocus: o = false, readonly: l, onChange: c2, onBlur: u, onFocus: f }) {
  const p = Array.isArray(s) ? s : [s], d2 = (0, import_react.useCallback)(({ target: h2 }) => u(e, Ne(h2 && h2.value, n, a)), [u, e]), m2 = (0, import_react.useCallback)(({ target: h2 }) => f(e, Ne(h2 && h2.value, n, a)), [f, e]);
  return d("div", { className: "checkboxes", id: e, children: Array.isArray(n) && n.map((h2, g) => {
    const y2 = rs(h2.value, p), v = Array.isArray(i) && i.indexOf(h2.value) !== -1, b = t || v || l ? "disabled" : "", w = (E2) => {
      E2.target.checked ? c2(a1(g, p, n)) : c2(t1(g, p, n));
    }, C = N2("span", { children: [d("input", { type: "checkbox", id: Si(e, g), name: e, checked: y2, value: String(g), disabled: t || v || l, autoFocus: o && g === 0, onChange: w, onBlur: d2, onFocus: m2, "aria-describedby": De(e) }), d("span", { children: h2.label })] });
    return r ? d("label", { className: `checkbox-inline ${b}`, children: C }, g) : d("div", { className: `checkbox ${b}`, children: d("label", { children: C }) }, g);
  }) });
}
function Vw(e) {
  const { disabled: t, readonly: r, options: n, registry: i } = e, a = ce("BaseInputTemplate", i, n);
  return d(a, { type: "color", ...e, disabled: t || r });
}
function xw(e) {
  const { onChange: t, options: r, registry: n } = e, i = ce("BaseInputTemplate", n, r), a = (0, import_react.useCallback)((s) => t(s || void 0), [t]);
  return d(i, { type: "date", ...e, onChange: a });
}
function Lw(e) {
  const { onChange: t, value: r, options: n, registry: i } = e, a = ce("BaseInputTemplate", i, n);
  return d(a, { type: "datetime-local", ...e, value: O1(r), onChange: (s) => t(d1(s)) });
}
function Bw(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return d(n, { type: "email", ...e });
}
function qw(e, t) {
  return e === null ? null : e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
}
function Kw(e) {
  const { name: t, size: r, type: n } = e;
  return new Promise((i, a) => {
    const s = new window.FileReader();
    s.onerror = a, s.onload = (o) => {
      var l;
      typeof ((l = o.target) === null || l === void 0 ? void 0 : l.result) == "string" ? i({
        dataURL: qw(o.target.result, t),
        name: t,
        size: r,
        type: n
      }) : i({
        dataURL: null,
        name: t,
        size: r,
        type: n
      });
    }, s.readAsDataURL(e);
  });
}
function zw(e) {
  return Promise.all(Array.from(e).map(Kw));
}
function Ww({ fileInfo: e, registry: t }) {
  const { translateString: r } = t, { dataURL: n, type: i, name: a } = e;
  return n ? ["image/jpeg", "image/png"].includes(i) ? d("img", { src: n, style: { maxWidth: "100%" }, className: "file-preview" }) : N2(p1, { children: [" ", d("a", { download: `preview-${a}`, href: n, className: "file-download", children: r(le.PreviewLabel) })] }) : null;
}
function Gw({ filesInfo: e, registry: t, preview: r, onRemove: n, options: i }) {
  if (e.length === 0)
    return null;
  const { translateString: a } = t, { RemoveButton: s } = ce("ButtonTemplates", t, i);
  return d("ul", { className: "file-info", children: e.map((o, l) => {
    const { name: c2, size: u, type: f } = o, p = () => n(l);
    return N2("li", { children: [d(Ei, { children: a(le.FilesInfo, [c2, f, String(u)]) }), r && d(Ww, { fileInfo: o, registry: t }), d(s, { onClick: p, registry: t })] }, l);
  }) });
}
function Hw(e) {
  return e.reduce((t, r) => {
    if (!r)
      return t;
    try {
      const { blob: n, name: i } = Zb(r);
      return [
        ...t,
        {
          dataURL: r,
          name: i,
          size: n.size,
          type: n.type
        }
      ];
    } catch {
      return t;
    }
  }, []);
}
function Yw(e) {
  const { disabled: t, readonly: r, required: n, multiple: i, onChange: a, value: s, options: o, registry: l } = e, c2 = ce("BaseInputTemplate", l, o), u = (0, import_react.useCallback)((d2) => {
    d2.target.files && zw(d2.target.files).then((m2) => {
      const h2 = m2.map((g) => g.dataURL);
      a(i ? s.concat(h2[0]) : h2[0]);
    });
  }, [i, s, a]), f = (0, import_react.useMemo)(() => Hw(Array.isArray(s) ? s : [s]), [s]), p = (0, import_react.useCallback)((d2) => {
    if (i) {
      const m2 = s.filter((h2, g) => g !== d2);
      a(m2);
    } else
      a(void 0);
  }, [i, s, a]);
  return N2("div", { children: [d(c2, { ...e, disabled: t || r, type: "file", required: s ? false : n, onChangeOverride: u, value: "", accept: o.accept ? String(o.accept) : void 0 }), d(Gw, { filesInfo: f, onRemove: p, registry: l, preview: o.filePreview, options: o })] });
}
function Jw({ id: e, value: t }) {
  return d("input", { type: "hidden", id: e, name: e, value: typeof t > "u" ? "" : t });
}
function Xw(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return d(n, { type: "password", ...e });
}
function Zw({ options: e, value: t, required: r, disabled: n, readonly: i, autofocus: a = false, onBlur: s, onFocus: o, onChange: l, id: c2 }) {
  const { enumOptions: u, enumDisabled: f, inline: p, emptyValue: d2 } = e, m2 = (0, import_react.useCallback)(({ target: g }) => s(c2, Ne(g && g.value, u, d2)), [s, c2]), h2 = (0, import_react.useCallback)(({ target: g }) => o(c2, Ne(g && g.value, u, d2)), [o, c2]);
  return d("div", { className: "field-radio-group", id: c2, children: Array.isArray(u) && u.map((g, y2) => {
    const v = rs(g.value, t), b = Array.isArray(f) && f.indexOf(g.value) !== -1, w = n || b || i ? "disabled" : "", C = () => l(g.value), E2 = N2("span", { children: [d("input", { type: "radio", id: Si(c2, y2), checked: v, name: c2, required: r, value: String(y2), disabled: n || b || i, autoFocus: a && y2 === 0, onChange: C, onBlur: m2, onFocus: h2, "aria-describedby": De(c2) }), d("span", { children: g.label })] });
    return p ? d("label", { className: `radio-inline ${w}`, children: E2 }, y2) : d("div", { className: `radio ${w}`, children: d("label", { children: E2 }) }, y2);
  }) });
}
function Qw(e) {
  const { value: t, registry: { templates: { BaseInputTemplate: r } } } = e;
  return N2("div", { className: "field-range-wrapper", children: [d(r, { type: "range", ...e }), d("span", { className: "range-view", children: t })] });
}
function qi(e, t) {
  return t ? Array.from(e.target.options).slice().filter((r) => r.selected).map((r) => r.value) : e.target.value;
}
function eE({ schema: e, id: t, options: r, value: n, required: i, disabled: a, readonly: s, multiple: o = false, autofocus: l = false, onChange: c2, onBlur: u, onFocus: f, placeholder: p }) {
  const { enumOptions: d2, enumDisabled: m2, emptyValue: h2 } = r, g = o ? [] : "", y2 = (0, import_react.useCallback)((C) => {
    const E2 = qi(C, o);
    return f(t, Ne(E2, d2, h2));
  }, [f, t, e, o, r]), v = (0, import_react.useCallback)((C) => {
    const E2 = qi(C, o);
    return u(t, Ne(E2, d2, h2));
  }, [u, t, e, o, r]), b = (0, import_react.useCallback)((C) => {
    const E2 = qi(C, o);
    return c2(Ne(E2, d2, h2));
  }, [c2, e, o, r]), w = bi(n, d2, o);
  return N2("select", { id: t, name: t, multiple: o, className: "form-control", value: typeof w > "u" ? g : w, required: i, disabled: a || s, autoFocus: l, onBlur: v, onFocus: y2, onChange: b, "aria-describedby": De(t), children: [!o && e.default === void 0 && d("option", { value: "", children: p }), Array.isArray(d2) && d2.map(({ value: C, label: E2 }, _3) => {
    const T = m2 && m2.indexOf(C) !== -1;
    return d("option", { value: String(_3), disabled: T, children: E2 }, _3);
  })] });
}
function Du({ id: e, options: t = {}, placeholder: r, value: n, required: i, disabled: a, readonly: s, autofocus: o = false, onChange: l, onBlur: c2, onFocus: u }) {
  const f = (0, import_react.useCallback)(({ target: { value: m2 } }) => l(m2 === "" ? t.emptyValue : m2), [l, t.emptyValue]), p = (0, import_react.useCallback)(({ target: m2 }) => c2(e, m2 && m2.value), [c2, e]), d2 = (0, import_react.useCallback)(({ target: m2 }) => u(e, m2 && m2.value), [e, u]);
  return d("textarea", { id: e, name: e, className: "form-control", value: n || "", placeholder: r, required: i, disabled: a, readOnly: s, autoFocus: o, rows: t.rows, onBlur: p, onFocus: d2, onChange: f, "aria-describedby": De(e) });
}
Du.defaultProps = {
  autofocus: false,
  options: {}
};
function tE(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return d(n, { ...e });
}
function rE(e) {
  const { onChange: t, options: r, registry: n } = e, i = ce("BaseInputTemplate", n, r), a = (0, import_react.useCallback)((s) => t(s ? `${s}:00` : void 0), [t]);
  return d(i, { type: "time", ...e, onChange: a });
}
function nE(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return d(n, { type: "url", ...e });
}
function iE(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return d(n, { type: "number", ...e });
}
function aE() {
  return {
    AltDateWidget: Rw,
    AltDateTimeWidget: Mw,
    CheckboxWidget: jw,
    CheckboxesWidget: Uw,
    ColorWidget: Vw,
    DateWidget: xw,
    DateTimeWidget: Lw,
    EmailWidget: Bw,
    FileWidget: Yw,
    HiddenWidget: Jw,
    PasswordWidget: Xw,
    RadioWidget: Zw,
    RangeWidget: Qw,
    SelectWidget: eE,
    TextWidget: tE,
    TextareaWidget: Du,
    TimeWidget: rE,
    UpDownWidget: iE,
    URLWidget: nE
  };
}
function sE() {
  return {
    fields: ow(),
    templates: Nw(),
    widgets: aE(),
    rootSchema: {},
    formContext: {},
    translateString: e1
  };
}
var oE = class extends import_react.Component {
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(t) {
    if (super(t), this.getUsedFormData = (r, n) => {
      if (n.length === 0 && typeof r != "object")
        return r;
      const i = L1(r, n);
      return Array.isArray(r) ? Object.keys(i).map((a) => i[a]) : i;
    }, this.getFieldNames = (r, n) => {
      const i = (a, s = [], o = [[]]) => (Object.keys(a).forEach((l) => {
        if (typeof a[l] == "object") {
          const c2 = o.map((u) => [...u, l]);
          a[l][Ia] && a[l][Bn] !== "" ? s.push(a[l][Bn]) : i(a[l], s, c2);
        } else
          l === Bn && a[l] !== "" && o.forEach((c2) => {
            const u = G2(n, c2);
            (typeof u != "object" || xt(u) || Array.isArray(u) && u.every((f) => typeof f != "object")) && s.push(c2);
          });
      }), s);
      return i(r);
    }, this.omitExtraData = (r) => {
      const { schema: n, schemaUtils: i } = this.state, a = i.retrieveSchema(n, r), s = i.toPathSchema(a, "", r), o = this.getFieldNames(s, r);
      return this.getUsedFormData(r, o);
    }, this.onChange = (r, n, i) => {
      const { extraErrors: a, omitExtraData: s, liveOmit: o, noValidate: l, liveValidate: c2, onChange: u } = this.props, { schemaUtils: f, schema: p, retrievedSchema: d2 } = this.state;
      (Se(r) || Array.isArray(r)) && (r = this.getStateFromProps(this.props, r, d2).formData);
      const m2 = !l && c2;
      let h2 = { formData: r, schema: p }, g = r;
      if (s === true && o === true && (g = this.omitExtraData(r), h2 = {
        formData: g
      }), m2) {
        const y2 = this.validate(g, p, f, d2);
        let v = y2.errors, b = y2.errorSchema;
        const w = v, C = b;
        if (a) {
          const E2 = Wn(y2, a);
          b = E2.errorSchema, v = E2.errors;
        }
        h2 = {
          formData: g,
          errors: v,
          errorSchema: b,
          schemaValidationErrors: w,
          schemaValidationErrorSchema: C
        };
      } else if (!l && n) {
        const y2 = a ? Mr(n, a, "preventDuplicates") : n;
        h2 = {
          formData: g,
          errorSchema: y2,
          errors: sn3(y2)
        };
      }
      this.setState(h2, () => u && u({ ...this.state, ...h2 }, i));
    }, this.reset = () => {
      const { onChange: r } = this.props, a = {
        formData: this.getStateFromProps(this.props, void 0).formData,
        errorSchema: {},
        errors: [],
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      };
      this.setState(a, () => r && r({ ...this.state, ...a }));
    }, this.onBlur = (r, n) => {
      const { onBlur: i } = this.props;
      i && i(r, n);
    }, this.onFocus = (r, n) => {
      const { onFocus: i } = this.props;
      i && i(r, n);
    }, this.onSubmit = (r) => {
      if (r.preventDefault(), r.target !== r.currentTarget)
        return;
      r.persist();
      const { omitExtraData: n, extraErrors: i, noValidate: a, onSubmit: s } = this.props;
      let { formData: o } = this.state;
      if (n === true && (o = this.omitExtraData(o)), a || this.validateFormWithFormData(o)) {
        const l = i || {}, c2 = i ? sn3(i) : [];
        this.setState({
          formData: o,
          errors: c2,
          errorSchema: l,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        }, () => {
          s && s({ ...this.state, formData: o, status: "submitted" }, r);
        });
      }
    }, this.submit = () => {
      if (this.formElement.current) {
        const r = new CustomEvent("submit", {
          cancelable: true
        });
        r.preventDefault(), this.formElement.current.dispatchEvent(r), this.formElement.current.requestSubmit();
      }
    }, this.validateFormWithFormData = (r) => {
      const { extraErrors: n, extraErrorsBlockSubmit: i, focusOnFirstError: a, onError: s } = this.props, { errors: o } = this.state, l = this.validate(r);
      let c2 = l.errors, u = l.errorSchema;
      const f = c2, p = u, d2 = c2.length > 0 || n && i;
      if (d2) {
        if (n) {
          const m2 = Wn(l, n);
          u = m2.errorSchema, c2 = m2.errors;
        }
        a && (typeof a == "function" ? a(c2[0]) : this.focusOnError(c2[0])), this.setState({
          errors: c2,
          errorSchema: u,
          schemaValidationErrors: f,
          schemaValidationErrorSchema: p
        }, () => {
          s ? s(c2) : console.error("Form validation failed", c2);
        });
      } else
        o.length > 0 && this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
      return !d2;
    }, !t.validator)
      throw new Error("A validator is required for Form functionality to work");
    this.state = this.getStateFromProps(t, t.formData), this.props.onChange && !Be(this.state.formData, this.props.formData) && this.props.onChange(this.state), this.formElement = (0, import_react.createRef)();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(t, r) {
    if (!Be(this.props, t)) {
      const n = !Be(t.schema, this.props.schema), i = !Be(t.formData, this.props.formData), a = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        n || i ? void 0 : this.state.retrievedSchema,
        n
      ), s = !Be(a, r);
      return { nextState: a, shouldUpdate: s };
    }
    return { shouldUpdate: false };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative
   * to handle prop changes and state updates.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(t, r, n) {
    if (n.shouldUpdate) {
      const { nextState: i } = n;
      !Be(i.formData, this.props.formData) && !Be(i.formData, r.formData) && this.props.onChange && this.props.onChange(i), this.setState(i);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @returns - The new state for the `Form`
   */
  getStateFromProps(t, r, n, i = false) {
    const a = this.state || {}, s = "schema" in t ? t.schema : this.props.schema, o = ("uiSchema" in t ? t.uiSchema : this.props.uiSchema) || {}, l = typeof r < "u", c2 = "liveValidate" in t ? t.liveValidate : this.props.liveValidate, u = l && !t.noValidate && c2, f = s, p = "experimental_defaultFormStateBehavior" in t ? t.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;
    let d2 = a.schemaUtils;
    (!d2 || d2.doesSchemaUtilsDiffer(t.validator, f, p)) && (d2 = Xb(t.validator, f, p));
    const m2 = d2.getDefaultFormState(s, r), h2 = n ?? d2.retrieveSchema(s, m2), g = () => t.noValidate || i ? { errors: [], errorSchema: {} } : t.liveValidate ? {
      errors: a.errors || [],
      errorSchema: a.errorSchema || {}
    } : {
      errors: a.schemaValidationErrors || [],
      errorSchema: a.schemaValidationErrorSchema || {}
    };
    let y2, v, b = a.schemaValidationErrors, w = a.schemaValidationErrorSchema;
    if (u) {
      const _3 = this.validate(m2, s, d2, h2);
      y2 = _3.errors, v = _3.errorSchema, b = y2, w = v;
    } else {
      const _3 = g();
      y2 = _3.errors, v = _3.errorSchema;
    }
    if (t.extraErrors) {
      const _3 = Wn({ errorSchema: v, errors: y2 }, t.extraErrors);
      v = _3.errorSchema, y2 = _3.errors;
    }
    const C = d2.toIdSchema(h2, o["ui:rootFieldId"], m2, t.idPrefix, t.idSeparator);
    return {
      schemaUtils: d2,
      schema: s,
      uiSchema: o,
      idSchema: C,
      formData: m2,
      edit: l,
      errors: y2,
      errorSchema: v,
      schemaValidationErrors: b,
      schemaValidationErrorSchema: w,
      retrievedSchema: h2
    };
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(t, r) {
    return m1(this, t, r);
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param altSchemaUtils - The alternate schemaUtils to use for validation
   */
  validate(t, r = this.props.schema, n, i) {
    const a = n || this.state.schemaUtils, { customValidate: s, transformErrors: o, uiSchema: l } = this.props, c2 = i ?? a.retrieveSchema(r, t);
    return a.getValidator().validateFormData(t, c2, s, o, l);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(t) {
    const { errors: r, errorSchema: n, schema: i, uiSchema: a } = this.state, { formContext: s } = this.props, o = oe(a), l = ce("ErrorListTemplate", t, o);
    return r && r.length ? d(l, { errors: r, errorSchema: n || {}, schema: i, uiSchema: a, formContext: s, registry: t }) : null;
  }
  /** Returns the registry for the form */
  getRegistry() {
    var t;
    const { translateString: r, uiSchema: n = {} } = this.props, { schemaUtils: i } = this.state, { fields: a, templates: s, widgets: o, formContext: l, translateString: c2 } = sE();
    return {
      fields: { ...a, ...this.props.fields },
      templates: {
        ...s,
        ...this.props.templates,
        ButtonTemplates: {
          ...s.ButtonTemplates,
          ...(t = this.props.templates) === null || t === void 0 ? void 0 : t.ButtonTemplates
        }
      },
      widgets: { ...o, ...this.props.widgets },
      rootSchema: this.props.schema,
      formContext: this.props.formContext || l,
      schemaUtils: i,
      translateString: r || c2,
      globalUiOptions: n[jf]
    };
  }
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(t) {
    const { idPrefix: r = "root", idSeparator: n = "_" } = this.props, { property: i } = t, a = uu(i);
    a[0] === "" ? a[0] = r : a.unshift(r);
    const s = a.join(n);
    let o = this.formElement.current.elements[s];
    o || (o = this.formElement.current.querySelector(`input[id^=${s}`)), o && o.length && (o = o[0]), o && o.focus();
  }
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData: t } = this.props;
    let { formData: r } = this.state;
    return t === true && (r = this.omitExtraData(r)), this.validateFormWithFormData(r);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const { children: t, id: r, idPrefix: n, idSeparator: i, className: a = "", tagName: s, name: o, method: l, target: c2, action: u, autoComplete: f, enctype: p, acceptcharset: d2, acceptCharset: m2, noHtml5Validate: h2 = false, disabled: g, readonly: y2, formContext: v, showErrorList: b = "top", _internalFormWrapper: w } = this.props, { schema: C, uiSchema: E2, formData: _3, errorSchema: T, idSchema: F } = this.state, j2 = this.getRegistry(), { SchemaField: L } = j2.fields, { SubmitButton: U } = j2.templates.ButtonTemplates, W = w ? s : void 0, z2 = w || s || "form";
    let { [Zn]: q3 = {} } = oe(E2);
    g && (q3 = { ...q3, props: { ...q3.props, disabled: true } });
    const ue = { [nr2]: { [Zn]: q3 } };
    return N2(z2, { className: a || "rjsf", id: r, name: o, method: l, target: c2, action: u, autoComplete: f, encType: p, acceptCharset: m2 || d2, noValidate: h2, onSubmit: this.onSubmit, as: W, ref: this.formElement, children: [b === "top" && this.renderErrors(j2), d(L, { name: "", schema: C, uiSchema: E2, errorSchema: T, idSchema: F, idPrefix: n, idSeparator: i, formContext: v, formData: _3, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: j2, disabled: g, readonly: y2 }), t || d(U, { uiSchema: ue, registry: j2 }), b === "bottom" && this.renderErrors(j2)] });
  }
};
function Fu(e) {
  return (0, import_react.forwardRef)(({ fields: t, widgets: r, templates: n, ...i }, a) => {
    var s;
    return t = { ...e == null ? void 0 : e.fields, ...t }, r = { ...e == null ? void 0 : e.widgets, ...r }, n = {
      ...e == null ? void 0 : e.templates,
      ...n,
      ButtonTemplates: {
        ...(s = e == null ? void 0 : e.templates) === null || s === void 0 ? void 0 : s.ButtonTemplates,
        ...n == null ? void 0 : n.ButtonTemplates
      }
    }, d(oE, { ...e, ...i, fields: t, widgets: r, templates: n, ref: a });
  });
}
var oa = { exports: {} };
var ku = {};
var lt = {};
var Tr = {};
var $n = {};
var re2 = {};
var on = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(v) {
      if (super(), !e.IDENTIFIER.test(v))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(v) {
      super(), this._items = typeof v == "string" ? [v] : v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const v = this._items[0];
      return v === "" || v === '""';
    }
    get str() {
      var v;
      return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((b, w) => `${b}${w}`, "");
    }
    get names() {
      var v;
      return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((b, w) => (w instanceof r && (b[w.str] = (b[w.str] || 0) + 1), b), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function i(y2, ...v) {
    const b = [y2[0]];
    let w = 0;
    for (; w < v.length; )
      o(b, v[w]), b.push(y2[++w]);
    return new n(b);
  }
  e._ = i;
  const a = new n("+");
  function s(y2, ...v) {
    const b = [d2(y2[0])];
    let w = 0;
    for (; w < v.length; )
      b.push(a), o(b, v[w]), b.push(a, d2(y2[++w]));
    return l(b), new n(b);
  }
  e.str = s;
  function o(y2, v) {
    v instanceof n ? y2.push(...v._items) : v instanceof r ? y2.push(v) : y2.push(f(v));
  }
  e.addCodeArg = o;
  function l(y2) {
    let v = 1;
    for (; v < y2.length - 1; ) {
      if (y2[v] === a) {
        const b = c2(y2[v - 1], y2[v + 1]);
        if (b !== void 0) {
          y2.splice(v - 1, 3, b);
          continue;
        }
        y2[v++] = "+";
      }
      v++;
    }
  }
  function c2(y2, v) {
    if (v === '""')
      return y2;
    if (y2 === '""')
      return v;
    if (typeof y2 == "string")
      return v instanceof r || y2[y2.length - 1] !== '"' ? void 0 : typeof v != "string" ? `${y2.slice(0, -1)}${v}"` : v[0] === '"' ? y2.slice(0, -1) + v.slice(1) : void 0;
    if (typeof v == "string" && v[0] === '"' && !(y2 instanceof r))
      return `"${y2}${v.slice(1)}`;
  }
  function u(y2, v) {
    return v.emptyStr() ? y2 : y2.emptyStr() ? v : s`${y2}${v}`;
  }
  e.strConcat = u;
  function f(y2) {
    return typeof y2 == "number" || typeof y2 == "boolean" || y2 === null ? y2 : d2(Array.isArray(y2) ? y2.join(",") : y2);
  }
  function p(y2) {
    return new n(d2(y2));
  }
  e.stringify = p;
  function d2(y2) {
    return JSON.stringify(y2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = d2;
  function m2(y2) {
    return typeof y2 == "string" && e.IDENTIFIER.test(y2) ? new n(`.${y2}`) : i`[${y2}]`;
  }
  e.getProperty = m2;
  function h2(y2) {
    if (typeof y2 == "string" && e.IDENTIFIER.test(y2))
      return new n(`${y2}`);
    throw new Error(`CodeGen: invalid export name: ${y2}, use explicit $id name mapping`);
  }
  e.getEsmExportName = h2;
  function g(y2) {
    return new n(y2.toString());
  }
  e.regexpCode = g;
})(on);
var la2 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = on;
  class r extends Error {
    constructor(c2) {
      super(`CodeGen: "code" for ${c2} not defined`), this.value = c2.value;
    }
  }
  var n;
  (function(l) {
    l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
  })(n = e.UsedValueState || (e.UsedValueState = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class i {
    constructor({ prefixes: c2, parent: u } = {}) {
      this._names = {}, this._prefixes = c2, this._parent = u;
    }
    toName(c2) {
      return c2 instanceof t.Name ? c2 : this.name(c2);
    }
    name(c2) {
      return new t.Name(this._newName(c2));
    }
    _newName(c2) {
      const u = this._names[c2] || this._nameGroup(c2);
      return `${c2}${u.index++}`;
    }
    _nameGroup(c2) {
      var u, f;
      if (!((f = (u = this._parent) === null || u === void 0 ? void 0 : u._prefixes) === null || f === void 0) && f.has(c2) || this._prefixes && !this._prefixes.has(c2))
        throw new Error(`CodeGen: prefix "${c2}" is not allowed in this scope`);
      return this._names[c2] = { prefix: c2, index: 0 };
    }
  }
  e.Scope = i;
  class a extends t.Name {
    constructor(c2, u) {
      super(u), this.prefix = c2;
    }
    setValue(c2, { property: u, itemIndex: f }) {
      this.value = c2, this.scopePath = (0, t._)`.${new t.Name(u)}[${f}]`;
    }
  }
  e.ValueScopeName = a;
  const s = (0, t._)`\n`;
  class o extends i {
    constructor(c2) {
      super(c2), this._values = {}, this._scope = c2.scope, this.opts = { ...c2, _n: c2.lines ? s : t.nil };
    }
    get() {
      return this._scope;
    }
    name(c2) {
      return new a(c2, this._newName(c2));
    }
    value(c2, u) {
      var f;
      if (u.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const p = this.toName(c2), { prefix: d2 } = p, m2 = (f = u.key) !== null && f !== void 0 ? f : u.ref;
      let h2 = this._values[d2];
      if (h2) {
        const v = h2.get(m2);
        if (v)
          return v;
      } else
        h2 = this._values[d2] = /* @__PURE__ */ new Map();
      h2.set(m2, p);
      const g = this._scope[d2] || (this._scope[d2] = []), y2 = g.length;
      return g[y2] = u.ref, p.setValue(u, { property: d2, itemIndex: y2 }), p;
    }
    getValue(c2, u) {
      const f = this._values[c2];
      if (f)
        return f.get(u);
    }
    scopeRefs(c2, u = this._values) {
      return this._reduceValues(u, (f) => {
        if (f.scopePath === void 0)
          throw new Error(`CodeGen: name "${f}" has no value`);
        return (0, t._)`${c2}${f.scopePath}`;
      });
    }
    scopeCode(c2 = this._values, u, f) {
      return this._reduceValues(c2, (p) => {
        if (p.value === void 0)
          throw new Error(`CodeGen: name "${p}" has no value`);
        return p.value.code;
      }, u, f);
    }
    _reduceValues(c2, u, f = {}, p) {
      let d2 = t.nil;
      for (const m2 in c2) {
        const h2 = c2[m2];
        if (!h2)
          continue;
        const g = f[m2] = f[m2] || /* @__PURE__ */ new Map();
        h2.forEach((y2) => {
          if (g.has(y2))
            return;
          g.set(y2, n.Started);
          let v = u(y2);
          if (v) {
            const b = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            d2 = (0, t._)`${d2}${b} ${y2} = ${v};${this.opts._n}`;
          } else if (v = p == null ? void 0 : p(y2))
            d2 = (0, t._)`${d2}${v}${this.opts._n}`;
          else
            throw new r(y2);
          g.set(y2, n.Completed);
        });
      }
      return d2;
    }
  }
  e.ValueScope = o;
})(la2);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = on, r = la2;
  var n = on;
  Object.defineProperty(e, "_", { enumerable: true, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: true, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: true, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: true, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: true, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: true, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: true, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: true, get: function() {
    return n.Name;
  } });
  var i = la2;
  Object.defineProperty(e, "Scope", { enumerable: true, get: function() {
    return i.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: true, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: true, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: true, get: function() {
    return i.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class a {
    optimizeNodes() {
      return this;
    }
    optimizeNames($, P) {
      return this;
    }
  }
  class s extends a {
    constructor($, P, M) {
      super(), this.varKind = $, this.name = P, this.rhs = M;
    }
    render({ es5: $, _n: P }) {
      const M = $ ? r.varKinds.var : this.varKind, B = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${M} ${this.name}${B};` + P;
    }
    optimizeNames($, P) {
      if ($[this.name.str])
        return this.rhs && (this.rhs = z2(this.rhs, $, P)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends a {
    constructor($, P, M) {
      super(), this.lhs = $, this.rhs = P, this.sideEffects = M;
    }
    render({ _n: $ }) {
      return `${this.lhs} = ${this.rhs};` + $;
    }
    optimizeNames($, P) {
      if (!(this.lhs instanceof t.Name && !$[this.lhs.str] && !this.sideEffects))
        return this.rhs = z2(this.rhs, $, P), this;
    }
    get names() {
      const $ = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return W($, this.rhs);
    }
  }
  class l extends o {
    constructor($, P, M, B) {
      super($, M, B), this.op = P;
    }
    render({ _n: $ }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + $;
    }
  }
  class c2 extends a {
    constructor($) {
      super(), this.label = $, this.names = {};
    }
    render({ _n: $ }) {
      return `${this.label}:` + $;
    }
  }
  class u extends a {
    constructor($) {
      super(), this.label = $, this.names = {};
    }
    render({ _n: $ }) {
      return `break${this.label ? ` ${this.label}` : ""};` + $;
    }
  }
  class f extends a {
    constructor($) {
      super(), this.error = $;
    }
    render({ _n: $ }) {
      return `throw ${this.error};` + $;
    }
    get names() {
      return this.error.names;
    }
  }
  class p extends a {
    constructor($) {
      super(), this.code = $;
    }
    render({ _n: $ }) {
      return `${this.code};` + $;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames($, P) {
      return this.code = z2(this.code, $, P), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class d2 extends a {
    constructor($ = []) {
      super(), this.nodes = $;
    }
    render($) {
      return this.nodes.reduce((P, M) => P + M.render($), "");
    }
    optimizeNodes() {
      const { nodes: $ } = this;
      let P = $.length;
      for (; P--; ) {
        const M = $[P].optimizeNodes();
        Array.isArray(M) ? $.splice(P, 1, ...M) : M ? $[P] = M : $.splice(P, 1);
      }
      return $.length > 0 ? this : void 0;
    }
    optimizeNames($, P) {
      const { nodes: M } = this;
      let B = M.length;
      for (; B--; ) {
        const K = M[B];
        K.optimizeNames($, P) || (q3($, K.names), M.splice(B, 1));
      }
      return M.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce(($, P) => U($, P.names), {});
    }
  }
  class m2 extends d2 {
    render($) {
      return "{" + $._n + super.render($) + "}" + $._n;
    }
  }
  class h2 extends d2 {
  }
  class g extends m2 {
  }
  g.kind = "else";
  class y2 extends m2 {
    constructor($, P) {
      super(P), this.condition = $;
    }
    render($) {
      let P = `if(${this.condition})` + super.render($);
      return this.else && (P += "else " + this.else.render($)), P;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const $ = this.condition;
      if ($ === true)
        return this.nodes;
      let P = this.else;
      if (P) {
        const M = P.optimizeNodes();
        P = this.else = Array.isArray(M) ? new g(M) : M;
      }
      if (P)
        return $ === false ? P instanceof y2 ? P : P.nodes : this.nodes.length ? this : new y2(ue($), P instanceof y2 ? [P] : P.nodes);
      if (!($ === false || !this.nodes.length))
        return this;
    }
    optimizeNames($, P) {
      var M;
      if (this.else = (M = this.else) === null || M === void 0 ? void 0 : M.optimizeNames($, P), !!(super.optimizeNames($, P) || this.else))
        return this.condition = z2(this.condition, $, P), this;
    }
    get names() {
      const $ = super.names;
      return W($, this.condition), this.else && U($, this.else.names), $;
    }
  }
  y2.kind = "if";
  class v extends m2 {
  }
  v.kind = "for";
  class b extends v {
    constructor($) {
      super(), this.iteration = $;
    }
    render($) {
      return `for(${this.iteration})` + super.render($);
    }
    optimizeNames($, P) {
      if (super.optimizeNames($, P))
        return this.iteration = z2(this.iteration, $, P), this;
    }
    get names() {
      return U(super.names, this.iteration.names);
    }
  }
  class w extends v {
    constructor($, P, M, B) {
      super(), this.varKind = $, this.name = P, this.from = M, this.to = B;
    }
    render($) {
      const P = $.es5 ? r.varKinds.var : this.varKind, { name: M, from: B, to: K } = this;
      return `for(${P} ${M}=${B}; ${M}<${K}; ${M}++)` + super.render($);
    }
    get names() {
      const $ = W(super.names, this.from);
      return W($, this.to);
    }
  }
  class C extends v {
    constructor($, P, M, B) {
      super(), this.loop = $, this.varKind = P, this.name = M, this.iterable = B;
    }
    render($) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render($);
    }
    optimizeNames($, P) {
      if (super.optimizeNames($, P))
        return this.iterable = z2(this.iterable, $, P), this;
    }
    get names() {
      return U(super.names, this.iterable.names);
    }
  }
  class E2 extends m2 {
    constructor($, P, M) {
      super(), this.name = $, this.args = P, this.async = M;
    }
    render($) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render($);
    }
  }
  E2.kind = "func";
  class _3 extends d2 {
    render($) {
      return "return " + super.render($);
    }
  }
  _3.kind = "return";
  class T extends m2 {
    render($) {
      let P = "try" + super.render($);
      return this.catch && (P += this.catch.render($)), this.finally && (P += this.finally.render($)), P;
    }
    optimizeNodes() {
      var $, P;
      return super.optimizeNodes(), ($ = this.catch) === null || $ === void 0 || $.optimizeNodes(), (P = this.finally) === null || P === void 0 || P.optimizeNodes(), this;
    }
    optimizeNames($, P) {
      var M, B;
      return super.optimizeNames($, P), (M = this.catch) === null || M === void 0 || M.optimizeNames($, P), (B = this.finally) === null || B === void 0 || B.optimizeNames($, P), this;
    }
    get names() {
      const $ = super.names;
      return this.catch && U($, this.catch.names), this.finally && U($, this.finally.names), $;
    }
  }
  class F extends m2 {
    constructor($) {
      super(), this.error = $;
    }
    render($) {
      return `catch(${this.error})` + super.render($);
    }
  }
  F.kind = "catch";
  class j2 extends m2 {
    render($) {
      return "finally" + super.render($);
    }
  }
  j2.kind = "finally";
  class L {
    constructor($, P = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...P, _n: P.lines ? `
` : "" }, this._extScope = $, this._scope = new r.Scope({ parent: $ }), this._nodes = [new h2()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name($) {
      return this._scope.name($);
    }
    // reserves unique name in the external scope
    scopeName($) {
      return this._extScope.name($);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue($, P) {
      const M = this._extScope.value($, P);
      return (this._values[M.prefix] || (this._values[M.prefix] = /* @__PURE__ */ new Set())).add(M), M;
    }
    getScopeValue($, P) {
      return this._extScope.getValue($, P);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs($) {
      return this._extScope.scopeRefs($, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def($, P, M, B) {
      const K = this._scope.toName(P);
      return M !== void 0 && B && (this._constants[K.str] = M), this._leafNode(new s($, K, M)), K;
    }
    // `const` declaration (`var` in es5 mode)
    const($, P, M) {
      return this._def(r.varKinds.const, $, P, M);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let($, P, M) {
      return this._def(r.varKinds.let, $, P, M);
    }
    // `var` declaration with optional assignment
    var($, P, M) {
      return this._def(r.varKinds.var, $, P, M);
    }
    // assignment code
    assign($, P, M) {
      return this._leafNode(new o($, P, M));
    }
    // `+=` code
    add($, P) {
      return this._leafNode(new l($, e.operators.ADD, P));
    }
    // appends passed SafeExpr to code or executes Block
    code($) {
      return typeof $ == "function" ? $() : $ !== t.nil && this._leafNode(new p($)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...$) {
      const P = ["{"];
      for (const [M, B] of $)
        P.length > 1 && P.push(","), P.push(M), (M !== B || this.opts.es5) && (P.push(":"), (0, t.addCodeArg)(P, B));
      return P.push("}"), new t._Code(P);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if($, P, M) {
      if (this._blockNode(new y2($)), P && M)
        this.code(P).else().code(M).endIf();
      else if (P)
        this.code(P).endIf();
      else if (M)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf($) {
      return this._elseNode(new y2($));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new g());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(y2, g);
    }
    _for($, P) {
      return this._blockNode($), P && this.code(P).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for($, P) {
      return this._for(new b($), P);
    }
    // `for` statement for a range of values
    forRange($, P, M, B, K = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const te = this._scope.toName($);
      return this._for(new w(K, te, P, M), () => B(te));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf($, P, M, B = r.varKinds.const) {
      const K = this._scope.toName($);
      if (this.opts.es5) {
        const te = P instanceof t.Name ? P : this.var("_arr", P);
        return this.forRange("_i", 0, (0, t._)`${te}.length`, (ae) => {
          this.var(K, (0, t._)`${te}[${ae}]`), M(K);
        });
      }
      return this._for(new C("of", B, K, P), () => M(K));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn($, P, M, B = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf($, (0, t._)`Object.keys(${P})`, M);
      const K = this._scope.toName($);
      return this._for(new C("in", B, K, P), () => M(K));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(v);
    }
    // `label` statement
    label($) {
      return this._leafNode(new c2($));
    }
    // `break` statement
    break($) {
      return this._leafNode(new u($));
    }
    // `return` statement
    return($) {
      const P = new _3();
      if (this._blockNode(P), this.code($), P.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(_3);
    }
    // `try` statement
    try($, P, M) {
      if (!P && !M)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const B = new T();
      if (this._blockNode(B), this.code($), P) {
        const K = this.name("e");
        this._currNode = B.catch = new F(K), P(K);
      }
      return M && (this._currNode = B.finally = new j2(), this.code(M)), this._endBlockNode(F, j2);
    }
    // `throw` statement
    throw($) {
      return this._leafNode(new f($));
    }
    // start self-balancing block
    block($, P) {
      return this._blockStarts.push(this._nodes.length), $ && this.code($).endBlock(P), this;
    }
    // end the current self-balancing block
    endBlock($) {
      const P = this._blockStarts.pop();
      if (P === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const M = this._nodes.length - P;
      if (M < 0 || $ !== void 0 && M !== $)
        throw new Error(`CodeGen: wrong number of nodes: ${M} vs ${$} expected`);
      return this._nodes.length = P, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func($, P = t.nil, M, B) {
      return this._blockNode(new E2($, P, M)), B && this.code(B).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(E2);
    }
    optimize($ = 1) {
      for (; $-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode($) {
      return this._currNode.nodes.push($), this;
    }
    _blockNode($) {
      this._currNode.nodes.push($), this._nodes.push($);
    }
    _endBlockNode($, P) {
      const M = this._currNode;
      if (M instanceof $ || P && M instanceof P)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${P ? `${$.kind}/${P.kind}` : $.kind}"`);
    }
    _elseNode($) {
      const P = this._currNode;
      if (!(P instanceof y2))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = P.else = $, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const $ = this._nodes;
      return $[$.length - 1];
    }
    set _currNode($) {
      const P = this._nodes;
      P[P.length - 1] = $;
    }
  }
  e.CodeGen = L;
  function U(D, $) {
    for (const P in $)
      D[P] = (D[P] || 0) + ($[P] || 0);
    return D;
  }
  function W(D, $) {
    return $ instanceof t._CodeOrName ? U(D, $.names) : D;
  }
  function z2(D, $, P) {
    if (D instanceof t.Name)
      return M(D);
    if (!B(D))
      return D;
    return new t._Code(D._items.reduce((K, te) => (te instanceof t.Name && (te = M(te)), te instanceof t._Code ? K.push(...te._items) : K.push(te), K), []));
    function M(K) {
      const te = P[K.str];
      return te === void 0 || $[K.str] !== 1 ? K : (delete $[K.str], te);
    }
    function B(K) {
      return K instanceof t._Code && K._items.some((te) => te instanceof t.Name && $[te.str] === 1 && P[te.str] !== void 0);
    }
  }
  function q3(D, $) {
    for (const P in $)
      D[P] = (D[P] || 0) - ($[P] || 0);
  }
  function ue(D) {
    return typeof D == "boolean" || typeof D == "number" || D === null ? !D : (0, t._)`!${x3(D)}`;
  }
  e.not = ue;
  const me = N3(e.operators.AND);
  function ie2(...D) {
    return D.reduce(me);
  }
  e.and = ie2;
  const Y2 = N3(e.operators.OR);
  function V2(...D) {
    return D.reduce(Y2);
  }
  e.or = V2;
  function N3(D) {
    return ($, P) => $ === t.nil ? P : P === t.nil ? $ : (0, t._)`${x3($)} ${D} ${x3(P)}`;
  }
  function x3(D) {
    return D instanceof t.Name ? D : (0, t._)`(${D})`;
  }
})(re2);
var fe = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.checkStrictMode = e.getErrorPath = e.Type = e.useFunc = e.setEvaluated = e.evaluatedPropsToName = e.mergeEvaluated = e.eachItem = e.unescapeJsonPointer = e.escapeJsonPointer = e.escapeFragment = e.unescapeFragment = e.schemaRefOrVal = e.schemaHasRulesButRef = e.schemaHasRules = e.checkUnknownRules = e.alwaysValidSchema = e.toHash = void 0;
  const t = re2, r = on;
  function n(E2) {
    const _3 = {};
    for (const T of E2)
      _3[T] = true;
    return _3;
  }
  e.toHash = n;
  function i(E2, _3) {
    return typeof _3 == "boolean" ? _3 : Object.keys(_3).length === 0 ? true : (a(E2, _3), !s(_3, E2.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function a(E2, _3 = E2.schema) {
    const { opts: T, self: F } = E2;
    if (!T.strictSchema || typeof _3 == "boolean")
      return;
    const j2 = F.RULES.keywords;
    for (const L in _3)
      j2[L] || C(E2, `unknown keyword: "${L}"`);
  }
  e.checkUnknownRules = a;
  function s(E2, _3) {
    if (typeof E2 == "boolean")
      return !E2;
    for (const T in E2)
      if (_3[T])
        return true;
    return false;
  }
  e.schemaHasRules = s;
  function o(E2, _3) {
    if (typeof E2 == "boolean")
      return !E2;
    for (const T in E2)
      if (T !== "$ref" && _3.all[T])
        return true;
    return false;
  }
  e.schemaHasRulesButRef = o;
  function l({ topSchemaRef: E2, schemaPath: _3 }, T, F, j2) {
    if (!j2) {
      if (typeof T == "number" || typeof T == "boolean")
        return T;
      if (typeof T == "string")
        return (0, t._)`${T}`;
    }
    return (0, t._)`${E2}${_3}${(0, t.getProperty)(F)}`;
  }
  e.schemaRefOrVal = l;
  function c2(E2) {
    return p(decodeURIComponent(E2));
  }
  e.unescapeFragment = c2;
  function u(E2) {
    return encodeURIComponent(f(E2));
  }
  e.escapeFragment = u;
  function f(E2) {
    return typeof E2 == "number" ? `${E2}` : E2.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = f;
  function p(E2) {
    return E2.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = p;
  function d2(E2, _3) {
    if (Array.isArray(E2))
      for (const T of E2)
        _3(T);
    else
      _3(E2);
  }
  e.eachItem = d2;
  function m2({ mergeNames: E2, mergeToName: _3, mergeValues: T, resultToName: F }) {
    return (j2, L, U, W) => {
      const z2 = U === void 0 ? L : U instanceof t.Name ? (L instanceof t.Name ? E2(j2, L, U) : _3(j2, L, U), U) : L instanceof t.Name ? (_3(j2, U, L), L) : T(L, U);
      return W === t.Name && !(z2 instanceof t.Name) ? F(j2, z2) : z2;
    };
  }
  e.mergeEvaluated = {
    props: m2({
      mergeNames: (E2, _3, T) => E2.if((0, t._)`${T} !== true && ${_3} !== undefined`, () => {
        E2.if((0, t._)`${_3} === true`, () => E2.assign(T, true), () => E2.assign(T, (0, t._)`${T} || {}`).code((0, t._)`Object.assign(${T}, ${_3})`));
      }),
      mergeToName: (E2, _3, T) => E2.if((0, t._)`${T} !== true`, () => {
        _3 === true ? E2.assign(T, true) : (E2.assign(T, (0, t._)`${T} || {}`), g(E2, T, _3));
      }),
      mergeValues: (E2, _3) => E2 === true ? true : { ...E2, ..._3 },
      resultToName: h2
    }),
    items: m2({
      mergeNames: (E2, _3, T) => E2.if((0, t._)`${T} !== true && ${_3} !== undefined`, () => E2.assign(T, (0, t._)`${_3} === true ? true : ${T} > ${_3} ? ${T} : ${_3}`)),
      mergeToName: (E2, _3, T) => E2.if((0, t._)`${T} !== true`, () => E2.assign(T, _3 === true ? true : (0, t._)`${T} > ${_3} ? ${T} : ${_3}`)),
      mergeValues: (E2, _3) => E2 === true ? true : Math.max(E2, _3),
      resultToName: (E2, _3) => E2.var("items", _3)
    })
  };
  function h2(E2, _3) {
    if (_3 === true)
      return E2.var("props", true);
    const T = E2.var("props", (0, t._)`{}`);
    return _3 !== void 0 && g(E2, T, _3), T;
  }
  e.evaluatedPropsToName = h2;
  function g(E2, _3, T) {
    Object.keys(T).forEach((F) => E2.assign((0, t._)`${_3}${(0, t.getProperty)(F)}`, true));
  }
  e.setEvaluated = g;
  const y2 = {};
  function v(E2, _3) {
    return E2.scopeValue("func", {
      ref: _3,
      code: y2[_3.code] || (y2[_3.code] = new r._Code(_3.code))
    });
  }
  e.useFunc = v;
  var b;
  (function(E2) {
    E2[E2.Num = 0] = "Num", E2[E2.Str = 1] = "Str";
  })(b = e.Type || (e.Type = {}));
  function w(E2, _3, T) {
    if (E2 instanceof t.Name) {
      const F = _3 === b.Num;
      return T ? F ? (0, t._)`"[" + ${E2} + "]"` : (0, t._)`"['" + ${E2} + "']"` : F ? (0, t._)`"/" + ${E2}` : (0, t._)`"/" + ${E2}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return T ? (0, t.getProperty)(E2).toString() : "/" + f(E2);
  }
  e.getErrorPath = w;
  function C(E2, _3, T = E2.opts.strictSchema) {
    if (T) {
      if (_3 = `strict mode: ${_3}`, T === true)
        throw new Error(_3);
      E2.self.logger.warn(_3);
    }
  }
  e.checkStrictMode = C;
})(fe);
var vt = {};
Object.defineProperty(vt, "__esModule", { value: true });
var Me2 = re2;
var lE = {
  // validation function arguments
  data: new Me2.Name("data"),
  // args passed from referencing schema
  valCxt: new Me2.Name("valCxt"),
  instancePath: new Me2.Name("instancePath"),
  parentData: new Me2.Name("parentData"),
  parentDataProperty: new Me2.Name("parentDataProperty"),
  rootData: new Me2.Name("rootData"),
  dynamicAnchors: new Me2.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new Me2.Name("vErrors"),
  errors: new Me2.Name("errors"),
  this: new Me2.Name("this"),
  // "globals"
  self: new Me2.Name("self"),
  scope: new Me2.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new Me2.Name("json"),
  jsonPos: new Me2.Name("jsonPos"),
  jsonLen: new Me2.Name("jsonLen"),
  jsonPart: new Me2.Name("jsonPart")
};
vt.default = lE;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = re2, r = fe, n = vt;
  e.keywordError = {
    message: ({ keyword: g }) => (0, t.str)`must pass "${g}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: g, schemaType: y2 }) => y2 ? (0, t.str)`"${g}" keyword must be ${y2} ($data)` : (0, t.str)`"${g}" keyword is invalid ($data)`
  };
  function i(g, y2 = e.keywordError, v, b) {
    const { it: w } = g, { gen: C, compositeRule: E2, allErrors: _3 } = w, T = f(g, y2, v);
    b ?? (E2 || _3) ? l(C, T) : c2(w, (0, t._)`[${T}]`);
  }
  e.reportError = i;
  function a(g, y2 = e.keywordError, v) {
    const { it: b } = g, { gen: w, compositeRule: C, allErrors: E2 } = b, _3 = f(g, y2, v);
    l(w, _3), C || E2 || c2(b, n.default.vErrors);
  }
  e.reportExtraError = a;
  function s(g, y2) {
    g.assign(n.default.errors, y2), g.if((0, t._)`${n.default.vErrors} !== null`, () => g.if(y2, () => g.assign((0, t._)`${n.default.vErrors}.length`, y2), () => g.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = s;
  function o({ gen: g, keyword: y2, schemaValue: v, data: b, errsCount: w, it: C }) {
    if (w === void 0)
      throw new Error("ajv implementation error");
    const E2 = g.name("err");
    g.forRange("i", w, n.default.errors, (_3) => {
      g.const(E2, (0, t._)`${n.default.vErrors}[${_3}]`), g.if((0, t._)`${E2}.instancePath === undefined`, () => g.assign((0, t._)`${E2}.instancePath`, (0, t.strConcat)(n.default.instancePath, C.errorPath))), g.assign((0, t._)`${E2}.schemaPath`, (0, t.str)`${C.errSchemaPath}/${y2}`), C.opts.verbose && (g.assign((0, t._)`${E2}.schema`, v), g.assign((0, t._)`${E2}.data`, b));
    });
  }
  e.extendErrors = o;
  function l(g, y2) {
    const v = g.const("err", y2);
    g.if((0, t._)`${n.default.vErrors} === null`, () => g.assign(n.default.vErrors, (0, t._)`[${v}]`), (0, t._)`${n.default.vErrors}.push(${v})`), g.code((0, t._)`${n.default.errors}++`);
  }
  function c2(g, y2) {
    const { gen: v, validateName: b, schemaEnv: w } = g;
    w.$async ? v.throw((0, t._)`new ${g.ValidationError}(${y2})`) : (v.assign((0, t._)`${b}.errors`, y2), v.return(false));
  }
  const u = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function f(g, y2, v) {
    const { createErrors: b } = g.it;
    return b === false ? (0, t._)`{}` : p(g, y2, v);
  }
  function p(g, y2, v = {}) {
    const { gen: b, it: w } = g, C = [
      d2(w, v),
      m2(g, v)
    ];
    return h2(g, y2, C), b.object(...C);
  }
  function d2({ errorPath: g }, { instancePath: y2 }) {
    const v = y2 ? (0, t.str)`${g}${(0, r.getErrorPath)(y2, r.Type.Str)}` : g;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, v)];
  }
  function m2({ keyword: g, it: { errSchemaPath: y2 } }, { schemaPath: v, parentSchema: b }) {
    let w = b ? y2 : (0, t.str)`${y2}/${g}`;
    return v && (w = (0, t.str)`${w}${(0, r.getErrorPath)(v, r.Type.Str)}`), [u.schemaPath, w];
  }
  function h2(g, { params: y2, message: v }, b) {
    const { keyword: w, data: C, schemaValue: E2, it: _3 } = g, { opts: T, propertyName: F, topSchemaRef: j2, schemaPath: L } = _3;
    b.push([u.keyword, w], [u.params, typeof y2 == "function" ? y2(g) : y2 || (0, t._)`{}`]), T.messages && b.push([u.message, typeof v == "function" ? v(g) : v]), T.verbose && b.push([u.schema, E2], [u.parentSchema, (0, t._)`${j2}${L}`], [n.default.data, C]), F && b.push([u.propertyName, F]);
  }
})($n);
Object.defineProperty(Tr, "__esModule", { value: true });
Tr.boolOrEmptySchema = Tr.topBoolOrEmptySchema = void 0;
var cE = $n;
var uE = re2;
var dE = vt;
var fE = {
  message: "boolean schema is false"
};
function hE(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === false ? Ru(e, false) : typeof r == "object" && r.$async === true ? t.return(dE.default.data) : (t.assign((0, uE._)`${n}.errors`, null), t.return(true));
}
Tr.topBoolOrEmptySchema = hE;
function mE(e, t) {
  const { gen: r, schema: n } = e;
  n === false ? (r.var(t, false), Ru(e)) : r.var(t, true);
}
Tr.boolOrEmptySchema = mE;
function Ru(e, t) {
  const { gen: r, data: n } = e, i = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: false,
    schemaCode: false,
    schemaValue: false,
    params: {},
    it: e
  };
  (0, cE.reportError)(i, fE, void 0, t);
}
var _n = {};
var or = {};
Object.defineProperty(or, "__esModule", { value: true });
or.getRules = or.isJSONType = void 0;
var pE = ["string", "number", "integer", "boolean", "null", "object", "array"];
var yE = new Set(pE);
function gE(e) {
  return typeof e == "string" && yE.has(e);
}
or.isJSONType = gE;
function vE() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: true, boolean: true, null: true },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
or.getRules = vE;
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: true });
Ot.shouldUseRule = Ot.shouldUseGroup = Ot.schemaHasRulesForType = void 0;
function $E({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== true && Mu(e, n);
}
Ot.schemaHasRulesForType = $E;
function Mu(e, t) {
  return t.rules.some((r) => ju(e, r));
}
Ot.shouldUseGroup = Mu;
function ju(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
Ot.shouldUseRule = ju;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.reportTypeError = e.checkDataTypes = e.checkDataType = e.coerceAndCheckDataType = e.getJSONTypes = e.getSchemaTypes = e.DataType = void 0;
  const t = or, r = Ot, n = $n, i = re2, a = fe;
  var s;
  (function(b) {
    b[b.Correct = 0] = "Correct", b[b.Wrong = 1] = "Wrong";
  })(s = e.DataType || (e.DataType = {}));
  function o(b) {
    const w = l(b.type);
    if (w.includes("null")) {
      if (b.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!w.length && b.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      b.nullable === true && w.push("null");
    }
    return w;
  }
  e.getSchemaTypes = o;
  function l(b) {
    const w = Array.isArray(b) ? b : b ? [b] : [];
    if (w.every(t.isJSONType))
      return w;
    throw new Error("type must be JSONType or JSONType[]: " + w.join(","));
  }
  e.getJSONTypes = l;
  function c2(b, w) {
    const { gen: C, data: E2, opts: _3 } = b, T = f(w, _3.coerceTypes), F = w.length > 0 && !(T.length === 0 && w.length === 1 && (0, r.schemaHasRulesForType)(b, w[0]));
    if (F) {
      const j2 = h2(w, E2, _3.strictNumbers, s.Wrong);
      C.if(j2, () => {
        T.length ? p(b, w, T) : y2(b);
      });
    }
    return F;
  }
  e.coerceAndCheckDataType = c2;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function f(b, w) {
    return w ? b.filter((C) => u.has(C) || w === "array" && C === "array") : [];
  }
  function p(b, w, C) {
    const { gen: E2, data: _3, opts: T } = b, F = E2.let("dataType", (0, i._)`typeof ${_3}`), j2 = E2.let("coerced", (0, i._)`undefined`);
    T.coerceTypes === "array" && E2.if((0, i._)`${F} == 'object' && Array.isArray(${_3}) && ${_3}.length == 1`, () => E2.assign(_3, (0, i._)`${_3}[0]`).assign(F, (0, i._)`typeof ${_3}`).if(h2(w, _3, T.strictNumbers), () => E2.assign(j2, _3))), E2.if((0, i._)`${j2} !== undefined`);
    for (const U of C)
      (u.has(U) || U === "array" && T.coerceTypes === "array") && L(U);
    E2.else(), y2(b), E2.endIf(), E2.if((0, i._)`${j2} !== undefined`, () => {
      E2.assign(_3, j2), d2(b, j2);
    });
    function L(U) {
      switch (U) {
        case "string":
          E2.elseIf((0, i._)`${F} == "number" || ${F} == "boolean"`).assign(j2, (0, i._)`"" + ${_3}`).elseIf((0, i._)`${_3} === null`).assign(j2, (0, i._)`""`);
          return;
        case "number":
          E2.elseIf((0, i._)`${F} == "boolean" || ${_3} === null
              || (${F} == "string" && ${_3} && ${_3} == +${_3})`).assign(j2, (0, i._)`+${_3}`);
          return;
        case "integer":
          E2.elseIf((0, i._)`${F} === "boolean" || ${_3} === null
              || (${F} === "string" && ${_3} && ${_3} == +${_3} && !(${_3} % 1))`).assign(j2, (0, i._)`+${_3}`);
          return;
        case "boolean":
          E2.elseIf((0, i._)`${_3} === "false" || ${_3} === 0 || ${_3} === null`).assign(j2, false).elseIf((0, i._)`${_3} === "true" || ${_3} === 1`).assign(j2, true);
          return;
        case "null":
          E2.elseIf((0, i._)`${_3} === "" || ${_3} === 0 || ${_3} === false`), E2.assign(j2, null);
          return;
        case "array":
          E2.elseIf((0, i._)`${F} === "string" || ${F} === "number"
              || ${F} === "boolean" || ${_3} === null`).assign(j2, (0, i._)`[${_3}]`);
      }
    }
  }
  function d2({ gen: b, parentData: w, parentDataProperty: C }, E2) {
    b.if((0, i._)`${w} !== undefined`, () => b.assign((0, i._)`${w}[${C}]`, E2));
  }
  function m2(b, w, C, E2 = s.Correct) {
    const _3 = E2 === s.Correct ? i.operators.EQ : i.operators.NEQ;
    let T;
    switch (b) {
      case "null":
        return (0, i._)`${w} ${_3} null`;
      case "array":
        T = (0, i._)`Array.isArray(${w})`;
        break;
      case "object":
        T = (0, i._)`${w} && typeof ${w} == "object" && !Array.isArray(${w})`;
        break;
      case "integer":
        T = F((0, i._)`!(${w} % 1) && !isNaN(${w})`);
        break;
      case "number":
        T = F();
        break;
      default:
        return (0, i._)`typeof ${w} ${_3} ${b}`;
    }
    return E2 === s.Correct ? T : (0, i.not)(T);
    function F(j2 = i.nil) {
      return (0, i.and)((0, i._)`typeof ${w} == "number"`, j2, C ? (0, i._)`isFinite(${w})` : i.nil);
    }
  }
  e.checkDataType = m2;
  function h2(b, w, C, E2) {
    if (b.length === 1)
      return m2(b[0], w, C, E2);
    let _3;
    const T = (0, a.toHash)(b);
    if (T.array && T.object) {
      const F = (0, i._)`typeof ${w} != "object"`;
      _3 = T.null ? F : (0, i._)`!${w} || ${F}`, delete T.null, delete T.array, delete T.object;
    } else
      _3 = i.nil;
    T.number && delete T.integer;
    for (const F in T)
      _3 = (0, i.and)(_3, m2(F, w, C, E2));
    return _3;
  }
  e.checkDataTypes = h2;
  const g = {
    message: ({ schema: b }) => `must be ${b}`,
    params: ({ schema: b, schemaValue: w }) => typeof b == "string" ? (0, i._)`{type: ${b}}` : (0, i._)`{type: ${w}}`
  };
  function y2(b) {
    const w = v(b);
    (0, n.reportError)(w, g);
  }
  e.reportTypeError = y2;
  function v(b) {
    const { gen: w, data: C, schema: E2 } = b, _3 = (0, a.schemaRefOrVal)(b, E2, "type");
    return {
      gen: w,
      keyword: "type",
      data: C,
      schema: E2.type,
      schemaCode: _3,
      schemaValue: _3,
      parentSchema: E2,
      params: {},
      it: b
    };
  }
})(_n);
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: true });
Oi.assignDefaults = void 0;
var gr = re2;
var _E = fe;
function bE(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const i in r)
      al(e, i, r[i].default);
  else
    t === "array" && Array.isArray(n) && n.forEach((i, a) => al(e, a, i.default));
}
Oi.assignDefaults = bE;
function al(e, t, r) {
  const { gen: n, compositeRule: i, data: a, opts: s } = e;
  if (r === void 0)
    return;
  const o = (0, gr._)`${a}${(0, gr.getProperty)(t)}`;
  if (i) {
    (0, _E.checkStrictMode)(e, `default is ignored for: ${o}`);
    return;
  }
  let l = (0, gr._)`${o} === undefined`;
  s.useDefaults === "empty" && (l = (0, gr._)`${l} || ${o} === null || ${o} === ""`), n.if(l, (0, gr._)`${o} = ${(0, gr.stringify)(r)}`);
}
var gt = {};
var ne = {};
Object.defineProperty(ne, "__esModule", { value: true });
ne.validateUnion = ne.validateArray = ne.usePattern = ne.callValidateCode = ne.schemaProperties = ne.allSchemaProperties = ne.noPropertyInData = ne.propertyInData = ne.isOwnProperty = ne.hasPropFunc = ne.reportMissingProp = ne.checkMissingProp = ne.checkReportMissingProp = void 0;
var ve = re2;
var ls = fe;
var Ft = vt;
var SE = fe;
function wE(e, t) {
  const { gen: r, data: n, it: i } = e;
  r.if(us(r, n, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, ve._)`${t}` }, true), e.error();
  });
}
ne.checkReportMissingProp = wE;
function EE({ gen: e, data: t, it: { opts: r } }, n, i) {
  return (0, ve.or)(...n.map((a) => (0, ve.and)(us(e, t, a, r.ownProperties), (0, ve._)`${i} = ${a}`)));
}
ne.checkMissingProp = EE;
function OE(e, t) {
  e.setParams({ missingProperty: t }, true), e.error();
}
ne.reportMissingProp = OE;
function Uu(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, ve._)`Object.prototype.hasOwnProperty`
  });
}
ne.hasPropFunc = Uu;
function cs(e, t, r) {
  return (0, ve._)`${Uu(e)}.call(${t}, ${r})`;
}
ne.isOwnProperty = cs;
function CE(e, t, r, n) {
  const i = (0, ve._)`${t}${(0, ve.getProperty)(r)} !== undefined`;
  return n ? (0, ve._)`${i} && ${cs(e, t, r)}` : i;
}
ne.propertyInData = CE;
function us(e, t, r, n) {
  const i = (0, ve._)`${t}${(0, ve.getProperty)(r)} === undefined`;
  return n ? (0, ve.or)(i, (0, ve.not)(cs(e, t, r))) : i;
}
ne.noPropertyInData = us;
function Vu(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
ne.allSchemaProperties = Vu;
function AE(e, t) {
  return Vu(t).filter((r) => !(0, ls.alwaysValidSchema)(e, t[r]));
}
ne.schemaProperties = AE;
function PE({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: i, errorPath: a }, it: s }, o, l, c2) {
  const u = c2 ? (0, ve._)`${e}, ${t}, ${n}${i}` : t, f = [
    [Ft.default.instancePath, (0, ve.strConcat)(Ft.default.instancePath, a)],
    [Ft.default.parentData, s.parentData],
    [Ft.default.parentDataProperty, s.parentDataProperty],
    [Ft.default.rootData, Ft.default.rootData]
  ];
  s.opts.dynamicRef && f.push([Ft.default.dynamicAnchors, Ft.default.dynamicAnchors]);
  const p = (0, ve._)`${u}, ${r.object(...f)}`;
  return l !== ve.nil ? (0, ve._)`${o}.call(${l}, ${p})` : (0, ve._)`${o}(${p})`;
}
ne.callValidateCode = PE;
var IE = (0, ve._)`new RegExp`;
function TE({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: i } = t.code, a = i(r, n);
  return e.scopeValue("pattern", {
    key: a.toString(),
    ref: a,
    code: (0, ve._)`${i.code === "new RegExp" ? IE : (0, SE.useFunc)(e, i)}(${r}, ${n})`
  });
}
ne.usePattern = TE;
function NE(e) {
  const { gen: t, data: r, keyword: n, it: i } = e, a = t.name("valid");
  if (i.allErrors) {
    const o = t.let("valid", true);
    return s(() => t.assign(o, false)), o;
  }
  return t.var(a, true), s(() => t.break()), a;
  function s(o) {
    const l = t.const("len", (0, ve._)`${r}.length`);
    t.forRange("i", 0, l, (c2) => {
      e.subschema({
        keyword: n,
        dataProp: c2,
        dataPropType: ls.Type.Num
      }, a), t.if((0, ve.not)(a), o);
    });
  }
}
ne.validateArray = NE;
function DE(e) {
  const { gen: t, schema: r, keyword: n, it: i } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((l) => (0, ls.alwaysValidSchema)(i, l)) && !i.opts.unevaluated)
    return;
  const s = t.let("valid", false), o = t.name("_valid");
  t.block(() => r.forEach((l, c2) => {
    const u = e.subschema({
      keyword: n,
      schemaProp: c2,
      compositeRule: true
    }, o);
    t.assign(s, (0, ve._)`${s} || ${o}`), e.mergeValidEvaluated(u, o) || t.if((0, ve.not)(s));
  })), e.result(s, () => e.reset(), () => e.error(true));
}
ne.validateUnion = DE;
Object.defineProperty(gt, "__esModule", { value: true });
gt.validateKeywordUsage = gt.validSchemaType = gt.funcKeywordCode = gt.macroKeywordCode = void 0;
var xe = re2;
var er = vt;
var FE = ne;
var kE = $n;
function RE(e, t) {
  const { gen: r, keyword: n, schema: i, parentSchema: a, it: s } = e, o = t.macro.call(s.self, i, a, s), l = xu(r, n, o);
  s.opts.validateSchema !== false && s.self.validateSchema(o, true);
  const c2 = r.name("valid");
  e.subschema({
    schema: o,
    schemaPath: xe.nil,
    errSchemaPath: `${s.errSchemaPath}/${n}`,
    topSchemaRef: l,
    compositeRule: true
  }, c2), e.pass(c2, () => e.error(true));
}
gt.macroKeywordCode = RE;
function ME(e, t) {
  var r;
  const { gen: n, keyword: i, schema: a, parentSchema: s, $data: o, it: l } = e;
  UE(l, t);
  const c2 = !o && t.compile ? t.compile.call(l.self, a, s, l) : t.validate, u = xu(n, i, c2), f = n.let("valid");
  e.block$data(f, p), e.ok((r = t.valid) !== null && r !== void 0 ? r : f);
  function p() {
    if (t.errors === false)
      h2(), t.modifying && sl(e), g(() => e.error());
    else {
      const y2 = t.async ? d2() : m2();
      t.modifying && sl(e), g(() => jE(e, y2));
    }
  }
  function d2() {
    const y2 = n.let("ruleErrs", null);
    return n.try(() => h2((0, xe._)`await `), (v) => n.assign(f, false).if((0, xe._)`${v} instanceof ${l.ValidationError}`, () => n.assign(y2, (0, xe._)`${v}.errors`), () => n.throw(v))), y2;
  }
  function m2() {
    const y2 = (0, xe._)`${u}.errors`;
    return n.assign(y2, null), h2(xe.nil), y2;
  }
  function h2(y2 = t.async ? (0, xe._)`await ` : xe.nil) {
    const v = l.opts.passContext ? er.default.this : er.default.self, b = !("compile" in t && !o || t.schema === false);
    n.assign(f, (0, xe._)`${y2}${(0, FE.callValidateCode)(e, u, v, b)}`, t.modifying);
  }
  function g(y2) {
    var v;
    n.if((0, xe.not)((v = t.valid) !== null && v !== void 0 ? v : f), y2);
  }
}
gt.funcKeywordCode = ME;
function sl(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, xe._)`${n.parentData}[${n.parentDataProperty}]`));
}
function jE(e, t) {
  const { gen: r } = e;
  r.if((0, xe._)`Array.isArray(${t})`, () => {
    r.assign(er.default.vErrors, (0, xe._)`${er.default.vErrors} === null ? ${t} : ${er.default.vErrors}.concat(${t})`).assign(er.default.errors, (0, xe._)`${er.default.vErrors}.length`), (0, kE.extendErrors)(e);
  }, () => e.error());
}
function UE({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function xu(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, xe.stringify)(r) });
}
function VE(e, t, r = false) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
gt.validSchemaType = VE;
function xE({ schema: e, opts: t, self: r, errSchemaPath: n }, i, a) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(a) : i.keyword !== a)
    throw new Error("ajv implementation error");
  const s = i.dependencies;
  if (s != null && s.some((o) => !Object.prototype.hasOwnProperty.call(e, o)))
    throw new Error(`parent schema must have dependencies of ${a}: ${s.join(",")}`);
  if (i.validateSchema && !i.validateSchema(e[a])) {
    const l = `keyword "${a}" value is invalid at path "${n}": ` + r.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(l);
    else
      throw new Error(l);
  }
}
gt.validateKeywordUsage = xE;
var Vt = {};
Object.defineProperty(Vt, "__esModule", { value: true });
Vt.extendSubschemaMode = Vt.extendSubschemaData = Vt.getSubschema = void 0;
var mt = re2;
var Lu = fe;
function LE(e, { keyword: t, schemaProp: r, schema: n, schemaPath: i, errSchemaPath: a, topSchemaRef: s }) {
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const o = e.schema[t];
    return r === void 0 ? {
      schema: o,
      schemaPath: (0, mt._)`${e.schemaPath}${(0, mt.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: o[r],
      schemaPath: (0, mt._)`${e.schemaPath}${(0, mt.getProperty)(t)}${(0, mt.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, Lu.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (i === void 0 || a === void 0 || s === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: i,
      topSchemaRef: s,
      errSchemaPath: a
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Vt.getSubschema = LE;
function BE(e, t, { dataProp: r, dataPropType: n, data: i, dataTypes: a, propertyName: s }) {
  if (i !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = t;
  if (r !== void 0) {
    const { errorPath: c2, dataPathArr: u, opts: f } = t, p = o.let("data", (0, mt._)`${t.data}${(0, mt.getProperty)(r)}`, true);
    l(p), e.errorPath = (0, mt.str)`${c2}${(0, Lu.getErrorPath)(r, n, f.jsPropertySyntax)}`, e.parentDataProperty = (0, mt._)`${r}`, e.dataPathArr = [...u, e.parentDataProperty];
  }
  if (i !== void 0) {
    const c2 = i instanceof mt.Name ? i : o.let("data", i, true);
    l(c2), s !== void 0 && (e.propertyName = s);
  }
  a && (e.dataTypes = a);
  function l(c2) {
    e.data = c2, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, c2];
  }
}
Vt.extendSubschemaData = BE;
function qE(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: i, allErrors: a }) {
  n !== void 0 && (e.compositeRule = n), i !== void 0 && (e.createErrors = i), a !== void 0 && (e.allErrors = a), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
Vt.extendSubschemaMode = qE;
var Re = {};
var Bu = { exports: {} };
var jt = Bu.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, i = r.post || function() {
  };
  Hn(t, n, i, e, "", e);
};
jt.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true,
  if: true,
  then: true,
  else: true
};
jt.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};
jt.propsKeywords = {
  $defs: true,
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};
jt.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};
function Hn(e, t, r, n, i, a, s, o, l, c2) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, i, a, s, o, l, c2);
    for (var u in n) {
      var f = n[u];
      if (Array.isArray(f)) {
        if (u in jt.arrayKeywords)
          for (var p = 0; p < f.length; p++)
            Hn(e, t, r, f[p], i + "/" + u + "/" + p, a, i, u, n, p);
      } else if (u in jt.propsKeywords) {
        if (f && typeof f == "object")
          for (var d2 in f)
            Hn(e, t, r, f[d2], i + "/" + u + "/" + KE(d2), a, i, u, n, d2);
      } else
        (u in jt.keywords || e.allKeys && !(u in jt.skipKeywords)) && Hn(e, t, r, f, i + "/" + u, a, i, u, n);
    }
    r(n, i, a, s, o, l, c2);
  }
}
function KE(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var zE = Bu.exports;
Object.defineProperty(Re, "__esModule", { value: true });
Re.getSchemaRefs = Re.resolveUrl = Re.normalizeId = Re._getFullPath = Re.getFullPath = Re.inlineRef = void 0;
var WE = fe;
var GE = r2r;
var HE = zE;
var YE = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function JE(e, t = true) {
  return typeof e == "boolean" ? true : t === true ? !ca(e) : t ? qu(e) <= t : false;
}
Re.inlineRef = JE;
var XE = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function ca(e) {
  for (const t in e) {
    if (XE.has(t))
      return true;
    const r = e[t];
    if (Array.isArray(r) && r.some(ca) || typeof r == "object" && ca(r))
      return true;
  }
  return false;
}
function qu(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !YE.has(r) && (typeof e[r] == "object" && (0, WE.eachItem)(e[r], (n) => t += qu(n)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function Ku(e, t = "", r) {
  r !== false && (t = Er2(t));
  const n = e.parse(t);
  return zu(e, n);
}
Re.getFullPath = Ku;
function zu(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
Re._getFullPath = zu;
var ZE = /#\/?$/;
function Er2(e) {
  return e ? e.replace(ZE, "") : "";
}
Re.normalizeId = Er2;
function QE(e, t, r) {
  return r = Er2(r), e.resolve(t, r);
}
Re.resolveUrl = QE;
var eO = /^[a-z_][-a-z0-9._]*$/i;
function tO(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, i = Er2(e[r] || t), a = { "": i }, s = Ku(n, i, false), o = {}, l = /* @__PURE__ */ new Set();
  return HE(e, { allKeys: true }, (f, p, d2, m2) => {
    if (m2 === void 0)
      return;
    const h2 = s + p;
    let g = a[m2];
    typeof f[r] == "string" && (g = y2.call(this, f[r])), v.call(this, f.$anchor), v.call(this, f.$dynamicAnchor), a[p] = g;
    function y2(b) {
      const w = this.opts.uriResolver.resolve;
      if (b = Er2(g ? w(g, b) : b), l.has(b))
        throw u(b);
      l.add(b);
      let C = this.refs[b];
      return typeof C == "string" && (C = this.refs[C]), typeof C == "object" ? c2(f, C.schema, b) : b !== Er2(h2) && (b[0] === "#" ? (c2(f, o[b], b), o[b] = f) : this.refs[b] = h2), b;
    }
    function v(b) {
      if (typeof b == "string") {
        if (!eO.test(b))
          throw new Error(`invalid anchor "${b}"`);
        y2.call(this, `#${b}`);
      }
    }
  }), o;
  function c2(f, p, d2) {
    if (p !== void 0 && !GE(f, p))
      throw u(d2);
  }
  function u(f) {
    return new Error(`reference "${f}" resolves to more than one schema`);
  }
}
Re.getSchemaRefs = tO;
Object.defineProperty(lt, "__esModule", { value: true });
lt.getData = lt.KeywordCxt = lt.validateFunctionCode = void 0;
var Wu = Tr;
var ol = _n;
var ds = Ot;
var si = _n;
var rO = Oi;
var Xr2 = gt;
var Ki = Vt;
var H = re2;
var Z = vt;
var nO = Re;
var Ct = fe;
var Hr = $n;
function iO(e) {
  if (Yu(e) && (Ju(e), Hu(e))) {
    oO(e);
    return;
  }
  Gu(e, () => (0, Wu.topBoolOrEmptySchema)(e));
}
lt.validateFunctionCode = iO;
function Gu({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: i }, a) {
  i.code.es5 ? e.func(t, (0, H._)`${Z.default.data}, ${Z.default.valCxt}`, n.$async, () => {
    e.code((0, H._)`"use strict"; ${ll(r, i)}`), sO(e, i), e.code(a);
  }) : e.func(t, (0, H._)`${Z.default.data}, ${aO(i)}`, n.$async, () => e.code(ll(r, i)).code(a));
}
function aO(e) {
  return (0, H._)`{${Z.default.instancePath}="", ${Z.default.parentData}, ${Z.default.parentDataProperty}, ${Z.default.rootData}=${Z.default.data}${e.dynamicRef ? (0, H._)`, ${Z.default.dynamicAnchors}={}` : H.nil}}={}`;
}
function sO(e, t) {
  e.if(Z.default.valCxt, () => {
    e.var(Z.default.instancePath, (0, H._)`${Z.default.valCxt}.${Z.default.instancePath}`), e.var(Z.default.parentData, (0, H._)`${Z.default.valCxt}.${Z.default.parentData}`), e.var(Z.default.parentDataProperty, (0, H._)`${Z.default.valCxt}.${Z.default.parentDataProperty}`), e.var(Z.default.rootData, (0, H._)`${Z.default.valCxt}.${Z.default.rootData}`), t.dynamicRef && e.var(Z.default.dynamicAnchors, (0, H._)`${Z.default.valCxt}.${Z.default.dynamicAnchors}`);
  }, () => {
    e.var(Z.default.instancePath, (0, H._)`""`), e.var(Z.default.parentData, (0, H._)`undefined`), e.var(Z.default.parentDataProperty, (0, H._)`undefined`), e.var(Z.default.rootData, Z.default.data), t.dynamicRef && e.var(Z.default.dynamicAnchors, (0, H._)`{}`);
  });
}
function oO(e) {
  const { schema: t, opts: r, gen: n } = e;
  Gu(e, () => {
    r.$comment && t.$comment && Zu(e), fO(e), n.let(Z.default.vErrors, null), n.let(Z.default.errors, 0), r.unevaluated && lO(e), Xu(e), pO(e);
  });
}
function lO(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, H._)`${r}.evaluated`), t.if((0, H._)`${e.evaluated}.dynamicProps`, () => t.assign((0, H._)`${e.evaluated}.props`, (0, H._)`undefined`)), t.if((0, H._)`${e.evaluated}.dynamicItems`, () => t.assign((0, H._)`${e.evaluated}.items`, (0, H._)`undefined`));
}
function ll(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, H._)`/*# sourceURL=${r} */` : H.nil;
}
function cO(e, t) {
  if (Yu(e) && (Ju(e), Hu(e))) {
    uO(e, t);
    return;
  }
  (0, Wu.boolOrEmptySchema)(e, t);
}
function Hu({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return true;
  return false;
}
function Yu(e) {
  return typeof e.schema != "boolean";
}
function uO(e, t) {
  const { schema: r, gen: n, opts: i } = e;
  i.$comment && r.$comment && Zu(e), hO(e), mO(e);
  const a = n.const("_errs", Z.default.errors);
  Xu(e, a), n.var(t, (0, H._)`${a} === ${Z.default.errors}`);
}
function Ju(e) {
  (0, Ct.checkUnknownRules)(e), dO(e);
}
function Xu(e, t) {
  if (e.opts.jtd)
    return cl(e, [], false, t);
  const r = (0, ol.getSchemaTypes)(e.schema), n = (0, ol.coerceAndCheckDataType)(e, r);
  cl(e, r, !n, t);
}
function dO(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: i } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, Ct.schemaHasRulesButRef)(t, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function fO(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, Ct.checkStrictMode)(e, "default is ignored in the schema root");
}
function hO(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, nO.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function mO(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function Zu({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: i }) {
  const a = r.$comment;
  if (i.$comment === true)
    e.code((0, H._)`${Z.default.self}.logger.log(${a})`);
  else if (typeof i.$comment == "function") {
    const s = (0, H.str)`${n}/$comment`, o = e.scopeValue("root", { ref: t.root });
    e.code((0, H._)`${Z.default.self}.opts.$comment(${a}, ${s}, ${o}.schema)`);
  }
}
function pO(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: i, opts: a } = e;
  r.$async ? t.if((0, H._)`${Z.default.errors} === 0`, () => t.return(Z.default.data), () => t.throw((0, H._)`new ${i}(${Z.default.vErrors})`)) : (t.assign((0, H._)`${n}.errors`, Z.default.vErrors), a.unevaluated && yO(e), t.return((0, H._)`${Z.default.errors} === 0`));
}
function yO({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof H.Name && e.assign((0, H._)`${t}.props`, r), n instanceof H.Name && e.assign((0, H._)`${t}.items`, n);
}
function cl(e, t, r, n) {
  const { gen: i, schema: a, data: s, allErrors: o, opts: l, self: c2 } = e, { RULES: u } = c2;
  if (a.$ref && (l.ignoreKeywordsWithRef || !(0, Ct.schemaHasRulesButRef)(a, u))) {
    i.block(() => td(e, "$ref", u.all.$ref.definition));
    return;
  }
  l.jtd || gO(e, t), i.block(() => {
    for (const p of u.rules)
      f(p);
    f(u.post);
  });
  function f(p) {
    (0, ds.shouldUseGroup)(a, p) && (p.type ? (i.if((0, si.checkDataType)(p.type, s, l.strictNumbers)), ul(e, p), t.length === 1 && t[0] === p.type && r && (i.else(), (0, si.reportTypeError)(e)), i.endIf()) : ul(e, p), o || i.if((0, H._)`${Z.default.errors} === ${n || 0}`));
  }
}
function ul(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: i } } = e;
  i && (0, rO.assignDefaults)(e, t.type), r.block(() => {
    for (const a of t.rules)
      (0, ds.shouldUseRule)(n, a) && td(e, a.keyword, a.definition, t.type);
  });
}
function gO(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (vO(e, t), e.opts.allowUnionTypes || $O(e, t), _O(e, e.dataTypes));
}
function vO(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      Qu(e.dataTypes, r) || fs(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), SO(e, t);
  }
}
function $O(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && fs(e, "use allowUnionTypes to allow union type keyword");
}
function _O(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const i = r[n];
    if (typeof i == "object" && (0, ds.shouldUseRule)(e.schema, i)) {
      const { type: a } = i.definition;
      a.length && !a.some((s) => bO(t, s)) && fs(e, `missing type "${a.join(",")}" for keyword "${n}"`);
    }
  }
}
function bO(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function Qu(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function SO(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    Qu(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function fs(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, Ct.checkStrictMode)(e, t, e.opts.strictTypes);
}
var ed = class {
  constructor(t, r, n) {
    if ((0, Xr2.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, Ct.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", rd(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Xr2.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== false) && (this.errsCount = t.gen.const("_errs", Z.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, H.not)(t), r, n);
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, H.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(false);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, H._)`${r} !== undefined && (${(0, H.or)(this.invalid$data(), t)})`);
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
    (t ? Hr.reportExtraError : Hr.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, Hr.reportError)(this, this.def.$dataError || Hr.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Hr.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, n = H.nil) {
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
  check$data(t = H.nil, r = H.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: i, schemaType: a, def: s } = this;
    n.if((0, H.or)((0, H._)`${i} === undefined`, r)), t !== H.nil && n.assign(t, true), (a.length || s.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== H.nil && n.assign(t, false)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: i, it: a } = this;
    return (0, H.or)(s(), o());
    function s() {
      if (n.length) {
        if (!(r instanceof H.Name))
          throw new Error("ajv implementation error");
        const l = Array.isArray(n) ? n : [n];
        return (0, H._)`${(0, si.checkDataTypes)(l, r, a.opts.strictNumbers, si.DataType.Wrong)}`;
      }
      return H.nil;
    }
    function o() {
      if (i.validateSchema) {
        const l = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, H._)`!${l}(${r})`;
      }
      return H.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Ki.getSubschema)(this.it, t);
    (0, Ki.extendSubschemaData)(n, this.it, t), (0, Ki.extendSubschemaMode)(n, t);
    const i = { ...this.it, ...n, items: void 0, props: void 0 };
    return cO(i, r), i;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: i } = this;
    n.opts.unevaluated && (n.props !== true && t.props !== void 0 && (n.props = Ct.mergeEvaluated.props(i, t.props, n.props, r)), n.items !== true && t.items !== void 0 && (n.items = Ct.mergeEvaluated.items(i, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: i } = this;
    if (n.opts.unevaluated && (n.props !== true || n.items !== true))
      return i.if(r, () => this.mergeEvaluated(t, H.Name)), true;
  }
};
lt.KeywordCxt = ed;
function td(e, t, r, n) {
  const i = new ed(e, r, t);
  "code" in r ? r.code(i, n) : i.$data && r.validate ? (0, Xr2.funcKeywordCode)(i, r) : "macro" in r ? (0, Xr2.macroKeywordCode)(i, r) : (r.compile || r.validate) && (0, Xr2.funcKeywordCode)(i, r);
}
var wO = /^\/(?:[^~]|~0|~1)*$/;
var EO = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function rd(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let i, a;
  if (e === "")
    return Z.default.rootData;
  if (e[0] === "/") {
    if (!wO.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    i = e, a = Z.default.rootData;
  } else {
    const c2 = EO.exec(e);
    if (!c2)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const u = +c2[1];
    if (i = c2[2], i === "#") {
      if (u >= t)
        throw new Error(l("property/index", u));
      return n[t - u];
    }
    if (u > t)
      throw new Error(l("data", u));
    if (a = r[t - u], !i)
      return a;
  }
  let s = a;
  const o = i.split("/");
  for (const c2 of o)
    c2 && (a = (0, H._)`${a}${(0, H.getProperty)((0, Ct.unescapeJsonPointer)(c2))}`, s = (0, H._)`${s} && ${a}`);
  return s;
  function l(c2, u) {
    return `Cannot access ${c2} ${u} levels up, current level is ${t}`;
  }
}
lt.getData = rd;
var bn = {};
Object.defineProperty(bn, "__esModule", { value: true });
var OO = class extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = true;
  }
};
bn.default = OO;
var Sn = {};
Object.defineProperty(Sn, "__esModule", { value: true });
var zi = Re;
var CO = class extends Error {
  constructor(t, r, n, i) {
    super(i || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, zi.resolveUrl)(t, r, n), this.missingSchema = (0, zi.normalizeId)((0, zi.getFullPath)(t, this.missingRef));
  }
};
Sn.default = CO;
var ze = {};
Object.defineProperty(ze, "__esModule", { value: true });
ze.resolveSchema = ze.getCompilingSchema = ze.resolveRef = ze.compileSchema = ze.SchemaEnv = void 0;
var nt2 = re2;
var AO = bn;
var Xt = vt;
var st2 = Re;
var dl = fe;
var PO = lt;
var Ci = class {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, st2.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
};
ze.SchemaEnv = Ci;
function hs(e) {
  const t = nd.call(this, e);
  if (t)
    return t;
  const r = (0, st2.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: i } = this.opts.code, { ownProperties: a } = this.opts, s = new nt2.CodeGen(this.scope, { es5: n, lines: i, ownProperties: a });
  let o;
  e.$async && (o = s.scopeValue("Error", {
    ref: AO.default,
    code: (0, nt2._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const l = s.scopeName("validate");
  e.validateName = l;
  const c2 = {
    gen: s,
    allErrors: this.opts.allErrors,
    data: Xt.default.data,
    parentData: Xt.default.parentData,
    parentDataProperty: Xt.default.parentDataProperty,
    dataNames: [Xt.default.data],
    dataPathArr: [nt2.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: s.scopeValue("schema", this.opts.code.source === true ? { ref: e.schema, code: (0, nt2.stringify)(e.schema) } : { ref: e.schema }),
    validateName: l,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: nt2.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, nt2._)`""`,
    opts: this.opts,
    self: this
  };
  let u;
  try {
    this._compilations.add(e), (0, PO.validateFunctionCode)(c2), s.optimize(this.opts.code.optimize);
    const f = s.toString();
    u = `${s.scopeRefs(Xt.default.scope)}return ${f}`, this.opts.code.process && (u = this.opts.code.process(u, e));
    const d2 = new Function(`${Xt.default.self}`, `${Xt.default.scope}`, u)(this, this.scope.get());
    if (this.scope.value(l, { ref: d2 }), d2.errors = null, d2.schema = e.schema, d2.schemaEnv = e, e.$async && (d2.$async = true), this.opts.code.source === true && (d2.source = { validateName: l, validateCode: f, scopeValues: s._values }), this.opts.unevaluated) {
      const { props: m2, items: h2 } = c2;
      d2.evaluated = {
        props: m2 instanceof nt2.Name ? void 0 : m2,
        items: h2 instanceof nt2.Name ? void 0 : h2,
        dynamicProps: m2 instanceof nt2.Name,
        dynamicItems: h2 instanceof nt2.Name
      }, d2.source && (d2.source.evaluated = (0, nt2.stringify)(d2.evaluated));
    }
    return e.validate = d2, e;
  } catch (f) {
    throw delete e.validate, delete e.validateName, u && this.logger.error("Error compiling schema, function code:", u), f;
  } finally {
    this._compilations.delete(e);
  }
}
ze.compileSchema = hs;
function IO(e, t, r) {
  var n;
  r = (0, st2.resolveUrl)(this.opts.uriResolver, t, r);
  const i = e.refs[r];
  if (i)
    return i;
  let a = DO.call(this, e, r);
  if (a === void 0) {
    const s = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: o } = this.opts;
    s && (a = new Ci({ schema: s, schemaId: o, root: e, baseId: t }));
  }
  if (a !== void 0)
    return e.refs[r] = TO.call(this, a);
}
ze.resolveRef = IO;
function TO(e) {
  return (0, st2.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : hs.call(this, e);
}
function nd(e) {
  for (const t of this._compilations)
    if (NO(t, e))
      return t;
}
ze.getCompilingSchema = nd;
function NO(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function DO(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Ai.call(this, e, t);
}
function Ai(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, st2._getFullPath)(this.opts.uriResolver, r);
  let i = (0, st2.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === i)
    return Wi.call(this, r, e);
  const a = (0, st2.normalizeId)(n), s = this.refs[a] || this.schemas[a];
  if (typeof s == "string") {
    const o = Ai.call(this, e, s);
    return typeof (o == null ? void 0 : o.schema) != "object" ? void 0 : Wi.call(this, r, o);
  }
  if (typeof (s == null ? void 0 : s.schema) == "object") {
    if (s.validate || hs.call(this, s), a === (0, st2.normalizeId)(t)) {
      const { schema: o } = s, { schemaId: l } = this.opts, c2 = o[l];
      return c2 && (i = (0, st2.resolveUrl)(this.opts.uriResolver, i, c2)), new Ci({ schema: o, schemaId: l, root: e, baseId: i });
    }
    return Wi.call(this, r, s);
  }
}
ze.resolveSchema = Ai;
var FO = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Wi(e, { baseId: t, schema: r, root: n }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const l = r[(0, dl.unescapeFragment)(o)];
    if (l === void 0)
      return;
    r = l;
    const c2 = typeof r == "object" && r[this.opts.schemaId];
    !FO.has(o) && c2 && (t = (0, st2.resolveUrl)(this.opts.uriResolver, t, c2));
  }
  let a;
  if (typeof r != "boolean" && r.$ref && !(0, dl.schemaHasRulesButRef)(r, this.RULES)) {
    const o = (0, st2.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    a = Ai.call(this, n, o);
  }
  const { schemaId: s } = this.opts;
  if (a = a || new Ci({ schema: r, schemaId: s, root: n, baseId: t }), a.schema !== a.root.schema)
    return a;
}
var kO = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var RO = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
var MO = "object";
var jO = [
  "$data"
];
var UO = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
};
var VO = false;
var xO = {
  $id: kO,
  description: RO,
  type: MO,
  required: jO,
  properties: UO,
  additionalProperties: VO
};
var ms = {};
var ua = { exports: {} };
(function(e, t) {
  (function(r, n) {
    n(t);
  })(Q2, function(r) {
    function n() {
      for (var A3 = arguments.length, S4 = Array(A3), I = 0; I < A3; I++)
        S4[I] = arguments[I];
      if (S4.length > 1) {
        S4[0] = S4[0].slice(0, -1);
        for (var R2 = S4.length - 1, k = 1; k < R2; ++k)
          S4[k] = S4[k].slice(1, -1);
        return S4[R2] = S4[R2].slice(1), S4.join("");
      } else
        return S4[0];
    }
    function i(A3) {
      return "(?:" + A3 + ")";
    }
    function a(A3) {
      return A3 === void 0 ? "undefined" : A3 === null ? "null" : Object.prototype.toString.call(A3).split(" ").pop().split("]").shift().toLowerCase();
    }
    function s(A3) {
      return A3.toUpperCase();
    }
    function o(A3) {
      return A3 != null ? A3 instanceof Array ? A3 : typeof A3.length != "number" || A3.split || A3.setInterval || A3.call ? [A3] : Array.prototype.slice.call(A3) : [];
    }
    function l(A3, S4) {
      var I = A3;
      if (S4)
        for (var R2 in S4)
          I[R2] = S4[R2];
      return I;
    }
    function c2(A3) {
      var S4 = "[A-Za-z]", I = "[0-9]", R2 = n(I, "[A-Fa-f]"), k = i(i("%[EFef]" + R2 + "%" + R2 + R2 + "%" + R2 + R2) + "|" + i("%[89A-Fa-f]" + R2 + "%" + R2 + R2) + "|" + i("%" + R2 + R2)), J2 = "[\\:\\/\\?\\#\\[\\]\\@]", X = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", de2 = n(J2, X), ge2 = A3 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Ce = A3 ? "[\\uE000-\\uF8FF]" : "[]", se = n(S4, I, "[\\-\\.\\_\\~]", ge2);
      i(S4 + n(S4, I, "[\\+\\-\\.]") + "*"), i(i(k + "|" + n(se, X, "[\\:]")) + "*");
      var ye = i(i("25[0-5]") + "|" + i("2[0-4]" + I) + "|" + i("1" + I + I) + "|" + i("0?[1-9]" + I) + "|0?0?" + I), Ae = i(ye + "\\." + ye + "\\." + ye + "\\." + ye), Q = i(R2 + "{1,4}"), _e2 = i(i(Q + "\\:" + Q) + "|" + Ae), Ie = i(i(Q + "\\:") + "{6}" + _e2), be2 = i("\\:\\:" + i(Q + "\\:") + "{5}" + _e2), Tt = i(i(Q) + "?\\:\\:" + i(Q + "\\:") + "{4}" + _e2), dt = i(i(i(Q + "\\:") + "{0,1}" + Q) + "?\\:\\:" + i(Q + "\\:") + "{3}" + _e2), ft = i(i(i(Q + "\\:") + "{0,2}" + Q) + "?\\:\\:" + i(Q + "\\:") + "{2}" + _e2), hr2 = i(i(i(Q + "\\:") + "{0,3}" + Q) + "?\\:\\:" + Q + "\\:" + _e2), Yt = i(i(i(Q + "\\:") + "{0,4}" + Q) + "?\\:\\:" + _e2), Xe2 = i(i(i(Q + "\\:") + "{0,5}" + Q) + "?\\:\\:" + Q), ht = i(i(i(Q + "\\:") + "{0,6}" + Q) + "?\\:\\:"), Jt = i([Ie, be2, Tt, dt, ft, hr2, Yt, Xe2, ht].join("|")), _t = i(i(se + "|" + k) + "+");
      i("[vV]" + R2 + "+\\." + n(se, X, "[\\:]") + "+"), i(i(k + "|" + n(se, X)) + "*");
      var qr = i(k + "|" + n(se, X, "[\\:\\@]"));
      return i(i(k + "|" + n(se, X, "[\\@]")) + "+"), i(i(qr + "|" + n("[\\/\\?]", Ce)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", S4, I, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", se, X), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", se, X), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", se, X), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", se, X), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", se, X, "[\\:\\@\\/\\?]", Ce), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", se, X, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", se, X), "g"),
        UNRESERVED: new RegExp(se, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", se, de2), "g"),
        PCT_ENCODED: new RegExp(k, "g"),
        IPV4ADDRESS: new RegExp("^(" + Ae + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Jt + ")" + i(i("\\%25|\\%(?!" + R2 + "{2})") + "(" + _t + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var u = c2(false), f = c2(true), p = /* @__PURE__ */ function() {
      function A3(S4, I) {
        var R2 = [], k = true, J2 = false, X = void 0;
        try {
          for (var de2 = S4[Symbol.iterator](), ge2; !(k = (ge2 = de2.next()).done) && (R2.push(ge2.value), !(I && R2.length === I)); k = true)
            ;
        } catch (Ce) {
          J2 = true, X = Ce;
        } finally {
          try {
            !k && de2.return && de2.return();
          } finally {
            if (J2)
              throw X;
          }
        }
        return R2;
      }
      return function(S4, I) {
        if (Array.isArray(S4))
          return S4;
        if (Symbol.iterator in Object(S4))
          return A3(S4, I);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), d2 = function(A3) {
      if (Array.isArray(A3)) {
        for (var S4 = 0, I = Array(A3.length); S4 < A3.length; S4++)
          I[S4] = A3[S4];
        return I;
      } else
        return Array.from(A3);
    }, m2 = 2147483647, h2 = 36, g = 1, y2 = 26, v = 38, b = 700, w = 72, C = 128, E2 = "-", _3 = /^xn--/, T = /[^\0-\x7E]/, F = /[\x2E\u3002\uFF0E\uFF61]/g, j2 = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, L = h2 - g, U = Math.floor, W = String.fromCharCode;
    function z2(A3) {
      throw new RangeError(j2[A3]);
    }
    function q3(A3, S4) {
      for (var I = [], R2 = A3.length; R2--; )
        I[R2] = S4(A3[R2]);
      return I;
    }
    function ue(A3, S4) {
      var I = A3.split("@"), R2 = "";
      I.length > 1 && (R2 = I[0] + "@", A3 = I[1]), A3 = A3.replace(F, ".");
      var k = A3.split("."), J2 = q3(k, S4).join(".");
      return R2 + J2;
    }
    function me(A3) {
      for (var S4 = [], I = 0, R2 = A3.length; I < R2; ) {
        var k = A3.charCodeAt(I++);
        if (k >= 55296 && k <= 56319 && I < R2) {
          var J2 = A3.charCodeAt(I++);
          (J2 & 64512) == 56320 ? S4.push(((k & 1023) << 10) + (J2 & 1023) + 65536) : (S4.push(k), I--);
        } else
          S4.push(k);
      }
      return S4;
    }
    var ie2 = function(S4) {
      return String.fromCodePoint.apply(String, d2(S4));
    }, Y2 = function(S4) {
      return S4 - 48 < 10 ? S4 - 22 : S4 - 65 < 26 ? S4 - 65 : S4 - 97 < 26 ? S4 - 97 : h2;
    }, V2 = function(S4, I) {
      return S4 + 22 + 75 * (S4 < 26) - ((I != 0) << 5);
    }, N3 = function(S4, I, R2) {
      var k = 0;
      for (
        S4 = R2 ? U(S4 / b) : S4 >> 1, S4 += U(S4 / I);
        /* no initialization */
        S4 > L * y2 >> 1;
        k += h2
      )
        S4 = U(S4 / L);
      return U(k + (L + 1) * S4 / (S4 + v));
    }, x3 = function(S4) {
      var I = [], R2 = S4.length, k = 0, J2 = C, X = w, de2 = S4.lastIndexOf(E2);
      de2 < 0 && (de2 = 0);
      for (var ge2 = 0; ge2 < de2; ++ge2)
        S4.charCodeAt(ge2) >= 128 && z2("not-basic"), I.push(S4.charCodeAt(ge2));
      for (var Ce = de2 > 0 ? de2 + 1 : 0; Ce < R2; ) {
        for (
          var se = k, ye = 1, Ae = h2;
          ;
          /* no condition */
          Ae += h2
        ) {
          Ce >= R2 && z2("invalid-input");
          var Q = Y2(S4.charCodeAt(Ce++));
          (Q >= h2 || Q > U((m2 - k) / ye)) && z2("overflow"), k += Q * ye;
          var _e2 = Ae <= X ? g : Ae >= X + y2 ? y2 : Ae - X;
          if (Q < _e2)
            break;
          var Ie = h2 - _e2;
          ye > U(m2 / Ie) && z2("overflow"), ye *= Ie;
        }
        var be2 = I.length + 1;
        X = N3(k - se, be2, se == 0), U(k / be2) > m2 - J2 && z2("overflow"), J2 += U(k / be2), k %= be2, I.splice(k++, 0, J2);
      }
      return String.fromCodePoint.apply(String, I);
    }, D = function(S4) {
      var I = [];
      S4 = me(S4);
      var R2 = S4.length, k = C, J2 = 0, X = w, de2 = true, ge2 = false, Ce = void 0;
      try {
        for (var se = S4[Symbol.iterator](), ye; !(de2 = (ye = se.next()).done); de2 = true) {
          var Ae = ye.value;
          Ae < 128 && I.push(W(Ae));
        }
      } catch (Kr) {
        ge2 = true, Ce = Kr;
      } finally {
        try {
          !de2 && se.return && se.return();
        } finally {
          if (ge2)
            throw Ce;
        }
      }
      var Q = I.length, _e2 = Q;
      for (Q && I.push(E2); _e2 < R2; ) {
        var Ie = m2, be2 = true, Tt = false, dt = void 0;
        try {
          for (var ft = S4[Symbol.iterator](), hr2; !(be2 = (hr2 = ft.next()).done); be2 = true) {
            var Yt = hr2.value;
            Yt >= k && Yt < Ie && (Ie = Yt);
          }
        } catch (Kr) {
          Tt = true, dt = Kr;
        } finally {
          try {
            !be2 && ft.return && ft.return();
          } finally {
            if (Tt)
              throw dt;
          }
        }
        var Xe2 = _e2 + 1;
        Ie - k > U((m2 - J2) / Xe2) && z2("overflow"), J2 += (Ie - k) * Xe2, k = Ie;
        var ht = true, Jt = false, _t = void 0;
        try {
          for (var qr = S4[Symbol.iterator](), no; !(ht = (no = qr.next()).done); ht = true) {
            var io = no.value;
            if (io < k && ++J2 > m2 && z2("overflow"), io == k) {
              for (
                var Cn = J2, An = h2;
                ;
                /* no condition */
                An += h2
              ) {
                var Pn = An <= X ? g : An >= X + y2 ? y2 : An - X;
                if (Cn < Pn)
                  break;
                var ao2 = Cn - Pn, so = h2 - Pn;
                I.push(W(V2(Pn + ao2 % so, 0))), Cn = U(ao2 / so);
              }
              I.push(W(V2(Cn, 0))), X = N3(J2, Xe2, _e2 == Q), J2 = 0, ++_e2;
            }
          }
        } catch (Kr) {
          Jt = true, _t = Kr;
        } finally {
          try {
            !ht && qr.return && qr.return();
          } finally {
            if (Jt)
              throw _t;
          }
        }
        ++J2, ++k;
      }
      return I.join("");
    }, $ = function(S4) {
      return ue(S4, function(I) {
        return _3.test(I) ? x3(I.slice(4).toLowerCase()) : I;
      });
    }, P = function(S4) {
      return ue(S4, function(I) {
        return T.test(I) ? "xn--" + D(I) : I;
      });
    }, M = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: me,
        encode: ie2
      },
      decode: x3,
      encode: D,
      toASCII: P,
      toUnicode: $
    }, B = {};
    function K(A3) {
      var S4 = A3.charCodeAt(0), I = void 0;
      return S4 < 16 ? I = "%0" + S4.toString(16).toUpperCase() : S4 < 128 ? I = "%" + S4.toString(16).toUpperCase() : S4 < 2048 ? I = "%" + (S4 >> 6 | 192).toString(16).toUpperCase() + "%" + (S4 & 63 | 128).toString(16).toUpperCase() : I = "%" + (S4 >> 12 | 224).toString(16).toUpperCase() + "%" + (S4 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (S4 & 63 | 128).toString(16).toUpperCase(), I;
    }
    function te(A3) {
      for (var S4 = "", I = 0, R2 = A3.length; I < R2; ) {
        var k = parseInt(A3.substr(I + 1, 2), 16);
        if (k < 128)
          S4 += String.fromCharCode(k), I += 3;
        else if (k >= 194 && k < 224) {
          if (R2 - I >= 6) {
            var J2 = parseInt(A3.substr(I + 4, 2), 16);
            S4 += String.fromCharCode((k & 31) << 6 | J2 & 63);
          } else
            S4 += A3.substr(I, 6);
          I += 6;
        } else if (k >= 224) {
          if (R2 - I >= 9) {
            var X = parseInt(A3.substr(I + 4, 2), 16), de2 = parseInt(A3.substr(I + 7, 2), 16);
            S4 += String.fromCharCode((k & 15) << 12 | (X & 63) << 6 | de2 & 63);
          } else
            S4 += A3.substr(I, 9);
          I += 9;
        } else
          S4 += A3.substr(I, 3), I += 3;
      }
      return S4;
    }
    function ae(A3, S4) {
      function I(R2) {
        var k = te(R2);
        return k.match(S4.UNRESERVED) ? k : R2;
      }
      return A3.scheme && (A3.scheme = String(A3.scheme).replace(S4.PCT_ENCODED, I).toLowerCase().replace(S4.NOT_SCHEME, "")), A3.userinfo !== void 0 && (A3.userinfo = String(A3.userinfo).replace(S4.PCT_ENCODED, I).replace(S4.NOT_USERINFO, K).replace(S4.PCT_ENCODED, s)), A3.host !== void 0 && (A3.host = String(A3.host).replace(S4.PCT_ENCODED, I).toLowerCase().replace(S4.NOT_HOST, K).replace(S4.PCT_ENCODED, s)), A3.path !== void 0 && (A3.path = String(A3.path).replace(S4.PCT_ENCODED, I).replace(A3.scheme ? S4.NOT_PATH : S4.NOT_PATH_NOSCHEME, K).replace(S4.PCT_ENCODED, s)), A3.query !== void 0 && (A3.query = String(A3.query).replace(S4.PCT_ENCODED, I).replace(S4.NOT_QUERY, K).replace(S4.PCT_ENCODED, s)), A3.fragment !== void 0 && (A3.fragment = String(A3.fragment).replace(S4.PCT_ENCODED, I).replace(S4.NOT_FRAGMENT, K).replace(S4.PCT_ENCODED, s)), A3;
    }
    function pe(A3) {
      return A3.replace(/^0*(.*)/, "$1") || "0";
    }
    function He(A3, S4) {
      var I = A3.match(S4.IPV4ADDRESS) || [], R2 = p(I, 2), k = R2[1];
      return k ? k.split(".").map(pe).join(".") : A3;
    }
    function rt(A3, S4) {
      var I = A3.match(S4.IPV6ADDRESS) || [], R2 = p(I, 3), k = R2[1], J2 = R2[2];
      if (k) {
        for (var X = k.toLowerCase().split("::").reverse(), de2 = p(X, 2), ge2 = de2[0], Ce = de2[1], se = Ce ? Ce.split(":").map(pe) : [], ye = ge2.split(":").map(pe), Ae = S4.IPV4ADDRESS.test(ye[ye.length - 1]), Q = Ae ? 7 : 8, _e2 = ye.length - Q, Ie = Array(Q), be2 = 0; be2 < Q; ++be2)
          Ie[be2] = se[be2] || ye[_e2 + be2] || "";
        Ae && (Ie[Q - 1] = He(Ie[Q - 1], S4));
        var Tt = Ie.reduce(function(Xe2, ht, Jt) {
          if (!ht || ht === "0") {
            var _t = Xe2[Xe2.length - 1];
            _t && _t.index + _t.length === Jt ? _t.length++ : Xe2.push({ index: Jt, length: 1 });
          }
          return Xe2;
        }, []), dt = Tt.sort(function(Xe2, ht) {
          return ht.length - Xe2.length;
        })[0], ft = void 0;
        if (dt && dt.length > 1) {
          var hr2 = Ie.slice(0, dt.index), Yt = Ie.slice(dt.index + dt.length);
          ft = hr2.join(":") + "::" + Yt.join(":");
        } else
          ft = Ie.join(":");
        return J2 && (ft += "%" + J2), ft;
      } else
        return A3;
    }
    var qt = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Kt = "".match(/(){0}/)[1] === void 0;
    function Ue(A3) {
      var S4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, I = {}, R2 = S4.iri !== false ? f : u;
      S4.reference === "suffix" && (A3 = (S4.scheme ? S4.scheme + ":" : "") + "//" + A3);
      var k = A3.match(qt);
      if (k) {
        Kt ? (I.scheme = k[1], I.userinfo = k[3], I.host = k[4], I.port = parseInt(k[5], 10), I.path = k[6] || "", I.query = k[7], I.fragment = k[8], isNaN(I.port) && (I.port = k[5])) : (I.scheme = k[1] || void 0, I.userinfo = A3.indexOf("@") !== -1 ? k[3] : void 0, I.host = A3.indexOf("//") !== -1 ? k[4] : void 0, I.port = parseInt(k[5], 10), I.path = k[6] || "", I.query = A3.indexOf("?") !== -1 ? k[7] : void 0, I.fragment = A3.indexOf("#") !== -1 ? k[8] : void 0, isNaN(I.port) && (I.port = A3.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? k[4] : void 0)), I.host && (I.host = rt(He(I.host, R2), R2)), I.scheme === void 0 && I.userinfo === void 0 && I.host === void 0 && I.port === void 0 && !I.path && I.query === void 0 ? I.reference = "same-document" : I.scheme === void 0 ? I.reference = "relative" : I.fragment === void 0 ? I.reference = "absolute" : I.reference = "uri", S4.reference && S4.reference !== "suffix" && S4.reference !== I.reference && (I.error = I.error || "URI is not a " + S4.reference + " reference.");
        var J2 = B[(S4.scheme || I.scheme || "").toLowerCase()];
        if (!S4.unicodeSupport && (!J2 || !J2.unicodeSupport)) {
          if (I.host && (S4.domainHost || J2 && J2.domainHost))
            try {
              I.host = M.toASCII(I.host.replace(R2.PCT_ENCODED, te).toLowerCase());
            } catch (X) {
              I.error = I.error || "Host's domain name can not be converted to ASCII via punycode: " + X;
            }
          ae(I, u);
        } else
          ae(I, R2);
        J2 && J2.parse && J2.parse(I, S4);
      } else
        I.error = I.error || "URI can not be parsed.";
      return I;
    }
    function zt(A3, S4) {
      var I = S4.iri !== false ? f : u, R2 = [];
      return A3.userinfo !== void 0 && (R2.push(A3.userinfo), R2.push("@")), A3.host !== void 0 && R2.push(rt(He(String(A3.host), I), I).replace(I.IPV6ADDRESS, function(k, J2, X) {
        return "[" + J2 + (X ? "%25" + X : "") + "]";
      })), (typeof A3.port == "number" || typeof A3.port == "string") && (R2.push(":"), R2.push(String(A3.port))), R2.length ? R2.join("") : void 0;
    }
    var It = /^\.\.?\//, $t = /^\/\.(\/|$)/, qe = /^\/\.\.(\/|$)/, Wt = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Ye(A3) {
      for (var S4 = []; A3.length; )
        if (A3.match(It))
          A3 = A3.replace(It, "");
        else if (A3.match($t))
          A3 = A3.replace($t, "/");
        else if (A3.match(qe))
          A3 = A3.replace(qe, "/"), S4.pop();
        else if (A3 === "." || A3 === "..")
          A3 = "";
        else {
          var I = A3.match(Wt);
          if (I) {
            var R2 = I[0];
            A3 = A3.slice(R2.length), S4.push(R2);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return S4.join("");
    }
    function Ve(A3) {
      var S4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, I = S4.iri ? f : u, R2 = [], k = B[(S4.scheme || A3.scheme || "").toLowerCase()];
      if (k && k.serialize && k.serialize(A3, S4), A3.host && !I.IPV6ADDRESS.test(A3.host)) {
        if (S4.domainHost || k && k.domainHost)
          try {
            A3.host = S4.iri ? M.toUnicode(A3.host) : M.toASCII(A3.host.replace(I.PCT_ENCODED, te).toLowerCase());
          } catch (de2) {
            A3.error = A3.error || "Host's domain name can not be converted to " + (S4.iri ? "Unicode" : "ASCII") + " via punycode: " + de2;
          }
      }
      ae(A3, I), S4.reference !== "suffix" && A3.scheme && (R2.push(A3.scheme), R2.push(":"));
      var J2 = zt(A3, S4);
      if (J2 !== void 0 && (S4.reference !== "suffix" && R2.push("//"), R2.push(J2), A3.path && A3.path.charAt(0) !== "/" && R2.push("/")), A3.path !== void 0) {
        var X = A3.path;
        !S4.absolutePath && (!k || !k.absolutePath) && (X = Ye(X)), J2 === void 0 && (X = X.replace(/^\/\//, "/%2F")), R2.push(X);
      }
      return A3.query !== void 0 && (R2.push("?"), R2.push(A3.query)), A3.fragment !== void 0 && (R2.push("#"), R2.push(A3.fragment)), R2.join("");
    }
    function dr(A3, S4) {
      var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, R2 = arguments[3], k = {};
      return R2 || (A3 = Ue(Ve(A3, I), I), S4 = Ue(Ve(S4, I), I)), I = I || {}, !I.tolerant && S4.scheme ? (k.scheme = S4.scheme, k.userinfo = S4.userinfo, k.host = S4.host, k.port = S4.port, k.path = Ye(S4.path || ""), k.query = S4.query) : (S4.userinfo !== void 0 || S4.host !== void 0 || S4.port !== void 0 ? (k.userinfo = S4.userinfo, k.host = S4.host, k.port = S4.port, k.path = Ye(S4.path || ""), k.query = S4.query) : (S4.path ? (S4.path.charAt(0) === "/" ? k.path = Ye(S4.path) : ((A3.userinfo !== void 0 || A3.host !== void 0 || A3.port !== void 0) && !A3.path ? k.path = "/" + S4.path : A3.path ? k.path = A3.path.slice(0, A3.path.lastIndexOf("/") + 1) + S4.path : k.path = S4.path, k.path = Ye(k.path)), k.query = S4.query) : (k.path = A3.path, S4.query !== void 0 ? k.query = S4.query : k.query = A3.query), k.userinfo = A3.userinfo, k.host = A3.host, k.port = A3.port), k.scheme = A3.scheme), k.fragment = S4.fragment, k;
    }
    function xr(A3, S4, I) {
      var R2 = l({ scheme: "null" }, I);
      return Ve(dr(Ue(A3, R2), Ue(S4, R2), R2, true), R2);
    }
    function Gt(A3, S4) {
      return typeof A3 == "string" ? A3 = Ve(Ue(A3, S4), S4) : a(A3) === "object" && (A3 = Ue(Ve(A3, S4), S4)), A3;
    }
    function Lr(A3, S4, I) {
      return typeof A3 == "string" ? A3 = Ve(Ue(A3, I), I) : a(A3) === "object" && (A3 = Ve(A3, I)), typeof S4 == "string" ? S4 = Ve(Ue(S4, I), I) : a(S4) === "object" && (S4 = Ve(S4, I)), A3 === S4;
    }
    function On(A3, S4) {
      return A3 && A3.toString().replace(!S4 || !S4.iri ? u.ESCAPE : f.ESCAPE, K);
    }
    function Je3(A3, S4) {
      return A3 && A3.toString().replace(!S4 || !S4.iri ? u.PCT_ENCODED : f.PCT_ENCODED, te);
    }
    var Ht = {
      scheme: "http",
      domainHost: true,
      parse: function(S4, I) {
        return S4.host || (S4.error = S4.error || "HTTP URIs must have a host."), S4;
      },
      serialize: function(S4, I) {
        var R2 = String(S4.scheme).toLowerCase() === "https";
        return (S4.port === (R2 ? 443 : 80) || S4.port === "") && (S4.port = void 0), S4.path || (S4.path = "/"), S4;
      }
    }, Ys = {
      scheme: "https",
      domainHost: Ht.domainHost,
      parse: Ht.parse,
      serialize: Ht.serialize
    };
    function Js(A3) {
      return typeof A3.secure == "boolean" ? A3.secure : String(A3.scheme).toLowerCase() === "wss";
    }
    var Br = {
      scheme: "ws",
      domainHost: true,
      parse: function(S4, I) {
        var R2 = S4;
        return R2.secure = Js(R2), R2.resourceName = (R2.path || "/") + (R2.query ? "?" + R2.query : ""), R2.path = void 0, R2.query = void 0, R2;
      },
      serialize: function(S4, I) {
        if ((S4.port === (Js(S4) ? 443 : 80) || S4.port === "") && (S4.port = void 0), typeof S4.secure == "boolean" && (S4.scheme = S4.secure ? "wss" : "ws", S4.secure = void 0), S4.resourceName) {
          var R2 = S4.resourceName.split("?"), k = p(R2, 2), J2 = k[0], X = k[1];
          S4.path = J2 && J2 !== "/" ? J2 : void 0, S4.query = X, S4.resourceName = void 0;
        }
        return S4.fragment = void 0, S4;
      }
    }, Xs = {
      scheme: "wss",
      domainHost: Br.domainHost,
      parse: Br.parse,
      serialize: Br.serialize
    }, _d = {}, Zs = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", ut = "[0-9A-Fa-f]", bd = i(i("%[EFef]" + ut + "%" + ut + ut + "%" + ut + ut) + "|" + i("%[89A-Fa-f]" + ut + "%" + ut + ut) + "|" + i("%" + ut + ut)), Sd = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", wd = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", Ed = n(wd, '[\\"\\\\]'), Od = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", Cd = new RegExp(Zs, "g"), fr = new RegExp(bd, "g"), Ad = new RegExp(n("[^]", Sd, "[\\.]", '[\\"]', Ed), "g"), Qs = new RegExp(n("[^]", Zs, Od), "g"), Pd = Qs;
    function Ii(A3) {
      var S4 = te(A3);
      return S4.match(Cd) ? S4 : A3;
    }
    var eo = {
      scheme: "mailto",
      parse: function(S4, I) {
        var R2 = S4, k = R2.to = R2.path ? R2.path.split(",") : [];
        if (R2.path = void 0, R2.query) {
          for (var J2 = false, X = {}, de2 = R2.query.split("&"), ge2 = 0, Ce = de2.length; ge2 < Ce; ++ge2) {
            var se = de2[ge2].split("=");
            switch (se[0]) {
              case "to":
                for (var ye = se[1].split(","), Ae = 0, Q = ye.length; Ae < Q; ++Ae)
                  k.push(ye[Ae]);
                break;
              case "subject":
                R2.subject = Je3(se[1], I);
                break;
              case "body":
                R2.body = Je3(se[1], I);
                break;
              default:
                J2 = true, X[Je3(se[0], I)] = Je3(se[1], I);
                break;
            }
          }
          J2 && (R2.headers = X);
        }
        R2.query = void 0;
        for (var _e2 = 0, Ie = k.length; _e2 < Ie; ++_e2) {
          var be2 = k[_e2].split("@");
          if (be2[0] = Je3(be2[0]), I.unicodeSupport)
            be2[1] = Je3(be2[1], I).toLowerCase();
          else
            try {
              be2[1] = M.toASCII(Je3(be2[1], I).toLowerCase());
            } catch (Tt) {
              R2.error = R2.error || "Email address's domain name can not be converted to ASCII via punycode: " + Tt;
            }
          k[_e2] = be2.join("@");
        }
        return R2;
      },
      serialize: function(S4, I) {
        var R2 = S4, k = o(S4.to);
        if (k) {
          for (var J2 = 0, X = k.length; J2 < X; ++J2) {
            var de2 = String(k[J2]), ge2 = de2.lastIndexOf("@"), Ce = de2.slice(0, ge2).replace(fr, Ii).replace(fr, s).replace(Ad, K), se = de2.slice(ge2 + 1);
            try {
              se = I.iri ? M.toUnicode(se) : M.toASCII(Je3(se, I).toLowerCase());
            } catch (_e2) {
              R2.error = R2.error || "Email address's domain name can not be converted to " + (I.iri ? "Unicode" : "ASCII") + " via punycode: " + _e2;
            }
            k[J2] = Ce + "@" + se;
          }
          R2.path = k.join(",");
        }
        var ye = S4.headers = S4.headers || {};
        S4.subject && (ye.subject = S4.subject), S4.body && (ye.body = S4.body);
        var Ae = [];
        for (var Q in ye)
          ye[Q] !== _d[Q] && Ae.push(Q.replace(fr, Ii).replace(fr, s).replace(Qs, K) + "=" + ye[Q].replace(fr, Ii).replace(fr, s).replace(Pd, K));
        return Ae.length && (R2.query = Ae.join("&")), R2;
      }
    }, Id = /^([^\:]+)\:(.*)/, to = {
      scheme: "urn",
      parse: function(S4, I) {
        var R2 = S4.path && S4.path.match(Id), k = S4;
        if (R2) {
          var J2 = I.scheme || k.scheme || "urn", X = R2[1].toLowerCase(), de2 = R2[2], ge2 = J2 + ":" + (I.nid || X), Ce = B[ge2];
          k.nid = X, k.nss = de2, k.path = void 0, Ce && (k = Ce.parse(k, I));
        } else
          k.error = k.error || "URN can not be parsed.";
        return k;
      },
      serialize: function(S4, I) {
        var R2 = I.scheme || S4.scheme || "urn", k = S4.nid, J2 = R2 + ":" + (I.nid || k), X = B[J2];
        X && (S4 = X.serialize(S4, I));
        var de2 = S4, ge2 = S4.nss;
        return de2.path = (k || I.nid) + ":" + ge2, de2;
      }
    }, Td = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ro = {
      scheme: "urn:uuid",
      parse: function(S4, I) {
        var R2 = S4;
        return R2.uuid = R2.nss, R2.nss = void 0, !I.tolerant && (!R2.uuid || !R2.uuid.match(Td)) && (R2.error = R2.error || "UUID is not valid."), R2;
      },
      serialize: function(S4, I) {
        var R2 = S4;
        return R2.nss = (S4.uuid || "").toLowerCase(), R2;
      }
    };
    B[Ht.scheme] = Ht, B[Ys.scheme] = Ys, B[Br.scheme] = Br, B[Xs.scheme] = Xs, B[eo.scheme] = eo, B[to.scheme] = to, B[ro.scheme] = ro, r.SCHEMES = B, r.pctEncChar = K, r.pctDecChars = te, r.parse = Ue, r.removeDotSegments = Ye, r.serialize = Ve, r.resolveComponents = dr, r.resolve = xr, r.normalize = Gt, r.equal = Lr, r.escapeComponent = On, r.unescapeComponent = Je3, Object.defineProperty(r, "__esModule", { value: true });
  });
})(ua, ua.exports);
var LO = ua.exports;
Object.defineProperty(ms, "__esModule", { value: true });
var id = LO;
id.code = 'require("ajv/dist/runtime/uri").default';
ms.default = id;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = lt;
  Object.defineProperty(e, "KeywordCxt", { enumerable: true, get: function() {
    return t.KeywordCxt;
  } });
  var r = re2;
  Object.defineProperty(e, "_", { enumerable: true, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: true, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: true, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: true, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: true, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: true, get: function() {
    return r.CodeGen;
  } });
  const n = bn, i = Sn, a = or, s = ze, o = re2, l = Re, c2 = _n, u = fe, f = xO, p = ms, d2 = (V2, N3) => new RegExp(V2, N3);
  d2.code = "new RegExp";
  const m2 = ["removeAdditional", "useDefaults", "coerceTypes"], h2 = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), g = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, y2 = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, v = 200;
  function b(V2) {
    var N3, x3, D, $, P, M, B, K, te, ae, pe, He, rt, qt, Kt, Ue, zt, It, $t, qe, Wt, Ye, Ve, dr, xr;
    const Gt = V2.strict, Lr = (N3 = V2.code) === null || N3 === void 0 ? void 0 : N3.optimize, On = Lr === true || Lr === void 0 ? 1 : Lr || 0, Je3 = (D = (x3 = V2.code) === null || x3 === void 0 ? void 0 : x3.regExp) !== null && D !== void 0 ? D : d2, Ht = ($ = V2.uriResolver) !== null && $ !== void 0 ? $ : p.default;
    return {
      strictSchema: (M = (P = V2.strictSchema) !== null && P !== void 0 ? P : Gt) !== null && M !== void 0 ? M : true,
      strictNumbers: (K = (B = V2.strictNumbers) !== null && B !== void 0 ? B : Gt) !== null && K !== void 0 ? K : true,
      strictTypes: (ae = (te = V2.strictTypes) !== null && te !== void 0 ? te : Gt) !== null && ae !== void 0 ? ae : "log",
      strictTuples: (He = (pe = V2.strictTuples) !== null && pe !== void 0 ? pe : Gt) !== null && He !== void 0 ? He : "log",
      strictRequired: (qt = (rt = V2.strictRequired) !== null && rt !== void 0 ? rt : Gt) !== null && qt !== void 0 ? qt : false,
      code: V2.code ? { ...V2.code, optimize: On, regExp: Je3 } : { optimize: On, regExp: Je3 },
      loopRequired: (Kt = V2.loopRequired) !== null && Kt !== void 0 ? Kt : v,
      loopEnum: (Ue = V2.loopEnum) !== null && Ue !== void 0 ? Ue : v,
      meta: (zt = V2.meta) !== null && zt !== void 0 ? zt : true,
      messages: (It = V2.messages) !== null && It !== void 0 ? It : true,
      inlineRefs: ($t = V2.inlineRefs) !== null && $t !== void 0 ? $t : true,
      schemaId: (qe = V2.schemaId) !== null && qe !== void 0 ? qe : "$id",
      addUsedSchema: (Wt = V2.addUsedSchema) !== null && Wt !== void 0 ? Wt : true,
      validateSchema: (Ye = V2.validateSchema) !== null && Ye !== void 0 ? Ye : true,
      validateFormats: (Ve = V2.validateFormats) !== null && Ve !== void 0 ? Ve : true,
      unicodeRegExp: (dr = V2.unicodeRegExp) !== null && dr !== void 0 ? dr : true,
      int32range: (xr = V2.int32range) !== null && xr !== void 0 ? xr : true,
      uriResolver: Ht
    };
  }
  class w {
    constructor(N3 = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), N3 = this.opts = { ...N3, ...b(N3) };
      const { es5: x3, lines: D } = this.opts.code;
      this.scope = new o.ValueScope({ scope: {}, prefixes: h2, es5: x3, lines: D }), this.logger = U(N3.logger);
      const $ = N3.validateFormats;
      N3.validateFormats = false, this.RULES = (0, a.getRules)(), C.call(this, g, N3, "NOT SUPPORTED"), C.call(this, y2, N3, "DEPRECATED", "warn"), this._metaOpts = j2.call(this), N3.formats && T.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), N3.keywords && F.call(this, N3.keywords), typeof N3.meta == "object" && this.addMetaSchema(N3.meta), _3.call(this), N3.validateFormats = $;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: N3, meta: x3, schemaId: D } = this.opts;
      let $ = f;
      D === "id" && ($ = { ...f }, $.id = $.$id, delete $.$id), x3 && N3 && this.addMetaSchema($, $[D], false);
    }
    defaultMeta() {
      const { meta: N3, schemaId: x3 } = this.opts;
      return this.opts.defaultMeta = typeof N3 == "object" ? N3[x3] || N3 : void 0;
    }
    validate(N3, x3) {
      let D;
      if (typeof N3 == "string") {
        if (D = this.getSchema(N3), !D)
          throw new Error(`no schema with key or ref "${N3}"`);
      } else
        D = this.compile(N3);
      const $ = D(x3);
      return "$async" in D || (this.errors = D.errors), $;
    }
    compile(N3, x3) {
      const D = this._addSchema(N3, x3);
      return D.validate || this._compileSchemaEnv(D);
    }
    compileAsync(N3, x3) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: D } = this.opts;
      return $.call(this, N3, x3);
      async function $(ae, pe) {
        await P.call(this, ae.$schema);
        const He = this._addSchema(ae, pe);
        return He.validate || M.call(this, He);
      }
      async function P(ae) {
        ae && !this.getSchema(ae) && await $.call(this, { $ref: ae }, true);
      }
      async function M(ae) {
        try {
          return this._compileSchemaEnv(ae);
        } catch (pe) {
          if (!(pe instanceof i.default))
            throw pe;
          return B.call(this, pe), await K.call(this, pe.missingSchema), M.call(this, ae);
        }
      }
      function B({ missingSchema: ae, missingRef: pe }) {
        if (this.refs[ae])
          throw new Error(`AnySchema ${ae} is loaded but ${pe} cannot be resolved`);
      }
      async function K(ae) {
        const pe = await te.call(this, ae);
        this.refs[ae] || await P.call(this, pe.$schema), this.refs[ae] || this.addSchema(pe, ae, x3);
      }
      async function te(ae) {
        const pe = this._loading[ae];
        if (pe)
          return pe;
        try {
          return await (this._loading[ae] = D(ae));
        } finally {
          delete this._loading[ae];
        }
      }
    }
    // Adds schema to the instance
    addSchema(N3, x3, D, $ = this.opts.validateSchema) {
      if (Array.isArray(N3)) {
        for (const M of N3)
          this.addSchema(M, void 0, D, $);
        return this;
      }
      let P;
      if (typeof N3 == "object") {
        const { schemaId: M } = this.opts;
        if (P = N3[M], P !== void 0 && typeof P != "string")
          throw new Error(`schema ${M} must be string`);
      }
      return x3 = (0, l.normalizeId)(x3 || P), this._checkUnique(x3), this.schemas[x3] = this._addSchema(N3, D, x3, $, true), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(N3, x3, D = this.opts.validateSchema) {
      return this.addSchema(N3, x3, true, D), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(N3, x3) {
      if (typeof N3 == "boolean")
        return true;
      let D;
      if (D = N3.$schema, D !== void 0 && typeof D != "string")
        throw new Error("$schema must be a string");
      if (D = D || this.opts.defaultMeta || this.defaultMeta(), !D)
        return this.logger.warn("meta-schema not available"), this.errors = null, true;
      const $ = this.validate(D, N3);
      if (!$ && x3) {
        const P = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(P);
        else
          throw new Error(P);
      }
      return $;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(N3) {
      let x3;
      for (; typeof (x3 = E2.call(this, N3)) == "string"; )
        N3 = x3;
      if (x3 === void 0) {
        const { schemaId: D } = this.opts, $ = new s.SchemaEnv({ schema: {}, schemaId: D });
        if (x3 = s.resolveSchema.call(this, $, N3), !x3)
          return;
        this.refs[N3] = x3;
      }
      return x3.validate || this._compileSchemaEnv(x3);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(N3) {
      if (N3 instanceof RegExp)
        return this._removeAllSchemas(this.schemas, N3), this._removeAllSchemas(this.refs, N3), this;
      switch (typeof N3) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const x3 = E2.call(this, N3);
          return typeof x3 == "object" && this._cache.delete(x3.schema), delete this.schemas[N3], delete this.refs[N3], this;
        }
        case "object": {
          const x3 = N3;
          this._cache.delete(x3);
          let D = N3[this.opts.schemaId];
          return D && (D = (0, l.normalizeId)(D), delete this.schemas[D], delete this.refs[D]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(N3) {
      for (const x3 of N3)
        this.addKeyword(x3);
      return this;
    }
    addKeyword(N3, x3) {
      let D;
      if (typeof N3 == "string")
        D = N3, typeof x3 == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), x3.keyword = D);
      else if (typeof N3 == "object" && x3 === void 0) {
        if (x3 = N3, D = x3.keyword, Array.isArray(D) && !D.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (z2.call(this, D, x3), !x3)
        return (0, u.eachItem)(D, (P) => q3.call(this, P)), this;
      me.call(this, x3);
      const $ = {
        ...x3,
        type: (0, c2.getJSONTypes)(x3.type),
        schemaType: (0, c2.getJSONTypes)(x3.schemaType)
      };
      return (0, u.eachItem)(D, $.type.length === 0 ? (P) => q3.call(this, P, $) : (P) => $.type.forEach((M) => q3.call(this, P, $, M))), this;
    }
    getKeyword(N3) {
      const x3 = this.RULES.all[N3];
      return typeof x3 == "object" ? x3.definition : !!x3;
    }
    // Remove keyword
    removeKeyword(N3) {
      const { RULES: x3 } = this;
      delete x3.keywords[N3], delete x3.all[N3];
      for (const D of x3.rules) {
        const $ = D.rules.findIndex((P) => P.keyword === N3);
        $ >= 0 && D.rules.splice($, 1);
      }
      return this;
    }
    // Add format
    addFormat(N3, x3) {
      return typeof x3 == "string" && (x3 = new RegExp(x3)), this.formats[N3] = x3, this;
    }
    errorsText(N3 = this.errors, { separator: x3 = ", ", dataVar: D = "data" } = {}) {
      return !N3 || N3.length === 0 ? "No errors" : N3.map(($) => `${D}${$.instancePath} ${$.message}`).reduce(($, P) => $ + x3 + P);
    }
    $dataMetaSchema(N3, x3) {
      const D = this.RULES.all;
      N3 = JSON.parse(JSON.stringify(N3));
      for (const $ of x3) {
        const P = $.split("/").slice(1);
        let M = N3;
        for (const B of P)
          M = M[B];
        for (const B in D) {
          const K = D[B];
          if (typeof K != "object")
            continue;
          const { $data: te } = K.definition, ae = M[B];
          te && ae && (M[B] = Y2(ae));
        }
      }
      return N3;
    }
    _removeAllSchemas(N3, x3) {
      for (const D in N3) {
        const $ = N3[D];
        (!x3 || x3.test(D)) && (typeof $ == "string" ? delete N3[D] : $ && !$.meta && (this._cache.delete($.schema), delete N3[D]));
      }
    }
    _addSchema(N3, x3, D, $ = this.opts.validateSchema, P = this.opts.addUsedSchema) {
      let M;
      const { schemaId: B } = this.opts;
      if (typeof N3 == "object")
        M = N3[B];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof N3 != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let K = this._cache.get(N3);
      if (K !== void 0)
        return K;
      D = (0, l.normalizeId)(M || D);
      const te = l.getSchemaRefs.call(this, N3, D);
      return K = new s.SchemaEnv({ schema: N3, schemaId: B, meta: x3, baseId: D, localRefs: te }), this._cache.set(K.schema, K), P && !D.startsWith("#") && (D && this._checkUnique(D), this.refs[D] = K), $ && this.validateSchema(N3, true), K;
    }
    _checkUnique(N3) {
      if (this.schemas[N3] || this.refs[N3])
        throw new Error(`schema with key or id "${N3}" already exists`);
    }
    _compileSchemaEnv(N3) {
      if (N3.meta ? this._compileMetaSchema(N3) : s.compileSchema.call(this, N3), !N3.validate)
        throw new Error("ajv implementation error");
      return N3.validate;
    }
    _compileMetaSchema(N3) {
      const x3 = this.opts;
      this.opts = this._metaOpts;
      try {
        s.compileSchema.call(this, N3);
      } finally {
        this.opts = x3;
      }
    }
  }
  e.default = w, w.ValidationError = n.default, w.MissingRefError = i.default;
  function C(V2, N3, x3, D = "error") {
    for (const $ in V2) {
      const P = $;
      P in N3 && this.logger[D](`${x3}: option ${$}. ${V2[P]}`);
    }
  }
  function E2(V2) {
    return V2 = (0, l.normalizeId)(V2), this.schemas[V2] || this.refs[V2];
  }
  function _3() {
    const V2 = this.opts.schemas;
    if (V2)
      if (Array.isArray(V2))
        this.addSchema(V2);
      else
        for (const N3 in V2)
          this.addSchema(V2[N3], N3);
  }
  function T() {
    for (const V2 in this.opts.formats) {
      const N3 = this.opts.formats[V2];
      N3 && this.addFormat(V2, N3);
    }
  }
  function F(V2) {
    if (Array.isArray(V2)) {
      this.addVocabulary(V2);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const N3 in V2) {
      const x3 = V2[N3];
      x3.keyword || (x3.keyword = N3), this.addKeyword(x3);
    }
  }
  function j2() {
    const V2 = { ...this.opts };
    for (const N3 of m2)
      delete V2[N3];
    return V2;
  }
  const L = { log() {
  }, warn() {
  }, error() {
  } };
  function U(V2) {
    if (V2 === false)
      return L;
    if (V2 === void 0)
      return console;
    if (V2.log && V2.warn && V2.error)
      return V2;
    throw new Error("logger must implement log, warn and error methods");
  }
  const W = /^[a-z_$][a-z0-9_$:-]*$/i;
  function z2(V2, N3) {
    const { RULES: x3 } = this;
    if ((0, u.eachItem)(V2, (D) => {
      if (x3.keywords[D])
        throw new Error(`Keyword ${D} is already defined`);
      if (!W.test(D))
        throw new Error(`Keyword ${D} has invalid name`);
    }), !!N3 && N3.$data && !("code" in N3 || "validate" in N3))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function q3(V2, N3, x3) {
    var D;
    const $ = N3 == null ? void 0 : N3.post;
    if (x3 && $)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: P } = this;
    let M = $ ? P.post : P.rules.find(({ type: K }) => K === x3);
    if (M || (M = { type: x3, rules: [] }, P.rules.push(M)), P.keywords[V2] = true, !N3)
      return;
    const B = {
      keyword: V2,
      definition: {
        ...N3,
        type: (0, c2.getJSONTypes)(N3.type),
        schemaType: (0, c2.getJSONTypes)(N3.schemaType)
      }
    };
    N3.before ? ue.call(this, M, B, N3.before) : M.rules.push(B), P.all[V2] = B, (D = N3.implements) === null || D === void 0 || D.forEach((K) => this.addKeyword(K));
  }
  function ue(V2, N3, x3) {
    const D = V2.rules.findIndex(($) => $.keyword === x3);
    D >= 0 ? V2.rules.splice(D, 0, N3) : (V2.rules.push(N3), this.logger.warn(`rule ${x3} is not defined`));
  }
  function me(V2) {
    let { metaSchema: N3 } = V2;
    N3 !== void 0 && (V2.$data && this.opts.$data && (N3 = Y2(N3)), V2.validateSchema = this.compile(N3, true));
  }
  const ie2 = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function Y2(V2) {
    return { anyOf: [V2, ie2] };
  }
})(ku);
var ps = {};
var ys = {};
var gs = {};
Object.defineProperty(gs, "__esModule", { value: true });
var BO = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
gs.default = BO;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: true });
lr.callRef = lr.getValidate = void 0;
var qO = Sn;
var fl2 = ne;
var Ke = re2;
var vr = vt;
var hl = ze;
var Rn = fe;
var KO = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: i, schemaEnv: a, validateName: s, opts: o, self: l } = n, { root: c2 } = a;
    if ((r === "#" || r === "#/") && i === c2.baseId)
      return f();
    const u = hl.resolveRef.call(l, c2, i, r);
    if (u === void 0)
      throw new qO.default(n.opts.uriResolver, i, r);
    if (u instanceof hl.SchemaEnv)
      return p(u);
    return d2(u);
    function f() {
      if (a === c2)
        return Yn(e, s, a, a.$async);
      const m2 = t.scopeValue("root", { ref: c2 });
      return Yn(e, (0, Ke._)`${m2}.validate`, c2, c2.$async);
    }
    function p(m2) {
      const h2 = ad(e, m2);
      Yn(e, h2, m2, m2.$async);
    }
    function d2(m2) {
      const h2 = t.scopeValue("schema", o.code.source === true ? { ref: m2, code: (0, Ke.stringify)(m2) } : { ref: m2 }), g = t.name("valid"), y2 = e.subschema({
        schema: m2,
        dataTypes: [],
        schemaPath: Ke.nil,
        topSchemaRef: h2,
        errSchemaPath: r
      }, g);
      e.mergeEvaluated(y2), e.ok(g);
    }
  }
};
function ad(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Ke._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
lr.getValidate = ad;
function Yn(e, t, r, n) {
  const { gen: i, it: a } = e, { allErrors: s, schemaEnv: o, opts: l } = a, c2 = l.passContext ? vr.default.this : Ke.nil;
  n ? u() : f();
  function u() {
    if (!o.$async)
      throw new Error("async schema referenced by sync schema");
    const m2 = i.let("valid");
    i.try(() => {
      i.code((0, Ke._)`await ${(0, fl2.callValidateCode)(e, t, c2)}`), d2(t), s || i.assign(m2, true);
    }, (h2) => {
      i.if((0, Ke._)`!(${h2} instanceof ${a.ValidationError})`, () => i.throw(h2)), p(h2), s || i.assign(m2, false);
    }), e.ok(m2);
  }
  function f() {
    e.result((0, fl2.callValidateCode)(e, t, c2), () => d2(t), () => p(t));
  }
  function p(m2) {
    const h2 = (0, Ke._)`${m2}.errors`;
    i.assign(vr.default.vErrors, (0, Ke._)`${vr.default.vErrors} === null ? ${h2} : ${vr.default.vErrors}.concat(${h2})`), i.assign(vr.default.errors, (0, Ke._)`${vr.default.vErrors}.length`);
  }
  function d2(m2) {
    var h2;
    if (!a.opts.unevaluated)
      return;
    const g = (h2 = r == null ? void 0 : r.validate) === null || h2 === void 0 ? void 0 : h2.evaluated;
    if (a.props !== true)
      if (g && !g.dynamicProps)
        g.props !== void 0 && (a.props = Rn.mergeEvaluated.props(i, g.props, a.props));
      else {
        const y2 = i.var("props", (0, Ke._)`${m2}.evaluated.props`);
        a.props = Rn.mergeEvaluated.props(i, y2, a.props, Ke.Name);
      }
    if (a.items !== true)
      if (g && !g.dynamicItems)
        g.items !== void 0 && (a.items = Rn.mergeEvaluated.items(i, g.items, a.items));
      else {
        const y2 = i.var("items", (0, Ke._)`${m2}.evaluated.items`);
        a.items = Rn.mergeEvaluated.items(i, y2, a.items, Ke.Name);
      }
  }
}
lr.callRef = Yn;
lr.default = KO;
Object.defineProperty(ys, "__esModule", { value: true });
var zO = gs;
var WO = lr;
var GO = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  zO.default,
  WO.default
];
ys.default = GO;
var vs2 = {};
var $s2 = {};
Object.defineProperty($s2, "__esModule", { value: true });
var oi = re2;
var kt = oi.operators;
var li = {
  maximum: { okStr: "<=", ok: kt.LTE, fail: kt.GT },
  minimum: { okStr: ">=", ok: kt.GTE, fail: kt.LT },
  exclusiveMaximum: { okStr: "<", ok: kt.LT, fail: kt.GTE },
  exclusiveMinimum: { okStr: ">", ok: kt.GT, fail: kt.LTE }
};
var HO = {
  message: ({ keyword: e, schemaCode: t }) => (0, oi.str)`must be ${li[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, oi._)`{comparison: ${li[e].okStr}, limit: ${t}}`
};
var YO = {
  keyword: Object.keys(li),
  type: "number",
  schemaType: "number",
  $data: true,
  error: HO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, oi._)`${r} ${li[t].fail} ${n} || isNaN(${r})`);
  }
};
$s2.default = YO;
var _s = {};
Object.defineProperty(_s, "__esModule", { value: true });
var Zr = re2;
var JO = {
  message: ({ schemaCode: e }) => (0, Zr.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, Zr._)`{multipleOf: ${e}}`
};
var XO = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: true,
  error: JO,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: i } = e, a = i.opts.multipleOfPrecision, s = t.let("res"), o = a ? (0, Zr._)`Math.abs(Math.round(${s}) - ${s}) > 1e-${a}` : (0, Zr._)`${s} !== parseInt(${s})`;
    e.fail$data((0, Zr._)`(${n} === 0 || (${s} = ${r}/${n}, ${o}))`);
  }
};
_s.default = XO;
var bs = {};
var Ss = {};
Object.defineProperty(Ss, "__esModule", { value: true });
function sd(e) {
  const t = e.length;
  let r = 0, n = 0, i;
  for (; n < t; )
    r++, i = e.charCodeAt(n++), i >= 55296 && i <= 56319 && n < t && (i = e.charCodeAt(n), (i & 64512) === 56320 && n++);
  return r;
}
Ss.default = sd;
sd.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(bs, "__esModule", { value: true });
var tr = re2;
var ZO = fe;
var QO = Ss;
var eC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, tr.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, tr._)`{limit: ${e}}`
};
var tC = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: true,
  error: eC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: i } = e, a = t === "maxLength" ? tr.operators.GT : tr.operators.LT, s = i.opts.unicode === false ? (0, tr._)`${r}.length` : (0, tr._)`${(0, ZO.useFunc)(e.gen, QO.default)}(${r})`;
    e.fail$data((0, tr._)`${s} ${a} ${n}`);
  }
};
bs.default = tC;
var ws2 = {};
Object.defineProperty(ws2, "__esModule", { value: true });
var rC = ne;
var ci = re2;
var nC = {
  message: ({ schemaCode: e }) => (0, ci.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, ci._)`{pattern: ${e}}`
};
var iC = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: true,
  error: nC,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: i, it: a } = e, s = a.opts.unicodeRegExp ? "u" : "", o = r ? (0, ci._)`(new RegExp(${i}, ${s}))` : (0, rC.usePattern)(e, n);
    e.fail$data((0, ci._)`!${o}.test(${t})`);
  }
};
ws2.default = iC;
var Es = {};
Object.defineProperty(Es, "__esModule", { value: true });
var Qr = re2;
var aC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Qr.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Qr._)`{limit: ${e}}`
};
var sC = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: true,
  error: aC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxProperties" ? Qr.operators.GT : Qr.operators.LT;
    e.fail$data((0, Qr._)`Object.keys(${r}).length ${i} ${n}`);
  }
};
Es.default = sC;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: true });
var Yr = ne;
var en = re2;
var oC = fe;
var lC = {
  message: ({ params: { missingProperty: e } }) => (0, en.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, en._)`{missingProperty: ${e}}`
};
var cC = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: true,
  error: lC,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: i, $data: a, it: s } = e, { opts: o } = s;
    if (!a && r.length === 0)
      return;
    const l = r.length >= o.loopRequired;
    if (s.allErrors ? c2() : u(), o.strictRequired) {
      const d2 = e.parentSchema.properties, { definedProperties: m2 } = e.it;
      for (const h2 of r)
        if ((d2 == null ? void 0 : d2[h2]) === void 0 && !m2.has(h2)) {
          const g = s.schemaEnv.baseId + s.errSchemaPath, y2 = `required property "${h2}" is not defined at "${g}" (strictRequired)`;
          (0, oC.checkStrictMode)(s, y2, s.opts.strictRequired);
        }
    }
    function c2() {
      if (l || a)
        e.block$data(en.nil, f);
      else
        for (const d2 of r)
          (0, Yr.checkReportMissingProp)(e, d2);
    }
    function u() {
      const d2 = t.let("missing");
      if (l || a) {
        const m2 = t.let("valid", true);
        e.block$data(m2, () => p(d2, m2)), e.ok(m2);
      } else
        t.if((0, Yr.checkMissingProp)(e, r, d2)), (0, Yr.reportMissingProp)(e, d2), t.else();
    }
    function f() {
      t.forOf("prop", n, (d2) => {
        e.setParams({ missingProperty: d2 }), t.if((0, Yr.noPropertyInData)(t, i, d2, o.ownProperties), () => e.error());
      });
    }
    function p(d2, m2) {
      e.setParams({ missingProperty: d2 }), t.forOf(d2, n, () => {
        t.assign(m2, (0, Yr.propertyInData)(t, i, d2, o.ownProperties)), t.if((0, en.not)(m2), () => {
          e.error(), t.break();
        });
      }, en.nil);
    }
  }
};
Os.default = cC;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: true });
var tn = re2;
var uC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, tn.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, tn._)`{limit: ${e}}`
};
var dC = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: true,
  error: uC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxItems" ? tn.operators.GT : tn.operators.LT;
    e.fail$data((0, tn._)`${r}.length ${i} ${n}`);
  }
};
Cs.default = dC;
var As2 = {};
var wn = {};
Object.defineProperty(wn, "__esModule", { value: true });
var od = r2r;
od.code = 'require("ajv/dist/runtime/equal").default';
wn.default = od;
Object.defineProperty(As2, "__esModule", { value: true });
var Gi = _n;
var ke = re2;
var fC = fe;
var hC = wn;
var mC = {
  message: ({ params: { i: e, j: t } }) => (0, ke.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, ke._)`{i: ${e}, j: ${t}}`
};
var pC = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error: mC,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, parentSchema: a, schemaCode: s, it: o } = e;
    if (!n && !i)
      return;
    const l = t.let("valid"), c2 = a.items ? (0, Gi.getSchemaTypes)(a.items) : [];
    e.block$data(l, u, (0, ke._)`${s} === false`), e.ok(l);
    function u() {
      const m2 = t.let("i", (0, ke._)`${r}.length`), h2 = t.let("j");
      e.setParams({ i: m2, j: h2 }), t.assign(l, true), t.if((0, ke._)`${m2} > 1`, () => (f() ? p : d2)(m2, h2));
    }
    function f() {
      return c2.length > 0 && !c2.some((m2) => m2 === "object" || m2 === "array");
    }
    function p(m2, h2) {
      const g = t.name("item"), y2 = (0, Gi.checkDataTypes)(c2, g, o.opts.strictNumbers, Gi.DataType.Wrong), v = t.const("indices", (0, ke._)`{}`);
      t.for((0, ke._)`;${m2}--;`, () => {
        t.let(g, (0, ke._)`${r}[${m2}]`), t.if(y2, (0, ke._)`continue`), c2.length > 1 && t.if((0, ke._)`typeof ${g} == "string"`, (0, ke._)`${g} += "_"`), t.if((0, ke._)`typeof ${v}[${g}] == "number"`, () => {
          t.assign(h2, (0, ke._)`${v}[${g}]`), e.error(), t.assign(l, false).break();
        }).code((0, ke._)`${v}[${g}] = ${m2}`);
      });
    }
    function d2(m2, h2) {
      const g = (0, fC.useFunc)(t, hC.default), y2 = t.name("outer");
      t.label(y2).for((0, ke._)`;${m2}--;`, () => t.for((0, ke._)`${h2} = ${m2}; ${h2}--;`, () => t.if((0, ke._)`${g}(${r}[${m2}], ${r}[${h2}])`, () => {
        e.error(), t.assign(l, false).break(y2);
      })));
    }
  }
};
As2.default = pC;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: true });
var da = re2;
var yC = fe;
var gC = wn;
var vC = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, da._)`{allowedValue: ${e}}`
};
var $C = {
  keyword: "const",
  $data: true,
  error: vC,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: i, schema: a } = e;
    n || a && typeof a == "object" ? e.fail$data((0, da._)`!${(0, yC.useFunc)(t, gC.default)}(${r}, ${i})`) : e.fail((0, da._)`${a} !== ${r}`);
  }
};
Ps.default = $C;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: true });
var Jr = re2;
var _C = fe;
var bC = wn;
var SC = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Jr._)`{allowedValues: ${e}}`
};
var wC = {
  keyword: "enum",
  schemaType: "array",
  $data: true,
  error: SC,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, schemaCode: a, it: s } = e;
    if (!n && i.length === 0)
      throw new Error("enum must have non-empty array");
    const o = i.length >= s.opts.loopEnum;
    let l;
    const c2 = () => l ?? (l = (0, _C.useFunc)(t, bC.default));
    let u;
    if (o || n)
      u = t.let("valid"), e.block$data(u, f);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const d2 = t.const("vSchema", a);
      u = (0, Jr.or)(...i.map((m2, h2) => p(d2, h2)));
    }
    e.pass(u);
    function f() {
      t.assign(u, false), t.forOf("v", a, (d2) => t.if((0, Jr._)`${c2()}(${r}, ${d2})`, () => t.assign(u, true).break()));
    }
    function p(d2, m2) {
      const h2 = i[m2];
      return typeof h2 == "object" && h2 !== null ? (0, Jr._)`${c2()}(${r}, ${d2}[${m2}])` : (0, Jr._)`${r} === ${h2}`;
    }
  }
};
Is.default = wC;
Object.defineProperty(vs2, "__esModule", { value: true });
var EC = $s2;
var OC = _s;
var CC = bs;
var AC = ws2;
var PC = Es;
var IC = Os;
var TC = Cs;
var NC = As2;
var DC = Ps;
var FC = Is;
var kC = [
  // number
  EC.default,
  OC.default,
  // string
  CC.default,
  AC.default,
  // object
  PC.default,
  IC.default,
  // array
  TC.default,
  NC.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  DC.default,
  FC.default
];
vs2.default = kC;
var Ts = {};
var Ur = {};
Object.defineProperty(Ur, "__esModule", { value: true });
Ur.validateAdditionalItems = void 0;
var rr = re2;
var fa2 = fe;
var RC = {
  message: ({ params: { len: e } }) => (0, rr.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, rr._)`{limit: ${e}}`
};
var MC = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: RC,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, fa2.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    ld(e, n);
  }
};
function ld(e, t) {
  const { gen: r, schema: n, data: i, keyword: a, it: s } = e;
  s.items = true;
  const o = r.const("len", (0, rr._)`${i}.length`);
  if (n === false)
    e.setParams({ len: t.length }), e.pass((0, rr._)`${o} <= ${t.length}`);
  else if (typeof n == "object" && !(0, fa2.alwaysValidSchema)(s, n)) {
    const c2 = r.var("valid", (0, rr._)`${o} <= ${t.length}`);
    r.if((0, rr.not)(c2), () => l(c2)), e.ok(c2);
  }
  function l(c2) {
    r.forRange("i", t.length, o, (u) => {
      e.subschema({ keyword: a, dataProp: u, dataPropType: fa2.Type.Num }, c2), s.allErrors || r.if((0, rr.not)(c2), () => r.break());
    });
  }
}
Ur.validateAdditionalItems = ld;
Ur.default = MC;
var Ns = {};
var Vr3 = {};
Object.defineProperty(Vr3, "__esModule", { value: true });
Vr3.validateTuple = void 0;
var ml = re2;
var Jn = fe;
var jC = ne;
var UC = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return cd(e, "additionalItems", t);
    r.items = true, !(0, Jn.alwaysValidSchema)(r, t) && e.ok((0, jC.validateArray)(e));
  }
};
function cd(e, t, r = e.schema) {
  const { gen: n, parentSchema: i, data: a, keyword: s, it: o } = e;
  u(i), o.opts.unevaluated && r.length && o.items !== true && (o.items = Jn.mergeEvaluated.items(n, r.length, o.items));
  const l = n.name("valid"), c2 = n.const("len", (0, ml._)`${a}.length`);
  r.forEach((f, p) => {
    (0, Jn.alwaysValidSchema)(o, f) || (n.if((0, ml._)`${c2} > ${p}`, () => e.subschema({
      keyword: s,
      schemaProp: p,
      dataProp: p
    }, l)), e.ok(l));
  });
  function u(f) {
    const { opts: p, errSchemaPath: d2 } = o, m2 = r.length, h2 = m2 === f.minItems && (m2 === f.maxItems || f[t] === false);
    if (p.strictTuples && !h2) {
      const g = `"${s}" is ${m2}-tuple, but minItems or maxItems/${t} are not specified or different at path "${d2}"`;
      (0, Jn.checkStrictMode)(o, g, p.strictTuples);
    }
  }
}
Vr3.validateTuple = cd;
Vr3.default = UC;
Object.defineProperty(Ns, "__esModule", { value: true });
var VC = Vr3;
var xC = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, VC.validateTuple)(e, "items")
};
Ns.default = xC;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: true });
var pl = re2;
var LC = fe;
var BC = ne;
var qC = Ur;
var KC = {
  message: ({ params: { len: e } }) => (0, pl.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, pl._)`{limit: ${e}}`
};
var zC = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: KC,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: i } = r;
    n.items = true, !(0, LC.alwaysValidSchema)(n, t) && (i ? (0, qC.validateAdditionalItems)(e, i) : e.ok((0, BC.validateArray)(e)));
  }
};
Ds.default = zC;
var Fs = {};
Object.defineProperty(Fs, "__esModule", { value: true });
var Ze = re2;
var Mn = fe;
var WC = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ze.str)`must contain at least ${e} valid item(s)` : (0, Ze.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ze._)`{minContains: ${e}}` : (0, Ze._)`{minContains: ${e}, maxContains: ${t}}`
};
var GC = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error: WC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: a } = e;
    let s, o;
    const { minContains: l, maxContains: c2 } = n;
    a.opts.next ? (s = l === void 0 ? 1 : l, o = c2) : s = 1;
    const u = t.const("len", (0, Ze._)`${i}.length`);
    if (e.setParams({ min: s, max: o }), o === void 0 && s === 0) {
      (0, Mn.checkStrictMode)(a, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (o !== void 0 && s > o) {
      (0, Mn.checkStrictMode)(a, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, Mn.alwaysValidSchema)(a, r)) {
      let h2 = (0, Ze._)`${u} >= ${s}`;
      o !== void 0 && (h2 = (0, Ze._)`${h2} && ${u} <= ${o}`), e.pass(h2);
      return;
    }
    a.items = true;
    const f = t.name("valid");
    o === void 0 && s === 1 ? d2(f, () => t.if(f, () => t.break())) : s === 0 ? (t.let(f, true), o !== void 0 && t.if((0, Ze._)`${i}.length > 0`, p)) : (t.let(f, false), p()), e.result(f, () => e.reset());
    function p() {
      const h2 = t.name("_valid"), g = t.let("count", 0);
      d2(h2, () => t.if(h2, () => m2(g)));
    }
    function d2(h2, g) {
      t.forRange("i", 0, u, (y2) => {
        e.subschema({
          keyword: "contains",
          dataProp: y2,
          dataPropType: Mn.Type.Num,
          compositeRule: true
        }, h2), g();
      });
    }
    function m2(h2) {
      t.code((0, Ze._)`${h2}++`), o === void 0 ? t.if((0, Ze._)`${h2} >= ${s}`, () => t.assign(f, true).break()) : (t.if((0, Ze._)`${h2} > ${o}`, () => t.assign(f, false).break()), s === 1 ? t.assign(f, true) : t.if((0, Ze._)`${h2} >= ${s}`, () => t.assign(f, true)));
    }
  }
};
Fs.default = GC;
var ud = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = re2, r = fe, n = ne;
  e.error = {
    message: ({ params: { property: l, depsCount: c2, deps: u } }) => {
      const f = c2 === 1 ? "property" : "properties";
      return (0, t.str)`must have ${f} ${u} when property ${l} is present`;
    },
    params: ({ params: { property: l, depsCount: c2, deps: u, missingProperty: f } }) => (0, t._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${c2},
    deps: ${u}}`
    // TODO change to reference
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(l) {
      const [c2, u] = a(l);
      s(l, c2), o(l, u);
    }
  };
  function a({ schema: l }) {
    const c2 = {}, u = {};
    for (const f in l) {
      if (f === "__proto__")
        continue;
      const p = Array.isArray(l[f]) ? c2 : u;
      p[f] = l[f];
    }
    return [c2, u];
  }
  function s(l, c2 = l.schema) {
    const { gen: u, data: f, it: p } = l;
    if (Object.keys(c2).length === 0)
      return;
    const d2 = u.let("missing");
    for (const m2 in c2) {
      const h2 = c2[m2];
      if (h2.length === 0)
        continue;
      const g = (0, n.propertyInData)(u, f, m2, p.opts.ownProperties);
      l.setParams({
        property: m2,
        depsCount: h2.length,
        deps: h2.join(", ")
      }), p.allErrors ? u.if(g, () => {
        for (const y2 of h2)
          (0, n.checkReportMissingProp)(l, y2);
      }) : (u.if((0, t._)`${g} && (${(0, n.checkMissingProp)(l, h2, d2)})`), (0, n.reportMissingProp)(l, d2), u.else());
    }
  }
  e.validatePropertyDeps = s;
  function o(l, c2 = l.schema) {
    const { gen: u, data: f, keyword: p, it: d2 } = l, m2 = u.name("valid");
    for (const h2 in c2)
      (0, r.alwaysValidSchema)(d2, c2[h2]) || (u.if(
        (0, n.propertyInData)(u, f, h2, d2.opts.ownProperties),
        () => {
          const g = l.subschema({ keyword: p, schemaProp: h2 }, m2);
          l.mergeValidEvaluated(g, m2);
        },
        () => u.var(m2, true)
        // TODO var
      ), l.ok(m2));
  }
  e.validateSchemaDeps = o, e.default = i;
})(ud);
var ks = {};
Object.defineProperty(ks, "__esModule", { value: true });
var dd = re2;
var HC = fe;
var YC = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, dd._)`{propertyName: ${e.propertyName}}`
};
var JC = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: YC,
  code(e) {
    const { gen: t, schema: r, data: n, it: i } = e;
    if ((0, HC.alwaysValidSchema)(i, r))
      return;
    const a = t.name("valid");
    t.forIn("key", n, (s) => {
      e.setParams({ propertyName: s }), e.subschema({
        keyword: "propertyNames",
        data: s,
        dataTypes: ["string"],
        propertyName: s,
        compositeRule: true
      }, a), t.if((0, dd.not)(a), () => {
        e.error(true), i.allErrors || t.break();
      });
    }), e.ok(a);
  }
};
ks.default = JC;
var Pi = {};
Object.defineProperty(Pi, "__esModule", { value: true });
var jn = ne;
var it = re2;
var XC = vt;
var Un = fe;
var ZC = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, it._)`{additionalProperty: ${e.additionalProperty}}`
};
var QC = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: true,
  trackErrors: true,
  error: ZC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, errsCount: a, it: s } = e;
    if (!a)
      throw new Error("ajv implementation error");
    const { allErrors: o, opts: l } = s;
    if (s.props = true, l.removeAdditional !== "all" && (0, Un.alwaysValidSchema)(s, r))
      return;
    const c2 = (0, jn.allSchemaProperties)(n.properties), u = (0, jn.allSchemaProperties)(n.patternProperties);
    f(), e.ok((0, it._)`${a} === ${XC.default.errors}`);
    function f() {
      t.forIn("key", i, (g) => {
        !c2.length && !u.length ? m2(g) : t.if(p(g), () => m2(g));
      });
    }
    function p(g) {
      let y2;
      if (c2.length > 8) {
        const v = (0, Un.schemaRefOrVal)(s, n.properties, "properties");
        y2 = (0, jn.isOwnProperty)(t, v, g);
      } else
        c2.length ? y2 = (0, it.or)(...c2.map((v) => (0, it._)`${g} === ${v}`)) : y2 = it.nil;
      return u.length && (y2 = (0, it.or)(y2, ...u.map((v) => (0, it._)`${(0, jn.usePattern)(e, v)}.test(${g})`))), (0, it.not)(y2);
    }
    function d2(g) {
      t.code((0, it._)`delete ${i}[${g}]`);
    }
    function m2(g) {
      if (l.removeAdditional === "all" || l.removeAdditional && r === false) {
        d2(g);
        return;
      }
      if (r === false) {
        e.setParams({ additionalProperty: g }), e.error(), o || t.break();
        return;
      }
      if (typeof r == "object" && !(0, Un.alwaysValidSchema)(s, r)) {
        const y2 = t.name("valid");
        l.removeAdditional === "failing" ? (h2(g, y2, false), t.if((0, it.not)(y2), () => {
          e.reset(), d2(g);
        })) : (h2(g, y2), o || t.if((0, it.not)(y2), () => t.break()));
      }
    }
    function h2(g, y2, v) {
      const b = {
        keyword: "additionalProperties",
        dataProp: g,
        dataPropType: Un.Type.Str
      };
      v === false && Object.assign(b, {
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }), e.subschema(b, y2);
    }
  }
};
Pi.default = QC;
var Rs = {};
Object.defineProperty(Rs, "__esModule", { value: true });
var eA = lt;
var yl = ne;
var Hi = fe;
var gl = Pi;
var tA = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: a } = e;
    a.opts.removeAdditional === "all" && n.additionalProperties === void 0 && gl.default.code(new eA.KeywordCxt(a, gl.default, "additionalProperties"));
    const s = (0, yl.allSchemaProperties)(r);
    for (const f of s)
      a.definedProperties.add(f);
    a.opts.unevaluated && s.length && a.props !== true && (a.props = Hi.mergeEvaluated.props(t, (0, Hi.toHash)(s), a.props));
    const o = s.filter((f) => !(0, Hi.alwaysValidSchema)(a, r[f]));
    if (o.length === 0)
      return;
    const l = t.name("valid");
    for (const f of o)
      c2(f) ? u(f) : (t.if((0, yl.propertyInData)(t, i, f, a.opts.ownProperties)), u(f), a.allErrors || t.else().var(l, true), t.endIf()), e.it.definedProperties.add(f), e.ok(l);
    function c2(f) {
      return a.opts.useDefaults && !a.compositeRule && r[f].default !== void 0;
    }
    function u(f) {
      e.subschema({
        keyword: "properties",
        schemaProp: f,
        dataProp: f
      }, l);
    }
  }
};
Rs.default = tA;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: true });
var vl = ne;
var Vn = re2;
var $l = fe;
var _l = fe;
var rA = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: n, parentSchema: i, it: a } = e, { opts: s } = a, o = (0, vl.allSchemaProperties)(r), l = o.filter((h2) => (0, $l.alwaysValidSchema)(a, r[h2]));
    if (o.length === 0 || l.length === o.length && (!a.opts.unevaluated || a.props === true))
      return;
    const c2 = s.strictSchema && !s.allowMatchingProperties && i.properties, u = t.name("valid");
    a.props !== true && !(a.props instanceof Vn.Name) && (a.props = (0, _l.evaluatedPropsToName)(t, a.props));
    const { props: f } = a;
    p();
    function p() {
      for (const h2 of o)
        c2 && d2(h2), a.allErrors ? m2(h2) : (t.var(u, true), m2(h2), t.if(u));
    }
    function d2(h2) {
      for (const g in c2)
        new RegExp(h2).test(g) && (0, $l.checkStrictMode)(a, `property ${g} matches pattern ${h2} (use allowMatchingProperties)`);
    }
    function m2(h2) {
      t.forIn("key", n, (g) => {
        t.if((0, Vn._)`${(0, vl.usePattern)(e, h2)}.test(${g})`, () => {
          const y2 = l.includes(h2);
          y2 || e.subschema({
            keyword: "patternProperties",
            schemaProp: h2,
            dataProp: g,
            dataPropType: _l.Type.Str
          }, u), a.opts.unevaluated && f !== true ? t.assign((0, Vn._)`${f}[${g}]`, true) : !y2 && !a.allErrors && t.if((0, Vn.not)(u), () => t.break());
        });
      });
    }
  }
};
Ms.default = rA;
var js = {};
Object.defineProperty(js, "__esModule", { value: true });
var nA = fe;
var iA = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if ((0, nA.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const i = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: true,
      createErrors: false,
      allErrors: false
    }, i), e.failResult(i, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
js.default = iA;
var Us2 = {};
Object.defineProperty(Us2, "__esModule", { value: true });
var aA = ne;
var sA = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: true,
  code: aA.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
Us2.default = sA;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: true });
var Xn = re2;
var oA = fe;
var lA = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, Xn._)`{passingSchemas: ${e.passing}}`
};
var cA = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error: lA,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && n.discriminator)
      return;
    const a = r, s = t.let("valid", false), o = t.let("passing", null), l = t.name("_valid");
    e.setParams({ passing: o }), t.block(c2), e.result(s, () => e.reset(), () => e.error(true));
    function c2() {
      a.forEach((u, f) => {
        let p;
        (0, oA.alwaysValidSchema)(i, u) ? t.var(l, true) : p = e.subschema({
          keyword: "oneOf",
          schemaProp: f,
          compositeRule: true
        }, l), f > 0 && t.if((0, Xn._)`${l} && ${s}`).assign(s, false).assign(o, (0, Xn._)`[${o}, ${f}]`).else(), t.if(l, () => {
          t.assign(s, true), t.assign(o, f), p && e.mergeEvaluated(p, Xn.Name);
        });
      });
    }
  }
};
Vs.default = cA;
var xs = {};
Object.defineProperty(xs, "__esModule", { value: true });
var uA = fe;
var dA = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const i = t.name("valid");
    r.forEach((a, s) => {
      if ((0, uA.alwaysValidSchema)(n, a))
        return;
      const o = e.subschema({ keyword: "allOf", schemaProp: s }, i);
      e.ok(i), e.mergeEvaluated(o);
    });
  }
};
xs.default = dA;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: true });
var ui = re2;
var fd = fe;
var fA = {
  message: ({ params: e }) => (0, ui.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, ui._)`{failingKeyword: ${e.ifClause}}`
};
var hA = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: true,
  error: fA,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, fd.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const i = bl(n, "then"), a = bl(n, "else");
    if (!i && !a)
      return;
    const s = t.let("valid", true), o = t.name("_valid");
    if (l(), e.reset(), i && a) {
      const u = t.let("ifClause");
      e.setParams({ ifClause: u }), t.if(o, c2("then", u), c2("else", u));
    } else
      i ? t.if(o, c2("then")) : t.if((0, ui.not)(o), c2("else"));
    e.pass(s, () => e.error(true));
    function l() {
      const u = e.subschema({
        keyword: "if",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, o);
      e.mergeEvaluated(u);
    }
    function c2(u, f) {
      return () => {
        const p = e.subschema({ keyword: u }, o);
        t.assign(s, o), e.mergeValidEvaluated(p, s), f ? t.assign(f, (0, ui._)`${u}`) : e.setParams({ ifClause: u });
      };
    }
  }
};
function bl(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, fd.alwaysValidSchema)(e, r);
}
Ls.default = hA;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: true });
var mA = fe;
var pA = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, mA.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
Bs.default = pA;
Object.defineProperty(Ts, "__esModule", { value: true });
var yA = Ur;
var gA = Ns;
var vA = Vr3;
var $A = Ds;
var _A = Fs;
var bA = ud;
var SA = ks;
var wA = Pi;
var EA = Rs;
var OA = Ms;
var CA = js;
var AA = Us2;
var PA = Vs;
var IA = xs;
var TA = Ls;
var NA = Bs;
function DA(e = false) {
  const t = [
    // any
    CA.default,
    AA.default,
    PA.default,
    IA.default,
    TA.default,
    NA.default,
    // object
    SA.default,
    wA.default,
    bA.default,
    EA.default,
    OA.default
  ];
  return e ? t.push(gA.default, $A.default) : t.push(yA.default, vA.default), t.push(_A.default), t;
}
Ts.default = DA;
var qs = {};
var Ks = {};
Object.defineProperty(Ks, "__esModule", { value: true });
var Pe = re2;
var FA = {
  message: ({ schemaCode: e }) => (0, Pe.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, Pe._)`{format: ${e}}`
};
var kA = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error: FA,
  code(e, t) {
    const { gen: r, data: n, $data: i, schema: a, schemaCode: s, it: o } = e, { opts: l, errSchemaPath: c2, schemaEnv: u, self: f } = o;
    if (!l.validateFormats)
      return;
    i ? p() : d2();
    function p() {
      const m2 = r.scopeValue("formats", {
        ref: f.formats,
        code: l.code.formats
      }), h2 = r.const("fDef", (0, Pe._)`${m2}[${s}]`), g = r.let("fType"), y2 = r.let("format");
      r.if((0, Pe._)`typeof ${h2} == "object" && !(${h2} instanceof RegExp)`, () => r.assign(g, (0, Pe._)`${h2}.type || "string"`).assign(y2, (0, Pe._)`${h2}.validate`), () => r.assign(g, (0, Pe._)`"string"`).assign(y2, h2)), e.fail$data((0, Pe.or)(v(), b()));
      function v() {
        return l.strictSchema === false ? Pe.nil : (0, Pe._)`${s} && !${y2}`;
      }
      function b() {
        const w = u.$async ? (0, Pe._)`(${h2}.async ? await ${y2}(${n}) : ${y2}(${n}))` : (0, Pe._)`${y2}(${n})`, C = (0, Pe._)`(typeof ${y2} == "function" ? ${w} : ${y2}.test(${n}))`;
        return (0, Pe._)`${y2} && ${y2} !== true && ${g} === ${t} && !${C}`;
      }
    }
    function d2() {
      const m2 = f.formats[a];
      if (!m2) {
        v();
        return;
      }
      if (m2 === true)
        return;
      const [h2, g, y2] = b(m2);
      h2 === t && e.pass(w());
      function v() {
        if (l.strictSchema === false) {
          f.logger.warn(C());
          return;
        }
        throw new Error(C());
        function C() {
          return `unknown format "${a}" ignored in schema at path "${c2}"`;
        }
      }
      function b(C) {
        const E2 = C instanceof RegExp ? (0, Pe.regexpCode)(C) : l.code.formats ? (0, Pe._)`${l.code.formats}${(0, Pe.getProperty)(a)}` : void 0, _3 = r.scopeValue("formats", { key: a, ref: C, code: E2 });
        return typeof C == "object" && !(C instanceof RegExp) ? [C.type || "string", C.validate, (0, Pe._)`${_3}.validate`] : ["string", C, _3];
      }
      function w() {
        if (typeof m2 == "object" && !(m2 instanceof RegExp) && m2.async) {
          if (!u.$async)
            throw new Error("async format in sync schema");
          return (0, Pe._)`await ${y2}(${n})`;
        }
        return typeof g == "function" ? (0, Pe._)`${y2}(${n})` : (0, Pe._)`${y2}.test(${n})`;
      }
    }
  }
};
Ks.default = kA;
Object.defineProperty(qs, "__esModule", { value: true });
var RA = Ks;
var MA = [RA.default];
qs.default = MA;
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: true });
Nr.contentVocabulary = Nr.metadataVocabulary = void 0;
Nr.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Nr.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(ps, "__esModule", { value: true });
var jA = ys;
var UA = vs2;
var VA = Ts;
var xA = qs;
var Sl = Nr;
var LA = [
  jA.default,
  UA.default,
  (0, VA.default)(),
  xA.default,
  Sl.metadataVocabulary,
  Sl.contentVocabulary
];
ps.default = LA;
var zs = {};
var hd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.DiscrError = void 0, function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e.DiscrError || (e.DiscrError = {}));
})(hd);
Object.defineProperty(zs, "__esModule", { value: true });
var $r = re2;
var ha = hd;
var wl = ze;
var BA = fe;
var qA = {
  message: ({ params: { discrError: e, tagName: t } }) => e === ha.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, $r._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
};
var KA = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: qA,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: i, it: a } = e, { oneOf: s } = i;
    if (!a.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const o = n.propertyName;
    if (typeof o != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!s)
      throw new Error("discriminator: requires oneOf keyword");
    const l = t.let("valid", false), c2 = t.const("tag", (0, $r._)`${r}${(0, $r.getProperty)(o)}`);
    t.if((0, $r._)`typeof ${c2} == "string"`, () => u(), () => e.error(false, { discrError: ha.DiscrError.Tag, tag: c2, tagName: o })), e.ok(l);
    function u() {
      const d2 = p();
      t.if(false);
      for (const m2 in d2)
        t.elseIf((0, $r._)`${c2} === ${m2}`), t.assign(l, f(d2[m2]));
      t.else(), e.error(false, { discrError: ha.DiscrError.Mapping, tag: c2, tagName: o }), t.endIf();
    }
    function f(d2) {
      const m2 = t.name("valid"), h2 = e.subschema({ keyword: "oneOf", schemaProp: d2 }, m2);
      return e.mergeEvaluated(h2, $r.Name), m2;
    }
    function p() {
      var d2;
      const m2 = {}, h2 = y2(i);
      let g = true;
      for (let w = 0; w < s.length; w++) {
        let C = s[w];
        C != null && C.$ref && !(0, BA.schemaHasRulesButRef)(C, a.self.RULES) && (C = wl.resolveRef.call(a.self, a.schemaEnv.root, a.baseId, C == null ? void 0 : C.$ref), C instanceof wl.SchemaEnv && (C = C.schema));
        const E2 = (d2 = C == null ? void 0 : C.properties) === null || d2 === void 0 ? void 0 : d2[o];
        if (typeof E2 != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`);
        g = g && (h2 || y2(C)), v(E2, w);
      }
      if (!g)
        throw new Error(`discriminator: "${o}" must be required`);
      return m2;
      function y2({ required: w }) {
        return Array.isArray(w) && w.includes(o);
      }
      function v(w, C) {
        if (w.const)
          b(w.const, C);
        else if (w.enum)
          for (const E2 of w.enum)
            b(E2, C);
        else
          throw new Error(`discriminator: "properties/${o}" must have "const" or "enum"`);
      }
      function b(w, C) {
        if (typeof w != "string" || w in m2)
          throw new Error(`discriminator: "${o}" values must be unique strings`);
        m2[w] = C;
      }
    }
  }
};
zs.default = KA;
var zA = "http://json-schema.org/draft-07/schema#";
var WA = "http://json-schema.org/draft-07/schema#";
var GA = "Core schema meta-schema";
var HA = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: true,
    default: []
  }
};
var YA = [
  "object",
  "boolean"
];
var JA = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: true,
  readOnly: {
    type: "boolean",
    default: false
  },
  examples: {
    type: "array",
    items: true
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: true
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: false
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: true,
  enum: {
    type: "array",
    items: true,
    minItems: 1,
    uniqueItems: true
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: true
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
};
var XA = {
  $schema: zA,
  $id: WA,
  title: GA,
  definitions: HA,
  type: YA,
  properties: JA,
  default: true
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: true }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = ku, n = ps, i = zs, a = XA, s = ["/properties"], o = "http://json-schema.org/draft-07/schema";
  class l extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((m2) => this.addVocabulary(m2)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const m2 = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
      this.addMetaSchema(m2, o, false), this.refs["http://json-schema.org/schema"] = o;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  e.exports = t = l, Object.defineProperty(t, "__esModule", { value: true }), t.default = l;
  var c2 = lt;
  Object.defineProperty(t, "KeywordCxt", { enumerable: true, get: function() {
    return c2.KeywordCxt;
  } });
  var u = re2;
  Object.defineProperty(t, "_", { enumerable: true, get: function() {
    return u._;
  } }), Object.defineProperty(t, "str", { enumerable: true, get: function() {
    return u.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: true, get: function() {
    return u.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: true, get: function() {
    return u.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: true, get: function() {
    return u.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: true, get: function() {
    return u.CodeGen;
  } });
  var f = bn;
  Object.defineProperty(t, "ValidationError", { enumerable: true, get: function() {
    return f.default;
  } });
  var p = Sn;
  Object.defineProperty(t, "MissingRefError", { enumerable: true, get: function() {
    return p.default;
  } });
})(oa, oa.exports);
var md = oa.exports;
var ZA = sn2(md);
var ma = { exports: {} };
var pd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(F, j2) {
    return { validate: F, compare: j2 };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(a, s),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(l, c2),
    "date-time": t(f, p),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: h2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: T,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y2,
    // signed 32 bit integer
    int32: { type: "number", validate: w },
    // signed 64 bit integer
    int64: { type: "number", validate: C },
    // C-type float
    float: { type: "number", validate: E2 },
    // C-type double
    double: { type: "number", validate: E2 },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, s),
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, c2),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
  function r(F) {
    return F % 4 === 0 && (F % 100 !== 0 || F % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function a(F) {
    const j2 = n.exec(F);
    if (!j2)
      return false;
    const L = +j2[1], U = +j2[2], W = +j2[3];
    return U >= 1 && U <= 12 && W >= 1 && W <= (U === 2 && r(L) ? 29 : i[U]);
  }
  function s(F, j2) {
    if (F && j2)
      return F > j2 ? 1 : F < j2 ? -1 : 0;
  }
  const o = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function l(F, j2) {
    const L = o.exec(F);
    if (!L)
      return false;
    const U = +L[1], W = +L[2], z2 = +L[3], q3 = L[5];
    return (U <= 23 && W <= 59 && z2 <= 59 || U === 23 && W === 59 && z2 === 60) && (!j2 || q3 !== "");
  }
  function c2(F, j2) {
    if (!(F && j2))
      return;
    const L = o.exec(F), U = o.exec(j2);
    if (L && U)
      return F = L[1] + L[2] + L[3] + (L[4] || ""), j2 = U[1] + U[2] + U[3] + (U[4] || ""), F > j2 ? 1 : F < j2 ? -1 : 0;
  }
  const u = /t|\s/i;
  function f(F) {
    const j2 = F.split(u);
    return j2.length === 2 && a(j2[0]) && l(j2[1], true);
  }
  function p(F, j2) {
    if (!(F && j2))
      return;
    const [L, U] = F.split(u), [W, z2] = j2.split(u), q3 = s(L, W);
    if (q3 !== void 0)
      return q3 || c2(U, z2);
  }
  const d2 = /\/|:/, m2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function h2(F) {
    return d2.test(F) && m2.test(F);
  }
  const g = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y2(F) {
    return g.lastIndex = 0, g.test(F);
  }
  const v = -(2 ** 31), b = 2 ** 31 - 1;
  function w(F) {
    return Number.isInteger(F) && F <= b && F >= v;
  }
  function C(F) {
    return Number.isInteger(F);
  }
  function E2() {
    return true;
  }
  const _3 = /[^\\]\\Z/;
  function T(F) {
    if (_3.test(F))
      return false;
    try {
      return new RegExp(F), true;
    } catch {
      return false;
    }
  }
})(pd);
var yd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.formatLimitDefinition = void 0;
  const t = md, r = re2, n = r.operators, i = {
    formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
    formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
    formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
  }, a = {
    message: ({ keyword: o, schemaCode: l }) => r.str`should be ${i[o].okStr} ${l}`,
    params: ({ keyword: o, schemaCode: l }) => r._`{comparison: ${i[o].okStr}, limit: ${l}}`
  };
  e.formatLimitDefinition = {
    keyword: Object.keys(i),
    type: "string",
    schemaType: "string",
    $data: true,
    error: a,
    code(o) {
      const { gen: l, data: c2, schemaCode: u, keyword: f, it: p } = o, { opts: d2, self: m2 } = p;
      if (!d2.validateFormats)
        return;
      const h2 = new t.KeywordCxt(p, m2.RULES.all.format.definition, "format");
      h2.$data ? g() : y2();
      function g() {
        const b = l.scopeValue("formats", {
          ref: m2.formats,
          code: d2.code.formats
        }), w = l.const("fmt", r._`${b}[${h2.schemaCode}]`);
        o.fail$data(r.or(r._`typeof ${w} != "object"`, r._`${w} instanceof RegExp`, r._`typeof ${w}.compare != "function"`, v(w)));
      }
      function y2() {
        const b = h2.schema, w = m2.formats[b];
        if (!w || w === true)
          return;
        if (typeof w != "object" || w instanceof RegExp || typeof w.compare != "function")
          throw new Error(`"${f}": format "${b}" does not define "compare" function`);
        const C = l.scopeValue("formats", {
          key: b,
          ref: w,
          code: d2.code.formats ? r._`${d2.code.formats}${r.getProperty(b)}` : void 0
        });
        o.fail$data(v(C));
      }
      function v(b) {
        return r._`${b}.compare(${c2}, ${u}) ${i[f].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const s = (o) => (o.addKeyword(e.formatLimitDefinition), o);
  e.default = s;
})(yd);
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: true });
  const r = pd, n = yd, i = re2, a = new i.Name("fullFormats"), s = new i.Name("fastFormats"), o = (c2, u = { keywords: true }) => {
    if (Array.isArray(u))
      return l(c2, u, r.fullFormats, a), c2;
    const [f, p] = u.mode === "fast" ? [r.fastFormats, s] : [r.fullFormats, a], d2 = u.formats || r.formatNames;
    return l(c2, d2, f, p), u.keywords && n.default(c2), c2;
  };
  o.get = (c2, u = "full") => {
    const p = (u === "fast" ? r.fastFormats : r.fullFormats)[c2];
    if (!p)
      throw new Error(`Unknown format "${c2}"`);
    return p;
  };
  function l(c2, u, f, p) {
    var d2, m2;
    (d2 = (m2 = c2.opts.code).formats) !== null && d2 !== void 0 || (m2.formats = i._`require("ajv-formats/dist/formats").${p}`);
    for (const h2 of u)
      c2.addFormat(h2, f[h2]);
  }
  e.exports = t = o, Object.defineProperty(t, "__esModule", { value: true }), t.default = o;
})(ma, ma.exports);
var QA = ma.exports;
var El = sn2(QA);
var eP = {
  allErrors: true,
  multipleOfPrecision: 8,
  strict: false,
  verbose: true
};
var tP = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/;
var rP = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function nP(e, t, r = {}, n, i = ZA) {
  const a = new i({ ...eP, ...r });
  return n ? El(a, n) : n !== false && El(a), a.addFormat("data-url", rP), a.addFormat("color", tP), a.addKeyword(Dr), a.addKeyword(Ia), Array.isArray(e) && a.addMetaSchema(e), A(t) && Object.keys(t).forEach((s) => {
    a.addFormat(s, t[s]);
  }), a;
}
function iP(e = [], t) {
  return e.map((r) => {
    const { instancePath: n, keyword: i, params: a, schemaPath: s, parentSchema: o, ...l } = r;
    let { message: c2 = "" } = l, u = n.replace(/\//g, "."), f = `${u} ${c2}`.trim();
    if ("missingProperty" in a) {
      u = u ? `${u}.${a.missingProperty}` : a.missingProperty;
      const p = a.missingProperty, d2 = oe(G2(t, `${u.replace(/^\./, "")}`)).title;
      if (d2)
        c2 = c2.replace(p, d2);
      else {
        const m2 = G2(o, [Oe, p, "title"]);
        m2 && (c2 = c2.replace(p, m2));
      }
      f = c2;
    } else {
      const p = oe(G2(t, `${u.replace(/^\./, "")}`)).title;
      if (p)
        f = `'${p}' ${c2}`.trim();
      else {
        const d2 = o == null ? void 0 : o.title;
        d2 && (f = `'${d2}' ${c2}`.trim());
      }
    }
    return {
      name: i,
      property: u,
      message: c2,
      params: a,
      stack: f,
      schemaPath: s
    };
  });
}
function aP(e, t, r, n, i, a, s) {
  const { validationError: o } = t;
  let l = iP(t.errors, s);
  o && (l = [...l, { stack: o.message }]), typeof a == "function" && (l = a(l, s));
  let c2 = E1(l);
  if (o && (c2 = {
    ...c2,
    $schema: {
      __errors: [o.message]
    }
  }), typeof i != "function")
    return { errors: l, errorSchema: c2 };
  const u = tu(e, n, r, n, true), f = i(u, Xi(u), s), p = du(f);
  return Wn({ errors: l, errorSchema: c2 }, p);
}
var sP = class {
  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  constructor(t, r) {
    const { additionalMetaSchemas: n, customFormats: i, ajvOptionsOverrides: a, ajvFormatOptions: s, AjvClass: o } = t;
    this.ajv = nP(n, i, a, s, o), this.localizer = r;
  }
  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
   *
   * @param errorSchema - The `ErrorSchema` instance to convert
   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in
   *        the next major release.
   */
  toErrorList(t, r = []) {
    return sn3(t, r);
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */
  rawValidation(t, r) {
    let n, i;
    t[Mt] && (i = this.ajv.getSchema(t[Mt]));
    try {
      i === void 0 && (i = this.ajv.compile(t)), i(r);
    } catch (s) {
      n = s;
    }
    let a;
    return i && (typeof this.localizer == "function" && this.localizer(i.errors), a = i.errors || void 0, i.errors = null), {
      errors: a,
      validationError: n
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */
  validateFormData(t, r, n, i, a) {
    const s = this.rawValidation(r, t);
    return aP(this, s, t, r, n, i, a);
  }
  /**
   * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  handleSchemaUpdate(t) {
    var r, n;
    const i = (r = t[Mt]) !== null && r !== void 0 ? r : Bl;
    this.ajv.getSchema(i) === void 0 ? this.ajv.addSchema(t, i) : Be(t, (n = this.ajv.getSchema(i)) === null || n === void 0 ? void 0 : n.schema) || (this.ajv.removeSchema(i), this.ajv.addSchema(t, i));
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  isValid(t, r, n) {
    var i;
    try {
      this.handleSchemaUpdate(n);
      const a = as(t), s = (i = a[Mt]) !== null && i !== void 0 ? i : c1(a);
      let o;
      return o = this.ajv.getSchema(s), o === void 0 && (o = this.ajv.addSchema(a, s).getSchema(s) || this.ajv.compile(a)), o(r);
    } catch (a) {
      return console.warn("Error encountered compiling schema:", a), false;
    }
  }
};
function oP(e = {}, t) {
  return new sP(e, t);
}
var lP = oP();
var cP = {
  width: "100%"
};
var xn = {
  width: "calc(100% / 4)"
};
function uP(e) {
  const { children: t, disabled: r, hasCopy: n, hasMoveDown: i, hasMoveUp: a, hasRemove: s, hasToolbar: o, index: l, onCopyIndexClick: c2, onDropIndexClick: u, onReorderClick: f, readonly: p, registry: d2, uiSchema: m2 } = e, { CopyButton: h2, MoveDownButton: g, MoveUpButton: y2, RemoveButton: v } = d2.templates.ButtonTemplates, { rowGutter: b = 24, toolbarAlign: w = "top" } = d2.formContext;
  return N2(KX, { align: w, gutter: b, children: [d(j$, { flex: "1", children: t }), o && d(j$, { flex: "192px", children: N2(sa.Group, { style: cP, children: [(a || i) && d(y2, { disabled: r || p || !a, onClick: f(l, l - 1), style: xn, uiSchema: m2, registry: d2 }), (a || i) && d(g, { disabled: r || p || !i, onClick: f(l, l + 1), style: xn, uiSchema: m2, registry: d2 }), n && d(h2, { disabled: r || p, onClick: c2(l), style: xn, uiSchema: m2, registry: d2 }), s && d(v, { disabled: r || p, onClick: u(l), style: xn, uiSchema: m2, registry: d2 })] }) })] }, `array-item-${l}`);
}
var dP = {
  paddingBottom: "8px"
};
function fP(e) {
  const { canAdd: t, className: r, disabled: n, formContext: i, idSchema: a, items: s, onAddClick: o, readonly: l, registry: c2, required: u, schema: f, title: p, uiSchema: d2 } = e, m2 = oe(d2), h2 = ce("ArrayFieldDescriptionTemplate", c2, m2), g = ce("ArrayFieldItemTemplate", c2, m2), y2 = ce("ArrayFieldTitleTemplate", c2, m2), { ButtonTemplates: { AddButton: v } } = c2.templates, { labelAlign: b = "right", rowGutter: w = 24 } = i, { getPrefixCls: C } = (0, import_react.useContext)(gh.ConfigContext), _3 = `${C("form")}-item-label`, T = _e(
    _3,
    b === "left" && `${_3}-left`
    // labelCol.className,
  );
  return d("fieldset", { className: r, id: a.$id, children: N2(KX, { gutter: w, children: [(m2.title || p) && d(j$, { className: T, span: 24, children: d(y2, { idSchema: a, required: u, title: m2.title || p, schema: f, uiSchema: d2, registry: c2 }) }), (m2.description || f.description) && d(j$, { span: 24, style: dP, children: d(h2, { description: m2.description || f.description, idSchema: a, schema: f, uiSchema: d2, registry: c2 }) }), d(j$, { className: "row array-item-list", span: 24, children: s && s.map(({ key: F, ...j2 }) => d(g, { ...j2 }, F)) }), t && d(j$, { span: 24, children: d(KX, { gutter: w, justify: "end", children: d(j$, { flex: "192px", children: d(v, { className: "array-item-add", disabled: n || l, onClick: o, uiSchema: d2, registry: c2 }) }) }) })] }) });
}
var Ol = {
  width: "100%"
};
function hP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onChangeOverride: s, onFocus: o, options: l, placeholder: c2, readonly: u, schema: f, value: p, type: d2 } = e, m2 = su(f, d2, l, false), { readonlyAsDisabled: h2 = true } = r, g = (C) => a(C), y2 = s || (({ target: C }) => a(C.value === "" ? l.emptyValue : C.value)), v = ({ target: C }) => i(n, C && C.value), b = ({ target: C }) => o(n, C && C.value), w = m2.type === "number" || m2.type === "integer" ? d(G$, { disabled: t || h2 && u, id: n, name: n, onBlur: u ? void 0 : v, onChange: u ? void 0 : g, onFocus: u ? void 0 : b, placeholder: c2, style: Ol, list: f.examples ? Sr(n) : void 0, ...m2, value: p, "aria-describedby": De(n, !!f.examples) }) : d(fl, { disabled: t || h2 && u, id: n, name: n, onBlur: u ? void 0 : v, onChange: u ? void 0 : y2, onFocus: u ? void 0 : b, placeholder: c2, style: Ol, list: f.examples ? Sr(n) : void 0, ...m2, value: p, "aria-describedby": De(n, !!f.examples) });
  return N2(p1, { children: [w, Array.isArray(f.examples) && d("datalist", { id: Sr(n), children: f.examples.concat(f.default && !f.examples.includes(f.default) ? [f.default] : []).map((C) => d("option", { value: C }, C)) })] });
}
function mP(e) {
  const { id: t, description: r } = e;
  return r ? d("span", { id: t, children: r }) : null;
}
function pP({ errors: e, registry: t }) {
  const { translateString: r } = t;
  return d(Ov, { className: "panel panel-danger errors", description: (() => d(yQ, { className: "list-group", size: "small", children: e.map((i, a) => d(yQ.Item, { children: N2(hQ, { children: [d(S3, {}), i.stack] }) }, a)) }))(), message: r(le.ErrorsLabel), type: "error" });
}
function En(e) {
  const { iconType: t = "default", icon: r, onClick: n, uiSchema: i, registry: a, ...s } = e;
  return d(sa, { onClick: n, type: t, icon: r, ...s });
}
function yP(e) {
  const { registry: { translateString: t } } = e;
  return d(En, { title: t(le.AddItemButton), ...e, block: true, iconType: "primary", icon: d(x2, {}) });
}
function gP(e) {
  const { registry: { translateString: t } } = e;
  return d(En, { title: t(le.CopyButton), ...e, icon: d(S2, {}) });
}
function vP(e) {
  const { registry: { translateString: t } } = e;
  return d(En, { title: t(le.MoveDownButton), ...e, icon: d(x, {}) });
}
function $P(e) {
  const { registry: { translateString: t } } = e;
  return d(En, { title: t(le.MoveUpButton), ...e, icon: d(S, {}) });
}
function _P(e) {
  const t = oe(e.uiSchema), { registry: { translateString: r } } = e;
  return d(En, { title: r(le.RemoveButton), ...e, danger: true, block: !!t.block, iconType: "primary", icon: d(N, {}) });
}
function bP(e) {
  const { errors: t = [], idSchema: r } = e;
  if (t.length === 0)
    return null;
  const n = ns(r);
  return d("div", { id: n, children: t.map((i) => d("div", { children: i }, `field-${n}-error-${i}`)) });
}
var SP = { span: 24 };
var wP = { span: 24 };
function EP(e) {
  const { children: t, classNames: r, style: n, description: i, disabled: a, displayLabel: s, errors: o, formContext: l, help: c2, hidden: u, id: f, label: p, onDropPropertyClick: d2, onKeyChange: m2, rawErrors: h2, rawDescription: g, rawHelp: y2, readonly: v, registry: b, required: w, schema: C, uiSchema: E2 } = e, { colon: _3, labelCol: T = SP, wrapperCol: F = wP, wrapperStyle: j2, descriptionLocation: L = "below" } = l, U = oe(E2), W = ce("WrapIfAdditionalTemplate", b, U);
  if (u)
    return d("div", { className: "field-hidden", children: t });
  const z2 = g ? i : void 0, q3 = {};
  switch (L) {
    case "tooltip":
      q3.tooltip = z2;
      break;
    case "below":
    default:
      q3.extra = z2;
      break;
  }
  return d(W, { classNames: r, style: n, disabled: a, id: f, label: p, onDropPropertyClick: d2, onKeyChange: m2, readonly: v, required: w, schema: C, uiSchema: E2, registry: b, children: d(qd.Item, { colon: _3, hasFeedback: C.type !== "array" && C.type !== "object", help: !!y2 && c2 || (h2 != null && h2.length ? o : void 0), htmlFor: f, label: s && p, labelCol: T, required: w, style: j2, validateStatus: h2 != null && h2.length ? "error" : void 0, wrapperCol: F, ...q3, children: t }) });
}
var OP = {
  paddingBottom: "8px"
};
function CP(e) {
  const { description: t, disabled: r, formContext: n, formData: i, idSchema: a, onAddClick: s, properties: o, readonly: l, required: c2, registry: u, schema: f, title: p, uiSchema: d2 } = e, m2 = oe(d2), h2 = ce("TitleFieldTemplate", u, m2), g = ce("DescriptionFieldTemplate", u, m2), { ButtonTemplates: { AddButton: y2 } } = u.templates, { colSpan: v = 24, labelAlign: b = "right", rowGutter: w = 24 } = n, C = (q3) => q3.content.props.schema, E2 = (q3) => C(q3).type, _3 = (q3) => q3.content.props.uiSchema, T = (q3) => oe(_3(q3)).field, F = (q3) => oe(_3(q3)).widget, j2 = (q3) => {
    const ue = E2(q3), me = T(q3), ie2 = F(q3), Y2 = o.length < 2 || // Single or no field in object.
    ue === "object" || ue === "array" || ie2 === "textarea" ? 24 : 12;
    if (A(v)) {
      const V2 = v;
      if (ir(ie2))
        return V2[ie2];
      if (ir(me))
        return V2[me];
      if (ir(ue))
        return V2[ue];
    }
    return ja(v) ? v : Y2;
  }, { getPrefixCls: L } = (0, import_react.useContext)(gh.ConfigContext), W = `${L("form")}-item-label`, z2 = _e(
    W,
    b === "left" && `${W}-left`
    // labelCol.className,
  );
  return N2("fieldset", { id: a.$id, children: [N2(KX, { gutter: w, children: [p && d(j$, { className: z2, span: 24, children: d(h2, { id: is(a), title: p, required: c2, schema: f, uiSchema: d2, registry: u }) }), t && d(j$, { span: 24, style: OP, children: d(g, { id: jr(a), description: t, schema: f, uiSchema: d2, registry: u }) }), o.filter((q3) => !q3.hidden).map((q3) => d(j$, { span: j2(q3), children: q3.content }, q3.name))] }), ql(f, d2, i) && d(j$, { span: 24, children: d(KX, { gutter: w, justify: "end", children: d(j$, { flex: "192px", children: d(y2, { className: "object-property-expand", disabled: r || l, onClick: s(f), uiSchema: d2, registry: u }) }) }) })] });
}
function AP({ uiSchema: e }) {
  const { submitText: t, norender: r, props: n } = ou(e);
  return r ? null : d(sa, { type: "submit", ...n, htmlType: "submit", children: t });
}
function PP({ id: e, required: t, registry: r, title: n }) {
  const { formContext: i } = r, { colon: a = true } = i;
  let s = n;
  a && typeof n == "string" && n.trim() !== "" && (s = n.replace(/[:]\s*$/, ""));
  const o = () => {
    if (!e)
      return;
    const f = document.querySelector(`[id="${e}"]`);
    f && f.focus && f.focus();
  }, { getPrefixCls: l } = (0, import_react.useContext)(gh.ConfigContext), c2 = l("form"), u = _e({
    [`${c2}-item-required`]: t,
    [`${c2}-item-no-colon`]: !a
  });
  return n ? d("label", { className: u, htmlFor: e, onClick: o, title: typeof n == "string" ? n : "", children: s }) : null;
}
var IP = { span: 24 };
var TP = { span: 24 };
var NP = {
  width: "100%"
};
function DP(e) {
  const { children: t, classNames: r, style: n, disabled: i, id: a, label: s, onDropPropertyClick: o, onKeyChange: l, readonly: c2, required: u, registry: f, schema: p, uiSchema: d2 } = e, { colon: m2, labelCol: h2 = IP, readonlyAsDisabled: g = true, rowGutter: y2 = 24, toolbarAlign: v = "top", wrapperCol: b = TP, wrapperStyle: w } = f.formContext, { templates: C, translateString: E2 } = f, { RemoveButton: _3 } = C.ButtonTemplates, T = E2(le.KeyLabel, [s]);
  if (!(Dr in p))
    return d("div", { className: r, style: n, children: t });
  const j2 = ({ target: W }) => l(W && W.value), L = d2 ? d2[nr2] : {}, U = {
    ...d2,
    [nr2]: { ...L, block: true }
  };
  return d("div", { className: r, style: n, children: N2(KX, { align: v, gutter: y2, children: [d(j$, { className: "form-additional", flex: "1", children: d("div", { className: "form-group", children: d(qd.Item, { colon: m2, className: "form-group", hasFeedback: true, htmlFor: `${a}-key`, label: T, labelCol: h2, required: u, style: w, wrapperCol: b, children: d(fl, { className: "form-control", defaultValue: s, disabled: i || g && c2, id: `${a}-key`, name: `${a}-key`, onBlur: c2 ? void 0 : j2, style: NP, type: "text" }) }) }) }), d(j$, { className: "form-additional", flex: "1", children: t }), d(j$, { flex: "192px", children: d(_3, { className: "array-item-remove", disabled: i || c2, onClick: o(s), uiSchema: U, registry: f }) })] }) });
}
function FP() {
  return {
    ArrayFieldItemTemplate: uP,
    ArrayFieldTemplate: fP,
    BaseInputTemplate: hP,
    ButtonTemplates: {
      AddButton: yP,
      CopyButton: gP,
      MoveDownButton: vP,
      MoveUpButton: $P,
      RemoveButton: _P,
      SubmitButton: AP
    },
    DescriptionFieldTemplate: mP,
    ErrorListTemplate: pP,
    FieldErrorTemplate: bP,
    FieldTemplate: EP,
    ObjectFieldTemplate: CP,
    TitleFieldTemplate: PP,
    WrapIfAdditionalTemplate: DP
  };
}
var kP = (e, t) => {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push({ value: n, label: St(n, 2) });
  return r;
};
var RP = (e) => Object.values(e).every((t) => t !== -1);
function Ws(e) {
  const { autofocus: t, disabled: r, formContext: n, id: i, onBlur: a, onChange: s, onFocus: o, options: l, readonly: c2, registry: u, showTime: f, value: p } = e, { translateString: d2, widgets: m2 } = u, { SelectWidget: h2 } = m2, { rowGutter: g = 24 } = n, [y2, v] = (0, import_react.useState)(wr(p, f));
  (0, import_react.useEffect)(() => {
    v(wr(p, f));
  }, [f, p]);
  const b = (_3, T) => {
    const F = {
      ...y2,
      [_3]: typeof T > "u" ? -1 : T
    };
    RP(F) ? s(ai(F, f)) : v(F);
  }, w = (_3) => {
    if (_3.preventDefault(), r || c2)
      return;
    const T = wr((/* @__PURE__ */ new Date()).toJSON(), f);
    s(ai(T, f));
  }, C = (_3) => {
    _3.preventDefault(), !(r || c2) && s(void 0);
  }, E2 = (_3) => d(h2, { autofocus: _3.autofocus, className: "form-control", disabled: _3.disabled, id: _3.id, name: _3.name, onBlur: _3.onBlur, onChange: (T) => _3.select(_3.type, T), onFocus: _3.onFocus, options: {
    enumOptions: kP(_3.range[0], _3.range[1])
  }, placeholder: _3.type, readonly: _3.readonly, schema: { type: "integer" }, value: _3.value, registry: u, label: "", "aria-describedby": De(i) });
  return N2(KX, { gutter: [Math.floor(g / 2), Math.floor(g / 2)], children: [iu(y2, f, l.yearsRange, l.format).map((_3, T) => {
    const F = i + "_" + _3.type;
    return d(j$, { flex: "88px", children: E2({
      ..._3,
      autofocus: t && T === 0,
      disabled: r,
      id: F,
      name: i,
      onBlur: a,
      onFocus: o,
      readonly: c2,
      registry: u,
      select: b,
      // NOTE: antd components accept -1 rather than issue a warning
      // like material-ui, so we need to convert -1 to undefined here.
      value: _3.value || -1 < 0 ? void 0 : _3.value
    }) }, F);
  }), !l.hideNowButton && d(j$, { flex: "88px", children: d(sa, { block: true, className: "btn-now", onClick: w, type: "primary", children: d2(le.NowLabel) }) }), !l.hideClearButton && d(j$, { flex: "88px", children: d(sa, { block: true, className: "btn-clear", danger: true, onClick: C, type: "primary", children: d2(le.ClearLabel) }) })] });
}
Ws.defaultProps = {
  autofocus: false,
  disabled: false,
  options: {
    yearsRange: [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2]
  },
  readonly: false,
  showTime: false
};
function gd(e) {
  const { AltDateWidget: t } = e.registry.widgets;
  return d(t, { showTime: true, ...e });
}
gd.defaultProps = {
  ...Ws.defaultProps,
  showTime: true
};
function MP({ autofocus: e, disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, options: o, readonly: l, value: c2 }) {
  const { readonlyAsDisabled: u = true } = r, { enumOptions: f, enumDisabled: p, inline: d2, emptyValue: m2 } = o, h2 = (w) => a(Ne(w, f, m2)), v = {
    id: n,
    onBlur: l ? void 0 : ({ target: w }) => i(n, Ne(w.value, f, m2)),
    onFocus: l ? void 0 : ({ target: w }) => s(n, Ne(w.value, f, m2))
  }, b = bi(c2, f, true);
  return Array.isArray(f) && f.length > 0 ? d(p1, { children: d(l9.Group, { disabled: t || u && l, name: n, onChange: l ? void 0 : h2, value: b, ...v, "aria-describedby": De(n), children: Array.isArray(f) && f.map((w, C) => N2("span", { children: [d(l9, { id: Si(n, C), name: n, autoFocus: C === 0 ? e : false, disabled: Array.isArray(p) && p.indexOf(w.value) !== -1, value: String(C), children: w.label }), !d2 && d("br", {})] }, C)) }) }) : null;
}
function jP(e) {
  const { autofocus: t, disabled: r, formContext: n, id: i, label: a, hideLabel: s, onBlur: o, onChange: l, onFocus: c2, readonly: u, value: f } = e, { readonlyAsDisabled: p = true } = n;
  return d(l9, { autoFocus: t, checked: typeof f > "u" ? false : f, disabled: r || p && u, id: i, name: i, onChange: u ? void 0 : ({ target: y2 }) => l(y2.checked), ...{
    onBlur: u ? void 0 : ({ target: y2 }) => o(i, y2 && y2.checked),
    onFocus: u ? void 0 : ({ target: y2 }) => c2(i, y2 && y2.checked)
  }, "aria-describedby": De(i), children: cu(a, s, "") });
}
var UP = {
  width: "100%"
};
function VP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, placeholder: o, readonly: l, value: c2 } = e, { readonlyAsDisabled: u = true } = r;
  return d(KRe, { disabled: t || u && l, getPopupContainer: (h2) => h2.parentNode, id: n, name: n, onBlur: l ? void 0 : () => i(n, c2), onChange: l ? void 0 : (h2) => a(h2 && h2.toISOString()), onFocus: l ? void 0 : () => s(n, c2), placeholder: o, showTime: true, style: UP, value: c2 && nn(c2), "aria-describedby": De(n) });
}
var xP = {
  width: "100%"
};
function LP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, placeholder: o, readonly: l, value: c2 } = e, { readonlyAsDisabled: u = true } = r;
  return d(KRe, { disabled: t || u && l, getPopupContainer: (h2) => h2.parentNode, id: n, name: n, onBlur: l ? void 0 : () => i(n, c2), onChange: l ? void 0 : (h2) => a(h2 && h2.format("YYYY-MM-DD")), onFocus: l ? void 0 : () => s(n, c2), placeholder: o, showTime: false, style: xP, value: c2 && nn(c2), "aria-describedby": De(n) });
}
function BP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, options: o, placeholder: l, readonly: c2, value: u } = e, { readonlyAsDisabled: f = true } = r, p = o.emptyValue || "", d2 = ({ target: g }) => a(g.value === "" ? p : g.value), m2 = ({ target: g }) => i(n, g.value), h2 = ({ target: g }) => s(n, g.value);
  return d(fl.Password, { disabled: t || f && c2, id: n, name: n, onBlur: c2 ? void 0 : m2, onChange: c2 ? void 0 : d2, onFocus: c2 ? void 0 : h2, placeholder: l, value: u || "", "aria-describedby": De(n) });
}
function qP({ autofocus: e, disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, options: o, readonly: l, value: c2 }) {
  const { readonlyAsDisabled: u = true } = r, { enumOptions: f, enumDisabled: p, emptyValue: d2 } = o, m2 = ({ target: { value: v } }) => a(Ne(v, f, d2)), h2 = ({ target: v }) => i(n, Ne(v && v.value, f, d2)), g = ({ target: v }) => s(n, Ne(v && v.value, f, d2)), y2 = bi(c2, f);
  return d(Hv.Group, { disabled: t || u && l, id: n, name: n, onChange: l ? void 0 : m2, onBlur: l ? void 0 : h2, onFocus: l ? void 0 : g, value: y2, "aria-describedby": De(n), children: Array.isArray(f) && f.map((v, b) => d(Hv, { id: Si(n, b), name: n, autoFocus: b === 0 ? e : false, disabled: Array.isArray(p) && p.indexOf(v.value) !== -1, value: String(b), children: v.label }, b)) });
}
function KP(e) {
  const { autofocus: t, disabled: r, formContext: n, id: i, onBlur: a, onChange: s, onFocus: o, options: l, placeholder: c2, readonly: u, schema: f, value: p } = e, { readonlyAsDisabled: d2 = true } = n, { min: m2, max: h2, step: g } = au(f), y2 = l.emptyValue || "";
  return d(iQ, { autoFocus: t, disabled: r || d2 && u, id: i, max: h2, min: m2, onChange: u ? void 0 : (E2) => s(E2 === "" ? y2 : E2), range: false, step: g, value: p, ...{
    placeholder: c2,
    onBlur: u ? void 0 : () => a(i, p),
    onFocus: u ? void 0 : () => o(i, p)
  }, "aria-describedby": De(i) });
}
var zP = {
  width: "100%"
};
function WP({ autofocus: e, disabled: t, formContext: r = {}, id: n, multiple: i, onBlur: a, onChange: s, onFocus: o, options: l, placeholder: c2, readonly: u, value: f }) {
  const { readonlyAsDisabled: p = true } = r, { enumOptions: d2, enumDisabled: m2, emptyValue: h2 } = l, g = (_3) => s(Ne(_3, d2, h2)), y2 = () => a(n, Ne(f, d2, h2)), v = () => o(n, Ne(f, d2, h2)), b = (_3, T) => T && ir(T.label) ? T.label.toLowerCase().indexOf(_3.toLowerCase()) >= 0 : false, w = (_3) => _3.parentNode, C = bi(f, d2, i);
  return d(h4, { autoFocus: e, disabled: t || p && u, getPopupContainer: w, id: n, mode: i ? "multiple" : void 0, onBlur: u ? void 0 : y2, onChange: u ? void 0 : g, onFocus: u ? void 0 : v, placeholder: c2, style: zP, value: C, ...{
    name: n
  }, filterOption: b, "aria-describedby": De(n), options: Array.isArray(d2) ? d2.map(({ value: _3, label: T }, F) => ({
    disabled: Array.isArray(m2) && m2.indexOf(_3) !== -1,
    key: String(F),
    value: String(F),
    label: T
  })) : void 0 });
}
var GP = {
  width: "100%"
};
function HP({ disabled: e, formContext: t, id: r, onBlur: n, onChange: i, onFocus: a, options: s, placeholder: o, readonly: l, value: c2 }) {
  const { readonlyAsDisabled: u = true } = t, f = ({ target: h2 }) => i(h2.value === "" ? s.emptyValue : h2.value), p = ({ target: h2 }) => n(r, h2 && h2.value), d2 = ({ target: h2 }) => a(r, h2 && h2.value), m2 = {
    type: "textarea"
  };
  return d(fl.TextArea, { disabled: e || u && l, id: r, name: r, onBlur: l ? void 0 : p, onChange: l ? void 0 : f, onFocus: l ? void 0 : d2, placeholder: o, rows: s.rows || 4, style: GP, value: c2, ...m2, "aria-describedby": De(r) });
}
function YP() {
  return {
    AltDateTimeWidget: gd,
    AltDateWidget: Ws,
    CheckboxesWidget: MP,
    CheckboxWidget: jP,
    DateTimeWidget: VP,
    DateWidget: LP,
    PasswordWidget: BP,
    RadioWidget: qP,
    RangeWidget: KP,
    SelectWidget: WP,
    TextareaWidget: HP
  };
}
function vd() {
  return {
    templates: FP(),
    widgets: YP()
  };
}
var Gs = vd();
function JP() {
  return Fu(vd());
}
JP();
Gs.widgets.DateWidget = m(false);
Gs.widgets.DateTimeWidget = m(true);
var XP = Fu(Gs);
var ZP = [ene];
var QP = de.div`
  ${(e) => e.$animationStyle}
  background: ${(e) => e.$style.background};
  border: 1px solid ${(e) => e.$style.border};
  padding: 15px;
  width: 100%;
  height: 100%;
  overflow: auto;
  border-radius: ${(e) => e.$style.radius};

  label[for="root-title"] {
    font-size: 18px;
  }

  #root-description {
    font-size: 12px;
    display: inline-block;
    line-height: 2;
  }

  .ant-form-item-label {
    padding: 0;
    font-weight: 600;
  }

  .ant-form-item-extra {
    min-height: 0px;
  }
  .ant-form-item-explain {
    line-height: 24px;
  }

  .ant-form-item {
    margin-bottom: 8px;
  }

  .help-block {
    margin-bottom: 0px;
  }
`;
function Hs(e, t) {
  if (!e)
    return t;
  if (!(e.type !== "object" && (t == null || t === "")))
    switch (e.type) {
      case "string":
        return _c(t);
      case "number":
        return LS(t);
      case "integer":
        return Math.trunc(LS(t));
      case "boolean":
        return Wte(t);
      case "null":
        return null;
      case "object": {
        const r = e.properties;
        if (!r)
          return t;
        let n = {};
        return Object.entries(r).forEach(([i, a]) => {
          const s = t ? t[i] : void 0;
          n[i] = typeof a == "object" ? Hs(a, s) : s;
        }), n;
      }
      default:
        return t;
    }
}
function eI(e) {
  switch (e.name) {
    case "required":
      return _2("jsonSchemaForm.required");
    case "maximum":
      return _2("jsonSchemaForm.maximum", {
        value: e.params.limit
      });
    case "minimum":
      return _2("jsonSchemaForm.minimum", {
        value: e.params.limit
      });
    case "exclusiveMaximum":
      return _2("jsonSchemaForm.exclusiveMaximum", {
        value: e.params.limit
      });
    case "exclusiveMinimum":
      return _2("jsonSchemaForm.exclusiveMinimum", {
        value: e.params.limit
      });
    case "multipleOf":
      return _2("jsonSchemaForm.multipleOf", {
        value: e.params.multipleOf
      });
    case "minLength":
      return _2("jsonSchemaForm.minLength", {
        value: e.params.limit
      });
    case "maxLength":
      return _2("jsonSchemaForm.maxLength", {
        value: e.params.limit
      });
    case "pattern":
      return _2("jsonSchemaForm.pattern", {
        value: e.params.pattern
      });
    case "format":
      return _2("jsonSchemaForm.format", {
        value: e.params.format
      });
  }
  return "";
}
function tI(e) {
  return e.map((t) => {
    const r = eI(t);
    return r && (t.message = r, t.stack = ""), t;
  });
}
function $d(e) {
  return e.onEvent("submit").then(() => {
    e.resetAfterSubmit && e.data.reset();
  });
}
var rI = function() {
  const e = {
    resetAfterSubmit: ao,
    schema: e2e(Ote.jsonForm.defaultSchema),
    uiSchema: e2e(Ote.jsonForm.defaultUiSchema),
    data: rq1("data", Ote.jsonForm.defaultFormData),
    onEvent: ya(ZP),
    style: nc(YW1, "style"),
    animationStyle: nc(Fj1, "animationStyle")
  };
  return new VS(e, (t) => {
    var n, i, a;
    const r = (n = t == null ? void 0 : t.uiSchema) == null ? void 0 : n["ui:submitButtonOptions"];
    return d(QP, {
      $style: t.style,
      $animationStyle: t.animationStyle,
      children: d(h, {
        children: d(XP, {
          validator: lP,
          schema: t.schema,
          uiSchema: t.uiSchema,
          formData: Hs(t.schema, t.data.value),
          onSubmit: () => $d(t),
          onChange: (s) => t.data.onChange(s.formData),
          transformErrors: (s) => tI(s),
          children: d(sa, {
            hidden: r == null ? void 0 : r.norender,
            disabled: (i = r == null ? void 0 : r.props) == null ? void 0 : i.disabled,
            className: (a = r == null ? void 0 : r.props) == null ? void 0 : a.className,
            type: "primary",
            htmlType: "submit",
            style: {
              float: "right"
            },
            children: (r == null ? void 0 : r.submitText) ?? _2("event.submit")
          })
        })
      })
    });
  }).setPropertyViewFn((t) => N2(p1, {
    children: [((0, import_react.useContext)(Vr2).editorModeStatus === "logic" || (0, import_react.useContext)(Vr2).editorModeStatus === "both") && N2(ka2, {
      name: b0.basic,
      children: [t.schema.propertyView({
        key: _2("jsonSchemaForm.jsonSchema"),
        label: N2(p1, {
          children: [_2("jsonSchemaForm.jsonSchema") + " (", d("a", {
            href: "http://json-schema.org/learn/getting-started-step-by-step",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 1"
          }), ", ", d("a", {
            href: "https://jsonforms.io/examples/basic",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 2"
          }), ")"]
        }),
        tooltip: N2(p1, {
          children: [_2("jsonSchemaForm.schemaTooltip") + " ", d("a", {
            href: "http://json-schema.org/learn/getting-started-step-by-step",
            target: "_blank",
            rel: "noreferrer",
            children: "JSON schema"
          })]
        })
      }), t.uiSchema.propertyView({
        key: _2("jsonSchemaForm.uiSchema"),
        label: N2(p1, {
          children: [_2("jsonSchemaForm.uiSchema") + " (", d("a", {
            href: "https://jsonforms.io/docs/uischema",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 1"
          }), ", ", d("a", {
            href: "https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 2"
          }), ")"]
        }),
        tooltip: N2(p1, {
          children: [_2("jsonSchemaForm.schemaTooltip") + " ", d("a", {
            href: "https://jsonforms.io/docs/uischema",
            target: "_blank",
            rel: "noreferrer",
            children: "UI schema"
          })]
        })
      }), t.data.propertyView({
        key: _2("jsonSchemaForm.defaultData"),
        label: _2("jsonSchemaForm.defaultData")
      })]
    }), ((0, import_react.useContext)(Vr2).editorModeStatus === "logic" || (0, import_react.useContext)(Vr2).editorModeStatus === "both") && N2(ka2, {
      name: b0.interaction,
      children: [t.onEvent.getPropertyView(), E7(t), t.resetAfterSubmit.propertyView({
        label: _2("jsonSchemaForm.resetAfterSubmit")
      })]
    }), ((0, import_react.useContext)(Vr2).editorModeStatus === "layout" || (0, import_react.useContext)(Vr2).editorModeStatus === "both") && N2(p1, {
      children: [d(ka2, {
        name: b0.style,
        children: t.style.getPropertyView()
      }), d(ka2, {
        name: b0.animationStyle,
        hasTooltip: true,
        children: t.animationStyle.getPropertyView()
      })]
    })]
  })).build();
}();
var pa = H0(rI, [HQe({
  name: "data",
  desc: _2("jsonSchemaForm.dataDesc"),
  depKeys: ["schema", "data"],
  func: (e) => Hs(e.schema, e.data)
}), s2e]);
pa = N0(pa, [{
  method: {
    name: "submit",
    description: _2("export.submitDesc"),
    params: []
  },
  // FIXME: currently, it cannot be verified when submitted through the method, fix it later
  execute: (e, t) => $d({
    resetAfterSubmit: e.children.resetAfterSubmit.getView(),
    data: e.children.data.getView(),
    onEvent: e.children.onEvent.getView()
  })
}]);
var _I = pa;

export {
  _I
};
/*! Bundled license information:

lowcoder-sdk/dist/ab9066e0.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)
*/
//# sourceMappingURL=chunk-2NZXCLGZ.js.map
