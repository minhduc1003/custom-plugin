import {
  E7,
  Fj1,
  Gse,
  H0,
  M2,
  N,
  QU1,
  VS,
  Vr,
  XW1,
  _,
  ao,
  b0,
  ca,
  d,
  ka,
  nc,
  p1,
  qse,
  s2e,
  t2,
  vo
} from "./chunk-2ZELARZW.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/92be2a34.js
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var tt = Object.defineProperty;
var S = Object.getOwnPropertySymbols;
var Q = Object.prototype.hasOwnProperty;
var z = Object.prototype.propertyIsEnumerable;
var T = (s, r, h) => r in s ? tt(s, r, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: h
}) : s[r] = h;
var et = (s, r) => {
  for (var h in r || (r = {}))
    Q.call(r, h) && T(s, h, r[h]);
  if (S)
    for (var h of S(r))
      z.call(r, h) && T(s, h, r[h]);
  return s;
};
var nt = (s, r) => {
  var h = {};
  for (var a in s)
    Q.call(s, a) && r.indexOf(a) < 0 && (h[a] = s[a]);
  if (s != null && S)
    for (var a of S(s))
      r.indexOf(a) < 0 && z.call(s, a) && (h[a] = s[a]);
  return h;
};
var A;
((s) => {
  const r = class {
    constructor(t, e, n, o) {
      if (this.version = t, this.errorCorrectionLevel = e, this.modules = [], this.isFunction = [], t < r.MIN_VERSION || t > r.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (o < -1 || o > 7)
        throw new RangeError("Mask value out of range");
      this.size = t * 4 + 17;
      let i = [];
      for (let l = 0; l < this.size; l++)
        i.push(false);
      for (let l = 0; l < this.size; l++)
        this.modules.push(i.slice()), this.isFunction.push(i.slice());
      this.drawFunctionPatterns();
      const u = this.addEccAndInterleave(n);
      if (this.drawCodewords(u), o == -1) {
        let l = 1e9;
        for (let m = 0; m < 8; m++) {
          this.applyMask(m), this.drawFormatBits(m);
          const d2 = this.getPenaltyScore();
          d2 < l && (o = m, l = d2), this.applyMask(m);
        }
      }
      c(0 <= o && o <= 7), this.mask = o, this.applyMask(o), this.drawFormatBits(o), this.isFunction = [];
    }
    static encodeText(t, e) {
      const n = s.QrSegment.makeSegments(t);
      return r.encodeSegments(n, e);
    }
    static encodeBinary(t, e) {
      const n = s.QrSegment.makeBytes(t);
      return r.encodeSegments([n], e);
    }
    static encodeSegments(t, e, n = 1, o = 40, i = -1, u = true) {
      if (!(r.MIN_VERSION <= n && n <= o && o <= r.MAX_VERSION) || i < -1 || i > 7)
        throw new RangeError("Invalid value");
      let l, m;
      for (l = n; ; l++) {
        const C = r.getNumDataCodewords(l, e) * 8, w = E.getTotalBits(t, l);
        if (w <= C) {
          m = w;
          break;
        }
        if (l >= o)
          throw new RangeError("Data too long");
      }
      for (const C of [r.Ecc.MEDIUM, r.Ecc.QUARTILE, r.Ecc.HIGH])
        u && m <= r.getNumDataCodewords(l, C) * 8 && (e = C);
      let d2 = [];
      for (const C of t) {
        a(C.mode.modeBits, 4, d2), a(C.numChars, C.mode.numCharCountBits(l), d2);
        for (const w of C.getData())
          d2.push(w);
      }
      c(d2.length == m);
      const p = r.getNumDataCodewords(l, e) * 8;
      c(d2.length <= p), a(0, Math.min(4, p - d2.length), d2), a(0, (8 - d2.length % 8) % 8, d2), c(d2.length % 8 == 0);
      for (let C = 236; d2.length < p; C ^= 253)
        a(C, 8, d2);
      let y = [];
      for (; y.length * 8 < d2.length; )
        y.push(0);
      return d2.forEach((C, w) => y[w >>> 3] |= C << 7 - (w & 7)), new r(l, e, y, i);
    }
    getModule(t, e) {
      return 0 <= t && t < this.size && 0 <= e && e < this.size && this.modules[e][t];
    }
    getModules() {
      return this.modules;
    }
    drawFunctionPatterns() {
      for (let n = 0; n < this.size; n++)
        this.setFunctionModule(6, n, n % 2 == 0), this.setFunctionModule(n, 6, n % 2 == 0);
      this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4);
      const t = this.getAlignmentPatternPositions(), e = t.length;
      for (let n = 0; n < e; n++)
        for (let o = 0; o < e; o++)
          n == 0 && o == 0 || n == 0 && o == e - 1 || n == e - 1 && o == 0 || this.drawAlignmentPattern(t[n], t[o]);
      this.drawFormatBits(0), this.drawVersion();
    }
    drawFormatBits(t) {
      const e = this.errorCorrectionLevel.formatBits << 3 | t;
      let n = e;
      for (let i = 0; i < 10; i++)
        n = n << 1 ^ (n >>> 9) * 1335;
      const o = (e << 10 | n) ^ 21522;
      c(o >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, g(o, i));
      this.setFunctionModule(8, 7, g(o, 6)), this.setFunctionModule(8, 8, g(o, 7)), this.setFunctionModule(7, 8, g(o, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, g(o, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, g(o, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, g(o, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    drawVersion() {
      if (this.version < 7)
        return;
      let t = this.version;
      for (let n = 0; n < 12; n++)
        t = t << 1 ^ (t >>> 11) * 7973;
      const e = this.version << 12 | t;
      c(e >>> 18 == 0);
      for (let n = 0; n < 18; n++) {
        const o = g(e, n), i = this.size - 11 + n % 3, u = Math.floor(n / 3);
        this.setFunctionModule(i, u, o), this.setFunctionModule(u, i, o);
      }
    }
    drawFinderPattern(t, e) {
      for (let n = -4; n <= 4; n++)
        for (let o = -4; o <= 4; o++) {
          const i = Math.max(Math.abs(o), Math.abs(n)), u = t + o, l = e + n;
          0 <= u && u < this.size && 0 <= l && l < this.size && this.setFunctionModule(u, l, i != 2 && i != 4);
        }
    }
    drawAlignmentPattern(t, e) {
      for (let n = -2; n <= 2; n++)
        for (let o = -2; o <= 2; o++)
          this.setFunctionModule(t + o, e + n, Math.max(Math.abs(o), Math.abs(n)) != 1);
    }
    setFunctionModule(t, e, n) {
      this.modules[e][t] = n, this.isFunction[e][t] = true;
    }
    addEccAndInterleave(t) {
      const e = this.version, n = this.errorCorrectionLevel;
      if (t.length != r.getNumDataCodewords(e, n))
        throw new RangeError("Invalid argument");
      const o = r.NUM_ERROR_CORRECTION_BLOCKS[n.ordinal][e], i = r.ECC_CODEWORDS_PER_BLOCK[n.ordinal][e], u = Math.floor(r.getNumRawDataModules(e) / 8), l = o - u % o, m = Math.floor(u / o);
      let d2 = [];
      const p = r.reedSolomonComputeDivisor(i);
      for (let C = 0, w = 0; C < o; C++) {
        let _2 = t.slice(w, w + m - i + (C < l ? 0 : 1));
        w += _2.length;
        const H = r.reedSolomonComputeRemainder(_2, p);
        C < l && _2.push(0), d2.push(_2.concat(H));
      }
      let y = [];
      for (let C = 0; C < d2[0].length; C++)
        d2.forEach((w, _2) => {
          (C != m - i || _2 >= l) && y.push(w[C]);
        });
      return c(y.length == u), y;
    }
    drawCodewords(t) {
      if (t.length != Math.floor(r.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let e = 0;
      for (let n = this.size - 1; n >= 1; n -= 2) {
        n == 6 && (n = 5);
        for (let o = 0; o < this.size; o++)
          for (let i = 0; i < 2; i++) {
            const u = n - i, m = (n + 1 & 2) == 0 ? this.size - 1 - o : o;
            !this.isFunction[m][u] && e < t.length * 8 && (this.modules[m][u] = g(t[e >>> 3], 7 - (e & 7)), e++);
          }
      }
      c(e == t.length * 8);
    }
    applyMask(t) {
      if (t < 0 || t > 7)
        throw new RangeError("Mask value out of range");
      for (let e = 0; e < this.size; e++)
        for (let n = 0; n < this.size; n++) {
          let o;
          switch (t) {
            case 0:
              o = (n + e) % 2 == 0;
              break;
            case 1:
              o = e % 2 == 0;
              break;
            case 2:
              o = n % 3 == 0;
              break;
            case 3:
              o = (n + e) % 3 == 0;
              break;
            case 4:
              o = (Math.floor(n / 3) + Math.floor(e / 2)) % 2 == 0;
              break;
            case 5:
              o = n * e % 2 + n * e % 3 == 0;
              break;
            case 6:
              o = (n * e % 2 + n * e % 3) % 2 == 0;
              break;
            case 7:
              o = ((n + e) % 2 + n * e % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          !this.isFunction[e][n] && o && (this.modules[e][n] = !this.modules[e][n]);
        }
    }
    getPenaltyScore() {
      let t = 0;
      for (let i = 0; i < this.size; i++) {
        let u = false, l = 0, m = [0, 0, 0, 0, 0, 0, 0];
        for (let d2 = 0; d2 < this.size; d2++)
          this.modules[i][d2] == u ? (l++, l == 5 ? t += r.PENALTY_N1 : l > 5 && t++) : (this.finderPenaltyAddHistory(l, m), u || (t += this.finderPenaltyCountPatterns(m) * r.PENALTY_N3), u = this.modules[i][d2], l = 1);
        t += this.finderPenaltyTerminateAndCount(u, l, m) * r.PENALTY_N3;
      }
      for (let i = 0; i < this.size; i++) {
        let u = false, l = 0, m = [0, 0, 0, 0, 0, 0, 0];
        for (let d2 = 0; d2 < this.size; d2++)
          this.modules[d2][i] == u ? (l++, l == 5 ? t += r.PENALTY_N1 : l > 5 && t++) : (this.finderPenaltyAddHistory(l, m), u || (t += this.finderPenaltyCountPatterns(m) * r.PENALTY_N3), u = this.modules[d2][i], l = 1);
        t += this.finderPenaltyTerminateAndCount(u, l, m) * r.PENALTY_N3;
      }
      for (let i = 0; i < this.size - 1; i++)
        for (let u = 0; u < this.size - 1; u++) {
          const l = this.modules[i][u];
          l == this.modules[i][u + 1] && l == this.modules[i + 1][u] && l == this.modules[i + 1][u + 1] && (t += r.PENALTY_N2);
        }
      let e = 0;
      for (const i of this.modules)
        e = i.reduce((u, l) => u + (l ? 1 : 0), e);
      const n = this.size * this.size, o = Math.ceil(Math.abs(e * 20 - n * 10) / n) - 1;
      return c(0 <= o && o <= 9), t += o * r.PENALTY_N4, c(0 <= t && t <= 2568888), t;
    }
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      {
        const t = Math.floor(this.version / 7) + 2, e = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (t * 2 - 2)) * 2;
        let n = [6];
        for (let o = this.size - 7; n.length < t; o -= e)
          n.splice(1, 0, o);
        return n;
      }
    }
    static getNumRawDataModules(t) {
      if (t < r.MIN_VERSION || t > r.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let e = (16 * t + 128) * t + 64;
      if (t >= 2) {
        const n = Math.floor(t / 7) + 2;
        e -= (25 * n - 10) * n - 55, t >= 7 && (e -= 36);
      }
      return c(208 <= e && e <= 29648), e;
    }
    static getNumDataCodewords(t, e) {
      return Math.floor(r.getNumRawDataModules(t) / 8) - r.ECC_CODEWORDS_PER_BLOCK[e.ordinal][t] * r.NUM_ERROR_CORRECTION_BLOCKS[e.ordinal][t];
    }
    static reedSolomonComputeDivisor(t) {
      if (t < 1 || t > 255)
        throw new RangeError("Degree out of range");
      let e = [];
      for (let o = 0; o < t - 1; o++)
        e.push(0);
      e.push(1);
      let n = 1;
      for (let o = 0; o < t; o++) {
        for (let i = 0; i < e.length; i++)
          e[i] = r.reedSolomonMultiply(e[i], n), i + 1 < e.length && (e[i] ^= e[i + 1]);
        n = r.reedSolomonMultiply(n, 2);
      }
      return e;
    }
    static reedSolomonComputeRemainder(t, e) {
      let n = e.map((o) => 0);
      for (const o of t) {
        const i = o ^ n.shift();
        n.push(0), e.forEach((u, l) => n[l] ^= r.reedSolomonMultiply(u, i));
      }
      return n;
    }
    static reedSolomonMultiply(t, e) {
      if (t >>> 8 || e >>> 8)
        throw new RangeError("Byte out of range");
      let n = 0;
      for (let o = 7; o >= 0; o--)
        n = n << 1 ^ (n >>> 7) * 285, n ^= (e >>> o & 1) * t;
      return c(n >>> 8 == 0), n;
    }
    finderPenaltyCountPatterns(t) {
      const e = t[1];
      c(e <= this.size * 3);
      const n = e > 0 && t[2] == e && t[3] == e * 3 && t[4] == e && t[5] == e;
      return (n && t[0] >= e * 4 && t[6] >= e ? 1 : 0) + (n && t[6] >= e * 4 && t[0] >= e ? 1 : 0);
    }
    finderPenaltyTerminateAndCount(t, e, n) {
      return t && (this.finderPenaltyAddHistory(e, n), e = 0), e += this.size, this.finderPenaltyAddHistory(e, n), this.finderPenaltyCountPatterns(n);
    }
    finderPenaltyAddHistory(t, e) {
      e[0] == 0 && (t += this.size), e.pop(), e.unshift(t);
    }
  };
  let h = r;
  h.MIN_VERSION = 1, h.MAX_VERSION = 40, h.PENALTY_N1 = 3, h.PENALTY_N2 = 3, h.PENALTY_N3 = 40, h.PENALTY_N4 = 10, h.ECC_CODEWORDS_PER_BLOCK = [[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]], h.NUM_ERROR_CORRECTION_BLOCKS = [[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]], s.QrCode = h;
  function a(t, e, n) {
    if (e < 0 || e > 31 || t >>> e)
      throw new RangeError("Value out of range");
    for (let o = e - 1; o >= 0; o--)
      n.push(t >>> o & 1);
  }
  function g(t, e) {
    return (t >>> e & 1) != 0;
  }
  function c(t) {
    if (!t)
      throw new Error("Assertion error");
  }
  const f = class {
    constructor(t, e, n) {
      if (this.mode = t, this.numChars = e, this.bitData = n, e < 0)
        throw new RangeError("Invalid argument");
      this.bitData = n.slice();
    }
    static makeBytes(t) {
      let e = [];
      for (const n of t)
        a(n, 8, e);
      return new f(f.Mode.BYTE, t.length, e);
    }
    static makeNumeric(t) {
      if (!f.isNumeric(t))
        throw new RangeError("String contains non-numeric characters");
      let e = [];
      for (let n = 0; n < t.length; ) {
        const o = Math.min(t.length - n, 3);
        a(parseInt(t.substr(n, o), 10), o * 3 + 1, e), n += o;
      }
      return new f(f.Mode.NUMERIC, t.length, e);
    }
    static makeAlphanumeric(t) {
      if (!f.isAlphanumeric(t))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let e = [], n;
      for (n = 0; n + 2 <= t.length; n += 2) {
        let o = f.ALPHANUMERIC_CHARSET.indexOf(t.charAt(n)) * 45;
        o += f.ALPHANUMERIC_CHARSET.indexOf(t.charAt(n + 1)), a(o, 11, e);
      }
      return n < t.length && a(f.ALPHANUMERIC_CHARSET.indexOf(t.charAt(n)), 6, e), new f(f.Mode.ALPHANUMERIC, t.length, e);
    }
    static makeSegments(t) {
      return t == "" ? [] : f.isNumeric(t) ? [f.makeNumeric(t)] : f.isAlphanumeric(t) ? [f.makeAlphanumeric(t)] : [f.makeBytes(f.toUtf8ByteArray(t))];
    }
    static makeEci(t) {
      let e = [];
      if (t < 0)
        throw new RangeError("ECI assignment value out of range");
      if (t < 128)
        a(t, 8, e);
      else if (t < 16384)
        a(2, 2, e), a(t, 14, e);
      else if (t < 1e6)
        a(6, 3, e), a(t, 21, e);
      else
        throw new RangeError("ECI assignment value out of range");
      return new f(f.Mode.ECI, 0, e);
    }
    static isNumeric(t) {
      return f.NUMERIC_REGEX.test(t);
    }
    static isAlphanumeric(t) {
      return f.ALPHANUMERIC_REGEX.test(t);
    }
    getData() {
      return this.bitData.slice();
    }
    static getTotalBits(t, e) {
      let n = 0;
      for (const o of t) {
        const i = o.mode.numCharCountBits(e);
        if (o.numChars >= 1 << i)
          return 1 / 0;
        n += 4 + i + o.bitData.length;
      }
      return n;
    }
    static toUtf8ByteArray(t) {
      t = encodeURI(t);
      let e = [];
      for (let n = 0; n < t.length; n++)
        t.charAt(n) != "%" ? e.push(t.charCodeAt(n)) : (e.push(parseInt(t.substr(n + 1, 2), 16)), n += 2);
      return e;
    }
  };
  let E = f;
  E.NUMERIC_REGEX = /^[0-9]*$/, E.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, E.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:", s.QrSegment = E;
})(A || (A = {}));
((s) => {
  ((r) => {
    const h = class {
      constructor(g, c) {
        this.ordinal = g, this.formatBits = c;
      }
    };
    let a = h;
    a.LOW = new h(0, 1), a.MEDIUM = new h(1, 0), a.QUARTILE = new h(2, 3), a.HIGH = new h(3, 2), r.Ecc = a;
  })(s.QrCode || (s.QrCode = {}));
})(A || (A = {}));
((s) => {
  ((r) => {
    const h = class {
      constructor(g, c) {
        this.modeBits = g, this.numBitsCharCount = c;
      }
      numCharCountBits(g) {
        return this.numBitsCharCount[Math.floor((g + 7) / 17)];
      }
    };
    let a = h;
    a.NUMERIC = new h(1, [10, 12, 14]), a.ALPHANUMERIC = new h(2, [9, 11, 13]), a.BYTE = new h(4, [8, 16, 16]), a.KANJI = new h(8, [8, 10, 12]), a.ECI = new h(7, [0, 0, 0]), r.Mode = a;
  })(s.QrSegment || (s.QrSegment = {}));
})(A || (A = {}));
var b = A;
var ot = {
  L: b.QrCode.Ecc.LOW,
  M: b.QrCode.Ecc.MEDIUM,
  Q: b.QrCode.Ecc.QUARTILE,
  H: b.QrCode.Ecc.HIGH
};
var it = 128;
var rt = "L";
var st = "#FFFFFF";
var at = "#000000";
var lt = false;
var U = 4;
var ht = 0.1;
function ut(s, r = 0) {
  const h = [];
  return s.forEach(function(a, g) {
    let c = null;
    a.forEach(function(f, E) {
      if (!f && c !== null) {
        h.push(`M${c + r} ${g + r}h${E - c}v1H${c + r}z`), c = null;
        return;
      }
      if (E === a.length - 1) {
        if (!f)
          return;
        c === null ? h.push(`M${E + r},${g + r} h1v1H${E + r}z`) : h.push(`M${c + r},${g + r} h${E + 1 - c}v1H${c + r}z`);
        return;
      }
      f && c === null && (c = E);
    });
  }), h.join("");
}
function ct(s, r) {
  return s.slice().map((h, a) => a < r.y || a >= r.y + r.h ? h : h.map((g, c) => c < r.x || c >= r.x + r.w ? g : false));
}
function dt(s, r, h, a) {
  if (a == null)
    return null;
  const g = h ? U : 0, c = s.length + g * 2, f = Math.floor(r * ht), E = c / r, t = (a.width || f) * E, e = (a.height || f) * E, n = a.x == null ? s.length / 2 - t / 2 : a.x * E, o = a.y == null ? s.length / 2 - e / 2 : a.y * E;
  let i = null;
  if (a.excavate) {
    let u = Math.floor(n), l = Math.floor(o), m = Math.ceil(t + n - u), d2 = Math.ceil(e + o - l);
    i = {
      x: u,
      y: l,
      w: m,
      h: d2
    };
  }
  return {
    x: n,
    y: o,
    h: e,
    w: t,
    excavation: i
  };
}
(function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch {
    return false;
  }
  return true;
})();
function ft(s) {
  const r = s, {
    value: h,
    size: a = it,
    level: g = rt,
    bgColor: c = st,
    fgColor: f = at,
    includeMargin: E = lt,
    imageSettings: t
  } = r, e = nt(r, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]);
  let n = b.QrCode.encodeText(h, ot[g]).getModules();
  const o = E ? U : 0, i = n.length + o * 2, u = dt(n, a, E, t);
  let l = null;
  t != null && u != null && (u.excavation != null && (n = ct(n, u.excavation)), l = d("image", {
    xlinkHref: t.src,
    height: u.h,
    width: u.w,
    x: u.x + o,
    y: u.y + o,
    preserveAspectRatio: "none"
  }));
  const m = ut(n, o);
  return N("svg", {
    ...et({
      height: a,
      width: a,
      viewBox: `0 0 ${i} ${i}`
    }, e),
    children: [d("path", {
      fill: c,
      d: `M0,0 h${i}v${i}H0z`,
      shapeRendering: "crispEdges"
    }), d("path", {
      fill: f,
      d: m,
      shapeRendering: "crispEdges"
    }), l]
  });
}
var mt = [{
  label: _("QRCode.L"),
  value: "L"
}, {
  label: _("QRCode.M"),
  value: "M"
}, {
  label: _("QRCode.Q"),
  value: "Q"
}, {
  label: _("QRCode.H"),
  value: "H"
}];
var gt = {
  value: QU1("value"),
  level: ca(mt, "L"),
  includeMargin: ao.DEFAULT_TRUE,
  image: M2,
  style: nc(XW1, "style"),
  animationStyle: nc(Fj1, "animationStyle"),
  restrictPaddingOnRotation: t2(M2, "qrCode")
};
var Ct = (s) => {
  const r = s.value.value;
  return r.length > 2953 ? d(p1, {
    children: _("QRCode.maxLength")
  }) : d("div", {
    style: {
      margin: s.style.margin,
      padding: s.includeMargin ? s.style.padding : 0,
      width: qse(s.style.margin),
      height: Gse(s.style.margin),
      background: s.style.background,
      borderRadius: s.style.radius,
      border: `${s.style.borderWidth ? s.style.borderWidth : "1px"} solid ${s.style.border}`,
      rotate: s.style.rotation,
      animation: s.animationStyle.animation,
      animationDelay: s.animationStyle.animationDelay,
      animationDuration: s.animationStyle.animationDuration,
      animationIterationCount: s.animationStyle.animationIterationCount
    },
    children: d(ft, {
      value: r,
      level: s.level,
      width: "100%",
      height: "100%",
      bgColor: s.style.background,
      fgColor: s.style.color,
      includeMargin: false,
      imageSettings: s.image ? {
        src: s.image,
        width: 0,
        height: 0,
        excavate: true
      } : void 0
    })
  });
};
var L = function() {
  return new VS(gt, (s) => d(Ct, {
    ...s
  })).setPropertyViewFn((s) => N(p1, {
    children: [d(ka, {
      name: b0.basic,
      children: s.value.propertyView({
        label: _("QRCode.value"),
        tooltip: _("QRCode.valueTooltip"),
        placeholder: "https://example.com"
      })
    }), ["logic", "both"].includes((0, import_react.useContext)(Vr).editorModeStatus) && N(p1, {
      children: [d(ka, {
        name: b0.interaction,
        children: E7(s)
      }), N(ka, {
        name: b0.advanced,
        children: [s.level.propertyView({
          label: _("QRCode.level"),
          tooltip: _("QRCode.levelTooltip")
        }), s.image.propertyView({
          label: _("QRCode.image"),
          placeholder: "http://logo.jpg"
        })]
      })]
    }), ["layout", "both"].includes((0, import_react.useContext)(Vr).editorModeStatus) && N(p1, {
      children: [N(ka, {
        name: b0.style,
        children: [s.style.getPropertyView(), s.includeMargin.propertyView({
          label: _("QRCode.includeMargin")
        })]
      }), d(ka, {
        name: b0.animationStyle,
        hasTooltip: true,
        children: s.animationStyle.getPropertyView()
      })]
    })]
  })).build();
}();
L = class extends L {
  autoHeight() {
    return false;
  }
};
var Rt = H0(L, [new vo("value", _("QRCode.valueDesc")), s2e]);

export {
  Rt
};
/*! Bundled license information:

lowcoder-sdk/dist/92be2a34.js:
  (**
   * @license qrcode.react
   * Copyright (c) Paul O'Shannessy
   * SPDX-License-Identifier: ISC
   *)
*/
//# sourceMappingURL=chunk-URMB2UL2.js.map
