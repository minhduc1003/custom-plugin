import {
  Ct,
  E7,
  EW1,
  F2e,
  FX,
  Fj1,
  H0,
  H3,
  IC,
  Jf,
  LH,
  N,
  OU1,
  QU1,
  Qf,
  R6n,
  T2,
  VS,
  Vr,
  XN,
  Zj1,
  _,
  ao,
  b0,
  b2e,
  bW1,
  d,
  de,
  dee,
  eee,
  gM,
  h1,
  h2,
  k3,
  ka,
  nV,
  nc,
  p1,
  qC,
  s2e,
  s4,
  t2,
  v6e,
  vc,
  vo,
  ya,
  zc,
  zf
} from "./chunk-2ZELARZW.js";
import {
  require_react_dom
} from "./chunk-VGGCA2L5.js";
import {
  require_react
} from "./chunk-73THXJN7.js";
import {
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/lowcoder-sdk/dist/85c8d626.js
var import_react = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var Ce = [{
  label: _("tabbedContainer.switchTab"),
  value: "change",
  description: _("tabbedContainer.switchTabDesc")
}];
var we = {
  tabs: OU1,
  selectedTabKey: QU1("key", "Tab1"),
  containers: t2(dee(nV), {
    0: {
      layout: {},
      items: {}
    },
    1: {
      layout: {},
      items: {}
    }
  }),
  autoHeight: gM,
  horizontalGridCells: v6e,
  scrollbars: t2(ao, false),
  placement: t2(F2e, "top"),
  onEvent: ya(Ce),
  disabled: H3,
  showHeader: t2(ao, true),
  style: nc(bW1, "style"),
  headerStyle: nc(Zj1, "headerStyle"),
  bodyStyle: nc(EW1, "bodyStyle"),
  animationStyle: nc(Fj1, "animationStyle"),
  tabsGutter: t2(vc, 32),
  tabsCentered: t2(ao, false)
};
var Se = (e, t, a) => T2`
    &.ant-tabs {
      overflow: hidden;
      border: ${e.borderWidth} ${e.borderStyle} ${e.border};
      border-radius: ${e.radius};
      padding: ${e.padding};
      background-color: ${e.background};
      background-image: url(${e.backgroundImage});
      background-repeat: ${e.backgroundImageRepeat};
      background-size: ${e.backgroundImageSize};
      background-position: ${e.backgroundImagePosition};
      background-origin: ${e.backgroundImageOrigin};

      > .ant-tabs-content-holder > .ant-tabs-content > .ant-tabs-tabpane {
        height: 100%;
        .react-grid-layout {
          border-radius: 0;
          background-color: ${a.background || "transparent"};
          padding: ${a.containerBodyPadding};
        }
      }

      > .ant-tabs-nav {
        background-color: ${t.headerBackground || "transparent"};
        padding: ${t.containerHeaderPadding};

        .ant-tabs-tab {
          div {
            color: #8b8fa3;
          }

          &.ant-tabs-tab-active div {
            color: ${e.accent};
          }
        }

        .ant-tabs-tab-btn {
          color: ${e.tabText} !important;
          font-size: ${e.textSize};
          font-family:${e.fontFamily};
          font-weight:${e.textWeight};
          text-transform:${e.textTransform};
          text-decoration:${e.textDecoration};
          font-style:${e.fontStyle};
        }

        .ant-tabs-ink-bar {
          background-color: ${e.accent};
        }

        ::before {
          border-color: ${e.border};
        }
      }
    }
  `;
var fe = de(FX)`
  &.ant-tabs {
    height: 100%;
    ${(e) => e.$animationStyle}
  }

  .ant-tabs-content-animated {
    transition-duration: 0ms;
  }

  .ant-tabs-content {
    height: 100%;
    // margin-top: -16px;
  }

  .ant-tabs-nav {
    display: ${(e) => e.$showHeader ? "block" : "none"};
    padding: 0 ${(e) => e.$isMobile ? 16 : 24}px;
    background: white;
    margin: 0px;
  }

  .ant-tabs-tab + .ant-tabs-tab {
    margin: 0 0 0 20px;
  }

  .ant-tabs-nav-operations {
    margin-right: -24px;
  }

  ${(e) => e.$style && Se(e.$style, e.$headerStyle, e.$bodyStyle)}
`;
var Te = (e) => d(Jf, {
  ...e,
  emptyRows: 15,
  hintPlaceholder: LH
});
var $e = (e) => {
  let {
    tabs: t,
    containers: a,
    dispatch: n,
    style: o,
    headerStyle: l,
    bodyStyle: i,
    horizontalGridCells: O
  } = e;
  const p = t.filter((r) => !r.hidden), k = p.find((r) => r.key === e.selectedTabKey.value), M = k ? k.key : p.length > 0 ? p[0].key : void 0, B = (0, import_react.useCallback)((r, m) => {
    const h = m.target;
    h.parentNode.click ? h.parentNode.click() : h.parentNode.parentNode.click();
  }, []), G = (0, import_react.useContext)(Vr).getAppSettings().maxWidth, v = zf(G), N2 = e.showHeader.valueOf(), K = v ? 8 : 0, z = p.map((r) => {
    const m = String(r.id), h = k3(k3(n, "containers"), m), C = a[m].children, x = r.icon.props.value;
    return {
      label: N(p1, {
        children: [r.iconPosition === "left" && x && d("span", {
          style: {
            marginRight: "4px"
          },
          children: r.icon
        }), r.label, r.iconPosition === "right" && x && d("span", {
          style: {
            marginLeft: "4px"
          },
          children: r.icon
        })]
      }),
      key: r.key,
      forceRender: true,
      children: d(Qf.Provider, {
        value: i.background,
        children: d(zc, {
          style: {
            height: e.autoHeight ? "100%" : "auto",
            margin: "0px",
            padding: "0px"
          },
          hideScrollbar: !e.scrollbars,
          children: d(Te, {
            layout: C.layout.getView(),
            items: IC(C.items.getView()),
            horizontalGridCells: O,
            positionParams: C.positionParams.getView(),
            dispatch: h,
            autoHeight: e.autoHeight,
            containerPadding: [K, 20]
          })
        })
      })
    };
  });
  return d(zc, {
    style: {
      height: e.autoHeight ? "100%" : "auto",
      margin: "0px",
      padding: "0px"
    },
    hideScrollbar: !e.scrollbars,
    children: d("div", {
      style: {
        padding: e.style.margin,
        height: e.autoHeight ? "100%" : "auto"
      },
      children: d(Qf.Provider, {
        value: l.headerBackground,
        children: d(fe, {
          $animationStyle: e.animationStyle,
          tabPosition: e.placement,
          activeKey: M,
          $style: o,
          $headerStyle: l,
          $bodyStyle: i,
          $showHeader: N2,
          onChange: (r) => {
            r !== e.selectedTabKey.value && (e.selectedTabKey.onChange(r), e.onEvent("change"));
          },
          onTabClick: B,
          animated: true,
          $isMobile: v,
          items: z,
          tabBarGutter: e.tabsGutter,
          centered: e.tabsCentered
        })
      })
    })
  });
};
var Ve = function() {
  return new VS(we, (e, t) => d(b2e.Provider, {
    value: e.disabled,
    children: d($e, {
      ...e,
      dispatch: t
    })
  })).setPropertyViewFn((e) => N(p1, {
    children: [N(ka, {
      name: b0.basic,
      children: [e.tabs.propertyView({
        title: _("tabbedContainer.tab"),
        newOptionLabel: "Tab"
      }), e.selectedTabKey.propertyView({
        label: _("prop.defaultValue")
      })]
    }), ["logic", "both"].includes((0, import_react.useContext)(Vr).editorModeStatus) && N(ka, {
      name: b0.interaction,
      children: [e.onEvent.getPropertyView(), qC(e), e.showHeader.propertyView({
        label: _("tabbedContainer.showTabs")
      }), E7(e)]
    }), ["layout", "both"].includes((0, import_react.useContext)(Vr).editorModeStatus) && N(p1, {
      children: [N(ka, {
        name: b0.layout,
        children: [e.placement.propertyView({
          label: _("tabbedContainer.placement"),
          radioButton: true
        }), e.tabsCentered.propertyView({
          label: _("tabbedContainer.tabsCentered")
        }), e.tabsGutter.propertyView({
          label: _("tabbedContainer.gutter"),
          tooltip: _("tabbedContainer.gutterTooltip")
        }), e.horizontalGridCells.propertyView({
          label: _("prop.horizontalGridCells")
        }), e.autoHeight.getPropertyView(), !e.autoHeight.getView() && e.scrollbars.propertyView({
          label: _("prop.scrollbar")
        })]
      }), d(ka, {
        name: b0.style,
        children: e.style.getPropertyView()
      }), e.showHeader.getView() && d(ka, {
        name: "Header Style",
        children: e.headerStyle.getPropertyView()
      }), d(ka, {
        name: "Body Style",
        children: e.bodyStyle.getPropertyView()
      }), d(ka, {
        name: b0.animationStyle,
        hasTooltip: true,
        children: e.animationStyle.getPropertyView()
      })]
    })]
  })).build();
}();
var ke = class extends Ve {
  syncContainers() {
    const t = this.children.tabs.getView(), a = new Set(t.map((i) => String(i.id)));
    let n = this.children.containers.getView();
    const o = [];
    Object.keys(n).forEach((i) => {
      a.has(i) || o.push(s4("containers", s4(i, eee())));
    }), a.forEach((i) => {
      n.hasOwnProperty(i) || o.push(s4("containers", XN(i, {
        layout: {},
        items: {}
      })));
    });
    let l = this;
    return o.forEach((i) => {
      l = l.reduce(i);
    }), l;
  }
  reduce(t) {
    if (t.type === h2.CUSTOM) {
      const n = t.value;
      if (n.type === "push") {
        const o = n.value;
        h1.isEmpty(o.key) && (o.key = o.label), t = {
          ...t,
          value: {
            ...n,
            value: {
              ...o
            }
          }
        };
      }
      if (n.type === "delete" && this.children.tabs.getView().length <= 1)
        return Ct.warning(_("tabbedContainer.atLeastOneTabError")), this;
    }
    let a = super.reduce(t);
    return t.type === h2.UPDATE_NODES_V2 && (a = a.syncContainers()), a;
  }
  realSimpleContainer(t) {
    let a = this.children.selectedTabKey.getView().value;
    const n = this.children.tabs.getView(), o = n.find((i) => i.key === a) ?? n[0], l = String(o.id);
    return h1.isNil(t) ? this.children.containers.children[l] : Object.values(this.children.containers.children).find((i) => i.realSimpleContainer(t));
  }
  getCompTree() {
    const t = this.children.containers.getView(), a = Object.values(t).map((n) => n.getCompTree());
    return R6n(a);
  }
  findContainer(t) {
    const a = this.children.containers.getView();
    for (const n of Object.values(a)) {
      const o = n.findContainer(t);
      if (o)
        return o === n ? this : o;
    }
  }
  getPasteValue(t) {
    const a = this.children.containers.getView(), n = h1.mapValues(a, (o) => o.getPasteValue(t));
    return {
      ...this.toJsonValue(),
      containers: n
    };
  }
  autoHeight() {
    return this.children.autoHeight.getView();
  }
};
var Ee = H0(ke, [new vo("selectedTabKey", _("tabbedContainer.selectedTabKeyDesc")), s2e]);

export {
  Ve,
  Ee
};
//# sourceMappingURL=chunk-PKMFW2Z4.js.map
