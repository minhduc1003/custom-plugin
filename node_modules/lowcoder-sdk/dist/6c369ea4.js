import { ly as w, i6 as Xe, lz as Y, lA as p, lB as q, lC as de, lD as ue, lE as he, lF as v, lG as fe, lH as ke, lI as Ye, X as D, fw as qe, a8 as M, G as ae, F as m, Y as O, eB as Je, ge as Qe, lJ as Ze, lK as _e, fK as Oe, lL as z, f5 as le, l9 as et, lM as tt, lN as nt, lO as rt, gg as it, _ as ot, cG as ne, ls as at, iS as se, lP as lt, lQ as st, dP as be, H as ct } from "./c988e26e.js";
import { createContext as dt, createRef as pe, createElement as te, Component as me, useState as De, useEffect as Q } from "react";
import { getDataSourceTypeConfig as ut } from "./f52ee168.js";
import { findDOMNode as ge } from "react-dom";
import "./de2e4e92.js";
import "./bf2ffa97.js";
import "./90e6d3f7.js";
import "./3eacf14a.js";
import "./a353f3e4.js";
import "./a6ed71f1.js";
function re(t) {
  for (var n = 1; n < arguments.length; n++) {
    var r = arguments[n] != null ? Object(arguments[n]) : {}, o = Object.keys(r);
    typeof Object.getOwnPropertySymbols == "function" && o.push.apply(o, Object.getOwnPropertySymbols(r).filter(function(l) {
      return Object.getOwnPropertyDescriptor(r, l).enumerable;
    })), o.forEach(function(l) {
      w(t, l, r[l]);
    });
  }
  return t;
}
var ht = function(t, n, r, o, l, s, d, e) {
  if (process.env.NODE_ENV !== "production" && n === void 0)
    throw new Error("invariant requires an error message argument");
  if (!t) {
    var f;
    if (n === void 0)
      f = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var i = [r, o, l, s, d, e], c = 0;
      f = new Error(
        n.replace(/%s/g, function() {
          return i[c++];
        })
      ), f.name = "Invariant Violation";
    }
    throw f.framesToPop = 1, f;
  }
}, ft = ht;
const F = /* @__PURE__ */ Xe(ft);
var pt = function() {
  function t() {
    q(this, t), w(this, "refs", {});
  }
  return Y(t, [{
    key: "add",
    value: function(r, o) {
      this.refs[r] || (this.refs[r] = []), this.refs[r].push(o);
    }
  }, {
    key: "remove",
    value: function(r, o) {
      var l = this.getIndex(r, o);
      l !== -1 && this.refs[r].splice(l, 1);
    }
  }, {
    key: "isActive",
    value: function() {
      return this.active;
    }
  }, {
    key: "getActive",
    value: function() {
      var r = this;
      return this.refs[this.active.collection].find(function(o) {
        var l = o.node;
        return l.sortableInfo.index == r.active.index;
      });
    }
  }, {
    key: "getIndex",
    value: function(r, o) {
      return this.refs[r].indexOf(o);
    }
  }, {
    key: "getOrderedRefs",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.active.collection;
      return this.refs[r].sort(mt);
    }
  }]), t;
}();
function mt(t, n) {
  var r = t.node.sortableInfo.index, o = n.node.sortableInfo.index;
  return r - o;
}
function gt(t, n, r) {
  return process.env.NODE_ENV !== "production" && typeof console < "u" && console.warn("Deprecation warning: arrayMove will no longer be exported by 'react-sortable-hoc' in the next major release. Please install the `array-move` package locally instead. https://www.npmjs.com/package/array-move"), t = t.slice(), t.splice(r < 0 ? t.length + r : r, 0, t.splice(n, 1)[0]), t;
}
function Re(t, n) {
  return Object.keys(t).reduce(function(r, o) {
    return n.indexOf(o) === -1 && (r[o] = t[o]), r;
  }, {});
}
var G = {
  end: ["touchend", "touchcancel", "mouseup"],
  move: ["touchmove", "mousemove"],
  start: ["touchstart", "mousedown"]
}, Ne = function() {
  if (typeof window > "u" || typeof document > "u")
    return "";
  var t = window.getComputedStyle(document.documentElement, "") || ["-moz-hidden-iframe"], n = (Array.prototype.slice.call(t).join("").match(/-(moz|webkit|ms)-/) || t.OLink === "" && ["", "o"])[1];
  switch (n) {
    case "ms":
      return "ms";
    default:
      return n && n.length ? n[0].toUpperCase() + n.substr(1) : "";
  }
}();
function Z(t, n) {
  Object.keys(n).forEach(function(r) {
    t.style[r] = n[r];
  });
}
function _(t, n) {
  t.style["".concat(Ne, "Transform")] = n == null ? "" : "translate3d(".concat(n.x, "px,").concat(n.y, "px,0)");
}
function ie(t, n) {
  t.style["".concat(Ne, "TransitionDuration")] = n == null ? "" : "".concat(n, "ms");
}
function X(t, n) {
  for (; t; ) {
    if (n(t))
      return t;
    t = t.parentNode;
  }
  return null;
}
function we(t, n, r) {
  return Math.max(t, Math.min(r, n));
}
function j(t) {
  return t.substr(-2) === "px" ? parseFloat(t) : 0;
}
function vt(t) {
  var n = window.getComputedStyle(t);
  return {
    bottom: j(n.marginBottom),
    left: j(n.marginLeft),
    right: j(n.marginRight),
    top: j(n.marginTop)
  };
}
function ve(t, n) {
  var r = n.displayName || n.name;
  return r ? "".concat(t, "(").concat(r, ")") : t;
}
function oe(t, n) {
  var r = t.getBoundingClientRect();
  return {
    top: r.top + n.top,
    left: r.left + n.left
  };
}
function V(t) {
  return t.touches && t.touches.length ? {
    x: t.touches[0].pageX,
    y: t.touches[0].pageY
  } : t.changedTouches && t.changedTouches.length ? {
    x: t.changedTouches[0].pageX,
    y: t.changedTouches[0].pageY
  } : {
    x: t.pageX,
    y: t.pageY
  };
}
function xt(t) {
  return t.touches && t.touches.length || t.changedTouches && t.changedTouches.length;
}
function ee(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    left: 0,
    top: 0
  };
  if (t) {
    var o = {
      left: r.left + t.offsetLeft,
      top: r.top + t.offsetTop
    };
    return t.parentNode === n ? o : ee(t.parentNode, n, o);
  }
}
function yt(t, n, r) {
  return t < r && t > n ? t - 1 : t > r && t < n ? t + 1 : t;
}
function Ce(t) {
  var n = t.lockOffset, r = t.width, o = t.height, l = n, s = n, d = "px";
  if (typeof n == "string") {
    var e = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(n);
    F(e !== null, 'lockOffset value should be a number or a string of a number followed by "px" or "%". Given %s', n), l = parseFloat(n), s = parseFloat(n), d = e[1];
  }
  return F(isFinite(l) && isFinite(s), "lockOffset value should be a finite. Given %s", n), d === "%" && (l = l * r / 100, s = s * o / 100), {
    x: l,
    y: s
  };
}
function bt(t) {
  var n = t.height, r = t.width, o = t.lockOffset, l = Array.isArray(o) ? o : [o, o];
  F(l.length === 2, "lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given %s", o);
  var s = ke(l, 2), d = s[0], e = s[1];
  return [Ce({
    height: n,
    lockOffset: d,
    width: r
  }), Ce({
    height: n,
    lockOffset: e,
    width: r
  })];
}
function wt(t) {
  var n = window.getComputedStyle(t), r = /(auto|scroll)/, o = ["overflow", "overflowX", "overflowY"];
  return o.find(function(l) {
    return r.test(n[l]);
  });
}
function Ae(t) {
  return t instanceof HTMLElement ? wt(t) ? t : Ae(t.parentNode) : null;
}
function Ct(t) {
  var n = window.getComputedStyle(t);
  return n.display === "grid" ? {
    x: j(n.gridColumnGap),
    y: j(n.gridRowGap)
  } : {
    x: 0,
    y: 0
  };
}
var B = {
  TAB: 9,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
}, H = {
  Anchor: "A",
  Button: "BUTTON",
  Canvas: "CANVAS",
  Input: "INPUT",
  Option: "OPTION",
  Textarea: "TEXTAREA",
  Select: "SELECT"
};
function St(t) {
  var n = "input, textarea, select, canvas, [contenteditable]", r = t.querySelectorAll(n), o = t.cloneNode(!0), l = Ye(o.querySelectorAll(n));
  return l.forEach(function(s, d) {
    if (s.type !== "file" && (s.value = r[d].value), s.type === "radio" && s.name && (s.name = "__sortableClone__".concat(s.name)), s.tagName === H.Canvas && r[d].width > 0 && r[d].height > 0) {
      var e = s.getContext("2d");
      e.drawImage(r[d], 0, 0);
    }
  }), o;
}
function Tt(t) {
  var n, r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    withRef: !1
  };
  return r = n = function(l) {
    de(s, l);
    function s() {
      var d, e;
      q(this, s);
      for (var f = arguments.length, i = new Array(f), c = 0; c < f; c++)
        i[c] = arguments[c];
      return e = ue(this, (d = he(s)).call.apply(d, [this].concat(i))), w(v(v(e)), "wrappedInstance", pe()), e;
    }
    return Y(s, [{
      key: "componentDidMount",
      value: function() {
        var e = ge(this);
        e.sortableHandle = !0;
      }
    }, {
      key: "getWrappedInstance",
      value: function() {
        return F(o.withRef, "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call"), this.wrappedInstance.current;
      }
    }, {
      key: "render",
      value: function() {
        var e = o.withRef ? this.wrappedInstance : null;
        return te(t, fe({
          ref: e
        }, this.props));
      }
    }]), s;
  }(me), w(n, "displayName", ve("sortableHandle", t)), r;
}
function Se(t) {
  return t.sortableHandle != null;
}
var It = function() {
  function t(n, r) {
    q(this, t), this.container = n, this.onScrollCallback = r;
  }
  return Y(t, [{
    key: "clear",
    value: function() {
      this.interval != null && (clearInterval(this.interval), this.interval = null);
    }
  }, {
    key: "update",
    value: function(r) {
      var o = this, l = r.translate, s = r.minTranslate, d = r.maxTranslate, e = r.width, f = r.height, i = {
        x: 0,
        y: 0
      }, c = {
        x: 1,
        y: 1
      }, h = {
        x: 10,
        y: 10
      }, u = this.container, a = u.scrollTop, g = u.scrollLeft, x = u.scrollHeight, R = u.scrollWidth, C = u.clientHeight, E = u.clientWidth, T = a === 0, y = x - a - C === 0, S = g === 0, N = R - g - E === 0;
      l.y >= d.y - f / 2 && !y ? (i.y = 1, c.y = h.y * Math.abs((d.y - f / 2 - l.y) / f)) : l.x >= d.x - e / 2 && !N ? (i.x = 1, c.x = h.x * Math.abs((d.x - e / 2 - l.x) / e)) : l.y <= s.y + f / 2 && !T ? (i.y = -1, c.y = h.y * Math.abs((l.y - f / 2 - s.y) / f)) : l.x <= s.x + e / 2 && !S && (i.x = -1, c.x = h.x * Math.abs((l.x - e / 2 - s.x) / e)), this.interval && (this.clear(), this.isAutoScrolling = !1), (i.x !== 0 || i.y !== 0) && (this.interval = setInterval(function() {
        o.isAutoScrolling = !0;
        var b = {
          left: c.x * i.x,
          top: c.y * i.y
        };
        o.container.scrollTop += b.top, o.container.scrollLeft += b.left, o.onScrollCallback(b);
      }, 5));
    }
  }]), t;
}();
function Et(t) {
  var n = t.node;
  return {
    height: n.offsetHeight,
    width: n.offsetWidth
  };
}
function kt(t) {
  var n = [H.Input, H.Textarea, H.Select, H.Option, H.Button];
  return !!(n.indexOf(t.target.tagName) !== -1 || X(t.target, function(r) {
    return r.contentEditable === "true";
  }));
}
var We = {
  axis: p.oneOf(["x", "y", "xy"]),
  contentWindow: p.any,
  disableAutoscroll: p.bool,
  distance: p.number,
  getContainer: p.func,
  getHelperDimensions: p.func,
  helperClass: p.string,
  helperContainer: p.oneOfType([p.func, typeof HTMLElement > "u" ? p.any : p.instanceOf(HTMLElement)]),
  hideSortableGhost: p.bool,
  keyboardSortingTransitionDuration: p.number,
  lockAxis: p.string,
  lockOffset: p.oneOfType([p.number, p.string, p.arrayOf(p.oneOfType([p.number, p.string]))]),
  lockToContainerEdges: p.bool,
  onSortEnd: p.func,
  onSortMove: p.func,
  onSortOver: p.func,
  onSortStart: p.func,
  pressDelay: p.number,
  pressThreshold: p.number,
  keyCodes: p.shape({
    lift: p.arrayOf(p.number),
    drop: p.arrayOf(p.number),
    cancel: p.arrayOf(p.number),
    up: p.arrayOf(p.number),
    down: p.arrayOf(p.number)
  }),
  shouldCancelStart: p.func,
  transitionDuration: p.number,
  updateBeforeSortStart: p.func,
  useDragHandle: p.bool,
  useWindowAsScrollContainer: p.bool
}, Pe = {
  lift: [B.SPACE],
  drop: [B.SPACE],
  cancel: [B.ESC],
  up: [B.UP, B.LEFT],
  down: [B.DOWN, B.RIGHT]
}, Ot = {
  axis: "y",
  disableAutoscroll: !1,
  distance: 0,
  getHelperDimensions: Et,
  hideSortableGhost: !0,
  lockOffset: "50%",
  lockToContainerEdges: !1,
  pressDelay: 0,
  pressThreshold: 5,
  keyCodes: Pe,
  shouldCancelStart: kt,
  transitionDuration: 300,
  useWindowAsScrollContainer: !1
}, Dt = Object.keys(We);
function Rt(t) {
  F(!(t.distance && t.pressDelay), "Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time.");
}
function Nt(t, n) {
  try {
    var r = t();
  } catch (o) {
    return n(!0, o);
  }
  return r && r.then ? r.then(n.bind(null, !1), n.bind(null, !0)) : n(!1, value);
}
var Me = dt({
  manager: {}
});
function At(t) {
  var n, r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    withRef: !1
  };
  return r = n = function(l) {
    de(s, l);
    function s(d) {
      var e;
      q(this, s), e = ue(this, he(s).call(this, d)), w(v(v(e)), "state", {}), w(v(v(e)), "handleStart", function(i) {
        var c = e.props, h = c.distance, u = c.shouldCancelStart;
        if (!(i.button === 2 || u(i))) {
          e.touched = !0, e.position = V(i);
          var a = X(i.target, function(T) {
            return T.sortableInfo != null;
          });
          if (a && a.sortableInfo && e.nodeIsChild(a) && !e.state.sorting) {
            var g = e.props.useDragHandle, x = a.sortableInfo, R = x.index, C = x.collection, E = x.disabled;
            if (E || g && !X(i.target, Se))
              return;
            e.manager.active = {
              collection: C,
              index: R
            }, !xt(i) && i.target.tagName === H.Anchor && i.preventDefault(), h || (e.props.pressDelay === 0 ? e.handlePress(i) : e.pressTimer = setTimeout(function() {
              return e.handlePress(i);
            }, e.props.pressDelay));
          }
        }
      }), w(v(v(e)), "nodeIsChild", function(i) {
        return i.sortableInfo.manager === e.manager;
      }), w(v(v(e)), "handleMove", function(i) {
        var c = e.props, h = c.distance, u = c.pressThreshold;
        if (!e.state.sorting && e.touched && !e._awaitingUpdateBeforeSortStart) {
          var a = V(i), g = {
            x: e.position.x - a.x,
            y: e.position.y - a.y
          }, x = Math.abs(g.x) + Math.abs(g.y);
          e.delta = g, !h && (!u || x >= u) ? (clearTimeout(e.cancelTimer), e.cancelTimer = setTimeout(e.cancel, 0)) : h && x >= h && e.manager.isActive() && e.handlePress(i);
        }
      }), w(v(v(e)), "handleEnd", function() {
        e.touched = !1, e.cancel();
      }), w(v(v(e)), "cancel", function() {
        var i = e.props.distance, c = e.state.sorting;
        c || (i || clearTimeout(e.pressTimer), e.manager.active = null);
      }), w(v(v(e)), "handlePress", function(i) {
        try {
          var c = e.manager.getActive(), h = function() {
            if (c) {
              var u = function() {
                var k = S.sortableInfo.index, I = vt(S), W = Ct(e.container), P = e.scrollContainer.getBoundingClientRect(), $ = x({
                  index: k,
                  node: S,
                  collection: N
                });
                if (e.node = S, e.margin = I, e.gridGap = W, e.width = $.width, e.height = $.height, e.marginOffset = {
                  x: e.margin.left + e.margin.right + e.gridGap.x,
                  y: Math.max(e.margin.top, e.margin.bottom, e.gridGap.y)
                }, e.boundingClientRect = S.getBoundingClientRect(), e.containerBoundingRect = P, e.index = k, e.newIndex = k, e.axis = {
                  x: g.indexOf("x") >= 0,
                  y: g.indexOf("y") >= 0
                }, e.offsetEdge = ee(S, e.container), b ? e.initialOffset = V(re({}, i, {
                  pageX: e.boundingClientRect.left,
                  pageY: e.boundingClientRect.top
                })) : e.initialOffset = V(i), e.initialScroll = {
                  left: e.scrollContainer.scrollLeft,
                  top: e.scrollContainer.scrollTop
                }, e.initialWindowScroll = {
                  left: window.pageXOffset,
                  top: window.pageYOffset
                }, e.helper = e.helperContainer.appendChild(St(S)), Z(e.helper, {
                  boxSizing: "border-box",
                  height: "".concat(e.height, "px"),
                  left: "".concat(e.boundingClientRect.left - I.left, "px"),
                  pointerEvents: "none",
                  position: "fixed",
                  top: "".concat(e.boundingClientRect.top - I.top, "px"),
                  width: "".concat(e.width, "px")
                }), b && e.helper.focus(), C && (e.sortableGhost = S, Z(S, {
                  opacity: 0,
                  visibility: "hidden"
                })), e.minTranslate = {}, e.maxTranslate = {}, b) {
                  var J = y ? {
                    top: 0,
                    left: 0,
                    width: e.contentWindow.innerWidth,
                    height: e.contentWindow.innerHeight
                  } : e.containerBoundingRect, xe = J.top, ye = J.left, $e = J.width, Ue = J.height, Ve = xe + Ue, ze = ye + $e;
                  e.axis.x && (e.minTranslate.x = ye - e.boundingClientRect.left, e.maxTranslate.x = ze - (e.boundingClientRect.left + e.width)), e.axis.y && (e.minTranslate.y = xe - e.boundingClientRect.top, e.maxTranslate.y = Ve - (e.boundingClientRect.top + e.height));
                } else
                  e.axis.x && (e.minTranslate.x = (y ? 0 : P.left) - e.boundingClientRect.left - e.width / 2, e.maxTranslate.x = (y ? e.contentWindow.innerWidth : P.left + P.width) - e.boundingClientRect.left - e.width / 2), e.axis.y && (e.minTranslate.y = (y ? 0 : P.top) - e.boundingClientRect.top - e.height / 2, e.maxTranslate.y = (y ? e.contentWindow.innerHeight : P.top + P.height) - e.boundingClientRect.top - e.height / 2);
                R && R.split(" ").forEach(function(U) {
                  return e.helper.classList.add(U);
                }), e.listenerNode = i.touches ? i.target : e.contentWindow, b ? (e.listenerNode.addEventListener("wheel", e.handleKeyEnd, !0), e.listenerNode.addEventListener("mousedown", e.handleKeyEnd, !0), e.listenerNode.addEventListener("keydown", e.handleKeyDown)) : (G.move.forEach(function(U) {
                  return e.listenerNode.addEventListener(U, e.handleSortMove, !1);
                }), G.end.forEach(function(U) {
                  return e.listenerNode.addEventListener(U, e.handleSortEnd, !1);
                })), e.setState({
                  sorting: !0,
                  sortingIndex: k
                }), T && T({
                  node: S,
                  index: k,
                  collection: N,
                  isKeySorting: b,
                  nodes: e.manager.getOrderedRefs(),
                  helper: e.helper
                }, i), b && e.keyMove(0);
              }, a = e.props, g = a.axis, x = a.getHelperDimensions, R = a.helperClass, C = a.hideSortableGhost, E = a.updateBeforeSortStart, T = a.onSortStart, y = a.useWindowAsScrollContainer, S = c.node, N = c.collection, b = e.manager.isKeySorting, A = function() {
                if (typeof E == "function") {
                  e._awaitingUpdateBeforeSortStart = !0;
                  var L = Nt(function() {
                    var k = S.sortableInfo.index;
                    return Promise.resolve(E({
                      collection: N,
                      index: k,
                      node: S,
                      isKeySorting: b
                    }, i)).then(function() {
                    });
                  }, function(k, I) {
                    if (e._awaitingUpdateBeforeSortStart = !1, k)
                      throw I;
                    return I;
                  });
                  if (L && L.then)
                    return L.then(function() {
                    });
                }
              }();
              return A && A.then ? A.then(u) : u(A);
            }
          }();
          return Promise.resolve(h && h.then ? h.then(function() {
          }) : void 0);
        } catch (u) {
          return Promise.reject(u);
        }
      }), w(v(v(e)), "handleSortMove", function(i) {
        var c = e.props.onSortMove;
        typeof i.preventDefault == "function" && i.cancelable && i.preventDefault(), e.updateHelperPosition(i), e.animateNodes(), e.autoscroll(), c && c(i);
      }), w(v(v(e)), "handleSortEnd", function(i) {
        var c = e.props, h = c.hideSortableGhost, u = c.onSortEnd, a = e.manager, g = a.active.collection, x = a.isKeySorting, R = e.manager.getOrderedRefs();
        e.listenerNode && (x ? (e.listenerNode.removeEventListener("wheel", e.handleKeyEnd, !0), e.listenerNode.removeEventListener("mousedown", e.handleKeyEnd, !0), e.listenerNode.removeEventListener("keydown", e.handleKeyDown)) : (G.move.forEach(function(S) {
          return e.listenerNode.removeEventListener(S, e.handleSortMove);
        }), G.end.forEach(function(S) {
          return e.listenerNode.removeEventListener(S, e.handleSortEnd);
        }))), e.helper.parentNode.removeChild(e.helper), h && e.sortableGhost && Z(e.sortableGhost, {
          opacity: "",
          visibility: ""
        });
        for (var C = 0, E = R.length; C < E; C++) {
          var T = R[C], y = T.node;
          T.edgeOffset = null, T.boundingClientRect = null, _(y, null), ie(y, null), T.translate = null;
        }
        e.autoScroller.clear(), e.manager.active = null, e.manager.isKeySorting = !1, e.setState({
          sorting: !1,
          sortingIndex: null
        }), typeof u == "function" && u({
          collection: g,
          newIndex: e.newIndex,
          oldIndex: e.index,
          isKeySorting: x,
          nodes: R
        }, i), e.touched = !1;
      }), w(v(v(e)), "autoscroll", function() {
        var i = e.props.disableAutoscroll, c = e.manager.isKeySorting;
        if (i) {
          e.autoScroller.clear();
          return;
        }
        if (c) {
          var h = re({}, e.translate), u = 0, a = 0;
          e.axis.x && (h.x = Math.min(e.maxTranslate.x, Math.max(e.minTranslate.x, e.translate.x)), u = e.translate.x - h.x), e.axis.y && (h.y = Math.min(e.maxTranslate.y, Math.max(e.minTranslate.y, e.translate.y)), a = e.translate.y - h.y), e.translate = h, _(e.helper, e.translate), e.scrollContainer.scrollLeft += u, e.scrollContainer.scrollTop += a;
          return;
        }
        e.autoScroller.update({
          height: e.height,
          maxTranslate: e.maxTranslate,
          minTranslate: e.minTranslate,
          translate: e.translate,
          width: e.width
        });
      }), w(v(v(e)), "onAutoScroll", function(i) {
        e.translate.x += i.left, e.translate.y += i.top, e.animateNodes();
      }), w(v(v(e)), "handleKeyDown", function(i) {
        var c = i.keyCode, h = e.props, u = h.shouldCancelStart, a = h.keyCodes, g = a === void 0 ? {} : a, x = re({}, Pe, g);
        e.manager.active && !e.manager.isKeySorting || !e.manager.active && (!x.lift.includes(c) || u(i) || !e.isValidSortingTarget(i)) || (i.stopPropagation(), i.preventDefault(), x.lift.includes(c) && !e.manager.active ? e.keyLift(i) : x.drop.includes(c) && e.manager.active ? e.keyDrop(i) : x.cancel.includes(c) ? (e.newIndex = e.manager.active.index, e.keyDrop(i)) : x.up.includes(c) ? e.keyMove(-1) : x.down.includes(c) && e.keyMove(1));
      }), w(v(v(e)), "keyLift", function(i) {
        var c = i.target, h = X(c, function(x) {
          return x.sortableInfo != null;
        }), u = h.sortableInfo, a = u.index, g = u.collection;
        e.initialFocusedNode = c, e.manager.isKeySorting = !0, e.manager.active = {
          index: a,
          collection: g
        }, e.handlePress(i);
      }), w(v(v(e)), "keyMove", function(i) {
        var c = e.manager.getOrderedRefs(), h = c[c.length - 1].node.sortableInfo.index, u = e.newIndex + i, a = e.newIndex;
        if (!(u < 0 || u > h)) {
          e.prevIndex = a, e.newIndex = u;
          var g = yt(e.newIndex, e.prevIndex, e.index), x = c.find(function(b) {
            var A = b.node;
            return A.sortableInfo.index === g;
          }), R = x.node, C = e.containerScrollDelta, E = x.boundingClientRect || oe(R, C), T = x.translate || {
            x: 0,
            y: 0
          }, y = {
            top: E.top + T.y - C.top,
            left: E.left + T.x - C.left
          }, S = a < u, N = {
            x: S && e.axis.x ? R.offsetWidth - e.width : 0,
            y: S && e.axis.y ? R.offsetHeight - e.height : 0
          };
          e.handleSortMove({
            pageX: y.left + N.x,
            pageY: y.top + N.y,
            ignoreTransition: i === 0
          });
        }
      }), w(v(v(e)), "keyDrop", function(i) {
        e.handleSortEnd(i), e.initialFocusedNode && e.initialFocusedNode.focus();
      }), w(v(v(e)), "handleKeyEnd", function(i) {
        e.manager.active && e.keyDrop(i);
      }), w(v(v(e)), "isValidSortingTarget", function(i) {
        var c = e.props.useDragHandle, h = i.target, u = X(h, function(a) {
          return a.sortableInfo != null;
        });
        return u && u.sortableInfo && !u.sortableInfo.disabled && (c ? Se(h) : h.sortableInfo);
      });
      var f = new pt();
      return Rt(d), e.manager = f, e.wrappedInstance = pe(), e.sortableContextValue = {
        manager: f
      }, e.events = {
        end: e.handleEnd,
        move: e.handleMove,
        start: e.handleStart
      }, e;
    }
    return Y(s, [{
      key: "componentDidMount",
      value: function() {
        var e = this, f = this.props.useWindowAsScrollContainer, i = this.getContainer();
        Promise.resolve(i).then(function(c) {
          e.container = c, e.document = e.container.ownerDocument || document;
          var h = e.props.contentWindow || e.document.defaultView || window;
          e.contentWindow = typeof h == "function" ? h() : h, e.scrollContainer = f ? e.document.scrollingElement || e.document.documentElement : Ae(e.container) || e.container, e.autoScroller = new It(e.scrollContainer, e.onAutoScroll), Object.keys(e.events).forEach(function(u) {
            return G[u].forEach(function(a) {
              return e.container.addEventListener(a, e.events[u], !1);
            });
          }), e.container.addEventListener("keydown", e.handleKeyDown);
        });
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        var e = this;
        this.helper && this.helper.parentNode && this.helper.parentNode.removeChild(this.helper), this.container && (Object.keys(this.events).forEach(function(f) {
          return G[f].forEach(function(i) {
            return e.container.removeEventListener(i, e.events[f]);
          });
        }), this.container.removeEventListener("keydown", this.handleKeyDown));
      }
    }, {
      key: "updateHelperPosition",
      value: function(e) {
        var f = this.props, i = f.lockAxis, c = f.lockOffset, h = f.lockToContainerEdges, u = f.transitionDuration, a = f.keyboardSortingTransitionDuration, g = a === void 0 ? u : a, x = this.manager.isKeySorting, R = e.ignoreTransition, C = V(e), E = {
          x: C.x - this.initialOffset.x,
          y: C.y - this.initialOffset.y
        };
        if (E.y -= window.pageYOffset - this.initialWindowScroll.top, E.x -= window.pageXOffset - this.initialWindowScroll.left, this.translate = E, h) {
          var T = bt({
            height: this.height,
            lockOffset: c,
            width: this.width
          }), y = ke(T, 2), S = y[0], N = y[1], b = {
            x: this.width / 2 - S.x,
            y: this.height / 2 - S.y
          }, A = {
            x: this.width / 2 - N.x,
            y: this.height / 2 - N.y
          };
          E.x = we(this.minTranslate.x + b.x, this.maxTranslate.x - A.x, E.x), E.y = we(this.minTranslate.y + b.y, this.maxTranslate.y - A.y, E.y);
        }
        i === "x" ? E.y = 0 : i === "y" && (E.x = 0), x && g && !R && ie(this.helper, g), _(this.helper, E);
      }
    }, {
      key: "animateNodes",
      value: function() {
        var e = this.props, f = e.transitionDuration, i = e.hideSortableGhost, c = e.onSortOver, h = this.containerScrollDelta, u = this.windowScrollDelta, a = this.manager.getOrderedRefs(), g = {
          left: this.offsetEdge.left + this.translate.x + h.left,
          top: this.offsetEdge.top + this.translate.y + h.top
        }, x = this.manager.isKeySorting, R = this.newIndex;
        this.newIndex = null;
        for (var C = 0, E = a.length; C < E; C++) {
          var T = a[C].node, y = T.sortableInfo.index, S = T.offsetWidth, N = T.offsetHeight, b = {
            height: this.height > N ? N / 2 : this.height / 2,
            width: this.width > S ? S / 2 : this.width / 2
          }, A = x && y > this.index && y <= R, L = x && y < this.index && y >= R, k = {
            x: 0,
            y: 0
          }, I = a[C].edgeOffset;
          I || (I = ee(T, this.container), a[C].edgeOffset = I, x && (a[C].boundingClientRect = oe(T, h)));
          var W = C < a.length - 1 && a[C + 1], P = C > 0 && a[C - 1];
          if (W && !W.edgeOffset && (W.edgeOffset = ee(W.node, this.container), x && (W.boundingClientRect = oe(W.node, h))), y === this.index) {
            i && (this.sortableGhost = T, Z(T, {
              opacity: 0,
              visibility: "hidden"
            }));
            continue;
          }
          f && ie(T, f), this.axis.x ? this.axis.y ? L || y < this.index && (g.left + u.left - b.width <= I.left && g.top + u.top <= I.top + b.height || g.top + u.top + b.height <= I.top) ? (k.x = this.width + this.marginOffset.x, I.left + k.x > this.containerBoundingRect.width - b.width && W && (k.x = W.edgeOffset.left - I.left, k.y = W.edgeOffset.top - I.top), this.newIndex === null && (this.newIndex = y)) : (A || y > this.index && (g.left + u.left + b.width >= I.left && g.top + u.top + b.height >= I.top || g.top + u.top + b.height >= I.top + N)) && (k.x = -(this.width + this.marginOffset.x), I.left + k.x < this.containerBoundingRect.left + b.width && P && (k.x = P.edgeOffset.left - I.left, k.y = P.edgeOffset.top - I.top), this.newIndex = y) : A || y > this.index && g.left + u.left + b.width >= I.left ? (k.x = -(this.width + this.marginOffset.x), this.newIndex = y) : (L || y < this.index && g.left + u.left <= I.left + b.width) && (k.x = this.width + this.marginOffset.x, this.newIndex == null && (this.newIndex = y)) : this.axis.y && (A || y > this.index && g.top + u.top + b.height >= I.top ? (k.y = -(this.height + this.marginOffset.y), this.newIndex = y) : (L || y < this.index && g.top + u.top <= I.top + b.height) && (k.y = this.height + this.marginOffset.y, this.newIndex == null && (this.newIndex = y))), _(T, k), a[C].translate = k;
        }
        this.newIndex == null && (this.newIndex = this.index), x && (this.newIndex = R);
        var $ = x ? this.prevIndex : R;
        c && this.newIndex !== $ && c({
          collection: this.manager.active.collection,
          index: this.index,
          newIndex: this.newIndex,
          oldIndex: $,
          isKeySorting: x,
          nodes: a,
          helper: this.helper
        });
      }
    }, {
      key: "getWrappedInstance",
      value: function() {
        return F(o.withRef, "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call"), this.wrappedInstance.current;
      }
    }, {
      key: "getContainer",
      value: function() {
        var e = this.props.getContainer;
        return typeof e != "function" ? ge(this) : e(o.withRef ? this.getWrappedInstance() : void 0);
      }
    }, {
      key: "render",
      value: function() {
        var e = o.withRef ? this.wrappedInstance : null;
        return te(Me.Provider, {
          value: this.sortableContextValue
        }, te(t, fe({
          ref: e
        }, Re(this.props, Dt))));
      }
    }, {
      key: "helperContainer",
      get: function() {
        var e = this.props.helperContainer;
        return typeof e == "function" ? e() : this.props.helperContainer || this.document.body;
      }
    }, {
      key: "containerScrollDelta",
      get: function() {
        var e = this.props.useWindowAsScrollContainer;
        return e ? {
          left: 0,
          top: 0
        } : {
          left: this.scrollContainer.scrollLeft - this.initialScroll.left,
          top: this.scrollContainer.scrollTop - this.initialScroll.top
        };
      }
    }, {
      key: "windowScrollDelta",
      get: function() {
        return {
          left: this.contentWindow.pageXOffset - this.initialWindowScroll.left,
          top: this.contentWindow.pageYOffset - this.initialWindowScroll.top
        };
      }
    }]), s;
  }(me), w(n, "displayName", ve("sortableList", t)), w(n, "defaultProps", Ot), w(n, "propTypes", We), r;
}
var Le = {
  index: p.number.isRequired,
  collection: p.oneOfType([p.number, p.string]),
  disabled: p.bool
}, Wt = Object.keys(Le);
function Pt(t) {
  var n, r, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    withRef: !1
  };
  return r = n = function(l) {
    de(s, l);
    function s() {
      var d, e;
      q(this, s);
      for (var f = arguments.length, i = new Array(f), c = 0; c < f; c++)
        i[c] = arguments[c];
      return e = ue(this, (d = he(s)).call.apply(d, [this].concat(i))), w(v(v(e)), "wrappedInstance", pe()), e;
    }
    return Y(s, [{
      key: "componentDidMount",
      value: function() {
        this.register();
      }
    }, {
      key: "componentDidUpdate",
      value: function(e) {
        this.node && (e.index !== this.props.index && (this.node.sortableInfo.index = this.props.index), e.disabled !== this.props.disabled && (this.node.sortableInfo.disabled = this.props.disabled)), e.collection !== this.props.collection && (this.unregister(e.collection), this.register());
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.unregister();
      }
    }, {
      key: "register",
      value: function() {
        var e = this.props, f = e.collection, i = e.disabled, c = e.index, h = ge(this);
        h.sortableInfo = {
          collection: f,
          disabled: i,
          index: c,
          manager: this.context.manager
        }, this.node = h, this.ref = {
          node: h
        }, this.context.manager.add(f, this.ref);
      }
    }, {
      key: "unregister",
      value: function() {
        var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props.collection;
        this.context.manager.remove(e, this.ref);
      }
    }, {
      key: "getWrappedInstance",
      value: function() {
        return F(o.withRef, "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call"), this.wrappedInstance.current;
      }
    }, {
      key: "render",
      value: function() {
        var e = o.withRef ? this.wrappedInstance : null;
        return te(t, fe({
          ref: e
        }, Re(this.props, Wt)));
      }
    }]), s;
  }(me), w(n, "displayName", ve("sortableElement", t)), w(n, "contextType", Me), w(n, "propTypes", Le), w(n, "defaultProps", {
    collection: 0
  }), r;
}
const Mt = D.span`
  &:hover {
    cursor: pointer;
  }

  color: #4965f2;
`, Be = D.div`
  width: 100%;
  display: flex;
  align-items: center;
`, Lt = D.div`
  display: flex;
  align-items: center;
  padding-left: 16px;
  padding-right: 8px;
`, Bt = D.div`
  display: flex;
  align-items: center;
  padding-left: 16px;
  padding-right: 8px;
`, ce = D(Qe)`
  .ant-select .ant-select-selector .ant-select-selection-item {
    padding-right: 20px;
  }
`, Te = D.label`
  ${qe};
  user-select: text;
  margin-right: 8px;
  max-width: 100px;
  white-space: nowrap;
`, Ie = D.div`
  display: inline-block;
  width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
`, Ht = D.div`
  display: flex;
  width: 100%;
  align-items: center;
`, K = D(Ze)`
  margin: 0;
  line-height: 13px;
  width: 100%;

  .ant-form-item-explain {
    font-size: 12px;
  }

  .ant-form-item-control-input {
    min-height: auto;
  }
`, Ft = D.div`
  font-size: 13px;
  color: #b8b9bf;
  text-align: center;
  line-height: 13px;
  height: 276px;
  display: flex;
  align-items: center;
  justify-content: center;
`, Gt = D.div`
  display: flex;
  align-items: center;
  margin-top: 16px;
  width: 100%;
  height: 36px;
  background: #f5f5f6;
  font-weight: 500;
  font-size: 13px;
  color: #222222;
  line-height: 13px;
`, jt = D.div`
  overflow: auto;
  height: 263px;

  &::-webkit-scrollbar {
    width: 14px;
  }

  &::-webkit-scrollbar-thumb {
    border: 4px solid transparent;
    background-clip: content-box;
    border-radius: 9999px;
    background-color: rgba(139, 143, 163, 0.12);
  }
`, Kt = D.div`
  display: flex;
  align-items: center;
  width: 100%;
  height: 43px;
  z-index: 2000;
  vertical-align: middle;
  border-bottom: 1px solid #f0f0f0;
  background: ${(t) => t.disabled ? "#FAFAFA" : "#ffffff"};

  font-size: 13px;
  color: ${(t) => t.disabled ? "#B8B9BF" : "#333333"};
  line-height: 13px;
`, He = D.div`
  width: 176px;
  padding-left: ${(t) => t.$head ? "16px" : "10px"};
`, Fe = D.div`
  width: 128px;
  padding-left: 16px;
`, Ge = D.div`
  width: 104px;
  padding-left: ${(t) => t.$head ? "16px" : "10px"};
`, je = D.div`
  width: 126px;
  padding-left: 16px;
`, Ke = D.div`
  /* width: 52px; */
  padding-left: 16px;
`, $t = D(_e)`
  cursor: grab;
  width: 16px;
  height: 16px;
`, Ee = D.div`
  width: 100%;
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
`, Ut = D.div`
  .taco-edit-text-wrapper {
    width: 94px;
    height: 24px;
    padding: 0 6px;
    margin: 0;
    border-radius: 4px;

    font-size: 13px;
    color: ${(t) => t.disabled ? "#B8B9BF" : "#333333"};
    line-height: 13px;

    &:hover {
      background-color: #f5f5f6;
    }
  }

  .taco-edit-text-body {
    height: auto;
  }

  .taco-edit-text-icon {
    margin: 0;
  }

  .taco-edit-text-input {
    width: 94px;
    height: 24px;
    padding: 0 6px;
    margin: 0;
    border-radius: 4px;

    font-size: 13px;
    color: #333333;
    line-height: 13px;
    background-color: #ffffff;
    border: 1px solid #315efb;

    &:focus {
      border-color: #315efb;
      box-shadow: 0 0 0 2px #d6e4ff;
    }
  }
`, Vt = D(K)`
  .ant-select {
    font-size: 13px;
    color: #333333;
    line-height: 13px;

    &:hover {
      color: #315efb;
    }
  }
`, zt = D(Oe)`
  .ant-checkbox-checked {
    .ant-checkbox-inner::after {
      border: 2px solid ${(t) => t.disabled ? "#B8B9BF" : "#4965f2"};
      border-top: 0;
      border-left: 0;
    }
  }
`;
function Xt(t, n) {
  const r = t.getCompSelection(n);
  if (!r) {
    be.error(O("formComp.compSelectionError"), t.type, n);
    return;
  }
  const o = [];
  if (r.comps.forEach((s) => {
    var e;
    const d = (e = ct[s.type]) == null ? void 0 : e.name;
    if (!d) {
      be.error(O("formComp.compTypeNameError"), s.type, n);
      return;
    }
    o.push({
      comp: s,
      compTypeName: d
    });
  }), o.length === 0)
    return;
  let l = r.defaultCompType;
  return o.find(({
    comp: s
  }) => s.type === l) || (l = o[0].comp.type), {
    compItems: o,
    defaultCompType: l
  };
}
function Yt(t, n) {
  var l;
  const r = [], o = {};
  return (l = n == null ? void 0 : n.columns) == null || l.forEach(({
    name: s,
    type: d,
    isAutogenerated: e
  }) => {
    if (t && s && d) {
      const f = Xt(t, d);
      f && (r.push({
        columnName: s,
        columnType: d,
        compItems: f.compItems
      }), o[s] = {
        enabled: !e,
        label: s.split("_").map(ot.upperFirst).join(" "),
        compType: f.defaultCompType,
        required: !0
      });
    }
  }), {
    initItems: r,
    initColumns: o
  };
}
function qt(t, n, r, o, l) {
  if (!t.dataSourceId || !n) {
    l(O("formComp.noDataSourceSelected"));
    return;
  }
  if (!t.tableName) {
    l(O("formComp.noTableSelected"));
    return;
  }
  if (!t.columns || Object.keys(t.columns).length === 0) {
    l(O("formComp.noColumn"));
    return;
  }
  const s = [];
  if (r.map(({
    columnName: d,
    columnType: e,
    compItems: f
  }) => {
    var c;
    const i = (c = t.columns) == null ? void 0 : c[d];
    if (i && i.enabled) {
      const h = f.find(({
        comp: u
      }) => u.type === i.compType);
      h && s.push({
        type: e,
        name: d,
        comp: h.comp,
        label: i.label,
        required: !!i.required
      });
    }
  }), s.length === 0) {
    l(O("formComp.noColumnSelected"));
    return;
  }
  return o({
    dataSourceId: t.dataSourceId,
    dataSourceTypeConfig: n,
    tableName: t.tableName,
    columns: s
  }).then((d) => l(d));
}
function Jt(t, n, r, o) {
  t.validateFields().then((l) => qt(l, n, r, o, (s) => {
    s ? ne.error(s) : ne.success(O("formComp.success"));
  })).catch((l) => {
    ne.error(JSON.stringify(l));
  });
}
const Qt = (t) => /* @__PURE__ */ m(Ut, {
  disabled: t.disabled,
  children: /* @__PURE__ */ m(at, {
    text: t.value ?? "",
    onChange: (n) => {
      var r;
      n && ((r = t.onChange) == null || r.call(t, n));
    },
    onFinish: () => {
    },
    disabled: t.disabled
  })
}), Zt = Tt(() => /* @__PURE__ */ m($t, {})), _t = Pt((t) => {
  const {
    item: n,
    form: r
  } = t, {
    columnName: o,
    columnType: l,
    compItems: s
  } = n, d = !z.useWatch(["columns", o, "enabled"], r);
  return /* @__PURE__ */ M(Kt, {
    disabled: d,
    children: [/* @__PURE__ */ m(He, {
      children: /* @__PURE__ */ M(Be, {
        children: [/* @__PURE__ */ m(Zt, {}), /* @__PURE__ */ m(K, {
          name: ["columns", o, "enabled"],
          valuePropName: "checked",
          style: {
            width: "auto",
            marginLeft: "4px",
            marginRight: "8px"
          },
          children: /* @__PURE__ */ m(Oe, {})
        }), /* @__PURE__ */ m(Ee, {
          title: o,
          children: o
        })]
      })
    }), /* @__PURE__ */ m(Fe, {
      children: /* @__PURE__ */ m(Ee, {
        title: l,
        children: l
      })
    }), /* @__PURE__ */ m(Ge, {
      children: /* @__PURE__ */ m(K, {
        name: ["columns", o, "label"],
        children: /* @__PURE__ */ m(Qt, {
          disabled: d
        })
      })
    }), /* @__PURE__ */ m(je, {
      children: /* @__PURE__ */ m(Vt, {
        name: ["columns", o, "compType"],
        children: /* @__PURE__ */ m(ce, {
          placeholder: O("formComp.selectCompType"),
          border: !0,
          disabled: d,
          children: s.map(({
            comp: e,
            compTypeName: f
          }) => /* @__PURE__ */ m(le.Option, {
            value: e.type,
            children: f
          }, e.type))
        })
      })
    }), /* @__PURE__ */ m(Ke, {
      children: /* @__PURE__ */ m(K, {
        name: ["columns", o, "required"],
        valuePropName: "checked",
        children: /* @__PURE__ */ m(zt, {
          disabled: d
        })
      })
    })]
  });
}), en = At((t) => /* @__PURE__ */ m(jt, {
  children: t.items.map((n, r) => /* @__PURE__ */ m(_t, {
    index: r,
    item: n,
    form: t.form
  }, n.columnName))
}));
function tn(t, n, r) {
  return t === 0 ? O("formComp.noDataSourceFound") : n === 0 ? O("formComp.noTableFound") : r === 0 ? O("formComp.noColumnFound") : "";
}
function nn() {
  const t = se(lt), n = se(st), r = {};
  t == null || t.forEach(({
    id: l
  }) => {
    const s = ut(l);
    s && (r[l] = s);
  });
  const o = [];
  return n == null || n.forEach(({
    datasource: l
  }) => {
    const s = r[l.type];
    s && o.push({
      dataSource: l,
      typeConfig: s
    });
  }), o;
}
function rn(t) {
  const n = se((r) => r.entities.datasource.structure);
  return t && n ? (n[t] ?? []).filter((r) => r.type === "TABLE") : [];
}
const on = (t) => {
  const [n] = z.useForm(), r = z.useWatch("dataSourceId", n), o = nn(), l = o.find((a) => a.dataSource.id === r);
  Q(() => {
    if (!l) {
      const a = o.length > 0 ? o[0].dataSource.id : void 0;
      n.setFieldsValue({
        dataSourceId: a
      });
    }
  }, [o]);
  const s = et();
  Q(() => {
    r && s(tt({
      datasourceId: r
    }));
  }, [r]);
  const d = z.useWatch("tableName", n), e = rn(r), f = e.find((a) => a.name === d);
  Q(() => {
    if (!f) {
      const a = e.length > 0 ? e[0].name : void 0;
      n.setFieldsValue({
        tableName: a
      });
    }
  }, [e]);
  const [i, c] = De([]), h = l == null ? void 0 : l.typeConfig;
  Q(() => {
    const {
      initItems: a,
      initColumns: g
    } = Yt(h, f);
    n.setFieldsValue({
      columns: g
    }), c(a);
  }, [h, f]);
  const u = tn(o.length, e.length, i.length);
  return /* @__PURE__ */ m(ae, {
    children: /* @__PURE__ */ M(z, {
      form: n,
      preserve: !1,
      children: [/* @__PURE__ */ M(Be, {
        children: [/* @__PURE__ */ M(Lt, {
          children: [/* @__PURE__ */ m(Te, {
            children: O("formComp.dataSource")
          }), /* @__PURE__ */ m(K, {
            name: "dataSourceId",
            children: /* @__PURE__ */ m(ce, {
              style: {
                width: "208px"
              },
              placeholder: O("formComp.selectSource"),
              children: o.map(({
                dataSource: a
              }) => /* @__PURE__ */ m(le.Option, {
                value: a.id,
                children: /* @__PURE__ */ M(Ht, {
                  children: [a.type && /* @__PURE__ */ m(nt, {
                    dataSourceType: a.type
                  }), /* @__PURE__ */ m(Ie, {
                    title: a.name,
                    children: a.name
                  })]
                })
              }, a.id))
            })
          })]
        }), /* @__PURE__ */ M(Bt, {
          children: [/* @__PURE__ */ m(Te, {
            children: O("formComp.table")
          }), /* @__PURE__ */ m(K, {
            name: "tableName",
            children: /* @__PURE__ */ m(ce, {
              style: {
                width: "208px"
              },
              placeholder: O("formComp.selectTable"),
              showSearch: !0,
              children: e.map((a) => /* @__PURE__ */ m(le.Option, {
                value: a.name,
                children: /* @__PURE__ */ m(Ie, {
                  title: a.name,
                  children: a.name + " (" + a.columns.length + ")"
                })
              }, a.name))
            })
          })]
        })]
      }), u ? /* @__PURE__ */ m(Ft, {
        children: u
      }) : /* @__PURE__ */ M(ae, {
        children: [/* @__PURE__ */ M(Gt, {
          children: [/* @__PURE__ */ m(He, {
            $head: !0,
            children: O("formComp.columnName")
          }), /* @__PURE__ */ m(Fe, {
            $head: !0,
            children: O("formComp.dataType")
          }), /* @__PURE__ */ m(Ge, {
            $head: !0,
            children: O("label")
          }), /* @__PURE__ */ m(je, {
            $head: !0,
            children: O("formComp.compType")
          }), /* @__PURE__ */ m(Ke, {
            $head: !0,
            children: O("formComp.required")
          })]
        }), /* @__PURE__ */ m(en, {
          items: i,
          form: n,
          useDragHandle: !0,
          onSortEnd: ({
            oldIndex: a,
            newIndex: g
          }) => {
            a !== g && c(gt(i, a, g));
          }
        }), /* @__PURE__ */ m(rt, {
          children: /* @__PURE__ */ m(it, {
            buttonType: "primary",
            loading: !1,
            onClick: () => Jt(n, h, i, t.onCreate),
            children: O("formComp.generateForm")
          })
        })]
      })]
    })
  });
}, gn = (t) => {
  const [n, r] = De(!1);
  return /* @__PURE__ */ M(ae, {
    children: [/* @__PURE__ */ m(Mt, {
      onMouseDown: (o) => {
        r(!0), o.stopPropagation();
      },
      children: O("formComp.openDialogButton")
    }), /* @__PURE__ */ m("div", {
      onKeyDown: (o) => o.stopPropagation(),
      onMouseDown: (o) => o.stopPropagation(),
      onClick: (o) => o.stopPropagation(),
      children: /* @__PURE__ */ m(Je, {
        open: n,
        destroyOnClose: !0,
        title: O("formComp.generateForm"),
        footer: null,
        onCancel: () => r(!1),
        width: "600px",
        children: /* @__PURE__ */ m(on, {
          ...t
        }),
        styles: {
          body: {
            padding: 0
          }
        }
      })
    })]
  });
};
export {
  gn as CreateForm
};
