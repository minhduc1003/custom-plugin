import { X as L, Y as o, a5 as F, cM as U, S as q, bI as B, O as S, P as A, a4 as _, w as G, a2 as H, c5 as j, f8 as z, N as K, Z as w, c6 as W, c7 as X, az as J, L as Y, dC as Z, ck as Q, U as ee, F as v, a8 as p, G as x, a9 as c, aa as m, en as te, ah as b, cd as ae, bJ as re, ab as ne, dE as oe, cg as ie, cS as le, db as ue, cU as de, dc as se, fa as ce, fb as me, fc as be, ac as fe, cf as E, dF as he, dG as pe, bL as ve, av as ge, aw as Se, ax as ye, gF as we, cH as Ne, bU as xe, bS as Ce } from "./c988e26e.js";
import { useContext as f, useRef as Ve, useEffect as P, useState as $e } from "react";
import { formDataChildren as Ie, FormDataPropertyView as Me } from "./85e61f03.js";
import { fixOldInputCompData as Fe } from "./70f9cad3.js";
import "react-dom";
function I(e, t) {
  return t === void 0 && (t = 15), +parseFloat(Number(e).toPrecision(t));
}
function d(e) {
  var t = e.toString().split(/[eE]/), a = (t[0].split(".")[1] || "").length - +(t[1] || 0);
  return a > 0 ? a : 0;
}
function y(e) {
  if (e.toString().indexOf("e") === -1)
    return Number(e.toString().replace(".", ""));
  var t = d(e);
  return t > 0 ? I(Number(e) * Math.pow(10, t)) : Number(e);
}
function C(e) {
  D && (e > Number.MAX_SAFE_INTEGER || e < Number.MIN_SAFE_INTEGER) && console.warn(e + " is beyond boundary when transfer to integer, the results may not be accurate");
}
function N(e) {
  return function() {
    for (var t = [], a = 0; a < arguments.length; a++)
      t[a] = arguments[a];
    var r = t[0], l = t.slice(1);
    return l.reduce(function(u, s) {
      return e(u, s);
    }, r);
  };
}
var h = N(function(e, t) {
  var a = y(e), r = y(t), l = d(e) + d(t), u = a * r;
  return C(u), u / Math.pow(10, l);
}), Ee = N(function(e, t) {
  var a = Math.pow(10, Math.max(d(e), d(t)));
  return (h(e, a) + h(t, a)) / a;
}), Pe = N(function(e, t) {
  var a = Math.pow(10, Math.max(d(e), d(t)));
  return (h(e, a) - h(t, a)) / a;
}), T = N(function(e, t) {
  var a = y(e), r = y(t);
  return C(a), C(r), h(a / r, I(Math.pow(10, d(t) - d(e))));
});
function Re(e, t) {
  var a = Math.pow(10, t), r = T(Math.round(Math.abs(h(e, a))), a);
  return e < 0 && r !== 0 && (r = h(r, -1)), r;
}
var D = !0;
function ke(e) {
  e === void 0 && (e = !0), D = e;
}
var V = {
  strip: I,
  plus: Ee,
  minus: Pe,
  times: h,
  divide: T,
  round: Re,
  digitLength: d,
  float2Fixed: y,
  enableBoundaryChecking: ke
};
const Te = (e) => ge`
    border-radius: ${e.radius};
    border-width:${e.borderWidth} !important;
    // line-height: ${e.lineHeight} !important;
    // still use antd style when disabled
    &:not(.ant-input-number-disabled) {
      color: ${e.text};
      background-color: ${e.background};
      border-color: ${e.border};
      //margin: ${e.margin};	
      padding: 0;	
      width: ${Se(e.margin)};
      &.ant-input-number-focused {
        border-color: ${e.accent};
      }

      &:hover {
        border-color: ${e.accent};
      }

      &::-webkit-input-placeholder {
        color: ${e.text};
        opacity: 0.4;
      }
      .ant-input-number {	
        margin: 0;	
        
      }	
      .ant-input-number-input {	
        margin: 0;	
        padding: ${e.padding};	
        height: ${ye(e.margin)};	
        color:${e.text};
        font-family:${e.fontFamily} !important;
        font-weight:${e.textWeight} !important;
        font-size:${e.textSize} !important;
        font-style:${e.fontStyle} !important;
      }

      .ant-input-number-handler-wrap {
        background-color: ${e.background};
        border-radius: 0 ${e.radius} ${e.radius} 0;

        .ant-input-number-handler span {
          color: ${e.text};
          opacity: 0.45;

          &:hover {
            opacity: 1;
          }
        }

        .ant-input-number-handler-up {
          border-top-right-radius: ${e.radius};
        }

        .ant-input-number-handler-down {
          border-bottom-right-radius: ${e.radius};
        }
      }
    }
  `, De = L(we)`
  box-shadow: ${(e) => {
  var t, a;
  return `${(t = e.$style) == null ? void 0 : t.boxShadow} ${(a = e.$style) == null ? void 0 : a.boxShadowColor}`;
}};
  width: 100%;
  ${(e) => e.$style && Te(e.$style)}
`, Oe = [{
  label: o("numberInput.standard"),
  value: "standard"
}, {
  label: o("numberInput.percent"),
  value: "percent"
}];
function R(e, t) {
  const a = e.replace(/[^\d.-]/g, "");
  if (a) {
    const r = Number(a);
    if (isFinite(r))
      return r;
  }
  return t ? Number.NaN : 0;
}
function Le(e) {
  const t = e.toString().split(".");
  return t[0] = t[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","), t.join(".");
}
function Ue(e, t, a, r, l) {
  const u = e;
  if (isNaN(u))
    return "";
  let s = u.toFixed(r);
  switch (l && (s = Le(s)), a) {
    case "standard":
      return s;
    case "percent":
      return s + "%";
  }
}
function qe(e, t, a) {
  const r = e;
  if (isNaN(r))
    return t ? null : 0;
  switch (a) {
    case "standard":
      return r;
    case "percent":
      return V.divide(r, 100);
  }
}
function O(e) {
  if (e.customRule)
    return {
      validateStatus: "error",
      help: e.customRule
    };
  const t = e.value.value;
  return isNaN(t) ? e.required ? {
    validateStatus: "error",
    help: o("prop.required")
  } : {
    validateStatus: ""
  } : e.max !== void 0 && t > e.max ? {
    validateStatus: "error",
    help: o("validationDesc.maxValue", {
      value: t,
      max: e.max
    })
  } : e.min !== void 0 && t < e.min ? {
    validateStatus: "error",
    help: o("validationDesc.minValue", {
      value: t,
      min: e.min
    })
  } : {
    validateStatus: ""
  };
}
const k = Ne((e) => {
  if (typeof e == "number")
    return e;
  const t = Number(e);
  return !e || isNaN(t) ? void 0 : t;
}), Be = {
  defaultValue: F("defaultValue"),
  // It is more convenient for string to handle various states, save raw input here
  value: U("value"),
  // It is more convenient for string to handle various states, save raw input here
  placeholder: q,
  disabled: B,
  readOnly: S,
  label: A,
  formatter: _(Oe, "standard"),
  step: G(H, 1),
  controls: S.DEFAULT_TRUE,
  // Whether to display the increase or decrease button
  precision: j.closed(0, 20, 0),
  thousandsSeparator: S.DEFAULT_TRUE,
  // Whether to display the thousand separator
  allowNull: S,
  onEvent: z,
  viewRef: K,
  style: w(W, "style"),
  labelStyle: w(X, "labelStyle"),
  prefixText: F("defaultValue"),
  animationStyle: w(J, "animationStyle"),
  prefixIcon: Y,
  inputFieldStyle: w(Z, "inputFieldStyle"),
  // validation
  required: S,
  min: k,
  max: k,
  customRule: Q,
  ...Ie
}, Ae = (e) => {
  const t = Ve(null), a = e.defaultValue.value;
  P(() => {
    let n = 0;
    a === "null" && e.allowNull ? n = NaN : isNaN(Number(a)) || (n = Number(a)), e.value.onChange(n);
  }, [a]);
  const r = (n) => Ue(n, e.allowNull, e.formatter, e.precision, e.thousandsSeparator), [l, u] = $e(r(e.value.value)), s = () => {
    const n = e.value.value, i = R(l, e.allowNull);
    e.value.onChange(i), n !== i && e.onEvent("change");
  };
  return P(() => {
    u(r(e.value.value));
  }, [e.value.value, e.allowNull, e.formatter, e.precision, e.thousandsSeparator]), /* @__PURE__ */ v(De, {
    ref: (n) => {
      e.viewRef(n), t.current = n;
    },
    value: l,
    controls: e.controls,
    step: e.step,
    disabled: e.disabled,
    readOnly: e.readOnly,
    placeholder: e.placeholder,
    stringMode: !0,
    precision: e.precision,
    $style: e.inputFieldStyle,
    prefix: xe(e.prefixIcon) ? e.prefixIcon : e.prefixText.value,
    onPressEnter: () => {
      s(), e.onEvent("submit");
    },
    onChangeCapture: (n) => {
      var i;
      u((((i = n.target.value) == null ? void 0 : i.toString()) ?? "").replace("。", "."));
    },
    onStep: (n, i) => {
      const g = V.plus(R(l), V.times(i.type === "up" ? 1 : -1, Number(i.offset)));
      e.value.onChange(g), e.onEvent("change");
    },
    onFocus: () => {
      e.onEvent("focus");
    },
    onBlur: () => {
      s(), e.onEvent("blur");
    },
    onKeyPress: (n) => {
      var M;
      const i = l, g = (M = t.current) == null ? void 0 : M.selectionStart;
      /\d/.test(n.key) || g === 0 && n.key === "-" && !/-/.test(i) || g !== 0 && e.thousandsSeparator && n.key === "," || g !== 0 && e.precision > 0 && // eslint-disable-next-line only-ascii/only-ascii
      (n.key === "." || n.key === "。") && !/[.]/.test(i) || n.preventDefault();
    }
  });
};
let $ = function() {
  return new ee(Be, (e) => e.label({
    required: e.required,
    children: /* @__PURE__ */ v(Ae, {
      ...e
    }),
    style: e.style,
    labelStyle: e.labelStyle,
    inputFieldStyle: e.inputFieldStyle,
    animationStyle: e.animationStyle,
    ...O(e)
  })).setPropertyViewFn((e) => /* @__PURE__ */ p(x, {
    children: [/* @__PURE__ */ p(c, {
      name: m.basic,
      children: [e.defaultValue.propertyView({
        label: o("prop.defaultValue")
      }), te(e), e.formatter.propertyView({
        label: o("numberInput.formatter")
      })]
    }), /* @__PURE__ */ v(Me, {
      ...e
    }), (f(b).editorModeStatus === "logic" || f(b).editorModeStatus === "both") && /* @__PURE__ */ p(x, {
      children: [/* @__PURE__ */ p(c, {
        name: m.validation,
        children: [ae(e), e.min.propertyView({
          label: o("prop.minimum")
        }), e.max.propertyView({
          label: o("prop.maximum")
        }), e.customRule.propertyView({})]
      }), /* @__PURE__ */ p(c, {
        name: m.interaction,
        children: [e.onEvent.getPropertyView(), re(e), ne(e)]
      })]
    }), (f(b).editorModeStatus === "layout" || f(b).editorModeStatus === "both") && e.label.getPropertyView(), (f(b).editorModeStatus === "logic" || f(b).editorModeStatus === "both") && /* @__PURE__ */ p(c, {
      name: m.advanced,
      children: [e.step.propertyView({
        label: o("numberInput.step")
      }), e.precision.propertyView({
        label: o("numberInput.precision")
      }), e.prefixIcon.propertyView({
        label: o("button.prefixIcon")
      }), e.prefixText.propertyView({
        label: o("button.prefixText")
      }), e.allowNull.propertyView({
        label: o("numberInput.allowNull")
      }), e.thousandsSeparator.propertyView({
        label: o("numberInput.thousandsSeparator")
      }), e.controls.propertyView({
        label: o("numberInput.controls")
      }), oe(e)]
    }), (f(b).editorModeStatus === "layout" || f(b).editorModeStatus === "both") && /* @__PURE__ */ p(x, {
      children: [/* @__PURE__ */ v(c, {
        name: m.style,
        children: e.style.getPropertyView()
      }), /* @__PURE__ */ v(c, {
        name: m.labelStyle,
        children: e.labelStyle.getPropertyView()
      }), /* @__PURE__ */ v(c, {
        name: m.inputFieldStyle,
        children: e.inputFieldStyle.getPropertyView()
      }), /* @__PURE__ */ v(c, {
        name: m.animationStyle,
        hasTooltip: !0,
        children: e.animationStyle.getPropertyView()
      })]
    })]
  })).build();
}();
$ = Ce($, Fe);
const _e = ie($, le([ue, de, se, ce, me, be])), We = fe(_e, [E({
  name: "value",
  desc: o("export.inputValueDesc"),
  depKeys: ["value", "allowNull", "formatter"],
  func: (e) => qe(e.value, e.allowNull, e.formatter)
}), he, pe, E({
  name: "invalid",
  desc: o("export.invalidDesc"),
  depKeys: ["value", "required", "min", "max", "allowNull", "customRule"],
  func: (e) => O({
    ...e,
    value: {
      value: e.value
    }
  }).validateStatus !== ""
}), ...ve]);
export {
  We as NumberInputComp
};
