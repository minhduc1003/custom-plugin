import { X as G, bI as O, eX as k, w as d, s as D, df as E, aA as I, O as R, S as g, Z as v, fW as W, eZ as A, U as j, F as i, a8 as u, G as w, a9 as c, aa as p, Y as r, ah as m, bJ as B, ab as z, bO as U, ac as F, ad as N, e$ as _, dk as J, dn as f, bW as X, dq as Z, dr as $, ds as q, dt as Y, du as V, _ as S, cG as K, x as Q, dv as ee, dw as te, dx as L } from "./c988e26e.js";
import { useContext as y } from "react";
import "react-dom";
const oe = G.div`
  display: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.display;
}};
  grid-template-columns: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.gridTemplateColumns;
}};
  grid-template-rows: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.gridTemplateRows;
}};
  column-gap: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.columnGap;
}};
  row-gap: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.rowGap;
}};

  background-color: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.background;
}} !important;
  border-radius: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.radius;
}};
  border-width: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.borderWidth;
}};
  border-color: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.border;
}};
  border-style: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.borderStyle;
}};
  margin: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.margin;
}};
  padding: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.padding;
}};
`, ne = G(_)`
  > div {
    height: ${(t) => {
  var e, o;
  return t.$matchColumnsHeight ? `calc(100% - ${((e = t.$style) == null ? void 0 : e.padding) || 0} - ${((o = t.$style) == null ? void 0 : o.padding) || 0})` : "auto";
}};
    background-color: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.background;
}} !important;
    border-radius: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.radius;
}};
    border-width: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.borderWidth;
}};
    border-color: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.border;
}};
    border-style: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.borderStyle;
}};
    margin: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.margin;
}};
    padding: ${(t) => {
  var e;
  return (e = t.$style) == null ? void 0 : e.padding;
}};
  }
`, ae = {
  disabled: O,
  columns: k,
  containers: d(D(J), {
    0: {
      view: {},
      layout: {}
    },
    1: {
      view: {},
      layout: {}
    }
  }),
  horizontalGridCells: E,
  autoHeight: I,
  matchColumnsHeight: d(R, !0),
  templateRows: d(g, "1fr"),
  rowGap: d(g, "20px"),
  templateColumns: d(g, "1fr 1fr"),
  columnGap: d(g, "20px"),
  style: v(W, "style"),
  columnStyle: v(A, "columnStyle")
}, se = (t) => /* @__PURE__ */ i(ee, {
  ...t,
  emptyRows: 15,
  hintPlaceholder: te,
  radius: "0",
  style: t.style,
  enableGridLines: !1
}), re = (t) => {
  let {
    columns: e,
    containers: o,
    dispatch: s,
    matchColumnsHeight: n,
    templateRows: l,
    rowGap: a,
    templateColumns: P,
    columnGap: H,
    columnStyle: T,
    horizontalGridCells: x
  } = t;
  return /* @__PURE__ */ i(f.Provider, {
    value: t.style.background,
    children: /* @__PURE__ */ i(X.Provider, {
      value: t.disabled,
      children: /* @__PURE__ */ i(oe, {
        $style: {
          ...t.style,
          display: "grid",
          gridTemplateColumns: P,
          columnGap: H,
          gridTemplateRows: l,
          rowGap: a
        },
        children: e.map((b) => {
          const h = String(b.id), M = L(L(s, "containers"), h);
          if (!o[h])
            return null;
          const C = o[h].children;
          return e.length, /* @__PURE__ */ i(f.Provider, {
            value: t.columnStyle.background,
            children: /* @__PURE__ */ i(ne, {
              $style: t.columnStyle,
              $minWidth: b.minWidth,
              $matchColumnsHeight: n,
              children: /* @__PURE__ */ i(se, {
                layout: C.layout.getView(),
                items: Z(C.items.getView()),
                horizontalGridCells: x,
                positionParams: C.positionParams.getView(),
                dispatch: M,
                autoHeight: t.autoHeight,
                style: T
              })
            }, h)
          });
        })
      })
    })
  });
}, ie = function() {
  return new j(ae, (t, e) => /* @__PURE__ */ i(re, {
    ...t,
    dispatch: e
  })).setPropertyViewFn((t) => /* @__PURE__ */ u(w, {
    children: [/* @__PURE__ */ i(c, {
      name: p.basic,
      children: t.columns.propertyView({
        title: r("responsiveLayout.column"),
        newOptionLabel: r("responsiveLayout.addColumn")
      })
    }), (y(m).editorModeStatus === "logic" || y(m).editorModeStatus === "both") && /* @__PURE__ */ u(c, {
      name: p.interaction,
      children: [B(t), z(t)]
    }), ["layout", "both"].includes(y(m).editorModeStatus) && /* @__PURE__ */ u(w, {
      children: [/* @__PURE__ */ u(c, {
        name: p.layout,
        children: [t.autoHeight.getPropertyView(), t.horizontalGridCells.propertyView({
          label: r("prop.horizontalGridCells")
        })]
      }), /* @__PURE__ */ u(c, {
        name: r("responsiveLayout.columnsLayout"),
        children: [t.matchColumnsHeight.propertyView({
          label: r("responsiveLayout.matchColumnsHeight")
        }), U({}, /* @__PURE__ */ i("div", {
          style: {
            marginTop: "8px"
          },
          children: r("responsiveLayout.columnsSpacing")
        })), t.templateColumns.propertyView({
          label: r("responsiveLayout.columnDefinition"),
          tooltip: r("responsiveLayout.columnsDefinitionTooltip")
        }), t.templateRows.propertyView({
          label: r("responsiveLayout.rowDefinition"),
          tooltip: r("responsiveLayout.rowsDefinitionTooltip")
        }), t.columnGap.propertyView({
          label: r("responsiveLayout.columnGap")
        }), t.rowGap.propertyView({
          label: r("responsiveLayout.rowGap")
        })]
      })]
    }), (y(m).editorModeStatus === "layout" || y(m).editorModeStatus === "both") && /* @__PURE__ */ u(w, {
      children: [/* @__PURE__ */ i(c, {
        name: p.style,
        children: t.style.getPropertyView()
      }), /* @__PURE__ */ i(c, {
        name: p.columnStyle,
        children: t.columnStyle.getPropertyView()
      })]
    })]
  })).build();
}();
class le extends ie {
  syncContainers() {
    const e = this.children.columns.getView(), o = new Set(e.map((a) => String(a.id)));
    let s = this.children.containers.getView();
    const n = [];
    Object.keys(s).forEach((a) => {
      o.has(a) || n.push($("containers", $(a, q())));
    }), o.forEach((a) => {
      s.hasOwnProperty(a) || n.push($("containers", Y(a, {
        layout: {},
        items: {}
      })));
    });
    let l = this;
    return n.forEach((a) => {
      l = l.reduce(a);
    }), l;
  }
  reduce(e) {
    const o = this.children.columns.getView();
    if (e.type === V.CUSTOM) {
      const n = e.value;
      if (n.type === "push") {
        const a = n.value;
        S.isEmpty(a.key) && (a.key = a.label), e = {
          ...e,
          value: {
            ...n,
            value: {
              ...a
            }
          }
        };
      }
      const {
        path: l
      } = e;
      if (n.type === "delete" && l[0] === "columns" && o.length <= 1)
        return K.warning(r("responsiveLayout.atLeastOneColumnError")), this;
    }
    let s = super.reduce(e);
    return e.type === V.UPDATE_NODES_V2 && (s = s.syncContainers()), s;
  }
  realSimpleContainer(e) {
    return Object.values(this.children.containers.children).find((o) => o.realSimpleContainer(e));
  }
  getCompTree() {
    const e = this.children.containers.getView(), o = Object.values(e).map((s) => s.getCompTree());
    return Q(o);
  }
  findContainer(e) {
    const o = this.children.containers.getView();
    for (const s of Object.values(o)) {
      const n = s.findContainer(e);
      if (n)
        return n === s ? this : n;
    }
  }
  getPasteValue(e) {
    const o = this.children.containers.getView(), s = S.mapValues(o, (n) => n.getPasteValue(e));
    return {
      ...this.toJsonValue(),
      containers: s
    };
  }
  autoHeight() {
    return this.children.autoHeight.getView();
  }
}
const pe = F(le, [N]);
export {
  pe as ColumnLayoutComp,
  ie as ResponsiveLayoutBaseComp
};
