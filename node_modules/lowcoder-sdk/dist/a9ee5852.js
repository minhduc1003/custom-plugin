var mr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Fn(t) {
  return t && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var gr = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function v0() {
  throw new Error("setTimeout has not been defined");
}
function E0() {
  throw new Error("clearTimeout has not been defined");
}
var Xr = v0, Qr = E0;
typeof gr.setTimeout == "function" && (Xr = setTimeout);
typeof gr.clearTimeout == "function" && (Qr = clearTimeout);
function b0(t) {
  if (Xr === setTimeout)
    return setTimeout(t, 0);
  if ((Xr === v0 || !Xr) && setTimeout)
    return Xr = setTimeout, setTimeout(t, 0);
  try {
    return Xr(t, 0);
  } catch {
    try {
      return Xr.call(null, t, 0);
    } catch {
      return Xr.call(this, t, 0);
    }
  }
}
function u1(t) {
  if (Qr === clearTimeout)
    return clearTimeout(t);
  if ((Qr === E0 || !Qr) && clearTimeout)
    return Qr = clearTimeout, clearTimeout(t);
  try {
    return Qr(t);
  } catch {
    try {
      return Qr.call(null, t);
    } catch {
      return Qr.call(this, t);
    }
  }
}
var Mr = [], Xn = !1, bn, wa = -1;
function c1() {
  !Xn || !bn || (Xn = !1, bn.length ? Mr = bn.concat(Mr) : wa = -1, Mr.length && C0());
}
function C0() {
  if (!Xn) {
    var t = b0(c1);
    Xn = !0;
    for (var e = Mr.length; e; ) {
      for (bn = Mr, Mr = []; ++wa < e; )
        bn && bn[wa].run();
      wa = -1, e = Mr.length;
    }
    bn = null, Xn = !1, u1(t);
  }
}
function p1(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var r = 1; r < arguments.length; r++)
      e[r - 1] = arguments[r];
  Mr.push(new S0(t, e)), Mr.length === 1 && !Xn && b0(C0);
}
function S0(t, e) {
  this.fun = t, this.array = e;
}
S0.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var f1 = "browser", h1 = "browser", m1 = !0, d1 = {}, g1 = [], y1 = "", x1 = {}, v1 = {}, E1 = {};
function Pn() {
}
var b1 = Pn, C1 = Pn, S1 = Pn, A1 = Pn, D1 = Pn, w1 = Pn, k1 = Pn;
function T1(t) {
  throw new Error("process.binding is not supported");
}
function F1() {
  return "/";
}
function P1(t) {
  throw new Error("process.chdir is not supported");
}
function I1() {
  return 0;
}
var Vn = gr.performance || {}, _1 = Vn.now || Vn.mozNow || Vn.msNow || Vn.oNow || Vn.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function B1(t) {
  var e = _1.call(Vn) * 1e-3, r = Math.floor(e), s = Math.floor(e % 1 * 1e9);
  return t && (r = r - t[0], s = s - t[1], s < 0 && (r--, s += 1e9)), [r, s];
}
var O1 = /* @__PURE__ */ new Date();
function L1() {
  var t = /* @__PURE__ */ new Date(), e = t - O1;
  return e / 1e3;
}
var Ze = {
  nextTick: p1,
  title: f1,
  browser: m1,
  env: d1,
  argv: g1,
  version: y1,
  versions: x1,
  on: b1,
  addListener: C1,
  once: S1,
  off: A1,
  removeListener: D1,
  removeAllListeners: w1,
  emit: k1,
  binding: T1,
  cwd: F1,
  chdir: P1,
  umask: I1,
  hrtime: B1,
  platform: h1,
  release: v1,
  config: E1,
  uptime: L1
}, A0 = {};
function D0(t, e) {
  for (var r = 0, s = t.length - 1; s >= 0; s--) {
    var n = t[s];
    n === "." ? t.splice(s, 1) : n === ".." ? (t.splice(s, 1), r++) : r && (t.splice(s, 1), r--);
  }
  if (e)
    for (; r--; r)
      t.unshift("..");
  return t;
}
var R1 = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, jl = function(t) {
  return R1.exec(t).slice(1);
};
function ja() {
  for (var t = "", e = !1, r = arguments.length - 1; r >= -1 && !e; r--) {
    var s = r >= 0 ? arguments[r] : "/";
    if (typeof s != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!s)
      continue;
    t = s + "/" + t, e = s.charAt(0) === "/";
  }
  return t = D0(Vl(t.split("/"), function(n) {
    return !!n;
  }), !e).join("/"), (e ? "/" : "") + t || ".";
}
function Ml(t) {
  var e = $l(t), r = j1(t, -1) === "/";
  return t = D0(Vl(t.split("/"), function(s) {
    return !!s;
  }), !e).join("/"), !t && !e && (t = "."), t && r && (t += "/"), (e ? "/" : "") + t;
}
function $l(t) {
  return t.charAt(0) === "/";
}
function w0() {
  var t = Array.prototype.slice.call(arguments, 0);
  return Ml(Vl(t, function(e, r) {
    if (typeof e != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function k0(t, e) {
  t = ja(t).substr(1), e = ja(e).substr(1);
  function r(u) {
    for (var c = 0; c < u.length && u[c] === ""; c++)
      ;
    for (var f = u.length - 1; f >= 0 && u[f] === ""; f--)
      ;
    return c > f ? [] : u.slice(c, f - c + 1);
  }
  for (var s = r(t.split("/")), n = r(e.split("/")), a = Math.min(s.length, n.length), o = a, l = 0; l < a; l++)
    if (s[l] !== n[l]) {
      o = l;
      break;
    }
  for (var i = [], l = o; l < s.length; l++)
    i.push("..");
  return i = i.concat(n.slice(o)), i.join("/");
}
var T0 = "/", F0 = ":";
function P0(t) {
  var e = jl(t), r = e[0], s = e[1];
  return !r && !s ? "." : (s && (s = s.substr(0, s.length - 1)), r + s);
}
function I0(t, e) {
  var r = jl(t)[2];
  return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)), r;
}
function _0(t) {
  return jl(t)[3];
}
var N1 = {
  extname: _0,
  basename: I0,
  dirname: P0,
  sep: T0,
  delimiter: F0,
  relative: k0,
  join: w0,
  isAbsolute: $l,
  normalize: Ml,
  resolve: ja
};
function Vl(t, e) {
  if (t.filter)
    return t.filter(e);
  for (var r = [], s = 0; s < t.length; s++)
    e(t[s], s, t) && r.push(t[s]);
  return r;
}
var j1 = "ab".substr(-1) === "b" ? function(t, e, r) {
  return t.substr(e, r);
} : function(t, e, r) {
  return e < 0 && (e = t.length + e), t.substr(e, r);
}, M1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  resolve: ja,
  normalize: Ml,
  isAbsolute: $l,
  join: w0,
  relative: k0,
  sep: T0,
  delimiter: F0,
  dirname: P0,
  basename: I0,
  extname: _0,
  default: N1
}), B0 = /* @__PURE__ */ Fn(M1), Ar = [], ur = [], $1 = typeof Uint8Array < "u" ? Uint8Array : Array, Ul = !1;
function O0() {
  Ul = !0;
  for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, r = t.length; e < r; ++e)
    Ar[e] = t[e], ur[t.charCodeAt(e)] = e;
  ur["-".charCodeAt(0)] = 62, ur["_".charCodeAt(0)] = 63;
}
function V1(t) {
  Ul || O0();
  var e, r, s, n, a, o, l = t.length;
  if (l % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  a = t[l - 2] === "=" ? 2 : t[l - 1] === "=" ? 1 : 0, o = new $1(l * 3 / 4 - a), s = a > 0 ? l - 4 : l;
  var i = 0;
  for (e = 0, r = 0; e < s; e += 4, r += 3)
    n = ur[t.charCodeAt(e)] << 18 | ur[t.charCodeAt(e + 1)] << 12 | ur[t.charCodeAt(e + 2)] << 6 | ur[t.charCodeAt(e + 3)], o[i++] = n >> 16 & 255, o[i++] = n >> 8 & 255, o[i++] = n & 255;
  return a === 2 ? (n = ur[t.charCodeAt(e)] << 2 | ur[t.charCodeAt(e + 1)] >> 4, o[i++] = n & 255) : a === 1 && (n = ur[t.charCodeAt(e)] << 10 | ur[t.charCodeAt(e + 1)] << 4 | ur[t.charCodeAt(e + 2)] >> 2, o[i++] = n >> 8 & 255, o[i++] = n & 255), o;
}
function U1(t) {
  return Ar[t >> 18 & 63] + Ar[t >> 12 & 63] + Ar[t >> 6 & 63] + Ar[t & 63];
}
function q1(t, e, r) {
  for (var s, n = [], a = e; a < r; a += 3)
    s = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2], n.push(U1(s));
  return n.join("");
}
function bd(t) {
  Ul || O0();
  for (var e, r = t.length, s = r % 3, n = "", a = [], o = 16383, l = 0, i = r - s; l < i; l += o)
    a.push(q1(t, l, l + o > i ? i : l + o));
  return s === 1 ? (e = t[r - 1], n += Ar[e >> 2], n += Ar[e << 4 & 63], n += "==") : s === 2 && (e = (t[r - 2] << 8) + t[r - 1], n += Ar[e >> 10], n += Ar[e >> 4 & 63], n += Ar[e << 2 & 63], n += "="), a.push(n), a.join("");
}
function li(t, e, r, s, n) {
  var a, o, l = n * 8 - s - 1, i = (1 << l) - 1, u = i >> 1, c = -7, f = r ? n - 1 : 0, h = r ? -1 : 1, p = t[e + f];
  for (f += h, a = p & (1 << -c) - 1, p >>= -c, c += l; c > 0; a = a * 256 + t[e + f], f += h, c -= 8)
    ;
  for (o = a & (1 << -c) - 1, a >>= -c, c += s; c > 0; o = o * 256 + t[e + f], f += h, c -= 8)
    ;
  if (a === 0)
    a = 1 - u;
  else {
    if (a === i)
      return o ? NaN : (p ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, s), a = a - u;
  }
  return (p ? -1 : 1) * o * Math.pow(2, a - s);
}
function L0(t, e, r, s, n, a) {
  var o, l, i, u = a * 8 - n - 1, c = (1 << u) - 1, f = c >> 1, h = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = s ? 0 : a - 1, m = s ? 1 : -1, d = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (i = Math.pow(2, -o)) < 1 && (o--, i *= 2), o + f >= 1 ? e += h / i : e += h * Math.pow(2, 1 - f), e * i >= 2 && (o++, i /= 2), o + f >= c ? (l = 0, o = c) : o + f >= 1 ? (l = (e * i - 1) * Math.pow(2, n), o = o + f) : (l = e * Math.pow(2, f - 1) * Math.pow(2, n), o = 0)); n >= 8; t[r + p] = l & 255, p += m, l /= 256, n -= 8)
    ;
  for (o = o << n | l, u += n; u > 0; t[r + p] = o & 255, p += m, o /= 256, u -= 8)
    ;
  t[r + p - m] |= d * 128;
}
var W1 = {}.toString, R0 = Array.isArray || function(t) {
  return W1.call(t) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var z1 = 50;
me.TYPED_ARRAY_SUPPORT = gr.TYPED_ARRAY_SUPPORT !== void 0 ? gr.TYPED_ARRAY_SUPPORT : !0;
Ma();
function Ma() {
  return me.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function $r(t, e) {
  if (Ma() < e)
    throw new RangeError("Invalid typed array length");
  return me.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e), t.__proto__ = me.prototype) : (t === null && (t = new me(e)), t.length = e), t;
}
function me(t, e, r) {
  if (!me.TYPED_ARRAY_SUPPORT && !(this instanceof me))
    return new me(t, e, r);
  if (typeof t == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return ql(this, t);
  }
  return N0(this, t, e, r);
}
me.poolSize = 8192;
me._augment = function(t) {
  return t.__proto__ = me.prototype, t;
};
function N0(t, e, r, s) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? K1(t, e, r, s) : typeof e == "string" ? H1(t, e, r) : J1(t, e);
}
me.from = function(t, e, r) {
  return N0(null, t, e, r);
};
me.TYPED_ARRAY_SUPPORT && (me.prototype.__proto__ = Uint8Array.prototype, me.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && me[Symbol.species]);
function j0(t) {
  if (typeof t != "number")
    throw new TypeError('"size" argument must be a number');
  if (t < 0)
    throw new RangeError('"size" argument must not be negative');
}
function G1(t, e, r, s) {
  return j0(e), e <= 0 ? $r(t, e) : r !== void 0 ? typeof s == "string" ? $r(t, e).fill(r, s) : $r(t, e).fill(r) : $r(t, e);
}
me.alloc = function(t, e, r) {
  return G1(null, t, e, r);
};
function ql(t, e) {
  if (j0(e), t = $r(t, e < 0 ? 0 : Wl(e) | 0), !me.TYPED_ARRAY_SUPPORT)
    for (var r = 0; r < e; ++r)
      t[r] = 0;
  return t;
}
me.allocUnsafe = function(t) {
  return ql(null, t);
};
me.allocUnsafeSlow = function(t) {
  return ql(null, t);
};
function H1(t, e, r) {
  if ((typeof r != "string" || r === "") && (r = "utf8"), !me.isEncoding(r))
    throw new TypeError('"encoding" must be a valid string encoding');
  var s = M0(e, r) | 0;
  t = $r(t, s);
  var n = t.write(e, r);
  return n !== s && (t = t.slice(0, n)), t;
}
function rl(t, e) {
  var r = e.length < 0 ? 0 : Wl(e.length) | 0;
  t = $r(t, r);
  for (var s = 0; s < r; s += 1)
    t[s] = e[s] & 255;
  return t;
}
function K1(t, e, r, s) {
  if (e.byteLength, r < 0 || e.byteLength < r)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < r + (s || 0))
    throw new RangeError("'length' is out of bounds");
  return r === void 0 && s === void 0 ? e = new Uint8Array(e) : s === void 0 ? e = new Uint8Array(e, r) : e = new Uint8Array(e, r, s), me.TYPED_ARRAY_SUPPORT ? (t = e, t.__proto__ = me.prototype) : t = rl(t, e), t;
}
function J1(t, e) {
  if (Tr(e)) {
    var r = Wl(e.length) | 0;
    return t = $r(t, r), t.length === 0 || e.copy(t, 0, 0, r), t;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || mC(e.length) ? $r(t, 0) : rl(t, e);
    if (e.type === "Buffer" && R0(e.data))
      return rl(t, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function Wl(t) {
  if (t >= Ma())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ma().toString(16) + " bytes");
  return t | 0;
}
me.isBuffer = Hn;
function Tr(t) {
  return !!(t != null && t._isBuffer);
}
me.compare = function(e, r) {
  if (!Tr(e) || !Tr(r))
    throw new TypeError("Arguments must be Buffers");
  if (e === r)
    return 0;
  for (var s = e.length, n = r.length, a = 0, o = Math.min(s, n); a < o; ++a)
    if (e[a] !== r[a]) {
      s = e[a], n = r[a];
      break;
    }
  return s < n ? -1 : n < s ? 1 : 0;
};
me.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
me.concat = function(e, r) {
  if (!R0(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return me.alloc(0);
  var s;
  if (r === void 0)
    for (r = 0, s = 0; s < e.length; ++s)
      r += e[s].length;
  var n = me.allocUnsafe(r), a = 0;
  for (s = 0; s < e.length; ++s) {
    var o = e[s];
    if (!Tr(o))
      throw new TypeError('"list" argument must be an Array of Buffers');
    o.copy(n, a), a += o.length;
  }
  return n;
};
function M0(t, e) {
  if (Tr(t))
    return t.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer))
    return t.byteLength;
  typeof t != "string" && (t = "" + t);
  var r = t.length;
  if (r === 0)
    return 0;
  for (var s = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return r;
      case "utf8":
      case "utf-8":
      case void 0:
        return $a(t).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return r * 2;
      case "hex":
        return r >>> 1;
      case "base64":
        return G0(t).length;
      default:
        if (s)
          return $a(t).length;
        e = ("" + e).toLowerCase(), s = !0;
    }
}
me.byteLength = M0;
function X1(t, e, r) {
  var s = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
    return "";
  for (t || (t = "utf8"); ; )
    switch (t) {
      case "hex":
        return iC(this, e, r);
      case "utf8":
      case "utf-8":
        return U0(this, e, r);
      case "ascii":
        return sC(this, e, r);
      case "latin1":
      case "binary":
        return aC(this, e, r);
      case "base64":
        return rC(this, e, r);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return oC(this, e, r);
      default:
        if (s)
          throw new TypeError("Unknown encoding: " + t);
        t = (t + "").toLowerCase(), s = !0;
    }
}
me.prototype._isBuffer = !0;
function Cn(t, e, r) {
  var s = t[e];
  t[e] = t[r], t[r] = s;
}
me.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var r = 0; r < e; r += 2)
    Cn(this, r, r + 1);
  return this;
};
me.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var r = 0; r < e; r += 4)
    Cn(this, r, r + 3), Cn(this, r + 1, r + 2);
  return this;
};
me.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var r = 0; r < e; r += 8)
    Cn(this, r, r + 7), Cn(this, r + 1, r + 6), Cn(this, r + 2, r + 5), Cn(this, r + 3, r + 4);
  return this;
};
me.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? U0(this, 0, e) : X1.apply(this, arguments);
};
me.prototype.equals = function(e) {
  if (!Tr(e))
    throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : me.compare(this, e) === 0;
};
me.prototype.inspect = function() {
  var e = "", r = z1;
  return this.length > 0 && (e = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (e += " ... ")), "<Buffer " + e + ">";
};
me.prototype.compare = function(e, r, s, n, a) {
  if (!Tr(e))
    throw new TypeError("Argument must be a Buffer");
  if (r === void 0 && (r = 0), s === void 0 && (s = e ? e.length : 0), n === void 0 && (n = 0), a === void 0 && (a = this.length), r < 0 || s > e.length || n < 0 || a > this.length)
    throw new RangeError("out of range index");
  if (n >= a && r >= s)
    return 0;
  if (n >= a)
    return -1;
  if (r >= s)
    return 1;
  if (r >>>= 0, s >>>= 0, n >>>= 0, a >>>= 0, this === e)
    return 0;
  for (var o = a - n, l = s - r, i = Math.min(o, l), u = this.slice(n, a), c = e.slice(r, s), f = 0; f < i; ++f)
    if (u[f] !== c[f]) {
      o = u[f], l = c[f];
      break;
    }
  return o < l ? -1 : l < o ? 1 : 0;
};
function $0(t, e, r, s, n) {
  if (t.length === 0)
    return -1;
  if (typeof r == "string" ? (s = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = n ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
    if (n)
      return -1;
    r = t.length - 1;
  } else if (r < 0)
    if (n)
      r = 0;
    else
      return -1;
  if (typeof e == "string" && (e = me.from(e, s)), Tr(e))
    return e.length === 0 ? -1 : Cd(t, e, r, s, n);
  if (typeof e == "number")
    return e = e & 255, me.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, s, n);
  throw new TypeError("val must be string, number or Buffer");
}
function Cd(t, e, r, s, n) {
  var a = 1, o = t.length, l = e.length;
  if (s !== void 0 && (s = String(s).toLowerCase(), s === "ucs2" || s === "ucs-2" || s === "utf16le" || s === "utf-16le")) {
    if (t.length < 2 || e.length < 2)
      return -1;
    a = 2, o /= 2, l /= 2, r /= 2;
  }
  function i(p, m) {
    return a === 1 ? p[m] : p.readUInt16BE(m * a);
  }
  var u;
  if (n) {
    var c = -1;
    for (u = r; u < o; u++)
      if (i(t, u) === i(e, c === -1 ? 0 : u - c)) {
        if (c === -1 && (c = u), u - c + 1 === l)
          return c * a;
      } else
        c !== -1 && (u -= u - c), c = -1;
  } else
    for (r + l > o && (r = o - l), u = r; u >= 0; u--) {
      for (var f = !0, h = 0; h < l; h++)
        if (i(t, u + h) !== i(e, h)) {
          f = !1;
          break;
        }
      if (f)
        return u;
    }
  return -1;
}
me.prototype.includes = function(e, r, s) {
  return this.indexOf(e, r, s) !== -1;
};
me.prototype.indexOf = function(e, r, s) {
  return $0(this, e, r, s, !0);
};
me.prototype.lastIndexOf = function(e, r, s) {
  return $0(this, e, r, s, !1);
};
function Q1(t, e, r, s) {
  r = Number(r) || 0;
  var n = t.length - r;
  s ? (s = Number(s), s > n && (s = n)) : s = n;
  var a = e.length;
  if (a % 2 !== 0)
    throw new TypeError("Invalid hex string");
  s > a / 2 && (s = a / 2);
  for (var o = 0; o < s; ++o) {
    var l = parseInt(e.substr(o * 2, 2), 16);
    if (isNaN(l))
      return o;
    t[r + o] = l;
  }
  return o;
}
function Y1(t, e, r, s) {
  return pi($a(e, t.length - r), t, r, s);
}
function V0(t, e, r, s) {
  return pi(fC(e), t, r, s);
}
function Z1(t, e, r, s) {
  return V0(t, e, r, s);
}
function eC(t, e, r, s) {
  return pi(G0(e), t, r, s);
}
function tC(t, e, r, s) {
  return pi(hC(e, t.length - r), t, r, s);
}
me.prototype.write = function(e, r, s, n) {
  if (r === void 0)
    n = "utf8", s = this.length, r = 0;
  else if (s === void 0 && typeof r == "string")
    n = r, s = this.length, r = 0;
  else if (isFinite(r))
    r = r | 0, isFinite(s) ? (s = s | 0, n === void 0 && (n = "utf8")) : (n = s, s = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var a = this.length - r;
  if ((s === void 0 || s > a) && (s = a), e.length > 0 && (s < 0 || r < 0) || r > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var o = !1; ; )
    switch (n) {
      case "hex":
        return Q1(this, e, r, s);
      case "utf8":
      case "utf-8":
        return Y1(this, e, r, s);
      case "ascii":
        return V0(this, e, r, s);
      case "latin1":
      case "binary":
        return Z1(this, e, r, s);
      case "base64":
        return eC(this, e, r, s);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return tC(this, e, r, s);
      default:
        if (o)
          throw new TypeError("Unknown encoding: " + n);
        n = ("" + n).toLowerCase(), o = !0;
    }
};
me.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function rC(t, e, r) {
  return e === 0 && r === t.length ? bd(t) : bd(t.slice(e, r));
}
function U0(t, e, r) {
  r = Math.min(t.length, r);
  for (var s = [], n = e; n < r; ) {
    var a = t[n], o = null, l = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
    if (n + l <= r) {
      var i, u, c, f;
      switch (l) {
        case 1:
          a < 128 && (o = a);
          break;
        case 2:
          i = t[n + 1], (i & 192) === 128 && (f = (a & 31) << 6 | i & 63, f > 127 && (o = f));
          break;
        case 3:
          i = t[n + 1], u = t[n + 2], (i & 192) === 128 && (u & 192) === 128 && (f = (a & 15) << 12 | (i & 63) << 6 | u & 63, f > 2047 && (f < 55296 || f > 57343) && (o = f));
          break;
        case 4:
          i = t[n + 1], u = t[n + 2], c = t[n + 3], (i & 192) === 128 && (u & 192) === 128 && (c & 192) === 128 && (f = (a & 15) << 18 | (i & 63) << 12 | (u & 63) << 6 | c & 63, f > 65535 && f < 1114112 && (o = f));
      }
    }
    o === null ? (o = 65533, l = 1) : o > 65535 && (o -= 65536, s.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), s.push(o), n += l;
  }
  return nC(s);
}
var Sd = 4096;
function nC(t) {
  var e = t.length;
  if (e <= Sd)
    return String.fromCharCode.apply(String, t);
  for (var r = "", s = 0; s < e; )
    r += String.fromCharCode.apply(
      String,
      t.slice(s, s += Sd)
    );
  return r;
}
function sC(t, e, r) {
  var s = "";
  r = Math.min(t.length, r);
  for (var n = e; n < r; ++n)
    s += String.fromCharCode(t[n] & 127);
  return s;
}
function aC(t, e, r) {
  var s = "";
  r = Math.min(t.length, r);
  for (var n = e; n < r; ++n)
    s += String.fromCharCode(t[n]);
  return s;
}
function iC(t, e, r) {
  var s = t.length;
  (!e || e < 0) && (e = 0), (!r || r < 0 || r > s) && (r = s);
  for (var n = "", a = e; a < r; ++a)
    n += pC(t[a]);
  return n;
}
function oC(t, e, r) {
  for (var s = t.slice(e, r), n = "", a = 0; a < s.length; a += 2)
    n += String.fromCharCode(s[a] + s[a + 1] * 256);
  return n;
}
me.prototype.slice = function(e, r) {
  var s = this.length;
  e = ~~e, r = r === void 0 ? s : ~~r, e < 0 ? (e += s, e < 0 && (e = 0)) : e > s && (e = s), r < 0 ? (r += s, r < 0 && (r = 0)) : r > s && (r = s), r < e && (r = e);
  var n;
  if (me.TYPED_ARRAY_SUPPORT)
    n = this.subarray(e, r), n.__proto__ = me.prototype;
  else {
    var a = r - e;
    n = new me(a, void 0);
    for (var o = 0; o < a; ++o)
      n[o] = this[o + e];
  }
  return n;
};
function Pt(t, e, r) {
  if (t % 1 !== 0 || t < 0)
    throw new RangeError("offset is not uint");
  if (t + e > r)
    throw new RangeError("Trying to access beyond buffer length");
}
me.prototype.readUIntLE = function(e, r, s) {
  e = e | 0, r = r | 0, s || Pt(e, r, this.length);
  for (var n = this[e], a = 1, o = 0; ++o < r && (a *= 256); )
    n += this[e + o] * a;
  return n;
};
me.prototype.readUIntBE = function(e, r, s) {
  e = e | 0, r = r | 0, s || Pt(e, r, this.length);
  for (var n = this[e + --r], a = 1; r > 0 && (a *= 256); )
    n += this[e + --r] * a;
  return n;
};
me.prototype.readUInt8 = function(e, r) {
  return r || Pt(e, 1, this.length), this[e];
};
me.prototype.readUInt16LE = function(e, r) {
  return r || Pt(e, 2, this.length), this[e] | this[e + 1] << 8;
};
me.prototype.readUInt16BE = function(e, r) {
  return r || Pt(e, 2, this.length), this[e] << 8 | this[e + 1];
};
me.prototype.readUInt32LE = function(e, r) {
  return r || Pt(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
me.prototype.readUInt32BE = function(e, r) {
  return r || Pt(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
me.prototype.readIntLE = function(e, r, s) {
  e = e | 0, r = r | 0, s || Pt(e, r, this.length);
  for (var n = this[e], a = 1, o = 0; ++o < r && (a *= 256); )
    n += this[e + o] * a;
  return a *= 128, n >= a && (n -= Math.pow(2, 8 * r)), n;
};
me.prototype.readIntBE = function(e, r, s) {
  e = e | 0, r = r | 0, s || Pt(e, r, this.length);
  for (var n = r, a = 1, o = this[e + --n]; n > 0 && (a *= 256); )
    o += this[e + --n] * a;
  return a *= 128, o >= a && (o -= Math.pow(2, 8 * r)), o;
};
me.prototype.readInt8 = function(e, r) {
  return r || Pt(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
me.prototype.readInt16LE = function(e, r) {
  r || Pt(e, 2, this.length);
  var s = this[e] | this[e + 1] << 8;
  return s & 32768 ? s | 4294901760 : s;
};
me.prototype.readInt16BE = function(e, r) {
  r || Pt(e, 2, this.length);
  var s = this[e + 1] | this[e] << 8;
  return s & 32768 ? s | 4294901760 : s;
};
me.prototype.readInt32LE = function(e, r) {
  return r || Pt(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
me.prototype.readInt32BE = function(e, r) {
  return r || Pt(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
me.prototype.readFloatLE = function(e, r) {
  return r || Pt(e, 4, this.length), li(this, e, !0, 23, 4);
};
me.prototype.readFloatBE = function(e, r) {
  return r || Pt(e, 4, this.length), li(this, e, !1, 23, 4);
};
me.prototype.readDoubleLE = function(e, r) {
  return r || Pt(e, 8, this.length), li(this, e, !0, 52, 8);
};
me.prototype.readDoubleBE = function(e, r) {
  return r || Pt(e, 8, this.length), li(this, e, !1, 52, 8);
};
function Wt(t, e, r, s, n, a) {
  if (!Tr(t))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > n || e < a)
    throw new RangeError('"value" argument is out of bounds');
  if (r + s > t.length)
    throw new RangeError("Index out of range");
}
me.prototype.writeUIntLE = function(e, r, s, n) {
  if (e = +e, r = r | 0, s = s | 0, !n) {
    var a = Math.pow(2, 8 * s) - 1;
    Wt(this, e, r, s, a, 0);
  }
  var o = 1, l = 0;
  for (this[r] = e & 255; ++l < s && (o *= 256); )
    this[r + l] = e / o & 255;
  return r + s;
};
me.prototype.writeUIntBE = function(e, r, s, n) {
  if (e = +e, r = r | 0, s = s | 0, !n) {
    var a = Math.pow(2, 8 * s) - 1;
    Wt(this, e, r, s, a, 0);
  }
  var o = s - 1, l = 1;
  for (this[r + o] = e & 255; --o >= 0 && (l *= 256); )
    this[r + o] = e / l & 255;
  return r + s;
};
me.prototype.writeUInt8 = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 1, 255, 0), me.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[r] = e & 255, r + 1;
};
function ui(t, e, r, s) {
  e < 0 && (e = 65535 + e + 1);
  for (var n = 0, a = Math.min(t.length - r, 2); n < a; ++n)
    t[r + n] = (e & 255 << 8 * (s ? n : 1 - n)) >>> (s ? n : 1 - n) * 8;
}
me.prototype.writeUInt16LE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 2, 65535, 0), me.TYPED_ARRAY_SUPPORT ? (this[r] = e & 255, this[r + 1] = e >>> 8) : ui(this, e, r, !0), r + 2;
};
me.prototype.writeUInt16BE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 2, 65535, 0), me.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 8, this[r + 1] = e & 255) : ui(this, e, r, !1), r + 2;
};
function ci(t, e, r, s) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var n = 0, a = Math.min(t.length - r, 4); n < a; ++n)
    t[r + n] = e >>> (s ? n : 3 - n) * 8 & 255;
}
me.prototype.writeUInt32LE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 4, 4294967295, 0), me.TYPED_ARRAY_SUPPORT ? (this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255) : ci(this, e, r, !0), r + 4;
};
me.prototype.writeUInt32BE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 4, 4294967295, 0), me.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255) : ci(this, e, r, !1), r + 4;
};
me.prototype.writeIntLE = function(e, r, s, n) {
  if (e = +e, r = r | 0, !n) {
    var a = Math.pow(2, 8 * s - 1);
    Wt(this, e, r, s, a - 1, -a);
  }
  var o = 0, l = 1, i = 0;
  for (this[r] = e & 255; ++o < s && (l *= 256); )
    e < 0 && i === 0 && this[r + o - 1] !== 0 && (i = 1), this[r + o] = (e / l >> 0) - i & 255;
  return r + s;
};
me.prototype.writeIntBE = function(e, r, s, n) {
  if (e = +e, r = r | 0, !n) {
    var a = Math.pow(2, 8 * s - 1);
    Wt(this, e, r, s, a - 1, -a);
  }
  var o = s - 1, l = 1, i = 0;
  for (this[r + o] = e & 255; --o >= 0 && (l *= 256); )
    e < 0 && i === 0 && this[r + o + 1] !== 0 && (i = 1), this[r + o] = (e / l >> 0) - i & 255;
  return r + s;
};
me.prototype.writeInt8 = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 1, 127, -128), me.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
};
me.prototype.writeInt16LE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 2, 32767, -32768), me.TYPED_ARRAY_SUPPORT ? (this[r] = e & 255, this[r + 1] = e >>> 8) : ui(this, e, r, !0), r + 2;
};
me.prototype.writeInt16BE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 2, 32767, -32768), me.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 8, this[r + 1] = e & 255) : ui(this, e, r, !1), r + 2;
};
me.prototype.writeInt32LE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 4, 2147483647, -2147483648), me.TYPED_ARRAY_SUPPORT ? (this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24) : ci(this, e, r, !0), r + 4;
};
me.prototype.writeInt32BE = function(e, r, s) {
  return e = +e, r = r | 0, s || Wt(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), me.TYPED_ARRAY_SUPPORT ? (this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255) : ci(this, e, r, !1), r + 4;
};
function q0(t, e, r, s, n, a) {
  if (r + s > t.length)
    throw new RangeError("Index out of range");
  if (r < 0)
    throw new RangeError("Index out of range");
}
function W0(t, e, r, s, n) {
  return n || q0(t, e, r, 4), L0(t, e, r, s, 23, 4), r + 4;
}
me.prototype.writeFloatLE = function(e, r, s) {
  return W0(this, e, r, !0, s);
};
me.prototype.writeFloatBE = function(e, r, s) {
  return W0(this, e, r, !1, s);
};
function z0(t, e, r, s, n) {
  return n || q0(t, e, r, 8), L0(t, e, r, s, 52, 8), r + 8;
}
me.prototype.writeDoubleLE = function(e, r, s) {
  return z0(this, e, r, !0, s);
};
me.prototype.writeDoubleBE = function(e, r, s) {
  return z0(this, e, r, !1, s);
};
me.prototype.copy = function(e, r, s, n) {
  if (s || (s = 0), !n && n !== 0 && (n = this.length), r >= e.length && (r = e.length), r || (r = 0), n > 0 && n < s && (n = s), n === s || e.length === 0 || this.length === 0)
    return 0;
  if (r < 0)
    throw new RangeError("targetStart out of bounds");
  if (s < 0 || s >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (n < 0)
    throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length), e.length - r < n - s && (n = e.length - r + s);
  var a = n - s, o;
  if (this === e && s < r && r < n)
    for (o = a - 1; o >= 0; --o)
      e[o + r] = this[o + s];
  else if (a < 1e3 || !me.TYPED_ARRAY_SUPPORT)
    for (o = 0; o < a; ++o)
      e[o + r] = this[o + s];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(s, s + a),
      r
    );
  return a;
};
me.prototype.fill = function(e, r, s, n) {
  if (typeof e == "string") {
    if (typeof r == "string" ? (n = r, r = 0, s = this.length) : typeof s == "string" && (n = s, s = this.length), e.length === 1) {
      var a = e.charCodeAt(0);
      a < 256 && (e = a);
    }
    if (n !== void 0 && typeof n != "string")
      throw new TypeError("encoding must be a string");
    if (typeof n == "string" && !me.isEncoding(n))
      throw new TypeError("Unknown encoding: " + n);
  } else
    typeof e == "number" && (e = e & 255);
  if (r < 0 || this.length < r || this.length < s)
    throw new RangeError("Out of range index");
  if (s <= r)
    return this;
  r = r >>> 0, s = s === void 0 ? this.length : s >>> 0, e || (e = 0);
  var o;
  if (typeof e == "number")
    for (o = r; o < s; ++o)
      this[o] = e;
  else {
    var l = Tr(e) ? e : $a(new me(e, n).toString()), i = l.length;
    for (o = 0; o < s - r; ++o)
      this[o + r] = l[o % i];
  }
  return this;
};
var lC = /[^+\/0-9A-Za-z-_]/g;
function uC(t) {
  if (t = cC(t).replace(lC, ""), t.length < 2)
    return "";
  for (; t.length % 4 !== 0; )
    t = t + "=";
  return t;
}
function cC(t) {
  return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
}
function pC(t) {
  return t < 16 ? "0" + t.toString(16) : t.toString(16);
}
function $a(t, e) {
  e = e || 1 / 0;
  for (var r, s = t.length, n = null, a = [], o = 0; o < s; ++o) {
    if (r = t.charCodeAt(o), r > 55295 && r < 57344) {
      if (!n) {
        if (r > 56319) {
          (e -= 3) > -1 && a.push(239, 191, 189);
          continue;
        } else if (o + 1 === s) {
          (e -= 3) > -1 && a.push(239, 191, 189);
          continue;
        }
        n = r;
        continue;
      }
      if (r < 56320) {
        (e -= 3) > -1 && a.push(239, 191, 189), n = r;
        continue;
      }
      r = (n - 55296 << 10 | r - 56320) + 65536;
    } else
      n && (e -= 3) > -1 && a.push(239, 191, 189);
    if (n = null, r < 128) {
      if ((e -= 1) < 0)
        break;
      a.push(r);
    } else if (r < 2048) {
      if ((e -= 2) < 0)
        break;
      a.push(
        r >> 6 | 192,
        r & 63 | 128
      );
    } else if (r < 65536) {
      if ((e -= 3) < 0)
        break;
      a.push(
        r >> 12 | 224,
        r >> 6 & 63 | 128,
        r & 63 | 128
      );
    } else if (r < 1114112) {
      if ((e -= 4) < 0)
        break;
      a.push(
        r >> 18 | 240,
        r >> 12 & 63 | 128,
        r >> 6 & 63 | 128,
        r & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return a;
}
function fC(t) {
  for (var e = [], r = 0; r < t.length; ++r)
    e.push(t.charCodeAt(r) & 255);
  return e;
}
function hC(t, e) {
  for (var r, s, n, a = [], o = 0; o < t.length && !((e -= 2) < 0); ++o)
    r = t.charCodeAt(o), s = r >> 8, n = r % 256, a.push(n), a.push(s);
  return a;
}
function G0(t) {
  return V1(uC(t));
}
function pi(t, e, r, s) {
  for (var n = 0; n < s && !(n + r >= e.length || n >= t.length); ++n)
    e[n + r] = t[n];
  return n;
}
function mC(t) {
  return t !== t;
}
function Hn(t) {
  return t != null && (!!t._isBuffer || H0(t) || dC(t));
}
function H0(t) {
  return !!t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
}
function dC(t) {
  return typeof t.readFloatLE == "function" && typeof t.slice == "function" && H0(t.slice(0, 0));
}
var nl;
typeof Object.create == "function" ? nl = function(e, r) {
  e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : nl = function(e, r) {
  e.super_ = r;
  var s = function() {
  };
  s.prototype = r.prototype, e.prototype = new s(), e.prototype.constructor = e;
};
var zl = nl, gC = /%[sdj%]/g;
function fi(t) {
  if (!zs(t)) {
    for (var e = [], r = 0; r < arguments.length; r++)
      e.push(dr(arguments[r]));
    return e.join(" ");
  }
  for (var r = 1, s = arguments, n = s.length, a = String(t).replace(gC, function(l) {
    if (l === "%%")
      return "%";
    if (r >= n)
      return l;
    switch (l) {
      case "%s":
        return String(s[r++]);
      case "%d":
        return Number(s[r++]);
      case "%j":
        try {
          return JSON.stringify(s[r++]);
        } catch {
          return "[Circular]";
        }
      default:
        return l;
    }
  }), o = s[r]; r < n; o = s[++r])
    Ws(o) || !In(o) ? a += " " + o : a += " " + dr(o);
  return a;
}
function Gl(t, e) {
  if (Dr(gr.process))
    return function() {
      return Gl(t, e).apply(this, arguments);
    };
  if (Ze.noDeprecation === !0)
    return t;
  var r = !1;
  function s() {
    if (!r) {
      if (Ze.throwDeprecation)
        throw new Error(e);
      Ze.traceDeprecation ? console.trace(e) : console.error(e), r = !0;
    }
    return t.apply(this, arguments);
  }
  return s;
}
var sa = {}, Hi;
function K0(t) {
  if (Dr(Hi) && (Hi = Ze.env.NODE_DEBUG || ""), t = t.toUpperCase(), !sa[t])
    if (new RegExp("\\b" + t + "\\b", "i").test(Hi)) {
      var e = 0;
      sa[t] = function() {
        var r = fi.apply(null, arguments);
        console.error("%s %d: %s", t, e, r);
      };
    } else
      sa[t] = function() {
      };
  return sa[t];
}
function dr(t, e) {
  var r = {
    seen: [],
    stylize: xC
  };
  return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), hi(e) ? r.showHidden = e : e && Xl(r, e), Dr(r.showHidden) && (r.showHidden = !1), Dr(r.depth) && (r.depth = 2), Dr(r.colors) && (r.colors = !1), Dr(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = yC), Va(r, t, r.depth);
}
dr.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
dr.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  // "name": intentionally not styling
  regexp: "red"
};
function yC(t, e) {
  var r = dr.styles[e];
  return r ? "\x1B[" + dr.colors[r][0] + "m" + t + "\x1B[" + dr.colors[r][1] + "m" : t;
}
function xC(t, e) {
  return t;
}
function vC(t) {
  var e = {};
  return t.forEach(function(r, s) {
    e[r] = !0;
  }), e;
}
function Va(t, e, r) {
  if (t.customInspect && e && Dn(e.inspect) && // Filter out the util module, it's inspect function is special
  e.inspect !== dr && // Also filter out any prototype objects using the circular check.
  !(e.constructor && e.constructor.prototype === e)) {
    var s = e.inspect(r, t);
    return zs(s) || (s = Va(t, s, r)), s;
  }
  var n = EC(t, e);
  if (n)
    return n;
  var a = Object.keys(e), o = vC(a);
  if (t.showHidden && (a = Object.getOwnPropertyNames(e)), Qn(e) && (a.indexOf("message") >= 0 || a.indexOf("description") >= 0))
    return Ki(e);
  if (a.length === 0) {
    if (Dn(e)) {
      var l = e.name ? ": " + e.name : "";
      return t.stylize("[Function" + l + "]", "special");
    }
    if (An(e))
      return t.stylize(RegExp.prototype.toString.call(e), "regexp");
    if (rs(e))
      return t.stylize(Date.prototype.toString.call(e), "date");
    if (Qn(e))
      return Ki(e);
  }
  var i = "", u = !1, c = ["{", "}"];
  if (Hl(e) && (u = !0, c = ["[", "]"]), Dn(e)) {
    var f = e.name ? ": " + e.name : "";
    i = " [Function" + f + "]";
  }
  if (An(e) && (i = " " + RegExp.prototype.toString.call(e)), rs(e) && (i = " " + Date.prototype.toUTCString.call(e)), Qn(e) && (i = " " + Ki(e)), a.length === 0 && (!u || e.length == 0))
    return c[0] + i + c[1];
  if (r < 0)
    return An(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
  t.seen.push(e);
  var h;
  return u ? h = bC(t, e, r, o, a) : h = a.map(function(p) {
    return sl(t, e, r, o, p, u);
  }), t.seen.pop(), CC(h, i, c);
}
function EC(t, e) {
  if (Dr(e))
    return t.stylize("undefined", "undefined");
  if (zs(e)) {
    var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return t.stylize(r, "string");
  }
  if (Kl(e))
    return t.stylize("" + e, "number");
  if (hi(e))
    return t.stylize("" + e, "boolean");
  if (Ws(e))
    return t.stylize("null", "null");
}
function Ki(t) {
  return "[" + Error.prototype.toString.call(t) + "]";
}
function bC(t, e, r, s, n) {
  for (var a = [], o = 0, l = e.length; o < l; ++o)
    Z0(e, String(o)) ? a.push(sl(
      t,
      e,
      r,
      s,
      String(o),
      !0
    )) : a.push("");
  return n.forEach(function(i) {
    i.match(/^\d+$/) || a.push(sl(
      t,
      e,
      r,
      s,
      i,
      !0
    ));
  }), a;
}
function sl(t, e, r, s, n, a) {
  var o, l, i;
  if (i = Object.getOwnPropertyDescriptor(e, n) || { value: e[n] }, i.get ? i.set ? l = t.stylize("[Getter/Setter]", "special") : l = t.stylize("[Getter]", "special") : i.set && (l = t.stylize("[Setter]", "special")), Z0(s, n) || (o = "[" + n + "]"), l || (t.seen.indexOf(i.value) < 0 ? (Ws(r) ? l = Va(t, i.value, null) : l = Va(t, i.value, r - 1), l.indexOf(`
`) > -1 && (a ? l = l.split(`
`).map(function(u) {
    return "  " + u;
  }).join(`
`).substr(2) : l = `
` + l.split(`
`).map(function(u) {
    return "   " + u;
  }).join(`
`))) : l = t.stylize("[Circular]", "special")), Dr(o)) {
    if (a && n.match(/^\d+$/))
      return l;
    o = JSON.stringify("" + n), o.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o = o.substr(1, o.length - 2), o = t.stylize(o, "name")) : (o = o.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o = t.stylize(o, "string"));
  }
  return o + ": " + l;
}
function CC(t, e, r) {
  var s = t.reduce(function(n, a) {
    return a.indexOf(`
`) >= 0, n + a.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return s > 60 ? r[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1];
}
function Hl(t) {
  return Array.isArray(t);
}
function hi(t) {
  return typeof t == "boolean";
}
function Ws(t) {
  return t === null;
}
function J0(t) {
  return t == null;
}
function Kl(t) {
  return typeof t == "number";
}
function zs(t) {
  return typeof t == "string";
}
function X0(t) {
  return typeof t == "symbol";
}
function Dr(t) {
  return t === void 0;
}
function An(t) {
  return In(t) && Jl(t) === "[object RegExp]";
}
function In(t) {
  return typeof t == "object" && t !== null;
}
function rs(t) {
  return In(t) && Jl(t) === "[object Date]";
}
function Qn(t) {
  return In(t) && (Jl(t) === "[object Error]" || t instanceof Error);
}
function Dn(t) {
  return typeof t == "function";
}
function Ua(t) {
  return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || // ES6 symbol
  typeof t > "u";
}
function Q0(t) {
  return me.isBuffer(t);
}
function Jl(t) {
  return Object.prototype.toString.call(t);
}
function Ji(t) {
  return t < 10 ? "0" + t.toString(10) : t.toString(10);
}
var SC = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function AC() {
  var t = /* @__PURE__ */ new Date(), e = [
    Ji(t.getHours()),
    Ji(t.getMinutes()),
    Ji(t.getSeconds())
  ].join(":");
  return [t.getDate(), SC[t.getMonth()], e].join(" ");
}
function Y0() {
  console.log("%s - %s", AC(), fi.apply(null, arguments));
}
function Xl(t, e) {
  if (!e || !In(e))
    return t;
  for (var r = Object.keys(e), s = r.length; s--; )
    t[r[s]] = e[r[s]];
  return t;
}
function Z0(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
var DC = {
  inherits: zl,
  _extend: Xl,
  log: Y0,
  isBuffer: Q0,
  isPrimitive: Ua,
  isFunction: Dn,
  isError: Qn,
  isDate: rs,
  isObject: In,
  isRegExp: An,
  isUndefined: Dr,
  isSymbol: X0,
  isString: zs,
  isNumber: Kl,
  isNullOrUndefined: J0,
  isNull: Ws,
  isBoolean: hi,
  isArray: Hl,
  inspect: dr,
  deprecate: Gl,
  format: fi,
  debuglog: K0
}, wC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  format: fi,
  deprecate: Gl,
  debuglog: K0,
  inspect: dr,
  isArray: Hl,
  isBoolean: hi,
  isNull: Ws,
  isNullOrUndefined: J0,
  isNumber: Kl,
  isString: zs,
  isSymbol: X0,
  isUndefined: Dr,
  isRegExp: An,
  isObject: In,
  isDate: rs,
  isError: Qn,
  isFunction: Dn,
  isPrimitive: Ua,
  isBuffer: Q0,
  log: Y0,
  inherits: zl,
  _extend: Xl,
  default: DC
});
function Ad(t, e) {
  if (t === e)
    return 0;
  for (var r = t.length, s = e.length, n = 0, a = Math.min(r, s); n < a; ++n)
    if (t[n] !== e[n]) {
      r = t[n], s = e[n];
      break;
    }
  return r < s ? -1 : s < r ? 1 : 0;
}
var kC = Object.prototype.hasOwnProperty, Dd = Object.keys || function(t) {
  var e = [];
  for (var r in t)
    kC.call(t, r) && e.push(r);
  return e;
}, wd = Array.prototype.slice, Xi;
function ex() {
  return typeof Xi < "u" ? Xi : Xi = function() {
    return (function() {
    }).name === "foo";
  }();
}
function kd(t) {
  return Object.prototype.toString.call(t);
}
function Td(t) {
  return Hn(t) || typeof gr.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t ? !!(t instanceof DataView || t.buffer && t.buffer instanceof ArrayBuffer) : !1;
}
function jt(t, e) {
  t || Nt(t, !0, e, "==", Ls);
}
var TC = /\s*function\s+([^\(\s]*)\s*/;
function tx(t) {
  if (Dn(t)) {
    if (ex())
      return t.name;
    var e = t.toString(), r = e.match(TC);
    return r && r[1];
  }
}
jt.AssertionError = mi;
function mi(t) {
  this.name = "AssertionError", this.actual = t.actual, this.expected = t.expected, this.operator = t.operator, t.message ? (this.message = t.message, this.generatedMessage = !1) : (this.message = FC(this), this.generatedMessage = !0);
  var e = t.stackStartFunction || Nt;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, e);
  else {
    var r = new Error();
    if (r.stack) {
      var s = r.stack, n = tx(e), a = s.indexOf(`
` + n);
      if (a >= 0) {
        var o = s.indexOf(`
`, a + 1);
        s = s.substring(o + 1);
      }
      this.stack = s;
    }
  }
}
zl(mi, Error);
function Fd(t, e) {
  return typeof t == "string" ? t.length < e ? t : t.slice(0, e) : t;
}
function Pd(t) {
  if (ex() || !Dn(t))
    return dr(t);
  var e = tx(t), r = e ? ": " + e : "";
  return "[Function" + r + "]";
}
function FC(t) {
  return Fd(Pd(t.actual), 128) + " " + t.operator + " " + Fd(Pd(t.expected), 128);
}
function Nt(t, e, r, s, n) {
  throw new mi({
    message: r,
    actual: t,
    expected: e,
    operator: s,
    stackStartFunction: n
  });
}
jt.fail = Nt;
function Ls(t, e) {
  t || Nt(t, !0, e, "==", Ls);
}
jt.ok = Ls;
jt.equal = Ql;
function Ql(t, e, r) {
  t != e && Nt(t, e, r, "==", Ql);
}
jt.notEqual = Yl;
function Yl(t, e, r) {
  t == e && Nt(t, e, r, "!=", Yl);
}
jt.deepEqual = Zl;
function Zl(t, e, r) {
  ns(t, e, !1) || Nt(t, e, r, "deepEqual", Zl);
}
jt.deepStrictEqual = eu;
function eu(t, e, r) {
  ns(t, e, !0) || Nt(t, e, r, "deepStrictEqual", eu);
}
function ns(t, e, r, s) {
  if (t === e)
    return !0;
  if (Hn(t) && Hn(e))
    return Ad(t, e) === 0;
  if (rs(t) && rs(e))
    return t.getTime() === e.getTime();
  if (An(t) && An(e))
    return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase;
  if ((t === null || typeof t != "object") && (e === null || typeof e != "object"))
    return r ? t === e : t == e;
  if (Td(t) && Td(e) && kd(t) === kd(e) && !(t instanceof Float32Array || t instanceof Float64Array))
    return Ad(
      new Uint8Array(t.buffer),
      new Uint8Array(e.buffer)
    ) === 0;
  if (Hn(t) !== Hn(e))
    return !1;
  s = s || { actual: [], expected: [] };
  var n = s.actual.indexOf(t);
  return n !== -1 && n === s.expected.indexOf(e) ? !0 : (s.actual.push(t), s.expected.push(e), PC(t, e, r, s));
}
function Id(t) {
  return Object.prototype.toString.call(t) == "[object Arguments]";
}
function PC(t, e, r, s) {
  if (t == null || e === null || e === void 0)
    return !1;
  if (Ua(t) || Ua(e))
    return t === e;
  if (r && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e))
    return !1;
  var n = Id(t), a = Id(e);
  if (n && !a || !n && a)
    return !1;
  if (n)
    return t = wd.call(t), e = wd.call(e), ns(t, e, r);
  var o = Dd(t), l = Dd(e), i, u;
  if (o.length !== l.length)
    return !1;
  for (o.sort(), l.sort(), u = o.length - 1; u >= 0; u--)
    if (o[u] !== l[u])
      return !1;
  for (u = o.length - 1; u >= 0; u--)
    if (i = o[u], !ns(t[i], e[i], r, s))
      return !1;
  return !0;
}
jt.notDeepEqual = tu;
function tu(t, e, r) {
  ns(t, e, !1) && Nt(t, e, r, "notDeepEqual", tu);
}
jt.notDeepStrictEqual = ru;
function ru(t, e, r) {
  ns(t, e, !0) && Nt(t, e, r, "notDeepStrictEqual", ru);
}
jt.strictEqual = nu;
function nu(t, e, r) {
  t !== e && Nt(t, e, r, "===", nu);
}
jt.notStrictEqual = su;
function su(t, e, r) {
  t === e && Nt(t, e, r, "!==", su);
}
function _d(t, e) {
  if (!t || !e)
    return !1;
  if (Object.prototype.toString.call(e) == "[object RegExp]")
    return e.test(t);
  try {
    if (t instanceof e)
      return !0;
  } catch {
  }
  return Error.isPrototypeOf(e) ? !1 : e.call({}, t) === !0;
}
function IC(t) {
  var e;
  try {
    t();
  } catch (r) {
    e = r;
  }
  return e;
}
function rx(t, e, r, s) {
  var n;
  if (typeof e != "function")
    throw new TypeError('"block" argument must be a function');
  typeof r == "string" && (s = r, r = null), n = IC(e), s = (r && r.name ? " (" + r.name + ")." : ".") + (s ? " " + s : "."), t && !n && Nt(n, r, "Missing expected exception" + s);
  var a = typeof s == "string", o = !t && Qn(n), l = !t && n && !r;
  if ((o && a && _d(n, r) || l) && Nt(n, r, "Got unwanted exception" + s), t && n && r && !_d(n, r) || !t && n)
    throw n;
}
jt.throws = nx;
function nx(t, e, r) {
  rx(!0, t, e, r);
}
jt.doesNotThrow = sx;
function sx(t, e, r) {
  rx(!1, t, e, r);
}
jt.ifError = ax;
function ax(t) {
  if (t)
    throw t;
}
var _C = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: jt,
  AssertionError: mi,
  fail: Nt,
  ok: Ls,
  assert: Ls,
  equal: Ql,
  notEqual: Yl,
  deepEqual: Zl,
  deepStrictEqual: eu,
  notDeepEqual: tu,
  notDeepStrictEqual: ru,
  strictEqual: nu,
  notStrictEqual: su,
  throws: nx,
  doesNotThrow: sx,
  ifError: ax
}), os = /* @__PURE__ */ Fn(_C), di = {}, BC = "estraverse", OC = "ECMAScript JS AST traversal functions", LC = "https://github.com/estools/estraverse", RC = "estraverse.js", NC = "4.3.0", jC = {
  node: ">=4.0"
}, MC = [
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "http://github.com/Constellation"
  }
], $C = {
  type: "git",
  url: "http://github.com/estools/estraverse.git"
}, VC = {
  "babel-preset-env": "^1.6.1",
  "babel-register": "^6.3.13",
  chai: "^2.1.1",
  espree: "^1.11.0",
  gulp: "^3.8.10",
  "gulp-bump": "^0.2.2",
  "gulp-filter": "^2.0.0",
  "gulp-git": "^1.0.1",
  "gulp-tag-version": "^1.3.0",
  jshint: "^2.5.6",
  mocha: "^2.1.0"
}, UC = "BSD-2-Clause", qC = {
  test: "npm run-script lint && npm run-script unit-test",
  lint: "jshint estraverse.js",
  "unit-test": "mocha --compilers js:babel-register"
}, WC = {
  name: BC,
  description: OC,
  homepage: LC,
  main: RC,
  version: NC,
  engines: jC,
  maintainers: MC,
  repository: $C,
  devDependencies: VC,
  license: UC,
  scripts: qC
};
(function(t) {
  (function e(r) {
    var s, n, a, o, l, i;
    function u(b) {
      var v = {}, C, T;
      for (C in b)
        b.hasOwnProperty(C) && (T = b[C], typeof T == "object" && T !== null ? v[C] = u(T) : v[C] = T);
      return v;
    }
    function c(b, v) {
      var C, T, w, B;
      for (T = b.length, w = 0; T; )
        C = T >>> 1, B = w + C, v(b[B]) ? T = C : (w = B + 1, T -= C + 1);
      return w;
    }
    s = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      // CAUTION: It's deferred to ES7.
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: "ComprehensionExpression",
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      // CAUTION: It's deferred to ES7.
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, a = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      // CAUTION: It's deferred to ES7.
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      Program: ["body"],
      Property: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    }, o = {}, l = {}, i = {}, n = {
      Break: o,
      Skip: l,
      Remove: i
    };
    function f(b, v) {
      this.parent = b, this.key = v;
    }
    f.prototype.replace = function(v) {
      this.parent[this.key] = v;
    }, f.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    };
    function h(b, v, C, T) {
      this.node = b, this.path = v, this.wrap = C, this.ref = T;
    }
    function p() {
    }
    p.prototype.path = function() {
      var v, C, T, w, B, I;
      function _(S, F) {
        if (Array.isArray(F))
          for (T = 0, w = F.length; T < w; ++T)
            S.push(F[T]);
        else
          S.push(F);
      }
      if (!this.__current.path)
        return null;
      for (B = [], v = 2, C = this.__leavelist.length; v < C; ++v)
        I = this.__leavelist[v], _(B, I.path);
      return _(B, this.__current.path), B;
    }, p.prototype.type = function() {
      var b = this.current();
      return b.type || this.__current.wrap;
    }, p.prototype.parents = function() {
      var v, C, T;
      for (T = [], v = 1, C = this.__leavelist.length; v < C; ++v)
        T.push(this.__leavelist[v].node);
      return T;
    }, p.prototype.current = function() {
      return this.__current.node;
    }, p.prototype.__execute = function(v, C) {
      var T, w;
      return w = void 0, T = this.__current, this.__current = C, this.__state = null, v && (w = v.call(this, C.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = T, w;
    }, p.prototype.notify = function(v) {
      this.__state = v;
    }, p.prototype.skip = function() {
      this.notify(l);
    }, p.prototype.break = function() {
      this.notify(o);
    }, p.prototype.remove = function() {
      this.notify(i);
    }, p.prototype.__initialize = function(b, v) {
      this.visitor = v, this.root = b, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, v.fallback === "iteration" ? this.__fallback = Object.keys : typeof v.fallback == "function" && (this.__fallback = v.fallback), this.__keys = a, v.keys && (this.__keys = Object.assign(Object.create(this.__keys), v.keys));
    };
    function m(b) {
      return b == null ? !1 : typeof b == "object" && typeof b.type == "string";
    }
    function d(b, v) {
      return (b === s.ObjectExpression || b === s.ObjectPattern) && v === "properties";
    }
    p.prototype.traverse = function(v, C) {
      var T, w, B, I, _, S, F, N, k, j, O, z;
      for (this.__initialize(v, C), z = {}, T = this.__worklist, w = this.__leavelist, T.push(new h(v, null, null, null)), w.push(new h(null, null, null, null)); T.length; ) {
        if (B = T.pop(), B === z) {
          if (B = w.pop(), S = this.__execute(C.leave, B), this.__state === o || S === o)
            return;
          continue;
        }
        if (B.node) {
          if (S = this.__execute(C.enter, B), this.__state === o || S === o)
            return;
          if (T.push(z), w.push(B), this.__state === l || S === l)
            continue;
          if (I = B.node, _ = I.type || B.wrap, j = this.__keys[_], !j)
            if (this.__fallback)
              j = this.__fallback(I);
            else
              throw new Error("Unknown node type " + _ + ".");
          for (N = j.length; (N -= 1) >= 0; )
            if (F = j[N], O = I[F], !!O)
              if (Array.isArray(O)) {
                for (k = O.length; (k -= 1) >= 0; )
                  if (O[k]) {
                    if (d(_, j[N]))
                      B = new h(O[k], [F, k], "Property", null);
                    else if (m(O[k]))
                      B = new h(O[k], [F, k], null, null);
                    else
                      continue;
                    T.push(B);
                  }
              } else
                m(O) && T.push(new h(O, F, null, null));
        }
      }
    }, p.prototype.replace = function(v, C) {
      var T, w, B, I, _, S, F, N, k, j, O, z, te;
      function se(ye) {
        var Se, xe, Ae, _e;
        if (ye.ref.remove()) {
          for (xe = ye.ref.key, _e = ye.ref.parent, Se = T.length; Se--; )
            if (Ae = T[Se], Ae.ref && Ae.ref.parent === _e) {
              if (Ae.ref.key < xe)
                break;
              --Ae.ref.key;
            }
        }
      }
      for (this.__initialize(v, C), O = {}, T = this.__worklist, w = this.__leavelist, z = {
        root: v
      }, S = new h(v, null, null, new f(z, "root")), T.push(S), w.push(S); T.length; ) {
        if (S = T.pop(), S === O) {
          if (S = w.pop(), _ = this.__execute(C.leave, S), _ !== void 0 && _ !== o && _ !== l && _ !== i && S.ref.replace(_), (this.__state === i || _ === i) && se(S), this.__state === o || _ === o)
            return z.root;
          continue;
        }
        if (_ = this.__execute(C.enter, S), _ !== void 0 && _ !== o && _ !== l && _ !== i && (S.ref.replace(_), S.node = _), (this.__state === i || _ === i) && (se(S), S.node = null), this.__state === o || _ === o)
          return z.root;
        if (B = S.node, !!B && (T.push(O), w.push(S), !(this.__state === l || _ === l))) {
          if (I = B.type || S.wrap, k = this.__keys[I], !k)
            if (this.__fallback)
              k = this.__fallback(B);
            else
              throw new Error("Unknown node type " + I + ".");
          for (F = k.length; (F -= 1) >= 0; )
            if (te = k[F], j = B[te], !!j)
              if (Array.isArray(j)) {
                for (N = j.length; (N -= 1) >= 0; )
                  if (j[N]) {
                    if (d(I, k[F]))
                      S = new h(j[N], [te, N], "Property", new f(j, N));
                    else if (m(j[N]))
                      S = new h(j[N], [te, N], null, new f(j, N));
                    else
                      continue;
                    T.push(S);
                  }
              } else
                m(j) && T.push(new h(j, te, null, new f(B, te)));
        }
      }
      return z.root;
    };
    function g(b, v) {
      var C = new p();
      return C.traverse(b, v);
    }
    function y(b, v) {
      var C = new p();
      return C.replace(b, v);
    }
    function x(b, v) {
      var C;
      return C = c(v, function(w) {
        return w.range[0] > b.range[0];
      }), b.extendedRange = [b.range[0], b.range[1]], C !== v.length && (b.extendedRange[1] = v[C].range[0]), C -= 1, C >= 0 && (b.extendedRange[0] = v[C].range[1]), b;
    }
    function A(b, v, C) {
      var T = [], w, B, I, _;
      if (!b.range)
        throw new Error("attachComments needs range information");
      if (!C.length) {
        if (v.length) {
          for (I = 0, B = v.length; I < B; I += 1)
            w = u(v[I]), w.extendedRange = [0, b.range[0]], T.push(w);
          b.leadingComments = T;
        }
        return b;
      }
      for (I = 0, B = v.length; I < B; I += 1)
        T.push(x(u(v[I]), C));
      return _ = 0, g(b, {
        enter: function(S) {
          for (var F; _ < T.length && (F = T[_], !(F.extendedRange[1] > S.range[0])); )
            F.extendedRange[1] === S.range[0] ? (S.leadingComments || (S.leadingComments = []), S.leadingComments.push(F), T.splice(_, 1)) : _ += 1;
          if (_ === T.length)
            return n.Break;
          if (T[_].extendedRange[0] > S.range[1])
            return n.Skip;
        }
      }), _ = 0, g(b, {
        leave: function(S) {
          for (var F; _ < T.length && (F = T[_], !(S.range[1] < F.extendedRange[0])); )
            S.range[1] === F.extendedRange[0] ? (S.trailingComments || (S.trailingComments = []), S.trailingComments.push(F), T.splice(_, 1)) : _ += 1;
          if (_ === T.length)
            return n.Break;
          if (T[_].extendedRange[0] > S.range[1])
            return n.Skip;
        }
      }), b;
    }
    return r.version = WC.version, r.Syntax = s, r.traverse = g, r.replace = y, r.attachComments = A, r.VisitorKeys = a, r.VisitorOption = n, r.Controller = p, r.cloneEnvironment = function() {
      return e({});
    }, r;
  })(t);
})(di);
const ix = 1, ox = 2, zC = ix | ox;
let jr = class {
  constructor(e, r, s, n, a, o, l) {
    this.identifier = e, this.from = r, this.tainted = !1, this.resolved = null, this.flag = s, this.isWrite() && (this.writeExpr = n, this.partial = o, this.init = l), this.__maybeImplicitGlobal = a;
  }
  /**
   * Whether the reference is static.
   * @method Reference#isStatic
   * @returns {boolean} static
   */
  isStatic() {
    return !this.tainted && this.resolved && this.resolved.scope.isStatic();
  }
  /**
   * Whether the reference is writeable.
   * @method Reference#isWrite
   * @returns {boolean} write
   */
  isWrite() {
    return !!(this.flag & jr.WRITE);
  }
  /**
   * Whether the reference is readable.
   * @method Reference#isRead
   * @returns {boolean} read
   */
  isRead() {
    return !!(this.flag & jr.READ);
  }
  /**
   * Whether the reference is read-only.
   * @method Reference#isReadOnly
   * @returns {boolean} read only
   */
  isReadOnly() {
    return this.flag === jr.READ;
  }
  /**
   * Whether the reference is write-only.
   * @method Reference#isWriteOnly
   * @returns {boolean} write only
   */
  isWriteOnly() {
    return this.flag === jr.WRITE;
  }
  /**
   * Whether the reference is read-write.
   * @method Reference#isReadWrite
   * @returns {boolean} read write
   */
  isReadWrite() {
    return this.flag === jr.RW;
  }
};
jr.READ = ix;
jr.WRITE = ox;
jr.RW = zC;
var au = jr;
let on = class {
  constructor(e, r) {
    this.name = e, this.identifiers = [], this.references = [], this.defs = [], this.tainted = !1, this.stack = !0, this.scope = r;
  }
};
on.CatchClause = "CatchClause";
on.Parameter = "Parameter";
on.FunctionName = "FunctionName";
on.ClassName = "ClassName";
on.Variable = "Variable";
on.ImportBinding = "ImportBinding";
on.ImplicitGlobalVariable = "ImplicitGlobalVariable";
var gi = on;
const GC = gi;
let lx = class {
  constructor(e, r, s, n, a, o) {
    this.type = e, this.name = r, this.node = s, this.parent = n, this.index = a, this.kind = o;
  }
}, HC = class extends lx {
  constructor(e, r, s, n) {
    super(GC.Parameter, e, r, null, s, null), this.rest = n;
  }
};
var ux = {
  ParameterDefinition: HC,
  Definition: lx
};
const cr = di.Syntax, Bd = au, Rs = gi, cx = ux.Definition, al = os;
function KC(t, e, r, s) {
  let n;
  if (t.upper && t.upper.isStrict || r || t.type === "class" || t.type === "module")
    return !0;
  if (t.type === "block" || t.type === "switch")
    return !1;
  if (t.type === "function") {
    if (e.type === cr.ArrowFunctionExpression && e.body.type !== cr.BlockStatement || (e.type === cr.Program ? n = e : n = e.body, !n))
      return !1;
  } else if (t.type === "global")
    n = e;
  else
    return !1;
  if (s)
    for (let a = 0, o = n.body.length; a < o; ++a) {
      const l = n.body[a];
      if (l.type !== cr.DirectiveStatement)
        break;
      if (l.raw === '"use strict"' || l.raw === "'use strict'")
        return !0;
    }
  else
    for (let a = 0, o = n.body.length; a < o; ++a) {
      const l = n.body[a];
      if (l.type !== cr.ExpressionStatement)
        break;
      const i = l.expression;
      if (i.type !== cr.Literal || typeof i.value != "string")
        break;
      if (i.raw !== null && i.raw !== void 0) {
        if (i.raw === '"use strict"' || i.raw === "'use strict'")
          return !0;
      } else if (i.value === "use strict")
        return !0;
    }
  return !1;
}
function JC(t, e) {
  t.scopes.push(e);
  const r = t.__nodeToScope.get(e.block);
  r ? r.push(e) : t.__nodeToScope.set(e.block, [e]);
}
function XC(t) {
  return t.type === Rs.ClassName || t.type === Rs.Variable && t.parent.kind !== "var";
}
let yr = class {
  constructor(e, r, s, n, a) {
    this.type = r, this.set = /* @__PURE__ */ new Map(), this.taints = /* @__PURE__ */ new Map(), this.dynamic = this.type === "global" || this.type === "with", this.block = n, this.through = [], this.variables = [], this.references = [], this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : s.variableScope, this.functionExpressionScope = !1, this.directCallToEvalScope = !1, this.thisFound = !1, this.__left = [], this.upper = s, this.isStrict = KC(this, n, a, e.__useDirective()), this.childScopes = [], this.upper && this.upper.childScopes.push(this), this.__declaredVariables = e.__declaredVariables, JC(e, this);
  }
  __shouldStaticallyClose(e) {
    return !this.dynamic || e.__isOptimistic();
  }
  __shouldStaticallyCloseForGlobal(e) {
    const r = e.identifier.name;
    if (!this.set.has(r))
      return !1;
    const n = this.set.get(r).defs;
    return n.length > 0 && n.every(XC);
  }
  __staticCloseRef(e) {
    this.__resolve(e) || this.__delegateToUpperScope(e);
  }
  __dynamicCloseRef(e) {
    let r = this;
    do
      r.through.push(e), r = r.upper;
    while (r);
  }
  __globalCloseRef(e) {
    this.__shouldStaticallyCloseForGlobal(e) ? this.__staticCloseRef(e) : this.__dynamicCloseRef(e);
  }
  __close(e) {
    let r;
    this.__shouldStaticallyClose(e) ? r = this.__staticCloseRef : this.type !== "global" ? r = this.__dynamicCloseRef : r = this.__globalCloseRef;
    for (let s = 0, n = this.__left.length; s < n; ++s) {
      const a = this.__left[s];
      r.call(this, a);
    }
    return this.__left = null, this.upper;
  }
  // To override by function scopes.
  // References in default parameters isn't resolved to variables which are in their function body.
  __isValidResolution(e, r) {
    return !0;
  }
  __resolve(e) {
    const r = e.identifier.name;
    if (!this.set.has(r))
      return !1;
    const s = this.set.get(r);
    return this.__isValidResolution(e, s) ? (s.references.push(e), s.stack = s.stack && e.from.variableScope === this.variableScope, e.tainted && (s.tainted = !0, this.taints.set(s.name, !0)), e.resolved = s, !0) : !1;
  }
  __delegateToUpperScope(e) {
    this.upper && this.upper.__left.push(e), this.through.push(e);
  }
  __addDeclaredVariablesOfNode(e, r) {
    if (r == null)
      return;
    let s = this.__declaredVariables.get(r);
    s == null && (s = [], this.__declaredVariables.set(r, s)), s.indexOf(e) === -1 && s.push(e);
  }
  __defineGeneric(e, r, s, n, a) {
    let o;
    o = r.get(e), o || (o = new Rs(e, this), r.set(e, o), s.push(o)), a && (o.defs.push(a), this.__addDeclaredVariablesOfNode(o, a.node), this.__addDeclaredVariablesOfNode(o, a.parent)), n && o.identifiers.push(n);
  }
  __define(e, r) {
    e && e.type === cr.Identifier && this.__defineGeneric(
      e.name,
      this.set,
      this.variables,
      e,
      r
    );
  }
  __referencing(e, r, s, n, a, o) {
    if (!e || e.type !== cr.Identifier || e.name === "super")
      return;
    const l = new Bd(e, this, r || Bd.READ, s, n, !!a, !!o);
    this.references.push(l), this.__left.push(l);
  }
  __detectEval() {
    let e = this;
    this.directCallToEvalScope = !0;
    do
      e.dynamic = !0, e = e.upper;
    while (e);
  }
  __detectThis() {
    this.thisFound = !0;
  }
  __isClosed() {
    return this.__left === null;
  }
  /**
   * returns resolved {Reference}
   * @method Scope#resolve
   * @param {Espree.Identifier} ident - identifier to be resolved.
   * @returns {Reference} reference
   */
  resolve(e) {
    let r, s, n;
    for (al(this.__isClosed(), "Scope should be closed."), al(e.type === cr.Identifier, "Target should be identifier."), s = 0, n = this.references.length; s < n; ++s)
      if (r = this.references[s], r.identifier === e)
        return r;
    return null;
  }
  /**
   * returns this scope is static
   * @method Scope#isStatic
   * @returns {boolean} static
   */
  isStatic() {
    return !this.dynamic;
  }
  /**
   * returns this scope has materialized arguments
   * @method Scope#isArgumentsMaterialized
   * @returns {boolean} arguemnts materialized
   */
  isArgumentsMaterialized() {
    return !0;
  }
  /**
   * returns this scope has materialized `this` reference
   * @method Scope#isThisMaterialized
   * @returns {boolean} this materialized
   */
  isThisMaterialized() {
    return !0;
  }
  isUsedName(e) {
    if (this.set.has(e))
      return !0;
    for (let r = 0, s = this.through.length; r < s; ++r)
      if (this.through[r].identifier.name === e)
        return !0;
    return !1;
  }
}, QC = class extends yr {
  constructor(e, r) {
    super(e, "global", null, r, !1), this.implicit = {
      set: /* @__PURE__ */ new Map(),
      variables: [],
      /**
      * List of {@link Reference}s that are left to be resolved (i.e. which
      * need to be linked to the variable they refer to).
      * @member {Reference[]} Scope#implicit#left
      */
      left: []
    };
  }
  __close(e) {
    const r = [];
    for (let s = 0, n = this.__left.length; s < n; ++s) {
      const a = this.__left[s];
      a.__maybeImplicitGlobal && !this.set.has(a.identifier.name) && r.push(a.__maybeImplicitGlobal);
    }
    for (let s = 0, n = r.length; s < n; ++s) {
      const a = r[s];
      this.__defineImplicit(
        a.pattern,
        new cx(
          Rs.ImplicitGlobalVariable,
          a.pattern,
          a.node,
          null,
          null,
          null
        )
      );
    }
    return this.implicit.left = this.__left, super.__close(e);
  }
  __defineImplicit(e, r) {
    e && e.type === cr.Identifier && this.__defineGeneric(
      e.name,
      this.implicit.set,
      this.implicit.variables,
      e,
      r
    );
  }
}, YC = class extends yr {
  constructor(e, r, s) {
    super(e, "module", r, s, !1);
  }
}, ZC = class extends yr {
  constructor(e, r, s) {
    super(e, "function-expression-name", r, s, !1), this.__define(
      s.id,
      new cx(
        Rs.FunctionName,
        s.id,
        s,
        null,
        null,
        null
      )
    ), this.functionExpressionScope = !0;
  }
}, eS = class extends yr {
  constructor(e, r, s) {
    super(e, "catch", r, s, !1);
  }
}, tS = class extends yr {
  constructor(e, r, s) {
    super(e, "with", r, s, !1);
  }
  __close(e) {
    if (this.__shouldStaticallyClose(e))
      return super.__close(e);
    for (let r = 0, s = this.__left.length; r < s; ++r) {
      const n = this.__left[r];
      n.tainted = !0, this.__delegateToUpperScope(n);
    }
    return this.__left = null, this.upper;
  }
}, rS = class extends yr {
  constructor(e, r, s) {
    super(e, "block", r, s, !1);
  }
}, nS = class extends yr {
  constructor(e, r, s) {
    super(e, "switch", r, s, !1);
  }
}, sS = class extends yr {
  constructor(e, r, s, n) {
    super(e, "function", r, s, n), this.block.type !== cr.ArrowFunctionExpression && this.__defineArguments();
  }
  isArgumentsMaterialized() {
    if (this.block.type === cr.ArrowFunctionExpression)
      return !1;
    if (!this.isStatic())
      return !0;
    const e = this.set.get("arguments");
    return al(e, "Always have arguments variable."), e.tainted || e.references.length !== 0;
  }
  isThisMaterialized() {
    return this.isStatic() ? this.thisFound : !0;
  }
  __defineArguments() {
    this.__defineGeneric(
      "arguments",
      this.set,
      this.variables,
      null,
      null
    ), this.taints.set("arguments", !0);
  }
  // References in default parameters isn't resolved to variables which are in their function body.
  //     const x = 1
  //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
  //         const x = 2
  //         console.log(a)
  //     }
  __isValidResolution(e, r) {
    if (this.block.type === "Program")
      return !0;
    const s = this.block.body.range[0];
    return !(r.scope === this && e.identifier.range[0] < s && // the reference is in the parameter part.
    r.defs.every((n) => n.name.range[0] >= s));
  }
}, aS = class extends yr {
  constructor(e, r, s) {
    super(e, "for", r, s, !1);
  }
}, iS = class extends yr {
  constructor(e, r, s) {
    super(e, "class", r, s, !1);
  }
};
var px = {
  Scope: yr,
  GlobalScope: QC,
  ModuleScope: YC,
  FunctionExpressionNameScope: ZC,
  CatchScope: eS,
  WithScope: tS,
  BlockScope: rS,
  SwitchScope: nS,
  FunctionScope: sS,
  ForScope: aS,
  ClassScope: iS
};
const Fr = px, oS = os, Od = Fr.GlobalScope, lS = Fr.CatchScope, uS = Fr.WithScope, cS = Fr.ModuleScope, pS = Fr.ClassScope, fS = Fr.SwitchScope, hS = Fr.FunctionScope, mS = Fr.ForScope, dS = Fr.FunctionExpressionNameScope, gS = Fr.BlockScope;
let yS = class {
  constructor(e) {
    this.scopes = [], this.globalScope = null, this.__nodeToScope = /* @__PURE__ */ new WeakMap(), this.__currentScope = null, this.__options = e, this.__declaredVariables = /* @__PURE__ */ new WeakMap();
  }
  __useDirective() {
    return this.__options.directive;
  }
  __isOptimistic() {
    return this.__options.optimistic;
  }
  __ignoreEval() {
    return this.__options.ignoreEval;
  }
  __isNodejsScope() {
    return this.__options.nodejsScope;
  }
  isModule() {
    return this.__options.sourceType === "module";
  }
  isImpliedStrict() {
    return this.__options.impliedStrict;
  }
  isStrictModeSupported() {
    return this.__options.ecmaVersion >= 5;
  }
  // Returns appropriate scope for this node.
  __get(e) {
    return this.__nodeToScope.get(e);
  }
  /**
   * Get variables that are declared by the node.
   *
   * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
   * If the node declares nothing, this method returns an empty array.
   * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
   *
   * @param {Espree.Node} node - a node to get.
   * @returns {Variable[]} variables that declared by the node.
   */
  getDeclaredVariables(e) {
    return this.__declaredVariables.get(e) || [];
  }
  /**
   * acquire scope from node.
   * @method ScopeManager#acquire
   * @param {Espree.Node} node - node for the acquired scope.
   * @param {boolean=} inner - look up the most inner scope, default value is false.
   * @returns {Scope?} Scope from node
   */
  acquire(e, r) {
    function s(a) {
      return !(a.type === "function" && a.functionExpressionScope);
    }
    const n = this.__get(e);
    if (!n || n.length === 0)
      return null;
    if (n.length === 1)
      return n[0];
    if (r)
      for (let a = n.length - 1; a >= 0; --a) {
        const o = n[a];
        if (s(o))
          return o;
      }
    else
      for (let a = 0, o = n.length; a < o; ++a) {
        const l = n[a];
        if (s(l))
          return l;
      }
    return null;
  }
  /**
   * acquire all scopes from node.
   * @method ScopeManager#acquireAll
   * @param {Espree.Node} node - node for the acquired scope.
   * @returns {Scopes?} Scope array
   */
  acquireAll(e) {
    return this.__get(e);
  }
  /**
   * release the node.
   * @method ScopeManager#release
   * @param {Espree.Node} node - releasing node.
   * @param {boolean=} inner - look up the most inner scope, default value is false.
   * @returns {Scope?} upper scope for the node.
   */
  release(e, r) {
    const s = this.__get(e);
    if (s && s.length) {
      const n = s[0].upper;
      return n ? this.acquire(n.block, r) : null;
    }
    return null;
  }
  attach() {
  }
  // eslint-disable-line class-methods-use-this
  detach() {
  }
  // eslint-disable-line class-methods-use-this
  __nestScope(e) {
    return e instanceof Od && (oS(this.__currentScope === null), this.globalScope = e), this.__currentScope = e, e;
  }
  __nestGlobalScope(e) {
    return this.__nestScope(new Od(this, e));
  }
  __nestBlockScope(e) {
    return this.__nestScope(new gS(this, this.__currentScope, e));
  }
  __nestFunctionScope(e, r) {
    return this.__nestScope(new hS(this, this.__currentScope, e, r));
  }
  __nestForScope(e) {
    return this.__nestScope(new mS(this, this.__currentScope, e));
  }
  __nestCatchScope(e) {
    return this.__nestScope(new lS(this, this.__currentScope, e));
  }
  __nestWithScope(e) {
    return this.__nestScope(new uS(this, this.__currentScope, e));
  }
  __nestClassScope(e) {
    return this.__nestScope(new pS(this, this.__currentScope, e));
  }
  __nestSwitchScope(e) {
    return this.__nestScope(new fS(this, this.__currentScope, e));
  }
  __nestModuleScope(e) {
    return this.__nestScope(new cS(this, this.__currentScope, e));
  }
  __nestFunctionExpressionNameScope(e) {
    return this.__nestScope(new dS(this, this.__currentScope, e));
  }
  __isES6() {
    return this.__options.ecmaVersion >= 6;
  }
};
var xS = yS, Fs = {}, fx = {};
(function(t) {
  (function e(r) {
    var s, n, a, o, l, i;
    function u(v) {
      var C = {}, T, w;
      for (T in v)
        v.hasOwnProperty(T) && (w = v[T], typeof w == "object" && w !== null ? C[T] = u(w) : C[T] = w);
      return C;
    }
    function c(v, C) {
      var T, w, B, I;
      for (w = v.length, B = 0; w; )
        T = w >>> 1, I = B + T, C(v[I]) ? w = T : (B = I + 1, w -= T + 1);
      return B;
    }
    s = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      // CAUTION: It's deferred to ES7.
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: "ComprehensionExpression",
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      // CAUTION: It's deferred to ES7.
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      PrivateIdentifier: "PrivateIdentifier",
      Program: "Program",
      Property: "Property",
      PropertyDefinition: "PropertyDefinition",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, a = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      // CAUTION: It's deferred to ES7.
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: ["key", "value"],
      PropertyDefinition: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    }, o = {}, l = {}, i = {}, n = {
      Break: o,
      Skip: l,
      Remove: i
    };
    function f(v, C) {
      this.parent = v, this.key = C;
    }
    f.prototype.replace = function(C) {
      this.parent[this.key] = C;
    }, f.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    };
    function h(v, C, T, w) {
      this.node = v, this.path = C, this.wrap = T, this.ref = w;
    }
    function p() {
    }
    p.prototype.path = function() {
      var C, T, w, B, I, _;
      function S(F, N) {
        if (Array.isArray(N))
          for (w = 0, B = N.length; w < B; ++w)
            F.push(N[w]);
        else
          F.push(N);
      }
      if (!this.__current.path)
        return null;
      for (I = [], C = 2, T = this.__leavelist.length; C < T; ++C)
        _ = this.__leavelist[C], S(I, _.path);
      return S(I, this.__current.path), I;
    }, p.prototype.type = function() {
      var v = this.current();
      return v.type || this.__current.wrap;
    }, p.prototype.parents = function() {
      var C, T, w;
      for (w = [], C = 1, T = this.__leavelist.length; C < T; ++C)
        w.push(this.__leavelist[C].node);
      return w;
    }, p.prototype.current = function() {
      return this.__current.node;
    }, p.prototype.__execute = function(C, T) {
      var w, B;
      return B = void 0, w = this.__current, this.__current = T, this.__state = null, C && (B = C.call(this, T.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = w, B;
    }, p.prototype.notify = function(C) {
      this.__state = C;
    }, p.prototype.skip = function() {
      this.notify(l);
    }, p.prototype.break = function() {
      this.notify(o);
    }, p.prototype.remove = function() {
      this.notify(i);
    }, p.prototype.__initialize = function(v, C) {
      this.visitor = C, this.root = v, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, C.fallback === "iteration" ? this.__fallback = Object.keys : typeof C.fallback == "function" && (this.__fallback = C.fallback), this.__keys = a, C.keys && (this.__keys = Object.assign(Object.create(this.__keys), C.keys));
    };
    function m(v) {
      return v == null ? !1 : typeof v == "object" && typeof v.type == "string";
    }
    function d(v, C) {
      return (v === s.ObjectExpression || v === s.ObjectPattern) && C === "properties";
    }
    function g(v, C) {
      for (var T = v.length - 1; T >= 0; --T)
        if (v[T].node === C)
          return !0;
      return !1;
    }
    p.prototype.traverse = function(C, T) {
      var w, B, I, _, S, F, N, k, j, O, z, te;
      for (this.__initialize(C, T), te = {}, w = this.__worklist, B = this.__leavelist, w.push(new h(C, null, null, null)), B.push(new h(null, null, null, null)); w.length; ) {
        if (I = w.pop(), I === te) {
          if (I = B.pop(), F = this.__execute(T.leave, I), this.__state === o || F === o)
            return;
          continue;
        }
        if (I.node) {
          if (F = this.__execute(T.enter, I), this.__state === o || F === o)
            return;
          if (w.push(te), B.push(I), this.__state === l || F === l)
            continue;
          if (_ = I.node, S = _.type || I.wrap, O = this.__keys[S], !O)
            if (this.__fallback)
              O = this.__fallback(_);
            else
              throw new Error("Unknown node type " + S + ".");
          for (k = O.length; (k -= 1) >= 0; )
            if (N = O[k], z = _[N], !!z) {
              if (Array.isArray(z)) {
                for (j = z.length; (j -= 1) >= 0; )
                  if (z[j] && !g(B, z[j])) {
                    if (d(S, O[k]))
                      I = new h(z[j], [N, j], "Property", null);
                    else if (m(z[j]))
                      I = new h(z[j], [N, j], null, null);
                    else
                      continue;
                    w.push(I);
                  }
              } else if (m(z)) {
                if (g(B, z))
                  continue;
                w.push(new h(z, N, null, null));
              }
            }
        }
      }
    }, p.prototype.replace = function(C, T) {
      var w, B, I, _, S, F, N, k, j, O, z, te, se;
      function ye(Se) {
        var xe, Ae, _e, H;
        if (Se.ref.remove()) {
          for (Ae = Se.ref.key, H = Se.ref.parent, xe = w.length; xe--; )
            if (_e = w[xe], _e.ref && _e.ref.parent === H) {
              if (_e.ref.key < Ae)
                break;
              --_e.ref.key;
            }
        }
      }
      for (this.__initialize(C, T), z = {}, w = this.__worklist, B = this.__leavelist, te = {
        root: C
      }, F = new h(C, null, null, new f(te, "root")), w.push(F), B.push(F); w.length; ) {
        if (F = w.pop(), F === z) {
          if (F = B.pop(), S = this.__execute(T.leave, F), S !== void 0 && S !== o && S !== l && S !== i && F.ref.replace(S), (this.__state === i || S === i) && ye(F), this.__state === o || S === o)
            return te.root;
          continue;
        }
        if (S = this.__execute(T.enter, F), S !== void 0 && S !== o && S !== l && S !== i && (F.ref.replace(S), F.node = S), (this.__state === i || S === i) && (ye(F), F.node = null), this.__state === o || S === o)
          return te.root;
        if (I = F.node, !!I && (w.push(z), B.push(F), !(this.__state === l || S === l))) {
          if (_ = I.type || F.wrap, j = this.__keys[_], !j)
            if (this.__fallback)
              j = this.__fallback(I);
            else
              throw new Error("Unknown node type " + _ + ".");
          for (N = j.length; (N -= 1) >= 0; )
            if (se = j[N], O = I[se], !!O)
              if (Array.isArray(O)) {
                for (k = O.length; (k -= 1) >= 0; )
                  if (O[k]) {
                    if (d(_, j[N]))
                      F = new h(O[k], [se, k], "Property", new f(O, k));
                    else if (m(O[k]))
                      F = new h(O[k], [se, k], null, new f(O, k));
                    else
                      continue;
                    w.push(F);
                  }
              } else
                m(O) && w.push(new h(O, se, null, new f(I, se)));
        }
      }
      return te.root;
    };
    function y(v, C) {
      var T = new p();
      return T.traverse(v, C);
    }
    function x(v, C) {
      var T = new p();
      return T.replace(v, C);
    }
    function A(v, C) {
      var T;
      return T = c(C, function(B) {
        return B.range[0] > v.range[0];
      }), v.extendedRange = [v.range[0], v.range[1]], T !== C.length && (v.extendedRange[1] = C[T].range[0]), T -= 1, T >= 0 && (v.extendedRange[0] = C[T].range[1]), v;
    }
    function b(v, C, T) {
      var w = [], B, I, _, S;
      if (!v.range)
        throw new Error("attachComments needs range information");
      if (!T.length) {
        if (C.length) {
          for (_ = 0, I = C.length; _ < I; _ += 1)
            B = u(C[_]), B.extendedRange = [0, v.range[0]], w.push(B);
          v.leadingComments = w;
        }
        return v;
      }
      for (_ = 0, I = C.length; _ < I; _ += 1)
        w.push(A(u(C[_]), T));
      return S = 0, y(v, {
        enter: function(F) {
          for (var N; S < w.length && (N = w[S], !(N.extendedRange[1] > F.range[0])); )
            N.extendedRange[1] === F.range[0] ? (F.leadingComments || (F.leadingComments = []), F.leadingComments.push(N), w.splice(S, 1)) : S += 1;
          if (S === w.length)
            return n.Break;
          if (w[S].extendedRange[0] > F.range[1])
            return n.Skip;
        }
      }), S = 0, y(v, {
        leave: function(F) {
          for (var N; S < w.length && (N = w[S], !(F.range[1] < N.extendedRange[0])); )
            F.range[1] === N.extendedRange[0] ? (F.trailingComments || (F.trailingComments = []), F.trailingComments.push(N), w.splice(S, 1)) : S += 1;
          if (S === w.length)
            return n.Break;
          if (w[S].extendedRange[0] > F.range[1])
            return n.Skip;
        }
      }), v;
    }
    return r.Syntax = s, r.traverse = y, r.replace = x, r.attachComments = b, r.VisitorKeys = a, r.VisitorOption = n, r.Controller = p, r.cloneEnvironment = function() {
      return e({});
    }, r;
  })(t);
})(fx);
var vS = "esrecurse", ES = "ECMAScript AST recursive visitor", bS = "https://github.com/estools/esrecurse", CS = "esrecurse.js", SS = "4.3.0", AS = {
  node: ">=4.0"
}, DS = [
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "https://github.com/Constellation"
  }
], wS = {
  type: "git",
  url: "https://github.com/estools/esrecurse.git"
}, kS = {
  estraverse: "^5.2.0"
}, TS = {
  "babel-cli": "^6.24.1",
  "babel-eslint": "^7.2.3",
  "babel-preset-es2015": "^6.24.1",
  "babel-register": "^6.24.1",
  chai: "^4.0.2",
  esprima: "^4.0.0",
  gulp: "^3.9.0",
  "gulp-bump": "^2.7.0",
  "gulp-eslint": "^4.0.0",
  "gulp-filter": "^5.0.0",
  "gulp-git": "^2.4.1",
  "gulp-mocha": "^4.3.1",
  "gulp-tag-version": "^1.2.1",
  jsdoc: "^3.3.0-alpha10",
  minimist: "^1.1.0"
}, FS = "BSD-2-Clause", PS = {
  test: "gulp travis",
  "unit-test": "gulp test",
  lint: "gulp lint"
}, IS = {
  presets: [
    "es2015"
  ]
}, _S = {
  name: vS,
  description: ES,
  homepage: bS,
  main: CS,
  version: SS,
  engines: AS,
  maintainers: DS,
  repository: wS,
  dependencies: kS,
  devDependencies: TS,
  license: FS,
  scripts: PS,
  babel: IS
};
(function() {
  var t = fx;
  function e(n) {
    return n == null ? !1 : typeof n == "object" && typeof n.type == "string";
  }
  function r(n, a) {
    return (n === t.Syntax.ObjectExpression || n === t.Syntax.ObjectPattern) && a === "properties";
  }
  function s(n, a) {
    a = a || {}, this.__visitor = n || this, this.__childVisitorKeys = a.childVisitorKeys ? Object.assign({}, t.VisitorKeys, a.childVisitorKeys) : t.VisitorKeys, a.fallback === "iteration" ? this.__fallback = Object.keys : typeof a.fallback == "function" && (this.__fallback = a.fallback);
  }
  s.prototype.visitChildren = function(n) {
    var a, o, l, i, u, c, f;
    if (n != null) {
      if (a = n.type || t.Syntax.Property, o = this.__childVisitorKeys[a], !o)
        if (this.__fallback)
          o = this.__fallback(n);
        else
          throw new Error("Unknown node type " + a + ".");
      for (l = 0, i = o.length; l < i; ++l)
        if (f = n[o[l]], f)
          if (Array.isArray(f))
            for (u = 0, c = f.length; u < c; ++u)
              f[u] && (e(f[u]) || r(a, o[l])) && this.visit(f[u]);
          else
            e(f) && this.visit(f);
    }
  }, s.prototype.visit = function(n) {
    var a;
    if (n != null) {
      if (a = n.type || t.Syntax.Property, this.__visitor[a]) {
        this.__visitor[a].call(this, n);
        return;
      }
      this.visitChildren(n);
    }
  }, Fs.version = _S.version, Fs.Visitor = s, Fs.visit = function(n, a, o) {
    var l = new s(a, o);
    l.visit(n);
  };
})();
const Rn = di.Syntax, BS = Fs;
function OS(t) {
  return t[t.length - 1] || null;
}
let LS = class extends BS.Visitor {
  static isPattern(e) {
    const r = e.type;
    return r === Rn.Identifier || r === Rn.ObjectPattern || r === Rn.ArrayPattern || r === Rn.SpreadElement || r === Rn.RestElement || r === Rn.AssignmentPattern;
  }
  constructor(e, r, s) {
    super(null, e), this.rootPattern = r, this.callback = s, this.assignments = [], this.rightHandNodes = [], this.restElements = [];
  }
  Identifier(e) {
    const r = OS(this.restElements);
    this.callback(e, {
      topLevel: e === this.rootPattern,
      rest: r != null && r.argument === e,
      assignments: this.assignments
    });
  }
  Property(e) {
    e.computed && this.rightHandNodes.push(e.key), this.visit(e.value);
  }
  ArrayPattern(e) {
    for (let r = 0, s = e.elements.length; r < s; ++r) {
      const n = e.elements[r];
      this.visit(n);
    }
  }
  AssignmentPattern(e) {
    this.assignments.push(e), this.visit(e.left), this.rightHandNodes.push(e.right), this.assignments.pop();
  }
  RestElement(e) {
    this.restElements.push(e), this.visit(e.argument), this.restElements.pop();
  }
  MemberExpression(e) {
    e.computed && this.rightHandNodes.push(e.property), this.rightHandNodes.push(e.object);
  }
  //
  // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
  // By spec, LeftHandSideExpression is Pattern or MemberExpression.
  //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
  // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
  //
  SpreadElement(e) {
    this.visit(e.argument);
  }
  ArrayExpression(e) {
    e.elements.forEach(this.visit, this);
  }
  AssignmentExpression(e) {
    this.assignments.push(e), this.visit(e.left), this.rightHandNodes.push(e.right), this.assignments.pop();
  }
  CallExpression(e) {
    e.arguments.forEach((r) => {
      this.rightHandNodes.push(r);
    }), this.visit(e.callee);
  }
};
var RS = LS;
const _r = di.Syntax, hx = Fs, dn = au, Un = gi, il = RS, mx = ux, NS = os, Ld = mx.ParameterDefinition, qn = mx.Definition;
function jS(t, e, r, s) {
  const n = new il(t, e, s);
  n.visit(e), r != null && n.rightHandNodes.forEach(r.visit, r);
}
class MS extends hx.Visitor {
  constructor(e, r) {
    super(null, r.options), this.declaration = e, this.referencer = r;
  }
  visitImport(e, r) {
    this.referencer.visitPattern(e, (s) => {
      this.referencer.currentScope().__define(
        s,
        new qn(
          Un.ImportBinding,
          s,
          r,
          this.declaration,
          null,
          null
        )
      );
    });
  }
  ImportNamespaceSpecifier(e) {
    const r = e.local || e.id;
    r && this.visitImport(r, e);
  }
  ImportDefaultSpecifier(e) {
    const r = e.local || e.id;
    this.visitImport(r, e);
  }
  ImportSpecifier(e) {
    const r = e.local || e.id;
    e.name ? this.visitImport(e.name, e) : this.visitImport(r, e);
  }
}
let $S = class extends hx.Visitor {
  constructor(e, r) {
    super(null, e), this.options = e, this.scopeManager = r, this.parent = null, this.isInnerMethodDefinition = !1;
  }
  currentScope() {
    return this.scopeManager.__currentScope;
  }
  close(e) {
    for (; this.currentScope() && e === this.currentScope().block; )
      this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
  }
  pushInnerMethodDefinition(e) {
    const r = this.isInnerMethodDefinition;
    return this.isInnerMethodDefinition = e, r;
  }
  popInnerMethodDefinition(e) {
    this.isInnerMethodDefinition = e;
  }
  referencingDefaultValue(e, r, s, n) {
    const a = this.currentScope();
    r.forEach((o) => {
      a.__referencing(
        e,
        dn.WRITE,
        o.right,
        s,
        e !== o.left,
        n
      );
    });
  }
  visitPattern(e, r, s) {
    let n = r, a = s;
    typeof r == "function" && (a = r, n = { processRightHandNodes: !1 }), jS(
      this.options,
      e,
      n.processRightHandNodes ? this : null,
      a
    );
  }
  visitFunction(e) {
    let r, s;
    e.type === _r.FunctionDeclaration && this.currentScope().__define(
      e.id,
      new qn(
        Un.FunctionName,
        e.id,
        e,
        null,
        null,
        null
      )
    ), e.type === _r.FunctionExpression && e.id && this.scopeManager.__nestFunctionExpressionNameScope(e), this.scopeManager.__nestFunctionScope(e, this.isInnerMethodDefinition);
    const n = this;
    function a(o, l) {
      n.currentScope().__define(
        o,
        new Ld(
          o,
          e,
          r,
          l.rest
        )
      ), n.referencingDefaultValue(o, l.assignments, null, !0);
    }
    for (r = 0, s = e.params.length; r < s; ++r)
      this.visitPattern(e.params[r], { processRightHandNodes: !0 }, a);
    e.rest && this.visitPattern({
      type: "RestElement",
      argument: e.rest
    }, (o) => {
      this.currentScope().__define(
        o,
        new Ld(
          o,
          e,
          e.params.length,
          !0
        )
      );
    }), e.body && (e.body.type === _r.BlockStatement ? this.visitChildren(e.body) : this.visit(e.body)), this.close(e);
  }
  visitClass(e) {
    e.type === _r.ClassDeclaration && this.currentScope().__define(
      e.id,
      new qn(
        Un.ClassName,
        e.id,
        e,
        null,
        null,
        null
      )
    ), this.visit(e.superClass), this.scopeManager.__nestClassScope(e), e.id && this.currentScope().__define(
      e.id,
      new qn(
        Un.ClassName,
        e.id,
        e
      )
    ), this.visit(e.body), this.close(e);
  }
  visitProperty(e) {
    let r;
    e.computed && this.visit(e.key);
    const s = e.type === _r.MethodDefinition;
    s && (r = this.pushInnerMethodDefinition(!0)), this.visit(e.value), s && this.popInnerMethodDefinition(r);
  }
  visitForIn(e) {
    e.left.type === _r.VariableDeclaration && e.left.kind !== "var" && this.scopeManager.__nestForScope(e), e.left.type === _r.VariableDeclaration ? (this.visit(e.left), this.visitPattern(e.left.declarations[0].id, (r) => {
      this.currentScope().__referencing(r, dn.WRITE, e.right, null, !0, !0);
    })) : this.visitPattern(e.left, { processRightHandNodes: !0 }, (r, s) => {
      let n = null;
      this.currentScope().isStrict || (n = {
        pattern: r,
        node: e
      }), this.referencingDefaultValue(r, s.assignments, n, !1), this.currentScope().__referencing(r, dn.WRITE, e.right, n, !0, !1);
    }), this.visit(e.right), this.visit(e.body), this.close(e);
  }
  visitVariableDeclaration(e, r, s, n) {
    const a = s.declarations[n], o = a.init;
    this.visitPattern(a.id, { processRightHandNodes: !0 }, (l, i) => {
      e.__define(
        l,
        new qn(
          r,
          l,
          a,
          s,
          n,
          s.kind
        )
      ), this.referencingDefaultValue(l, i.assignments, null, !0), o && this.currentScope().__referencing(l, dn.WRITE, o, null, !i.topLevel, !0);
    });
  }
  AssignmentExpression(e) {
    il.isPattern(e.left) ? e.operator === "=" ? this.visitPattern(e.left, { processRightHandNodes: !0 }, (r, s) => {
      let n = null;
      this.currentScope().isStrict || (n = {
        pattern: r,
        node: e
      }), this.referencingDefaultValue(r, s.assignments, n, !1), this.currentScope().__referencing(r, dn.WRITE, e.right, n, !s.topLevel, !1);
    }) : this.currentScope().__referencing(e.left, dn.RW, e.right) : this.visit(e.left), this.visit(e.right);
  }
  CatchClause(e) {
    this.scopeManager.__nestCatchScope(e), this.visitPattern(e.param, { processRightHandNodes: !0 }, (r, s) => {
      this.currentScope().__define(
        r,
        new qn(
          Un.CatchClause,
          e.param,
          e,
          null,
          null,
          null
        )
      ), this.referencingDefaultValue(r, s.assignments, null, !0);
    }), this.visit(e.body), this.close(e);
  }
  Program(e) {
    this.scopeManager.__nestGlobalScope(e), this.scopeManager.__isNodejsScope() && (this.currentScope().isStrict = !1, this.scopeManager.__nestFunctionScope(e, !1)), this.scopeManager.__isES6() && this.scopeManager.isModule() && this.scopeManager.__nestModuleScope(e), this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0), this.visitChildren(e), this.close(e);
  }
  Identifier(e) {
    this.currentScope().__referencing(e);
  }
  UpdateExpression(e) {
    il.isPattern(e.argument) ? this.currentScope().__referencing(e.argument, dn.RW, null) : this.visitChildren(e);
  }
  MemberExpression(e) {
    this.visit(e.object), e.computed && this.visit(e.property);
  }
  Property(e) {
    this.visitProperty(e);
  }
  MethodDefinition(e) {
    this.visitProperty(e);
  }
  BreakStatement() {
  }
  // eslint-disable-line class-methods-use-this
  ContinueStatement() {
  }
  // eslint-disable-line class-methods-use-this
  LabeledStatement(e) {
    this.visit(e.body);
  }
  ForStatement(e) {
    e.init && e.init.type === _r.VariableDeclaration && e.init.kind !== "var" && this.scopeManager.__nestForScope(e), this.visitChildren(e), this.close(e);
  }
  ClassExpression(e) {
    this.visitClass(e);
  }
  ClassDeclaration(e) {
    this.visitClass(e);
  }
  CallExpression(e) {
    !this.scopeManager.__ignoreEval() && e.callee.type === _r.Identifier && e.callee.name === "eval" && this.currentScope().variableScope.__detectEval(), this.visitChildren(e);
  }
  BlockStatement(e) {
    this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(e), this.visitChildren(e), this.close(e);
  }
  ThisExpression() {
    this.currentScope().variableScope.__detectThis();
  }
  WithStatement(e) {
    this.visit(e.object), this.scopeManager.__nestWithScope(e), this.visit(e.body), this.close(e);
  }
  VariableDeclaration(e) {
    const r = e.kind === "var" ? this.currentScope().variableScope : this.currentScope();
    for (let s = 0, n = e.declarations.length; s < n; ++s) {
      const a = e.declarations[s];
      this.visitVariableDeclaration(r, Un.Variable, e, s), a.init && this.visit(a.init);
    }
  }
  // sec 13.11.8
  SwitchStatement(e) {
    this.visit(e.discriminant), this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(e);
    for (let r = 0, s = e.cases.length; r < s; ++r)
      this.visit(e.cases[r]);
    this.close(e);
  }
  FunctionDeclaration(e) {
    this.visitFunction(e);
  }
  FunctionExpression(e) {
    this.visitFunction(e);
  }
  ForOfStatement(e) {
    this.visitForIn(e);
  }
  ForInStatement(e) {
    this.visitForIn(e);
  }
  ArrowFunctionExpression(e) {
    this.visitFunction(e);
  }
  ImportDeclaration(e) {
    NS(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context."), new MS(e, this).visit(e);
  }
  visitExportDeclaration(e) {
    if (!e.source) {
      if (e.declaration) {
        this.visit(e.declaration);
        return;
      }
      this.visitChildren(e);
    }
  }
  // TODO: ExportDeclaration doesn't exist. for bc?
  ExportDeclaration(e) {
    this.visitExportDeclaration(e);
  }
  ExportAllDeclaration(e) {
    this.visitExportDeclaration(e);
  }
  ExportDefaultDeclaration(e) {
    this.visitExportDeclaration(e);
  }
  ExportNamedDeclaration(e) {
    this.visitExportDeclaration(e);
  }
  ExportSpecifier(e) {
    const r = e.id || e.local;
    this.visit(r);
  }
  MetaProperty() {
  }
};
var VS = $S, US = "eslint-scope", qS = "ECMAScript scope analyzer for ESLint", WS = "http://github.com/eslint/eslint-scope", zS = "lib/index.js", GS = "5.1.1", HS = {
  node: ">=8.0.0"
}, KS = "eslint/eslint-scope", JS = {
  url: "https://github.com/eslint/eslint-scope/issues"
}, XS = "BSD-2-Clause", QS = {
  test: "node Makefile.js test",
  lint: "node Makefile.js lint",
  "generate-release": "eslint-generate-release",
  "generate-alpharelease": "eslint-generate-prerelease alpha",
  "generate-betarelease": "eslint-generate-prerelease beta",
  "generate-rcrelease": "eslint-generate-prerelease rc",
  "publish-release": "eslint-publish-release"
}, YS = [
  "LICENSE",
  "README.md",
  "lib"
], ZS = {
  esrecurse: "^4.3.0",
  estraverse: "^4.1.1"
}, eA = {
  "@typescript-eslint/parser": "^1.11.0",
  chai: "^4.2.0",
  eslint: "^6.0.1",
  "eslint-config-eslint": "^5.0.1",
  "eslint-plugin-node": "^9.1.0",
  "eslint-release": "^1.0.0",
  "eslint-visitor-keys": "^1.2.0",
  espree: "^7.1.0",
  istanbul: "^0.4.5",
  mocha: "^6.1.4",
  "npm-license": "^0.3.3",
  shelljs: "^0.8.3",
  typescript: "^3.5.2"
}, tA = {
  name: US,
  description: qS,
  homepage: WS,
  main: zS,
  version: GS,
  engines: HS,
  repository: KS,
  bugs: JS,
  license: XS,
  scripts: QS,
  files: YS,
  dependencies: ZS,
  devDependencies: eA
};
const rA = os, dx = xS, nA = VS, sA = au, aA = gi, iA = px.Scope, oA = tA.version;
function lA() {
  return {
    optimistic: !1,
    directive: !1,
    nodejsScope: !1,
    impliedStrict: !1,
    sourceType: "script",
    // one of ['script', 'module']
    ecmaVersion: 5,
    childVisitorKeys: null,
    fallback: "iteration"
  };
}
function ol(t, e) {
  function r(s) {
    return typeof s == "object" && s instanceof Object && !(s instanceof Array) && !(s instanceof RegExp);
  }
  for (const s in e)
    if (Object.prototype.hasOwnProperty.call(e, s)) {
      const n = e[s];
      r(n) ? r(t[s]) ? ol(t[s], n) : t[s] = ol({}, n) : t[s] = n;
    }
  return t;
}
function uA(t, e) {
  const r = ol(lA(), e), s = new dx(r);
  return new nA(r, s).visit(t), rA(s.__currentScope === null, "currentScope should be null."), s;
}
var cA = {
  /** @name module:escope.version */
  version: oA,
  /** @name module:escope.Reference */
  Reference: sA,
  /** @name module:escope.Variable */
  Variable: aA,
  /** @name module:escope.Scope */
  Scope: iA,
  /** @name module:escope.ScopeManager */
  ScopeManager: dx,
  analyze: uA
}, pA = [
  "left",
  "right"
], fA = [
  "left",
  "right"
], hA = [
  "elements"
], mA = [
  "elements"
], dA = [
  "params",
  "body"
], gA = [
  "argument"
], yA = [
  "body"
], xA = [
  "left",
  "right"
], vA = [
  "label"
], EA = [
  "callee",
  "arguments"
], bA = [
  "param",
  "body"
], CA = [
  "expression"
], SA = [
  "body"
], AA = [
  "id",
  "superClass",
  "body"
], DA = [
  "id",
  "superClass",
  "body"
], wA = [
  "test",
  "consequent",
  "alternate"
], kA = [
  "label"
], TA = [], FA = [
  "body",
  "test"
], PA = [], IA = [
  "exported",
  "source"
], _A = [
  "declaration"
], BA = [
  "declaration",
  "specifiers",
  "source"
], OA = [
  "exported",
  "local"
], LA = [
  "expression"
], RA = [
  "argument"
], NA = [
  "argument"
], jA = [
  "init",
  "test",
  "update",
  "body"
], MA = [
  "left",
  "right",
  "body"
], $A = [
  "left",
  "right",
  "body"
], VA = [
  "id",
  "params",
  "body"
], UA = [
  "id",
  "params",
  "body"
], qA = [], WA = [
  "test",
  "consequent",
  "alternate"
], zA = [
  "specifiers",
  "source"
], GA = [
  "local"
], HA = [
  "source"
], KA = [
  "local"
], JA = [
  "imported",
  "local"
], XA = [
  "name",
  "value"
], QA = [
  "name"
], YA = [
  "openingElement",
  "children",
  "closingElement"
], ZA = [], eD = [
  "expression"
], tD = [], rD = [
  "object",
  "property"
], nD = [
  "namespace",
  "name"
], sD = [
  "name",
  "attributes"
], aD = [
  "argument"
], iD = [], oD = [
  "openingFragment",
  "children",
  "closingFragment"
], lD = [], uD = [
  "label",
  "body"
], cD = [
  "left",
  "right"
], pD = [
  "object",
  "property"
], fD = [
  "meta",
  "property"
], hD = [
  "key",
  "value"
], mD = [
  "callee",
  "arguments"
], dD = [
  "properties"
], gD = [
  "properties"
], yD = [], xD = [
  "body"
], vD = [
  "key",
  "value"
], ED = [
  "key",
  "value"
], bD = [
  "argument"
], CD = [
  "argument"
], SD = [
  "expressions"
], AD = [
  "argument"
], DD = [], wD = [
  "discriminant",
  "cases"
], kD = [
  "test",
  "consequent"
], TD = [
  "tag",
  "quasi"
], FD = [], PD = [
  "quasis",
  "expressions"
], ID = [], _D = [
  "argument"
], BD = [
  "block",
  "handler",
  "finalizer"
], OD = [
  "argument"
], LD = [
  "argument"
], RD = [
  "declarations"
], ND = [
  "id",
  "init"
], jD = [
  "test",
  "body"
], MD = [
  "object",
  "body"
], $D = [
  "argument"
], VD = {
  AssignmentExpression: pA,
  AssignmentPattern: fA,
  ArrayExpression: hA,
  ArrayPattern: mA,
  ArrowFunctionExpression: dA,
  AwaitExpression: gA,
  BlockStatement: yA,
  BinaryExpression: xA,
  BreakStatement: vA,
  CallExpression: EA,
  CatchClause: bA,
  ChainExpression: CA,
  ClassBody: SA,
  ClassDeclaration: AA,
  ClassExpression: DA,
  ConditionalExpression: wA,
  ContinueStatement: kA,
  DebuggerStatement: TA,
  DoWhileStatement: FA,
  EmptyStatement: PA,
  ExportAllDeclaration: IA,
  ExportDefaultDeclaration: _A,
  ExportNamedDeclaration: BA,
  ExportSpecifier: OA,
  ExpressionStatement: LA,
  ExperimentalRestProperty: RA,
  ExperimentalSpreadProperty: NA,
  ForStatement: jA,
  ForInStatement: MA,
  ForOfStatement: $A,
  FunctionDeclaration: VA,
  FunctionExpression: UA,
  Identifier: qA,
  IfStatement: WA,
  ImportDeclaration: zA,
  ImportDefaultSpecifier: GA,
  ImportExpression: HA,
  ImportNamespaceSpecifier: KA,
  ImportSpecifier: JA,
  JSXAttribute: XA,
  JSXClosingElement: QA,
  JSXElement: YA,
  JSXEmptyExpression: ZA,
  JSXExpressionContainer: eD,
  JSXIdentifier: tD,
  JSXMemberExpression: rD,
  JSXNamespacedName: nD,
  JSXOpeningElement: sD,
  JSXSpreadAttribute: aD,
  JSXText: iD,
  JSXFragment: oD,
  Literal: lD,
  LabeledStatement: uD,
  LogicalExpression: cD,
  MemberExpression: pD,
  MetaProperty: fD,
  MethodDefinition: hD,
  NewExpression: mD,
  ObjectExpression: dD,
  ObjectPattern: gD,
  PrivateIdentifier: yD,
  Program: xD,
  Property: vD,
  PropertyDefinition: ED,
  RestElement: bD,
  ReturnStatement: CD,
  SequenceExpression: SD,
  SpreadElement: AD,
  Super: DD,
  SwitchStatement: wD,
  SwitchCase: kD,
  TaggedTemplateExpression: TD,
  TemplateElement: FD,
  TemplateLiteral: PD,
  ThisExpression: ID,
  ThrowStatement: _D,
  TryStatement: BD,
  UnaryExpression: OD,
  UpdateExpression: LD,
  VariableDeclaration: RD,
  VariableDeclarator: ND,
  WhileStatement: jD,
  WithStatement: MD,
  YieldExpression: $D
};
const Ns = VD, UD = Object.freeze(Object.keys(Ns));
for (const t of UD)
  Object.freeze(Ns[t]);
Object.freeze(Ns);
const qD = /* @__PURE__ */ new Set([
  "parent",
  "leadingComments",
  "trailingComments"
]);
function WD(t) {
  return !qD.has(t) && t[0] !== "_";
}
var gx = Object.freeze({
  /**
   * Visitor keys.
   * @type {{ [type: string]: string[] | undefined }}
   */
  KEYS: Ns,
  /**
   * Get visitor keys of a given node.
   * @param {Object} node The AST node to get keys.
   * @returns {string[]} Visitor keys of the node.
   */
  getKeys(t) {
    return Object.keys(t).filter(WD);
  },
  // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
  // eslint-disable-next-line valid-jsdoc
  /**
   * Make the union set with `KEYS` and given keys.
   * @param {Object} additionalKeys The additional keys.
   * @returns {{ [type: string]: string[] | undefined }} The union set.
   */
  unionWith(t) {
    const e = Object.assign({}, Ns);
    for (const r of Object.keys(t))
      if (e.hasOwnProperty(r)) {
        const s = new Set(t[r]);
        for (const n of e[r])
          s.add(n);
        e[r] = Object.freeze(Array.from(s));
      } else
        e[r] = Object.freeze(Array.from(t[r]));
    return Object.freeze(e);
  }
}), Wr = {}, Qi = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, Yi = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", zD = {
  5: Yi,
  "5module": Yi + " export import",
  6: Yi + " const class extends export import super"
}, GD = /^in(stanceof)?$/, iu = "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", yx = "----------------------------------------------------------------------------------------------------------------------------------------------------", HD = new RegExp("[" + iu + "]"), KD = new RegExp("[" + iu + yx + "]");
iu = yx = null;
var xx = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], JD = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function ll(t, e) {
  for (var r = 65536, s = 0; s < e.length; s += 2) {
    if (r += e[s], r > t)
      return !1;
    if (r += e[s + 1], r >= t)
      return !0;
  }
}
function Ur(t, e) {
  return t < 65 ? t === 36 : t < 91 ? !0 : t < 97 ? t === 95 : t < 123 ? !0 : t <= 65535 ? t >= 170 && HD.test(String.fromCharCode(t)) : e === !1 ? !1 : ll(t, xx);
}
function Tn(t, e) {
  return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t < 91 ? !0 : t < 97 ? t === 95 : t < 123 ? !0 : t <= 65535 ? t >= 170 && KD.test(String.fromCharCode(t)) : e === !1 ? !1 : ll(t, xx) || ll(t, JD);
}
var Xe = function(e, r) {
  r === void 0 && (r = {}), this.label = e, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
};
function ir(t, e) {
  return new Xe(t, { beforeExpr: !0, binop: e });
}
var or = { beforeExpr: !0 }, Ht = { startsExpr: !0 }, yi = {};
function Ke(t, e) {
  return e === void 0 && (e = {}), e.keyword = t, yi[t] = new Xe(t, e);
}
var $ = {
  num: new Xe("num", Ht),
  regexp: new Xe("regexp", Ht),
  string: new Xe("string", Ht),
  name: new Xe("name", Ht),
  eof: new Xe("eof"),
  // Punctuation token types.
  bracketL: new Xe("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new Xe("]"),
  braceL: new Xe("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new Xe("}"),
  parenL: new Xe("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new Xe(")"),
  comma: new Xe(",", or),
  semi: new Xe(";", or),
  colon: new Xe(":", or),
  dot: new Xe("."),
  question: new Xe("?", or),
  questionDot: new Xe("?."),
  arrow: new Xe("=>", or),
  template: new Xe("template"),
  invalidTemplate: new Xe("invalidTemplate"),
  ellipsis: new Xe("...", or),
  backQuote: new Xe("`", Ht),
  dollarBraceL: new Xe("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new Xe("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new Xe("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new Xe("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new Xe("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: ir("||", 1),
  logicalAND: ir("&&", 2),
  bitwiseOR: ir("|", 3),
  bitwiseXOR: ir("^", 4),
  bitwiseAND: ir("&", 5),
  equality: ir("==/!=/===/!==", 6),
  relational: ir("</>/<=/>=", 7),
  bitShift: ir("<</>>/>>>", 8),
  plusMin: new Xe("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: ir("%", 10),
  star: ir("*", 10),
  slash: ir("/", 10),
  starstar: new Xe("**", { beforeExpr: !0 }),
  coalesce: ir("??", 1),
  // Keyword token types.
  _break: Ke("break"),
  _case: Ke("case", or),
  _catch: Ke("catch"),
  _continue: Ke("continue"),
  _debugger: Ke("debugger"),
  _default: Ke("default", or),
  _do: Ke("do", { isLoop: !0, beforeExpr: !0 }),
  _else: Ke("else", or),
  _finally: Ke("finally"),
  _for: Ke("for", { isLoop: !0 }),
  _function: Ke("function", Ht),
  _if: Ke("if"),
  _return: Ke("return", or),
  _switch: Ke("switch"),
  _throw: Ke("throw", or),
  _try: Ke("try"),
  _var: Ke("var"),
  _const: Ke("const"),
  _while: Ke("while", { isLoop: !0 }),
  _with: Ke("with"),
  _new: Ke("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: Ke("this", Ht),
  _super: Ke("super", Ht),
  _class: Ke("class", Ht),
  _extends: Ke("extends", or),
  _export: Ke("export"),
  _import: Ke("import", Ht),
  _null: Ke("null", Ht),
  _true: Ke("true", Ht),
  _false: Ke("false", Ht),
  _in: Ke("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: Ke("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: Ke("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: Ke("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: Ke("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, Zt = /\r\n?|\n|\u2028|\u2029/, ss = new RegExp(Zt.source, "g");
function ls(t, e) {
  return t === 10 || t === 13 || !e && (t === 8232 || t === 8233);
}
var ou = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, pr = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, vx = Object.prototype, XD = vx.hasOwnProperty, QD = vx.toString;
function xi(t, e) {
  return XD.call(t, e);
}
var Rd = Array.isArray || function(t) {
  return QD.call(t) === "[object Array]";
};
function Sn(t) {
  return new RegExp("^(?:" + t.replace(/ /g, "|") + ")$");
}
var as = function(e, r) {
  this.line = e, this.column = r;
};
as.prototype.offset = function(e) {
  return new as(this.line, this.column + e);
};
var Gs = function(e, r, s) {
  this.start = r, this.end = s, e.sourceFile !== null && (this.source = e.sourceFile);
};
function lu(t, e) {
  for (var r = 1, s = 0; ; ) {
    ss.lastIndex = s;
    var n = ss.exec(t);
    if (n && n.index < e)
      ++r, s = n.index + n[0].length;
    else
      return new as(r, e - s);
  }
}
var qa = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10
  // (2019). This influences support for strict mode, the set of
  // reserved words, and support for new syntax features. The default
  // is 10.
  ecmaVersion: 10,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: !1,
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: !1,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: !1,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callbackthat will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callbackthat will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
};
function YD(t) {
  var e = {};
  for (var r in qa)
    e[r] = t && xi(t, r) ? t[r] : qa[r];
  if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), e.allowReserved == null && (e.allowReserved = e.ecmaVersion < 5), Rd(e.onToken)) {
    var s = e.onToken;
    e.onToken = function(n) {
      return s.push(n);
    };
  }
  return Rd(e.onComment) && (e.onComment = ZD(e, e.onComment)), e;
}
function ZD(t, e) {
  return function(r, s, n, a, o, l) {
    var i = {
      type: r ? "Block" : "Line",
      value: s,
      start: n,
      end: a
    };
    t.locations && (i.loc = new Gs(this, o, l)), t.ranges && (i.range = [n, a]), e.push(i);
  };
}
var js = 1, Hs = 2, uu = js | Hs, Ex = 4, bx = 8, Cx = 16, Sx = 32, Ax = 64, Dx = 128;
function cu(t, e) {
  return Hs | (t ? Ex : 0) | (e ? bx : 0);
}
var Nd = 0, pu = 1, Vr = 2, wx = 3, kx = 4, Tx = 5, ht = function(e, r, s) {
  this.options = e = YD(e), this.sourceFile = e.sourceFile, this.keywords = Sn(zD[e.ecmaVersion >= 6 ? 6 : e.sourceType === "module" ? "5module" : 5]);
  var n = "";
  if (e.allowReserved !== !0) {
    for (var a = e.ecmaVersion; !(n = Qi[a]); a--)
      ;
    e.sourceType === "module" && (n += " await");
  }
  this.reservedWords = Sn(n);
  var o = (n ? n + " " : "") + Qi.strict;
  this.reservedWordsStrict = Sn(o), this.reservedWordsStrictBind = Sn(o + " " + Qi.strictBind), this.input = String(r), this.containsEsc = !1, s ? (this.pos = s, this.lineStart = this.input.lastIndexOf(`
`, s - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Zt).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = $.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = e.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(js), this.regexpState = null;
}, _n = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 } };
ht.prototype.parse = function() {
  var e = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(e);
};
_n.inFunction.get = function() {
  return (this.currentVarScope().flags & Hs) > 0;
};
_n.inGenerator.get = function() {
  return (this.currentVarScope().flags & bx) > 0;
};
_n.inAsync.get = function() {
  return (this.currentVarScope().flags & Ex) > 0;
};
_n.allowSuper.get = function() {
  return (this.currentThisScope().flags & Ax) > 0;
};
_n.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & Dx) > 0;
};
_n.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
ht.prototype.inNonArrowFunction = function() {
  return (this.currentThisScope().flags & Hs) > 0;
};
ht.extend = function() {
  for (var e = [], r = arguments.length; r--; )
    e[r] = arguments[r];
  for (var s = this, n = 0; n < e.length; n++)
    s = e[n](s);
  return s;
};
ht.parse = function(e, r) {
  return new this(r, e).parse();
};
ht.parseExpressionAt = function(e, r, s) {
  var n = new this(s, e, r);
  return n.nextToken(), n.parseExpression();
};
ht.tokenizer = function(e, r) {
  return new this(r, e);
};
Object.defineProperties(ht.prototype, _n);
var Mt = ht.prototype, ew = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
Mt.strictDirective = function(t) {
  for (; ; ) {
    pr.lastIndex = t, t += pr.exec(this.input)[0].length;
    var e = ew.exec(this.input.slice(t));
    if (!e)
      return !1;
    if ((e[1] || e[2]) === "use strict") {
      pr.lastIndex = t + e[0].length;
      var r = pr.exec(this.input), s = r.index + r[0].length, n = this.input.charAt(s);
      return n === ";" || n === "}" || Zt.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n) || n === "!" && this.input.charAt(s + 1) === "=");
    }
    t += e[0].length, pr.lastIndex = t, t += pr.exec(this.input)[0].length, this.input[t] === ";" && t++;
  }
};
Mt.eat = function(t) {
  return this.type === t ? (this.next(), !0) : !1;
};
Mt.isContextual = function(t) {
  return this.type === $.name && this.value === t && !this.containsEsc;
};
Mt.eatContextual = function(t) {
  return this.isContextual(t) ? (this.next(), !0) : !1;
};
Mt.expectContextual = function(t) {
  this.eatContextual(t) || this.unexpected();
};
Mt.canInsertSemicolon = function() {
  return this.type === $.eof || this.type === $.braceR || Zt.test(this.input.slice(this.lastTokEnd, this.start));
};
Mt.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
Mt.semicolon = function() {
  !this.eat($.semi) && !this.insertSemicolon() && this.unexpected();
};
Mt.afterTrailingComma = function(t, e) {
  if (this.type === t)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0;
};
Mt.expect = function(t) {
  this.eat(t) || this.unexpected();
};
Mt.unexpected = function(t) {
  this.raise(t ?? this.start, "Unexpected token");
};
function vi() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
Mt.checkPatternErrors = function(t, e) {
  if (t) {
    t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element");
    var r = e ? t.parenthesizedAssign : t.parenthesizedBind;
    r > -1 && this.raiseRecoverable(r, "Parenthesized pattern");
  }
};
Mt.checkExpressionErrors = function(t, e) {
  if (!t)
    return !1;
  var r = t.shorthandAssign, s = t.doubleProto;
  if (!e)
    return r >= 0 || s >= 0;
  r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), s >= 0 && this.raiseRecoverable(s, "Redefinition of __proto__ property");
};
Mt.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
Mt.isSimpleAssignTarget = function(t) {
  return t.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(t.expression) : t.type === "Identifier" || t.type === "MemberExpression";
};
var $e = ht.prototype;
$e.parseTopLevel = function(t) {
  var e = {};
  for (t.body || (t.body = []); this.type !== $.eof; ) {
    var r = this.parseStatement(null, !0, e);
    t.body.push(r);
  }
  if (this.inModule)
    for (var s = 0, n = Object.keys(this.undefinedExports); s < n.length; s += 1) {
      var a = n[s];
      this.raiseRecoverable(this.undefinedExports[a].start, "Export '" + a + "' is not defined");
    }
  return this.adaptDirectivePrologue(t.body), this.next(), t.sourceType = this.options.sourceType, this.finishNode(t, "Program");
};
var fu = { kind: "loop" }, tw = { kind: "switch" };
$e.isLet = function(t) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  pr.lastIndex = this.pos;
  var e = pr.exec(this.input), r = this.pos + e[0].length, s = this.input.charCodeAt(r);
  if (s === 91)
    return !0;
  if (t)
    return !1;
  if (s === 123)
    return !0;
  if (Ur(s, !0)) {
    for (var n = r + 1; Tn(this.input.charCodeAt(n), !0); )
      ++n;
    var a = this.input.slice(r, n);
    if (!GD.test(a))
      return !0;
  }
  return !1;
};
$e.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  pr.lastIndex = this.pos;
  var t = pr.exec(this.input), e = this.pos + t[0].length;
  return !Zt.test(this.input.slice(this.pos, e)) && this.input.slice(e, e + 8) === "function" && (e + 8 === this.input.length || !Tn(this.input.charAt(e + 8)));
};
$e.parseStatement = function(t, e, r) {
  var s = this.type, n = this.startNode(), a;
  switch (this.isLet(t) && (s = $._var, a = "let"), s) {
    case $._break:
    case $._continue:
      return this.parseBreakContinueStatement(n, s.keyword);
    case $._debugger:
      return this.parseDebuggerStatement(n);
    case $._do:
      return this.parseDoStatement(n);
    case $._for:
      return this.parseForStatement(n);
    case $._function:
      return t && (this.strict || t !== "if" && t !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, !1, !t);
    case $._class:
      return t && this.unexpected(), this.parseClass(n, !0);
    case $._if:
      return this.parseIfStatement(n);
    case $._return:
      return this.parseReturnStatement(n);
    case $._switch:
      return this.parseSwitchStatement(n);
    case $._throw:
      return this.parseThrowStatement(n);
    case $._try:
      return this.parseTryStatement(n);
    case $._const:
    case $._var:
      return a = a || this.value, t && a !== "var" && this.unexpected(), this.parseVarStatement(n, a);
    case $._while:
      return this.parseWhileStatement(n);
    case $._with:
      return this.parseWithStatement(n);
    case $.braceL:
      return this.parseBlock(!0, n);
    case $.semi:
      return this.parseEmptyStatement(n);
    case $._export:
    case $._import:
      if (this.options.ecmaVersion > 10 && s === $._import) {
        pr.lastIndex = this.pos;
        var o = pr.exec(this.input), l = this.pos + o[0].length, i = this.input.charCodeAt(l);
        if (i === 40 || i === 46)
          return this.parseExpressionStatement(n, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), s === $._import ? this.parseImport(n) : this.parseExport(n, r);
    default:
      if (this.isAsyncFunction())
        return t && this.unexpected(), this.next(), this.parseFunctionStatement(n, !0, !t);
      var u = this.value, c = this.parseExpression();
      return s === $.name && c.type === "Identifier" && this.eat($.colon) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c);
  }
};
$e.parseBreakContinueStatement = function(t, e) {
  var r = e === "break";
  this.next(), this.eat($.semi) || this.insertSemicolon() ? t.label = null : this.type !== $.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon());
  for (var s = 0; s < this.labels.length; ++s) {
    var n = this.labels[s];
    if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === "loop") || t.label && r))
      break;
  }
  return s === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
};
$e.parseDebuggerStatement = function(t) {
  return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
};
$e.parseDoStatement = function(t) {
  return this.next(), this.labels.push(fu), t.body = this.parseStatement("do"), this.labels.pop(), this.expect($._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat($.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement");
};
$e.parseForStatement = function(t) {
  this.next();
  var e = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(fu), this.enterScope(0), this.expect($.parenL), this.type === $.semi)
    return e > -1 && this.unexpected(e), this.parseFor(t, null);
  var r = this.isLet();
  if (this.type === $._var || this.type === $._const || r) {
    var s = this.startNode(), n = r ? "let" : this.value;
    return this.next(), this.parseVar(s, !0, n), this.finishNode(s, "VariableDeclaration"), (this.type === $._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && s.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === $._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, s)) : (e > -1 && this.unexpected(e), this.parseFor(t, s));
  }
  var a = new vi(), o = this.parseExpression(!0, a);
  return this.type === $._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === $._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.toAssignable(o, !1, a), this.checkLVal(o), this.parseForIn(t, o)) : (this.checkExpressionErrors(a, !0), e > -1 && this.unexpected(e), this.parseFor(t, o));
};
$e.parseFunctionStatement = function(t, e, r) {
  return this.next(), this.parseFunction(t, Ps | (r ? 0 : ul), !1, e);
};
$e.parseIfStatement = function(t) {
  return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat($._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
};
$e.parseReturnStatement = function(t) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat($.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
};
$e.parseSwitchStatement = function(t) {
  this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect($.braceL), this.labels.push(tw), this.enterScope(0);
  for (var e, r = !1; this.type !== $.braceR; )
    if (this.type === $._case || this.type === $._default) {
      var s = this.type === $._case;
      e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), s ? e.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, e.test = null), this.expect($.colon);
    } else
      e || this.unexpected(), e.consequent.push(this.parseStatement(null));
  return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement");
};
$e.parseThrowStatement = function(t) {
  return this.next(), Zt.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
};
var rw = [];
$e.parseTryStatement = function(t) {
  if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === $._catch) {
    var e = this.startNode();
    if (this.next(), this.eat($.parenL)) {
      e.param = this.parseBindingAtom();
      var r = e.param.type === "Identifier";
      this.enterScope(r ? Sx : 0), this.checkLVal(e.param, r ? kx : Vr), this.expect($.parenR);
    } else
      this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0);
    e.body = this.parseBlock(!1), this.exitScope(), t.handler = this.finishNode(e, "CatchClause");
  }
  return t.finalizer = this.eat($._finally) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement");
};
$e.parseVarStatement = function(t, e) {
  return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
};
$e.parseWhileStatement = function(t) {
  return this.next(), t.test = this.parseParenExpression(), this.labels.push(fu), t.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(t, "WhileStatement");
};
$e.parseWithStatement = function(t) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement("with"), this.finishNode(t, "WithStatement");
};
$e.parseEmptyStatement = function(t) {
  return this.next(), this.finishNode(t, "EmptyStatement");
};
$e.parseLabeledStatement = function(t, e, r, s) {
  for (var n = 0, a = this.labels; n < a.length; n += 1) {
    var o = a[n];
    o.name === e && this.raise(r.start, "Label '" + e + "' is already declared");
  }
  for (var l = this.type.isLoop ? "loop" : this.type === $._switch ? "switch" : null, i = this.labels.length - 1; i >= 0; i--) {
    var u = this.labels[i];
    if (u.statementStart === t.start)
      u.statementStart = this.start, u.kind = l;
    else
      break;
  }
  return this.labels.push({ name: e, kind: l, statementStart: this.start }), t.body = this.parseStatement(s ? s.indexOf("label") === -1 ? s + "label" : s : "label"), this.labels.pop(), t.label = r, this.finishNode(t, "LabeledStatement");
};
$e.parseExpressionStatement = function(t, e) {
  return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
};
$e.parseBlock = function(t, e, r) {
  for (t === void 0 && (t = !0), e === void 0 && (e = this.startNode()), e.body = [], this.expect($.braceL), t && this.enterScope(0); this.type !== $.braceR; ) {
    var s = this.parseStatement(null);
    e.body.push(s);
  }
  return r && (this.strict = !1), this.next(), t && this.exitScope(), this.finishNode(e, "BlockStatement");
};
$e.parseFor = function(t, e) {
  return t.init = e, this.expect($.semi), t.test = this.type === $.semi ? null : this.parseExpression(), this.expect($.semi), t.update = this.type === $.parenR ? null : this.parseExpression(), this.expect($.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, "ForStatement");
};
$e.parseForIn = function(t, e) {
  var r = this.type === $._in;
  return this.next(), e.type === "VariableDeclaration" && e.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") ? this.raise(
    e.start,
    (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ) : e.type === "AssignmentPattern" && this.raise(e.start, "Invalid left-hand side in for-loop"), t.left = e, t.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect($.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, r ? "ForInStatement" : "ForOfStatement");
};
$e.parseVar = function(t, e, r) {
  for (t.declarations = [], t.kind = r; ; ) {
    var s = this.startNode();
    if (this.parseVarId(s, r), this.eat($.eq) ? s.init = this.parseMaybeAssign(e) : r === "const" && !(this.type === $._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : s.id.type !== "Identifier" && !(e && (this.type === $._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : s.init = null, t.declarations.push(this.finishNode(s, "VariableDeclarator")), !this.eat($.comma))
      break;
  }
  return t;
};
$e.parseVarId = function(t, e) {
  t.id = this.parseBindingAtom(), this.checkLVal(t.id, e === "var" ? pu : Vr, !1);
};
var Ps = 1, ul = 2, Fx = 4;
$e.parseFunction = function(t, e, r, s) {
  this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s) && (this.type === $.star && e & ul && this.unexpected(), t.generator = this.eat($.star)), this.options.ecmaVersion >= 8 && (t.async = !!s), e & Ps && (t.id = e & Fx && this.type !== $.name ? null : this.parseIdent(), t.id && !(e & ul) && this.checkLVal(t.id, this.strict || t.generator || t.async ? this.treatFunctionsAsVar ? pu : Vr : wx));
  var n = this.yieldPos, a = this.awaitPos, o = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(cu(t.async, t.generator)), e & Ps || (t.id = this.type === $.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, r, !1), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = o, this.finishNode(t, e & Ps ? "FunctionDeclaration" : "FunctionExpression");
};
$e.parseFunctionParams = function(t) {
  this.expect($.parenL), t.params = this.parseBindingList($.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
$e.parseClass = function(t, e) {
  this.next();
  var r = this.strict;
  this.strict = !0, this.parseClassId(t, e), this.parseClassSuper(t);
  var s = this.startNode(), n = !1;
  for (s.body = [], this.expect($.braceL); this.type !== $.braceR; ) {
    var a = this.parseClassElement(t.superClass !== null);
    a && (s.body.push(a), a.type === "MethodDefinition" && a.kind === "constructor" && (n && this.raise(a.start, "Duplicate constructor in the same class"), n = !0));
  }
  return this.strict = r, this.next(), t.body = this.finishNode(s, "ClassBody"), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
};
$e.parseClassElement = function(t) {
  var e = this;
  if (this.eat($.semi))
    return null;
  var r = this.startNode(), s = function(i, u) {
    u === void 0 && (u = !1);
    var c = e.start, f = e.startLoc;
    return e.eatContextual(i) ? e.type !== $.parenL && (!u || !e.canInsertSemicolon()) ? !0 : (r.key && e.unexpected(), r.computed = !1, r.key = e.startNodeAt(c, f), r.key.name = i, e.finishNode(r.key, "Identifier"), !1) : !1;
  };
  r.kind = "method", r.static = s("static");
  var n = this.eat($.star), a = !1;
  n || (this.options.ecmaVersion >= 8 && s("async", !0) ? (a = !0, n = this.options.ecmaVersion >= 9 && this.eat($.star)) : s("get") ? r.kind = "get" : s("set") && (r.kind = "set")), r.key || this.parsePropertyName(r);
  var o = r.key, l = !1;
  return !r.computed && !r.static && (o.type === "Identifier" && o.name === "constructor" || o.type === "Literal" && o.value === "constructor") ? (r.kind !== "method" && this.raise(o.start, "Constructor can't have get/set modifier"), n && this.raise(o.start, "Constructor can't be a generator"), a && this.raise(o.start, "Constructor can't be an async method"), r.kind = "constructor", l = t) : r.static && o.type === "Identifier" && o.name === "prototype" && this.raise(o.start, "Classes may not have a static property named prototype"), this.parseClassMethod(r, n, a, l), r.kind === "get" && r.value.params.length !== 0 && this.raiseRecoverable(r.value.start, "getter should have no params"), r.kind === "set" && r.value.params.length !== 1 && this.raiseRecoverable(r.value.start, "setter should have exactly one param"), r.kind === "set" && r.value.params[0].type === "RestElement" && this.raiseRecoverable(r.value.params[0].start, "Setter cannot use rest params"), r;
};
$e.parseClassMethod = function(t, e, r, s) {
  return t.value = this.parseMethod(e, r, s), this.finishNode(t, "MethodDefinition");
};
$e.parseClassId = function(t, e) {
  this.type === $.name ? (t.id = this.parseIdent(), e && this.checkLVal(t.id, Vr, !1)) : (e === !0 && this.unexpected(), t.id = null);
};
$e.parseClassSuper = function(t) {
  t.superClass = this.eat($._extends) ? this.parseExprSubscripts() : null;
};
$e.parseExport = function(t, e) {
  if (this.next(), this.eat($.star))
    return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (t.exported = this.parseIdent(!0), this.checkExport(e, t.exported.name, this.lastTokStart)) : t.exported = null), this.expectContextual("from"), this.type !== $.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration");
  if (this.eat($._default)) {
    this.checkExport(e, "default", this.lastTokStart);
    var r;
    if (this.type === $._function || (r = this.isAsyncFunction())) {
      var s = this.startNode();
      this.next(), r && this.next(), t.declaration = this.parseFunction(s, Ps | Fx, !1, r);
    } else if (this.type === $._class) {
      var n = this.startNode();
      t.declaration = this.parseClass(n, "nullableID");
    } else
      t.declaration = this.parseMaybeAssign(), this.semicolon();
    return this.finishNode(t, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement())
    t.declaration = this.parseStatement(null), t.declaration.type === "VariableDeclaration" ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null;
  else {
    if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from"))
      this.type !== $.string && this.unexpected(), t.source = this.parseExprAtom();
    else {
      for (var a = 0, o = t.specifiers; a < o.length; a += 1) {
        var l = o[a];
        this.checkUnreserved(l.local), this.checkLocalExport(l.local);
      }
      t.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(t, "ExportNamedDeclaration");
};
$e.checkExport = function(t, e, r) {
  t && (xi(t, e) && this.raiseRecoverable(r, "Duplicate export '" + e + "'"), t[e] = !0);
};
$e.checkPatternExport = function(t, e) {
  var r = e.type;
  if (r === "Identifier")
    this.checkExport(t, e.name, e.start);
  else if (r === "ObjectPattern")
    for (var s = 0, n = e.properties; s < n.length; s += 1) {
      var a = n[s];
      this.checkPatternExport(t, a);
    }
  else if (r === "ArrayPattern")
    for (var o = 0, l = e.elements; o < l.length; o += 1) {
      var i = l[o];
      i && this.checkPatternExport(t, i);
    }
  else
    r === "Property" ? this.checkPatternExport(t, e.value) : r === "AssignmentPattern" ? this.checkPatternExport(t, e.left) : r === "RestElement" ? this.checkPatternExport(t, e.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(t, e.expression);
};
$e.checkVariableExport = function(t, e) {
  if (t)
    for (var r = 0, s = e; r < s.length; r += 1) {
      var n = s[r];
      this.checkPatternExport(t, n.id);
    }
};
$e.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
$e.parseExportSpecifiers = function(t) {
  var e = [], r = !0;
  for (this.expect($.braceL); !this.eat($.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect($.comma), this.afterTrailingComma($.braceR))
      break;
    var s = this.startNode();
    s.local = this.parseIdent(!0), s.exported = this.eatContextual("as") ? this.parseIdent(!0) : s.local, this.checkExport(t, s.exported.name, s.exported.start), e.push(this.finishNode(s, "ExportSpecifier"));
  }
  return e;
};
$e.parseImport = function(t) {
  return this.next(), this.type === $.string ? (t.specifiers = rw, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === $.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration");
};
$e.parseImportSpecifiers = function() {
  var t = [], e = !0;
  if (this.type === $.name) {
    var r = this.startNode();
    if (r.local = this.parseIdent(), this.checkLVal(r.local, Vr), t.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat($.comma))
      return t;
  }
  if (this.type === $.star) {
    var s = this.startNode();
    return this.next(), this.expectContextual("as"), s.local = this.parseIdent(), this.checkLVal(s.local, Vr), t.push(this.finishNode(s, "ImportNamespaceSpecifier")), t;
  }
  for (this.expect($.braceL); !this.eat($.braceR); ) {
    if (e)
      e = !1;
    else if (this.expect($.comma), this.afterTrailingComma($.braceR))
      break;
    var n = this.startNode();
    n.imported = this.parseIdent(!0), this.eatContextual("as") ? n.local = this.parseIdent() : (this.checkUnreserved(n.imported), n.local = n.imported), this.checkLVal(n.local, Vr), t.push(this.finishNode(n, "ImportSpecifier"));
  }
  return t;
};
$e.adaptDirectivePrologue = function(t) {
  for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e)
    t[e].directive = t[e].expression.raw.slice(1, -1);
};
$e.isDirectiveCandidate = function(t) {
  return t.type === "ExpressionStatement" && t.expression.type === "Literal" && typeof t.expression.value == "string" && // Reject parenthesized strings.
  (this.input[t.start] === '"' || this.input[t.start] === "'");
};
var zr = ht.prototype;
zr.toAssignable = function(t, e, r) {
  if (this.options.ecmaVersion >= 6 && t)
    switch (t.type) {
      case "Identifier":
        this.inAsync && t.name === "await" && this.raise(t.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern", r && this.checkPatternErrors(r, !0);
        for (var s = 0, n = t.properties; s < n.length; s += 1) {
          var a = n[s];
          this.toAssignable(a, e), a.type === "RestElement" && (a.argument.type === "ArrayPattern" || a.argument.type === "ObjectPattern") && this.raise(a.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        t.kind !== "init" && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e);
        break;
      case "ArrayExpression":
        t.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(t.elements, e);
        break;
      case "SpreadElement":
        t.type = "RestElement", this.toAssignable(t.argument, e), t.argument.type === "AssignmentPattern" && this.raise(t.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
      case "AssignmentPattern":
        break;
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, e, r);
        break;
      case "ChainExpression":
        this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!e)
          break;
      default:
        this.raise(t.start, "Assigning to rvalue");
    }
  else
    r && this.checkPatternErrors(r, !0);
  return t;
};
zr.toAssignableList = function(t, e) {
  for (var r = t.length, s = 0; s < r; s++) {
    var n = t[s];
    n && this.toAssignable(n, e);
  }
  if (r) {
    var a = t[r - 1];
    this.options.ecmaVersion === 6 && e && a && a.type === "RestElement" && a.argument.type !== "Identifier" && this.unexpected(a.argument.start);
  }
  return t;
};
zr.parseSpread = function(t) {
  var e = this.startNode();
  return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement");
};
zr.parseRestBinding = function() {
  var t = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== $.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
};
zr.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case $.bracketL:
        var t = this.startNode();
        return this.next(), t.elements = this.parseBindingList($.bracketR, !0, !0), this.finishNode(t, "ArrayPattern");
      case $.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
zr.parseBindingList = function(t, e, r) {
  for (var s = [], n = !0; !this.eat(t); )
    if (n ? n = !1 : this.expect($.comma), e && this.type === $.comma)
      s.push(null);
    else {
      if (r && this.afterTrailingComma(t))
        break;
      if (this.type === $.ellipsis) {
        var a = this.parseRestBinding();
        this.parseBindingListItem(a), s.push(a), this.type === $.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(t);
        break;
      } else {
        var o = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(o), s.push(o);
      }
    }
  return s;
};
zr.parseBindingListItem = function(t) {
  return t;
};
zr.parseMaybeDefault = function(t, e, r) {
  if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat($.eq))
    return r;
  var s = this.startNodeAt(t, e);
  return s.left = r, s.right = this.parseMaybeAssign(), this.finishNode(s, "AssignmentPattern");
};
zr.checkLVal = function(t, e, r) {
  switch (e === void 0 && (e = Nd), t.type) {
    case "Identifier":
      e === Vr && t.name === "let" && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? "Binding " : "Assigning to ") + t.name + " in strict mode"), r && (xi(r, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), r[t.name] = !0), e !== Nd && e !== Tx && this.declareName(t.name, e, t.start);
      break;
    case "ChainExpression":
      this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      e && this.raiseRecoverable(t.start, "Binding member expression");
      break;
    case "ObjectPattern":
      for (var s = 0, n = t.properties; s < n.length; s += 1) {
        var a = n[s];
        this.checkLVal(a, e, r);
      }
      break;
    case "Property":
      this.checkLVal(t.value, e, r);
      break;
    case "ArrayPattern":
      for (var o = 0, l = t.elements; o < l.length; o += 1) {
        var i = l[o];
        i && this.checkLVal(i, e, r);
      }
      break;
    case "AssignmentPattern":
      this.checkLVal(t.left, e, r);
      break;
    case "RestElement":
      this.checkLVal(t.argument, e, r);
      break;
    case "ParenthesizedExpression":
      this.checkLVal(t.expression, e, r);
      break;
    default:
      this.raise(t.start, (e ? "Binding" : "Assigning to") + " rvalue");
  }
};
var Ue = ht.prototype;
Ue.checkPropClash = function(t, e, r) {
  if (!(this.options.ecmaVersion >= 9 && t.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) {
    var s = t.key, n;
    switch (s.type) {
      case "Identifier":
        n = s.name;
        break;
      case "Literal":
        n = String(s.value);
        break;
      default:
        return;
    }
    var a = t.kind;
    if (this.options.ecmaVersion >= 6) {
      n === "__proto__" && a === "init" && (e.proto && (r ? r.doubleProto < 0 && (r.doubleProto = s.start) : this.raiseRecoverable(s.start, "Redefinition of __proto__ property")), e.proto = !0);
      return;
    }
    n = "$" + n;
    var o = e[n];
    if (o) {
      var l;
      a === "init" ? l = this.strict && o.init || o.get || o.set : l = o.init || o[a], l && this.raiseRecoverable(s.start, "Redefinition of property");
    } else
      o = e[n] = {
        init: !1,
        get: !1,
        set: !1
      };
    o[a] = !0;
  }
};
Ue.parseExpression = function(t, e) {
  var r = this.start, s = this.startLoc, n = this.parseMaybeAssign(t, e);
  if (this.type === $.comma) {
    var a = this.startNodeAt(r, s);
    for (a.expressions = [n]; this.eat($.comma); )
      a.expressions.push(this.parseMaybeAssign(t, e));
    return this.finishNode(a, "SequenceExpression");
  }
  return n;
};
Ue.parseMaybeAssign = function(t, e, r) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(t);
    this.exprAllowed = !1;
  }
  var s = !1, n = -1, a = -1;
  e ? (n = e.parenthesizedAssign, a = e.trailingComma, e.parenthesizedAssign = e.trailingComma = -1) : (e = new vi(), s = !0);
  var o = this.start, l = this.startLoc;
  (this.type === $.parenL || this.type === $.name) && (this.potentialArrowAt = this.start);
  var i = this.parseMaybeConditional(t, e);
  if (r && (i = r.call(this, i, o, l)), this.type.isAssign) {
    var u = this.startNodeAt(o, l);
    return u.operator = this.value, u.left = this.type === $.eq ? this.toAssignable(i, !1, e) : i, s || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1), e.shorthandAssign >= u.left.start && (e.shorthandAssign = -1), this.checkLVal(i), this.next(), u.right = this.parseMaybeAssign(t), this.finishNode(u, "AssignmentExpression");
  } else
    s && this.checkExpressionErrors(e, !0);
  return n > -1 && (e.parenthesizedAssign = n), a > -1 && (e.trailingComma = a), i;
};
Ue.parseMaybeConditional = function(t, e) {
  var r = this.start, s = this.startLoc, n = this.parseExprOps(t, e);
  if (this.checkExpressionErrors(e))
    return n;
  if (this.eat($.question)) {
    var a = this.startNodeAt(r, s);
    return a.test = n, a.consequent = this.parseMaybeAssign(), this.expect($.colon), a.alternate = this.parseMaybeAssign(t), this.finishNode(a, "ConditionalExpression");
  }
  return n;
};
Ue.parseExprOps = function(t, e) {
  var r = this.start, s = this.startLoc, n = this.parseMaybeUnary(e, !1);
  return this.checkExpressionErrors(e) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, s, -1, t);
};
Ue.parseExprOp = function(t, e, r, s, n) {
  var a = this.type.binop;
  if (a != null && (!n || this.type !== $._in) && a > s) {
    var o = this.type === $.logicalOR || this.type === $.logicalAND, l = this.type === $.coalesce;
    l && (a = $.logicalAND.binop);
    var i = this.value;
    this.next();
    var u = this.start, c = this.startLoc, f = this.parseExprOp(this.parseMaybeUnary(null, !1), u, c, a, n), h = this.buildBinary(e, r, t, f, i, o || l);
    return (o && this.type === $.coalesce || l && (this.type === $.logicalOR || this.type === $.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(h, e, r, s, n);
  }
  return t;
};
Ue.buildBinary = function(t, e, r, s, n, a) {
  var o = this.startNodeAt(t, e);
  return o.left = r, o.operator = n, o.right = s, this.finishNode(o, a ? "LogicalExpression" : "BinaryExpression");
};
Ue.parseMaybeUnary = function(t, e) {
  var r = this.start, s = this.startLoc, n;
  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
    n = this.parseAwait(), e = !0;
  else if (this.type.prefix) {
    var a = this.startNode(), o = this.type === $.incDec;
    a.operator = this.value, a.prefix = !0, this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), o ? this.checkLVal(a.argument) : this.strict && a.operator === "delete" && a.argument.type === "Identifier" ? this.raiseRecoverable(a.start, "Deleting local variable in strict mode") : e = !0, n = this.finishNode(a, o ? "UpdateExpression" : "UnaryExpression");
  } else {
    if (n = this.parseExprSubscripts(t), this.checkExpressionErrors(t))
      return n;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var l = this.startNodeAt(r, s);
      l.operator = this.value, l.prefix = !1, l.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(l, "UpdateExpression");
    }
  }
  return !e && this.eat($.starstar) ? this.buildBinary(r, s, n, this.parseMaybeUnary(null, !1), "**", !1) : n;
};
Ue.parseExprSubscripts = function(t) {
  var e = this.start, r = this.startLoc, s = this.parseExprAtom(t);
  if (s.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return s;
  var n = this.parseSubscripts(s, e, r);
  return t && n.type === "MemberExpression" && (t.parenthesizedAssign >= n.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= n.start && (t.parenthesizedBind = -1)), n;
};
Ue.parseSubscripts = function(t, e, r, s) {
  for (var n = this.options.ecmaVersion >= 8 && t.type === "Identifier" && t.name === "async" && this.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && this.potentialArrowAt === t.start, a = !1; ; ) {
    var o = this.parseSubscript(t, e, r, s, n, a);
    if (o.optional && (a = !0), o === t || o.type === "ArrowFunctionExpression") {
      if (a) {
        var l = this.startNodeAt(e, r);
        l.expression = o, o = this.finishNode(l, "ChainExpression");
      }
      return o;
    }
    t = o;
  }
};
Ue.parseSubscript = function(t, e, r, s, n, a) {
  var o = this.options.ecmaVersion >= 11, l = o && this.eat($.questionDot);
  s && l && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var i = this.eat($.bracketL);
  if (i || l && this.type !== $.parenL && this.type !== $.backQuote || this.eat($.dot)) {
    var u = this.startNodeAt(e, r);
    u.object = t, u.property = i ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), u.computed = !!i, i && this.expect($.bracketR), o && (u.optional = l), t = this.finishNode(u, "MemberExpression");
  } else if (!s && this.eat($.parenL)) {
    var c = new vi(), f = this.yieldPos, h = this.awaitPos, p = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var m = this.parseExprList($.parenR, this.options.ecmaVersion >= 8, !1, c);
    if (n && !l && !this.canInsertSemicolon() && this.eat($.arrow))
      return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = f, this.awaitPos = h, this.awaitIdentPos = p, this.parseArrowExpression(this.startNodeAt(e, r), m, !0);
    this.checkExpressionErrors(c, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = h || this.awaitPos, this.awaitIdentPos = p || this.awaitIdentPos;
    var d = this.startNodeAt(e, r);
    d.callee = t, d.arguments = m, o && (d.optional = l), t = this.finishNode(d, "CallExpression");
  } else if (this.type === $.backQuote) {
    (l || a) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var g = this.startNodeAt(e, r);
    g.tag = t, g.quasi = this.parseTemplate({ isTagged: !0 }), t = this.finishNode(g, "TaggedTemplateExpression");
  }
  return t;
};
Ue.parseExprAtom = function(t) {
  this.type === $.slash && this.readRegexp();
  var e, r = this.potentialArrowAt === this.start;
  switch (this.type) {
    case $._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), e = this.startNode(), this.next(), this.type === $.parenL && !this.allowDirectSuper && this.raise(e.start, "super() call outside constructor of a subclass"), this.type !== $.dot && this.type !== $.bracketL && this.type !== $.parenL && this.unexpected(), this.finishNode(e, "Super");
    case $._this:
      return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
    case $.name:
      var s = this.start, n = this.startLoc, a = this.containsEsc, o = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !a && o.name === "async" && !this.canInsertSemicolon() && this.eat($._function))
        return this.parseFunction(this.startNodeAt(s, n), 0, !1, !0);
      if (r && !this.canInsertSemicolon()) {
        if (this.eat($.arrow))
          return this.parseArrowExpression(this.startNodeAt(s, n), [o], !1);
        if (this.options.ecmaVersion >= 8 && o.name === "async" && this.type === $.name && !a)
          return o = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat($.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, n), [o], !0);
      }
      return o;
    case $.regexp:
      var l = this.value;
      return e = this.parseLiteral(l.value), e.regex = { pattern: l.pattern, flags: l.flags }, e;
    case $.num:
    case $.string:
      return this.parseLiteral(this.value);
    case $._null:
    case $._true:
    case $._false:
      return e = this.startNode(), e.value = this.type === $._null ? null : this.type === $._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, "Literal");
    case $.parenL:
      var i = this.start, u = this.parseParenAndDistinguishExpression(r);
      return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (t.parenthesizedAssign = i), t.parenthesizedBind < 0 && (t.parenthesizedBind = i)), u;
    case $.bracketL:
      return e = this.startNode(), this.next(), e.elements = this.parseExprList($.bracketR, !0, !0, t), this.finishNode(e, "ArrayExpression");
    case $.braceL:
      return this.parseObj(!1, t);
    case $._function:
      return e = this.startNode(), this.next(), this.parseFunction(e, 0);
    case $._class:
      return this.parseClass(this.startNode(), !1);
    case $._new:
      return this.parseNew();
    case $.backQuote:
      return this.parseTemplate();
    case $._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
    default:
      this.unexpected();
  }
};
Ue.parseExprImport = function() {
  var t = this.startNode();
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  var e = this.parseIdent(!0);
  switch (this.type) {
    case $.parenL:
      return this.parseDynamicImport(t);
    case $.dot:
      return t.meta = e, this.parseImportMeta(t);
    default:
      this.unexpected();
  }
};
Ue.parseDynamicImport = function(t) {
  if (this.next(), t.source = this.parseMaybeAssign(), !this.eat($.parenR)) {
    var e = this.start;
    this.eat($.comma) && this.eat($.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e);
  }
  return this.finishNode(t, "ImportExpression");
};
Ue.parseImportMeta = function(t) {
  this.next();
  var e = this.containsEsc;
  return t.property = this.parseIdent(!0), t.property.name !== "meta" && this.raiseRecoverable(t.property.start, "The only valid meta property for import is 'import.meta'"), e && this.raiseRecoverable(t.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && this.raiseRecoverable(t.start, "Cannot use 'import.meta' outside a module"), this.finishNode(t, "MetaProperty");
};
Ue.parseLiteral = function(t) {
  var e = this.startNode();
  return e.value = t, e.raw = this.input.slice(this.start, this.end), e.raw.charCodeAt(e.raw.length - 1) === 110 && (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(e, "Literal");
};
Ue.parseParenExpression = function() {
  this.expect($.parenL);
  var t = this.parseExpression();
  return this.expect($.parenR), t;
};
Ue.parseParenAndDistinguishExpression = function(t) {
  var e = this.start, r = this.startLoc, s, n = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var a = this.start, o = this.startLoc, l = [], i = !0, u = !1, c = new vi(), f = this.yieldPos, h = this.awaitPos, p;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== $.parenR; )
      if (i ? i = !1 : this.expect($.comma), n && this.afterTrailingComma($.parenR, !0)) {
        u = !0;
        break;
      } else if (this.type === $.ellipsis) {
        p = this.start, l.push(this.parseParenItem(this.parseRestBinding())), this.type === $.comma && this.raise(this.start, "Comma is not permitted after the rest element");
        break;
      } else
        l.push(this.parseMaybeAssign(!1, c, this.parseParenItem));
    var m = this.start, d = this.startLoc;
    if (this.expect($.parenR), t && !this.canInsertSemicolon() && this.eat($.arrow))
      return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f, this.awaitPos = h, this.parseParenArrowList(e, r, l);
    (!l.length || u) && this.unexpected(this.lastTokStart), p && this.unexpected(p), this.checkExpressionErrors(c, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = h || this.awaitPos, l.length > 1 ? (s = this.startNodeAt(a, o), s.expressions = l, this.finishNodeAt(s, "SequenceExpression", m, d)) : s = l[0];
  } else
    s = this.parseParenExpression();
  if (this.options.preserveParens) {
    var g = this.startNodeAt(e, r);
    return g.expression = s, this.finishNode(g, "ParenthesizedExpression");
  } else
    return s;
};
Ue.parseParenItem = function(t) {
  return t;
};
Ue.parseParenArrowList = function(t, e, r) {
  return this.parseArrowExpression(this.startNodeAt(t, e), r);
};
var nw = [];
Ue.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var t = this.startNode(), e = this.parseIdent(!0);
  if (this.options.ecmaVersion >= 6 && this.eat($.dot)) {
    t.meta = e;
    var r = this.containsEsc;
    return t.property = this.parseIdent(!0), t.property.name !== "target" && this.raiseRecoverable(t.property.start, "The only valid meta property for new is 'new.target'"), r && this.raiseRecoverable(t.start, "'new.target' must not contain escaped characters"), this.inNonArrowFunction() || this.raiseRecoverable(t.start, "'new.target' can only be used in functions"), this.finishNode(t, "MetaProperty");
  }
  var s = this.start, n = this.startLoc, a = this.type === $._import;
  return t.callee = this.parseSubscripts(this.parseExprAtom(), s, n, !0), a && t.callee.type === "ImportExpression" && this.raise(s, "Cannot use new with import()"), this.eat($.parenL) ? t.arguments = this.parseExprList($.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = nw, this.finishNode(t, "NewExpression");
};
Ue.parseTemplateElement = function(t) {
  var e = t.isTagged, r = this.startNode();
  return this.type === $.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = {
    raw: this.value,
    cooked: null
  }) : r.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), r.tail = this.type === $.backQuote, this.finishNode(r, "TemplateElement");
};
Ue.parseTemplate = function(t) {
  t === void 0 && (t = {});
  var e = t.isTagged;
  e === void 0 && (e = !1);
  var r = this.startNode();
  this.next(), r.expressions = [];
  var s = this.parseTemplateElement({ isTagged: e });
  for (r.quasis = [s]; !s.tail; )
    this.type === $.eof && this.raise(this.pos, "Unterminated template literal"), this.expect($.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect($.braceR), r.quasis.push(s = this.parseTemplateElement({ isTagged: e }));
  return this.next(), this.finishNode(r, "TemplateLiteral");
};
Ue.isAsyncProp = function(t) {
  return !t.computed && t.key.type === "Identifier" && t.key.name === "async" && (this.type === $.name || this.type === $.num || this.type === $.string || this.type === $.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === $.star) && !Zt.test(this.input.slice(this.lastTokEnd, this.start));
};
Ue.parseObj = function(t, e) {
  var r = this.startNode(), s = !0, n = {};
  for (r.properties = [], this.next(); !this.eat($.braceR); ) {
    if (s)
      s = !1;
    else if (this.expect($.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma($.braceR))
      break;
    var a = this.parseProperty(t, e);
    t || this.checkPropClash(a, n, e), r.properties.push(a);
  }
  return this.finishNode(r, t ? "ObjectPattern" : "ObjectExpression");
};
Ue.parseProperty = function(t, e) {
  var r = this.startNode(), s, n, a, o;
  if (this.options.ecmaVersion >= 9 && this.eat($.ellipsis))
    return t ? (r.argument = this.parseIdent(!1), this.type === $.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (this.type === $.parenL && e && (e.parenthesizedAssign < 0 && (e.parenthesizedAssign = this.start), e.parenthesizedBind < 0 && (e.parenthesizedBind = this.start)), r.argument = this.parseMaybeAssign(!1, e), this.type === $.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (t || e) && (a = this.start, o = this.startLoc), t || (s = this.eat($.star)));
  var l = this.containsEsc;
  return this.parsePropertyName(r), !t && !l && this.options.ecmaVersion >= 8 && !s && this.isAsyncProp(r) ? (n = !0, s = this.options.ecmaVersion >= 9 && this.eat($.star), this.parsePropertyName(r, e)) : n = !1, this.parsePropertyValue(r, t, s, n, a, o, e, l), this.finishNode(r, "Property");
};
Ue.parsePropertyValue = function(t, e, r, s, n, a, o, l) {
  if ((r || s) && this.type === $.colon && this.unexpected(), this.eat($.colon))
    t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, o), t.kind = "init";
  else if (this.options.ecmaVersion >= 6 && this.type === $.parenL)
    e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(r, s);
  else if (!e && !l && this.options.ecmaVersion >= 5 && !t.computed && t.key.type === "Identifier" && (t.key.name === "get" || t.key.name === "set") && this.type !== $.comma && this.type !== $.braceR && this.type !== $.eq) {
    (r || s) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1);
    var i = t.kind === "get" ? 0 : 1;
    if (t.value.params.length !== i) {
      var u = t.value.start;
      t.kind === "get" ? this.raiseRecoverable(u, "getter should have no params") : this.raiseRecoverable(u, "setter should have exactly one param");
    } else
      t.kind === "set" && t.value.params[0].type === "RestElement" && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params");
  } else
    this.options.ecmaVersion >= 6 && !t.computed && t.key.type === "Identifier" ? ((r || s) && this.unexpected(), this.checkUnreserved(t.key), t.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), t.kind = "init", e ? t.value = this.parseMaybeDefault(n, a, t.key) : this.type === $.eq && o ? (o.shorthandAssign < 0 && (o.shorthandAssign = this.start), t.value = this.parseMaybeDefault(n, a, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected();
};
Ue.parsePropertyName = function(t) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat($.bracketL))
      return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect($.bracketR), t.key;
    t.computed = !1;
  }
  return t.key = this.type === $.num || this.type === $.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
Ue.initFunction = function(t) {
  t.id = null, this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1);
};
Ue.parseMethod = function(t, e, r) {
  var s = this.startNode(), n = this.yieldPos, a = this.awaitPos, o = this.awaitIdentPos;
  return this.initFunction(s), this.options.ecmaVersion >= 6 && (s.generator = t), this.options.ecmaVersion >= 8 && (s.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(cu(e, s.generator) | Ax | (r ? Dx : 0)), this.expect($.parenL), s.params = this.parseBindingList($.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s, !1, !0), this.yieldPos = n, this.awaitPos = a, this.awaitIdentPos = o, this.finishNode(s, "FunctionExpression");
};
Ue.parseArrowExpression = function(t, e, r) {
  var s = this.yieldPos, n = this.awaitPos, a = this.awaitIdentPos;
  return this.enterScope(cu(r, !1) | Cx), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0, !1), this.yieldPos = s, this.awaitPos = n, this.awaitIdentPos = a, this.finishNode(t, "ArrowFunctionExpression");
};
Ue.parseFunctionBody = function(t, e, r) {
  var s = e && this.type !== $.braceL, n = this.strict, a = !1;
  if (s)
    t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1);
  else {
    var o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
    (!n || o) && (a = this.strictDirective(this.end), a && o && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var l = this.labels;
    this.labels = [], a && (this.strict = !0), this.checkParams(t, !n && !a && !e && !r && this.isSimpleParamList(t.params)), this.strict && t.id && this.checkLVal(t.id, Tx), t.body = this.parseBlock(!1, void 0, a && !n), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = l;
  }
  this.exitScope();
};
Ue.isSimpleParamList = function(t) {
  for (var e = 0, r = t; e < r.length; e += 1) {
    var s = r[e];
    if (s.type !== "Identifier")
      return !1;
  }
  return !0;
};
Ue.checkParams = function(t, e) {
  for (var r = {}, s = 0, n = t.params; s < n.length; s += 1) {
    var a = n[s];
    this.checkLVal(a, pu, e ? null : r);
  }
};
Ue.parseExprList = function(t, e, r, s) {
  for (var n = [], a = !0; !this.eat(t); ) {
    if (a)
      a = !1;
    else if (this.expect($.comma), e && this.afterTrailingComma(t))
      break;
    var o = void 0;
    r && this.type === $.comma ? o = null : this.type === $.ellipsis ? (o = this.parseSpread(s), s && this.type === $.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : o = this.parseMaybeAssign(!1, s), n.push(o);
  }
  return n;
};
Ue.checkUnreserved = function(t) {
  var e = t.start, r = t.end, s = t.name;
  if (this.inGenerator && s === "yield" && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && s === "await" && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(s) && this.raise(e, "Unexpected keyword '" + s + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(e, r).indexOf("\\") !== -1)) {
    var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
    n.test(s) && (!this.inAsync && s === "await" && this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + s + "' is reserved"));
  }
};
Ue.parseIdent = function(t, e) {
  var r = this.startNode();
  return this.type === $.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!t), this.finishNode(r, "Identifier"), t || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r;
};
Ue.parseYield = function(t) {
  this.yieldPos || (this.yieldPos = this.start);
  var e = this.startNode();
  return this.next(), this.type === $.semi || this.canInsertSemicolon() || this.type !== $.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat($.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, "YieldExpression");
};
Ue.parseAwait = function() {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !1), this.finishNode(t, "AwaitExpression");
};
var Wa = ht.prototype;
Wa.raise = function(t, e) {
  var r = lu(this.input, t);
  e += " (" + r.line + ":" + r.column + ")";
  var s = new SyntaxError(e);
  throw s.pos = t, s.loc = r, s.raisedAt = this.pos, s;
};
Wa.raiseRecoverable = Wa.raise;
Wa.curPosition = function() {
  if (this.options.locations)
    return new as(this.curLine, this.pos - this.lineStart);
};
var ln = ht.prototype, sw = function(e) {
  this.flags = e, this.var = [], this.lexical = [], this.functions = [];
};
ln.enterScope = function(t) {
  this.scopeStack.push(new sw(t));
};
ln.exitScope = function() {
  this.scopeStack.pop();
};
ln.treatFunctionsAsVarInScope = function(t) {
  return t.flags & Hs || !this.inModule && t.flags & js;
};
ln.declareName = function(t, e, r) {
  var s = !1;
  if (e === Vr) {
    var n = this.currentScope();
    s = n.lexical.indexOf(t) > -1 || n.functions.indexOf(t) > -1 || n.var.indexOf(t) > -1, n.lexical.push(t), this.inModule && n.flags & js && delete this.undefinedExports[t];
  } else if (e === kx) {
    var a = this.currentScope();
    a.lexical.push(t);
  } else if (e === wx) {
    var o = this.currentScope();
    this.treatFunctionsAsVar ? s = o.lexical.indexOf(t) > -1 : s = o.lexical.indexOf(t) > -1 || o.var.indexOf(t) > -1, o.functions.push(t);
  } else
    for (var l = this.scopeStack.length - 1; l >= 0; --l) {
      var i = this.scopeStack[l];
      if (i.lexical.indexOf(t) > -1 && !(i.flags & Sx && i.lexical[0] === t) || !this.treatFunctionsAsVarInScope(i) && i.functions.indexOf(t) > -1) {
        s = !0;
        break;
      }
      if (i.var.push(t), this.inModule && i.flags & js && delete this.undefinedExports[t], i.flags & uu)
        break;
    }
  s && this.raiseRecoverable(r, "Identifier '" + t + "' has already been declared");
};
ln.checkLocalExport = function(t) {
  this.scopeStack[0].lexical.indexOf(t.name) === -1 && this.scopeStack[0].var.indexOf(t.name) === -1 && (this.undefinedExports[t.name] = t);
};
ln.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
ln.currentVarScope = function() {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & uu)
      return e;
  }
};
ln.currentThisScope = function() {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & uu && !(e.flags & Cx))
      return e;
  }
};
var Ei = function(e, r, s) {
  this.type = "", this.start = r, this.end = 0, e.options.locations && (this.loc = new Gs(e, s)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [r, 0]);
}, bi = ht.prototype;
bi.startNode = function() {
  return new Ei(this, this.start, this.startLoc);
};
bi.startNodeAt = function(t, e) {
  return new Ei(this, t, e);
};
function Px(t, e, r, s) {
  return t.type = e, t.end = r, this.options.locations && (t.loc.end = s), this.options.ranges && (t.range[1] = r), t;
}
bi.finishNode = function(t, e) {
  return Px.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);
};
bi.finishNodeAt = function(t, e, r, s) {
  return Px.call(this, t, e, r, s);
};
var lr = function(e, r, s, n, a) {
  this.token = e, this.isExpr = !!r, this.preserveSpace = !!s, this.override = n, this.generator = !!a;
}, gt = {
  b_stat: new lr("{", !1),
  b_expr: new lr("{", !0),
  b_tmpl: new lr("${", !1),
  p_stat: new lr("(", !1),
  p_expr: new lr("(", !0),
  q_tmpl: new lr("`", !0, !0, function(t) {
    return t.tryReadTemplateToken();
  }),
  f_stat: new lr("function", !1),
  f_expr: new lr("function", !0),
  f_expr_gen: new lr("function", !0, !1, null, !0),
  f_gen: new lr("function", !1, !1, null, !0)
}, Ci = ht.prototype;
Ci.initialContext = function() {
  return [gt.b_stat];
};
Ci.braceIsBlock = function(t) {
  var e = this.curContext();
  return e === gt.f_expr || e === gt.f_stat ? !0 : t === $.colon && (e === gt.b_stat || e === gt.b_expr) ? !e.isExpr : t === $._return || t === $.name && this.exprAllowed ? Zt.test(this.input.slice(this.lastTokEnd, this.start)) : t === $._else || t === $.semi || t === $.eof || t === $.parenR || t === $.arrow ? !0 : t === $.braceL ? e === gt.b_stat : t === $._var || t === $._const || t === $.name ? !1 : !this.exprAllowed;
};
Ci.inGeneratorContext = function() {
  for (var t = this.context.length - 1; t >= 1; t--) {
    var e = this.context[t];
    if (e.token === "function")
      return e.generator;
  }
  return !1;
};
Ci.updateContext = function(t) {
  var e, r = this.type;
  r.keyword && t === $.dot ? this.exprAllowed = !1 : (e = r.updateContext) ? e.call(this, t) : this.exprAllowed = r.beforeExpr;
};
$.parenR.updateContext = $.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var t = this.context.pop();
  t === gt.b_stat && this.curContext().token === "function" && (t = this.context.pop()), this.exprAllowed = !t.isExpr;
};
$.braceL.updateContext = function(t) {
  this.context.push(this.braceIsBlock(t) ? gt.b_stat : gt.b_expr), this.exprAllowed = !0;
};
$.dollarBraceL.updateContext = function() {
  this.context.push(gt.b_tmpl), this.exprAllowed = !0;
};
$.parenL.updateContext = function(t) {
  var e = t === $._if || t === $._for || t === $._with || t === $._while;
  this.context.push(e ? gt.p_stat : gt.p_expr), this.exprAllowed = !0;
};
$.incDec.updateContext = function() {
};
$._function.updateContext = $._class.updateContext = function(t) {
  t.beforeExpr && t !== $.semi && t !== $._else && !(t === $._return && Zt.test(this.input.slice(this.lastTokEnd, this.start))) && !((t === $.colon || t === $.braceL) && this.curContext() === gt.b_stat) ? this.context.push(gt.f_expr) : this.context.push(gt.f_stat), this.exprAllowed = !1;
};
$.backQuote.updateContext = function() {
  this.curContext() === gt.q_tmpl ? this.context.pop() : this.context.push(gt.q_tmpl), this.exprAllowed = !1;
};
$.star.updateContext = function(t) {
  if (t === $._function) {
    var e = this.context.length - 1;
    this.context[e] === gt.f_expr ? this.context[e] = gt.f_expr_gen : this.context[e] = gt.f_gen;
  }
  this.exprAllowed = !0;
};
$.name.updateContext = function(t) {
  var e = !1;
  this.options.ecmaVersion >= 6 && t !== $.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e;
};
var Ix = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", _x = Ix + " Extended_Pictographic", aw = _x, iw = {
  9: Ix,
  10: _x,
  11: aw
}, jd = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Bx = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Ox = Bx + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ow = Ox + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", lw = {
  9: Bx,
  10: Ox,
  11: ow
}, Lx = {};
function hu(t) {
  var e = Lx[t] = {
    binary: Sn(iw[t] + " " + jd),
    nonBinary: {
      General_Category: Sn(jd),
      Script: Sn(lw[t])
    }
  };
  e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions;
}
hu(9);
hu(10);
hu(11);
var Le = ht.prototype, Gr = function(e) {
  this.parser = e, this.validFlags = "gim" + (e.options.ecmaVersion >= 6 ? "uy" : "") + (e.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = Lx[e.options.ecmaVersion >= 11 ? 11 : e.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
Gr.prototype.reset = function(e, r, s) {
  var n = s.indexOf("u") !== -1;
  this.start = e | 0, this.source = r + "", this.flags = s, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9;
};
Gr.prototype.raise = function(e) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e);
};
Gr.prototype.at = function(e, r) {
  r === void 0 && (r = !1);
  var s = this.source, n = s.length;
  if (e >= n)
    return -1;
  var a = s.charCodeAt(e);
  if (!(r || this.switchU) || a <= 55295 || a >= 57344 || e + 1 >= n)
    return a;
  var o = s.charCodeAt(e + 1);
  return o >= 56320 && o <= 57343 ? (a << 10) + o - 56613888 : a;
};
Gr.prototype.nextIndex = function(e, r) {
  r === void 0 && (r = !1);
  var s = this.source, n = s.length;
  if (e >= n)
    return n;
  var a = s.charCodeAt(e), o;
  return !(r || this.switchU) || a <= 55295 || a >= 57344 || e + 1 >= n || (o = s.charCodeAt(e + 1)) < 56320 || o > 57343 ? e + 1 : e + 2;
};
Gr.prototype.current = function(e) {
  return e === void 0 && (e = !1), this.at(this.pos, e);
};
Gr.prototype.lookahead = function(e) {
  return e === void 0 && (e = !1), this.at(this.nextIndex(this.pos, e), e);
};
Gr.prototype.advance = function(e) {
  e === void 0 && (e = !1), this.pos = this.nextIndex(this.pos, e);
};
Gr.prototype.eat = function(e, r) {
  return r === void 0 && (r = !1), this.current(r) === e ? (this.advance(r), !0) : !1;
};
function za(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
Le.validateRegExpFlags = function(t) {
  for (var e = t.validFlags, r = t.flags, s = 0; s < r.length; s++) {
    var n = r.charAt(s);
    e.indexOf(n) === -1 && this.raise(t.start, "Invalid regular expression flag"), r.indexOf(n, s + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag");
  }
};
Le.validateRegExpPattern = function(t) {
  this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t));
};
Le.regexp_pattern = function(t) {
  t.pos = 0, t.lastIntValue = 0, t.lastStringValue = "", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(
    41
    /* ) */
  ) && t.raise("Unmatched ')'"), (t.eat(
    93
    /* ] */
  ) || t.eat(
    125
    /* } */
  )) && t.raise("Lone quantifier brackets")), t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
  for (var e = 0, r = t.backReferenceNames; e < r.length; e += 1) {
    var s = r[e];
    t.groupNames.indexOf(s) === -1 && t.raise("Invalid named capture referenced");
  }
};
Le.regexp_disjunction = function(t) {
  for (this.regexp_alternative(t); t.eat(
    124
    /* | */
  ); )
    this.regexp_alternative(t);
  this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(
    123
    /* { */
  ) && t.raise("Lone quantifier brackets");
};
Le.regexp_alternative = function(t) {
  for (; t.pos < t.source.length && this.regexp_eatTerm(t); )
    ;
};
Le.regexp_eatTerm = function(t) {
  return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0) : (t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t)) ? (this.regexp_eatQuantifier(t), !0) : !1;
};
Le.regexp_eatAssertion = function(t) {
  var e = t.pos;
  if (t.lastAssertionIsQuantifiable = !1, t.eat(
    94
    /* ^ */
  ) || t.eat(
    36
    /* $ */
  ))
    return !0;
  if (t.eat(
    92
    /* \ */
  )) {
    if (t.eat(
      66
      /* B */
    ) || t.eat(
      98
      /* b */
    ))
      return !0;
    t.pos = e;
  }
  if (t.eat(
    40
    /* ( */
  ) && t.eat(
    63
    /* ? */
  )) {
    var r = !1;
    if (this.options.ecmaVersion >= 9 && (r = t.eat(
      60
      /* < */
    )), t.eat(
      61
      /* = */
    ) || t.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(t), t.eat(
        41
        /* ) */
      ) || t.raise("Unterminated group"), t.lastAssertionIsQuantifiable = !r, !0;
  }
  return t.pos = e, !1;
};
Le.regexp_eatQuantifier = function(t, e) {
  return e === void 0 && (e = !1), this.regexp_eatQuantifierPrefix(t, e) ? (t.eat(
    63
    /* ? */
  ), !0) : !1;
};
Le.regexp_eatQuantifierPrefix = function(t, e) {
  return t.eat(
    42
    /* * */
  ) || t.eat(
    43
    /* + */
  ) || t.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(t, e);
};
Le.regexp_eatBracedQuantifier = function(t, e) {
  var r = t.pos;
  if (t.eat(
    123
    /* { */
  )) {
    var s = 0, n = -1;
    if (this.regexp_eatDecimalDigits(t) && (s = t.lastIntValue, t.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(t) && (n = t.lastIntValue), t.eat(
      125
      /* } */
    )))
      return n !== -1 && n < s && !e && t.raise("numbers out of order in {} quantifier"), !0;
    t.switchU && !e && t.raise("Incomplete quantifier"), t.pos = r;
  }
  return !1;
};
Le.regexp_eatAtom = function(t) {
  return this.regexp_eatPatternCharacters(t) || t.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t);
};
Le.regexp_eatReverseSolidusAtomEscape = function(t) {
  var e = t.pos;
  if (t.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(t))
      return !0;
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatUncapturingGroup = function(t) {
  var e = t.pos;
  if (t.eat(
    40
    /* ( */
  )) {
    if (t.eat(
      63
      /* ? */
    ) && t.eat(
      58
      /* : */
    )) {
      if (this.regexp_disjunction(t), t.eat(
        41
        /* ) */
      ))
        return !0;
      t.raise("Unterminated group");
    }
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatCapturingGroup = function(t) {
  if (t.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : t.current() === 63 && t.raise("Invalid group"), this.regexp_disjunction(t), t.eat(
      41
      /* ) */
    ))
      return t.numCapturingParens += 1, !0;
    t.raise("Unterminated group");
  }
  return !1;
};
Le.regexp_eatExtendedAtom = function(t) {
  return t.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t);
};
Le.regexp_eatInvalidBracedQuantifier = function(t) {
  return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1;
};
Le.regexp_eatSyntaxCharacter = function(t) {
  var e = t.current();
  return Rx(e) ? (t.lastIntValue = e, t.advance(), !0) : !1;
};
function Rx(t) {
  return t === 36 || t >= 40 && t <= 43 || t === 46 || t === 63 || t >= 91 && t <= 94 || t >= 123 && t <= 125;
}
Le.regexp_eatPatternCharacters = function(t) {
  for (var e = t.pos, r = 0; (r = t.current()) !== -1 && !Rx(r); )
    t.advance();
  return t.pos !== e;
};
Le.regexp_eatExtendedPatternCharacter = function(t) {
  var e = t.current();
  return e !== -1 && e !== 36 && !(e >= 40 && e <= 43) && e !== 46 && e !== 63 && e !== 91 && e !== 94 && e !== 124 ? (t.advance(), !0) : !1;
};
Le.regexp_groupSpecifier = function(t) {
  if (t.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(t)) {
      t.groupNames.indexOf(t.lastStringValue) !== -1 && t.raise("Duplicate capture group name"), t.groupNames.push(t.lastStringValue);
      return;
    }
    t.raise("Invalid group");
  }
};
Le.regexp_eatGroupName = function(t) {
  if (t.lastStringValue = "", t.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(t) && t.eat(
      62
      /* > */
    ))
      return !0;
    t.raise("Invalid capture group name");
  }
  return !1;
};
Le.regexp_eatRegExpIdentifierName = function(t) {
  if (t.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(t)) {
    for (t.lastStringValue += za(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t); )
      t.lastStringValue += za(t.lastIntValue);
    return !0;
  }
  return !1;
};
Le.regexp_eatRegExpIdentifierStart = function(t) {
  var e = t.pos, r = this.options.ecmaVersion >= 11, s = t.current(r);
  return t.advance(r), s === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t, r) && (s = t.lastIntValue), uw(s) ? (t.lastIntValue = s, !0) : (t.pos = e, !1);
};
function uw(t) {
  return Ur(t, !0) || t === 36 || t === 95;
}
Le.regexp_eatRegExpIdentifierPart = function(t) {
  var e = t.pos, r = this.options.ecmaVersion >= 11, s = t.current(r);
  return t.advance(r), s === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t, r) && (s = t.lastIntValue), cw(s) ? (t.lastIntValue = s, !0) : (t.pos = e, !1);
};
function cw(t) {
  return Tn(t, !0) || t === 36 || t === 95 || t === 8204 || t === 8205;
}
Le.regexp_eatAtomEscape = function(t) {
  return this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t) ? !0 : (t.switchU && (t.current() === 99 && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1);
};
Le.regexp_eatBackReference = function(t) {
  var e = t.pos;
  if (this.regexp_eatDecimalEscape(t)) {
    var r = t.lastIntValue;
    if (t.switchU)
      return r > t.maxBackReference && (t.maxBackReference = r), !0;
    if (r <= t.numCapturingParens)
      return !0;
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatKGroupName = function(t) {
  if (t.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(t))
      return t.backReferenceNames.push(t.lastStringValue), !0;
    t.raise("Invalid named reference");
  }
  return !1;
};
Le.regexp_eatCharacterEscape = function(t) {
  return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t);
};
Le.regexp_eatCControlLetter = function(t) {
  var e = t.pos;
  if (t.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(t))
      return !0;
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatZero = function(t) {
  return t.current() === 48 && !Si(t.lookahead()) ? (t.lastIntValue = 0, t.advance(), !0) : !1;
};
Le.regexp_eatControlEscape = function(t) {
  var e = t.current();
  return e === 116 ? (t.lastIntValue = 9, t.advance(), !0) : e === 110 ? (t.lastIntValue = 10, t.advance(), !0) : e === 118 ? (t.lastIntValue = 11, t.advance(), !0) : e === 102 ? (t.lastIntValue = 12, t.advance(), !0) : e === 114 ? (t.lastIntValue = 13, t.advance(), !0) : !1;
};
Le.regexp_eatControlLetter = function(t) {
  var e = t.current();
  return Nx(e) ? (t.lastIntValue = e % 32, t.advance(), !0) : !1;
};
function Nx(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122;
}
Le.regexp_eatRegExpUnicodeEscapeSequence = function(t, e) {
  e === void 0 && (e = !1);
  var r = t.pos, s = e || t.switchU;
  if (t.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(t, 4)) {
      var n = t.lastIntValue;
      if (s && n >= 55296 && n <= 56319) {
        var a = t.pos;
        if (t.eat(
          92
          /* \ */
        ) && t.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(t, 4)) {
          var o = t.lastIntValue;
          if (o >= 56320 && o <= 57343)
            return t.lastIntValue = (n - 55296) * 1024 + (o - 56320) + 65536, !0;
        }
        t.pos = a, t.lastIntValue = n;
      }
      return !0;
    }
    if (s && t.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(t) && t.eat(
      125
      /* } */
    ) && pw(t.lastIntValue))
      return !0;
    s && t.raise("Invalid unicode escape"), t.pos = r;
  }
  return !1;
};
function pw(t) {
  return t >= 0 && t <= 1114111;
}
Le.regexp_eatIdentityEscape = function(t) {
  if (t.switchU)
    return this.regexp_eatSyntaxCharacter(t) ? !0 : t.eat(
      47
      /* / */
    ) ? (t.lastIntValue = 47, !0) : !1;
  var e = t.current();
  return e !== 99 && (!t.switchN || e !== 107) ? (t.lastIntValue = e, t.advance(), !0) : !1;
};
Le.regexp_eatDecimalEscape = function(t) {
  t.lastIntValue = 0;
  var e = t.current();
  if (e >= 49 && e <= 57) {
    do
      t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance();
    while ((e = t.current()) >= 48 && e <= 57);
    return !0;
  }
  return !1;
};
Le.regexp_eatCharacterClassEscape = function(t) {
  var e = t.current();
  if (fw(e))
    return t.lastIntValue = -1, t.advance(), !0;
  if (t.switchU && this.options.ecmaVersion >= 9 && (e === 80 || e === 112)) {
    if (t.lastIntValue = -1, t.advance(), t.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(t) && t.eat(
      125
      /* } */
    ))
      return !0;
    t.raise("Invalid property name");
  }
  return !1;
};
function fw(t) {
  return t === 100 || t === 68 || t === 115 || t === 83 || t === 119 || t === 87;
}
Le.regexp_eatUnicodePropertyValueExpression = function(t) {
  var e = t.pos;
  if (this.regexp_eatUnicodePropertyName(t) && t.eat(
    61
    /* = */
  )) {
    var r = t.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(t)) {
      var s = t.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(t, r, s), !0;
    }
  }
  if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) {
    var n = t.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(t, n), !0;
  }
  return !1;
};
Le.regexp_validateUnicodePropertyNameAndValue = function(t, e, r) {
  xi(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"), t.unicodeProperties.nonBinary[e].test(r) || t.raise("Invalid property value");
};
Le.regexp_validateUnicodePropertyNameOrValue = function(t, e) {
  t.unicodeProperties.binary.test(e) || t.raise("Invalid property name");
};
Le.regexp_eatUnicodePropertyName = function(t) {
  var e = 0;
  for (t.lastStringValue = ""; jx(e = t.current()); )
    t.lastStringValue += za(e), t.advance();
  return t.lastStringValue !== "";
};
function jx(t) {
  return Nx(t) || t === 95;
}
Le.regexp_eatUnicodePropertyValue = function(t) {
  var e = 0;
  for (t.lastStringValue = ""; hw(e = t.current()); )
    t.lastStringValue += za(e), t.advance();
  return t.lastStringValue !== "";
};
function hw(t) {
  return jx(t) || Si(t);
}
Le.regexp_eatLoneUnicodePropertyNameOrValue = function(t) {
  return this.regexp_eatUnicodePropertyValue(t);
};
Le.regexp_eatCharacterClass = function(t) {
  if (t.eat(
    91
    /* [ */
  )) {
    if (t.eat(
      94
      /* ^ */
    ), this.regexp_classRanges(t), t.eat(
      93
      /* ] */
    ))
      return !0;
    t.raise("Unterminated character class");
  }
  return !1;
};
Le.regexp_classRanges = function(t) {
  for (; this.regexp_eatClassAtom(t); ) {
    var e = t.lastIntValue;
    if (t.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(t)) {
      var r = t.lastIntValue;
      t.switchU && (e === -1 || r === -1) && t.raise("Invalid character class"), e !== -1 && r !== -1 && e > r && t.raise("Range out of order in character class");
    }
  }
};
Le.regexp_eatClassAtom = function(t) {
  var e = t.pos;
  if (t.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(t))
      return !0;
    if (t.switchU) {
      var r = t.current();
      (r === 99 || Vx(r)) && t.raise("Invalid class escape"), t.raise("Invalid escape");
    }
    t.pos = e;
  }
  var s = t.current();
  return s !== 93 ? (t.lastIntValue = s, t.advance(), !0) : !1;
};
Le.regexp_eatClassEscape = function(t) {
  var e = t.pos;
  if (t.eat(
    98
    /* b */
  ))
    return t.lastIntValue = 8, !0;
  if (t.switchU && t.eat(
    45
    /* - */
  ))
    return t.lastIntValue = 45, !0;
  if (!t.switchU && t.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(t))
      return !0;
    t.pos = e;
  }
  return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t);
};
Le.regexp_eatClassControlLetter = function(t) {
  var e = t.current();
  return Si(e) || e === 95 ? (t.lastIntValue = e % 32, t.advance(), !0) : !1;
};
Le.regexp_eatHexEscapeSequence = function(t) {
  var e = t.pos;
  if (t.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(t, 2))
      return !0;
    t.switchU && t.raise("Invalid escape"), t.pos = e;
  }
  return !1;
};
Le.regexp_eatDecimalDigits = function(t) {
  var e = t.pos, r = 0;
  for (t.lastIntValue = 0; Si(r = t.current()); )
    t.lastIntValue = 10 * t.lastIntValue + (r - 48), t.advance();
  return t.pos !== e;
};
function Si(t) {
  return t >= 48 && t <= 57;
}
Le.regexp_eatHexDigits = function(t) {
  var e = t.pos, r = 0;
  for (t.lastIntValue = 0; Mx(r = t.current()); )
    t.lastIntValue = 16 * t.lastIntValue + $x(r), t.advance();
  return t.pos !== e;
};
function Mx(t) {
  return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
}
function $x(t) {
  return t >= 65 && t <= 70 ? 10 + (t - 65) : t >= 97 && t <= 102 ? 10 + (t - 97) : t - 48;
}
Le.regexp_eatLegacyOctalEscapeSequence = function(t) {
  if (this.regexp_eatOctalDigit(t)) {
    var e = t.lastIntValue;
    if (this.regexp_eatOctalDigit(t)) {
      var r = t.lastIntValue;
      e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = e * 64 + r * 8 + t.lastIntValue : t.lastIntValue = e * 8 + r;
    } else
      t.lastIntValue = e;
    return !0;
  }
  return !1;
};
Le.regexp_eatOctalDigit = function(t) {
  var e = t.current();
  return Vx(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1);
};
function Vx(t) {
  return t >= 48 && t <= 55;
}
Le.regexp_eatFixedHexDigits = function(t, e) {
  var r = t.pos;
  t.lastIntValue = 0;
  for (var s = 0; s < e; ++s) {
    var n = t.current();
    if (!Mx(n))
      return t.pos = r, !1;
    t.lastIntValue = 16 * t.lastIntValue + $x(n), t.advance();
  }
  return !0;
};
var Ai = function(e) {
  this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new Gs(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]);
}, ze = ht.prototype;
ze.next = function(t) {
  !t && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Ai(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
ze.getToken = function() {
  return this.next(), new Ai(this);
};
typeof Symbol < "u" && (ze[Symbol.iterator] = function() {
  var t = this;
  return {
    next: function() {
      var e = t.getToken();
      return {
        done: e.type === $.eof,
        value: e
      };
    }
  };
});
ze.curContext = function() {
  return this.context[this.context.length - 1];
};
ze.nextToken = function() {
  var t = this.curContext();
  if ((!t || !t.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken($.eof);
  if (t.override)
    return t.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
ze.readToken = function(t) {
  return Ur(t, this.options.ecmaVersion >= 6) || t === 92 ? this.readWord() : this.getTokenFromCode(t);
};
ze.fullCharCodeAtPos = function() {
  var t = this.input.charCodeAt(this.pos);
  if (t <= 55295 || t >= 57344)
    return t;
  var e = this.input.charCodeAt(this.pos + 1);
  return (t << 10) + e - 56613888;
};
ze.skipBlockComment = function() {
  var t = this.options.onComment && this.curPosition(), e = this.pos, r = this.input.indexOf("*/", this.pos += 2);
  if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) {
    ss.lastIndex = e;
    for (var s; (s = ss.exec(this.input)) && s.index < this.pos; )
      ++this.curLine, this.lineStart = s.index + s[0].length;
  }
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(e + 2, r),
    e,
    this.pos,
    t,
    this.curPosition()
  );
};
ze.skipLineComment = function(t) {
  for (var e = this.pos, r = this.options.onComment && this.curPosition(), s = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !ls(s); )
    s = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(e + t, this.pos),
    e,
    this.pos,
    r,
    this.curPosition()
  );
};
ze.skipSpace = function() {
  e:
    for (; this.pos < this.input.length; ) {
      var t = this.input.charCodeAt(this.pos);
      switch (t) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (t > 8 && t < 14 || t >= 5760 && ou.test(String.fromCharCode(t)))
            ++this.pos;
          else
            break e;
      }
    }
};
ze.finishToken = function(t, e) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var r = this.type;
  this.type = t, this.value = e, this.updateContext(r);
};
ze.readToken_dot = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t >= 48 && t <= 57)
    return this.readNumber(!0);
  var e = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && t === 46 && e === 46 ? (this.pos += 3, this.finishToken($.ellipsis)) : (++this.pos, this.finishToken($.dot));
};
ze.readToken_slash = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : t === 61 ? this.finishOp($.assign, 2) : this.finishOp($.slash, 1);
};
ze.readToken_mult_modulo_exp = function(t) {
  var e = this.input.charCodeAt(this.pos + 1), r = 1, s = t === 42 ? $.star : $.modulo;
  return this.options.ecmaVersion >= 7 && t === 42 && e === 42 && (++r, s = $.starstar, e = this.input.charCodeAt(this.pos + 2)), e === 61 ? this.finishOp($.assign, r + 1) : this.finishOp(s, r);
};
ze.readToken_pipe_amp = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e === t) {
    if (this.options.ecmaVersion >= 12) {
      var r = this.input.charCodeAt(this.pos + 2);
      if (r === 61)
        return this.finishOp($.assign, 3);
    }
    return this.finishOp(t === 124 ? $.logicalOR : $.logicalAND, 2);
  }
  return e === 61 ? this.finishOp($.assign, 2) : this.finishOp(t === 124 ? $.bitwiseOR : $.bitwiseAND, 1);
};
ze.readToken_caret = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp($.assign, 2) : this.finishOp($.bitwiseXOR, 1);
};
ze.readToken_plus_min = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === t ? e === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Zt.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp($.incDec, 2) : e === 61 ? this.finishOp($.assign, 2) : this.finishOp($.plusMin, 1);
};
ze.readToken_lt_gt = function(t) {
  var e = this.input.charCodeAt(this.pos + 1), r = 1;
  return e === t ? (r = t === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp($.assign, r + 1) : this.finishOp($.bitShift, r)) : e === 33 && t === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (e === 61 && (r = 2), this.finishOp($.relational, r));
};
ze.readToken_eq_excl = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp($.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : t === 61 && e === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken($.arrow)) : this.finishOp(t === 61 ? $.eq : $.prefix, 1);
};
ze.readToken_question = function() {
  var t = this.options.ecmaVersion;
  if (t >= 11) {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e === 46) {
      var r = this.input.charCodeAt(this.pos + 2);
      if (r < 48 || r > 57)
        return this.finishOp($.questionDot, 2);
    }
    if (e === 63) {
      if (t >= 12) {
        var s = this.input.charCodeAt(this.pos + 2);
        if (s === 61)
          return this.finishOp($.assign, 3);
      }
      return this.finishOp($.coalesce, 2);
    }
  }
  return this.finishOp($.question, 1);
};
ze.getTokenFromCode = function(t) {
  switch (t) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken($.parenL);
    case 41:
      return ++this.pos, this.finishToken($.parenR);
    case 59:
      return ++this.pos, this.finishToken($.semi);
    case 44:
      return ++this.pos, this.finishToken($.comma);
    case 91:
      return ++this.pos, this.finishToken($.bracketL);
    case 93:
      return ++this.pos, this.finishToken($.bracketR);
    case 123:
      return ++this.pos, this.finishToken($.braceL);
    case 125:
      return ++this.pos, this.finishToken($.braceR);
    case 58:
      return ++this.pos, this.finishToken($.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken($.backQuote);
    case 48:
      var e = this.input.charCodeAt(this.pos + 1);
      if (e === 120 || e === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (e === 111 || e === 79)
          return this.readRadixNumber(8);
        if (e === 98 || e === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(t);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(t);
    case 124:
    case 38:
      return this.readToken_pipe_amp(t);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(t);
    case 60:
    case 62:
      return this.readToken_lt_gt(t);
    case 61:
    case 33:
      return this.readToken_eq_excl(t);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp($.prefix, 1);
  }
  this.raise(this.pos, "Unexpected character '" + mu(t) + "'");
};
ze.finishOp = function(t, e) {
  var r = this.input.slice(this.pos, this.pos + e);
  return this.pos += e, this.finishToken(t, r);
};
ze.readRegexp = function() {
  for (var t, e, r = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
    var s = this.input.charAt(this.pos);
    if (Zt.test(s) && this.raise(r, "Unterminated regular expression"), t)
      t = !1;
    else {
      if (s === "[")
        e = !0;
      else if (s === "]" && e)
        e = !1;
      else if (s === "/" && !e)
        break;
      t = s === "\\";
    }
    ++this.pos;
  }
  var n = this.input.slice(r, this.pos);
  ++this.pos;
  var a = this.pos, o = this.readWord1();
  this.containsEsc && this.unexpected(a);
  var l = this.regexpState || (this.regexpState = new Gr(this));
  l.reset(r, n, o), this.validateRegExpFlags(l), this.validateRegExpPattern(l);
  var i = null;
  try {
    i = new RegExp(n, o);
  } catch {
  }
  return this.finishToken($.regexp, { pattern: n, flags: o, value: i });
};
ze.readInt = function(t, e, r) {
  for (var s = this.options.ecmaVersion >= 12 && e === void 0, n = r && this.input.charCodeAt(this.pos) === 48, a = this.pos, o = 0, l = 0, i = 0, u = e ?? 1 / 0; i < u; ++i, ++this.pos) {
    var c = this.input.charCodeAt(this.pos), f = void 0;
    if (s && c === 95) {
      n && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), l === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), i === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), l = c;
      continue;
    }
    if (c >= 97 ? f = c - 97 + 10 : c >= 65 ? f = c - 65 + 10 : c >= 48 && c <= 57 ? f = c - 48 : f = 1 / 0, f >= t)
      break;
    l = c, o = o * t + f;
  }
  return s && l === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === a || e != null && this.pos - a !== e ? null : o;
};
function mw(t, e) {
  return e ? parseInt(t, 8) : parseFloat(t.replace(/_/g, ""));
}
function Ux(t) {
  return typeof BigInt != "function" ? null : BigInt(t.replace(/_/g, ""));
}
ze.readRadixNumber = function(t) {
  var e = this.pos;
  this.pos += 2;
  var r = this.readInt(t);
  return r == null && this.raise(this.start + 2, "Expected number in radix " + t), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = Ux(this.input.slice(e, this.pos)), ++this.pos) : Ur(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken($.num, r);
};
ze.readNumber = function(t) {
  var e = this.pos;
  !t && this.readInt(10, void 0, !0) === null && this.raise(e, "Invalid number");
  var r = this.pos - e >= 2 && this.input.charCodeAt(e) === 48;
  r && this.strict && this.raise(e, "Invalid number");
  var s = this.input.charCodeAt(this.pos);
  if (!r && !t && this.options.ecmaVersion >= 11 && s === 110) {
    var n = Ux(this.input.slice(e, this.pos));
    return ++this.pos, Ur(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken($.num, n);
  }
  r && /[89]/.test(this.input.slice(e, this.pos)) && (r = !1), s === 46 && !r && (++this.pos, this.readInt(10), s = this.input.charCodeAt(this.pos)), (s === 69 || s === 101) && !r && (s = this.input.charCodeAt(++this.pos), (s === 43 || s === 45) && ++this.pos, this.readInt(10) === null && this.raise(e, "Invalid number")), Ur(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var a = mw(this.input.slice(e, this.pos), r);
  return this.finishToken($.num, a);
};
ze.readCodePoint = function() {
  var t = this.input.charCodeAt(this.pos), e;
  if (t === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var r = ++this.pos;
    e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
  } else
    e = this.readHexChar(4);
  return e;
};
function mu(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
ze.readString = function(t) {
  for (var e = "", r = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var s = this.input.charCodeAt(this.pos);
    if (s === t)
      break;
    s === 92 ? (e += this.input.slice(r, this.pos), e += this.readEscapedChar(!1), r = this.pos) : (ls(s, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return e += this.input.slice(r, this.pos++), this.finishToken($.string, e);
};
var qx = {};
ze.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (t) {
    if (t === qx)
      this.readInvalidTemplateToken();
    else
      throw t;
  }
  this.inTemplateElement = !1;
};
ze.invalidStringToken = function(t, e) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw qx;
  this.raise(t, e);
};
ze.readTmplToken = function() {
  for (var t = "", e = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var r = this.input.charCodeAt(this.pos);
    if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === $.template || this.type === $.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken($.dollarBraceL)) : (++this.pos, this.finishToken($.backQuote)) : (t += this.input.slice(e, this.pos), this.finishToken($.template, t));
    if (r === 92)
      t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos;
    else if (ls(r)) {
      switch (t += this.input.slice(e, this.pos), ++this.pos, r) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          t += `
`;
          break;
        default:
          t += String.fromCharCode(r);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos;
    } else
      ++this.pos;
  }
};
ze.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken($.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
ze.readEscapedChar = function(t) {
  var e = this.input.charCodeAt(++this.pos);
  switch (++this.pos, e) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return mu(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (t) {
        var r = this.pos - 1;
        return this.invalidStringToken(
          r,
          "Invalid escape sequence in template string"
        ), null;
      }
    default:
      if (e >= 48 && e <= 55) {
        var s = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n = parseInt(s, 8);
        return n > 255 && (s = s.slice(0, -1), n = parseInt(s, 8)), this.pos += s.length - 1, e = this.input.charCodeAt(this.pos), (s !== "0" || e === 56 || e === 57) && (this.strict || t) && this.invalidStringToken(
          this.pos - 1 - s.length,
          t ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(n);
      }
      return ls(e) ? "" : String.fromCharCode(e);
  }
};
ze.readHexChar = function(t) {
  var e = this.pos, r = this.readInt(16, t);
  return r === null && this.invalidStringToken(e, "Bad character escape sequence"), r;
};
ze.readWord1 = function() {
  this.containsEsc = !1;
  for (var t = "", e = !0, r = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var n = this.fullCharCodeAtPos();
    if (Tn(n, s))
      this.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.containsEsc = !0, t += this.input.slice(r, this.pos);
      var a = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var o = this.readCodePoint();
      (e ? Ur : Tn)(o, s) || this.invalidStringToken(a, "Invalid Unicode escape"), t += mu(o), r = this.pos;
    } else
      break;
    e = !1;
  }
  return t + this.input.slice(r, this.pos);
};
ze.readWord = function() {
  var t = this.readWord1(), e = $.name;
  return this.keywords.test(t) && (e = yi[t]), this.finishToken(e, t);
};
var Wx = "7.4.1";
ht.acorn = {
  Parser: ht,
  version: Wx,
  defaultOptions: qa,
  Position: as,
  SourceLocation: Gs,
  getLineInfo: lu,
  Node: Ei,
  TokenType: Xe,
  tokTypes: $,
  keywordTypes: yi,
  TokContext: lr,
  tokContexts: gt,
  isIdentifierChar: Tn,
  isIdentifierStart: Ur,
  Token: Ai,
  isNewLine: ls,
  lineBreak: Zt,
  lineBreakG: ss,
  nonASCIIwhitespace: ou
};
function dw(t, e) {
  return ht.parse(t, e);
}
function gw(t, e, r) {
  return ht.parseExpressionAt(t, e, r);
}
function yw(t, e) {
  return ht.tokenizer(t, e);
}
var xw = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Node: Ei,
  Parser: ht,
  Position: as,
  SourceLocation: Gs,
  TokContext: lr,
  Token: Ai,
  TokenType: Xe,
  defaultOptions: qa,
  getLineInfo: lu,
  isIdentifierChar: Tn,
  isIdentifierStart: Ur,
  isNewLine: ls,
  keywordTypes: yi,
  lineBreak: Zt,
  lineBreakG: ss,
  nonASCIIwhitespace: ou,
  parse: dw,
  parseExpressionAt: gw,
  tokContexts: gt,
  tokTypes: $,
  tokenizer: yw,
  version: Wx
}), cl = /* @__PURE__ */ Fn(xw), zx = { exports: {} }, vw = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "",
  iexcl: "",
  cent: "",
  pound: "",
  curren: "",
  yen: "",
  brvbar: "",
  sect: "",
  uml: "",
  copy: "",
  ordf: "",
  laquo: "",
  not: "",
  shy: "",
  reg: "",
  macr: "",
  deg: "",
  plusmn: "",
  sup2: "",
  sup3: "",
  acute: "",
  micro: "",
  para: "",
  middot: "",
  cedil: "",
  sup1: "",
  ordm: "",
  raquo: "",
  frac14: "",
  frac12: "",
  frac34: "",
  iquest: "",
  Agrave: "",
  Aacute: "",
  Acirc: "",
  Atilde: "",
  Auml: "",
  Aring: "",
  AElig: "",
  Ccedil: "",
  Egrave: "",
  Eacute: "",
  Ecirc: "",
  Euml: "",
  Igrave: "",
  Iacute: "",
  Icirc: "",
  Iuml: "",
  ETH: "",
  Ntilde: "",
  Ograve: "",
  Oacute: "",
  Ocirc: "",
  Otilde: "",
  Ouml: "",
  times: "",
  Oslash: "",
  Ugrave: "",
  Uacute: "",
  Ucirc: "",
  Uuml: "",
  Yacute: "",
  THORN: "",
  szlig: "",
  agrave: "",
  aacute: "",
  acirc: "",
  atilde: "",
  auml: "",
  aring: "",
  aelig: "",
  ccedil: "",
  egrave: "",
  eacute: "",
  ecirc: "",
  euml: "",
  igrave: "",
  iacute: "",
  icirc: "",
  iuml: "",
  eth: "",
  ntilde: "",
  ograve: "",
  oacute: "",
  ocirc: "",
  otilde: "",
  ouml: "",
  divide: "",
  oslash: "",
  ugrave: "",
  uacute: "",
  ucirc: "",
  uuml: "",
  yacute: "",
  thorn: "",
  yuml: "",
  OElig: "",
  oelig: "",
  Scaron: "",
  scaron: "",
  Yuml: "",
  fnof: "",
  circ: "",
  tilde: "",
  Alpha: "",
  Beta: "",
  Gamma: "",
  Delta: "",
  Epsilon: "",
  Zeta: "",
  Eta: "",
  Theta: "",
  Iota: "",
  Kappa: "",
  Lambda: "",
  Mu: "",
  Nu: "",
  Xi: "",
  Omicron: "",
  Pi: "",
  Rho: "",
  Sigma: "",
  Tau: "",
  Upsilon: "",
  Phi: "",
  Chi: "",
  Psi: "",
  Omega: "",
  alpha: "",
  beta: "",
  gamma: "",
  delta: "",
  epsilon: "",
  zeta: "",
  eta: "",
  theta: "",
  iota: "",
  kappa: "",
  lambda: "",
  mu: "",
  nu: "",
  xi: "",
  omicron: "",
  pi: "",
  rho: "",
  sigmaf: "",
  sigma: "",
  tau: "",
  upsilon: "",
  phi: "",
  chi: "",
  psi: "",
  omega: "",
  thetasym: "",
  upsih: "",
  piv: "",
  ensp: "",
  emsp: "",
  thinsp: "",
  zwnj: "",
  zwj: "",
  lrm: "",
  rlm: "",
  ndash: "",
  mdash: "",
  lsquo: "",
  rsquo: "",
  sbquo: "",
  ldquo: "",
  rdquo: "",
  bdquo: "",
  dagger: "",
  Dagger: "",
  bull: "",
  hellip: "",
  permil: "",
  prime: "",
  Prime: "",
  lsaquo: "",
  rsaquo: "",
  oline: "",
  frasl: "",
  euro: "",
  image: "",
  weierp: "",
  real: "",
  trade: "",
  alefsym: "",
  larr: "",
  uarr: "",
  rarr: "",
  darr: "",
  harr: "",
  crarr: "",
  lArr: "",
  uArr: "",
  rArr: "",
  dArr: "",
  hArr: "",
  forall: "",
  part: "",
  exist: "",
  empty: "",
  nabla: "",
  isin: "",
  notin: "",
  ni: "",
  prod: "",
  sum: "",
  minus: "",
  lowast: "",
  radic: "",
  prop: "",
  infin: "",
  ang: "",
  and: "",
  or: "",
  cap: "",
  cup: "",
  int: "",
  there4: "",
  sim: "",
  cong: "",
  asymp: "",
  ne: "",
  equiv: "",
  le: "",
  ge: "",
  sub: "",
  sup: "",
  nsub: "",
  sube: "",
  supe: "",
  oplus: "",
  otimes: "",
  perp: "",
  sdot: "",
  lceil: "",
  rceil: "",
  lfloor: "",
  rfloor: "",
  lang: "",
  rang: "",
  loz: "",
  spades: "",
  clubs: "",
  hearts: "",
  diams: ""
};
(function(t) {
  const e = vw, r = /^[\da-fA-F]+$/, s = /^\d+$/, n = /* @__PURE__ */ new WeakMap();
  function a(i) {
    i = i.Parser.acorn || i;
    let u = n.get(i);
    if (!u) {
      const c = i.tokTypes, f = i.TokContext, h = i.TokenType, p = new f("<tag", !1), m = new f("</tag", !1), d = new f("<tag>...</tag>", !0, !0), g = {
        tc_oTag: p,
        tc_cTag: m,
        tc_expr: d
      }, y = {
        jsxName: new h("jsxName"),
        jsxText: new h("jsxText", { beforeExpr: !0 }),
        jsxTagStart: new h("jsxTagStart", { startsExpr: !0 }),
        jsxTagEnd: new h("jsxTagEnd")
      };
      y.jsxTagStart.updateContext = function() {
        this.context.push(d), this.context.push(p), this.exprAllowed = !1;
      }, y.jsxTagEnd.updateContext = function(x) {
        let A = this.context.pop();
        A === p && x === c.slash || A === m ? (this.context.pop(), this.exprAllowed = this.curContext() === d) : this.exprAllowed = !0;
      }, u = { tokContexts: g, tokTypes: y }, n.set(i, u);
    }
    return u;
  }
  function o(i) {
    if (!i)
      return i;
    if (i.type === "JSXIdentifier")
      return i.name;
    if (i.type === "JSXNamespacedName")
      return i.namespace.name + ":" + i.name.name;
    if (i.type === "JSXMemberExpression")
      return o(i.object) + "." + o(i.property);
  }
  t.exports = function(i) {
    return i = i || {}, function(u) {
      return l({
        allowNamespaces: i.allowNamespaces !== !1,
        allowNamespacedObjects: !!i.allowNamespacedObjects
      }, u);
    };
  }, Object.defineProperty(t.exports, "tokTypes", {
    get: function() {
      return a(cl).tokTypes;
    },
    configurable: !0,
    enumerable: !0
  });
  function l(i, u) {
    const c = u.acorn || cl, f = a(c), h = c.tokTypes, p = f.tokTypes, m = c.tokContexts, d = f.tokContexts.tc_oTag, g = f.tokContexts.tc_cTag, y = f.tokContexts.tc_expr, x = c.isNewLine, A = c.isIdentifierStart, b = c.isIdentifierChar;
    return class extends u {
      // Expose actual `tokTypes` and `tokContexts` to other plugins.
      static get acornJsx() {
        return f;
      }
      // Reads inline JSX contents token.
      jsx_readToken() {
        let v = "", C = this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
          let T = this.input.charCodeAt(this.pos);
          switch (T) {
            case 60:
            case 123:
              return this.pos === this.start ? T === 60 && this.exprAllowed ? (++this.pos, this.finishToken(p.jsxTagStart)) : this.getTokenFromCode(T) : (v += this.input.slice(C, this.pos), this.finishToken(p.jsxText, v));
            case 38:
              v += this.input.slice(C, this.pos), v += this.jsx_readEntity(), C = this.pos;
              break;
            case 62:
            case 125:
              this.raise(
                this.pos,
                "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (T === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
              );
            default:
              x(T) ? (v += this.input.slice(C, this.pos), v += this.jsx_readNewLine(!0), C = this.pos) : ++this.pos;
          }
        }
      }
      jsx_readNewLine(v) {
        let C = this.input.charCodeAt(this.pos), T;
        return ++this.pos, C === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, T = v ? `
` : `\r
`) : T = String.fromCharCode(C), this.options.locations && (++this.curLine, this.lineStart = this.pos), T;
      }
      jsx_readString(v) {
        let C = "", T = ++this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          let w = this.input.charCodeAt(this.pos);
          if (w === v)
            break;
          w === 38 ? (C += this.input.slice(T, this.pos), C += this.jsx_readEntity(), T = this.pos) : x(w) ? (C += this.input.slice(T, this.pos), C += this.jsx_readNewLine(!1), T = this.pos) : ++this.pos;
        }
        return C += this.input.slice(T, this.pos++), this.finishToken(h.string, C);
      }
      jsx_readEntity() {
        let v = "", C = 0, T, w = this.input[this.pos];
        w !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
        let B = ++this.pos;
        for (; this.pos < this.input.length && C++ < 10; ) {
          if (w = this.input[this.pos++], w === ";") {
            v[0] === "#" ? v[1] === "x" ? (v = v.substr(2), r.test(v) && (T = String.fromCharCode(parseInt(v, 16)))) : (v = v.substr(1), s.test(v) && (T = String.fromCharCode(parseInt(v, 10)))) : T = e[v];
            break;
          }
          v += w;
        }
        return T || (this.pos = B, "&");
      }
      // Read a JSX identifier (valid tag or attribute name).
      //
      // Optimized version since JSX identifiers can't contain
      // escape characters and so can be read as single slice.
      // Also assumes that first character was already checked
      // by isIdentifierStart in readToken.
      jsx_readWord() {
        let v, C = this.pos;
        do
          v = this.input.charCodeAt(++this.pos);
        while (b(v) || v === 45);
        return this.finishToken(p.jsxName, this.input.slice(C, this.pos));
      }
      // Parse next token as JSX identifier
      jsx_parseIdentifier() {
        let v = this.startNode();
        return this.type === p.jsxName ? v.name = this.value : this.type.keyword ? v.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(v, "JSXIdentifier");
      }
      // Parse namespaced identifier.
      jsx_parseNamespacedName() {
        let v = this.start, C = this.startLoc, T = this.jsx_parseIdentifier();
        if (!i.allowNamespaces || !this.eat(h.colon))
          return T;
        var w = this.startNodeAt(v, C);
        return w.namespace = T, w.name = this.jsx_parseIdentifier(), this.finishNode(w, "JSXNamespacedName");
      }
      // Parses element name in any form - namespaced, member
      // or single identifier.
      jsx_parseElementName() {
        if (this.type === p.jsxTagEnd)
          return "";
        let v = this.start, C = this.startLoc, T = this.jsx_parseNamespacedName();
        for (this.type === h.dot && T.type === "JSXNamespacedName" && !i.allowNamespacedObjects && this.unexpected(); this.eat(h.dot); ) {
          let w = this.startNodeAt(v, C);
          w.object = T, w.property = this.jsx_parseIdentifier(), T = this.finishNode(w, "JSXMemberExpression");
        }
        return T;
      }
      // Parses any type of JSX attribute value.
      jsx_parseAttributeValue() {
        switch (this.type) {
          case h.braceL:
            let v = this.jsx_parseExpressionContainer();
            return v.expression.type === "JSXEmptyExpression" && this.raise(v.start, "JSX attributes must only be assigned a non-empty expression"), v;
          case p.jsxTagStart:
          case h.string:
            return this.parseExprAtom();
          default:
            this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
      // JSXEmptyExpression is unique type since it doesn't actually parse anything,
      // and so it should start at the end of last read token (left brace) and finish
      // at the beginning of the next one (right brace).
      jsx_parseEmptyExpression() {
        let v = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
        return this.finishNodeAt(v, "JSXEmptyExpression", this.start, this.startLoc);
      }
      // Parses JSX expression enclosed into curly brackets.
      jsx_parseExpressionContainer() {
        let v = this.startNode();
        return this.next(), v.expression = this.type === h.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(h.braceR), this.finishNode(v, "JSXExpressionContainer");
      }
      // Parses following JSX attribute name-value pair.
      jsx_parseAttribute() {
        let v = this.startNode();
        return this.eat(h.braceL) ? (this.expect(h.ellipsis), v.argument = this.parseMaybeAssign(), this.expect(h.braceR), this.finishNode(v, "JSXSpreadAttribute")) : (v.name = this.jsx_parseNamespacedName(), v.value = this.eat(h.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(v, "JSXAttribute"));
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(v, C) {
        let T = this.startNodeAt(v, C);
        T.attributes = [];
        let w = this.jsx_parseElementName();
        for (w && (T.name = w); this.type !== h.slash && this.type !== p.jsxTagEnd; )
          T.attributes.push(this.jsx_parseAttribute());
        return T.selfClosing = this.eat(h.slash), this.expect(p.jsxTagEnd), this.finishNode(T, w ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      // Parses JSX closing tag starting after '</'.
      jsx_parseClosingElementAt(v, C) {
        let T = this.startNodeAt(v, C), w = this.jsx_parseElementName();
        return w && (T.name = w), this.expect(p.jsxTagEnd), this.finishNode(T, w ? "JSXClosingElement" : "JSXClosingFragment");
      }
      // Parses entire JSX element, including it's opening tag
      // (starting after '<'), attributes, contents and closing tag.
      jsx_parseElementAt(v, C) {
        let T = this.startNodeAt(v, C), w = [], B = this.jsx_parseOpeningElementAt(v, C), I = null;
        if (!B.selfClosing) {
          e:
            for (; ; )
              switch (this.type) {
                case p.jsxTagStart:
                  if (v = this.start, C = this.startLoc, this.next(), this.eat(h.slash)) {
                    I = this.jsx_parseClosingElementAt(v, C);
                    break e;
                  }
                  w.push(this.jsx_parseElementAt(v, C));
                  break;
                case p.jsxText:
                  w.push(this.parseExprAtom());
                  break;
                case h.braceL:
                  w.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
          o(I.name) !== o(B.name) && this.raise(
            I.start,
            "Expected corresponding JSX closing tag for <" + o(B.name) + ">"
          );
        }
        let _ = B.name ? "Element" : "Fragment";
        return T["opening" + _] = B, T["closing" + _] = I, T.children = w, this.type === h.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(T, "JSX" + _);
      }
      // Parse JSX text
      jsx_parseText() {
        let v = this.parseLiteral(this.value);
        return v.type = "JSXText", v;
      }
      // Parses entire JSX element from current position.
      jsx_parseElement() {
        let v = this.start, C = this.startLoc;
        return this.next(), this.jsx_parseElementAt(v, C);
      }
      parseExprAtom(v) {
        return this.type === p.jsxText ? this.jsx_parseText() : this.type === p.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(v);
      }
      readToken(v) {
        let C = this.curContext();
        if (C === y)
          return this.jsx_readToken();
        if (C === d || C === g) {
          if (A(v))
            return this.jsx_readWord();
          if (v == 62)
            return ++this.pos, this.finishToken(p.jsxTagEnd);
          if ((v === 34 || v === 39) && C == d)
            return this.jsx_readString(v);
        }
        return v === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(p.jsxTagStart)) : super.readToken(v);
      }
      updateContext(v) {
        if (this.type == h.braceL) {
          var C = this.curContext();
          C == d ? this.context.push(m.b_expr) : C == y ? this.context.push(m.b_tmpl) : super.updateContext(v), this.exprAllowed = !0;
        } else if (this.type === h.slash && v === p.jsxTagStart)
          this.context.length -= 2, this.context.push(g), this.exprAllowed = !1;
        else
          return super.updateContext(v);
      }
    };
  }
})(zx);
var Ew = {
  AssignmentExpression: "AssignmentExpression",
  AssignmentPattern: "AssignmentPattern",
  ArrayExpression: "ArrayExpression",
  ArrayPattern: "ArrayPattern",
  ArrowFunctionExpression: "ArrowFunctionExpression",
  AwaitExpression: "AwaitExpression",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  CatchClause: "CatchClause",
  ClassBody: "ClassBody",
  ClassDeclaration: "ClassDeclaration",
  ClassExpression: "ClassExpression",
  ConditionalExpression: "ConditionalExpression",
  ContinueStatement: "ContinueStatement",
  DoWhileStatement: "DoWhileStatement",
  DebuggerStatement: "DebuggerStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  ForOfStatement: "ForOfStatement",
  FunctionDeclaration: "FunctionDeclaration",
  FunctionExpression: "FunctionExpression",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  Literal: "Literal",
  LabeledStatement: "LabeledStatement",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  MetaProperty: "MetaProperty",
  MethodDefinition: "MethodDefinition",
  NewExpression: "NewExpression",
  ObjectExpression: "ObjectExpression",
  ObjectPattern: "ObjectPattern",
  Program: "Program",
  Property: "Property",
  RestElement: "RestElement",
  ReturnStatement: "ReturnStatement",
  SequenceExpression: "SequenceExpression",
  SpreadElement: "SpreadElement",
  Super: "Super",
  SwitchCase: "SwitchCase",
  SwitchStatement: "SwitchStatement",
  TaggedTemplateExpression: "TaggedTemplateExpression",
  TemplateElement: "TemplateElement",
  TemplateLiteral: "TemplateLiteral",
  ThisExpression: "ThisExpression",
  ThrowStatement: "ThrowStatement",
  TryStatement: "TryStatement",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement",
  WithStatement: "WithStatement",
  YieldExpression: "YieldExpression",
  JSXIdentifier: "JSXIdentifier",
  JSXNamespacedName: "JSXNamespacedName",
  JSXMemberExpression: "JSXMemberExpression",
  JSXEmptyExpression: "JSXEmptyExpression",
  JSXExpressionContainer: "JSXExpressionContainer",
  JSXElement: "JSXElement",
  JSXClosingElement: "JSXClosingElement",
  JSXOpeningElement: "JSXOpeningElement",
  JSXAttribute: "JSXAttribute",
  JSXSpreadAttribute: "JSXSpreadAttribute",
  JSXText: "JSXText",
  ExportDefaultDeclaration: "ExportDefaultDeclaration",
  ExportNamedDeclaration: "ExportNamedDeclaration",
  ExportAllDeclaration: "ExportAllDeclaration",
  ExportSpecifier: "ExportSpecifier",
  ImportDeclaration: "ImportDeclaration",
  ImportSpecifier: "ImportSpecifier",
  ImportDefaultSpecifier: "ImportDefaultSpecifier",
  ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
};
const Ut = {
  Boolean: "Boolean",
  EOF: "<end>",
  Identifier: "Identifier",
  Keyword: "Keyword",
  Null: "Null",
  Numeric: "Numeric",
  Punctuator: "Punctuator",
  String: "String",
  RegularExpression: "RegularExpression",
  Template: "Template",
  JSXIdentifier: "JSXIdentifier",
  JSXText: "JSXText"
};
function bw(t, e) {
  const r = t[0], s = t[t.length - 1], n = {
    type: Ut.Template,
    value: e.slice(r.start, s.end)
  };
  return r.loc && (n.loc = {
    start: r.loc.start,
    end: s.loc.end
  }), r.range && (n.start = r.range[0], n.end = s.range[1], n.range = [n.start, n.end]), n;
}
function pl(t, e) {
  this._acornTokTypes = t, this._tokens = [], this._curlyBrace = null, this._code = e;
}
pl.prototype = {
  constructor: pl,
  /**
   * Translates a single Esprima token to a single Acorn token. This may be
   * inaccurate due to how templates are handled differently in Esprima and
   * Acorn, but should be accurate for all other tokens.
   * @param {AcornToken} token The Acorn token to translate.
   * @param {Object} extra Espree extra object.
   * @returns {EsprimaToken} The Esprima version of the token.
   */
  translate(t, e) {
    const r = t.type, s = this._acornTokTypes;
    if (r === s.name)
      t.type = Ut.Identifier, t.value === "static" && (t.type = Ut.Keyword), e.ecmaVersion > 5 && (t.value === "yield" || t.value === "let") && (t.type = Ut.Keyword);
    else if (r === s.semi || r === s.comma || r === s.parenL || r === s.parenR || r === s.braceL || r === s.braceR || r === s.dot || r === s.bracketL || r === s.colon || r === s.question || r === s.bracketR || r === s.ellipsis || r === s.arrow || r === s.jsxTagStart || r === s.incDec || r === s.starstar || r === s.jsxTagEnd || r === s.prefix || r === s.questionDot || r.binop && !r.keyword || r.isAssign)
      t.type = Ut.Punctuator, t.value = this._code.slice(t.start, t.end);
    else if (r === s.jsxName)
      t.type = Ut.JSXIdentifier;
    else if (r.label === "jsxText" || r === s.jsxAttrValueToken)
      t.type = Ut.JSXText;
    else if (r.keyword)
      r.keyword === "true" || r.keyword === "false" ? t.type = Ut.Boolean : r.keyword === "null" ? t.type = Ut.Null : t.type = Ut.Keyword;
    else if (r === s.num)
      t.type = Ut.Numeric, t.value = this._code.slice(t.start, t.end);
    else if (r === s.string)
      e.jsxAttrValueToken ? (e.jsxAttrValueToken = !1, t.type = Ut.JSXText) : t.type = Ut.String, t.value = this._code.slice(t.start, t.end);
    else if (r === s.regexp) {
      t.type = Ut.RegularExpression;
      const n = t.value;
      t.regex = {
        flags: n.flags,
        pattern: n.pattern
      }, t.value = `/${n.pattern}/${n.flags}`;
    }
    return t;
  },
  /**
   * Function to call during Acorn's onToken handler.
   * @param {AcornToken} token The Acorn token.
   * @param {Object} extra The Espree extra object.
   * @returns {void}
   */
  onToken(t, e) {
    const r = this, s = this._acornTokTypes, n = e.tokens, a = this._tokens;
    function o() {
      n.push(bw(r._tokens, r._code)), r._tokens = [];
    }
    if (t.type === s.eof) {
      this._curlyBrace && n.push(this.translate(this._curlyBrace, e));
      return;
    }
    if (t.type === s.backQuote) {
      this._curlyBrace && (n.push(this.translate(this._curlyBrace, e)), this._curlyBrace = null), a.push(t), a.length > 1 && o();
      return;
    }
    if (t.type === s.dollarBraceL) {
      a.push(t), o();
      return;
    }
    if (t.type === s.braceR) {
      this._curlyBrace && n.push(this.translate(this._curlyBrace, e)), this._curlyBrace = t;
      return;
    }
    if (t.type === s.template || t.type === s.invalidTemplate) {
      this._curlyBrace && (a.push(this._curlyBrace), this._curlyBrace = null), a.push(t);
      return;
    }
    this._curlyBrace && (n.push(this.translate(this._curlyBrace, e)), this._curlyBrace = null), n.push(this.translate(t, e));
  }
};
var Cw = pl;
const Sw = 5, Ga = [
  3,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12
];
function Aw(t = Sw) {
  if (typeof t != "number")
    throw new Error(`ecmaVersion must be a number. Received value of type ${typeof t} instead.`);
  let e = t;
  if (e >= 2015 && (e -= 2009), !Ga.includes(e))
    throw new Error("Invalid ecmaVersion.");
  return e;
}
function Dw(t = "script") {
  if (t === "script" || t === "module")
    return t;
  throw new Error("Invalid sourceType.");
}
function ww(t) {
  const e = Aw(t.ecmaVersion), r = Dw(t.sourceType), s = t.range === !0, n = t.loc === !0;
  if (r === "module" && e < 6)
    throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
  return Object.assign({}, t, { ecmaVersion: e, sourceType: r, ranges: s, locations: n });
}
function kw() {
  return Ga[Ga.length - 1];
}
function Tw() {
  return [...Ga];
}
var Gx = {
  normalizeOptions: ww,
  getLatestEcmaVersion: kw,
  getSupportedEcmaVersions: Tw
};
const Fw = Cw, { normalizeOptions: Pw } = Gx, Br = Symbol("espree's internal state"), Zi = Symbol("espree's esprimaFinishNode");
function Iw(t, e, r, s, n, a) {
  const o = {
    type: t ? "Block" : "Line",
    value: e
  };
  return typeof r == "number" && (o.start = r, o.end = s, o.range = [r, s]), typeof n == "object" && (o.loc = {
    start: n,
    end: a
  }), o;
}
var _w = () => (t) => {
  const e = Object.assign({}, t.acorn.tokTypes);
  return t.acornJsx && Object.assign(e, t.acornJsx.tokTypes), class extends t {
    constructor(s, n) {
      (typeof s != "object" || s === null) && (s = {}), typeof n != "string" && !(n instanceof String) && (n = String(n));
      const a = Pw(s), o = a.ecmaFeatures || {}, l = a.tokens === !0 ? new Fw(e, n) : null;
      super({
        // TODO: use {...options} when spread is supported(Node.js >= 8.3.0).
        ecmaVersion: a.ecmaVersion,
        sourceType: a.sourceType,
        ranges: a.ranges,
        locations: a.locations,
        // Truthy value is true for backward compatibility.
        allowReturnOutsideFunction: !!o.globalReturn,
        // Collect tokens
        onToken: (i) => {
          l && l.onToken(i, this[Br]), i.type !== e.eof && (this[Br].lastToken = i);
        },
        // Collect comments
        onComment: (i, u, c, f, h, p) => {
          if (this[Br].comments) {
            const m = Iw(i, u, c, f, h, p);
            this[Br].comments.push(m);
          }
        }
      }, n), this[Br] = {
        tokens: l ? [] : null,
        comments: a.comment === !0 ? [] : null,
        impliedStrict: o.impliedStrict === !0 && this.options.ecmaVersion >= 5,
        ecmaVersion: this.options.ecmaVersion,
        jsxAttrValueToken: !1,
        lastToken: null
      };
    }
    tokenize() {
      do
        this.next();
      while (this.type !== e.eof);
      this.next();
      const s = this[Br], n = s.tokens;
      return s.comments && (n.comments = s.comments), n;
    }
    finishNode(...s) {
      const n = super.finishNode(...s);
      return this[Zi](n);
    }
    finishNodeAt(...s) {
      const n = super.finishNodeAt(...s);
      return this[Zi](n);
    }
    parse() {
      const s = this[Br], n = super.parse();
      return n.sourceType = this.options.sourceType, s.comments && (n.comments = s.comments), s.tokens && (n.tokens = s.tokens), n.range && (n.range[0] = n.body.length ? n.body[0].range[0] : n.range[0], n.range[1] = s.lastToken ? s.lastToken.range[1] : n.range[1]), n.loc && (n.loc.start = n.body.length ? n.body[0].loc.start : n.loc.start, n.loc.end = s.lastToken ? s.lastToken.loc.end : n.loc.end), n;
    }
    parseTopLevel(s) {
      return this[Br].impliedStrict && (this.strict = !0), super.parseTopLevel(s);
    }
    /**
     * Overwrites the default raise method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @param {string} message The error message.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */
    raise(s, n) {
      const a = t.acorn.getLineInfo(this.input, s), o = new SyntaxError(n);
      throw o.index = s, o.lineNumber = a.line, o.column = a.column + 1, o;
    }
    /**
     * Overwrites the default raise method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @param {string} message The error message.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */
    raiseRecoverable(s, n) {
      this.raise(s, n);
    }
    /**
     * Overwrites the default unexpected method to throw Esprima-style errors.
     * @param {int} pos The position of the error.
     * @throws {SyntaxError} A syntax error.
     * @returns {void}
     */
    unexpected(s) {
      let n = "Unexpected token";
      if (s != null) {
        if (this.pos = s, this.options.locations)
          for (; this.pos < this.lineStart; )
            this.lineStart = this.input.lastIndexOf(`
`, this.lineStart - 2) + 1, --this.curLine;
        this.nextToken();
      }
      this.end > this.start && (n += ` ${this.input.slice(this.start, this.end)}`), this.raise(this.start, n);
    }
    /*
    * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
    * uses regular tt.string without any distinction between this and regular JS
    * strings. As such, we intercept an attempt to read a JSX string and set a flag
    * on extra so that when tokens are converted, the next token will be switched
    * to JSXText via onToken.
    */
    jsx_readString(s) {
      const n = super.jsx_readString(s);
      return this.type === e.string && (this[Br].jsxAttrValueToken = !0), n;
    }
    /**
     * Performs last-minute Esprima-specific compatibility checks and fixes.
     * @param {ASTNode} result The node to check.
     * @returns {ASTNode} The finished node.
     */
    [Zi](s) {
      if (s.type === "TemplateElement") {
        const n = this.input.slice(s.end, s.end + 2) === "${";
        s.range && (s.range[0]--, s.range[1] += n ? 2 : 1), s.loc && (s.loc.start.column--, s.loc.end.column += n ? 2 : 1);
      }
      return s.type.indexOf("Function") > -1 && !s.generator && (s.generator = !1), s;
    }
  };
}, Bw = "espree", Ow = "An Esprima-compatible JavaScript parser built on Acorn", Lw = "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>", Rw = "https://github.com/eslint/espree", Nw = "espree.js", jw = "7.3.1", Mw = [
  "lib",
  "espree.js"
], $w = {
  node: "^10.12.0 || >=12.0.0"
}, Vw = "eslint/espree", Uw = {
  url: "http://github.com/eslint/espree.git"
}, qw = "BSD-2-Clause", Ww = {
  acorn: "^7.4.0",
  "acorn-jsx": "^5.3.1",
  "eslint-visitor-keys": "^1.3.0"
}, zw = {
  browserify: "^16.5.0",
  chai: "^4.2.0",
  eslint: "^6.0.1",
  "eslint-config-eslint": "^5.0.1",
  "eslint-plugin-node": "^9.1.0",
  "eslint-release": "^1.0.0",
  esprima: "latest",
  "esprima-fb": "^8001.2001.0-dev-harmony-fb",
  "json-diff": "^0.5.4",
  leche: "^2.3.0",
  mocha: "^6.2.0",
  nyc: "^14.1.1",
  regenerate: "^1.4.0",
  shelljs: "^0.3.0",
  "shelljs-nodecli": "^0.1.1",
  "unicode-6.3.0": "^0.7.5"
}, Gw = [
  "ast",
  "ecmascript",
  "javascript",
  "parser",
  "syntax",
  "acorn"
], Hw = {
  "generate-regex": "node tools/generate-identifier-regex.js",
  test: "npm run-script lint && node Makefile.js test",
  lint: "node Makefile.js lint",
  fixlint: "node Makefile.js lint --fix",
  "sync-docs": "node Makefile.js docs",
  browserify: "node Makefile.js browserify",
  "generate-release": "eslint-generate-release",
  "generate-alpharelease": "eslint-generate-prerelease alpha",
  "generate-betarelease": "eslint-generate-prerelease beta",
  "generate-rcrelease": "eslint-generate-prerelease rc",
  "publish-release": "eslint-publish-release"
}, Kw = {
  name: Bw,
  description: Ow,
  author: Lw,
  homepage: Rw,
  main: Nw,
  version: jw,
  files: Mw,
  engines: $w,
  repository: Vw,
  bugs: Uw,
  license: qw,
  dependencies: Ww,
  devDependencies: zw,
  keywords: Gw,
  scripts: Hw
}, Jw = [
  "left",
  "right"
], Xw = [
  "left",
  "right"
], Qw = [
  "elements"
], Yw = [
  "elements"
], Zw = [
  "params",
  "body"
], ek = [
  "argument"
], tk = [
  "body"
], rk = [
  "left",
  "right"
], nk = [
  "label"
], sk = [
  "callee",
  "arguments"
], ak = [
  "param",
  "body"
], ik = [
  "expression"
], ok = [
  "body"
], lk = [
  "id",
  "superClass",
  "body"
], uk = [
  "id",
  "superClass",
  "body"
], ck = [
  "test",
  "consequent",
  "alternate"
], pk = [
  "label"
], fk = [], hk = [
  "body",
  "test"
], mk = [], dk = [
  "exported",
  "source"
], gk = [
  "declaration"
], yk = [
  "declaration",
  "specifiers",
  "source"
], xk = [
  "exported",
  "local"
], vk = [
  "expression"
], Ek = [
  "argument"
], bk = [
  "argument"
], Ck = [
  "init",
  "test",
  "update",
  "body"
], Sk = [
  "left",
  "right",
  "body"
], Ak = [
  "left",
  "right",
  "body"
], Dk = [
  "id",
  "params",
  "body"
], wk = [
  "id",
  "params",
  "body"
], kk = [], Tk = [
  "test",
  "consequent",
  "alternate"
], Fk = [
  "specifiers",
  "source"
], Pk = [
  "local"
], Ik = [
  "source"
], _k = [
  "local"
], Bk = [
  "imported",
  "local"
], Ok = [
  "name",
  "value"
], Lk = [
  "name"
], Rk = [
  "openingElement",
  "children",
  "closingElement"
], Nk = [], jk = [
  "expression"
], Mk = [], $k = [
  "object",
  "property"
], Vk = [
  "namespace",
  "name"
], Uk = [
  "name",
  "attributes"
], qk = [
  "argument"
], Wk = [], zk = [
  "openingFragment",
  "children",
  "closingFragment"
], Gk = [], Hk = [
  "label",
  "body"
], Kk = [
  "left",
  "right"
], Jk = [
  "object",
  "property"
], Xk = [
  "meta",
  "property"
], Qk = [
  "key",
  "value"
], Yk = [
  "callee",
  "arguments"
], Zk = [
  "properties"
], eT = [
  "properties"
], tT = [
  "body"
], rT = [
  "key",
  "value"
], nT = [
  "argument"
], sT = [
  "argument"
], aT = [
  "expressions"
], iT = [
  "argument"
], oT = [], lT = [
  "discriminant",
  "cases"
], uT = [
  "test",
  "consequent"
], cT = [
  "tag",
  "quasi"
], pT = [], fT = [
  "quasis",
  "expressions"
], hT = [], mT = [
  "argument"
], dT = [
  "block",
  "handler",
  "finalizer"
], gT = [
  "argument"
], yT = [
  "argument"
], xT = [
  "declarations"
], vT = [
  "id",
  "init"
], ET = [
  "test",
  "body"
], bT = [
  "object",
  "body"
], CT = [
  "argument"
], ST = {
  AssignmentExpression: Jw,
  AssignmentPattern: Xw,
  ArrayExpression: Qw,
  ArrayPattern: Yw,
  ArrowFunctionExpression: Zw,
  AwaitExpression: ek,
  BlockStatement: tk,
  BinaryExpression: rk,
  BreakStatement: nk,
  CallExpression: sk,
  CatchClause: ak,
  ChainExpression: ik,
  ClassBody: ok,
  ClassDeclaration: lk,
  ClassExpression: uk,
  ConditionalExpression: ck,
  ContinueStatement: pk,
  DebuggerStatement: fk,
  DoWhileStatement: hk,
  EmptyStatement: mk,
  ExportAllDeclaration: dk,
  ExportDefaultDeclaration: gk,
  ExportNamedDeclaration: yk,
  ExportSpecifier: xk,
  ExpressionStatement: vk,
  ExperimentalRestProperty: Ek,
  ExperimentalSpreadProperty: bk,
  ForStatement: Ck,
  ForInStatement: Sk,
  ForOfStatement: Ak,
  FunctionDeclaration: Dk,
  FunctionExpression: wk,
  Identifier: kk,
  IfStatement: Tk,
  ImportDeclaration: Fk,
  ImportDefaultSpecifier: Pk,
  ImportExpression: Ik,
  ImportNamespaceSpecifier: _k,
  ImportSpecifier: Bk,
  JSXAttribute: Ok,
  JSXClosingElement: Lk,
  JSXElement: Rk,
  JSXEmptyExpression: Nk,
  JSXExpressionContainer: jk,
  JSXIdentifier: Mk,
  JSXMemberExpression: $k,
  JSXNamespacedName: Vk,
  JSXOpeningElement: Uk,
  JSXSpreadAttribute: qk,
  JSXText: Wk,
  JSXFragment: zk,
  Literal: Gk,
  LabeledStatement: Hk,
  LogicalExpression: Kk,
  MemberExpression: Jk,
  MetaProperty: Xk,
  MethodDefinition: Qk,
  NewExpression: Yk,
  ObjectExpression: Zk,
  ObjectPattern: eT,
  Program: tT,
  Property: rT,
  RestElement: nT,
  ReturnStatement: sT,
  SequenceExpression: aT,
  SpreadElement: iT,
  Super: oT,
  SwitchStatement: lT,
  SwitchCase: uT,
  TaggedTemplateExpression: cT,
  TemplateElement: pT,
  TemplateLiteral: fT,
  ThisExpression: hT,
  ThrowStatement: mT,
  TryStatement: dT,
  UnaryExpression: gT,
  UpdateExpression: yT,
  VariableDeclaration: xT,
  VariableDeclarator: vT,
  WhileStatement: ET,
  WithStatement: bT,
  YieldExpression: CT
};
const Ms = ST, AT = Object.freeze(Object.keys(Ms));
for (const t of AT)
  Object.freeze(Ms[t]);
Object.freeze(Ms);
const DT = /* @__PURE__ */ new Set([
  "parent",
  "leadingComments",
  "trailingComments"
]);
function wT(t) {
  return !DT.has(t) && t[0] !== "_";
}
var du = Object.freeze({
  /**
   * Visitor keys.
   * @type {{ [type: string]: string[] | undefined }}
   */
  KEYS: Ms,
  /**
   * Get visitor keys of a given node.
   * @param {Object} node The AST node to get keys.
   * @returns {string[]} Visitor keys of the node.
   */
  getKeys(t) {
    return Object.keys(t).filter(wT);
  },
  // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
  // eslint-disable-next-line valid-jsdoc
  /**
   * Make the union set with `KEYS` and given keys.
   * @param {Object} additionalKeys The additional keys.
   * @returns {{ [type: string]: string[] | undefined }} The union set.
   */
  unionWith(t) {
    const e = Object.assign({}, Ms);
    for (const r of Object.keys(t))
      if (e.hasOwnProperty(r)) {
        const s = new Set(t[r]);
        for (const n of e[r])
          s.add(n);
        e[r] = Object.freeze(Array.from(s));
      } else
        e[r] = Object.freeze(Array.from(t[r]));
    return Object.freeze(e);
  }
});
const Md = cl, kT = zx.exports, eo = Ew, $d = _w, { getLatestEcmaVersion: TT, getSupportedEcmaVersions: FT } = Gx, Hx = {
  _regular: null,
  _jsx: null,
  get regular() {
    return this._regular === null && (this._regular = Md.Parser.extend($d())), this._regular;
  },
  get jsx() {
    return this._jsx === null && (this._jsx = Md.Parser.extend(kT(), $d())), this._jsx;
  },
  get(t) {
    return !!(t && t.ecmaFeatures && t.ecmaFeatures.jsx) ? this.jsx : this.regular;
  }
};
function PT(t, e) {
  const r = Hx.get(e);
  return (!e || e.tokens !== !0) && (e = Object.assign({}, e, { tokens: !0 })), new r(e, t).tokenize();
}
function IT(t, e) {
  const r = Hx.get(e);
  return new r(e, t).parse();
}
Wr.version = Kw.version;
Wr.tokenize = PT;
Wr.parse = IT;
Wr.Syntax = function() {
  let t, e = {};
  typeof Object.create == "function" && (e = /* @__PURE__ */ Object.create(null));
  for (t in eo)
    Object.hasOwnProperty.call(eo, t) && (e[t] = eo[t]);
  return typeof Object.freeze == "function" && Object.freeze(e), e;
}();
Wr.VisitorKeys = function() {
  return du.KEYS;
}();
Wr.latestEcmaVersion = TT();
Wr.supportedEcmaVersions = FT();
var fl = { exports: {} };
(function(t, e) {
  var r = 200, s = "__lodash_hash_undefined__", n = 800, a = 16, o = 9007199254740991, l = "[object Arguments]", i = "[object Array]", u = "[object AsyncFunction]", c = "[object Boolean]", f = "[object Date]", h = "[object Error]", p = "[object Function]", m = "[object GeneratorFunction]", d = "[object Map]", g = "[object Number]", y = "[object Null]", x = "[object Object]", A = "[object Proxy]", b = "[object RegExp]", v = "[object Set]", C = "[object String]", T = "[object Undefined]", w = "[object WeakMap]", B = "[object ArrayBuffer]", I = "[object DataView]", _ = "[object Float32Array]", S = "[object Float64Array]", F = "[object Int8Array]", N = "[object Int16Array]", k = "[object Int32Array]", j = "[object Uint8Array]", O = "[object Uint8ClampedArray]", z = "[object Uint16Array]", te = "[object Uint32Array]", se = /[\\^$.*+?()[\]{}|]/g, ye = /^\[object .+?Constructor\]$/, Se = /^(?:0|[1-9]\d*)$/, xe = {};
  xe[_] = xe[S] = xe[F] = xe[N] = xe[k] = xe[j] = xe[O] = xe[z] = xe[te] = !0, xe[l] = xe[i] = xe[B] = xe[c] = xe[I] = xe[f] = xe[h] = xe[p] = xe[d] = xe[g] = xe[x] = xe[b] = xe[v] = xe[C] = xe[w] = !1;
  var Ae = typeof mr == "object" && mr && mr.Object === Object && mr, _e = typeof self == "object" && self && self.Object === Object && self, H = Ae || _e || Function("return this")(), Q = e && !e.nodeType && e, ge = Q && !0 && t && !t.nodeType && t, ae = ge && ge.exports === Q, ee = ae && Ae.process, he = function() {
    try {
      var q = ge && ge.require && ge.require("util").types;
      return q || ee && ee.binding && ee.binding("util");
    } catch {
    }
  }(), R = he && he.isTypedArray;
  function D(q, Y, ie) {
    switch (ie.length) {
      case 0:
        return q.call(Y);
      case 1:
        return q.call(Y, ie[0]);
      case 2:
        return q.call(Y, ie[0], ie[1]);
      case 3:
        return q.call(Y, ie[0], ie[1], ie[2]);
    }
    return q.apply(Y, ie);
  }
  function U(q, Y) {
    for (var ie = -1, Ie = Array(q); ++ie < q; )
      Ie[ie] = Y(ie);
    return Ie;
  }
  function ne(q) {
    return function(Y) {
      return q(Y);
    };
  }
  function pe(q, Y) {
    return q == null ? void 0 : q[Y];
  }
  function Ee(q, Y) {
    return function(ie) {
      return q(Y(ie));
    };
  }
  var Re = Array.prototype, We = Function.prototype, wt = Object.prototype, Lt = H["__core-js_shared__"], et = We.toString, Ge = wt.hasOwnProperty, mt = function() {
    var q = /[^.]+$/.exec(Lt && Lt.keys && Lt.keys.IE_PROTO || "");
    return q ? "Symbol(src)_1." + q : "";
  }(), tr = wt.toString, vr = et.call(Object), Er = RegExp(
    "^" + et.call(Ge).replace(se, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), hr = ae ? H.Buffer : void 0, P = H.Symbol, It = H.Uint8Array, St = hr ? hr.allocUnsafe : void 0, rr = Ee(Object.getPrototypeOf, Object), Te = Object.create, qe = wt.propertyIsEnumerable, Be = Re.splice, At = P ? P.toStringTag : void 0, bt = function() {
    try {
      var q = Mi(Object, "defineProperty");
      return q({}, "", {}), q;
    } catch {
    }
  }(), Ce = hr ? hr.isBuffer : void 0, Z = Math.max, W = Date.now, G = Mi(H, "Map"), J = Mi(Object, "create"), le = function() {
    function q() {
    }
    return function(Y) {
      if (!mn(Y))
        return {};
      if (Te)
        return Te(Y);
      q.prototype = Y;
      var ie = new q();
      return q.prototype = void 0, ie;
    };
  }();
  function ce(q) {
    var Y = -1, ie = q == null ? 0 : q.length;
    for (this.clear(); ++Y < ie; ) {
      var Ie = q[Y];
      this.set(Ie[0], Ie[1]);
    }
  }
  function Fe() {
    this.__data__ = J ? J(null) : {}, this.size = 0;
  }
  function Ve(q) {
    var Y = this.has(q) && delete this.__data__[q];
    return this.size -= Y ? 1 : 0, Y;
  }
  function Ye(q) {
    var Y = this.__data__;
    if (J) {
      var ie = Y[q];
      return ie === s ? void 0 : ie;
    }
    return Ge.call(Y, q) ? Y[q] : void 0;
  }
  function lt(q) {
    var Y = this.__data__;
    return J ? Y[q] !== void 0 : Ge.call(Y, q);
  }
  function xt(q, Y) {
    var ie = this.__data__;
    return this.size += this.has(q) ? 0 : 1, ie[q] = J && Y === void 0 ? s : Y, this;
  }
  ce.prototype.clear = Fe, ce.prototype.delete = Ve, ce.prototype.get = Ye, ce.prototype.has = lt, ce.prototype.set = xt;
  function oe(q) {
    var Y = -1, ie = q == null ? 0 : q.length;
    for (this.clear(); ++Y < ie; ) {
      var Ie = q[Y];
      this.set(Ie[0], Ie[1]);
    }
  }
  function be() {
    this.__data__ = [], this.size = 0;
  }
  function ke(q) {
    var Y = this.__data__, ie = at(Y, q);
    if (ie < 0)
      return !1;
    var Ie = Y.length - 1;
    return ie == Ie ? Y.pop() : Be.call(Y, ie, 1), --this.size, !0;
  }
  function re(q) {
    var Y = this.__data__, ie = at(Y, q);
    return ie < 0 ? void 0 : Y[ie][1];
  }
  function M(q) {
    return at(this.__data__, q) > -1;
  }
  function L(q, Y) {
    var ie = this.__data__, Ie = at(ie, q);
    return Ie < 0 ? (++this.size, ie.push([q, Y])) : ie[Ie][1] = Y, this;
  }
  oe.prototype.clear = be, oe.prototype.delete = ke, oe.prototype.get = re, oe.prototype.has = M, oe.prototype.set = L;
  function V(q) {
    var Y = -1, ie = q == null ? 0 : q.length;
    for (this.clear(); ++Y < ie; ) {
      var Ie = q[Y];
      this.set(Ie[0], Ie[1]);
    }
  }
  function K() {
    this.size = 0, this.__data__ = {
      hash: new ce(),
      map: new (G || oe)(),
      string: new ce()
    };
  }
  function X(q) {
    var Y = ra(this, q).delete(q);
    return this.size -= Y ? 1 : 0, Y;
  }
  function de(q) {
    return ra(this, q).get(q);
  }
  function we(q) {
    return ra(this, q).has(q);
  }
  function Me(q, Y) {
    var ie = ra(this, q), Ie = ie.size;
    return ie.set(q, Y), this.size += ie.size == Ie ? 0 : 1, this;
  }
  V.prototype.clear = K, V.prototype.delete = X, V.prototype.get = de, V.prototype.has = we, V.prototype.set = Me;
  function Ne(q) {
    var Y = this.__data__ = new oe(q);
    this.size = Y.size;
  }
  function tt() {
    this.__data__ = new oe(), this.size = 0;
  }
  function je(q) {
    var Y = this.__data__, ie = Y.delete(q);
    return this.size = Y.size, ie;
  }
  function fe(q) {
    return this.__data__.get(q);
  }
  function De(q) {
    return this.__data__.has(q);
  }
  function ve(q, Y) {
    var ie = this.__data__;
    if (ie instanceof oe) {
      var Ie = ie.__data__;
      if (!G || Ie.length < r - 1)
        return Ie.push([q, Y]), this.size = ++ie.size, this;
      ie = this.__data__ = new V(Ie);
    }
    return ie.set(q, Y), this.size = ie.size, this;
  }
  Ne.prototype.clear = tt, Ne.prototype.delete = je, Ne.prototype.get = fe, Ne.prototype.has = De, Ne.prototype.set = ve;
  function ue(q, Y) {
    var ie = Ui(q), Ie = !ie && Vi(q), Je = !ie && !Ie && dd(q), nt = !ie && !Ie && !Je && yd(q), ct = ie || Ie || Je || nt, He = ct ? U(q.length, String) : [], pt = He.length;
    for (var ar in q)
      (Y || Ge.call(q, ar)) && !(ct && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ar == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Je && (ar == "offset" || ar == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      nt && (ar == "buffer" || ar == "byteLength" || ar == "byteOffset") || // Skip index properties.
      hd(ar, pt))) && He.push(ar);
    return He;
  }
  function Pe(q, Y, ie) {
    (ie !== void 0 && !na(q[Y], ie) || ie === void 0 && !(Y in q)) && ut(q, Y, ie);
  }
  function Oe(q, Y, ie) {
    var Ie = q[Y];
    (!(Ge.call(q, Y) && na(Ie, ie)) || ie === void 0 && !(Y in q)) && ut(q, Y, ie);
  }
  function at(q, Y) {
    for (var ie = q.length; ie--; )
      if (na(q[ie][0], Y))
        return ie;
    return -1;
  }
  function ut(q, Y, ie) {
    Y == "__proto__" && bt ? bt(q, Y, {
      configurable: !0,
      enumerable: !0,
      value: ie,
      writable: !0
    }) : q[Y] = ie;
  }
  var dt = zb();
  function Dt(q) {
    return q == null ? q === void 0 ? T : y : At && At in Object(q) ? Gb(q) : Yb(q);
  }
  function zt(q) {
    return fs(q) && Dt(q) == l;
  }
  function kt(q) {
    if (!mn(q) || Xb(q))
      return !1;
    var Y = Wi(q) ? Er : ye;
    return Y.test(r1(q));
  }
  function nr(q) {
    return fs(q) && gd(q.length) && !!xe[Dt(q)];
  }
  function Ir(q) {
    if (!mn(q))
      return Qb(q);
    var Y = md(q), ie = [];
    for (var Ie in q)
      Ie == "constructor" && (Y || !Ge.call(q, Ie)) || ie.push(Ie);
    return ie;
  }
  function sr(q, Y, ie, Ie, Je) {
    q !== Y && dt(Y, function(nt, ct) {
      if (Je || (Je = new Ne()), mn(nt))
        fn(q, Y, ct, ie, sr, Ie, Je);
      else {
        var He = Ie ? Ie($i(q, ct), nt, ct + "", q, Y, Je) : void 0;
        He === void 0 && (He = nt), Pe(q, ct, He);
      }
    }, xd);
  }
  function fn(q, Y, ie, Ie, Je, nt, ct) {
    var He = $i(q, ie), pt = $i(Y, ie), ar = ct.get(pt);
    if (ar) {
      Pe(q, ie, ar);
      return;
    }
    var Gt = nt ? nt(He, pt, ie + "", q, Y, ct) : void 0, hs = Gt === void 0;
    if (hs) {
      var zi = Ui(pt), Gi = !zi && dd(pt), Ed = !zi && !Gi && yd(pt);
      Gt = pt, zi || Gi || Ed ? Ui(He) ? Gt = He : n1(He) ? Gt = ea(He) : Gi ? (hs = !1, Gt = Bn(pt, !0)) : Ed ? (hs = !1, Gt = Ln(pt, !0)) : Gt = [] : s1(pt) || Vi(pt) ? (Gt = He, Vi(He) ? Gt = a1(He) : (!mn(He) || Wi(He)) && (Gt = Hb(pt))) : hs = !1;
    }
    hs && (ct.set(pt, Gt), Je(Gt, pt, Ie, nt, ct), ct.delete(pt)), Pe(q, ie, Gt);
  }
  function Ys(q, Y) {
    return e1(Zb(q, Y, vd), q + "");
  }
  var Zs = bt ? function(q, Y) {
    return bt(q, "toString", {
      configurable: !0,
      enumerable: !1,
      value: o1(Y),
      writable: !0
    });
  } : vd;
  function Bn(q, Y) {
    if (Y)
      return q.slice();
    var ie = q.length, Ie = St ? St(ie) : new q.constructor(ie);
    return q.copy(Ie), Ie;
  }
  function On(q) {
    var Y = new q.constructor(q.byteLength);
    return new It(Y).set(new It(q)), Y;
  }
  function Ln(q, Y) {
    var ie = Y ? On(q.buffer) : q.buffer;
    return new q.constructor(ie, q.byteOffset, q.length);
  }
  function ea(q, Y) {
    var ie = -1, Ie = q.length;
    for (Y || (Y = Array(Ie)); ++ie < Ie; )
      Y[ie] = q[ie];
    return Y;
  }
  function ta(q, Y, ie, Ie) {
    var Je = !ie;
    ie || (ie = {});
    for (var nt = -1, ct = Y.length; ++nt < ct; ) {
      var He = Y[nt], pt = Ie ? Ie(ie[He], q[He], He, ie, q) : void 0;
      pt === void 0 && (pt = q[He]), Je ? ut(ie, He, pt) : Oe(ie, He, pt);
    }
    return ie;
  }
  function hn(q) {
    return Ys(function(Y, ie) {
      var Ie = -1, Je = ie.length, nt = Je > 1 ? ie[Je - 1] : void 0, ct = Je > 2 ? ie[2] : void 0;
      for (nt = q.length > 3 && typeof nt == "function" ? (Je--, nt) : void 0, ct && Kb(ie[0], ie[1], ct) && (nt = Je < 3 ? void 0 : nt, Je = 1), Y = Object(Y); ++Ie < Je; ) {
        var He = ie[Ie];
        He && q(Y, He, Ie, nt);
      }
      return Y;
    });
  }
  function zb(q) {
    return function(Y, ie, Ie) {
      for (var Je = -1, nt = Object(Y), ct = Ie(Y), He = ct.length; He--; ) {
        var pt = ct[q ? He : ++Je];
        if (ie(nt[pt], pt, nt) === !1)
          break;
      }
      return Y;
    };
  }
  function ra(q, Y) {
    var ie = q.__data__;
    return Jb(Y) ? ie[typeof Y == "string" ? "string" : "hash"] : ie.map;
  }
  function Mi(q, Y) {
    var ie = pe(q, Y);
    return kt(ie) ? ie : void 0;
  }
  function Gb(q) {
    var Y = Ge.call(q, At), ie = q[At];
    try {
      q[At] = void 0;
      var Ie = !0;
    } catch {
    }
    var Je = tr.call(q);
    return Ie && (Y ? q[At] = ie : delete q[At]), Je;
  }
  function Hb(q) {
    return typeof q.constructor == "function" && !md(q) ? le(rr(q)) : {};
  }
  function hd(q, Y) {
    var ie = typeof q;
    return Y = Y ?? o, !!Y && (ie == "number" || ie != "symbol" && Se.test(q)) && q > -1 && q % 1 == 0 && q < Y;
  }
  function Kb(q, Y, ie) {
    if (!mn(ie))
      return !1;
    var Ie = typeof Y;
    return (Ie == "number" ? qi(ie) && hd(Y, ie.length) : Ie == "string" && Y in ie) ? na(ie[Y], q) : !1;
  }
  function Jb(q) {
    var Y = typeof q;
    return Y == "string" || Y == "number" || Y == "symbol" || Y == "boolean" ? q !== "__proto__" : q === null;
  }
  function Xb(q) {
    return !!mt && mt in q;
  }
  function md(q) {
    var Y = q && q.constructor, ie = typeof Y == "function" && Y.prototype || wt;
    return q === ie;
  }
  function Qb(q) {
    var Y = [];
    if (q != null)
      for (var ie in Object(q))
        Y.push(ie);
    return Y;
  }
  function Yb(q) {
    return tr.call(q);
  }
  function Zb(q, Y, ie) {
    return Y = Z(Y === void 0 ? q.length - 1 : Y, 0), function() {
      for (var Ie = arguments, Je = -1, nt = Z(Ie.length - Y, 0), ct = Array(nt); ++Je < nt; )
        ct[Je] = Ie[Y + Je];
      Je = -1;
      for (var He = Array(Y + 1); ++Je < Y; )
        He[Je] = Ie[Je];
      return He[Y] = ie(ct), D(q, this, He);
    };
  }
  function $i(q, Y) {
    if (!(Y === "constructor" && typeof q[Y] == "function") && Y != "__proto__")
      return q[Y];
  }
  var e1 = t1(Zs);
  function t1(q) {
    var Y = 0, ie = 0;
    return function() {
      var Ie = W(), Je = a - (Ie - ie);
      if (ie = Ie, Je > 0) {
        if (++Y >= n)
          return arguments[0];
      } else
        Y = 0;
      return q.apply(void 0, arguments);
    };
  }
  function r1(q) {
    if (q != null) {
      try {
        return et.call(q);
      } catch {
      }
      try {
        return q + "";
      } catch {
      }
    }
    return "";
  }
  function na(q, Y) {
    return q === Y || q !== q && Y !== Y;
  }
  var Vi = zt(function() {
    return arguments;
  }()) ? zt : function(q) {
    return fs(q) && Ge.call(q, "callee") && !qe.call(q, "callee");
  }, Ui = Array.isArray;
  function qi(q) {
    return q != null && gd(q.length) && !Wi(q);
  }
  function n1(q) {
    return fs(q) && qi(q);
  }
  var dd = Ce || l1;
  function Wi(q) {
    if (!mn(q))
      return !1;
    var Y = Dt(q);
    return Y == p || Y == m || Y == u || Y == A;
  }
  function gd(q) {
    return typeof q == "number" && q > -1 && q % 1 == 0 && q <= o;
  }
  function mn(q) {
    var Y = typeof q;
    return q != null && (Y == "object" || Y == "function");
  }
  function fs(q) {
    return q != null && typeof q == "object";
  }
  function s1(q) {
    if (!fs(q) || Dt(q) != x)
      return !1;
    var Y = rr(q);
    if (Y === null)
      return !0;
    var ie = Ge.call(Y, "constructor") && Y.constructor;
    return typeof ie == "function" && ie instanceof ie && et.call(ie) == vr;
  }
  var yd = R ? ne(R) : nr;
  function a1(q) {
    return ta(q, xd(q));
  }
  function xd(q) {
    return qi(q) ? ue(q, !0) : Ir(q);
  }
  var i1 = hn(function(q, Y, ie) {
    sr(q, Y, ie);
  });
  function o1(q) {
    return function() {
      return q;
    };
  }
  function vd(q) {
    return q;
  }
  function l1() {
    return !1;
  }
  t.exports = i1;
})(fl, fl.exports);
var gu = { exports: {} }, _T = {
  AggregateError: !1,
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  FinalizationRegistry: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakRef: !1,
  WeakSet: !1
}, BT = {
  Array: !1,
  Boolean: !1,
  constructor: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  propertyIsEnumerable: !1,
  RangeError: !1,
  ReferenceError: !1,
  RegExp: !1,
  String: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1
}, OT = {
  Array: !1,
  ArrayBuffer: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, LT = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, RT = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, NT = {
  AggregateError: !1,
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  FinalizationRegistry: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakRef: !1,
  WeakSet: !1
}, jT = {
  AbortController: !1,
  AbortSignal: !1,
  addEventListener: !1,
  alert: !1,
  AnalyserNode: !1,
  Animation: !1,
  AnimationEffectReadOnly: !1,
  AnimationEffectTiming: !1,
  AnimationEffectTimingReadOnly: !1,
  AnimationEvent: !1,
  AnimationPlaybackEvent: !1,
  AnimationTimeline: !1,
  applicationCache: !1,
  ApplicationCache: !1,
  ApplicationCacheErrorEvent: !1,
  atob: !1,
  Attr: !1,
  Audio: !1,
  AudioBuffer: !1,
  AudioBufferSourceNode: !1,
  AudioContext: !1,
  AudioDestinationNode: !1,
  AudioListener: !1,
  AudioNode: !1,
  AudioParam: !1,
  AudioProcessingEvent: !1,
  AudioScheduledSourceNode: !1,
  AudioWorkletGlobalScope: !1,
  AudioWorkletNode: !1,
  AudioWorkletProcessor: !1,
  BarProp: !1,
  BaseAudioContext: !1,
  BatteryManager: !1,
  BeforeUnloadEvent: !1,
  BiquadFilterNode: !1,
  Blob: !1,
  BlobEvent: !1,
  blur: !1,
  BroadcastChannel: !1,
  btoa: !1,
  BudgetService: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  cancelAnimationFrame: !1,
  cancelIdleCallback: !1,
  CanvasCaptureMediaStreamTrack: !1,
  CanvasGradient: !1,
  CanvasPattern: !1,
  CanvasRenderingContext2D: !1,
  ChannelMergerNode: !1,
  ChannelSplitterNode: !1,
  CharacterData: !1,
  clearInterval: !1,
  clearTimeout: !1,
  clientInformation: !1,
  ClipboardEvent: !1,
  ClipboardItem: !1,
  close: !1,
  closed: !1,
  CloseEvent: !1,
  Comment: !1,
  CompositionEvent: !1,
  confirm: !1,
  console: !1,
  ConstantSourceNode: !1,
  ConvolverNode: !1,
  CountQueuingStrategy: !1,
  createImageBitmap: !1,
  Credential: !1,
  CredentialsContainer: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CSS: !1,
  CSSConditionRule: !1,
  CSSFontFaceRule: !1,
  CSSGroupingRule: !1,
  CSSImportRule: !1,
  CSSKeyframeRule: !1,
  CSSKeyframesRule: !1,
  CSSMatrixComponent: !1,
  CSSMediaRule: !1,
  CSSNamespaceRule: !1,
  CSSPageRule: !1,
  CSSPerspective: !1,
  CSSRotate: !1,
  CSSRule: !1,
  CSSRuleList: !1,
  CSSScale: !1,
  CSSSkew: !1,
  CSSSkewX: !1,
  CSSSkewY: !1,
  CSSStyleDeclaration: !1,
  CSSStyleRule: !1,
  CSSStyleSheet: !1,
  CSSSupportsRule: !1,
  CSSTransformValue: !1,
  CSSTranslate: !1,
  CustomElementRegistry: !1,
  customElements: !1,
  CustomEvent: !1,
  DataTransfer: !1,
  DataTransferItem: !1,
  DataTransferItemList: !1,
  defaultstatus: !1,
  defaultStatus: !1,
  DelayNode: !1,
  DeviceMotionEvent: !1,
  DeviceOrientationEvent: !1,
  devicePixelRatio: !1,
  dispatchEvent: !1,
  document: !1,
  Document: !1,
  DocumentFragment: !1,
  DocumentType: !1,
  DOMError: !1,
  DOMException: !1,
  DOMImplementation: !1,
  DOMMatrix: !1,
  DOMMatrixReadOnly: !1,
  DOMParser: !1,
  DOMPoint: !1,
  DOMPointReadOnly: !1,
  DOMQuad: !1,
  DOMRect: !1,
  DOMRectList: !1,
  DOMRectReadOnly: !1,
  DOMStringList: !1,
  DOMStringMap: !1,
  DOMTokenList: !1,
  DragEvent: !1,
  DynamicsCompressorNode: !1,
  Element: !1,
  ErrorEvent: !1,
  event: !1,
  Event: !1,
  EventSource: !1,
  EventTarget: !1,
  external: !1,
  fetch: !1,
  File: !1,
  FileList: !1,
  FileReader: !1,
  find: !1,
  focus: !1,
  FocusEvent: !1,
  FontFace: !1,
  FontFaceSetLoadEvent: !1,
  FormData: !1,
  FormDataEvent: !1,
  frameElement: !1,
  frames: !1,
  GainNode: !1,
  Gamepad: !1,
  GamepadButton: !1,
  GamepadEvent: !1,
  getComputedStyle: !1,
  getSelection: !1,
  HashChangeEvent: !1,
  Headers: !1,
  history: !1,
  History: !1,
  HTMLAllCollection: !1,
  HTMLAnchorElement: !1,
  HTMLAreaElement: !1,
  HTMLAudioElement: !1,
  HTMLBaseElement: !1,
  HTMLBodyElement: !1,
  HTMLBRElement: !1,
  HTMLButtonElement: !1,
  HTMLCanvasElement: !1,
  HTMLCollection: !1,
  HTMLContentElement: !1,
  HTMLDataElement: !1,
  HTMLDataListElement: !1,
  HTMLDetailsElement: !1,
  HTMLDialogElement: !1,
  HTMLDirectoryElement: !1,
  HTMLDivElement: !1,
  HTMLDListElement: !1,
  HTMLDocument: !1,
  HTMLElement: !1,
  HTMLEmbedElement: !1,
  HTMLFieldSetElement: !1,
  HTMLFontElement: !1,
  HTMLFormControlsCollection: !1,
  HTMLFormElement: !1,
  HTMLFrameElement: !1,
  HTMLFrameSetElement: !1,
  HTMLHeadElement: !1,
  HTMLHeadingElement: !1,
  HTMLHRElement: !1,
  HTMLHtmlElement: !1,
  HTMLIFrameElement: !1,
  HTMLImageElement: !1,
  HTMLInputElement: !1,
  HTMLLabelElement: !1,
  HTMLLegendElement: !1,
  HTMLLIElement: !1,
  HTMLLinkElement: !1,
  HTMLMapElement: !1,
  HTMLMarqueeElement: !1,
  HTMLMediaElement: !1,
  HTMLMenuElement: !1,
  HTMLMetaElement: !1,
  HTMLMeterElement: !1,
  HTMLModElement: !1,
  HTMLObjectElement: !1,
  HTMLOListElement: !1,
  HTMLOptGroupElement: !1,
  HTMLOptionElement: !1,
  HTMLOptionsCollection: !1,
  HTMLOutputElement: !1,
  HTMLParagraphElement: !1,
  HTMLParamElement: !1,
  HTMLPictureElement: !1,
  HTMLPreElement: !1,
  HTMLProgressElement: !1,
  HTMLQuoteElement: !1,
  HTMLScriptElement: !1,
  HTMLSelectElement: !1,
  HTMLShadowElement: !1,
  HTMLSlotElement: !1,
  HTMLSourceElement: !1,
  HTMLSpanElement: !1,
  HTMLStyleElement: !1,
  HTMLTableCaptionElement: !1,
  HTMLTableCellElement: !1,
  HTMLTableColElement: !1,
  HTMLTableElement: !1,
  HTMLTableRowElement: !1,
  HTMLTableSectionElement: !1,
  HTMLTemplateElement: !1,
  HTMLTextAreaElement: !1,
  HTMLTimeElement: !1,
  HTMLTitleElement: !1,
  HTMLTrackElement: !1,
  HTMLUListElement: !1,
  HTMLUnknownElement: !1,
  HTMLVideoElement: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  IdleDeadline: !1,
  IIRFilterNode: !1,
  Image: !1,
  ImageBitmap: !1,
  ImageBitmapRenderingContext: !1,
  ImageCapture: !1,
  ImageData: !1,
  indexedDB: !1,
  innerHeight: !1,
  innerWidth: !1,
  InputEvent: !1,
  IntersectionObserver: !1,
  IntersectionObserverEntry: !1,
  Intl: !1,
  isSecureContext: !1,
  KeyboardEvent: !1,
  KeyframeEffect: !1,
  KeyframeEffectReadOnly: !1,
  length: !1,
  localStorage: !1,
  location: !0,
  Location: !1,
  locationbar: !1,
  matchMedia: !1,
  MediaDeviceInfo: !1,
  MediaDevices: !1,
  MediaElementAudioSourceNode: !1,
  MediaEncryptedEvent: !1,
  MediaError: !1,
  MediaKeyMessageEvent: !1,
  MediaKeySession: !1,
  MediaKeyStatusMap: !1,
  MediaKeySystemAccess: !1,
  MediaList: !1,
  MediaMetadata: !1,
  MediaQueryList: !1,
  MediaQueryListEvent: !1,
  MediaRecorder: !1,
  MediaSettingsRange: !1,
  MediaSource: !1,
  MediaStream: !1,
  MediaStreamAudioDestinationNode: !1,
  MediaStreamAudioSourceNode: !1,
  MediaStreamEvent: !1,
  MediaStreamTrack: !1,
  MediaStreamTrackEvent: !1,
  menubar: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  MIDIAccess: !1,
  MIDIConnectionEvent: !1,
  MIDIInput: !1,
  MIDIInputMap: !1,
  MIDIMessageEvent: !1,
  MIDIOutput: !1,
  MIDIOutputMap: !1,
  MIDIPort: !1,
  MimeType: !1,
  MimeTypeArray: !1,
  MouseEvent: !1,
  moveBy: !1,
  moveTo: !1,
  MutationEvent: !1,
  MutationObserver: !1,
  MutationRecord: !1,
  name: !1,
  NamedNodeMap: !1,
  NavigationPreloadManager: !1,
  navigator: !1,
  Navigator: !1,
  NetworkInformation: !1,
  Node: !1,
  NodeFilter: !1,
  NodeIterator: !1,
  NodeList: !1,
  Notification: !1,
  OfflineAudioCompletionEvent: !1,
  OfflineAudioContext: !1,
  offscreenBuffering: !1,
  OffscreenCanvas: !0,
  OffscreenCanvasRenderingContext2D: !1,
  onabort: !0,
  onafterprint: !0,
  onanimationend: !0,
  onanimationiteration: !0,
  onanimationstart: !0,
  onappinstalled: !0,
  onauxclick: !0,
  onbeforeinstallprompt: !0,
  onbeforeprint: !0,
  onbeforeunload: !0,
  onblur: !0,
  oncancel: !0,
  oncanplay: !0,
  oncanplaythrough: !0,
  onchange: !0,
  onclick: !0,
  onclose: !0,
  oncontextmenu: !0,
  oncuechange: !0,
  ondblclick: !0,
  ondevicemotion: !0,
  ondeviceorientation: !0,
  ondeviceorientationabsolute: !0,
  ondrag: !0,
  ondragend: !0,
  ondragenter: !0,
  ondragleave: !0,
  ondragover: !0,
  ondragstart: !0,
  ondrop: !0,
  ondurationchange: !0,
  onemptied: !0,
  onended: !0,
  onerror: !0,
  onfocus: !0,
  ongotpointercapture: !0,
  onhashchange: !0,
  oninput: !0,
  oninvalid: !0,
  onkeydown: !0,
  onkeypress: !0,
  onkeyup: !0,
  onlanguagechange: !0,
  onload: !0,
  onloadeddata: !0,
  onloadedmetadata: !0,
  onloadstart: !0,
  onlostpointercapture: !0,
  onmessage: !0,
  onmessageerror: !0,
  onmousedown: !0,
  onmouseenter: !0,
  onmouseleave: !0,
  onmousemove: !0,
  onmouseout: !0,
  onmouseover: !0,
  onmouseup: !0,
  onmousewheel: !0,
  onoffline: !0,
  ononline: !0,
  onpagehide: !0,
  onpageshow: !0,
  onpause: !0,
  onplay: !0,
  onplaying: !0,
  onpointercancel: !0,
  onpointerdown: !0,
  onpointerenter: !0,
  onpointerleave: !0,
  onpointermove: !0,
  onpointerout: !0,
  onpointerover: !0,
  onpointerup: !0,
  onpopstate: !0,
  onprogress: !0,
  onratechange: !0,
  onrejectionhandled: !0,
  onreset: !0,
  onresize: !0,
  onscroll: !0,
  onsearch: !0,
  onseeked: !0,
  onseeking: !0,
  onselect: !0,
  onstalled: !0,
  onstorage: !0,
  onsubmit: !0,
  onsuspend: !0,
  ontimeupdate: !0,
  ontoggle: !0,
  ontransitionend: !0,
  onunhandledrejection: !0,
  onunload: !0,
  onvolumechange: !0,
  onwaiting: !0,
  onwheel: !0,
  open: !1,
  openDatabase: !1,
  opener: !1,
  Option: !1,
  origin: !1,
  OscillatorNode: !1,
  outerHeight: !1,
  outerWidth: !1,
  OverconstrainedError: !1,
  PageTransitionEvent: !1,
  pageXOffset: !1,
  pageYOffset: !1,
  PannerNode: !1,
  parent: !1,
  Path2D: !1,
  PaymentAddress: !1,
  PaymentRequest: !1,
  PaymentRequestUpdateEvent: !1,
  PaymentResponse: !1,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceLongTaskTiming: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceNavigationTiming: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformancePaintTiming: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  PeriodicWave: !1,
  Permissions: !1,
  PermissionStatus: !1,
  personalbar: !1,
  PhotoCapabilities: !1,
  Plugin: !1,
  PluginArray: !1,
  PointerEvent: !1,
  PopStateEvent: !1,
  postMessage: !1,
  Presentation: !1,
  PresentationAvailability: !1,
  PresentationConnection: !1,
  PresentationConnectionAvailableEvent: !1,
  PresentationConnectionCloseEvent: !1,
  PresentationConnectionList: !1,
  PresentationReceiver: !1,
  PresentationRequest: !1,
  print: !1,
  ProcessingInstruction: !1,
  ProgressEvent: !1,
  PromiseRejectionEvent: !1,
  prompt: !1,
  PushManager: !1,
  PushSubscription: !1,
  PushSubscriptionOptions: !1,
  queueMicrotask: !1,
  RadioNodeList: !1,
  Range: !1,
  ReadableStream: !1,
  registerProcessor: !1,
  RemotePlayback: !1,
  removeEventListener: !1,
  reportError: !1,
  Request: !1,
  requestAnimationFrame: !1,
  requestIdleCallback: !1,
  resizeBy: !1,
  ResizeObserver: !1,
  ResizeObserverEntry: !1,
  resizeTo: !1,
  Response: !1,
  RTCCertificate: !1,
  RTCDataChannel: !1,
  RTCDataChannelEvent: !1,
  RTCDtlsTransport: !1,
  RTCIceCandidate: !1,
  RTCIceGatherer: !1,
  RTCIceTransport: !1,
  RTCPeerConnection: !1,
  RTCPeerConnectionIceEvent: !1,
  RTCRtpContributingSource: !1,
  RTCRtpReceiver: !1,
  RTCRtpSender: !1,
  RTCSctpTransport: !1,
  RTCSessionDescription: !1,
  RTCStatsReport: !1,
  RTCTrackEvent: !1,
  screen: !1,
  Screen: !1,
  screenLeft: !1,
  ScreenOrientation: !1,
  screenTop: !1,
  screenX: !1,
  screenY: !1,
  ScriptProcessorNode: !1,
  scroll: !1,
  scrollbars: !1,
  scrollBy: !1,
  scrollTo: !1,
  scrollX: !1,
  scrollY: !1,
  SecurityPolicyViolationEvent: !1,
  Selection: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerRegistration: !1,
  sessionStorage: !1,
  setInterval: !1,
  setTimeout: !1,
  ShadowRoot: !1,
  SharedWorker: !1,
  SourceBuffer: !1,
  SourceBufferList: !1,
  speechSynthesis: !1,
  SpeechSynthesisEvent: !1,
  SpeechSynthesisUtterance: !1,
  StaticRange: !1,
  status: !1,
  statusbar: !1,
  StereoPannerNode: !1,
  stop: !1,
  Storage: !1,
  StorageEvent: !1,
  StorageManager: !1,
  structuredClone: !1,
  styleMedia: !1,
  StyleSheet: !1,
  StyleSheetList: !1,
  SubmitEvent: !1,
  SubtleCrypto: !1,
  SVGAElement: !1,
  SVGAngle: !1,
  SVGAnimatedAngle: !1,
  SVGAnimatedBoolean: !1,
  SVGAnimatedEnumeration: !1,
  SVGAnimatedInteger: !1,
  SVGAnimatedLength: !1,
  SVGAnimatedLengthList: !1,
  SVGAnimatedNumber: !1,
  SVGAnimatedNumberList: !1,
  SVGAnimatedPreserveAspectRatio: !1,
  SVGAnimatedRect: !1,
  SVGAnimatedString: !1,
  SVGAnimatedTransformList: !1,
  SVGAnimateElement: !1,
  SVGAnimateMotionElement: !1,
  SVGAnimateTransformElement: !1,
  SVGAnimationElement: !1,
  SVGCircleElement: !1,
  SVGClipPathElement: !1,
  SVGComponentTransferFunctionElement: !1,
  SVGDefsElement: !1,
  SVGDescElement: !1,
  SVGDiscardElement: !1,
  SVGElement: !1,
  SVGEllipseElement: !1,
  SVGFEBlendElement: !1,
  SVGFEColorMatrixElement: !1,
  SVGFEComponentTransferElement: !1,
  SVGFECompositeElement: !1,
  SVGFEConvolveMatrixElement: !1,
  SVGFEDiffuseLightingElement: !1,
  SVGFEDisplacementMapElement: !1,
  SVGFEDistantLightElement: !1,
  SVGFEDropShadowElement: !1,
  SVGFEFloodElement: !1,
  SVGFEFuncAElement: !1,
  SVGFEFuncBElement: !1,
  SVGFEFuncGElement: !1,
  SVGFEFuncRElement: !1,
  SVGFEGaussianBlurElement: !1,
  SVGFEImageElement: !1,
  SVGFEMergeElement: !1,
  SVGFEMergeNodeElement: !1,
  SVGFEMorphologyElement: !1,
  SVGFEOffsetElement: !1,
  SVGFEPointLightElement: !1,
  SVGFESpecularLightingElement: !1,
  SVGFESpotLightElement: !1,
  SVGFETileElement: !1,
  SVGFETurbulenceElement: !1,
  SVGFilterElement: !1,
  SVGForeignObjectElement: !1,
  SVGGElement: !1,
  SVGGeometryElement: !1,
  SVGGradientElement: !1,
  SVGGraphicsElement: !1,
  SVGImageElement: !1,
  SVGLength: !1,
  SVGLengthList: !1,
  SVGLinearGradientElement: !1,
  SVGLineElement: !1,
  SVGMarkerElement: !1,
  SVGMaskElement: !1,
  SVGMatrix: !1,
  SVGMetadataElement: !1,
  SVGMPathElement: !1,
  SVGNumber: !1,
  SVGNumberList: !1,
  SVGPathElement: !1,
  SVGPatternElement: !1,
  SVGPoint: !1,
  SVGPointList: !1,
  SVGPolygonElement: !1,
  SVGPolylineElement: !1,
  SVGPreserveAspectRatio: !1,
  SVGRadialGradientElement: !1,
  SVGRect: !1,
  SVGRectElement: !1,
  SVGScriptElement: !1,
  SVGSetElement: !1,
  SVGStopElement: !1,
  SVGStringList: !1,
  SVGStyleElement: !1,
  SVGSVGElement: !1,
  SVGSwitchElement: !1,
  SVGSymbolElement: !1,
  SVGTextContentElement: !1,
  SVGTextElement: !1,
  SVGTextPathElement: !1,
  SVGTextPositioningElement: !1,
  SVGTitleElement: !1,
  SVGTransform: !1,
  SVGTransformList: !1,
  SVGTSpanElement: !1,
  SVGUnitTypes: !1,
  SVGUseElement: !1,
  SVGViewElement: !1,
  TaskAttributionTiming: !1,
  Text: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  TextEvent: !1,
  TextMetrics: !1,
  TextTrack: !1,
  TextTrackCue: !1,
  TextTrackCueList: !1,
  TextTrackList: !1,
  TimeRanges: !1,
  toolbar: !1,
  top: !1,
  Touch: !1,
  TouchEvent: !1,
  TouchList: !1,
  TrackEvent: !1,
  TransformStream: !1,
  TransitionEvent: !1,
  TreeWalker: !1,
  UIEvent: !1,
  URL: !1,
  URLSearchParams: !1,
  ValidityState: !1,
  visualViewport: !1,
  VisualViewport: !1,
  VTTCue: !1,
  WaveShaperNode: !1,
  WebAssembly: !1,
  WebGL2RenderingContext: !1,
  WebGLActiveInfo: !1,
  WebGLBuffer: !1,
  WebGLContextEvent: !1,
  WebGLFramebuffer: !1,
  WebGLProgram: !1,
  WebGLQuery: !1,
  WebGLRenderbuffer: !1,
  WebGLRenderingContext: !1,
  WebGLSampler: !1,
  WebGLShader: !1,
  WebGLShaderPrecisionFormat: !1,
  WebGLSync: !1,
  WebGLTexture: !1,
  WebGLTransformFeedback: !1,
  WebGLUniformLocation: !1,
  WebGLVertexArrayObject: !1,
  WebSocket: !1,
  WheelEvent: !1,
  window: !1,
  Window: !1,
  Worker: !1,
  WritableStream: !1,
  XMLDocument: !1,
  XMLHttpRequest: !1,
  XMLHttpRequestEventTarget: !1,
  XMLHttpRequestUpload: !1,
  XMLSerializer: !1,
  XPathEvaluator: !1,
  XPathExpression: !1,
  XPathResult: !1,
  XSLTProcessor: !1
}, MT = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  clearInterval: !1,
  clearTimeout: !1,
  close: !0,
  console: !1,
  CustomEvent: !1,
  ErrorEvent: !1,
  Event: !1,
  fetch: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !0,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onoffline: !0,
  ononline: !0,
  onrejectionhandled: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  removeEventListener: !1,
  reportError: !1,
  Request: !1,
  Response: !1,
  self: !0,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, $T = {
  __dirname: !1,
  __filename: !1,
  AbortController: !1,
  AbortSignal: !1,
  atob: !1,
  btoa: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  DOMException: !1,
  Event: !1,
  EventTarget: !1,
  exports: !0,
  fetch: !1,
  global: !1,
  Intl: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  module: !1,
  performance: !1,
  process: !1,
  queueMicrotask: !1,
  require: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  structuredClone: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, VT = {
  AbortController: !1,
  AbortSignal: !1,
  atob: !1,
  btoa: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  DOMException: !1,
  Event: !1,
  EventTarget: !1,
  fetch: !1,
  global: !1,
  Intl: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  performance: !1,
  process: !1,
  queueMicrotask: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  structuredClone: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, UT = {
  exports: !0,
  global: !1,
  module: !1,
  require: !1
}, qT = {
  define: !1,
  require: !1
}, WT = {
  after: !1,
  afterEach: !1,
  before: !1,
  beforeEach: !1,
  context: !1,
  describe: !1,
  it: !1,
  mocha: !1,
  run: !1,
  setup: !1,
  specify: !1,
  suite: !1,
  suiteSetup: !1,
  suiteTeardown: !1,
  teardown: !1,
  test: !1,
  xcontext: !1,
  xdescribe: !1,
  xit: !1,
  xspecify: !1
}, zT = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  expectAsync: !1,
  fail: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jasmine: !1,
  pending: !1,
  runs: !1,
  spyOn: !1,
  spyOnAllFunctions: !1,
  spyOnProperty: !1,
  waits: !1,
  waitsFor: !1,
  xdescribe: !1,
  xit: !1
}, GT = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jest: !1,
  pit: !1,
  require: !1,
  test: !1,
  xdescribe: !1,
  xit: !1,
  xtest: !1
}, HT = {
  asyncTest: !1,
  deepEqual: !1,
  equal: !1,
  expect: !1,
  module: !1,
  notDeepEqual: !1,
  notEqual: !1,
  notOk: !1,
  notPropEqual: !1,
  notStrictEqual: !1,
  ok: !1,
  propEqual: !1,
  QUnit: !1,
  raises: !1,
  start: !1,
  stop: !1,
  strictEqual: !1,
  test: !1,
  throws: !1
}, KT = {
  console: !0,
  exports: !0,
  phantom: !0,
  require: !0,
  WebPage: !0
}, JT = {
  emit: !1,
  exports: !1,
  getRow: !1,
  log: !1,
  module: !1,
  provides: !1,
  require: !1,
  respond: !1,
  send: !1,
  start: !1,
  sum: !1
}, XT = {
  defineClass: !1,
  deserialize: !1,
  gc: !1,
  help: !1,
  importClass: !1,
  importPackage: !1,
  java: !1,
  load: !1,
  loadClass: !1,
  Packages: !1,
  print: !1,
  quit: !1,
  readFile: !1,
  readUrl: !1,
  runCommand: !1,
  seal: !1,
  serialize: !1,
  spawn: !1,
  sync: !1,
  toint32: !1,
  version: !1
}, QT = {
  __DIR__: !1,
  __FILE__: !1,
  __LINE__: !1,
  com: !1,
  edu: !1,
  exit: !1,
  java: !1,
  Java: !1,
  javafx: !1,
  JavaImporter: !1,
  javax: !1,
  JSAdapter: !1,
  load: !1,
  loadWithNewGlobal: !1,
  org: !1,
  Packages: !1,
  print: !1,
  quit: !1
}, YT = {
  ActiveXObject: !1,
  CollectGarbage: !1,
  Debug: !1,
  Enumerator: !1,
  GetObject: !1,
  RuntimeObject: !1,
  ScriptEngine: !1,
  ScriptEngineBuildVersion: !1,
  ScriptEngineMajorVersion: !1,
  ScriptEngineMinorVersion: !1,
  VBArray: !1,
  WScript: !1,
  WSH: !1
}, ZT = {
  $: !1,
  jQuery: !1
}, eF = {
  YAHOO: !1,
  YAHOO_config: !1,
  YUI: !1,
  YUI_config: !1
}, tF = {
  cat: !1,
  cd: !1,
  chmod: !1,
  config: !1,
  cp: !1,
  dirs: !1,
  echo: !1,
  env: !1,
  error: !1,
  exec: !1,
  exit: !1,
  find: !1,
  grep: !1,
  ln: !1,
  ls: !1,
  mkdir: !1,
  mv: !1,
  popd: !1,
  pushd: !1,
  pwd: !1,
  rm: !1,
  sed: !1,
  set: !1,
  target: !1,
  tempdir: !1,
  test: !1,
  touch: !1,
  which: !1
}, rF = {
  $: !1,
  $$: !1,
  $A: !1,
  $break: !1,
  $continue: !1,
  $F: !1,
  $H: !1,
  $R: !1,
  $w: !1,
  Abstract: !1,
  Ajax: !1,
  Autocompleter: !1,
  Builder: !1,
  Class: !1,
  Control: !1,
  Draggable: !1,
  Draggables: !1,
  Droppables: !1,
  Effect: !1,
  Element: !1,
  Enumerable: !1,
  Event: !1,
  Field: !1,
  Form: !1,
  Hash: !1,
  Insertion: !1,
  ObjectRange: !1,
  PeriodicalExecuter: !1,
  Position: !1,
  Prototype: !1,
  Scriptaculous: !1,
  Selector: !1,
  Sortable: !1,
  SortableObserver: !1,
  Sound: !1,
  Template: !1,
  Toggle: !1,
  Try: !1
}, nF = {
  $: !1,
  Accounts: !1,
  AccountsClient: !1,
  AccountsCommon: !1,
  AccountsServer: !1,
  App: !1,
  Assets: !1,
  Blaze: !1,
  check: !1,
  Cordova: !1,
  DDP: !1,
  DDPRateLimiter: !1,
  DDPServer: !1,
  Deps: !1,
  EJSON: !1,
  Email: !1,
  HTTP: !1,
  Log: !1,
  Match: !1,
  Meteor: !1,
  Mongo: !1,
  MongoInternals: !1,
  Npm: !1,
  Package: !1,
  Plugin: !1,
  process: !1,
  Random: !1,
  ReactiveDict: !1,
  ReactiveVar: !1,
  Router: !1,
  ServiceConfiguration: !1,
  Session: !1,
  share: !1,
  Spacebars: !1,
  Template: !1,
  Tinytest: !1,
  Tracker: !1,
  UI: !1,
  Utils: !1,
  WebApp: !1,
  WebAppInternals: !1
}, sF = {
  _isWindows: !1,
  _rand: !1,
  BulkWriteResult: !1,
  cat: !1,
  cd: !1,
  connect: !1,
  db: !1,
  getHostName: !1,
  getMemInfo: !1,
  hostname: !1,
  ISODate: !1,
  listFiles: !1,
  load: !1,
  ls: !1,
  md5sumFile: !1,
  mkdir: !1,
  Mongo: !1,
  NumberInt: !1,
  NumberLong: !1,
  ObjectId: !1,
  PlanCache: !1,
  print: !1,
  printjson: !1,
  pwd: !1,
  quit: !1,
  removeFile: !1,
  rs: !1,
  sh: !1,
  UUID: !1,
  version: !1,
  WriteResult: !1
}, aF = {
  $: !1,
  Application: !1,
  Automation: !1,
  console: !1,
  delay: !1,
  Library: !1,
  ObjC: !1,
  ObjectSpecifier: !1,
  Path: !1,
  Progress: !1,
  Ref: !1
}, iF = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  clearInterval: !1,
  clearTimeout: !1,
  Client: !1,
  clients: !1,
  Clients: !1,
  close: !0,
  console: !1,
  CustomEvent: !1,
  ErrorEvent: !1,
  Event: !1,
  ExtendableEvent: !1,
  ExtendableMessageEvent: !1,
  fetch: !1,
  FetchEvent: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !1,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onfetch: !0,
  oninstall: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onmessageerror: !0,
  onnotificationclick: !0,
  onnotificationclose: !0,
  onoffline: !0,
  ononline: !0,
  onpush: !0,
  onpushsubscriptionchange: !0,
  onrejectionhandled: !0,
  onsync: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  registration: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerGlobalScope: !1,
  ServiceWorkerMessageEvent: !1,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  skipWaiting: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  WindowClient: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, oF = {
  advanceClock: !1,
  atom: !1,
  fakeClearInterval: !1,
  fakeClearTimeout: !1,
  fakeSetInterval: !1,
  fakeSetTimeout: !1,
  resetTimeouts: !1,
  waitsForPromise: !1
}, lF = {
  andThen: !1,
  click: !1,
  currentPath: !1,
  currentRouteName: !1,
  currentURL: !1,
  fillIn: !1,
  find: !1,
  findAll: !1,
  findWithAssert: !1,
  keyEvent: !1,
  pauseTest: !1,
  resumeTest: !1,
  triggerEvent: !1,
  visit: !1,
  wait: !1
}, uF = {
  $: !1,
  $$: !1,
  browser: !1,
  by: !1,
  By: !1,
  DartObject: !1,
  element: !1,
  protractor: !1
}, cF = {
  browser: !1,
  chrome: !1,
  opr: !1
}, pF = {
  cloneInto: !1,
  createObjectIn: !1,
  exportFunction: !1,
  GM: !1,
  GM_addElement: !1,
  GM_addStyle: !1,
  GM_addValueChangeListener: !1,
  GM_deleteValue: !1,
  GM_download: !1,
  GM_getResourceText: !1,
  GM_getResourceURL: !1,
  GM_getTab: !1,
  GM_getTabs: !1,
  GM_getValue: !1,
  GM_info: !1,
  GM_listValues: !1,
  GM_log: !1,
  GM_notification: !1,
  GM_openInTab: !1,
  GM_registerMenuCommand: !1,
  GM_removeValueChangeListener: !1,
  GM_saveTab: !1,
  GM_setClipboard: !1,
  GM_setValue: !1,
  GM_unregisterMenuCommand: !1,
  GM_xmlhttpRequest: !1,
  unsafeWindow: !1
}, fF = {
  $: !1,
  $_: !1,
  $$: !1,
  $0: !1,
  $1: !1,
  $2: !1,
  $3: !1,
  $4: !1,
  $x: !1,
  chrome: !1,
  clear: !1,
  copy: !1,
  debug: !1,
  dir: !1,
  dirxml: !1,
  getEventListeners: !1,
  inspect: !1,
  keys: !1,
  monitor: !1,
  monitorEvents: !1,
  profile: !1,
  profileEnd: !1,
  queryObjects: !1,
  table: !1,
  undebug: !1,
  unmonitor: !1,
  unmonitorEvents: !1,
  values: !1
}, hF = {
  builtin: _T,
  es5: BT,
  es2015: OT,
  es2017: LT,
  es2020: RT,
  es2021: NT,
  browser: jT,
  worker: MT,
  node: $T,
  nodeBuiltin: VT,
  commonjs: UT,
  amd: qT,
  mocha: WT,
  jasmine: zT,
  jest: GT,
  qunit: HT,
  phantomjs: KT,
  couch: JT,
  rhino: XT,
  nashorn: QT,
  wsh: YT,
  jquery: ZT,
  yui: eF,
  shelljs: tF,
  prototypejs: rF,
  meteor: nF,
  mongo: sF,
  applescript: aF,
  serviceworker: iF,
  atomtest: oF,
  embertest: lF,
  protractor: uF,
  "shared-node-browser": {
    AbortController: !1,
    AbortSignal: !1,
    atob: !1,
    btoa: !1,
    clearInterval: !1,
    clearTimeout: !1,
    console: !1,
    DOMException: !1,
    Event: !1,
    EventTarget: !1,
    fetch: !1,
    Intl: !1,
    MessageChannel: !1,
    MessageEvent: !1,
    MessagePort: !1,
    performance: !1,
    queueMicrotask: !1,
    setInterval: !1,
    setTimeout: !1,
    structuredClone: !1,
    TextDecoder: !1,
    TextEncoder: !1,
    URL: !1,
    URLSearchParams: !1
  },
  webextensions: cF,
  greasemonkey: pF,
  devtools: fF
};
(function(t) {
  t.exports = hF;
})(gu);
const st = gu.exports;
function mF(t, e) {
  const r = {};
  for (const [s, n] of Object.entries(t))
    Object.hasOwnProperty.call(e, s) || (r[s] = n);
  return r;
}
const ms = mF(st.es2015, st.es5), to = {
  Atomics: !1,
  SharedArrayBuffer: !1
}, Vd = {
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  globalThis: !1
}, dF = {
  AggregateError: !1,
  FinalizationRegistry: !1,
  WeakRef: !1
};
var Kx = new Map(Object.entries({
  // Language
  builtin: {
    globals: st.es5
  },
  es6: {
    globals: ms,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  es2015: {
    globals: ms,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  es2017: {
    globals: { ...ms, ...to },
    parserOptions: {
      ecmaVersion: 8
    }
  },
  es2020: {
    globals: { ...ms, ...to, ...Vd },
    parserOptions: {
      ecmaVersion: 11
    }
  },
  es2021: {
    globals: { ...ms, ...to, ...Vd, ...dF },
    parserOptions: {
      ecmaVersion: 12
    }
  },
  // Platforms
  browser: {
    globals: st.browser
  },
  node: {
    globals: st.node,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: !0
      }
    }
  },
  "shared-node-browser": {
    globals: st["shared-node-browser"]
  },
  worker: {
    globals: st.worker
  },
  serviceworker: {
    globals: st.serviceworker
  },
  // Frameworks
  commonjs: {
    globals: st.commonjs,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: !0
      }
    }
  },
  amd: {
    globals: st.amd
  },
  mocha: {
    globals: st.mocha
  },
  jasmine: {
    globals: st.jasmine
  },
  jest: {
    globals: st.jest
  },
  phantomjs: {
    globals: st.phantomjs
  },
  jquery: {
    globals: st.jquery
  },
  qunit: {
    globals: st.qunit
  },
  prototypejs: {
    globals: st.prototypejs
  },
  shelljs: {
    globals: st.shelljs
  },
  meteor: {
    globals: st.meteor
  },
  mongo: {
    globals: st.mongo
  },
  protractor: {
    globals: st.protractor
  },
  applescript: {
    globals: st.applescript
  },
  nashorn: {
    globals: st.nashorn
  },
  atomtest: {
    globals: st.atomtest
  },
  embertest: {
    globals: st.embertest
  },
  webextensions: {
    globals: st.webextensions
  },
  greasemonkey: {
    globals: st.greasemonkey
  }
})), us = {}, yu = { exports: {} }, aa = { exports: {} }, ro, Ud;
function gF() {
  if (Ud)
    return ro;
  Ud = 1;
  var t = 1e3, e = t * 60, r = e * 60, s = r * 24, n = s * 7, a = s * 365.25;
  ro = function(c, f) {
    f = f || {};
    var h = typeof c;
    if (h === "string" && c.length > 0)
      return o(c);
    if (h === "number" && isFinite(c))
      return f.long ? i(c) : l(c);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(c)
    );
  };
  function o(c) {
    if (c = String(c), !(c.length > 100)) {
      var f = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        c
      );
      if (f) {
        var h = parseFloat(f[1]), p = (f[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h * a;
          case "weeks":
          case "week":
          case "w":
            return h * n;
          case "days":
          case "day":
          case "d":
            return h * s;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h * t;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h;
          default:
            return;
        }
      }
    }
  }
  function l(c) {
    var f = Math.abs(c);
    return f >= s ? Math.round(c / s) + "d" : f >= r ? Math.round(c / r) + "h" : f >= e ? Math.round(c / e) + "m" : f >= t ? Math.round(c / t) + "s" : c + "ms";
  }
  function i(c) {
    var f = Math.abs(c);
    return f >= s ? u(c, f, s, "day") : f >= r ? u(c, f, r, "hour") : f >= e ? u(c, f, e, "minute") : f >= t ? u(c, f, t, "second") : c + " ms";
  }
  function u(c, f, h, p) {
    var m = f >= h * 1.5;
    return Math.round(c / h) + " " + p + (m ? "s" : "");
  }
  return ro;
}
var no, qd;
function Jx() {
  if (qd)
    return no;
  qd = 1;
  function t(e) {
    s.debug = s, s.default = s, s.coerce = u, s.disable = o, s.enable = a, s.enabled = l, s.humanize = gF(), s.destroy = c, Object.keys(e).forEach((f) => {
      s[f] = e[f];
    }), s.names = [], s.skips = [], s.formatters = {};
    function r(f) {
      let h = 0;
      for (let p = 0; p < f.length; p++)
        h = (h << 5) - h + f.charCodeAt(p), h |= 0;
      return s.colors[Math.abs(h) % s.colors.length];
    }
    s.selectColor = r;
    function s(f) {
      let h, p = null, m, d;
      function g(...y) {
        if (!g.enabled)
          return;
        const x = g, A = Number(/* @__PURE__ */ new Date()), b = A - (h || A);
        x.diff = b, x.prev = h, x.curr = A, h = A, y[0] = s.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
        let v = 0;
        y[0] = y[0].replace(/%([a-zA-Z%])/g, (T, w) => {
          if (T === "%%")
            return "%";
          v++;
          const B = s.formatters[w];
          if (typeof B == "function") {
            const I = y[v];
            T = B.call(x, I), y.splice(v, 1), v--;
          }
          return T;
        }), s.formatArgs.call(x, y), (x.log || s.log).apply(x, y);
      }
      return g.namespace = f, g.useColors = s.useColors(), g.color = s.selectColor(f), g.extend = n, g.destroy = s.destroy, Object.defineProperty(g, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => p !== null ? p : (m !== s.namespaces && (m = s.namespaces, d = s.enabled(f)), d),
        set: (y) => {
          p = y;
        }
      }), typeof s.init == "function" && s.init(g), g;
    }
    function n(f, h) {
      const p = s(this.namespace + (typeof h > "u" ? ":" : h) + f);
      return p.log = this.log, p;
    }
    function a(f) {
      s.save(f), s.namespaces = f, s.names = [], s.skips = [];
      let h;
      const p = (typeof f == "string" ? f : "").split(/[\s,]+/), m = p.length;
      for (h = 0; h < m; h++)
        p[h] && (f = p[h].replace(/\*/g, ".*?"), f[0] === "-" ? s.skips.push(new RegExp("^" + f.slice(1) + "$")) : s.names.push(new RegExp("^" + f + "$")));
    }
    function o() {
      const f = [
        ...s.names.map(i),
        ...s.skips.map(i).map((h) => "-" + h)
      ].join(",");
      return s.enable(""), f;
    }
    function l(f) {
      if (f[f.length - 1] === "*")
        return !0;
      let h, p;
      for (h = 0, p = s.skips.length; h < p; h++)
        if (s.skips[h].test(f))
          return !1;
      for (h = 0, p = s.names.length; h < p; h++)
        if (s.names[h].test(f))
          return !0;
      return !1;
    }
    function i(f) {
      return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function u(f) {
      return f instanceof Error ? f.stack || f.message : f;
    }
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return s.enable(s.load()), s;
  }
  return no = t, no;
}
var Wd;
function yF() {
  return Wd || (Wd = 1, function(t, e) {
    e.formatArgs = s, e.save = n, e.load = a, e.useColors = r, e.storage = o(), e.destroy = (() => {
      let i = !1;
      return () => {
        i || (i = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function s(i) {
      if (i[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + i[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors)
        return;
      const u = "color: " + this.color;
      i.splice(1, 0, u, "color: inherit");
      let c = 0, f = 0;
      i[0].replace(/%[a-zA-Z%]/g, (h) => {
        h !== "%%" && (c++, h === "%c" && (f = c));
      }), i.splice(f, 0, u);
    }
    e.log = console.debug || console.log || (() => {
    });
    function n(i) {
      try {
        i ? e.storage.setItem("debug", i) : e.storage.removeItem("debug");
      } catch {
      }
    }
    function a() {
      let i;
      try {
        i = e.storage.getItem("debug");
      } catch {
      }
      return !i && typeof Ze < "u" && "env" in Ze && (i = Ze.env.DEBUG), i;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    t.exports = Jx()(e);
    const { formatters: l } = t.exports;
    l.j = function(i) {
      try {
        return JSON.stringify(i);
      } catch (u) {
        return "[UnexpectedJSONParseError]: " + u.message;
      }
    };
  }(aa, aa.exports)), aa.exports;
}
var ia = { exports: {} };
function Xx() {
  return !1;
}
function Qx() {
  throw new Error("tty.ReadStream is not implemented");
}
function Yx() {
  throw new Error("tty.ReadStream is not implemented");
}
var xF = {
  isatty: Xx,
  ReadStream: Qx,
  WriteStream: Yx
}, vF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isatty: Xx,
  ReadStream: Qx,
  WriteStream: Yx,
  default: xF
}), EF = /* @__PURE__ */ Fn(vF), Zx = /* @__PURE__ */ Fn(wC), oa;
function ev() {
  if (typeof oa > "u") {
    var t = new ArrayBuffer(2), e = new Uint8Array(t), r = new Uint16Array(t);
    if (e[0] = 1, e[1] = 2, r[0] === 258)
      oa = "BE";
    else if (r[0] === 513)
      oa = "LE";
    else
      throw new Error("unable to figure out endianess");
  }
  return oa;
}
function tv() {
  return typeof gr.location < "u" ? gr.location.hostname : "";
}
function rv() {
  return [];
}
function nv() {
  return 0;
}
function sv() {
  return Number.MAX_VALUE;
}
function av() {
  return Number.MAX_VALUE;
}
function iv() {
  return [];
}
function ov() {
  return "Browser";
}
function lv() {
  return typeof gr.navigator < "u" ? gr.navigator.appVersion : "";
}
function uv() {
  return {};
}
function cv() {
  return {};
}
function pv() {
  return "javascript";
}
function fv() {
  return "browser";
}
function xu() {
  return "/tmp";
}
var hv = xu, mv = `
`;
function dv() {
  return "$HOME";
}
var bF = {
  homedir: dv,
  EOL: mv,
  arch: pv,
  platform: fv,
  tmpdir: hv,
  tmpDir: xu,
  networkInterfaces: uv,
  getNetworkInterfaces: cv,
  release: lv,
  type: ov,
  cpus: iv,
  totalmem: av,
  freemem: sv,
  uptime: nv,
  loadavg: rv,
  hostname: tv,
  endianness: ev
}, CF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  endianness: ev,
  hostname: tv,
  loadavg: rv,
  uptime: nv,
  freemem: sv,
  totalmem: av,
  cpus: iv,
  type: ov,
  release: lv,
  networkInterfaces: uv,
  getNetworkInterfaces: cv,
  arch: pv,
  platform: fv,
  tmpDir: xu,
  tmpdir: hv,
  EOL: mv,
  homedir: dv,
  default: bF
}), SF = /* @__PURE__ */ Fn(CF), so, zd;
function AF() {
  return zd || (zd = 1, so = (t, e) => {
    e = e || Ze.argv;
    const r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", s = e.indexOf(r + t), n = e.indexOf("--");
    return s !== -1 && (n === -1 ? !0 : s < n);
  }), so;
}
var ao, Gd;
function DF() {
  if (Gd)
    return ao;
  Gd = 1;
  const t = SF, e = AF(), r = Ze.env;
  let s;
  e("no-color") || e("no-colors") || e("color=false") ? s = !1 : (e("color") || e("colors") || e("color=true") || e("color=always")) && (s = !0), "FORCE_COLOR" in r && (s = r.FORCE_COLOR.length === 0 || parseInt(r.FORCE_COLOR, 10) !== 0);
  function n(l) {
    return l === 0 ? !1 : {
      level: l,
      hasBasic: !0,
      has256: l >= 2,
      has16m: l >= 3
    };
  }
  function a(l) {
    if (s === !1)
      return 0;
    if (e("color=16m") || e("color=full") || e("color=truecolor"))
      return 3;
    if (e("color=256"))
      return 2;
    if (l && !l.isTTY && s !== !0)
      return 0;
    const i = s ? 1 : 0;
    if (Ze.platform === "win32") {
      const u = t.release().split(".");
      return Number(Ze.versions.node.split(".")[0]) >= 8 && Number(u[0]) >= 10 && Number(u[2]) >= 10586 ? Number(u[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in r)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((u) => u in r) || r.CI_NAME === "codeship" ? 1 : i;
    if ("TEAMCITY_VERSION" in r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(r.TEAMCITY_VERSION) ? 1 : 0;
    if (r.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in r) {
      const u = parseInt((r.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (r.TERM_PROGRAM) {
        case "iTerm.app":
          return u >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(r.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(r.TERM) || "COLORTERM" in r ? 1 : (r.TERM === "dumb", i);
  }
  function o(l) {
    const i = a(l);
    return n(i);
  }
  return ao = {
    supportsColor: o,
    stdout: o(Ze.stdout),
    stderr: o(Ze.stderr)
  }, ao;
}
var Hd;
function wF() {
  return Hd || (Hd = 1, function(t, e) {
    const r = EF, s = Zx;
    e.init = c, e.log = l, e.formatArgs = a, e.save = i, e.load = u, e.useColors = n, e.destroy = s.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    ), e.colors = [6, 2, 3, 4, 5, 1];
    try {
      const h = DF();
      h && (h.stderr || h).level >= 2 && (e.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ]);
    } catch {
    }
    e.inspectOpts = Object.keys(Ze.env).filter((h) => /^debug_/i.test(h)).reduce((h, p) => {
      const m = p.substring(6).toLowerCase().replace(/_([a-z])/g, (g, y) => y.toUpperCase());
      let d = Ze.env[p];
      return /^(yes|on|true|enabled)$/i.test(d) ? d = !0 : /^(no|off|false|disabled)$/i.test(d) ? d = !1 : d === "null" ? d = null : d = Number(d), h[m] = d, h;
    }, {});
    function n() {
      return "colors" in e.inspectOpts ? !!e.inspectOpts.colors : r.isatty(Ze.stderr.fd);
    }
    function a(h) {
      const { namespace: p, useColors: m } = this;
      if (m) {
        const d = this.color, g = "\x1B[3" + (d < 8 ? d : "8;5;" + d), y = `  ${g};1m${p} \x1B[0m`;
        h[0] = y + h[0].split(`
`).join(`
` + y), h.push(g + "m+" + t.exports.humanize(this.diff) + "\x1B[0m");
      } else
        h[0] = o() + p + " " + h[0];
    }
    function o() {
      return e.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function l(...h) {
      return Ze.stderr.write(s.format(...h) + `
`);
    }
    function i(h) {
      h ? Ze.env.DEBUG = h : delete Ze.env.DEBUG;
    }
    function u() {
      return Ze.env.DEBUG;
    }
    function c(h) {
      h.inspectOpts = {};
      const p = Object.keys(e.inspectOpts);
      for (let m = 0; m < p.length; m++)
        h.inspectOpts[p[m]] = e.inspectOpts[p[m]];
    }
    t.exports = Jx()(e);
    const { formatters: f } = t.exports;
    f.o = function(h) {
      return this.inspectOpts.colors = this.useColors, s.inspect(h, this.inspectOpts).split(`
`).map((p) => p.trim()).join(" ");
    }, f.O = function(h) {
      return this.inspectOpts.colors = this.useColors, s.inspect(h, this.inspectOpts);
    };
  }(ia, ia.exports)), ia.exports;
}
(function(t) {
  typeof Ze > "u" || Ze.type === "renderer" || Ze.browser === !0 || Ze.__nwjs ? t.exports = yF() : t.exports = wF();
})(yu);
var kF = gx, TF = yu.exports;
function gv(t) {
  return t && typeof t == "object" && "default" in t ? t : {
    default: t
  };
}
var ka = gv(kF), FF = gv(TF);
const PF = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u, yv = /\r\n|[\r\n\u2028\u2029]/u, IF = /^#!([^\r\n]+)/u;
function _F() {
  return new RegExp(yv.source, "gu");
}
var BF = {
  breakableTypePattern: PF,
  lineBreakPattern: yv,
  createGlobalLinebreakMatcher: _F,
  shebangPattern: IF
};
const OF = FF.default("eslint:traverser");
function Kd() {
}
function LF(t) {
  return t !== null && typeof t == "object" && typeof t.type == "string";
}
function RF(t, e) {
  let r = t[e.type];
  return r || (r = ka.default.getKeys(e), OF('Unknown node type "%s": Estimated visitor keys %j', e.type, r)), r;
}
class vu {
  constructor() {
    this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = null, this._enter = null, this._leave = null;
  }
  current() {
    return this._current;
  }
  parents() {
    return this._parents.slice(0);
  }
  break() {
    this._broken = !0;
  }
  skip() {
    this._skipped = !0;
  }
  traverse(e, r) {
    this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = r.visitorKeys || ka.default.KEYS, this._enter = r.enter || Kd, this._leave = r.leave || Kd, this._traverse(e, null);
  }
  _traverse(e, r) {
    if (LF(e)) {
      if (this._current = e, this._skipped = !1, this._enter(e, r), !this._skipped && !this._broken) {
        const s = RF(this._visitorKeys, e);
        if (s.length >= 1) {
          this._parents.push(e);
          for (let n = 0; n < s.length && !this._broken; ++n) {
            const a = e[s[n]];
            if (Array.isArray(a))
              for (let o = 0; o < a.length && !this._broken; ++o)
                this._traverse(a[o], e);
            else
              this._traverse(a, e);
          }
          this._parents.pop();
        }
      }
      this._broken || this._leave(e, r), this._current = r;
    }
  }
  static getKeys(e) {
    return ka.default.getKeys(e);
  }
  static traverse(e, r) {
    new vu().traverse(e, r);
  }
  static get DEFAULT_VISITOR_KEYS() {
    return ka.default.KEYS;
  }
}
var NF = vu;
function jF(t, e) {
  return e = {
    exports: {}
  }, t(e, e.exports), e.exports;
}
function MF(t) {
  return t && t.default || t;
}
us.astUtils = BF;
us.createCommonjsModule = jF;
us.getCjsExportFromNamespace = MF;
us.traverser = NF;
var Eu = { exports: {} };
(function(t) {
  const e = ["off", "warn", "error"], r = e.reduce((n, a, o) => (n[a] = o, n), {}), s = [0, 1, 2, "off", "warn", "error"];
  t.exports = {
    /**
     * Normalizes the severity value of a rule's configuration to a number
     * @param {(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally
     * received from the user. A valid config value is either 0, 1, 2, the string "off" (treated the same as 0),
     * the string "warn" (treated the same as 1), the string "error" (treated the same as 2), or an array
     * whose first element is one of the above values. Strings are matched case-insensitively.
     * @returns {(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.
     */
    getRuleSeverity(n) {
      const a = Array.isArray(n) ? n[0] : n;
      return a === 0 || a === 1 || a === 2 ? a : typeof a == "string" && r[a.toLowerCase()] || 0;
    },
    /**
     * Converts old-style severity settings (0, 1, 2) into new-style
     * severity settings (off, warn, error) for all rules. Assumption is that severity
     * values have already been validated as correct.
     * @param {Object} config The config object to normalize.
     * @returns {void}
     */
    normalizeToStrings(n) {
      n.rules && Object.keys(n.rules).forEach((a) => {
        const o = n.rules[a];
        typeof o == "number" ? n.rules[a] = e[o] || e[0] : Array.isArray(o) && typeof o[0] == "number" && (o[0] = e[o[0]] || e[0]);
      });
    },
    /**
     * Determines if the severity for the given rule configuration represents an error.
     * @param {int|string|Array} ruleConfig The configuration for an individual rule.
     * @returns {boolean} True if the rule represents an error, false if not.
     */
    isErrorSeverity(n) {
      return t.exports.getRuleSeverity(n) === 2;
    },
    /**
     * Checks whether a given config has valid severity or not.
     * @param {number|string|Array} ruleConfig The configuration for an individual rule.
     * @returns {boolean} `true` if the configuration has valid severity.
     */
    isValidSeverity(n) {
      let a = Array.isArray(n) ? n[0] : n;
      return typeof a == "string" && (a = a.toLowerCase()), s.indexOf(a) !== -1;
    },
    /**
     * Checks whether every rule of a given config has valid severity or not.
     * @param {Object} config The configuration for rules.
     * @returns {boolean} `true` if the configuration has valid severity.
     */
    isEverySeverityValid(n) {
      return Object.keys(n).every((a) => this.isValidSeverity(n[a]));
    },
    /**
     * Normalizes a value for a global in a config
     * @param {(boolean|string|null)} configuredValue The value given for a global in configuration or in
     * a global directive comment
     * @returns {("readable"|"writeable"|"off")} The value normalized as a string
     * @throws Error if global value is invalid
     */
    normalizeConfigGlobal(n) {
      switch (n) {
        case "off":
          return "off";
        case !0:
        case "true":
        case "writeable":
        case "writable":
          return "writable";
        case null:
        case !1:
        case "false":
        case "readable":
        case "readonly":
          return "readonly";
        default:
          throw new Error(`'${n}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
      }
    }
  };
})(Eu);
const Jd = {
  $schema: { type: "string" },
  env: { type: "object" },
  extends: { $ref: "#/definitions/stringOrStrings" },
  globals: { type: "object" },
  overrides: {
    type: "array",
    items: { $ref: "#/definitions/overrideConfig" },
    additionalItems: !1
  },
  parser: { type: ["string", "null"] },
  parserOptions: { type: "object" },
  plugins: { type: "array" },
  processor: { type: "string" },
  rules: { type: "object" },
  settings: { type: "object" },
  noInlineConfig: { type: "boolean" },
  reportUnusedDisableDirectives: { type: "boolean" },
  ecmaFeatures: { type: "object" }
  // deprecated; logs a warning when used
}, $F = {
  definitions: {
    stringOrStrings: {
      oneOf: [
        { type: "string" },
        {
          type: "array",
          items: { type: "string" },
          additionalItems: !1
        }
      ]
    },
    stringOrStringsRequired: {
      oneOf: [
        { type: "string" },
        {
          type: "array",
          items: { type: "string" },
          additionalItems: !1,
          minItems: 1
        }
      ]
    },
    // Config at top-level.
    objectConfig: {
      type: "object",
      properties: {
        root: { type: "boolean" },
        ignorePatterns: { $ref: "#/definitions/stringOrStrings" },
        ...Jd
      },
      additionalProperties: !1
    },
    // Config in `overrides`.
    overrideConfig: {
      type: "object",
      properties: {
        excludedFiles: { $ref: "#/definitions/stringOrStrings" },
        files: { $ref: "#/definitions/stringOrStringsRequired" },
        ...Jd
      },
      required: ["files"],
      additionalProperties: !1
    }
  },
  $ref: "#/definitions/objectConfig"
};
var VF = $F;
const UF = B0, qF = {
  ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
  ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
  ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
}, Xd = /* @__PURE__ */ new Set();
function WF(t, e) {
  const r = JSON.stringify({ source: t, errorCode: e });
  if (Xd.has(r))
    return;
  Xd.add(r);
  const s = UF.relative(Ze.cwd(), t), n = qF[e];
  Ze.emitWarning(
    `${n} (found in "${s}")`,
    "DeprecationWarning",
    e
  );
}
var zF = {
  emitDeprecationWarning: WF
}, hl = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(t, e) {
  (function(r, s) {
    s(e);
  })(mr, function(r) {
    function s() {
      for (var M = arguments.length, L = Array(M), V = 0; V < M; V++)
        L[V] = arguments[V];
      if (L.length > 1) {
        L[0] = L[0].slice(0, -1);
        for (var K = L.length - 1, X = 1; X < K; ++X)
          L[X] = L[X].slice(1, -1);
        return L[K] = L[K].slice(1), L.join("");
      } else
        return L[0];
    }
    function n(M) {
      return "(?:" + M + ")";
    }
    function a(M) {
      return M === void 0 ? "undefined" : M === null ? "null" : Object.prototype.toString.call(M).split(" ").pop().split("]").shift().toLowerCase();
    }
    function o(M) {
      return M.toUpperCase();
    }
    function l(M) {
      return M != null ? M instanceof Array ? M : typeof M.length != "number" || M.split || M.setInterval || M.call ? [M] : Array.prototype.slice.call(M) : [];
    }
    function i(M, L) {
      var V = M;
      if (L)
        for (var K in L)
          V[K] = L[K];
      return V;
    }
    function u(M) {
      var L = "[A-Za-z]", V = "[0-9]", K = s(V, "[A-Fa-f]"), X = n(n("%[EFef]" + K + "%" + K + K + "%" + K + K) + "|" + n("%[89A-Fa-f]" + K + "%" + K + K) + "|" + n("%" + K + K)), de = "[\\:\\/\\?\\#\\[\\]\\@]", we = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", Me = s(de, we), Ne = M ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", tt = M ? "[\\uE000-\\uF8FF]" : "[]", je = s(L, V, "[\\-\\.\\_\\~]", Ne);
      n(L + s(L, V, "[\\+\\-\\.]") + "*"), n(n(X + "|" + s(je, we, "[\\:]")) + "*");
      var fe = n(n("25[0-5]") + "|" + n("2[0-4]" + V) + "|" + n("1" + V + V) + "|" + n("0?[1-9]" + V) + "|0?0?" + V), De = n(fe + "\\." + fe + "\\." + fe + "\\." + fe), ve = n(K + "{1,4}"), ue = n(n(ve + "\\:" + ve) + "|" + De), Pe = n(n(ve + "\\:") + "{6}" + ue), Oe = n("\\:\\:" + n(ve + "\\:") + "{5}" + ue), at = n(n(ve) + "?\\:\\:" + n(ve + "\\:") + "{4}" + ue), ut = n(n(n(ve + "\\:") + "{0,1}" + ve) + "?\\:\\:" + n(ve + "\\:") + "{3}" + ue), dt = n(n(n(ve + "\\:") + "{0,2}" + ve) + "?\\:\\:" + n(ve + "\\:") + "{2}" + ue), Dt = n(n(n(ve + "\\:") + "{0,3}" + ve) + "?\\:\\:" + ve + "\\:" + ue), zt = n(n(n(ve + "\\:") + "{0,4}" + ve) + "?\\:\\:" + ue), kt = n(n(n(ve + "\\:") + "{0,5}" + ve) + "?\\:\\:" + ve), nr = n(n(n(ve + "\\:") + "{0,6}" + ve) + "?\\:\\:"), Ir = n([Pe, Oe, at, ut, dt, Dt, zt, kt, nr].join("|")), sr = n(n(je + "|" + X) + "+");
      n("[vV]" + K + "+\\." + s(je, we, "[\\:]") + "+"), n(n(X + "|" + s(je, we)) + "*");
      var fn = n(X + "|" + s(je, we, "[\\:\\@]"));
      return n(n(X + "|" + s(je, we, "[\\@]")) + "+"), n(n(fn + "|" + s("[\\/\\?]", tt)) + "*"), {
        NOT_SCHEME: new RegExp(s("[^]", L, V, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(s("[^\\%\\:]", je, we), "g"),
        NOT_HOST: new RegExp(s("[^\\%\\[\\]\\:]", je, we), "g"),
        NOT_PATH: new RegExp(s("[^\\%\\/\\:\\@]", je, we), "g"),
        NOT_PATH_NOSCHEME: new RegExp(s("[^\\%\\/\\@]", je, we), "g"),
        NOT_QUERY: new RegExp(s("[^\\%]", je, we, "[\\:\\@\\/\\?]", tt), "g"),
        NOT_FRAGMENT: new RegExp(s("[^\\%]", je, we, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(s("[^]", je, we), "g"),
        UNRESERVED: new RegExp(je, "g"),
        OTHER_CHARS: new RegExp(s("[^\\%]", je, Me), "g"),
        PCT_ENCODED: new RegExp(X, "g"),
        IPV4ADDRESS: new RegExp("^(" + De + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Ir + ")" + n(n("\\%25|\\%(?!" + K + "{2})") + "(" + sr + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var c = u(!1), f = u(!0), h = function() {
      function M(L, V) {
        var K = [], X = !0, de = !1, we = void 0;
        try {
          for (var Me = L[Symbol.iterator](), Ne; !(X = (Ne = Me.next()).done) && (K.push(Ne.value), !(V && K.length === V)); X = !0)
            ;
        } catch (tt) {
          de = !0, we = tt;
        } finally {
          try {
            !X && Me.return && Me.return();
          } finally {
            if (de)
              throw we;
          }
        }
        return K;
      }
      return function(L, V) {
        if (Array.isArray(L))
          return L;
        if (Symbol.iterator in Object(L))
          return M(L, V);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), p = function(M) {
      if (Array.isArray(M)) {
        for (var L = 0, V = Array(M.length); L < M.length; L++)
          V[L] = M[L];
        return V;
      } else
        return Array.from(M);
    }, m = 2147483647, d = 36, g = 1, y = 26, x = 38, A = 700, b = 72, v = 128, C = "-", T = /^xn--/, w = /[^\0-\x7E]/, B = /[\x2E\u3002\uFF0E\uFF61]/g, I = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, _ = d - g, S = Math.floor, F = String.fromCharCode;
    function N(M) {
      throw new RangeError(I[M]);
    }
    function k(M, L) {
      for (var V = [], K = M.length; K--; )
        V[K] = L(M[K]);
      return V;
    }
    function j(M, L) {
      var V = M.split("@"), K = "";
      V.length > 1 && (K = V[0] + "@", M = V[1]), M = M.replace(B, ".");
      var X = M.split("."), de = k(X, L).join(".");
      return K + de;
    }
    function O(M) {
      for (var L = [], V = 0, K = M.length; V < K; ) {
        var X = M.charCodeAt(V++);
        if (X >= 55296 && X <= 56319 && V < K) {
          var de = M.charCodeAt(V++);
          (de & 64512) == 56320 ? L.push(((X & 1023) << 10) + (de & 1023) + 65536) : (L.push(X), V--);
        } else
          L.push(X);
      }
      return L;
    }
    var z = function(L) {
      return String.fromCodePoint.apply(String, p(L));
    }, te = function(L) {
      return L - 48 < 10 ? L - 22 : L - 65 < 26 ? L - 65 : L - 97 < 26 ? L - 97 : d;
    }, se = function(L, V) {
      return L + 22 + 75 * (L < 26) - ((V != 0) << 5);
    }, ye = function(L, V, K) {
      var X = 0;
      for (
        L = K ? S(L / A) : L >> 1, L += S(L / V);
        /* no initialization */
        L > _ * y >> 1;
        X += d
      )
        L = S(L / _);
      return S(X + (_ + 1) * L / (L + x));
    }, Se = function(L) {
      var V = [], K = L.length, X = 0, de = v, we = b, Me = L.lastIndexOf(C);
      Me < 0 && (Me = 0);
      for (var Ne = 0; Ne < Me; ++Ne)
        L.charCodeAt(Ne) >= 128 && N("not-basic"), V.push(L.charCodeAt(Ne));
      for (var tt = Me > 0 ? Me + 1 : 0; tt < K; ) {
        for (
          var je = X, fe = 1, De = d;
          ;
          /* no condition */
          De += d
        ) {
          tt >= K && N("invalid-input");
          var ve = te(L.charCodeAt(tt++));
          (ve >= d || ve > S((m - X) / fe)) && N("overflow"), X += ve * fe;
          var ue = De <= we ? g : De >= we + y ? y : De - we;
          if (ve < ue)
            break;
          var Pe = d - ue;
          fe > S(m / Pe) && N("overflow"), fe *= Pe;
        }
        var Oe = V.length + 1;
        we = ye(X - je, Oe, je == 0), S(X / Oe) > m - de && N("overflow"), de += S(X / Oe), X %= Oe, V.splice(X++, 0, de);
      }
      return String.fromCodePoint.apply(String, V);
    }, xe = function(L) {
      var V = [];
      L = O(L);
      var K = L.length, X = v, de = 0, we = b, Me = !0, Ne = !1, tt = void 0;
      try {
        for (var je = L[Symbol.iterator](), fe; !(Me = (fe = je.next()).done); Me = !0) {
          var De = fe.value;
          De < 128 && V.push(F(De));
        }
      } catch (hn) {
        Ne = !0, tt = hn;
      } finally {
        try {
          !Me && je.return && je.return();
        } finally {
          if (Ne)
            throw tt;
        }
      }
      var ve = V.length, ue = ve;
      for (ve && V.push(C); ue < K; ) {
        var Pe = m, Oe = !0, at = !1, ut = void 0;
        try {
          for (var dt = L[Symbol.iterator](), Dt; !(Oe = (Dt = dt.next()).done); Oe = !0) {
            var zt = Dt.value;
            zt >= X && zt < Pe && (Pe = zt);
          }
        } catch (hn) {
          at = !0, ut = hn;
        } finally {
          try {
            !Oe && dt.return && dt.return();
          } finally {
            if (at)
              throw ut;
          }
        }
        var kt = ue + 1;
        Pe - X > S((m - de) / kt) && N("overflow"), de += (Pe - X) * kt, X = Pe;
        var nr = !0, Ir = !1, sr = void 0;
        try {
          for (var fn = L[Symbol.iterator](), Ys; !(nr = (Ys = fn.next()).done); nr = !0) {
            var Zs = Ys.value;
            if (Zs < X && ++de > m && N("overflow"), Zs == X) {
              for (
                var Bn = de, On = d;
                ;
                /* no condition */
                On += d
              ) {
                var Ln = On <= we ? g : On >= we + y ? y : On - we;
                if (Bn < Ln)
                  break;
                var ea = Bn - Ln, ta = d - Ln;
                V.push(F(se(Ln + ea % ta, 0))), Bn = S(ea / ta);
              }
              V.push(F(se(Bn, 0))), we = ye(de, kt, ue == ve), de = 0, ++ue;
            }
          }
        } catch (hn) {
          Ir = !0, sr = hn;
        } finally {
          try {
            !nr && fn.return && fn.return();
          } finally {
            if (Ir)
              throw sr;
          }
        }
        ++de, ++X;
      }
      return V.join("");
    }, Ae = function(L) {
      return j(L, function(V) {
        return T.test(V) ? Se(V.slice(4).toLowerCase()) : V;
      });
    }, _e = function(L) {
      return j(L, function(V) {
        return w.test(V) ? "xn--" + xe(V) : V;
      });
    }, H = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: O,
        encode: z
      },
      decode: Se,
      encode: xe,
      toASCII: _e,
      toUnicode: Ae
    }, Q = {};
    function ge(M) {
      var L = M.charCodeAt(0), V = void 0;
      return L < 16 ? V = "%0" + L.toString(16).toUpperCase() : L < 128 ? V = "%" + L.toString(16).toUpperCase() : L < 2048 ? V = "%" + (L >> 6 | 192).toString(16).toUpperCase() + "%" + (L & 63 | 128).toString(16).toUpperCase() : V = "%" + (L >> 12 | 224).toString(16).toUpperCase() + "%" + (L >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (L & 63 | 128).toString(16).toUpperCase(), V;
    }
    function ae(M) {
      for (var L = "", V = 0, K = M.length; V < K; ) {
        var X = parseInt(M.substr(V + 1, 2), 16);
        if (X < 128)
          L += String.fromCharCode(X), V += 3;
        else if (X >= 194 && X < 224) {
          if (K - V >= 6) {
            var de = parseInt(M.substr(V + 4, 2), 16);
            L += String.fromCharCode((X & 31) << 6 | de & 63);
          } else
            L += M.substr(V, 6);
          V += 6;
        } else if (X >= 224) {
          if (K - V >= 9) {
            var we = parseInt(M.substr(V + 4, 2), 16), Me = parseInt(M.substr(V + 7, 2), 16);
            L += String.fromCharCode((X & 15) << 12 | (we & 63) << 6 | Me & 63);
          } else
            L += M.substr(V, 9);
          V += 9;
        } else
          L += M.substr(V, 3), V += 3;
      }
      return L;
    }
    function ee(M, L) {
      function V(K) {
        var X = ae(K);
        return X.match(L.UNRESERVED) ? X : K;
      }
      return M.scheme && (M.scheme = String(M.scheme).replace(L.PCT_ENCODED, V).toLowerCase().replace(L.NOT_SCHEME, "")), M.userinfo !== void 0 && (M.userinfo = String(M.userinfo).replace(L.PCT_ENCODED, V).replace(L.NOT_USERINFO, ge).replace(L.PCT_ENCODED, o)), M.host !== void 0 && (M.host = String(M.host).replace(L.PCT_ENCODED, V).toLowerCase().replace(L.NOT_HOST, ge).replace(L.PCT_ENCODED, o)), M.path !== void 0 && (M.path = String(M.path).replace(L.PCT_ENCODED, V).replace(M.scheme ? L.NOT_PATH : L.NOT_PATH_NOSCHEME, ge).replace(L.PCT_ENCODED, o)), M.query !== void 0 && (M.query = String(M.query).replace(L.PCT_ENCODED, V).replace(L.NOT_QUERY, ge).replace(L.PCT_ENCODED, o)), M.fragment !== void 0 && (M.fragment = String(M.fragment).replace(L.PCT_ENCODED, V).replace(L.NOT_FRAGMENT, ge).replace(L.PCT_ENCODED, o)), M;
    }
    function he(M) {
      return M.replace(/^0*(.*)/, "$1") || "0";
    }
    function R(M, L) {
      var V = M.match(L.IPV4ADDRESS) || [], K = h(V, 2), X = K[1];
      return X ? X.split(".").map(he).join(".") : M;
    }
    function D(M, L) {
      var V = M.match(L.IPV6ADDRESS) || [], K = h(V, 3), X = K[1], de = K[2];
      if (X) {
        for (var we = X.toLowerCase().split("::").reverse(), Me = h(we, 2), Ne = Me[0], tt = Me[1], je = tt ? tt.split(":").map(he) : [], fe = Ne.split(":").map(he), De = L.IPV4ADDRESS.test(fe[fe.length - 1]), ve = De ? 7 : 8, ue = fe.length - ve, Pe = Array(ve), Oe = 0; Oe < ve; ++Oe)
          Pe[Oe] = je[Oe] || fe[ue + Oe] || "";
        De && (Pe[ve - 1] = R(Pe[ve - 1], L));
        var at = Pe.reduce(function(kt, nr, Ir) {
          if (!nr || nr === "0") {
            var sr = kt[kt.length - 1];
            sr && sr.index + sr.length === Ir ? sr.length++ : kt.push({ index: Ir, length: 1 });
          }
          return kt;
        }, []), ut = at.sort(function(kt, nr) {
          return nr.length - kt.length;
        })[0], dt = void 0;
        if (ut && ut.length > 1) {
          var Dt = Pe.slice(0, ut.index), zt = Pe.slice(ut.index + ut.length);
          dt = Dt.join(":") + "::" + zt.join(":");
        } else
          dt = Pe.join(":");
        return de && (dt += "%" + de), dt;
      } else
        return M;
    }
    var U = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, ne = "".match(/(){0}/)[1] === void 0;
    function pe(M) {
      var L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, V = {}, K = L.iri !== !1 ? f : c;
      L.reference === "suffix" && (M = (L.scheme ? L.scheme + ":" : "") + "//" + M);
      var X = M.match(U);
      if (X) {
        ne ? (V.scheme = X[1], V.userinfo = X[3], V.host = X[4], V.port = parseInt(X[5], 10), V.path = X[6] || "", V.query = X[7], V.fragment = X[8], isNaN(V.port) && (V.port = X[5])) : (V.scheme = X[1] || void 0, V.userinfo = M.indexOf("@") !== -1 ? X[3] : void 0, V.host = M.indexOf("//") !== -1 ? X[4] : void 0, V.port = parseInt(X[5], 10), V.path = X[6] || "", V.query = M.indexOf("?") !== -1 ? X[7] : void 0, V.fragment = M.indexOf("#") !== -1 ? X[8] : void 0, isNaN(V.port) && (V.port = M.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? X[4] : void 0)), V.host && (V.host = D(R(V.host, K), K)), V.scheme === void 0 && V.userinfo === void 0 && V.host === void 0 && V.port === void 0 && !V.path && V.query === void 0 ? V.reference = "same-document" : V.scheme === void 0 ? V.reference = "relative" : V.fragment === void 0 ? V.reference = "absolute" : V.reference = "uri", L.reference && L.reference !== "suffix" && L.reference !== V.reference && (V.error = V.error || "URI is not a " + L.reference + " reference.");
        var de = Q[(L.scheme || V.scheme || "").toLowerCase()];
        if (!L.unicodeSupport && (!de || !de.unicodeSupport)) {
          if (V.host && (L.domainHost || de && de.domainHost))
            try {
              V.host = H.toASCII(V.host.replace(K.PCT_ENCODED, ae).toLowerCase());
            } catch (we) {
              V.error = V.error || "Host's domain name can not be converted to ASCII via punycode: " + we;
            }
          ee(V, c);
        } else
          ee(V, K);
        de && de.parse && de.parse(V, L);
      } else
        V.error = V.error || "URI can not be parsed.";
      return V;
    }
    function Ee(M, L) {
      var V = L.iri !== !1 ? f : c, K = [];
      return M.userinfo !== void 0 && (K.push(M.userinfo), K.push("@")), M.host !== void 0 && K.push(D(R(String(M.host), V), V).replace(V.IPV6ADDRESS, function(X, de, we) {
        return "[" + de + (we ? "%25" + we : "") + "]";
      })), (typeof M.port == "number" || typeof M.port == "string") && (K.push(":"), K.push(String(M.port))), K.length ? K.join("") : void 0;
    }
    var Re = /^\.\.?\//, We = /^\/\.(\/|$)/, wt = /^\/\.\.(\/|$)/, Lt = /^\/?(?:.|\n)*?(?=\/|$)/;
    function et(M) {
      for (var L = []; M.length; )
        if (M.match(Re))
          M = M.replace(Re, "");
        else if (M.match(We))
          M = M.replace(We, "/");
        else if (M.match(wt))
          M = M.replace(wt, "/"), L.pop();
        else if (M === "." || M === "..")
          M = "";
        else {
          var V = M.match(Lt);
          if (V) {
            var K = V[0];
            M = M.slice(K.length), L.push(K);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return L.join("");
    }
    function Ge(M) {
      var L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, V = L.iri ? f : c, K = [], X = Q[(L.scheme || M.scheme || "").toLowerCase()];
      if (X && X.serialize && X.serialize(M, L), M.host && !V.IPV6ADDRESS.test(M.host)) {
        if (L.domainHost || X && X.domainHost)
          try {
            M.host = L.iri ? H.toUnicode(M.host) : H.toASCII(M.host.replace(V.PCT_ENCODED, ae).toLowerCase());
          } catch (Me) {
            M.error = M.error || "Host's domain name can not be converted to " + (L.iri ? "Unicode" : "ASCII") + " via punycode: " + Me;
          }
      }
      ee(M, V), L.reference !== "suffix" && M.scheme && (K.push(M.scheme), K.push(":"));
      var de = Ee(M, L);
      if (de !== void 0 && (L.reference !== "suffix" && K.push("//"), K.push(de), M.path && M.path.charAt(0) !== "/" && K.push("/")), M.path !== void 0) {
        var we = M.path;
        !L.absolutePath && (!X || !X.absolutePath) && (we = et(we)), de === void 0 && (we = we.replace(/^\/\//, "/%2F")), K.push(we);
      }
      return M.query !== void 0 && (K.push("?"), K.push(M.query)), M.fragment !== void 0 && (K.push("#"), K.push(M.fragment)), K.join("");
    }
    function mt(M, L) {
      var V = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, K = arguments[3], X = {};
      return K || (M = pe(Ge(M, V), V), L = pe(Ge(L, V), V)), V = V || {}, !V.tolerant && L.scheme ? (X.scheme = L.scheme, X.userinfo = L.userinfo, X.host = L.host, X.port = L.port, X.path = et(L.path || ""), X.query = L.query) : (L.userinfo !== void 0 || L.host !== void 0 || L.port !== void 0 ? (X.userinfo = L.userinfo, X.host = L.host, X.port = L.port, X.path = et(L.path || ""), X.query = L.query) : (L.path ? (L.path.charAt(0) === "/" ? X.path = et(L.path) : ((M.userinfo !== void 0 || M.host !== void 0 || M.port !== void 0) && !M.path ? X.path = "/" + L.path : M.path ? X.path = M.path.slice(0, M.path.lastIndexOf("/") + 1) + L.path : X.path = L.path, X.path = et(X.path)), X.query = L.query) : (X.path = M.path, L.query !== void 0 ? X.query = L.query : X.query = M.query), X.userinfo = M.userinfo, X.host = M.host, X.port = M.port), X.scheme = M.scheme), X.fragment = L.fragment, X;
    }
    function tr(M, L, V) {
      var K = i({ scheme: "null" }, V);
      return Ge(mt(pe(M, K), pe(L, K), K, !0), K);
    }
    function vr(M, L) {
      return typeof M == "string" ? M = Ge(pe(M, L), L) : a(M) === "object" && (M = pe(Ge(M, L), L)), M;
    }
    function Er(M, L, V) {
      return typeof M == "string" ? M = Ge(pe(M, V), V) : a(M) === "object" && (M = Ge(M, V)), typeof L == "string" ? L = Ge(pe(L, V), V) : a(L) === "object" && (L = Ge(L, V)), M === L;
    }
    function hr(M, L) {
      return M && M.toString().replace(!L || !L.iri ? c.ESCAPE : f.ESCAPE, ge);
    }
    function P(M, L) {
      return M && M.toString().replace(!L || !L.iri ? c.PCT_ENCODED : f.PCT_ENCODED, ae);
    }
    var It = {
      scheme: "http",
      domainHost: !0,
      parse: function(L, V) {
        return L.host || (L.error = L.error || "HTTP URIs must have a host."), L;
      },
      serialize: function(L, V) {
        var K = String(L.scheme).toLowerCase() === "https";
        return (L.port === (K ? 443 : 80) || L.port === "") && (L.port = void 0), L.path || (L.path = "/"), L;
      }
    }, St = {
      scheme: "https",
      domainHost: It.domainHost,
      parse: It.parse,
      serialize: It.serialize
    };
    function rr(M) {
      return typeof M.secure == "boolean" ? M.secure : String(M.scheme).toLowerCase() === "wss";
    }
    var Te = {
      scheme: "ws",
      domainHost: !0,
      parse: function(L, V) {
        var K = L;
        return K.secure = rr(K), K.resourceName = (K.path || "/") + (K.query ? "?" + K.query : ""), K.path = void 0, K.query = void 0, K;
      },
      serialize: function(L, V) {
        if ((L.port === (rr(L) ? 443 : 80) || L.port === "") && (L.port = void 0), typeof L.secure == "boolean" && (L.scheme = L.secure ? "wss" : "ws", L.secure = void 0), L.resourceName) {
          var K = L.resourceName.split("?"), X = h(K, 2), de = X[0], we = X[1];
          L.path = de && de !== "/" ? de : void 0, L.query = we, L.resourceName = void 0;
        }
        return L.fragment = void 0, L;
      }
    }, qe = {
      scheme: "wss",
      domainHost: Te.domainHost,
      parse: Te.parse,
      serialize: Te.serialize
    }, Be = {}, At = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", bt = "[0-9A-Fa-f]", Ce = n(n("%[EFef]" + bt + "%" + bt + bt + "%" + bt + bt) + "|" + n("%[89A-Fa-f]" + bt + "%" + bt + bt) + "|" + n("%" + bt + bt)), Z = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", W = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", G = s(W, '[\\"\\\\]'), J = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", le = new RegExp(At, "g"), ce = new RegExp(Ce, "g"), Fe = new RegExp(s("[^]", Z, "[\\.]", '[\\"]', G), "g"), Ve = new RegExp(s("[^]", At, J), "g"), Ye = Ve;
    function lt(M) {
      var L = ae(M);
      return L.match(le) ? L : M;
    }
    var xt = {
      scheme: "mailto",
      parse: function(L, V) {
        var K = L, X = K.to = K.path ? K.path.split(",") : [];
        if (K.path = void 0, K.query) {
          for (var de = !1, we = {}, Me = K.query.split("&"), Ne = 0, tt = Me.length; Ne < tt; ++Ne) {
            var je = Me[Ne].split("=");
            switch (je[0]) {
              case "to":
                for (var fe = je[1].split(","), De = 0, ve = fe.length; De < ve; ++De)
                  X.push(fe[De]);
                break;
              case "subject":
                K.subject = P(je[1], V);
                break;
              case "body":
                K.body = P(je[1], V);
                break;
              default:
                de = !0, we[P(je[0], V)] = P(je[1], V);
                break;
            }
          }
          de && (K.headers = we);
        }
        K.query = void 0;
        for (var ue = 0, Pe = X.length; ue < Pe; ++ue) {
          var Oe = X[ue].split("@");
          if (Oe[0] = P(Oe[0]), V.unicodeSupport)
            Oe[1] = P(Oe[1], V).toLowerCase();
          else
            try {
              Oe[1] = H.toASCII(P(Oe[1], V).toLowerCase());
            } catch (at) {
              K.error = K.error || "Email address's domain name can not be converted to ASCII via punycode: " + at;
            }
          X[ue] = Oe.join("@");
        }
        return K;
      },
      serialize: function(L, V) {
        var K = L, X = l(L.to);
        if (X) {
          for (var de = 0, we = X.length; de < we; ++de) {
            var Me = String(X[de]), Ne = Me.lastIndexOf("@"), tt = Me.slice(0, Ne).replace(ce, lt).replace(ce, o).replace(Fe, ge), je = Me.slice(Ne + 1);
            try {
              je = V.iri ? H.toUnicode(je) : H.toASCII(P(je, V).toLowerCase());
            } catch (ue) {
              K.error = K.error || "Email address's domain name can not be converted to " + (V.iri ? "Unicode" : "ASCII") + " via punycode: " + ue;
            }
            X[de] = tt + "@" + je;
          }
          K.path = X.join(",");
        }
        var fe = L.headers = L.headers || {};
        L.subject && (fe.subject = L.subject), L.body && (fe.body = L.body);
        var De = [];
        for (var ve in fe)
          fe[ve] !== Be[ve] && De.push(ve.replace(ce, lt).replace(ce, o).replace(Ve, ge) + "=" + fe[ve].replace(ce, lt).replace(ce, o).replace(Ye, ge));
        return De.length && (K.query = De.join("&")), K;
      }
    }, oe = /^([^\:]+)\:(.*)/, be = {
      scheme: "urn",
      parse: function(L, V) {
        var K = L.path && L.path.match(oe), X = L;
        if (K) {
          var de = V.scheme || X.scheme || "urn", we = K[1].toLowerCase(), Me = K[2], Ne = de + ":" + (V.nid || we), tt = Q[Ne];
          X.nid = we, X.nss = Me, X.path = void 0, tt && (X = tt.parse(X, V));
        } else
          X.error = X.error || "URN can not be parsed.";
        return X;
      },
      serialize: function(L, V) {
        var K = V.scheme || L.scheme || "urn", X = L.nid, de = K + ":" + (V.nid || X), we = Q[de];
        we && (L = we.serialize(L, V));
        var Me = L, Ne = L.nss;
        return Me.path = (X || V.nid) + ":" + Ne, Me;
      }
    }, ke = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, re = {
      scheme: "urn:uuid",
      parse: function(L, V) {
        var K = L;
        return K.uuid = K.nss, K.nss = void 0, !V.tolerant && (!K.uuid || !K.uuid.match(ke)) && (K.error = K.error || "UUID is not valid."), K;
      },
      serialize: function(L, V) {
        var K = L;
        return K.nss = (L.uuid || "").toLowerCase(), K;
      }
    };
    Q[It.scheme] = It, Q[St.scheme] = St, Q[Te.scheme] = Te, Q[qe.scheme] = qe, Q[xt.scheme] = xt, Q[be.scheme] = be, Q[re.scheme] = re, r.SCHEMES = Q, r.pctEncChar = ge, r.pctDecChars = ae, r.parse = pe, r.removeDotSegments = et, r.serialize = Ge, r.resolveComponents = mt, r.resolve = tr, r.normalize = vr, r.equal = Er, r.escapeComponent = hr, r.unescapeComponent = P, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(hl, hl.exports);
var bu = function t(e, r) {
  if (e === r)
    return !0;
  if (e && r && typeof e == "object" && typeof r == "object") {
    if (e.constructor !== r.constructor)
      return !1;
    var s, n, a;
    if (Array.isArray(e)) {
      if (s = e.length, s != r.length)
        return !1;
      for (n = s; n-- !== 0; )
        if (!t(e[n], r[n]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === r.source && e.flags === r.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === r.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === r.toString();
    if (a = Object.keys(e), s = a.length, s !== Object.keys(r).length)
      return !1;
    for (n = s; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, a[n]))
        return !1;
    for (n = s; n-- !== 0; ) {
      var o = a[n];
      if (!t(e[o], r[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && r !== r;
}, GF = function(e) {
  for (var r = 0, s = e.length, n = 0, a; n < s; )
    r++, a = e.charCodeAt(n++), a >= 55296 && a <= 56319 && n < s && (a = e.charCodeAt(n), (a & 64512) == 56320 && n++);
  return r;
}, cs = {
  copy: HF,
  checkDataType: ml,
  checkDataTypes: KF,
  coerceToTypes: JF,
  toHash: Cu,
  getProperty: Su,
  escapeQuotes: Au,
  equal: bu,
  ucs2length: GF,
  varOccurences: YF,
  varReplace: ZF,
  schemaHasRules: eP,
  schemaHasRulesExcept: tP,
  schemaUnknownRules: rP,
  toQuotedString: dl,
  getPathExpr: nP,
  getPath: sP,
  getData: oP,
  unescapeFragment: lP,
  unescapeJsonPointer: wu,
  escapeFragment: uP,
  escapeJsonPointer: Du
};
function HF(t, e) {
  e = e || {};
  for (var r in t)
    e[r] = t[r];
  return e;
}
function ml(t, e, r, s) {
  var n = s ? " !== " : " === ", a = s ? " || " : " && ", o = s ? "!" : "", l = s ? "" : "!";
  switch (t) {
    case "null":
      return e + n + "null";
    case "array":
      return o + "Array.isArray(" + e + ")";
    case "object":
      return "(" + o + e + a + "typeof " + e + n + '"object"' + a + l + "Array.isArray(" + e + "))";
    case "integer":
      return "(typeof " + e + n + '"number"' + a + l + "(" + e + " % 1)" + a + e + n + e + (r ? a + o + "isFinite(" + e + ")" : "") + ")";
    case "number":
      return "(typeof " + e + n + '"' + t + '"' + (r ? a + o + "isFinite(" + e + ")" : "") + ")";
    default:
      return "typeof " + e + n + '"' + t + '"';
  }
}
function KF(t, e, r) {
  switch (t.length) {
    case 1:
      return ml(t[0], e, r, !0);
    default:
      var s = "", n = Cu(t);
      n.array && n.object && (s = n.null ? "(" : "(!" + e + " || ", s += "typeof " + e + ' !== "object")', delete n.null, delete n.array, delete n.object), n.number && delete n.integer;
      for (var a in n)
        s += (s ? " && " : "") + ml(a, e, r, !0);
      return s;
  }
}
var Qd = Cu(["string", "number", "integer", "boolean", "null"]);
function JF(t, e) {
  if (Array.isArray(e)) {
    for (var r = [], s = 0; s < e.length; s++) {
      var n = e[s];
      (Qd[n] || t === "array" && n === "array") && (r[r.length] = n);
    }
    if (r.length)
      return r;
  } else {
    if (Qd[e])
      return [e];
    if (t === "array" && e === "array")
      return ["array"];
  }
}
function Cu(t) {
  for (var e = {}, r = 0; r < t.length; r++)
    e[t[r]] = !0;
  return e;
}
var XF = /^[a-z$_][a-z$_0-9]*$/i, QF = /'|\\/g;
function Su(t) {
  return typeof t == "number" ? "[" + t + "]" : XF.test(t) ? "." + t : "['" + Au(t) + "']";
}
function Au(t) {
  return t.replace(QF, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function YF(t, e) {
  e += "[^0-9]";
  var r = t.match(new RegExp(e, "g"));
  return r ? r.length : 0;
}
function ZF(t, e, r) {
  return e += "([^0-9])", r = r.replace(/\$/g, "$$$$"), t.replace(new RegExp(e, "g"), r + "$1");
}
function eP(t, e) {
  if (typeof t == "boolean")
    return !t;
  for (var r in t)
    if (e[r])
      return !0;
}
function tP(t, e, r) {
  if (typeof t == "boolean")
    return !t && r != "not";
  for (var s in t)
    if (s != r && e[s])
      return !0;
}
function rP(t, e) {
  if (typeof t != "boolean") {
    for (var r in t)
      if (!e[r])
        return r;
  }
}
function dl(t) {
  return "'" + Au(t) + "'";
}
function nP(t, e, r, s) {
  var n = r ? "'/' + " + e + (s ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : s ? "'[' + " + e + " + ']'" : "'[\\'' + " + e + " + '\\']'";
  return xv(t, n);
}
function sP(t, e, r) {
  var s = dl(r ? "/" + Du(e) : Su(e));
  return xv(t, s);
}
var aP = /^\/(?:[^~]|~0|~1)*$/, iP = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function oP(t, e, r) {
  var s, n, a, o;
  if (t === "")
    return "rootData";
  if (t[0] == "/") {
    if (!aP.test(t))
      throw new Error("Invalid JSON-pointer: " + t);
    n = t, a = "rootData";
  } else {
    if (o = t.match(iP), !o)
      throw new Error("Invalid JSON-pointer: " + t);
    if (s = +o[1], n = o[2], n == "#") {
      if (s >= e)
        throw new Error("Cannot access property/index " + s + " levels up, current level is " + e);
      return r[e - s];
    }
    if (s > e)
      throw new Error("Cannot access data " + s + " levels up, current level is " + e);
    if (a = "data" + (e - s || ""), !n)
      return a;
  }
  for (var l = a, i = n.split("/"), u = 0; u < i.length; u++) {
    var c = i[u];
    c && (a += Su(wu(c)), l += " && " + a);
  }
  return l;
}
function xv(t, e) {
  return t == '""' ? e : (t + " + " + e).replace(/([^\\])' \+ '/g, "$1");
}
function lP(t) {
  return wu(decodeURIComponent(t));
}
function uP(t) {
  return encodeURIComponent(Du(t));
}
function Du(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
function wu(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
}
var cP = cs, vv = pP;
function pP(t) {
  cP.copy(t, this);
}
var Ev = { exports: {} }, en = Ev.exports = function(t, e, r) {
  typeof e == "function" && (r = e, e = {}), r = e.cb || r;
  var s = typeof r == "function" ? r : r.pre || function() {
  }, n = r.post || function() {
  };
  Ta(e, s, n, t, "", t);
};
en.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0
};
en.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
en.propsKeywords = {
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
en.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Ta(t, e, r, s, n, a, o, l, i, u) {
  if (s && typeof s == "object" && !Array.isArray(s)) {
    e(s, n, a, o, l, i, u);
    for (var c in s) {
      var f = s[c];
      if (Array.isArray(f)) {
        if (c in en.arrayKeywords)
          for (var h = 0; h < f.length; h++)
            Ta(t, e, r, f[h], n + "/" + c + "/" + h, a, n, c, s, h);
      } else if (c in en.propsKeywords) {
        if (f && typeof f == "object")
          for (var p in f)
            Ta(t, e, r, f[p], n + "/" + c + "/" + fP(p), a, n, c, s, p);
      } else
        (c in en.keywords || t.allKeys && !(c in en.skipKeywords)) && Ta(t, e, r, f, n + "/" + c, a, n, c, s);
    }
    r(s, n, a, o, l, i, u);
  }
}
function fP(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
var Ks = hl.exports, Yd = bu, Di = cs, Ha = vv, hP = Ev.exports, ku = un;
un.normalizeId = sn;
un.fullPath = Ka;
un.url = Ja;
un.ids = xP;
un.inlineRef = gl;
un.schema = wi;
function un(t, e, r) {
  var s = this._refs[r];
  if (typeof s == "string")
    if (this._refs[s])
      s = this._refs[s];
    else
      return un.call(this, t, e, s);
  if (s = s || this._schemas[r], s instanceof Ha)
    return gl(s.schema, this._opts.inlineRefs) ? s.schema : s.validate || this._compile(s);
  var n = wi.call(this, e, r), a, o, l;
  return n && (a = n.schema, e = n.root, l = n.baseId), a instanceof Ha ? o = a.validate || t.call(this, a.schema, e, void 0, l) : a !== void 0 && (o = gl(a, this._opts.inlineRefs) ? a : t.call(this, a, e, void 0, l)), o;
}
function wi(t, e) {
  var r = Ks.parse(e), s = Cv(r), n = Ka(this._getId(t.schema));
  if (Object.keys(t.schema).length === 0 || s !== n) {
    var a = sn(s), o = this._refs[a];
    if (typeof o == "string")
      return mP.call(this, t, o, r);
    if (o instanceof Ha)
      o.validate || this._compile(o), t = o;
    else if (o = this._schemas[a], o instanceof Ha) {
      if (o.validate || this._compile(o), a == sn(e))
        return { schema: o, root: t, baseId: n };
      t = o;
    } else
      return;
    if (!t.schema)
      return;
    n = Ka(this._getId(t.schema));
  }
  return bv.call(this, r, n, t.schema, t);
}
function mP(t, e, r) {
  var s = wi.call(this, t, e);
  if (s) {
    var n = s.schema, a = s.baseId;
    t = s.root;
    var o = this._getId(n);
    return o && (a = Ja(a, o)), bv.call(this, r, a, n, t);
  }
}
var dP = Di.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
function bv(t, e, r, s) {
  if (t.fragment = t.fragment || "", t.fragment.slice(0, 1) == "/") {
    for (var n = t.fragment.split("/"), a = 1; a < n.length; a++) {
      var o = n[a];
      if (o) {
        if (o = Di.unescapeFragment(o), r = r[o], r === void 0)
          break;
        var l;
        if (!dP[o] && (l = this._getId(r), l && (e = Ja(e, l)), r.$ref)) {
          var i = Ja(e, r.$ref), u = wi.call(this, s, i);
          u && (r = u.schema, s = u.root, e = u.baseId);
        }
      }
    }
    if (r !== void 0 && r !== s.schema)
      return { schema: r, root: s, baseId: e };
  }
}
var gP = Di.toHash([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum"
]);
function gl(t, e) {
  if (e === !1)
    return !1;
  if (e === void 0 || e === !0)
    return yl(t);
  if (e)
    return xl(t) <= e;
}
function yl(t) {
  var e;
  if (Array.isArray(t)) {
    for (var r = 0; r < t.length; r++)
      if (e = t[r], typeof e == "object" && !yl(e))
        return !1;
  } else
    for (var s in t)
      if (s == "$ref" || (e = t[s], typeof e == "object" && !yl(e)))
        return !1;
  return !0;
}
function xl(t) {
  var e = 0, r;
  if (Array.isArray(t)) {
    for (var s = 0; s < t.length; s++)
      if (r = t[s], typeof r == "object" && (e += xl(r)), e == 1 / 0)
        return 1 / 0;
  } else
    for (var n in t) {
      if (n == "$ref")
        return 1 / 0;
      if (gP[n])
        e++;
      else if (r = t[n], typeof r == "object" && (e += xl(r) + 1), e == 1 / 0)
        return 1 / 0;
    }
  return e;
}
function Ka(t, e) {
  e !== !1 && (t = sn(t));
  var r = Ks.parse(t);
  return Cv(r);
}
function Cv(t) {
  return Ks.serialize(t).split("#")[0] + "#";
}
var yP = /#\/?$/;
function sn(t) {
  return t ? t.replace(yP, "") : "";
}
function Ja(t, e) {
  return e = sn(e), Ks.resolve(t, e);
}
function xP(t) {
  var e = sn(this._getId(t)), r = { "": e }, s = { "": Ka(e, !1) }, n = {}, a = this;
  return hP(t, { allKeys: !0 }, function(o, l, i, u, c, f, h) {
    if (l !== "") {
      var p = a._getId(o), m = r[u], d = s[u] + "/" + c;
      if (h !== void 0 && (d += "/" + (typeof h == "number" ? h : Di.escapeFragment(h))), typeof p == "string") {
        p = m = sn(m ? Ks.resolve(m, p) : p);
        var g = a._refs[p];
        if (typeof g == "string" && (g = a._refs[g]), g && g.schema) {
          if (!Yd(o, g.schema))
            throw new Error('id "' + p + '" resolves to more than one schema');
        } else if (p != sn(d))
          if (p[0] == "#") {
            if (n[p] && !Yd(o, n[p]))
              throw new Error('id "' + p + '" resolves to more than one schema');
            n[p] = o;
          } else
            a._refs[p] = d;
      }
      r[l] = m, s[l] = d;
    }
  }), n;
}
var io = ku, Tu = {
  Validation: Zd(vP),
  MissingRef: Zd(Fu)
};
function vP(t) {
  this.message = "validation failed", this.errors = t, this.ajv = this.validation = !0;
}
Fu.message = function(t, e) {
  return "can't resolve reference " + e + " from id " + t;
};
function Fu(t, e, r) {
  this.message = r || Fu.message(t, e), this.missingRef = io.url(t, e), this.missingSchema = io.normalizeId(io.fullPath(this.missingRef));
}
function Zd(t) {
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var Sv = function(t, e) {
  e || (e = {}), typeof e == "function" && (e = { cmp: e });
  var r = typeof e.cycles == "boolean" ? e.cycles : !1, s = e.cmp && function(a) {
    return function(o) {
      return function(l, i) {
        var u = { key: l, value: o[l] }, c = { key: i, value: o[i] };
        return a(u, c);
      };
    };
  }(e.cmp), n = [];
  return function a(o) {
    if (o && o.toJSON && typeof o.toJSON == "function" && (o = o.toJSON()), o !== void 0) {
      if (typeof o == "number")
        return isFinite(o) ? "" + o : "null";
      if (typeof o != "object")
        return JSON.stringify(o);
      var l, i;
      if (Array.isArray(o)) {
        for (i = "[", l = 0; l < o.length; l++)
          l && (i += ","), i += a(o[l]) || "null";
        return i + "]";
      }
      if (o === null)
        return "null";
      if (n.indexOf(o) !== -1) {
        if (r)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var u = n.push(o) - 1, c = Object.keys(o).sort(s && s(o));
      for (i = "", l = 0; l < c.length; l++) {
        var f = c[l], h = a(o[f]);
        h && (i && (i += ","), i += JSON.stringify(f) + ":" + h);
      }
      return n.splice(u, 1), "{" + i + "}";
    }
  }(t);
}, Av = function(e, r, s) {
  var n = "", a = e.schema.$async === !0, o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"), l = e.self._getId(e.schema);
  if (e.opts.strictKeywords) {
    var i = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
    if (i) {
      var u = "unknown keyword: " + i;
      if (e.opts.strictKeywords === "log")
        e.logger.warn(u);
      else
        throw new Error(u);
    }
  }
  if (e.isTop && (n += " var validate = ", a && (e.async = !0, n += "async "), n += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", l && (e.opts.sourceCode || e.opts.processCode) && (n += " " + ("/*# sourceURL=" + l + " */") + " ")), typeof e.schema == "boolean" || !(o || e.schema.$ref)) {
    var r = "false schema", c = e.level, f = e.dataLevel, h = e.schema[r], p = e.schemaPath + e.util.getProperty(r), m = e.errSchemaPath + "/" + r, v = !e.opts.allErrors, w, d = "data" + (f || ""), b = "valid" + c;
    if (e.schema === !1) {
      e.isTop ? v = !0 : n += " var " + b + " = false; ";
      var g = g || [];
      g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (w || "false schema") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'boolean schema is false' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
      var y = n;
      n = g.pop(), !e.compositeRule && v ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    } else
      e.isTop ? a ? n += " return data; " : n += " validate.errors = null; return true; " : n += " var " + b + " = true; ";
    return e.isTop && (n += " }; return validate; "), n;
  }
  if (e.isTop) {
    var x = e.isTop, c = e.level = 0, f = e.dataLevel = 0, d = "data";
    if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [""], e.schema.default !== void 0 && e.opts.useDefaults && e.opts.strictDefaults) {
      var A = "default is ignored in the schema root";
      if (e.opts.strictDefaults === "log")
        e.logger.warn(A);
      else
        throw new Error(A);
    }
    n += " var vErrors = null; ", n += " var errors = 0;     ", n += " if (rootData === undefined) rootData = data; ";
  } else {
    var c = e.level, f = e.dataLevel, d = "data" + (f || "");
    if (l && (e.baseId = e.resolve.url(e.baseId, l)), a && !e.async)
      throw new Error("async schema in sync schema");
    n += " var errs_" + c + " = errors;";
  }
  var b = "valid" + c, v = !e.opts.allErrors, C = "", T = "", w, B = e.schema.type, I = Array.isArray(B);
  if (B && e.opts.nullable && e.schema.nullable === !0 && (I ? B.indexOf("null") == -1 && (B = B.concat("null")) : B != "null" && (B = [B, "null"], I = !0)), I && B.length == 1 && (B = B[0], I = !1), e.schema.$ref && o) {
    if (e.opts.extendRefs == "fail")
      throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
    e.opts.extendRefs !== !0 && (o = !1, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'));
  }
  if (e.schema.$comment && e.opts.$comment && (n += " " + e.RULES.all.$comment.code(e, "$comment")), B) {
    if (e.opts.coerceTypes)
      var _ = e.util.coerceToTypes(e.opts.coerceTypes, B);
    var S = e.RULES.types[B];
    if (_ || I || S === !0 || S && !We(S)) {
      var p = e.schemaPath + ".type", m = e.errSchemaPath + "/type", p = e.schemaPath + ".type", m = e.errSchemaPath + "/type", F = I ? "checkDataTypes" : "checkDataType";
      if (n += " if (" + e.util[F](B, d, e.opts.strictNumbers, !0) + ") { ", _) {
        var N = "dataType" + c, k = "coerced" + c;
        n += " var " + N + " = typeof " + d + "; var " + k + " = undefined; ", e.opts.coerceTypes == "array" && (n += " if (" + N + " == 'object' && Array.isArray(" + d + ") && " + d + ".length == 1) { " + d + " = " + d + "[0]; " + N + " = typeof " + d + "; if (" + e.util.checkDataType(e.schema.type, d, e.opts.strictNumbers) + ") " + k + " = " + d + "; } "), n += " if (" + k + " !== undefined) ; ";
        var j = _;
        if (j)
          for (var O, z = -1, te = j.length - 1; z < te; )
            O = j[z += 1], O == "string" ? n += " else if (" + N + " == 'number' || " + N + " == 'boolean') " + k + " = '' + " + d + "; else if (" + d + " === null) " + k + " = ''; " : O == "number" || O == "integer" ? (n += " else if (" + N + " == 'boolean' || " + d + " === null || (" + N + " == 'string' && " + d + " && " + d + " == +" + d + " ", O == "integer" && (n += " && !(" + d + " % 1)"), n += ")) " + k + " = +" + d + "; ") : O == "boolean" ? n += " else if (" + d + " === 'false' || " + d + " === 0 || " + d + " === null) " + k + " = false; else if (" + d + " === 'true' || " + d + " === 1) " + k + " = true; " : O == "null" ? n += " else if (" + d + " === '' || " + d + " === 0 || " + d + " === false) " + k + " = null; " : e.opts.coerceTypes == "array" && O == "array" && (n += " else if (" + N + " == 'string' || " + N + " == 'number' || " + N + " == 'boolean' || " + d + " == null) " + k + " = [" + d + "]; ");
        n += " else {   ";
        var g = g || [];
        g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (w || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", I ? n += "" + B.join(",") : n += "" + B, n += "' } ", e.opts.messages !== !1 && (n += " , message: 'should be ", I ? n += "" + B.join(",") : n += "" + B, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var y = n;
        n = g.pop(), !e.compositeRule && v ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } if (" + k + " !== undefined) {  ";
        var se = f ? "data" + (f - 1 || "") : "parentData", ye = f ? e.dataPathArr[f] : "parentDataProperty";
        n += " " + d + " = " + k + "; ", f || (n += "if (" + se + " !== undefined)"), n += " " + se + "[" + ye + "] = " + k + "; } ";
      } else {
        var g = g || [];
        g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (w || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", I ? n += "" + B.join(",") : n += "" + B, n += "' } ", e.opts.messages !== !1 && (n += " , message: 'should be ", I ? n += "" + B.join(",") : n += "" + B, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var y = n;
        n = g.pop(), !e.compositeRule && v ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      n += " } ";
    }
  }
  if (e.schema.$ref && !o)
    n += " " + e.RULES.all.$ref.code(e, "$ref") + " ", v && (n += " } if (errors === ", x ? n += "0" : n += "errs_" + c, n += ") { ", T += "}");
  else {
    var Se = e.RULES;
    if (Se) {
      for (var S, xe = -1, Ae = Se.length - 1; xe < Ae; )
        if (S = Se[xe += 1], We(S)) {
          if (S.type && (n += " if (" + e.util.checkDataType(S.type, d, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) {
            if (S.type == "object" && e.schema.properties) {
              var h = e.schema.properties, _e = Object.keys(h), H = _e;
              if (H)
                for (var Q, ge = -1, ae = H.length - 1; ge < ae; ) {
                  Q = H[ge += 1];
                  var ee = h[Q];
                  if (ee.default !== void 0) {
                    var he = d + e.util.getProperty(Q);
                    if (e.compositeRule) {
                      if (e.opts.strictDefaults) {
                        var A = "default is ignored for: " + he;
                        if (e.opts.strictDefaults === "log")
                          e.logger.warn(A);
                        else
                          throw new Error(A);
                      }
                    } else
                      n += " if (" + he + " === undefined ", e.opts.useDefaults == "empty" && (n += " || " + he + " === null || " + he + " === '' "), n += " ) " + he + " = ", e.opts.useDefaults == "shared" ? n += " " + e.useDefault(ee.default) + " " : n += " " + JSON.stringify(ee.default) + " ", n += "; ";
                  }
                }
            } else if (S.type == "array" && Array.isArray(e.schema.items)) {
              var R = e.schema.items;
              if (R) {
                for (var ee, z = -1, D = R.length - 1; z < D; )
                  if (ee = R[z += 1], ee.default !== void 0) {
                    var he = d + "[" + z + "]";
                    if (e.compositeRule) {
                      if (e.opts.strictDefaults) {
                        var A = "default is ignored for: " + he;
                        if (e.opts.strictDefaults === "log")
                          e.logger.warn(A);
                        else
                          throw new Error(A);
                      }
                    } else
                      n += " if (" + he + " === undefined ", e.opts.useDefaults == "empty" && (n += " || " + he + " === null || " + he + " === '' "), n += " ) " + he + " = ", e.opts.useDefaults == "shared" ? n += " " + e.useDefault(ee.default) + " " : n += " " + JSON.stringify(ee.default) + " ", n += "; ";
                  }
              }
            }
          }
          var U = S.rules;
          if (U) {
            for (var ne, pe = -1, Ee = U.length - 1; pe < Ee; )
              if (ne = U[pe += 1], wt(ne)) {
                var Re = ne.code(e, ne.keyword, S.type);
                Re && (n += " " + Re + " ", v && (C += "}"));
              }
          }
          if (v && (n += " " + C + " ", C = ""), S.type && (n += " } ", B && B === S.type && !_)) {
            n += " else { ";
            var p = e.schemaPath + ".type", m = e.errSchemaPath + "/type", g = g || [];
            g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (w || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", I ? n += "" + B.join(",") : n += "" + B, n += "' } ", e.opts.messages !== !1 && (n += " , message: 'should be ", I ? n += "" + B.join(",") : n += "" + B, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
            var y = n;
            n = g.pop(), !e.compositeRule && v ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ";
          }
          v && (n += " if (errors === ", x ? n += "0" : n += "errs_" + c, n += ") { ", T += "}");
        }
    }
  }
  v && (n += " " + T + " "), x ? (a ? (n += " if (errors === 0) return data;           ", n += " else throw new ValidationError(vErrors); ") : (n += " validate.errors = vErrors; ", n += " return errors === 0;       "), n += " }; return validate;") : n += " var " + b + " = errors === errs_" + c + ";";
  function We(et) {
    for (var Ge = et.rules, mt = 0; mt < Ge.length; mt++)
      if (wt(Ge[mt]))
        return !0;
  }
  function wt(et) {
    return e.schema[et.keyword] !== void 0 || et.implements && Lt(et);
  }
  function Lt(et) {
    for (var Ge = et.implements, mt = 0; mt < Ge.length; mt++)
      if (e.schema[Ge[mt]] !== void 0)
        return !0;
  }
  return n;
}, la = ku, Xa = cs, Dv = Tu, EP = Sv, eg = Av, bP = Xa.ucs2length, CP = bu, SP = Dv.Validation, AP = vl;
function vl(t, e, r, s) {
  var n = this, a = this._opts, o = [void 0], l = {}, i = [], u = {}, c = [], f = {}, h = [];
  e = e || { schema: t, refVal: o, refs: l };
  var p = DP.call(this, t, e, s), m = this._compilations[p.index];
  if (p.compiling)
    return m.callValidate = A;
  var d = this._formats, g = this.RULES;
  try {
    var y = b(t, e, r, s);
    m.validate = y;
    var x = m.callValidate;
    return x && (x.schema = y.schema, x.errors = null, x.refs = y.refs, x.refVal = y.refVal, x.root = y.root, x.$async = y.$async, a.sourceCode && (x.source = y.source)), y;
  } finally {
    wP.call(this, t, e, s);
  }
  function A() {
    var F = m.validate, N = F.apply(this, arguments);
    return A.errors = F.errors, N;
  }
  function b(F, N, k, j) {
    var O = !N || N && N.schema == F;
    if (N.schema != e.schema)
      return vl.call(n, F, N, k, j);
    var z = F.$async === !0, te = eg({
      isTop: !0,
      schema: F,
      isRoot: O,
      baseId: j,
      root: N,
      schemaPath: "",
      errSchemaPath: "#",
      errorPath: '""',
      MissingRefError: Dv.MissingRef,
      RULES: g,
      validate: eg,
      util: Xa,
      resolve: la,
      resolveRef: v,
      usePattern: I,
      useDefault: _,
      useCustomRule: S,
      opts: a,
      formats: d,
      logger: n.logger,
      self: n
    });
    te = ua(o, FP) + ua(i, kP) + ua(c, TP) + ua(h, PP) + te, a.processCode && (te = a.processCode(te, F));
    var se;
    try {
      var ye = new Function(
        "self",
        "RULES",
        "formats",
        "root",
        "refVal",
        "defaults",
        "customRules",
        "equal",
        "ucs2length",
        "ValidationError",
        te
      );
      se = ye(
        n,
        g,
        d,
        e,
        o,
        c,
        h,
        CP,
        bP,
        SP
      ), o[0] = se;
    } catch (Se) {
      throw n.logger.error("Error compiling schema, function code:", te), Se;
    }
    return se.schema = F, se.errors = null, se.refs = l, se.refVal = o, se.root = O ? se : N, z && (se.$async = !0), a.sourceCode === !0 && (se.source = {
      code: te,
      patterns: i,
      defaults: c
    }), se;
  }
  function v(F, N, k) {
    N = la.url(F, N);
    var j = l[N], O, z;
    if (j !== void 0)
      return O = o[j], z = "refVal[" + j + "]", B(O, z);
    if (!k && e.refs) {
      var te = e.refs[N];
      if (te !== void 0)
        return O = e.refVal[te], z = C(N, O), B(O, z);
    }
    z = C(N);
    var se = la.call(n, b, e, N);
    if (se === void 0) {
      var ye = r && r[N];
      ye && (se = la.inlineRef(ye, a.inlineRefs) ? ye : vl.call(n, ye, e, r, F));
    }
    if (se === void 0)
      T(N);
    else
      return w(N, se), B(se, z);
  }
  function C(F, N) {
    var k = o.length;
    return o[k] = N, l[F] = k, "refVal" + k;
  }
  function T(F) {
    delete l[F];
  }
  function w(F, N) {
    var k = l[F];
    o[k] = N;
  }
  function B(F, N) {
    return typeof F == "object" || typeof F == "boolean" ? { code: N, schema: F, inline: !0 } : { code: N, $async: F && !!F.$async };
  }
  function I(F) {
    var N = u[F];
    return N === void 0 && (N = u[F] = i.length, i[N] = F), "pattern" + N;
  }
  function _(F) {
    switch (typeof F) {
      case "boolean":
      case "number":
        return "" + F;
      case "string":
        return Xa.toQuotedString(F);
      case "object":
        if (F === null)
          return "null";
        var N = EP(F), k = f[N];
        return k === void 0 && (k = f[N] = c.length, c[k] = F), "default" + k;
    }
  }
  function S(F, N, k, j) {
    if (n._opts.validateSchema !== !1) {
      var O = F.definition.dependencies;
      if (O && !O.every(function(H) {
        return Object.prototype.hasOwnProperty.call(k, H);
      }))
        throw new Error("parent schema must have all required keywords: " + O.join(","));
      var z = F.definition.validateSchema;
      if (z) {
        var te = z(N);
        if (!te) {
          var se = "keyword schema is invalid: " + n.errorsText(z.errors);
          if (n._opts.validateSchema == "log")
            n.logger.error(se);
          else
            throw new Error(se);
        }
      }
    }
    var ye = F.definition.compile, Se = F.definition.inline, xe = F.definition.macro, Ae;
    if (ye)
      Ae = ye.call(n, N, k, j);
    else if (xe)
      Ae = xe.call(n, N, k, j), a.validateSchema !== !1 && n.validateSchema(Ae, !0);
    else if (Se)
      Ae = Se.call(n, j, F.keyword, N, k);
    else if (Ae = F.definition.validate, !Ae)
      return;
    if (Ae === void 0)
      throw new Error('custom keyword "' + F.keyword + '"failed to compile');
    var _e = h.length;
    return h[_e] = Ae, {
      code: "customRule" + _e,
      validate: Ae
    };
  }
}
function DP(t, e, r) {
  var s = wv.call(this, t, e, r);
  return s >= 0 ? { index: s, compiling: !0 } : (s = this._compilations.length, this._compilations[s] = {
    schema: t,
    root: e,
    baseId: r
  }, { index: s, compiling: !1 });
}
function wP(t, e, r) {
  var s = wv.call(this, t, e, r);
  s >= 0 && this._compilations.splice(s, 1);
}
function wv(t, e, r) {
  for (var s = 0; s < this._compilations.length; s++) {
    var n = this._compilations[s];
    if (n.schema == t && n.root == e && n.baseId == r)
      return s;
  }
  return -1;
}
function kP(t, e) {
  return "var pattern" + t + " = new RegExp(" + Xa.toQuotedString(e[t]) + ");";
}
function TP(t) {
  return "var default" + t + " = defaults[" + t + "];";
}
function FP(t, e) {
  return e[t] === void 0 ? "" : "var refVal" + t + " = refVal[" + t + "];";
}
function PP(t) {
  return "var customRule" + t + " = customRules[" + t + "];";
}
function ua(t, e) {
  if (!t.length)
    return "";
  for (var r = "", s = 0; s < t.length; s++)
    r += e(s, t);
  return r;
}
var kv = { exports: {} }, ki = kv.exports = function() {
  this._cache = {};
};
ki.prototype.put = function(e, r) {
  this._cache[e] = r;
};
ki.prototype.get = function(e) {
  return this._cache[e];
};
ki.prototype.del = function(e) {
  delete this._cache[e];
};
ki.prototype.clear = function() {
  this._cache = {};
};
var IP = cs, _P = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, BP = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], OP = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, Tv = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, LP = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, RP = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, Fv = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, Pv = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, Iv = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, _v = /^(?:\/(?:[^~/]|~0|~1)*)*$/, Bv = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, Ov = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, NP = Ti;
function Ti(t) {
  return t = t == "full" ? "full" : "fast", IP.copy(Ti[t]);
}
Ti.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  "uri-template": Fv,
  url: Pv,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: Tv,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: Nv,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: Iv,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  "json-pointer": _v,
  "json-pointer-uri-fragment": Bv,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  "relative-json-pointer": Ov
};
Ti.full = {
  date: Lv,
  time: Rv,
  "date-time": $P,
  uri: UP,
  "uri-reference": RP,
  "uri-template": Fv,
  url: Pv,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: Tv,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: Nv,
  uuid: Iv,
  "json-pointer": _v,
  "json-pointer-uri-fragment": Bv,
  "relative-json-pointer": Ov
};
function jP(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function Lv(t) {
  var e = t.match(_P);
  if (!e)
    return !1;
  var r = +e[1], s = +e[2], n = +e[3];
  return s >= 1 && s <= 12 && n >= 1 && n <= (s == 2 && jP(r) ? 29 : BP[s]);
}
function Rv(t, e) {
  var r = t.match(OP);
  if (!r)
    return !1;
  var s = r[1], n = r[2], a = r[3], o = r[5];
  return (s <= 23 && n <= 59 && a <= 59 || s == 23 && n == 59 && a == 60) && (!e || o);
}
var MP = /t|\s/i;
function $P(t) {
  var e = t.split(MP);
  return e.length == 2 && Lv(e[0]) && Rv(e[1], !0);
}
var VP = /\/|:/;
function UP(t) {
  return VP.test(t) && LP.test(t);
}
var qP = /[^\\]\\Z/;
function Nv(t) {
  if (qP.test(t))
    return !1;
  try {
    return new RegExp(t), !0;
  } catch {
    return !1;
  }
}
var WP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.errSchemaPath + "/" + r, u = !e.opts.allErrors, c = "data" + (o || ""), f = "valid" + a, h, p;
  if (l == "#" || l == "#/")
    e.isRoot ? (h = e.async, p = "validate") : (h = e.root.schema.$async === !0, p = "root.refVal[0]");
  else {
    var m = e.resolveRef(e.baseId, l, e.isRoot);
    if (m === void 0) {
      var d = e.MissingRefError.message(e.baseId, l);
      if (e.opts.missingRefs == "fail") {
        e.logger.error(d);
        var g = g || [];
        g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(i) + " , params: { ref: '" + e.util.escapeQuotes(l) + "' } ", e.opts.messages !== !1 && (n += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(l) + "' "), e.opts.verbose && (n += " , schema: " + e.util.toQuotedString(l) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), n += " } ") : n += " {} ";
        var y = n;
        n = g.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u && (n += " if (false) { ");
      } else if (e.opts.missingRefs == "ignore")
        e.logger.warn(d), u && (n += " if (true) { ");
      else
        throw new e.MissingRefError(e.baseId, l, d);
    } else if (m.inline) {
      var x = e.util.copy(e);
      x.level++;
      var A = "valid" + x.level;
      x.schema = m.schema, x.schemaPath = "", x.errSchemaPath = l;
      var b = e.validate(x).replace(/validate\.schema/g, m.code);
      n += " " + b + " ", u && (n += " if (" + A + ") { ");
    } else
      h = m.$async === !0 || e.async && m.$async !== !1, p = m.code;
  }
  if (p) {
    var g = g || [];
    g.push(n), n = "", e.opts.passContext ? n += " " + p + ".call(this, " : n += " " + p + "( ", n += " " + c + ", (dataPath || '')", e.errorPath != '""' && (n += " + " + e.errorPath);
    var v = o ? "data" + (o - 1 || "") : "parentData", C = o ? e.dataPathArr[o] : "parentDataProperty";
    n += " , " + v + " , " + C + ", rootData)  ";
    var T = n;
    if (n = g.pop(), h) {
      if (!e.async)
        throw new Error("async schema referenced by sync schema");
      u && (n += " var " + f + "; "), n += " try { await " + T + "; ", u && (n += " " + f + " = true; "), n += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", u && (n += " " + f + " = false; "), n += " } ", u && (n += " if (" + f + ") { ");
    } else
      n += " if (!" + T + ") { if (vErrors === null) vErrors = " + p + ".errors; else vErrors = vErrors.concat(" + p + ".errors); errors = vErrors.length; } ", u && (n += " else { ");
  }
  return n;
}, zP = function(e, r, s) {
  var n = " ", a = e.schema[r], o = e.schemaPath + e.util.getProperty(r), l = e.errSchemaPath + "/" + r, i = !e.opts.allErrors, u = e.util.copy(e), c = "";
  u.level++;
  var f = "valid" + u.level, h = u.baseId, p = !0, m = a;
  if (m)
    for (var d, g = -1, y = m.length - 1; g < y; )
      d = m[g += 1], (e.opts.strictKeywords ? typeof d == "object" && Object.keys(d).length > 0 || d === !1 : e.util.schemaHasRules(d, e.RULES.all)) && (p = !1, u.schema = d, u.schemaPath = o + "[" + g + "]", u.errSchemaPath = l + "/" + g, n += "  " + e.validate(u) + " ", u.baseId = h, i && (n += " if (" + f + ") { ", c += "}"));
  return i && (p ? n += " if (true) { " : n += " " + c.slice(0, -1) + " "), n;
}, GP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = "errs__" + a, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, y = l.every(function(w) {
    return e.opts.strictKeywords ? typeof w == "object" && Object.keys(w).length > 0 || w === !1 : e.util.schemaHasRules(w, e.RULES.all);
  });
  if (y) {
    var x = m.baseId;
    n += " var " + p + " = errors; var " + h + " = false;  ";
    var A = e.compositeRule;
    e.compositeRule = m.compositeRule = !0;
    var b = l;
    if (b)
      for (var v, C = -1, T = b.length - 1; C < T; )
        v = b[C += 1], m.schema = v, m.schemaPath = i + "[" + C + "]", m.errSchemaPath = u + "/" + C, n += "  " + e.validate(m) + " ", m.baseId = x, n += " " + h + " = " + h + " || " + g + "; if (!" + h + ") { ", d += "}";
    e.compositeRule = m.compositeRule = A, n += " " + d + " if (!" + h + ") {   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += " } else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } ", e.opts.allErrors && (n += " } ");
  } else
    c && (n += " if (true) { ");
  return n;
}, HP = function(e, r, s) {
  var n = " ", a = e.schema[r], o = e.errSchemaPath + "/" + r;
  e.opts.allErrors;
  var l = e.util.toQuotedString(a);
  return e.opts.$comment === !0 ? n += " console.log(" + l + ");" : typeof e.opts.$comment == "function" && (n += " self._opts.$comment(" + l + ", " + e.util.toQuotedString(o) + ", validate.root.schema);"), n;
}, KP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = e.opts.$data && l && l.$data;
  p && (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; "), p || (n += " var schema" + a + " = validate.schema" + i + ";"), n += "var " + h + " = equal(" + f + ", schema" + a + "); if (!" + h + ") {   ";
  var m = m || [];
  m.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'const' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValue: schema" + a + " } ", e.opts.messages !== !1 && (n += " , message: 'should be equal to constant' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var d = n;
  return n = m.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + d + "]); " : n += " validate.errors = [" + d + "]; return false; " : n += " var err = " + d + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " }", c && (n += " else { "), n;
}, JP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = "errs__" + a, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, y = "i" + a, x = m.dataLevel = e.dataLevel + 1, A = "data" + x, b = e.baseId, v = e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all);
  if (n += "var " + p + " = errors;var " + h + ";", v) {
    var C = e.compositeRule;
    e.compositeRule = m.compositeRule = !0, m.schema = l, m.schemaPath = i, m.errSchemaPath = u, n += " var " + g + " = false; for (var " + y + " = 0; " + y + " < " + f + ".length; " + y + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers, !0);
    var T = f + "[" + y + "]";
    m.dataPathArr[x] = y;
    var w = e.validate(m);
    m.baseId = b, e.util.varOccurences(w, A) < 2 ? n += " " + e.util.varReplace(w, A, T) + " " : n += " var " + A + " = " + T + "; " + w + " ", n += " if (" + g + ") break; }  ", e.compositeRule = m.compositeRule = C, n += " " + d + " if (!" + g + ") {";
  } else
    n += " if (" + f + ".length == 0) {";
  var B = B || [];
  B.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should contain a valid item' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var I = n;
  return n = B.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + I + "]); " : n += " validate.errors = [" + I + "]; return false; " : n += " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ", v && (n += "  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } "), e.opts.allErrors && (n += " } "), n;
}, XP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "errs__" + a, p = e.util.copy(e), m = "";
  p.level++;
  var d = "valid" + p.level, g = {}, y = {}, x = e.opts.ownProperties;
  for (C in l)
    if (C != "__proto__") {
      var A = l[C], b = Array.isArray(A) ? y : g;
      b[C] = A;
    }
  n += "var " + h + " = errors;";
  var v = e.errorPath;
  n += "var missing" + a + ";";
  for (var C in y)
    if (b = y[C], b.length) {
      if (n += " if ( " + f + e.util.getProperty(C) + " !== undefined ", x && (n += " && Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(C) + "') "), c) {
        n += " && ( ";
        var T = b;
        if (T)
          for (var w, B = -1, I = T.length - 1; B < I; ) {
            w = T[B += 1], B && (n += " || ");
            var _ = e.util.getProperty(w), S = f + _;
            n += " ( ( " + S + " === undefined ", x && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(w) + "') "), n += ") && (missing" + a + " = " + e.util.toQuotedString(e.opts.jsonPointers ? w : _) + ") ) ";
          }
        n += ")) {  ";
        var F = "missing" + a, N = "' + " + F + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(v, F, !0) : v + " + " + F);
        var k = k || [];
        k.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(C) + "', missingProperty: '" + N + "', depsCount: " + b.length + ", deps: '" + e.util.escapeQuotes(b.length == 1 ? b[0] : b.join(", ")) + "' } ", e.opts.messages !== !1 && (n += " , message: 'should have ", b.length == 1 ? n += "property " + e.util.escapeQuotes(b[0]) : n += "properties " + e.util.escapeQuotes(b.join(", ")), n += " when property " + e.util.escapeQuotes(C) + " is present' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
        var j = n;
        n = k.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + j + "]); " : n += " validate.errors = [" + j + "]; return false; " : n += " var err = " + j + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      } else {
        n += " ) { ";
        var O = b;
        if (O)
          for (var w, z = -1, te = O.length - 1; z < te; ) {
            w = O[z += 1];
            var _ = e.util.getProperty(w), N = e.util.escapeQuotes(w), S = f + _;
            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(v, w, e.opts.jsonPointers)), n += " if ( " + S + " === undefined ", x && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(w) + "') "), n += ") {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(C) + "', missingProperty: '" + N + "', depsCount: " + b.length + ", deps: '" + e.util.escapeQuotes(b.length == 1 ? b[0] : b.join(", ")) + "' } ", e.opts.messages !== !1 && (n += " , message: 'should have ", b.length == 1 ? n += "property " + e.util.escapeQuotes(b[0]) : n += "properties " + e.util.escapeQuotes(b.join(", ")), n += " when property " + e.util.escapeQuotes(C) + " is present' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
      }
      n += " }   ", c && (m += "}", n += " else { ");
    }
  e.errorPath = v;
  var se = p.baseId;
  for (var C in g) {
    var A = g[C];
    (e.opts.strictKeywords ? typeof A == "object" && Object.keys(A).length > 0 || A === !1 : e.util.schemaHasRules(A, e.RULES.all)) && (n += " " + d + " = true; if ( " + f + e.util.getProperty(C) + " !== undefined ", x && (n += " && Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(C) + "') "), n += ") { ", p.schema = A, p.schemaPath = i + e.util.getProperty(C), p.errSchemaPath = u + "/" + e.util.escapeFragment(C), n += "  " + e.validate(p) + " ", p.baseId = se, n += " }  ", c && (n += " if (" + d + ") { ", m += "}"));
  }
  return c && (n += "   " + m + " if (" + h + " == errors) {"), n;
}, QP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = e.opts.$data && l && l.$data;
  p && (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ");
  var m = "i" + a, d = "schema" + a;
  p || (n += " var " + d + " = validate.schema" + i + ";"), n += "var " + h + ";", p && (n += " if (schema" + a + " === undefined) " + h + " = true; else if (!Array.isArray(schema" + a + ")) " + h + " = false; else {"), n += "" + h + " = false;for (var " + m + "=0; " + m + "<" + d + ".length; " + m + "++) if (equal(" + f + ", " + d + "[" + m + "])) { " + h + " = true; break; }", p && (n += "  }  "), n += " if (!" + h + ") {   ";
  var g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValues: schema" + a + " } ", e.opts.messages !== !1 && (n += " , message: 'should be equal to one of the allowed values' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var y = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " }", c && (n += " else { "), n;
}, YP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || "");
  if (e.opts.format === !1)
    return c && (n += " if (true) { "), n;
  var h = e.opts.$data && l && l.$data, p;
  h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l;
  var m = e.opts.unknownFormats, d = Array.isArray(m);
  if (h) {
    var g = "format" + a, y = "isObject" + a, x = "formatType" + a;
    n += " var " + g + " = formats[" + p + "]; var " + y + " = typeof " + g + " == 'object' && !(" + g + " instanceof RegExp) && " + g + ".validate; var " + x + " = " + y + " && " + g + ".type || 'string'; if (" + y + ") { ", e.async && (n += " var async" + a + " = " + g + ".async; "), n += " " + g + " = " + g + ".validate; } if (  ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'string') || "), n += " (", m != "ignore" && (n += " (" + p + " && !" + g + " ", d && (n += " && self._opts.unknownFormats.indexOf(" + p + ") == -1 "), n += ") || "), n += " (" + g + " && " + x + " == '" + s + "' && !(typeof " + g + " == 'function' ? ", e.async ? n += " (async" + a + " ? await " + g + "(" + f + ") : " + g + "(" + f + ")) " : n += " " + g + "(" + f + ") ", n += " : " + g + ".test(" + f + "))))) {";
  } else {
    var g = e.formats[l];
    if (!g) {
      if (m == "ignore")
        return e.logger.warn('unknown format "' + l + '" ignored in schema at path "' + e.errSchemaPath + '"'), c && (n += " if (true) { "), n;
      if (d && m.indexOf(l) >= 0)
        return c && (n += " if (true) { "), n;
      throw new Error('unknown format "' + l + '" is used in schema at path "' + e.errSchemaPath + '"');
    }
    var y = typeof g == "object" && !(g instanceof RegExp) && g.validate, x = y && g.type || "string";
    if (y) {
      var A = g.async === !0;
      g = g.validate;
    }
    if (x != s)
      return c && (n += " if (true) { "), n;
    if (A) {
      if (!e.async)
        throw new Error("async format in sync schema");
      var b = "formats" + e.util.getProperty(l) + ".validate";
      n += " if (!(await " + b + "(" + f + "))) { ";
    } else {
      n += " if (! ";
      var b = "formats" + e.util.getProperty(l);
      y && (b += ".validate"), typeof g == "function" ? n += " " + b + "(" + f + ") " : n += " " + b + ".test(" + f + ") ", n += ") { ";
    }
  }
  var v = v || [];
  v.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'format' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { format:  ", h ? n += "" + p : n += "" + e.util.toQuotedString(l), n += "  } ", e.opts.messages !== !1 && (n += ` , message: 'should match format "`, h ? n += "' + " + p + " + '" : n += "" + e.util.escapeQuotes(l), n += `"' `), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + e.util.toQuotedString(l), n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var C = n;
  return n = v.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + C + "]); " : n += " validate.errors = [" + C + "]; return false; " : n += " var err = " + C + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c && (n += " else { "), n;
}, ZP = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = "errs__" + a, m = e.util.copy(e);
  m.level++;
  var d = "valid" + m.level, g = e.schema.then, y = e.schema.else, x = g !== void 0 && (e.opts.strictKeywords ? typeof g == "object" && Object.keys(g).length > 0 || g === !1 : e.util.schemaHasRules(g, e.RULES.all)), A = y !== void 0 && (e.opts.strictKeywords ? typeof y == "object" && Object.keys(y).length > 0 || y === !1 : e.util.schemaHasRules(y, e.RULES.all)), b = m.baseId;
  if (x || A) {
    var v;
    m.createErrors = !1, m.schema = l, m.schemaPath = i, m.errSchemaPath = u, n += " var " + p + " = errors; var " + h + " = true;  ";
    var C = e.compositeRule;
    e.compositeRule = m.compositeRule = !0, n += "  " + e.validate(m) + " ", m.baseId = b, m.createErrors = !0, n += "  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; }  ", e.compositeRule = m.compositeRule = C, x ? (n += " if (" + d + ") {  ", m.schema = e.schema.then, m.schemaPath = e.schemaPath + ".then", m.errSchemaPath = e.errSchemaPath + "/then", n += "  " + e.validate(m) + " ", m.baseId = b, n += " " + h + " = " + d + "; ", x && A ? (v = "ifClause" + a, n += " var " + v + " = 'then'; ") : v = "'then'", n += " } ", A && (n += " else { ")) : n += " if (!" + d + ") { ", A && (m.schema = e.schema.else, m.schemaPath = e.schemaPath + ".else", m.errSchemaPath = e.errSchemaPath + "/else", n += "  " + e.validate(m) + " ", m.baseId = b, n += " " + h + " = " + d + "; ", x && A ? (v = "ifClause" + a, n += " var " + v + " = 'else'; ") : v = "'else'", n += " } "), n += " if (!" + h + ") {   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { failingKeyword: " + v + " } ", e.opts.messages !== !1 && (n += ` , message: 'should match "' + ` + v + ` + '" schema' `), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += " }   ", c && (n += " else { ");
  } else
    c && (n += " if (true) { ");
  return n;
}, eI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = "errs__" + a, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, y = "i" + a, x = m.dataLevel = e.dataLevel + 1, A = "data" + x, b = e.baseId;
  if (n += "var " + p + " = errors;var " + h + ";", Array.isArray(l)) {
    var v = e.schema.additionalItems;
    if (v === !1) {
      n += " " + h + " = " + f + ".length <= " + l.length + "; ";
      var C = u;
      u = e.errSchemaPath + "/additionalItems", n += "  if (!" + h + ") {   ";
      var T = T || [];
      T.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + l.length + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have more than " + l.length + " items' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
      var w = n;
      n = T.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + w + "]); " : n += " validate.errors = [" + w + "]; return false; " : n += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", u = C, c && (d += "}", n += " else { ");
    }
    var B = l;
    if (B) {
      for (var I, _ = -1, S = B.length - 1; _ < S; )
        if (I = B[_ += 1], e.opts.strictKeywords ? typeof I == "object" && Object.keys(I).length > 0 || I === !1 : e.util.schemaHasRules(I, e.RULES.all)) {
          n += " " + g + " = true; if (" + f + ".length > " + _ + ") { ";
          var F = f + "[" + _ + "]";
          m.schema = I, m.schemaPath = i + "[" + _ + "]", m.errSchemaPath = u + "/" + _, m.errorPath = e.util.getPathExpr(e.errorPath, _, e.opts.jsonPointers, !0), m.dataPathArr[x] = _;
          var N = e.validate(m);
          m.baseId = b, e.util.varOccurences(N, A) < 2 ? n += " " + e.util.varReplace(N, A, F) + " " : n += " var " + A + " = " + F + "; " + N + " ", n += " }  ", c && (n += " if (" + g + ") { ", d += "}");
        }
    }
    if (typeof v == "object" && (e.opts.strictKeywords ? typeof v == "object" && Object.keys(v).length > 0 || v === !1 : e.util.schemaHasRules(v, e.RULES.all))) {
      m.schema = v, m.schemaPath = e.schemaPath + ".additionalItems", m.errSchemaPath = e.errSchemaPath + "/additionalItems", n += " " + g + " = true; if (" + f + ".length > " + l.length + ") {  for (var " + y + " = " + l.length + "; " + y + " < " + f + ".length; " + y + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers, !0);
      var F = f + "[" + y + "]";
      m.dataPathArr[x] = y;
      var N = e.validate(m);
      m.baseId = b, e.util.varOccurences(N, A) < 2 ? n += " " + e.util.varReplace(N, A, F) + " " : n += " var " + A + " = " + F + "; " + N + " ", c && (n += " if (!" + g + ") break; "), n += " } }  ", c && (n += " if (" + g + ") { ", d += "}");
    }
  } else if (e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all)) {
    m.schema = l, m.schemaPath = i, m.errSchemaPath = u, n += "  for (var " + y + " = 0; " + y + " < " + f + ".length; " + y + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers, !0);
    var F = f + "[" + y + "]";
    m.dataPathArr[x] = y;
    var N = e.validate(m);
    m.baseId = b, e.util.varOccurences(N, A) < 2 ? n += " " + e.util.varReplace(N, A, F) + " " : n += " var " + A + " = " + F + "; " + N + " ", c && (n += " if (!" + g + ") break; "), n += " }";
  }
  return c && (n += " " + d + " if (" + p + " == errors) {"), n;
}, tg = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, b, f = "data" + (o || ""), h = e.opts.$data && l && l.$data, p;
  h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l;
  var m = r == "maximum", d = m ? "exclusiveMaximum" : "exclusiveMinimum", g = e.schema[d], y = e.opts.$data && g && g.$data, x = m ? "<" : ">", A = m ? ">" : "<", b = void 0;
  if (!(h || typeof l == "number" || l === void 0))
    throw new Error(r + " must be number");
  if (!(y || g === void 0 || typeof g == "number" || typeof g == "boolean"))
    throw new Error(d + " must be number or boolean");
  if (y) {
    var v = e.util.getData(g.$data, o, e.dataPathArr), C = "exclusive" + a, T = "exclType" + a, w = "exclIsNumber" + a, B = "op" + a, I = "' + " + B + " + '";
    n += " var schemaExcl" + a + " = " + v + "; ", v = "schemaExcl" + a, n += " var " + C + "; var " + T + " = typeof " + v + "; if (" + T + " != 'boolean' && " + T + " != 'undefined' && " + T + " != 'number') { ";
    var b = d, _ = _ || [];
    _.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (b || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: '" + d + " should be boolean' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
    var S = n;
    n = _.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + S + "]); " : n += " validate.errors = [" + S + "]; return false; " : n += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), n += " " + T + " == 'number' ? ( (" + C + " = " + p + " === undefined || " + v + " " + x + "= " + p + ") ? " + f + " " + A + "= " + v + " : " + f + " " + A + " " + p + " ) : ( (" + C + " = " + v + " === true) ? " + f + " " + A + "= " + p + " : " + f + " " + A + " " + p + " ) || " + f + " !== " + f + ") { var op" + a + " = " + C + " ? '" + x + "' : '" + x + "='; ", l === void 0 && (b = d, u = e.errSchemaPath + "/" + d, p = v, h = y);
  } else {
    var w = typeof g == "number", I = x;
    if (w && h) {
      var B = "'" + I + "'";
      n += " if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), n += " ( " + p + " === undefined || " + g + " " + x + "= " + p + " ? " + f + " " + A + "= " + g + " : " + f + " " + A + " " + p + " ) || " + f + " !== " + f + ") { ";
    } else {
      w && l === void 0 ? (C = !0, b = d, u = e.errSchemaPath + "/" + d, p = g, A += "=") : (w && (p = Math[m ? "min" : "max"](g, l)), g === (w ? p : !0) ? (C = !0, b = d, u = e.errSchemaPath + "/" + d, A += "=") : (C = !1, I += "="));
      var B = "'" + I + "'";
      n += " if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), n += " " + f + " " + A + " " + p + " || " + f + " !== " + f + ") { ";
    }
  }
  b = b || r;
  var _ = _ || [];
  _.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (b || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + B + ", limit: " + p + ", exclusive: " + C + " } ", e.opts.messages !== !1 && (n += " , message: 'should be " + I + " ", h ? n += "' + " + p : n += "" + p + "'"), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + l, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var S = n;
  return n = _.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + S + "]); " : n += " validate.errors = [" + S + "]; return false; " : n += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c && (n += " else { "), n;
}, rg = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, d, f = "data" + (o || ""), h = e.opts.$data && l && l.$data, p;
  if (h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l, !(h || typeof l == "number"))
    throw new Error(r + " must be number");
  var m = r == "maxItems" ? ">" : "<";
  n += "if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), n += " " + f + ".length " + m + " " + p + ") { ";
  var d = r, g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (d || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have ", r == "maxItems" ? n += "more" : n += "fewer", n += " than ", h ? n += "' + " + p + " + '" : n += "" + l, n += " items' "), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + l, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var y = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, ng = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, d, f = "data" + (o || ""), h = e.opts.$data && l && l.$data, p;
  if (h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l, !(h || typeof l == "number"))
    throw new Error(r + " must be number");
  var m = r == "maxLength" ? ">" : "<";
  n += "if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), e.opts.unicode === !1 ? n += " " + f + ".length " : n += " ucs2length(" + f + ") ", n += " " + m + " " + p + ") { ";
  var d = r, g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (d || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT be ", r == "maxLength" ? n += "longer" : n += "shorter", n += " than ", h ? n += "' + " + p + " + '" : n += "" + l, n += " characters' "), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + l, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var y = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, sg = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, d, f = "data" + (o || ""), h = e.opts.$data && l && l.$data, p;
  if (h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l, !(h || typeof l == "number"))
    throw new Error(r + " must be number");
  var m = r == "maxProperties" ? ">" : "<";
  n += "if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "), n += " Object.keys(" + f + ").length " + m + " " + p + ") { ";
  var d = r, g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (d || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have ", r == "maxProperties" ? n += "more" : n += "fewer", n += " than ", h ? n += "' + " + p + " + '" : n += "" + l, n += " properties' "), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + l, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var y = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, tI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = e.opts.$data && l && l.$data, p;
  if (h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l, !(h || typeof l == "number"))
    throw new Error(r + " must be number");
  n += "var division" + a + ";if (", h && (n += " " + p + " !== undefined && ( typeof " + p + " != 'number' || "), n += " (division" + a + " = " + f + " / " + p + ", ", e.opts.multipleOfPrecision ? n += " Math.abs(Math.round(division" + a + ") - division" + a + ") > 1e-" + e.opts.multipleOfPrecision + " " : n += " division" + a + " !== parseInt(division" + a + ") ", n += " ) ", h && (n += "  )  "), n += " ) {   ";
  var m = m || [];
  m.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { multipleOf: " + p + " } ", e.opts.messages !== !1 && (n += " , message: 'should be multiple of ", h ? n += "' + " + p : n += "" + p + "'"), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + l, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var d = n;
  return n = m.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + d + "]); " : n += " validate.errors = [" + d + "]; return false; " : n += " var err = " + d + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, rI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "errs__" + a, p = e.util.copy(e);
  p.level++;
  var m = "valid" + p.level;
  if (e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all)) {
    p.schema = l, p.schemaPath = i, p.errSchemaPath = u, n += " var " + h + " = errors;  ";
    var d = e.compositeRule;
    e.compositeRule = p.compositeRule = !0, p.createErrors = !1;
    var g;
    p.opts.allErrors && (g = p.opts.allErrors, p.opts.allErrors = !1), n += " " + e.validate(p) + " ", p.createErrors = !0, g && (p.opts.allErrors = g), e.compositeRule = p.compositeRule = d, n += " if (" + m + ") {   ";
    var y = y || [];
    y.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should NOT be valid' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
    var x = n;
    n = y.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + x + "]); " : n += " validate.errors = [" + x + "]; return false; " : n += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } ", e.opts.allErrors && (n += " } ");
  } else
    n += "  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should NOT be valid' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c && (n += " if (false) { ");
  return n;
}, nI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = "errs__" + a, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, y = m.baseId, x = "prevValid" + a, A = "passingSchemas" + a;
  n += "var " + p + " = errors , " + x + " = false , " + h + " = false , " + A + " = null; ";
  var b = e.compositeRule;
  e.compositeRule = m.compositeRule = !0;
  var v = l;
  if (v)
    for (var C, T = -1, w = v.length - 1; T < w; )
      C = v[T += 1], (e.opts.strictKeywords ? typeof C == "object" && Object.keys(C).length > 0 || C === !1 : e.util.schemaHasRules(C, e.RULES.all)) ? (m.schema = C, m.schemaPath = i + "[" + T + "]", m.errSchemaPath = u + "/" + T, n += "  " + e.validate(m) + " ", m.baseId = y) : n += " var " + g + " = true; ", T && (n += " if (" + g + " && " + x + ") { " + h + " = false; " + A + " = [" + A + ", " + T + "]; } else { ", d += "}"), n += " if (" + g + ") { " + h + " = " + x + " = true; " + A + " = " + T + "; }";
  return e.compositeRule = m.compositeRule = b, n += "" + d + "if (!" + h + ") {   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { passingSchemas: " + A + " } ", e.opts.messages !== !1 && (n += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += "} else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; }", e.opts.allErrors && (n += " } "), n;
}, sI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = e.opts.$data && l && l.$data, p;
  h ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", p = "schema" + a) : p = l;
  var m = h ? "(new RegExp(" + p + "))" : e.usePattern(l);
  n += "if ( ", h && (n += " (" + p + " !== undefined && typeof " + p + " != 'string') || "), n += " !" + m + ".test(" + f + ") ) {   ";
  var d = d || [];
  d.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { pattern:  ", h ? n += "" + p : n += "" + e.util.toQuotedString(l), n += "  } ", e.opts.messages !== !1 && (n += ` , message: 'should match pattern "`, h ? n += "' + " + p + " + '" : n += "" + e.util.escapeQuotes(l), n += `"' `), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + i : n += "" + e.util.toQuotedString(l), n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var g = n;
  return n = d.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + g + "]); " : n += " validate.errors = [" + g + "]; return false; " : n += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, aI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "errs__" + a, p = e.util.copy(e), m = "";
  p.level++;
  var d = "valid" + p.level, g = "key" + a, y = "idx" + a, x = p.dataLevel = e.dataLevel + 1, A = "data" + x, b = "dataProperties" + a, v = Object.keys(l || {}).filter(z), C = e.schema.patternProperties || {}, T = Object.keys(C).filter(z), w = e.schema.additionalProperties, B = v.length || T.length, I = w === !1, _ = typeof w == "object" && Object.keys(w).length, S = e.opts.removeAdditional, F = I || _ || S, N = e.opts.ownProperties, k = e.baseId, j = e.schema.required;
  if (j && !(e.opts.$data && j.$data) && j.length < e.opts.loopRequired)
    var O = e.util.toHash(j);
  function z(Er) {
    return Er !== "__proto__";
  }
  if (n += "var " + h + " = errors;var " + d + " = true;", N && (n += " var " + b + " = undefined;"), F) {
    if (N ? n += " " + b + " = " + b + " || Object.keys(" + f + "); for (var " + y + "=0; " + y + "<" + b + ".length; " + y + "++) { var " + g + " = " + b + "[" + y + "]; " : n += " for (var " + g + " in " + f + ") { ", B) {
      if (n += " var isAdditional" + a + " = !(false ", v.length)
        if (v.length > 8)
          n += " || validate.schema" + i + ".hasOwnProperty(" + g + ") ";
        else {
          var te = v;
          if (te)
            for (var se, ye = -1, Se = te.length - 1; ye < Se; )
              se = te[ye += 1], n += " || " + g + " == " + e.util.toQuotedString(se) + " ";
        }
      if (T.length) {
        var xe = T;
        if (xe)
          for (var Ae, _e = -1, H = xe.length - 1; _e < H; )
            Ae = xe[_e += 1], n += " || " + e.usePattern(Ae) + ".test(" + g + ") ";
      }
      n += " ); if (isAdditional" + a + ") { ";
    }
    if (S == "all")
      n += " delete " + f + "[" + g + "]; ";
    else {
      var Q = e.errorPath, ge = "' + " + g + " + '";
      if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers)), I)
        if (S)
          n += " delete " + f + "[" + g + "]; ";
        else {
          n += " " + d + " = false; ";
          var ae = u;
          u = e.errSchemaPath + "/additionalProperties";
          var ee = ee || [];
          ee.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { additionalProperty: '" + ge + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is an invalid additional property" : n += "should NOT have additional properties", n += "' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
          var he = n;
          n = ee.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + he + "]); " : n += " validate.errors = [" + he + "]; return false; " : n += " var err = " + he + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u = ae, c && (n += " break; ");
        }
      else if (_)
        if (S == "failing") {
          n += " var " + h + " = errors;  ";
          var R = e.compositeRule;
          e.compositeRule = p.compositeRule = !0, p.schema = w, p.schemaPath = e.schemaPath + ".additionalProperties", p.errSchemaPath = e.errSchemaPath + "/additionalProperties", p.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers);
          var D = f + "[" + g + "]";
          p.dataPathArr[x] = g;
          var U = e.validate(p);
          p.baseId = k, e.util.varOccurences(U, A) < 2 ? n += " " + e.util.varReplace(U, A, D) + " " : n += " var " + A + " = " + D + "; " + U + " ", n += " if (!" + d + ") { errors = " + h + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + f + "[" + g + "]; }  ", e.compositeRule = p.compositeRule = R;
        } else {
          p.schema = w, p.schemaPath = e.schemaPath + ".additionalProperties", p.errSchemaPath = e.errSchemaPath + "/additionalProperties", p.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers);
          var D = f + "[" + g + "]";
          p.dataPathArr[x] = g;
          var U = e.validate(p);
          p.baseId = k, e.util.varOccurences(U, A) < 2 ? n += " " + e.util.varReplace(U, A, D) + " " : n += " var " + A + " = " + D + "; " + U + " ", c && (n += " if (!" + d + ") break; ");
        }
      e.errorPath = Q;
    }
    B && (n += " } "), n += " }  ", c && (n += " if (" + d + ") { ", m += "}");
  }
  var ne = e.opts.useDefaults && !e.compositeRule;
  if (v.length) {
    var pe = v;
    if (pe)
      for (var se, Ee = -1, Re = pe.length - 1; Ee < Re; ) {
        se = pe[Ee += 1];
        var We = l[se];
        if (e.opts.strictKeywords ? typeof We == "object" && Object.keys(We).length > 0 || We === !1 : e.util.schemaHasRules(We, e.RULES.all)) {
          var wt = e.util.getProperty(se), D = f + wt, Lt = ne && We.default !== void 0;
          p.schema = We, p.schemaPath = i + wt, p.errSchemaPath = u + "/" + e.util.escapeFragment(se), p.errorPath = e.util.getPath(e.errorPath, se, e.opts.jsonPointers), p.dataPathArr[x] = e.util.toQuotedString(se);
          var U = e.validate(p);
          if (p.baseId = k, e.util.varOccurences(U, A) < 2) {
            U = e.util.varReplace(U, A, D);
            var et = D;
          } else {
            var et = A;
            n += " var " + A + " = " + D + "; ";
          }
          if (Lt)
            n += " " + U + " ";
          else {
            if (O && O[se]) {
              n += " if ( " + et + " === undefined ", N && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(se) + "') "), n += ") { " + d + " = false; ";
              var Q = e.errorPath, ae = u, Ge = e.util.escapeQuotes(se);
              e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(Q, se, e.opts.jsonPointers)), u = e.errSchemaPath + "/required";
              var ee = ee || [];
              ee.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + Ge + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + Ge + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
              var he = n;
              n = ee.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + he + "]); " : n += " validate.errors = [" + he + "]; return false; " : n += " var err = " + he + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u = ae, e.errorPath = Q, n += " } else { ";
            } else
              c ? (n += " if ( " + et + " === undefined ", N && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(se) + "') "), n += ") { " + d + " = true; } else { ") : (n += " if (" + et + " !== undefined ", N && (n += " &&   Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(se) + "') "), n += " ) { ");
            n += " " + U + " } ";
          }
        }
        c && (n += " if (" + d + ") { ", m += "}");
      }
  }
  if (T.length) {
    var mt = T;
    if (mt)
      for (var Ae, tr = -1, vr = mt.length - 1; tr < vr; ) {
        Ae = mt[tr += 1];
        var We = C[Ae];
        if (e.opts.strictKeywords ? typeof We == "object" && Object.keys(We).length > 0 || We === !1 : e.util.schemaHasRules(We, e.RULES.all)) {
          p.schema = We, p.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(Ae), p.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(Ae), N ? n += " " + b + " = " + b + " || Object.keys(" + f + "); for (var " + y + "=0; " + y + "<" + b + ".length; " + y + "++) { var " + g + " = " + b + "[" + y + "]; " : n += " for (var " + g + " in " + f + ") { ", n += " if (" + e.usePattern(Ae) + ".test(" + g + ")) { ", p.errorPath = e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers);
          var D = f + "[" + g + "]";
          p.dataPathArr[x] = g;
          var U = e.validate(p);
          p.baseId = k, e.util.varOccurences(U, A) < 2 ? n += " " + e.util.varReplace(U, A, D) + " " : n += " var " + A + " = " + D + "; " + U + " ", c && (n += " if (!" + d + ") break; "), n += " } ", c && (n += " else " + d + " = true; "), n += " }  ", c && (n += " if (" + d + ") { ", m += "}");
        }
      }
  }
  return c && (n += " " + m + " if (" + h + " == errors) {"), n;
}, iI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "errs__" + a, p = e.util.copy(e), m = "";
  p.level++;
  var d = "valid" + p.level;
  if (n += "var " + h + " = errors;", e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all)) {
    p.schema = l, p.schemaPath = i, p.errSchemaPath = u;
    var g = "key" + a, y = "idx" + a, x = "i" + a, A = "' + " + g + " + '", b = p.dataLevel = e.dataLevel + 1, v = "data" + b, C = "dataProperties" + a, T = e.opts.ownProperties, w = e.baseId;
    T && (n += " var " + C + " = undefined; "), T ? n += " " + C + " = " + C + " || Object.keys(" + f + "); for (var " + y + "=0; " + y + "<" + C + ".length; " + y + "++) { var " + g + " = " + C + "[" + y + "]; " : n += " for (var " + g + " in " + f + ") { ", n += " var startErrs" + a + " = errors; ";
    var B = g, I = e.compositeRule;
    e.compositeRule = p.compositeRule = !0;
    var _ = e.validate(p);
    p.baseId = w, e.util.varOccurences(_, v) < 2 ? n += " " + e.util.varReplace(_, v, B) + " " : n += " var " + v + " = " + B + "; " + _ + " ", e.compositeRule = p.compositeRule = I, n += " if (!" + d + ") { for (var " + x + "=startErrs" + a + "; " + x + "<errors; " + x + "++) { vErrors[" + x + "].propertyName = " + g + "; }   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { propertyName: '" + A + "' } ", e.opts.messages !== !1 && (n += " , message: 'property name \\'" + A + "\\' is invalid' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), c && (n += " break; "), n += " } }";
  }
  return c && (n += " " + m + " if (" + h + " == errors) {"), n;
}, oI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = e.opts.$data && l && l.$data;
  p && (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ");
  var m = "schema" + a;
  if (!p)
    if (l.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
      var d = [], g = l;
      if (g)
        for (var y, x = -1, A = g.length - 1; x < A; ) {
          y = g[x += 1];
          var b = e.schema.properties[y];
          b && (e.opts.strictKeywords ? typeof b == "object" && Object.keys(b).length > 0 || b === !1 : e.util.schemaHasRules(b, e.RULES.all)) || (d[d.length] = y);
        }
    } else
      var d = l;
  if (p || d.length) {
    var v = e.errorPath, C = p || d.length >= e.opts.loopRequired, T = e.opts.ownProperties;
    if (c)
      if (n += " var missing" + a + "; ", C) {
        p || (n += " var " + m + " = validate.schema" + i + "; ");
        var w = "i" + a, B = "schema" + a + "[" + w + "]", I = "' + " + B + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(v, B, e.opts.jsonPointers)), n += " var " + h + " = true; ", p && (n += " if (schema" + a + " === undefined) " + h + " = true; else if (!Array.isArray(schema" + a + ")) " + h + " = false; else {"), n += " for (var " + w + " = 0; " + w + " < " + m + ".length; " + w + "++) { " + h + " = " + f + "[" + m + "[" + w + "]] !== undefined ", T && (n += " &&   Object.prototype.hasOwnProperty.call(" + f + ", " + m + "[" + w + "]) "), n += "; if (!" + h + ") break; } ", p && (n += "  }  "), n += "  if (!" + h + ") {   ";
        var _ = _ || [];
        _.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
        var S = n;
        n = _.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + S + "]); " : n += " validate.errors = [" + S + "]; return false; " : n += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ";
      } else {
        n += " if ( ";
        var F = d;
        if (F)
          for (var N, w = -1, k = F.length - 1; w < k; ) {
            N = F[w += 1], w && (n += " || ");
            var j = e.util.getProperty(N), O = f + j;
            n += " ( ( " + O + " === undefined ", T && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(N) + "') "), n += ") && (missing" + a + " = " + e.util.toQuotedString(e.opts.jsonPointers ? N : j) + ") ) ";
          }
        n += ") {  ";
        var B = "missing" + a, I = "' + " + B + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(v, B, !0) : v + " + " + B);
        var _ = _ || [];
        _.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
        var S = n;
        n = _.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + S + "]); " : n += " validate.errors = [" + S + "]; return false; " : n += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ";
      }
    else if (C) {
      p || (n += " var " + m + " = validate.schema" + i + "; ");
      var w = "i" + a, B = "schema" + a + "[" + w + "]", I = "' + " + B + " + '";
      e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(v, B, e.opts.jsonPointers)), p && (n += " if (" + m + " && !Array.isArray(" + m + ")) {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + m + " !== undefined) { "), n += " for (var " + w + " = 0; " + w + " < " + m + ".length; " + w + "++) { if (" + f + "[" + m + "[" + w + "]] === undefined ", T && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", " + m + "[" + w + "]) "), n += ") {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", p && (n += "  }  ");
    } else {
      var z = d;
      if (z)
        for (var N, te = -1, se = z.length - 1; te < se; ) {
          N = z[te += 1];
          var j = e.util.getProperty(N), I = e.util.escapeQuotes(N), O = f + j;
          e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(v, N, e.opts.jsonPointers)), n += " if ( " + O + " === undefined ", T && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(N) + "') "), n += ") {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
        }
    }
    e.errorPath = v;
  } else
    c && (n += " if (true) {");
  return n;
}, lI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (o || ""), h = "valid" + a, p = e.opts.$data && l && l.$data, m;
  if (p ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", m = "schema" + a) : m = l, (l || p) && e.opts.uniqueItems !== !1) {
    p && (n += " var " + h + "; if (" + m + " === false || " + m + " === undefined) " + h + " = true; else if (typeof " + m + " != 'boolean') " + h + " = false; else { "), n += " var i = " + f + ".length , " + h + " = true , j; if (i > 1) { ";
    var d = e.schema.items && e.schema.items.type, g = Array.isArray(d);
    if (!d || d == "object" || d == "array" || g && (d.indexOf("object") >= 0 || d.indexOf("array") >= 0))
      n += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + f + "[i], " + f + "[j])) { " + h + " = false; break outer; } } } ";
    else {
      n += " var itemIndices = {}, item; for (;i--;) { var item = " + f + "[i]; ";
      var y = "checkDataType" + (g ? "s" : "");
      n += " if (" + e.util[y](d, "item", e.opts.strictNumbers, !0) + ") continue; ", g && (n += ` if (typeof item == 'string') item = '"' + item; `), n += " if (typeof itemIndices[item] == 'number') { " + h + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
    }
    n += " } ", p && (n += "  }  "), n += " if (!" + h + ") {   ";
    var x = x || [];
    x.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { i: i, j: j } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + i : n += "" + l, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
    var A = n;
    n = x.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c && (n += " else { ");
  } else
    c && (n += " if (true) { ");
  return n;
}, uI = {
  $ref: WP,
  allOf: zP,
  anyOf: GP,
  $comment: HP,
  const: KP,
  contains: JP,
  dependencies: XP,
  enum: QP,
  format: YP,
  if: ZP,
  items: eI,
  maximum: tg,
  minimum: tg,
  maxItems: rg,
  minItems: rg,
  maxLength: ng,
  minLength: ng,
  maxProperties: sg,
  minProperties: sg,
  multipleOf: tI,
  not: rI,
  oneOf: nI,
  pattern: sI,
  properties: aI,
  propertyNames: iI,
  required: oI,
  uniqueItems: lI,
  validate: Av
}, ag = uI, oo = cs.toHash, cI = function() {
  var e = [
    {
      type: "number",
      rules: [
        { maximum: ["exclusiveMaximum"] },
        { minimum: ["exclusiveMinimum"] },
        "multipleOf",
        "format"
      ]
    },
    {
      type: "string",
      rules: ["maxLength", "minLength", "pattern", "format"]
    },
    {
      type: "array",
      rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
    },
    {
      type: "object",
      rules: [
        "maxProperties",
        "minProperties",
        "required",
        "dependencies",
        "propertyNames",
        { properties: ["additionalProperties", "patternProperties"] }
      ]
    },
    { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
  ], r = ["type", "$comment"], s = [
    "$schema",
    "$id",
    "id",
    "$data",
    "$async",
    "title",
    "description",
    "default",
    "definitions",
    "examples",
    "readOnly",
    "writeOnly",
    "contentMediaType",
    "contentEncoding",
    "additionalItems",
    "then",
    "else"
  ], n = ["number", "integer", "string", "array", "object", "boolean", "null"];
  return e.all = oo(r), e.types = oo(n), e.forEach(function(a) {
    a.rules = a.rules.map(function(o) {
      var l;
      if (typeof o == "object") {
        var i = Object.keys(o)[0];
        l = o[i], o = i, l.forEach(function(c) {
          r.push(c), e.all[c] = !0;
        });
      }
      r.push(o);
      var u = e.all[o] = {
        keyword: o,
        code: ag[o],
        implements: l
      };
      return u;
    }), e.all.$comment = {
      keyword: "$comment",
      code: ag.$comment
    }, a.type && (e.types[a.type] = a);
  }), e.keywords = oo(r.concat(s)), e.custom = {}, e;
}, ig = [
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "additionalItems",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "additionalProperties",
  "enum",
  "format",
  "const"
], pI = function(t, e) {
  for (var r = 0; r < e.length; r++) {
    t = JSON.parse(JSON.stringify(t));
    var s = e[r].split("/"), n = t, a;
    for (a = 1; a < s.length; a++)
      n = n[s[a]];
    for (a = 0; a < ig.length; a++) {
      var o = ig[a], l = n[o];
      l && (n[o] = {
        anyOf: [
          l,
          { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
        ]
      });
    }
  }
  return t;
}, fI = Tu.MissingRef, hI = jv;
function jv(t, e, r) {
  var s = this;
  if (typeof this._opts.loadSchema != "function")
    throw new Error("options.loadSchema should be a function");
  typeof e == "function" && (r = e, e = void 0);
  var n = a(t).then(function() {
    var l = s._addSchema(t, void 0, e);
    return l.validate || o(l);
  });
  return r && n.then(
    function(l) {
      r(null, l);
    },
    r
  ), n;
  function a(l) {
    var i = l.$schema;
    return i && !s.getSchema(i) ? jv.call(s, { $ref: i }, !0) : Promise.resolve();
  }
  function o(l) {
    try {
      return s._compile(l);
    } catch (u) {
      if (u instanceof fI)
        return i(u);
      throw u;
    }
    function i(u) {
      var c = u.missingSchema;
      if (p(c))
        throw new Error("Schema " + c + " is loaded but " + u.missingRef + " cannot be resolved");
      var f = s._loadingSchemas[c];
      return f || (f = s._loadingSchemas[c] = s._opts.loadSchema(c), f.then(h, h)), f.then(function(m) {
        if (!p(c))
          return a(m).then(function() {
            p(c) || s.addSchema(m, c, void 0, e);
          });
      }).then(function() {
        return o(l);
      });
      function h() {
        delete s._loadingSchemas[c];
      }
      function p(m) {
        return s._refs[m] || s._schemas[m];
      }
    }
  }
}
var mI = function(e, r, s) {
  var n = " ", a = e.level, o = e.dataLevel, l = e.schema[r], i = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f, h = "data" + (o || ""), p = "valid" + a, m = "errs__" + a, d = e.opts.$data && l && l.$data, g;
  d ? (n += " var schema" + a + " = " + e.util.getData(l.$data, o, e.dataPathArr) + "; ", g = "schema" + a) : g = l;
  var y = this, x = "definition" + a, A = y.definition, b = "", v, C, T, w, B;
  if (d && A.$data) {
    B = "keywordValidate" + a;
    var I = A.validateSchema;
    n += " var " + x + " = RULES.custom['" + r + "'].definition; var " + B + " = " + x + ".validate;";
  } else {
    if (w = e.useCustomRule(y, l, e.schema, e), !w)
      return;
    g = "validate.schema" + i, B = w.code, v = A.compile, C = A.inline, T = A.macro;
  }
  var _ = B + ".errors", S = "i" + a, F = "ruleErr" + a, N = A.async;
  if (N && !e.async)
    throw new Error("async keyword in sync schema");
  if (C || T || (n += "" + _ + " = null;"), n += "var " + m + " = errors;var " + p + ";", d && A.$data && (b += "}", n += " if (" + g + " === undefined) { " + p + " = true; } else { ", I && (b += "}", n += " " + p + " = " + x + ".validateSchema(" + g + "); if (" + p + ") { ")), C)
    A.statements ? n += " " + w.validate + " " : n += " " + p + " = " + w.validate + "; ";
  else if (T) {
    var k = e.util.copy(e), b = "";
    k.level++;
    var j = "valid" + k.level;
    k.schema = w.validate, k.schemaPath = "";
    var O = e.compositeRule;
    e.compositeRule = k.compositeRule = !0;
    var z = e.validate(k).replace(/validate\.schema/g, B);
    e.compositeRule = k.compositeRule = O, n += " " + z;
  } else {
    var te = te || [];
    te.push(n), n = "", n += "  " + B + ".call( ", e.opts.passContext ? n += "this" : n += "self", v || A.schema === !1 ? n += " , " + h + " " : n += " , " + g + " , " + h + " , validate.schema" + e.schemaPath + " ", n += " , (dataPath || '')", e.errorPath != '""' && (n += " + " + e.errorPath);
    var se = o ? "data" + (o - 1 || "") : "parentData", ye = o ? e.dataPathArr[o] : "parentDataProperty";
    n += " , " + se + " , " + ye + " , rootData )  ";
    var Se = n;
    n = te.pop(), A.errors === !1 ? (n += " " + p + " = ", N && (n += "await "), n += "" + Se + "; ") : N ? (_ = "customErrors" + a, n += " var " + _ + " = null; try { " + p + " = await " + Se + "; } catch (e) { " + p + " = false; if (e instanceof ValidationError) " + _ + " = e.errors; else throw e; } ") : n += " " + _ + " = null; " + p + " = " + Se + "; ";
  }
  if (A.modifying && (n += " if (" + se + ") " + h + " = " + se + "[" + ye + "];"), n += "" + b, A.valid)
    c && (n += " if (true) { ");
  else {
    n += " if ( ", A.valid === void 0 ? (n += " !", T ? n += "" + j : n += "" + p) : n += " " + !A.valid + " ", n += ") { ", f = y.keyword;
    var te = te || [];
    te.push(n), n = "";
    var te = te || [];
    te.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (f || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + y.keyword + "' } ", e.opts.messages !== !1 && (n += ` , message: 'should pass "` + y.keyword + `" keyword validation' `), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), n += " } ") : n += " {} ";
    var xe = n;
    n = te.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + xe + "]); " : n += " validate.errors = [" + xe + "]; return false; " : n += " var err = " + xe + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    var Ae = n;
    n = te.pop(), C ? A.errors ? A.errors != "full" && (n += "  for (var " + S + "=" + m + "; " + S + "<errors; " + S + "++) { var " + F + " = vErrors[" + S + "]; if (" + F + ".dataPath === undefined) " + F + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + F + ".schemaPath === undefined) { " + F + '.schemaPath = "' + u + '"; } ', e.opts.verbose && (n += " " + F + ".schema = " + g + "; " + F + ".data = " + h + "; "), n += " } ") : A.errors === !1 ? n += " " + Ae + " " : (n += " if (" + m + " == errors) { " + Ae + " } else {  for (var " + S + "=" + m + "; " + S + "<errors; " + S + "++) { var " + F + " = vErrors[" + S + "]; if (" + F + ".dataPath === undefined) " + F + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + F + ".schemaPath === undefined) { " + F + '.schemaPath = "' + u + '"; } ', e.opts.verbose && (n += " " + F + ".schema = " + g + "; " + F + ".data = " + h + "; "), n += " } } ") : T ? (n += "   var err =   ", e.createErrors !== !1 ? (n += " { keyword: '" + (f || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + y.keyword + "' } ", e.opts.messages !== !1 && (n += ` , message: 'should pass "` + y.keyword + `" keyword validation' `), e.opts.verbose && (n += " , schema: validate.schema" + i + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; ")) : A.errors === !1 ? n += " " + Ae + " " : (n += " if (Array.isArray(" + _ + ")) { if (vErrors === null) vErrors = " + _ + "; else vErrors = vErrors.concat(" + _ + "); errors = vErrors.length;  for (var " + S + "=" + m + "; " + S + "<errors; " + S + "++) { var " + F + " = vErrors[" + S + "]; if (" + F + ".dataPath === undefined) " + F + ".dataPath = (dataPath || '') + " + e.errorPath + ";  " + F + '.schemaPath = "' + u + '";  ', e.opts.verbose && (n += " " + F + ".schema = " + g + "; " + F + ".data = " + h + "; "), n += " } } else { " + Ae + " } "), n += " } ", c && (n += " else { ");
  }
  return n;
}, dI = "http://json-schema.org/draft-07/schema#", gI = "http://json-schema.org/draft-07/schema#", yI = "Core schema meta-schema", xI = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, vI = [
  "object",
  "boolean"
], EI = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, Mv = {
  $schema: dI,
  $id: gI,
  title: yI,
  definitions: xI,
  type: vI,
  properties: EI,
  default: !0
}, og = Mv, bI = {
  $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
  definitions: {
    simpleTypes: og.definitions.simpleTypes
  },
  type: "object",
  dependencies: {
    schema: ["validate"],
    $data: ["validate"],
    statements: ["inline"],
    valid: { not: { required: ["macro"] } }
  },
  properties: {
    type: og.properties.type,
    schema: { type: "boolean" },
    statements: { type: "boolean" },
    dependencies: {
      type: "array",
      items: { type: "string" }
    },
    metaSchema: { type: "object" },
    modifying: { type: "boolean" },
    valid: { type: "boolean" },
    $data: { type: "boolean" },
    async: { type: "boolean" },
    errors: {
      anyOf: [
        { type: "boolean" },
        { const: "full" }
      ]
    }
  }
}, CI = /^[a-z_$][a-z0-9_$-]*$/i, SI = mI, AI = bI, DI = {
  add: wI,
  get: kI,
  remove: TI,
  validate: El
};
function wI(t, e) {
  var r = this.RULES;
  if (r.keywords[t])
    throw new Error("Keyword " + t + " is already defined");
  if (!CI.test(t))
    throw new Error("Keyword " + t + " is not a valid identifier");
  if (e) {
    this.validateKeyword(e, !0);
    var s = e.type;
    if (Array.isArray(s))
      for (var n = 0; n < s.length; n++)
        o(t, s[n], e);
    else
      o(t, s, e);
    var a = e.metaSchema;
    a && (e.$data && this._opts.$data && (a = {
      anyOf: [
        a,
        { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
      ]
    }), e.validateSchema = this.compile(a, !0));
  }
  r.keywords[t] = r.all[t] = !0;
  function o(l, i, u) {
    for (var c, f = 0; f < r.length; f++) {
      var h = r[f];
      if (h.type == i) {
        c = h;
        break;
      }
    }
    c || (c = { type: i, rules: [] }, r.push(c));
    var p = {
      keyword: l,
      definition: u,
      custom: !0,
      code: SI,
      implements: u.implements
    };
    c.rules.push(p), r.custom[l] = p;
  }
  return this;
}
function kI(t) {
  var e = this.RULES.custom[t];
  return e ? e.definition : this.RULES.keywords[t] || !1;
}
function TI(t) {
  var e = this.RULES;
  delete e.keywords[t], delete e.all[t], delete e.custom[t];
  for (var r = 0; r < e.length; r++)
    for (var s = e[r].rules, n = 0; n < s.length; n++)
      if (s[n].keyword == t) {
        s.splice(n, 1);
        break;
      }
  return this;
}
function El(t, e) {
  El.errors = null;
  var r = this._validateKeyword = this._validateKeyword || this.compile(AI, !0);
  if (r(t))
    return !0;
  if (El.errors = r.errors, e)
    throw new Error("custom keyword definition is invalid: " + this.errorsText(r.errors));
  return !1;
}
var FI = "http://json-schema.org/draft-07/schema#", PI = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", II = "Meta-schema for $data reference (JSON Schema extension proposal)", _I = "object", BI = [
  "$data"
], OI = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, LI = !1, RI = {
  $schema: FI,
  $id: PI,
  description: II,
  type: _I,
  required: BI,
  properties: OI,
  additionalProperties: LI
}, $v = AP, wn = ku, NI = kv.exports, Vv = vv, jI = Sv, MI = NP, $I = cI, Uv = pI, qv = cs, VI = yt;
yt.prototype.validate = qI;
yt.prototype.compile = WI;
yt.prototype.addSchema = zI;
yt.prototype.addMetaSchema = GI;
yt.prototype.validateSchema = HI;
yt.prototype.getSchema = JI;
yt.prototype.removeSchema = QI;
yt.prototype.addFormat = a_;
yt.prototype.errorsText = s_;
yt.prototype._addSchema = YI;
yt.prototype._compile = ZI;
yt.prototype.compileAsync = hI;
var Fi = DI;
yt.prototype.addKeyword = Fi.add;
yt.prototype.getKeyword = Fi.get;
yt.prototype.removeKeyword = Fi.remove;
yt.prototype.validateKeyword = Fi.validate;
var Wv = Tu;
yt.ValidationError = Wv.Validation;
yt.MissingRefError = Wv.MissingRef;
yt.$dataMetaSchema = Uv;
var Qa = "http://json-schema.org/draft-07/schema", lg = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], UI = ["/properties"];
function yt(t) {
  if (!(this instanceof yt))
    return new yt(t);
  t = this._opts = qv.copy(t) || {}, p_(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = MI(t.format), this._cache = t.cache || new NI(), this._loadingSchemas = {}, this._compilations = [], this.RULES = $I(), this._getId = e_(t), t.loopRequired = t.loopRequired || 1 / 0, t.errorDataPath == "property" && (t._errorDataPathProperty = !0), t.serialize === void 0 && (t.serialize = jI), this._metaOpts = c_(this), t.formats && l_(this), t.keywords && u_(this), i_(this), typeof t.meta == "object" && this.addMetaSchema(t.meta), t.nullable && this.addKeyword("nullable", { metaSchema: { type: "boolean" } }), o_(this);
}
function qI(t, e) {
  var r;
  if (typeof t == "string") {
    if (r = this.getSchema(t), !r)
      throw new Error('no schema with key or ref "' + t + '"');
  } else {
    var s = this._addSchema(t);
    r = s.validate || this._compile(s);
  }
  var n = r(e);
  return r.$async !== !0 && (this.errors = r.errors), n;
}
function WI(t, e) {
  var r = this._addSchema(t, void 0, e);
  return r.validate || this._compile(r);
}
function zI(t, e, r, s) {
  if (Array.isArray(t)) {
    for (var n = 0; n < t.length; n++)
      this.addSchema(t[n], void 0, r, s);
    return this;
  }
  var a = this._getId(t);
  if (a !== void 0 && typeof a != "string")
    throw new Error("schema id must be string");
  return e = wn.normalizeId(e || a), Gv(this, e), this._schemas[e] = this._addSchema(t, r, s, !0), this;
}
function GI(t, e, r) {
  return this.addSchema(t, e, r, !0), this;
}
function HI(t, e) {
  var r = t.$schema;
  if (r !== void 0 && typeof r != "string")
    throw new Error("$schema must be a string");
  if (r = r || this._opts.defaultMeta || KI(this), !r)
    return this.logger.warn("meta-schema not available"), this.errors = null, !0;
  var s = this.validate(r, t);
  if (!s && e) {
    var n = "schema is invalid: " + this.errorsText();
    if (this._opts.validateSchema == "log")
      this.logger.error(n);
    else
      throw new Error(n);
  }
  return s;
}
function KI(t) {
  var e = t._opts.meta;
  return t._opts.defaultMeta = typeof e == "object" ? t._getId(e) || e : t.getSchema(Qa) ? Qa : void 0, t._opts.defaultMeta;
}
function JI(t) {
  var e = zv(this, t);
  switch (typeof e) {
    case "object":
      return e.validate || this._compile(e);
    case "string":
      return this.getSchema(e);
    case "undefined":
      return XI(this, t);
  }
}
function XI(t, e) {
  var r = wn.schema.call(t, { schema: {} }, e);
  if (r) {
    var s = r.schema, n = r.root, a = r.baseId, o = $v.call(t, s, n, void 0, a);
    return t._fragments[e] = new Vv({
      ref: e,
      fragment: !0,
      schema: s,
      root: n,
      baseId: a,
      validate: o
    }), o;
  }
}
function zv(t, e) {
  return e = wn.normalizeId(e), t._schemas[e] || t._refs[e] || t._fragments[e];
}
function QI(t) {
  if (t instanceof RegExp)
    return ca(this, this._schemas, t), ca(this, this._refs, t), this;
  switch (typeof t) {
    case "undefined":
      return ca(this, this._schemas), ca(this, this._refs), this._cache.clear(), this;
    case "string":
      var e = zv(this, t);
      return e && this._cache.del(e.cacheKey), delete this._schemas[t], delete this._refs[t], this;
    case "object":
      var r = this._opts.serialize, s = r ? r(t) : t;
      this._cache.del(s);
      var n = this._getId(t);
      n && (n = wn.normalizeId(n), delete this._schemas[n], delete this._refs[n]);
  }
  return this;
}
function ca(t, e, r) {
  for (var s in e) {
    var n = e[s];
    !n.meta && (!r || r.test(s)) && (t._cache.del(n.cacheKey), delete e[s]);
  }
}
function YI(t, e, r, s) {
  if (typeof t != "object" && typeof t != "boolean")
    throw new Error("schema should be object or boolean");
  var n = this._opts.serialize, a = n ? n(t) : t, o = this._cache.get(a);
  if (o)
    return o;
  s = s || this._opts.addUsedSchema !== !1;
  var l = wn.normalizeId(this._getId(t));
  l && s && Gv(this, l);
  var i = this._opts.validateSchema !== !1 && !e, u;
  i && !(u = l && l == wn.normalizeId(t.$schema)) && this.validateSchema(t, !0);
  var c = wn.ids.call(this, t), f = new Vv({
    id: l,
    schema: t,
    localRefs: c,
    cacheKey: a,
    meta: r
  });
  return l[0] != "#" && s && (this._refs[l] = f), this._cache.put(a, f), i && u && this.validateSchema(t, !0), f;
}
function ZI(t, e) {
  if (t.compiling)
    return t.validate = n, n.schema = t.schema, n.errors = null, n.root = e || n, t.schema.$async === !0 && (n.$async = !0), n;
  t.compiling = !0;
  var r;
  t.meta && (r = this._opts, this._opts = this._metaOpts);
  var s;
  try {
    s = $v.call(this, t.schema, e, t.localRefs);
  } catch (a) {
    throw delete t.validate, a;
  } finally {
    t.compiling = !1, t.meta && (this._opts = r);
  }
  return t.validate = s, t.refs = s.refs, t.refVal = s.refVal, t.root = s.root, s;
  function n() {
    var a = t.validate, o = a.apply(this, arguments);
    return n.errors = a.errors, o;
  }
}
function e_(t) {
  switch (t.schemaId) {
    case "auto":
      return n_;
    case "id":
      return t_;
    default:
      return r_;
  }
}
function t_(t) {
  return t.$id && this.logger.warn("schema $id ignored", t.$id), t.id;
}
function r_(t) {
  return t.id && this.logger.warn("schema id ignored", t.id), t.$id;
}
function n_(t) {
  if (t.$id && t.id && t.$id != t.id)
    throw new Error("schema $id is different from id");
  return t.$id || t.id;
}
function s_(t, e) {
  if (t = t || this.errors, !t)
    return "No errors";
  e = e || {};
  for (var r = e.separator === void 0 ? ", " : e.separator, s = e.dataVar === void 0 ? "data" : e.dataVar, n = "", a = 0; a < t.length; a++) {
    var o = t[a];
    o && (n += s + o.dataPath + " " + o.message + r);
  }
  return n.slice(0, -r.length);
}
function a_(t, e) {
  return typeof e == "string" && (e = new RegExp(e)), this._formats[t] = e, this;
}
function i_(t) {
  var e;
  if (t._opts.$data && (e = RI, t.addMetaSchema(e, e.$id, !0)), t._opts.meta !== !1) {
    var r = Mv;
    t._opts.$data && (r = Uv(r, UI)), t.addMetaSchema(r, Qa, !0), t._refs["http://json-schema.org/schema"] = Qa;
  }
}
function o_(t) {
  var e = t._opts.schemas;
  if (e)
    if (Array.isArray(e))
      t.addSchema(e);
    else
      for (var r in e)
        t.addSchema(e[r], r);
}
function l_(t) {
  for (var e in t._opts.formats) {
    var r = t._opts.formats[e];
    t.addFormat(e, r);
  }
}
function u_(t) {
  for (var e in t._opts.keywords) {
    var r = t._opts.keywords[e];
    t.addKeyword(e, r);
  }
}
function Gv(t, e) {
  if (t._schemas[e] || t._refs[e])
    throw new Error('schema with key or id "' + e + '" already exists');
}
function c_(t) {
  for (var e = qv.copy(t._opts), r = 0; r < lg.length; r++)
    delete e[lg[r]];
  return e;
}
function p_(t) {
  var e = t._opts.logger;
  if (e === !1)
    t.logger = { log: lo, warn: lo, error: lo };
  else {
    if (e === void 0 && (e = console), !(typeof e == "object" && e.log && e.warn && e.error))
      throw new Error("logger must implement log, warn and error methods");
    t.logger = e;
  }
}
function lo() {
}
var f_ = "http://json-schema.org/draft-04/schema#", h_ = "http://json-schema.org/draft-04/schema#", m_ = "Core schema meta-schema", d_ = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, g_ = "object", y_ = {
  id: {
    type: "string"
  },
  $schema: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, x_ = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, v_ = {
  id: f_,
  $schema: h_,
  description: m_,
  definitions: d_,
  type: g_,
  properties: y_,
  dependencies: x_,
  default: {}
};
const E_ = VI, ug = v_;
var b_ = (t = {}) => {
  const e = new E_({
    meta: !1,
    useDefaults: !0,
    validateSchema: !1,
    missingRefs: "ignore",
    verbose: !0,
    schemaId: "auto",
    ...t
  });
  return e.addMetaSchema(ug), e._opts.defaultMeta = ug.id, e;
};
const C_ = Zx, S_ = VF, A_ = Kx, D_ = Eu.exports, { emitDeprecationWarning: w_ } = zF, cg = b_(), uo = /* @__PURE__ */ new WeakMap(), pg = Function.prototype;
let pa;
const k_ = {
  error: 2,
  warn: 1,
  off: 0
}, fg = /* @__PURE__ */ new WeakSet();
var T_ = class {
  constructor({ builtInRules: e = /* @__PURE__ */ new Map() } = {}) {
    this.builtInRules = e;
  }
  /**
   * Gets a complete options schema for a rule.
   * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
   * @returns {Object} JSON Schema for the rule's options.
   */
  getRuleOptionsSchema(e) {
    if (!e)
      return null;
    const r = e.schema || e.meta && e.meta.schema;
    return Array.isArray(r) ? r.length ? {
      type: "array",
      items: r,
      minItems: 0,
      maxItems: r.length
    } : {
      type: "array",
      minItems: 0,
      maxItems: 0
    } : r || null;
  }
  /**
   * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
   * @param {options} options The given options for the rule.
   * @returns {number|string} The rule's severity value
   */
  validateRuleSeverity(e) {
    const r = Array.isArray(e) ? e[0] : e, s = typeof r == "string" ? k_[r.toLowerCase()] : r;
    if (s === 0 || s === 1 || s === 2)
      return s;
    throw new Error(`	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${C_.inspect(r).replace(/'/gu, '"').replace(/\n/gu, "")}').
`);
  }
  /**
   * Validates the non-severity options passed to a rule, based on its schema.
   * @param {{create: Function}} rule The rule to validate
   * @param {Array} localOptions The options for the rule, excluding severity
   * @returns {void}
   */
  validateRuleSchema(e, r) {
    if (!uo.has(e)) {
      const n = this.getRuleOptionsSchema(e);
      n && uo.set(e, cg.compile(n));
    }
    const s = uo.get(e);
    if (s && (s(r), s.errors))
      throw new Error(s.errors.map(
        (n) => `	Value ${JSON.stringify(n.data)} ${n.message}.
`
      ).join(""));
  }
  /**
   * Validates a rule's options against its schema.
   * @param {{create: Function}|null} rule The rule that the config is being validated for
   * @param {string} ruleId The rule's unique name.
   * @param {Array|number} options The given options for the rule.
   * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
   * no source is prepended to the message.
   * @returns {void}
   */
  validateRuleOptions(e, r, s, n = null) {
    try {
      this.validateRuleSeverity(s) !== 0 && this.validateRuleSchema(e, Array.isArray(s) ? s.slice(1) : []);
    } catch (a) {
      const o = `Configuration for rule "${r}" is invalid:
${a.message}`;
      throw typeof n == "string" ? new Error(`${n}:
	${o}`) : new Error(o);
    }
  }
  /**
   * Validates an environment object
   * @param {Object} environment The environment config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.
   * @returns {void}
   */
  validateEnvironment(e, r, s = pg) {
    e && Object.keys(e).forEach((n) => {
      if (!(s(n) || A_.get(n) || null)) {
        const o = `${r}:
	Environment key "${n}" is unknown
`;
        throw new Error(o);
      }
    });
  }
  /**
   * Validates a rules config object
   * @param {Object} rulesConfig The rules config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules
   * @returns {void}
   */
  validateRules(e, r, s = pg) {
    e && Object.keys(e).forEach((n) => {
      const a = s(n) || this.builtInRules.get(n) || null;
      this.validateRuleOptions(a, n, e[n], r);
    });
  }
  /**
   * Validates a `globals` section of a config file
   * @param {Object} globalsConfig The `globals` section
   * @param {string|null} source The name of the configuration source to report in the event of an error.
   * @returns {void}
   */
  validateGlobals(e, r = null) {
    e && Object.entries(e).forEach(([s, n]) => {
      try {
        D_.normalizeConfigGlobal(n);
      } catch (a) {
        throw new Error(`ESLint configuration of global '${s}' in ${r} is invalid:
${a.message}`);
      }
    });
  }
  /**
   * Validate `processor` configuration.
   * @param {string|undefined} processorName The processor name.
   * @param {string} source The name of config file.
   * @param {function(id:string): Processor} getProcessor The getter of defined processors.
   * @returns {void}
   */
  validateProcessor(e, r, s) {
    if (e && !s(e))
      throw new Error(`ESLint configuration of processor in '${r}' is invalid: '${e}' was not found.`);
  }
  /**
   * Formats an array of schema validation errors.
   * @param {Array} errors An array of error messages to format.
   * @returns {string} Formatted error message
   */
  formatErrors(e) {
    return e.map((r) => {
      if (r.keyword === "additionalProperties")
        return `Unexpected top-level property "${r.dataPath.length ? `${r.dataPath.slice(1)}.${r.params.additionalProperty}` : r.params.additionalProperty}"`;
      if (r.keyword === "type") {
        const n = r.dataPath.slice(1), a = Array.isArray(r.schema) ? r.schema.join("/") : r.schema, o = JSON.stringify(r.data);
        return `Property "${n}" is the wrong type (expected ${a} but got \`${o}\`)`;
      }
      return `"${r.dataPath[0] === "." ? r.dataPath.slice(1) : r.dataPath}" ${r.message}. Value: ${JSON.stringify(r.data)}`;
    }).map((r) => `	- ${r}.
`).join("");
  }
  /**
   * Validates the top level properties of the config object.
   * @param {Object} config The config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @returns {void}
   */
  validateConfigSchema(e, r = null) {
    if (pa = pa || cg.compile(S_), !pa(e))
      throw new Error(`ESLint configuration in ${r} is invalid:
${this.formatErrors(pa.errors)}`);
    Object.hasOwnProperty.call(e, "ecmaFeatures") && w_(r, "ESLINT_LEGACY_ECMAFEATURES");
  }
  /**
   * Validates an entire config object.
   * @param {Object} config The config object to validate.
   * @param {string} source The name of the configuration source to report in any errors.
   * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.
   * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.
   * @returns {void}
   */
  validate(e, r, s, n) {
    this.validateConfigSchema(e, r), this.validateRules(e.rules, r, s), this.validateEnvironment(e.env, r, n), this.validateGlobals(e.globals, r);
    for (const a of e.overrides || [])
      this.validateRules(a.rules, r, s), this.validateEnvironment(a.env, r, n), this.validateGlobals(e.globals, r);
  }
  /**
   * Validate config array object.
   * @param {ConfigArray} configArray The config array to validate.
   * @returns {void}
   */
  validateConfigArray(e) {
    const r = Map.prototype.get.bind(e.pluginEnvironments), s = Map.prototype.get.bind(e.pluginProcessors), n = Map.prototype.get.bind(e.pluginRules);
    for (const a of e)
      fg.has(a) || (fg.add(a), this.validateEnvironment(a.env, a.name, r), this.validateGlobals(a.globals, a.name), this.validateProcessor(a.processor, a.name, s), this.validateRules(a.rules, a.name, n));
  }
};
/*! @author Toru Nagashima <https://github.com/mysticatea> */
function Pu(t, e) {
  const r = e.range[0];
  let s = t, n = !1;
  do {
    n = !1;
    for (const a of s.childScopes) {
      const o = a.block.range;
      if (o[0] <= r && r < o[1]) {
        s = a, n = !0;
        break;
      }
    }
  } while (n);
  return s;
}
function Yn(t, e) {
  let r = "", s = t;
  for (typeof e == "string" ? r = e : (r = e.name, s = Pu(s, e)); s != null; ) {
    const n = s.set.get(r);
    if (n != null)
      return n;
    s = s.upper;
  }
  return null;
}
function F_(t) {
  return !this(t);
}
function xr(t) {
  return F_.bind(t);
}
function Pi(t) {
  return t.value === "=>" && t.type === "Punctuator";
}
function Iu(t) {
  return t.value === "," && t.type === "Punctuator";
}
function _u(t) {
  return t.value === ";" && t.type === "Punctuator";
}
function Bu(t) {
  return t.value === ":" && t.type === "Punctuator";
}
function an(t) {
  return t.value === "(" && t.type === "Punctuator";
}
function Ii(t) {
  return t.value === ")" && t.type === "Punctuator";
}
function Ou(t) {
  return t.value === "[" && t.type === "Punctuator";
}
function Lu(t) {
  return t.value === "]" && t.type === "Punctuator";
}
function Ru(t) {
  return t.value === "{" && t.type === "Punctuator";
}
function Nu(t) {
  return t.value === "}" && t.type === "Punctuator";
}
function ju(t) {
  return t.type === "Line" || t.type === "Block" || t.type === "Shebang";
}
const Hv = xr(Pi), Kv = xr(Iu), Jv = xr(_u), Xv = xr(Bu), Qv = xr(an), Yv = xr(Ii), Zv = xr(Ou), eE = xr(Lu), tE = xr(Ru), rE = xr(Nu), nE = xr(ju);
function hg(t, e) {
  return t.id ? e.getTokenAfter(t.id, an) : e.getFirstToken(t, an);
}
function sE(t, e) {
  const r = t.parent;
  let s = null, n = null;
  if (t.type === "ArrowFunctionExpression") {
    const a = e.getTokenBefore(t.body, Pi);
    s = a.loc.start, n = a.loc.end;
  } else
    r.type === "Property" || r.type === "MethodDefinition" ? (s = r.loc.start, n = hg(t, e).loc.start) : (s = t.loc.start, n = hg(t, e).loc.start);
  return {
    start: Object.assign({}, s),
    end: Object.assign({}, n)
  };
}
const mg = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}, P_ = Object.freeze(
  /* @__PURE__ */ new Set([
    "Array",
    "ArrayBuffer",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "Boolean",
    "DataView",
    "Date",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "Float32Array",
    "Float64Array",
    "Function",
    "Infinity",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "isFinite",
    "isNaN",
    "isPrototypeOf",
    "JSON",
    "Map",
    "Math",
    "NaN",
    "Number",
    "Object",
    "parseFloat",
    "parseInt",
    "Promise",
    "Proxy",
    "Reflect",
    "RegExp",
    "Set",
    "String",
    "Symbol",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "undefined",
    "unescape",
    "WeakMap",
    "WeakSet"
  ])
), co = new Set(
  [
    Array.isArray,
    typeof BigInt == "function" ? BigInt : void 0,
    Boolean,
    Date,
    Date.parse,
    decodeURI,
    decodeURIComponent,
    encodeURI,
    encodeURIComponent,
    escape,
    isFinite,
    isNaN,
    isPrototypeOf,
    ...Object.getOwnPropertyNames(Math).map((t) => Math[t]).filter((t) => typeof t == "function"),
    Number,
    Number.isFinite,
    Number.isNaN,
    Number.parseFloat,
    Number.parseInt,
    Object,
    Object.entries,
    Object.is,
    Object.isExtensible,
    Object.isFrozen,
    Object.isSealed,
    Object.keys,
    Object.values,
    parseFloat,
    parseInt,
    RegExp,
    String,
    String.fromCharCode,
    String.fromCodePoint,
    String.raw,
    Symbol,
    Symbol.for,
    Symbol.keyFor,
    unescape
  ].filter((t) => typeof t == "function")
), dg = /* @__PURE__ */ new Set([
  Object.freeze,
  Object.preventExtensions,
  Object.seal
]);
function I_(t, e) {
  let r = t;
  for (; (typeof r == "object" || typeof r == "function") && r !== null; ) {
    const s = Object.getOwnPropertyDescriptor(r, e);
    if (s)
      return s;
    r = Object.getPrototypeOf(r);
  }
  return null;
}
function __(t, e) {
  const r = I_(t, e);
  return r != null && r.get != null;
}
function ds(t, e) {
  const r = [];
  for (let s = 0; s < t.length; ++s) {
    const n = t[s];
    if (n == null)
      r.length = s + 1;
    else if (n.type === "SpreadElement") {
      const a = it(n.argument, e);
      if (a == null)
        return null;
      r.push(...a.value);
    } else {
      const a = it(n, e);
      if (a == null)
        return null;
      r.push(a.value);
    }
  }
  return r;
}
const gg = Object.freeze({
  ArrayExpression(t, e) {
    const r = ds(t.elements, e);
    return r != null ? { value: r } : null;
  },
  AssignmentExpression(t, e) {
    return t.operator === "=" ? it(t.right, e) : null;
  },
  //eslint-disable-next-line complexity
  BinaryExpression(t, e) {
    if (t.operator === "in" || t.operator === "instanceof")
      return null;
    const r = it(t.left, e), s = it(t.right, e);
    if (r != null && s != null)
      switch (t.operator) {
        case "==":
          return { value: r.value == s.value };
        case "!=":
          return { value: r.value != s.value };
        case "===":
          return { value: r.value === s.value };
        case "!==":
          return { value: r.value !== s.value };
        case "<":
          return { value: r.value < s.value };
        case "<=":
          return { value: r.value <= s.value };
        case ">":
          return { value: r.value > s.value };
        case ">=":
          return { value: r.value >= s.value };
        case "<<":
          return { value: r.value << s.value };
        case ">>":
          return { value: r.value >> s.value };
        case ">>>":
          return { value: r.value >>> s.value };
        case "+":
          return { value: r.value + s.value };
        case "-":
          return { value: r.value - s.value };
        case "*":
          return { value: r.value * s.value };
        case "/":
          return { value: r.value / s.value };
        case "%":
          return { value: r.value % s.value };
        case "**":
          return { value: Math.pow(r.value, s.value) };
        case "|":
          return { value: r.value | s.value };
        case "^":
          return { value: r.value ^ s.value };
        case "&":
          return { value: r.value & s.value };
      }
    return null;
  },
  CallExpression(t, e) {
    const r = t.callee, s = ds(t.arguments, e);
    if (s != null)
      if (r.type === "MemberExpression") {
        const n = it(r.object, e);
        if (n != null) {
          if (n.value == null && (n.optional || t.optional))
            return { value: void 0, optional: !0 };
          const a = r.computed ? it(r.property, e) : { value: r.property.name };
          if (a != null) {
            const o = n.value, l = a.value;
            if (co.has(o[l]))
              return { value: o[l](...s) };
            if (dg.has(o[l]))
              return { value: s[0] };
          }
        }
      } else {
        const n = it(r, e);
        if (n != null) {
          if (n.value == null && t.optional)
            return { value: void 0, optional: !0 };
          const a = n.value;
          if (co.has(a))
            return { value: a(...s) };
          if (dg.has(a))
            return { value: s[0] };
        }
      }
    return null;
  },
  ConditionalExpression(t, e) {
    const r = it(t.test, e);
    return r != null ? r.value ? it(t.consequent, e) : it(t.alternate, e) : null;
  },
  ExpressionStatement(t, e) {
    return it(t.expression, e);
  },
  Identifier(t, e) {
    if (e != null) {
      const r = Yn(e, t);
      if (r != null && r.defs.length === 0 && P_.has(r.name) && r.name in mg)
        return { value: mg[r.name] };
      if (r != null && r.defs.length === 1) {
        const s = r.defs[0];
        if (s.parent && s.parent.kind === "const" && // TODO(mysticatea): don't support destructuring here.
        s.node.id.type === "Identifier")
          return it(s.node.init, e);
      }
    }
    return null;
  },
  Literal(t) {
    return (t.regex != null || t.bigint != null) && t.value == null ? null : { value: t.value };
  },
  LogicalExpression(t, e) {
    const r = it(t.left, e);
    if (r != null) {
      if (t.operator === "||" && r.value || t.operator === "&&" && !r.value || t.operator === "??" && r.value != null)
        return r;
      const s = it(t.right, e);
      if (s != null)
        return s;
    }
    return null;
  },
  MemberExpression(t, e) {
    const r = it(t.object, e);
    if (r != null) {
      if (r.value == null && (r.optional || t.optional))
        return { value: void 0, optional: !0 };
      const s = t.computed ? it(t.property, e) : { value: t.property.name };
      if (s != null && !__(r.value, s.value))
        return { value: r.value[s.value] };
    }
    return null;
  },
  ChainExpression(t, e) {
    const r = it(t.expression, e);
    return r != null ? { value: r.value } : null;
  },
  NewExpression(t, e) {
    const r = it(t.callee, e), s = ds(t.arguments, e);
    if (r != null && s != null) {
      const n = r.value;
      if (co.has(n))
        return { value: new n(...s) };
    }
    return null;
  },
  ObjectExpression(t, e) {
    const r = {};
    for (const s of t.properties)
      if (s.type === "Property") {
        if (s.kind !== "init")
          return null;
        const n = s.computed ? it(s.key, e) : { value: s.key.name }, a = it(s.value, e);
        if (n == null || a == null)
          return null;
        r[n.value] = a.value;
      } else if (s.type === "SpreadElement" || s.type === "ExperimentalSpreadProperty") {
        const n = it(
          s.argument,
          e
        );
        if (n == null)
          return null;
        Object.assign(r, n.value);
      } else
        return null;
    return { value: r };
  },
  SequenceExpression(t, e) {
    const r = t.expressions[t.expressions.length - 1];
    return it(r, e);
  },
  TaggedTemplateExpression(t, e) {
    const r = it(t.tag, e), s = ds(
      t.quasi.expressions,
      e
    );
    if (r != null && s != null) {
      const n = r.value, a = t.quasi.quasis.map((o) => o.value.cooked);
      if (a.raw = t.quasi.quasis.map((o) => o.value.raw), n === String.raw)
        return { value: n(a, ...s) };
    }
    return null;
  },
  TemplateLiteral(t, e) {
    const r = ds(t.expressions, e);
    if (r != null) {
      let s = t.quasis[0].value.cooked;
      for (let n = 0; n < r.length; ++n)
        s += r[n], s += t.quasis[n + 1].value.cooked;
      return { value: s };
    }
    return null;
  },
  UnaryExpression(t, e) {
    if (t.operator === "delete")
      return null;
    if (t.operator === "void")
      return { value: void 0 };
    const r = it(t.argument, e);
    if (r != null)
      switch (t.operator) {
        case "-":
          return { value: -r.value };
        case "+":
          return { value: +r.value };
        case "!":
          return { value: !r.value };
        case "~":
          return { value: ~r.value };
        case "typeof":
          return { value: typeof r.value };
      }
    return null;
  }
});
function it(t, e) {
  return t != null && Object.hasOwnProperty.call(gg, t.type) ? gg[t.type](t, e) : null;
}
function Mu(t, e = null) {
  try {
    return it(t, e);
  } catch {
    return null;
  }
}
function $s(t, e = null) {
  if (t && t.type === "Literal" && t.value === null) {
    if (t.regex)
      return `/${t.regex.pattern}/${t.regex.flags}`;
    if (t.bigint)
      return t.bigint;
  }
  const r = Mu(t, e);
  return r && String(r.value);
}
function Vs(t, e) {
  switch (t.type) {
    case "MemberExpression":
      return t.computed ? $s(t.property, e) : t.property.name;
    case "Property":
    case "MethodDefinition":
      return t.computed ? $s(t.key, e) : t.key.type === "Literal" ? String(t.key.value) : t.key.name;
  }
  return null;
}
function aE(t) {
  const e = t.parent, r = [];
  if (e.type === "MethodDefinition" && e.static && r.push("static"), t.async && r.push("async"), t.generator && r.push("generator"), t.type === "ArrowFunctionExpression")
    r.push("arrow", "function");
  else if (e.type === "Property" || e.type === "MethodDefinition") {
    if (e.kind === "constructor")
      return "constructor";
    e.kind === "get" ? r.push("getter") : e.kind === "set" ? r.push("setter") : r.push("method");
  } else
    r.push("function");
  if (t.id)
    r.push(`'${t.id.name}'`);
  else {
    const s = Vs(e);
    s && r.push(`'${s}'`);
  }
  return t.type === "ArrowFunctionExpression" && (e.type === "VariableDeclarator" && e.id && e.id.type === "Identifier" && r.push(`'${e.id.name}'`), e.type === "AssignmentExpression" && e.left && e.left.type === "Identifier" && r.push(`'${e.left.name}'`)), r.join(" ");
}
const B_ = Object.freeze(
  /* @__PURE__ */ new Set([
    "==",
    "!=",
    "<",
    "<=",
    ">",
    ">=",
    "<<",
    ">>",
    ">>>",
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "^",
    "&",
    "in"
  ])
), O_ = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
function yg(t) {
  return t !== null && typeof t == "object" && typeof t.type == "string";
}
const L_ = Object.freeze(
  Object.assign(/* @__PURE__ */ Object.create(null), {
    $visit(t, e, r) {
      const { type: s } = t;
      return typeof this[s] == "function" ? this[s](t, e, r) : this.$visitChildren(t, e, r);
    },
    $visitChildren(t, e, r) {
      const { type: s } = t;
      for (const n of r[s] || du.getKeys(t)) {
        const a = t[n];
        if (Array.isArray(a)) {
          for (const o of a)
            if (yg(o) && this.$visit(o, e, r))
              return !0;
        } else if (yg(a) && this.$visit(a, e, r))
          return !0;
      }
      return !1;
    },
    ArrowFunctionExpression() {
      return !1;
    },
    AssignmentExpression() {
      return !0;
    },
    AwaitExpression() {
      return !0;
    },
    BinaryExpression(t, e, r) {
      return e.considerImplicitTypeConversion && B_.has(t.operator) && (t.left.type !== "Literal" || t.right.type !== "Literal") ? !0 : this.$visitChildren(t, e, r);
    },
    CallExpression() {
      return !0;
    },
    FunctionExpression() {
      return !1;
    },
    ImportExpression() {
      return !0;
    },
    MemberExpression(t, e, r) {
      return e.considerGetters || e.considerImplicitTypeConversion && t.computed && t.property.type !== "Literal" ? !0 : this.$visitChildren(t, e, r);
    },
    MethodDefinition(t, e, r) {
      return e.considerImplicitTypeConversion && t.computed && t.key.type !== "Literal" ? !0 : this.$visitChildren(t, e, r);
    },
    NewExpression() {
      return !0;
    },
    Property(t, e, r) {
      return e.considerImplicitTypeConversion && t.computed && t.key.type !== "Literal" ? !0 : this.$visitChildren(t, e, r);
    },
    UnaryExpression(t, e, r) {
      return t.operator === "delete" || e.considerImplicitTypeConversion && O_.has(t.operator) && t.argument.type !== "Literal" ? !0 : this.$visitChildren(t, e, r);
    },
    UpdateExpression() {
      return !0;
    },
    YieldExpression() {
      return !0;
    }
  })
);
function iE(t, e, { considerGetters: r = !1, considerImplicitTypeConversion: s = !1 } = {}) {
  return L_.$visit(
    t,
    { considerGetters: r, considerImplicitTypeConversion: s },
    e.visitorKeys || du.KEYS
  );
}
function R_(t, e) {
  const r = t.parent;
  switch (r.type) {
    case "CallExpression":
    case "NewExpression":
      return r.arguments.length === 1 && r.arguments[0] === t ? e.getTokenAfter(
        r.callee,
        an
      ) : null;
    case "DoWhileStatement":
      return r.test === t ? e.getTokenAfter(
        r.body,
        an
      ) : null;
    case "IfStatement":
    case "WhileStatement":
      return r.test === t ? e.getFirstToken(r, 1) : null;
    case "ImportExpression":
      return r.source === t ? e.getFirstToken(r, 1) : null;
    case "SwitchStatement":
      return r.discriminant === t ? e.getFirstToken(r, 1) : null;
    case "WithStatement":
      return r.object === t ? e.getFirstToken(r, 1) : null;
    default:
      return null;
  }
}
function oE(t, e, r) {
  let s, n, a, o, l;
  if (typeof t == "number") {
    if (s = t | 0, n = e, a = r, !(s >= 1))
      throw new TypeError("'times' should be a positive integer.");
  } else
    s = 1, n = t, a = e;
  if (n == null)
    return !1;
  o = l = n;
  do
    o = a.getTokenBefore(o), l = a.getTokenAfter(l);
  while (o != null && l != null && an(o) && Ii(l) && // Avoid false positive such as `if (a) {}`
  o !== R_(n, a) && --s > 0);
  return s === 0;
}
const N_ = /\$(?:[$&`']|[1-9][0-9]?)/gu, xg = /* @__PURE__ */ new WeakMap();
function j_(t, e) {
  let r = !1;
  for (let s = e - 1; s >= 0 && t.charCodeAt(s) === 92; --s)
    r = !r;
  return r;
}
function M_(t, e, r) {
  const s = [];
  let n = 0, a = null;
  function o(l) {
    switch (l) {
      case "$$":
        return "$";
      case "$&":
        return a[0];
      case "$`":
        return e.slice(0, a.index);
      case "$'":
        return e.slice(a.index + a[0].length);
      default: {
        const i = l.slice(1);
        return i in a ? a[i] : l;
      }
    }
  }
  for (a of t.execAll(e))
    s.push(e.slice(n, a.index)), s.push(r.replace(N_, o)), n = a.index + a[0].length;
  return s.push(e.slice(n)), s.join("");
}
function $_(t, e, r) {
  const s = [];
  let n = 0;
  for (const a of t.execAll(e))
    s.push(e.slice(n, a.index)), s.push(String(r(...a, a.index, a.input))), n = a.index + a[0].length;
  return s.push(e.slice(n)), s.join("");
}
class lE {
  /**
   * Initialize this matcher.
   * @param {RegExp} pattern The pattern to match.
   * @param {{escaped:boolean}} options The options.
   */
  constructor(e, { escaped: r = !1 } = {}) {
    if (!(e instanceof RegExp))
      throw new TypeError("'pattern' should be a RegExp instance.");
    if (!e.flags.includes("g"))
      throw new Error("'pattern' should contains 'g' flag.");
    xg.set(this, {
      pattern: new RegExp(e.source, e.flags),
      escaped: !!r
    });
  }
  /**
   * Find the pattern in a given string.
   * @param {string} str The string to find.
   * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
   */
  *execAll(e) {
    const { pattern: r, escaped: s } = xg.get(this);
    let n = null, a = 0;
    for (r.lastIndex = 0; (n = r.exec(e)) != null; )
      (s || !j_(e, n.index)) && (a = r.lastIndex, yield n, r.lastIndex = a);
  }
  /**
   * Check whether the pattern is found in a given string.
   * @param {string} str The string to check.
   * @returns {boolean} `true` if the pattern was found in the string.
   */
  test(e) {
    return !this.execAll(e).next().done;
  }
  /**
   * Replace a given string.
   * @param {string} str The string to be replaced.
   * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
   * @returns {string} The replaced string.
   */
  [Symbol.replace](e, r) {
    return typeof r == "function" ? $_(this, String(e), r) : M_(this, String(e), String(r));
  }
}
const V_ = /^(?:Import|Export(?:All|Default|Named))Declaration$/u, gn = Function.call.bind(Object.hasOwnProperty), rt = Symbol("read"), kn = Symbol("call"), Zn = Symbol("construct"), _i = Symbol("esm"), U_ = { require: { [kn]: !0 } };
function vg(t) {
  return t == null || t.defs.length !== 0 || t.references.some((e) => e.isWrite());
}
function q_(t) {
  const e = t.parent;
  switch (e && e.type) {
    case "ConditionalExpression":
      return e.consequent === t || e.alternate === t;
    case "LogicalExpression":
      return !0;
    case "SequenceExpression":
      return e.expressions[e.expressions.length - 1] === t;
    case "ChainExpression":
      return !0;
    default:
      return !1;
  }
}
let ps = class {
  /**
   * Initialize this tracker.
   * @param {Scope} globalScope The global scope.
   * @param {object} [options] The options.
   * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
   * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
   */
  constructor(e, {
    mode: r = "strict",
    globalObjectNames: s = ["global", "globalThis", "self", "window"]
  } = {}) {
    this.variableStack = [], this.globalScope = e, this.mode = r, this.globalObjectNames = s.slice(0);
  }
  /**
   * Iterate the references of global variables.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateGlobalReferences(e) {
    for (const r of Object.keys(e)) {
      const s = e[r], n = [r], a = this.globalScope.set.get(r);
      vg(a) || (yield* this._iterateVariableReferences(
        a,
        n,
        s,
        !0
      ));
    }
    for (const r of this.globalObjectNames) {
      const s = [], n = this.globalScope.set.get(r);
      vg(n) || (yield* this._iterateVariableReferences(
        n,
        s,
        e,
        !1
      ));
    }
  }
  /**
   * Iterate the references of CommonJS modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateCjsReferences(e) {
    for (const { node: r } of this.iterateGlobalReferences(U_)) {
      const s = $s(r.arguments[0]);
      if (s == null || !gn(e, s))
        continue;
      const n = e[s], a = [s];
      n[rt] && (yield {
        node: r,
        path: a,
        type: rt,
        info: n[rt]
      }), yield* this._iteratePropertyReferences(r, a, n);
    }
  }
  /**
   * Iterate the references of ES modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateEsmReferences(e) {
    const r = this.globalScope.block;
    for (const s of r.body) {
      if (!V_.test(s.type) || s.source == null)
        continue;
      const n = s.source.value;
      if (!gn(e, n))
        continue;
      const a = e[n], o = [n];
      if (a[rt] && (yield { node: s, path: o, type: rt, info: a[rt] }), s.type === "ExportAllDeclaration")
        for (const l of Object.keys(a)) {
          const i = a[l];
          i[rt] && (yield {
            node: s,
            path: o.concat(l),
            type: rt,
            info: i[rt]
          });
        }
      else
        for (const l of s.specifiers) {
          const i = gn(a, _i), u = this._iterateImportReferences(
            l,
            o,
            i ? a : this.mode === "legacy" ? Object.assign(
              { default: a },
              a
            ) : { default: a }
          );
          if (i)
            yield* u;
          else
            for (const c of u)
              c.path = c.path.filter(W_), (c.path.length >= 2 || c.type !== rt) && (yield c);
        }
    }
  }
  /**
   * Iterate the references for a given variable.
   * @param {Variable} variable The variable to iterate that references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @param {boolean} shouldReport = The flag to report those references.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateVariableReferences(e, r, s, n) {
    if (!this.variableStack.includes(e)) {
      this.variableStack.push(e);
      try {
        for (const a of e.references) {
          if (!a.isRead())
            continue;
          const o = a.identifier;
          n && s[rt] && (yield { node: o, path: r, type: rt, info: s[rt] }), yield* this._iteratePropertyReferences(o, r, s);
        }
      } finally {
        this.variableStack.pop();
      }
    }
  }
  /**
   * Iterate the references for a given AST node.
   * @param rootNode The AST node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  //eslint-disable-next-line complexity
  *_iteratePropertyReferences(e, r, s) {
    let n = e;
    for (; q_(n); )
      n = n.parent;
    const a = n.parent;
    if (a.type === "MemberExpression") {
      if (a.object === n) {
        const o = Vs(a);
        if (o == null || !gn(s, o))
          return;
        r = r.concat(o);
        const l = s[o];
        l[rt] && (yield {
          node: a,
          path: r,
          type: rt,
          info: l[rt]
        }), yield* this._iteratePropertyReferences(
          a,
          r,
          l
        );
      }
      return;
    }
    if (a.type === "CallExpression") {
      a.callee === n && s[kn] && (yield { node: a, path: r, type: kn, info: s[kn] });
      return;
    }
    if (a.type === "NewExpression") {
      a.callee === n && s[Zn] && (yield {
        node: a,
        path: r,
        type: Zn,
        info: s[Zn]
      });
      return;
    }
    if (a.type === "AssignmentExpression") {
      a.right === n && (yield* this._iterateLhsReferences(a.left, r, s), yield* this._iteratePropertyReferences(a, r, s));
      return;
    }
    if (a.type === "AssignmentPattern") {
      a.right === n && (yield* this._iterateLhsReferences(a.left, r, s));
      return;
    }
    a.type === "VariableDeclarator" && a.init === n && (yield* this._iterateLhsReferences(a.id, r, s));
  }
  /**
   * Iterate the references for a given Pattern node.
   * @param {Node} patternNode The Pattern node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateLhsReferences(e, r, s) {
    if (e.type === "Identifier") {
      const n = Yn(this.globalScope, e);
      n != null && (yield* this._iterateVariableReferences(
        n,
        r,
        s,
        !1
      ));
      return;
    }
    if (e.type === "ObjectPattern") {
      for (const n of e.properties) {
        const a = Vs(n);
        if (a == null || !gn(s, a))
          continue;
        const o = r.concat(a), l = s[a];
        l[rt] && (yield {
          node: n,
          path: o,
          type: rt,
          info: l[rt]
        }), yield* this._iterateLhsReferences(
          n.value,
          o,
          l
        );
      }
      return;
    }
    e.type === "AssignmentPattern" && (yield* this._iterateLhsReferences(e.left, r, s));
  }
  /**
   * Iterate the references for a given ModuleSpecifier node.
   * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateImportReferences(e, r, s) {
    const n = e.type;
    if (n === "ImportSpecifier" || n === "ImportDefaultSpecifier") {
      const a = n === "ImportDefaultSpecifier" ? "default" : e.imported.name;
      if (!gn(s, a))
        return;
      r = r.concat(a);
      const o = s[a];
      o[rt] && (yield {
        node: e,
        path: r,
        type: rt,
        info: o[rt]
      }), yield* this._iterateVariableReferences(
        Yn(this.globalScope, e.local),
        r,
        o,
        !1
      );
      return;
    }
    if (n === "ImportNamespaceSpecifier") {
      yield* this._iterateVariableReferences(
        Yn(this.globalScope, e.local),
        r,
        s,
        !1
      );
      return;
    }
    if (n === "ExportSpecifier") {
      const a = e.local.name;
      if (!gn(s, a))
        return;
      r = r.concat(a);
      const o = s[a];
      o[rt] && (yield {
        node: e,
        path: r,
        type: rt,
        info: o[rt]
      });
    }
  }
};
ps.READ = rt;
ps.CALL = kn;
ps.CONSTRUCT = Zn;
ps.ESM = _i;
function W_(t, e) {
  return !(e === 1 && t === "default");
}
var z_ = {
  CALL: kn,
  CONSTRUCT: Zn,
  ESM: _i,
  findVariable: Yn,
  getFunctionHeadLocation: sE,
  getFunctionNameWithKind: aE,
  getInnermostScope: Pu,
  getPropertyName: Vs,
  getStaticValue: Mu,
  getStringIfConstant: $s,
  hasSideEffect: iE,
  isArrowToken: Pi,
  isClosingBraceToken: Nu,
  isClosingBracketToken: Lu,
  isClosingParenToken: Ii,
  isColonToken: Bu,
  isCommaToken: Iu,
  isCommentToken: ju,
  isNotArrowToken: Hv,
  isNotClosingBraceToken: rE,
  isNotClosingBracketToken: eE,
  isNotClosingParenToken: Yv,
  isNotColonToken: Xv,
  isNotCommaToken: Kv,
  isNotCommentToken: nE,
  isNotOpeningBraceToken: tE,
  isNotOpeningBracketToken: Zv,
  isNotOpeningParenToken: Qv,
  isNotSemicolonToken: Jv,
  isOpeningBraceToken: Ru,
  isOpeningBracketToken: Ou,
  isOpeningParenToken: an,
  isParenthesized: oE,
  isSemicolonToken: _u,
  PatternMatcher: lE,
  READ: rt,
  ReferenceTracker: ps
}, G_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: z_,
  CALL: kn,
  CONSTRUCT: Zn,
  ESM: _i,
  PatternMatcher: lE,
  READ: rt,
  ReferenceTracker: ps,
  findVariable: Yn,
  getFunctionHeadLocation: sE,
  getFunctionNameWithKind: aE,
  getInnermostScope: Pu,
  getPropertyName: Vs,
  getStaticValue: Mu,
  getStringIfConstant: $s,
  hasSideEffect: iE,
  isArrowToken: Pi,
  isClosingBraceToken: Nu,
  isClosingBracketToken: Lu,
  isClosingParenToken: Ii,
  isColonToken: Bu,
  isCommaToken: Iu,
  isCommentToken: ju,
  isNotArrowToken: Hv,
  isNotClosingBraceToken: rE,
  isNotClosingBracketToken: eE,
  isNotClosingParenToken: Yv,
  isNotColonToken: Xv,
  isNotCommaToken: Kv,
  isNotCommentToken: nE,
  isNotOpeningBraceToken: tE,
  isNotOpeningBracketToken: Zv,
  isNotOpeningParenToken: Qv,
  isNotSemicolonToken: Jv,
  isOpeningBraceToken: Ru,
  isOpeningBracketToken: Ou,
  isOpeningParenToken: an,
  isParenthesized: oE,
  isSemicolonToken: _u
}), uE = /* @__PURE__ */ Fn(G_), cE = { exports: {} }, po = { exports: {} }, fo, Eg;
function H_() {
  if (Eg)
    return fo;
  Eg = 1;
  var t, e, r, s, n, a, o = {}.toString;
  t = l(function(i, u) {
    return i.apply(null, u);
  }), e = function(i) {
    return l(i);
  }, r = l(function(i, u, c) {
    return i(c, u);
  }), s = function(i) {
    return function(u) {
      return function() {
        return i(u(u)).apply(null, arguments);
      };
    }(function(u) {
      return function() {
        return i(u(u)).apply(null, arguments);
      };
    });
  }, n = l(function(i, u, c, f) {
    return i(u(c), u(f));
  }), a = function(i) {
    var u;
    return u = {}, function() {
      var c, f, h, p, m, d;
      for (f = [], h = 0, p = arguments.length; h < p; ++h)
        f.push(arguments[h]);
      return c = f, m = function() {
        var g, y, x, A = [];
        for (g = 0, x = (y = c).length; g < x; ++g)
          d = y[g], A.push(d + o.call(d).slice(8, -1));
        return A;
      }().join(""), u[m] = m in u ? u[m] : i.apply(null, c);
    };
  }, fo = {
    curry: e,
    flip: r,
    fix: s,
    apply: t,
    over: n,
    memoize: a
  };
  function l(i, u) {
    var c, f = function(h) {
      return i.length > 1 ? function() {
        var p = h ? h.concat() : [];
        return c = u ? c || this : this, p.push.apply(p, arguments) < i.length && arguments.length ? f.call(c, p) : i.apply(c, p);
      } : i;
    };
    return f();
  }
  return fo;
}
var ho, bg;
function K_() {
  if (bg)
    return ho;
  bg = 1;
  var t, e, r, s, n, a, o, l, i, u, c, f, h, p, m, d, g, y, x, A, b, v, C, T, w, B, I, _, S, F, N, k, j, O, z, te, se, ye, Se, xe, Ae, _e, H, Q, ge, ae, ee, he, R, D, U, ne, pe, Ee, Re, We, wt, Lt, et, Ge, mt, tr, vr, Er, hr, P, It, St, rr, Te, qe = {}.toString;
  t = Be(function(Z, W) {
    var G, J, le;
    for (G = 0, J = W.length; G < J; ++G)
      le = W[G], Z(le);
    return W;
  }), e = Be(function(Z, W) {
    var G, J, le, ce = [];
    for (G = 0, J = W.length; G < J; ++G)
      le = W[G], ce.push(Z(le));
    return ce;
  }), r = function(Z) {
    var W, G, J, le = [];
    for (W = 0, G = Z.length; W < G; ++W)
      J = Z[W], J && le.push(J);
    return le;
  }, s = Be(function(Z, W) {
    var G, J, le, ce = [];
    for (G = 0, J = W.length; G < J; ++G)
      le = W[G], Z(le) && ce.push(le);
    return ce;
  }), n = Be(function(Z, W) {
    var G, J, le, ce = [];
    for (G = 0, J = W.length; G < J; ++G)
      le = W[G], Z(le) || ce.push(le);
    return ce;
  }), a = Be(function(Z, W) {
    var G, J;
    return G = It(Z, W), J = W.slice(), G != null && J.splice(G, 1), J;
  }), o = Be(function(Z, W) {
    var G, J, le, ce, Fe;
    for (G = [], J = [], le = 0, ce = W.length; le < ce; ++le)
      Fe = W[le], (Z(Fe) ? G : J).push(Fe);
    return [G, J];
  }), l = Be(function(Z, W) {
    var G, J, le;
    for (G = 0, J = W.length; G < J; ++G)
      if (le = W[G], Z(le))
        return le;
  }), i = u = function(Z) {
    return Z[0];
  }, c = function(Z) {
    if (Z.length)
      return Z.slice(1);
  }, f = function(Z) {
    return Z[Z.length - 1];
  }, h = function(Z) {
    if (Z.length)
      return Z.slice(0, -1);
  }, p = function(Z) {
    return !Z.length;
  }, m = function(Z) {
    return Z.concat().reverse();
  }, d = function(Z) {
    var W, G, J, le;
    for (W = [], G = 0, J = Z.length; G < J; ++G)
      le = Z[G], At(le, W) || W.push(le);
    return W;
  }, g = Be(function(Z, W) {
    var G, J, le, ce, Fe, Ve = [];
    for (G = [], J = 0, le = W.length; J < le; ++J)
      ce = W[J], Fe = Z(ce), !At(Fe, G) && (G.push(Fe), Ve.push(ce));
    return Ve;
  }), y = x = Be(function(Z, W, G) {
    var J, le, ce;
    for (J = 0, le = G.length; J < le; ++J)
      ce = G[J], W = Z(W, ce);
    return W;
  }), A = b = Be(function(Z, W) {
    return y(Z, W[0], W.slice(1));
  }), v = Be(function(Z, W, G) {
    var J, le;
    for (J = G.length - 1; J >= 0; --J)
      le = G[J], W = Z(le, W);
    return W;
  }), C = Be(function(Z, W) {
    return v(Z, W[W.length - 1], W.slice(0, -1));
  }), T = Be(function(Z, W) {
    var G, J, le;
    for (G = [], J = W; (le = Z(J)) != null; )
      G.push(le[0]), J = le[1];
    return G;
  }), w = function(Z) {
    return [].concat.apply([], Z);
  }, B = Be(function(Z, W) {
    var G;
    return [].concat.apply([], function() {
      var J, le, ce, Fe = [];
      for (J = 0, ce = (le = W).length; J < ce; ++J)
        G = le[J], Fe.push(Z(G));
      return Fe;
    }());
  }), I = function(Z) {
    var W;
    return [].concat.apply([], function() {
      var G, J, le, ce = [];
      for (G = 0, le = (J = Z).length; G < le; ++G)
        W = J[G], qe.call(W).slice(8, -1) === "Array" ? ce.push(I(W)) : ce.push(W);
      return ce;
    }());
  }, _ = function(Z) {
    var W, G, J, le, ce, Fe, Ve, Ye, lt, xt;
    for (G = [], J = 1, le = arguments.length; J < le; ++J)
      G.push(arguments[J]);
    W = G, ce = [];
    e:
      for (J = 0, Fe = Z.length; J < Fe; ++J) {
        for (Ve = Z[J], Ye = 0, lt = W.length; Ye < lt; ++Ye)
          if (xt = W[Ye], At(Ve, xt))
            continue e;
        ce.push(Ve);
      }
    return ce;
  }, S = function(Z) {
    var W, G, J, le, ce, Fe, Ve, Ye, lt, xt;
    for (G = [], J = 1, le = arguments.length; J < le; ++J)
      G.push(arguments[J]);
    W = G, ce = [];
    e:
      for (J = 0, Fe = Z.length; J < Fe; ++J) {
        for (Ve = Z[J], Ye = 0, lt = W.length; Ye < lt; ++Ye)
          if (xt = W[Ye], !At(Ve, xt))
            continue e;
        ce.push(Ve);
      }
    return ce;
  }, F = function() {
    var Z, W, G, J, le, ce, Fe, Ve, Ye, lt;
    for (W = [], G = 0, J = arguments.length; G < J; ++G)
      W.push(arguments[G]);
    for (Z = W, le = [], G = 0, ce = Z.length; G < ce; ++G)
      for (Fe = Z[G], Ve = 0, Ye = Fe.length; Ve < Ye; ++Ve)
        lt = Fe[Ve], At(lt, le) || le.push(lt);
    return le;
  }, N = Be(function(Z, W) {
    var G, J, le, ce, Fe;
    for (G = {}, J = 0, le = W.length; J < le; ++J)
      ce = W[J], Fe = Z(ce), Fe in G ? G[Fe] += 1 : G[Fe] = 1;
    return G;
  }), k = Be(function(Z, W) {
    var G, J, le, ce, Fe;
    for (G = {}, J = 0, le = W.length; J < le; ++J)
      ce = W[J], Fe = Z(ce), Fe in G ? G[Fe].push(ce) : G[Fe] = [ce];
    return G;
  }), j = function(Z) {
    var W, G, J;
    for (W = 0, G = Z.length; W < G; ++W)
      if (J = Z[W], !J)
        return !1;
    return !0;
  }, O = function(Z) {
    var W, G, J;
    for (W = 0, G = Z.length; W < G; ++W)
      if (J = Z[W], J)
        return !0;
    return !1;
  }, z = Be(function(Z, W) {
    var G, J, le;
    for (G = 0, J = W.length; G < J; ++G)
      if (le = W[G], Z(le))
        return !0;
    return !1;
  }), te = Be(function(Z, W) {
    var G, J, le;
    for (G = 0, J = W.length; G < J; ++G)
      if (le = W[G], !Z(le))
        return !1;
    return !0;
  }), se = function(Z) {
    return Z.concat().sort(function(W, G) {
      return W > G ? 1 : W < G ? -1 : 0;
    });
  }, ye = Be(function(Z, W) {
    return W.concat().sort(Z);
  }), Se = Be(function(Z, W) {
    return W.concat().sort(function(G, J) {
      return Z(G) > Z(J) ? 1 : Z(G) < Z(J) ? -1 : 0;
    });
  }), xe = function(Z) {
    var W, G, J, le;
    for (W = 0, G = 0, J = Z.length; G < J; ++G)
      le = Z[G], W += le;
    return W;
  }, Ae = function(Z) {
    var W, G, J, le;
    for (W = 1, G = 0, J = Z.length; G < J; ++G)
      le = Z[G], W *= le;
    return W;
  }, _e = H = function(Z) {
    var W, G, J, le;
    for (W = 0, G = 0, J = Z.length; G < J; ++G)
      le = Z[G], W += le;
    return W / Z.length;
  }, Q = function(Z) {
    var W, G, J, le, ce;
    for (W = Z[0], G = 0, le = (J = Z.slice(1)).length; G < le; ++G)
      ce = J[G], ce > W && (W = ce);
    return W;
  }, ge = function(Z) {
    var W, G, J, le, ce;
    for (W = Z[0], G = 0, le = (J = Z.slice(1)).length; G < le; ++G)
      ce = J[G], ce < W && (W = ce);
    return W;
  }, ae = Be(function(Z, W) {
    var G, J, le, ce, Fe;
    for (G = W[0], J = 0, ce = (le = W.slice(1)).length; J < ce; ++J)
      Fe = le[J], Z(Fe) > Z(G) && (G = Fe);
    return G;
  }), ee = Be(function(Z, W) {
    var G, J, le, ce, Fe;
    for (G = W[0], J = 0, ce = (le = W.slice(1)).length; J < ce; ++J)
      Fe = le[J], Z(Fe) < Z(G) && (G = Fe);
    return G;
  }), he = R = Be(function(Z, W, G) {
    var J, le;
    return J = W, [W].concat(function() {
      var ce, Fe, Ve, Ye = [];
      for (ce = 0, Ve = (Fe = G).length; ce < Ve; ++ce)
        le = Fe[ce], Ye.push(J = Z(J, le));
      return Ye;
    }());
  }), D = U = Be(function(Z, W) {
    if (W.length)
      return he(Z, W[0], W.slice(1));
  }), ne = Be(function(Z, W, G) {
    return G = G.concat().reverse(), he(Z, W, G).reverse();
  }), pe = Be(function(Z, W) {
    if (W.length)
      return W = W.concat().reverse(), he(Z, W[0], W.slice(1)).reverse();
  }), Ee = Be(function(Z, W, G) {
    return G.slice(Z, W);
  }), Re = Be(function(Z, W) {
    return Z <= 0 ? W.slice(0, 0) : W.slice(0, Z);
  }), We = Be(function(Z, W) {
    return Z <= 0 ? W : W.slice(Z);
  }), wt = Be(function(Z, W) {
    return [Re(Z, W), We(Z, W)];
  }), Lt = Be(function(Z, W) {
    var G, J;
    if (G = W.length, !G)
      return W;
    for (J = 0; J < G && Z(W[J]); )
      J += 1;
    return W.slice(0, J);
  }), et = Be(function(Z, W) {
    var G, J;
    if (G = W.length, !G)
      return W;
    for (J = 0; J < G && Z(W[J]); )
      J += 1;
    return W.slice(J);
  }), Ge = Be(function(Z, W) {
    return [Lt(Z, W), et(Z, W)];
  }), mt = Be(function(Z, W) {
    return Ge(bt(Z, Ce), W);
  }), tr = Be(function(Z, W) {
    var G, J, le, ce, Fe, Ve;
    for (G = [], J = W.length, le = 0, ce = Z.length; le < ce && (Fe = le, Ve = Z[le], Fe !== J); ++le)
      G.push([Ve, W[Fe]]);
    return G;
  }), vr = Be(function(Z, W, G) {
    var J, le, ce, Fe, Ve, Ye;
    for (J = [], le = G.length, ce = 0, Fe = W.length; ce < Fe && (Ve = ce, Ye = W[ce], Ve !== le); ++ce)
      J.push(Z(Ye, G[Ve]));
    return J;
  }), Er = function() {
    var Z, W, G, J, le, ce, Fe, Ve, Ye, lt, xt, oe = [];
    for (W = [], G = 0, J = arguments.length; G < J; ++G)
      W.push(arguments[G]);
    for (Z = W, le = void 0, G = 0, ce = Z.length; G < ce; ++G)
      Fe = Z[G], le <= (Ve = Fe.length) || (le = Ve);
    for (G = 0; G < le; ++G) {
      for (Ye = G, lt = [], xt = 0, ce = Z.length; xt < ce; ++xt)
        Fe = Z[xt], lt.push(Fe[Ye]);
      oe.push(lt);
    }
    return oe;
  }, hr = function(Z) {
    var W, G, J, le, ce, Fe, Ve, Ye, lt, xt = [];
    for (G = [], J = 1, le = arguments.length; J < le; ++J)
      G.push(arguments[J]);
    for (W = G, ce = void 0, J = 0, Fe = W.length; J < Fe; ++J)
      Ve = W[J], ce <= (Ye = Ve.length) || (ce = Ye);
    for (J = 0; J < ce; ++J)
      lt = J, xt.push(Z.apply(null, oe()));
    return xt;
    function oe() {
      var be, ke, re, M = [];
      for (be = 0, re = (ke = W).length; be < re; ++be)
        Ve = ke[be], M.push(Ve[lt]);
      return M;
    }
  }, P = Be(function(Z, W) {
    return Z < 0 ? W[W.length + Z] : W[Z];
  }), It = Be(function(Z, W) {
    var G, J, le, ce;
    for (G = 0, J = W.length; G < J; ++G)
      if (le = G, ce = W[G], ce === Z)
        return le;
  }), St = Be(function(Z, W) {
    var G, J, le, ce, Fe = [];
    for (G = 0, J = W.length; G < J; ++G)
      le = G, ce = W[G], ce === Z && Fe.push(le);
    return Fe;
  }), rr = Be(function(Z, W) {
    var G, J, le, ce;
    for (G = 0, J = W.length; G < J; ++G)
      if (le = G, ce = W[G], Z(ce))
        return le;
  }), Te = Be(function(Z, W) {
    var G, J, le, ce, Fe = [];
    for (G = 0, J = W.length; G < J; ++G)
      le = G, ce = W[G], Z(ce) && Fe.push(le);
    return Fe;
  }), ho = {
    each: t,
    map: e,
    filter: s,
    compact: r,
    reject: n,
    remove: a,
    partition: o,
    find: l,
    head: i,
    first: u,
    tail: c,
    last: f,
    initial: h,
    empty: p,
    reverse: m,
    difference: _,
    intersection: S,
    union: F,
    countBy: N,
    groupBy: k,
    fold: y,
    fold1: A,
    foldl: x,
    foldl1: b,
    foldr: v,
    foldr1: C,
    unfoldr: T,
    andList: j,
    orList: O,
    any: z,
    all: te,
    unique: d,
    uniqueBy: g,
    sort: se,
    sortWith: ye,
    sortBy: Se,
    sum: xe,
    product: Ae,
    mean: _e,
    average: H,
    concat: w,
    concatMap: B,
    flatten: I,
    maximum: Q,
    minimum: ge,
    maximumBy: ae,
    minimumBy: ee,
    scan: he,
    scan1: D,
    scanl: R,
    scanl1: U,
    scanr: ne,
    scanr1: pe,
    slice: Ee,
    take: Re,
    drop: We,
    splitAt: wt,
    takeWhile: Lt,
    dropWhile: et,
    span: Ge,
    breakList: mt,
    zip: tr,
    zipWith: vr,
    zipAll: Er,
    zipAllWith: hr,
    at: P,
    elemIndex: It,
    elemIndices: St,
    findIndex: rr,
    findIndices: Te
  };
  function Be(Z, W) {
    var G, J = function(le) {
      return Z.length > 1 ? function() {
        var ce = le ? le.concat() : [];
        return G = W ? G || this : this, ce.push.apply(ce, arguments) < Z.length && arguments.length ? J.call(G, ce) : Z.apply(G, ce);
      } : Z;
    };
    return J();
  }
  function At(Z, W) {
    for (var G = -1, J = W.length >>> 0; ++G < J; )
      if (Z === W[G])
        return !0;
    return !1;
  }
  function bt() {
    var Z = arguments;
    return function() {
      var W, G;
      for (G = Z[0].apply(this, arguments), W = 1; W < Z.length; ++W)
        G = Z[W](G);
      return G;
    };
  }
  function Ce(Z) {
    return !Z;
  }
  return ho;
}
var mo, Cg;
function J_() {
  if (Cg)
    return mo;
  Cg = 1;
  var t, e, r, s, n, a, o, l, i, u, c, f, h, p;
  t = function(d) {
    var g, y, x = [];
    for (g in d)
      y = d[g], x.push(y);
    return x;
  }, e = function(d) {
    var g, y = [];
    for (g in d)
      y.push(g);
    return y;
  }, r = function(d) {
    var g, y, x, A = {};
    for (g = 0, y = d.length; g < y; ++g)
      x = d[g], A[x[0]] = x[1];
    return A;
  }, s = function(d) {
    var g, y, x = [];
    for (g in d)
      y = d[g], x.push([g, y]);
    return x;
  }, n = m(function(d, g) {
    var y, x, A, b, v = {};
    for (y = 0, x = d.length; y < x; ++y)
      A = y, b = d[y], v[b] = g[A];
    return v;
  }), a = function(d) {
    var g, y, x, A;
    g = [], y = [];
    for (x in d)
      A = d[x], g.push(x), y.push(A);
    return [g, y];
  }, o = function(d) {
    var g;
    for (g in d)
      return !1;
    return !0;
  }, l = m(function(d, g) {
    var y, x;
    for (y in g)
      x = g[y], d(x);
    return g;
  }), i = m(function(d, g) {
    var y, x, A = {};
    for (y in g)
      x = g[y], A[y] = d(x);
    return A;
  }), u = function(d) {
    var g, y, x = {};
    for (g in d)
      y = d[g], y && (x[g] = y);
    return x;
  }, c = m(function(d, g) {
    var y, x, A = {};
    for (y in g)
      x = g[y], d(x) && (A[y] = x);
    return A;
  }), f = m(function(d, g) {
    var y, x, A = {};
    for (y in g)
      x = g[y], d(x) || (A[y] = x);
    return A;
  }), h = m(function(d, g) {
    var y, x, A, b;
    y = {}, x = {};
    for (A in g)
      b = g[A], (d(b) ? y : x)[A] = b;
    return [y, x];
  }), p = m(function(d, g) {
    var y, x;
    for (y in g)
      if (x = g[y], d(x))
        return x;
  }), mo = {
    values: t,
    keys: e,
    pairsToObj: r,
    objToPairs: s,
    listsToObj: n,
    objToLists: a,
    empty: o,
    each: l,
    map: i,
    filter: c,
    compact: u,
    reject: f,
    partition: h,
    find: p
  };
  function m(d, g) {
    var y, x = function(A) {
      return d.length > 1 ? function() {
        var b = A ? A.concat() : [];
        return y = g ? y || this : this, b.push.apply(b, arguments) < d.length && arguments.length ? x.call(y, b) : d.apply(y, b);
      } : d;
    };
    return x();
  }
  return mo;
}
var go, Sg;
function X_() {
  if (Sg)
    return go;
  Sg = 1;
  var t, e, r, s, n, a, o, l, i, u, c, f, h;
  t = p(function(m, d) {
    return d.split(m);
  }), e = p(function(m, d) {
    return d.join(m);
  }), r = function(m) {
    return m.length ? m.split(`
`) : [];
  }, s = function(m) {
    return m.join(`
`);
  }, n = function(m) {
    return m.length ? m.split(/[ ]+/) : [];
  }, a = function(m) {
    return m.join(" ");
  }, o = function(m) {
    return m.split("");
  }, l = function(m) {
    return m.join("");
  }, i = function(m) {
    return m.split("").reverse().join("");
  }, u = p(function(m, d) {
    var g, y;
    for (g = "", y = 0; y < m; ++y)
      g += d;
    return g;
  }), c = function(m) {
    return m.charAt(0).toUpperCase() + m.slice(1);
  }, f = function(m) {
    return m.replace(/[-_]+(.)?/g, function(d, g) {
      return (g ?? "").toUpperCase();
    });
  }, h = function(m) {
    return m.replace(/([^-A-Z])([A-Z]+)/g, function(d, g, y) {
      return g + "-" + (y.length > 1 ? y : y.toLowerCase());
    }).replace(/^([A-Z]+)/, function(d, g) {
      return g.length > 1 ? g + "-" : g.toLowerCase();
    });
  }, go = {
    split: t,
    join: e,
    lines: r,
    unlines: s,
    words: n,
    unwords: a,
    chars: o,
    unchars: l,
    reverse: i,
    repeat: u,
    capitalize: c,
    camelize: f,
    dasherize: h
  };
  function p(m, d) {
    var g, y = function(x) {
      return m.length > 1 ? function() {
        var A = x ? x.concat() : [];
        return g = d ? g || this : this, A.push.apply(A, arguments) < m.length && arguments.length ? y.call(g, A) : m.apply(g, A);
      } : m;
    };
    return y();
  }
  return go;
}
var yo, Ag;
function Q_() {
  if (Ag)
    return yo;
  Ag = 1;
  var t, e, r, s, n, a, o, l, i, u, c, f, h, p, m, d, g, y, x, A, b, v, C, T, w, B, I, _, S, F, N, k;
  t = j(function(O, z) {
    return O > z ? O : z;
  }), e = j(function(O, z) {
    return O < z ? O : z;
  }), r = function(O) {
    return -O;
  }, s = Math.abs, n = function(O) {
    return O < 0 ? -1 : O > 0 ? 1 : 0;
  }, a = j(function(O, z) {
    return ~~(O / z);
  }), o = j(function(O, z) {
    return O % z;
  }), l = j(function(O, z) {
    return Math.floor(O / z);
  }), i = j(function(O, z) {
    var te;
    return (O % (te = z) + te) % te;
  }), u = function(O) {
    return 1 / O;
  }, c = Math.PI, f = c * 2, h = Math.exp, p = Math.sqrt, m = Math.log, d = j(function(O, z) {
    return Math.pow(O, z);
  }), g = Math.sin, y = Math.tan, x = Math.cos, A = Math.asin, b = Math.acos, v = Math.atan, C = j(function(O, z) {
    return Math.atan2(O, z);
  }), T = function(O) {
    return ~~O;
  }, w = Math.round, B = Math.ceil, I = Math.floor, _ = function(O) {
    return O !== O;
  }, S = function(O) {
    return O % 2 === 0;
  }, F = function(O) {
    return O % 2 !== 0;
  }, N = j(function(O, z) {
    var te;
    for (O = Math.abs(O), z = Math.abs(z); z !== 0; )
      te = O % z, O = z, z = te;
    return O;
  }), k = j(function(O, z) {
    return Math.abs(Math.floor(O / N(O, z) * z));
  }), yo = {
    max: t,
    min: e,
    negate: r,
    abs: s,
    signum: n,
    quot: a,
    rem: o,
    div: l,
    mod: i,
    recip: u,
    pi: c,
    tau: f,
    exp: h,
    sqrt: p,
    ln: m,
    pow: d,
    sin: g,
    tan: y,
    cos: x,
    acos: b,
    asin: A,
    atan: v,
    atan2: C,
    truncate: T,
    round: w,
    ceiling: B,
    floor: I,
    isItNaN: _,
    even: S,
    odd: F,
    gcd: N,
    lcm: k
  };
  function j(O, z) {
    var te, se = function(ye) {
      return O.length > 1 ? function() {
        var Se = ye ? ye.concat() : [];
        return te = z ? te || this : this, Se.push.apply(Se, arguments) < O.length && arguments.length ? se.call(te, Se) : O.apply(te, Se);
      } : O;
    };
    return se();
  }
  return yo;
}
var xo, Dg;
function pE() {
  if (Dg)
    return xo;
  Dg = 1;
  var t, e, r, s, n, a, o, l, i, u = {}.toString;
  t = H_(), e = K_(), r = J_(), s = X_(), n = Q_(), a = function(f) {
    return f;
  }, o = c(function(f, h) {
    return u.call(h).slice(8, -1) === f;
  }), l = c(function(f, h) {
    var p, m = [];
    for (p = 0; p < f; ++p)
      m.push(h);
    return m;
  }), s.empty = e.empty, s.slice = e.slice, s.take = e.take, s.drop = e.drop, s.splitAt = e.splitAt, s.takeWhile = e.takeWhile, s.dropWhile = e.dropWhile, s.span = e.span, s.breakStr = e.breakList, i = {
    Func: t,
    List: e,
    Obj: r,
    Str: s,
    Num: n,
    id: a,
    isType: o,
    replicate: l
  }, i.each = e.each, i.map = e.map, i.filter = e.filter, i.compact = e.compact, i.reject = e.reject, i.partition = e.partition, i.find = e.find, i.head = e.head, i.first = e.first, i.tail = e.tail, i.last = e.last, i.initial = e.initial, i.empty = e.empty, i.reverse = e.reverse, i.difference = e.difference, i.intersection = e.intersection, i.union = e.union, i.countBy = e.countBy, i.groupBy = e.groupBy, i.fold = e.fold, i.foldl = e.foldl, i.fold1 = e.fold1, i.foldl1 = e.foldl1, i.foldr = e.foldr, i.foldr1 = e.foldr1, i.unfoldr = e.unfoldr, i.andList = e.andList, i.orList = e.orList, i.any = e.any, i.all = e.all, i.unique = e.unique, i.uniqueBy = e.uniqueBy, i.sort = e.sort, i.sortWith = e.sortWith, i.sortBy = e.sortBy, i.sum = e.sum, i.product = e.product, i.mean = e.mean, i.average = e.average, i.concat = e.concat, i.concatMap = e.concatMap, i.flatten = e.flatten, i.maximum = e.maximum, i.minimum = e.minimum, i.maximumBy = e.maximumBy, i.minimumBy = e.minimumBy, i.scan = e.scan, i.scanl = e.scanl, i.scan1 = e.scan1, i.scanl1 = e.scanl1, i.scanr = e.scanr, i.scanr1 = e.scanr1, i.slice = e.slice, i.take = e.take, i.drop = e.drop, i.splitAt = e.splitAt, i.takeWhile = e.takeWhile, i.dropWhile = e.dropWhile, i.span = e.span, i.breakList = e.breakList, i.zip = e.zip, i.zipWith = e.zipWith, i.zipAll = e.zipAll, i.zipAllWith = e.zipAllWith, i.at = e.at, i.elemIndex = e.elemIndex, i.elemIndices = e.elemIndices, i.findIndex = e.findIndex, i.findIndices = e.findIndices, i.apply = t.apply, i.curry = t.curry, i.flip = t.flip, i.fix = t.fix, i.over = t.over, i.split = s.split, i.join = s.join, i.lines = s.lines, i.unlines = s.unlines, i.words = s.words, i.unwords = s.unwords, i.chars = s.chars, i.unchars = s.unchars, i.repeat = s.repeat, i.capitalize = s.capitalize, i.camelize = s.camelize, i.dasherize = s.dasherize, i.values = r.values, i.keys = r.keys, i.pairsToObj = r.pairsToObj, i.objToPairs = r.objToPairs, i.listsToObj = r.listsToObj, i.objToLists = r.objToLists, i.max = n.max, i.min = n.min, i.negate = n.negate, i.abs = n.abs, i.signum = n.signum, i.quot = n.quot, i.rem = n.rem, i.div = n.div, i.mod = n.mod, i.recip = n.recip, i.pi = n.pi, i.tau = n.tau, i.exp = n.exp, i.sqrt = n.sqrt, i.ln = n.ln, i.pow = n.pow, i.sin = n.sin, i.tan = n.tan, i.cos = n.cos, i.acos = n.acos, i.asin = n.asin, i.atan = n.atan, i.atan2 = n.atan2, i.truncate = n.truncate, i.round = n.round, i.ceiling = n.ceiling, i.floor = n.floor, i.isItNaN = n.isItNaN, i.even = n.even, i.odd = n.odd, i.gcd = n.gcd, i.lcm = n.lcm, i.VERSION = "1.2.1", xo = i;
  function c(f, h) {
    var p, m = function(d) {
      return f.length > 1 ? function() {
        var g = d ? d.concat() : [];
        return p = h ? p || this : this, g.push.apply(g, arguments) < f.length && arguments.length ? m.call(p, g) : f.apply(p, g);
      } : f;
    };
    return m();
  }
  return xo;
}
var wg;
function Y_() {
  return wg || (wg = 1, (function() {
    var t, e, r;
    t = pE().reject;
    function s(p, m) {
      if (p[0] === m)
        return p.shift();
      throw new Error("Expected '" + m + "', but got '" + p[0] + "' instead in " + JSON.stringify(p) + ".");
    }
    function n(p, m) {
      if (p[0] === m)
        return p.shift();
    }
    function a(p, m, d) {
      var g, y, x, A;
      for (g = m[0], y = m[1], d && s(p, g), x = [], A = "," + (d ? y : ""); p.length && d && p[0] !== y; )
        x.push(c(p, A)), n(p, ",");
      return d && s(p, y), x;
    }
    function o(p, m) {
      return a(p, ["[", "]"], m);
    }
    function l(p, m) {
      return a(p, ["(", ")"], m);
    }
    function i(p, m) {
      var d, g, y;
      for (m && s(p, "{"), d = {}, g = "," + (m ? "}" : ""); p.length && (!m || p[0] !== "}"); )
        y = u(p, ":"), s(p, ":"), d[y] = c(p, g), n(p, ",");
      return m && s(p, "}"), d;
    }
    function u(p, m) {
      var d;
      for (m == null && (m = ""), d = ""; p.length && m.indexOf(p[0]) === -1; )
        d += p.shift();
      return d;
    }
    function c(p, m) {
      switch (p[0]) {
        case "[":
          return o(p, !0);
        case "(":
          return l(p, !0);
        case "{":
          return i(p, !0);
        default:
          return u(p, m);
      }
    }
    function f(p, m, d) {
      var g, y, x, A, b, v, C, T;
      return g = m[0], y = g.type, x = g.structure, A = p.concat(), !d.explicit && m.length === 1 && (!y && x || y === "Array" || y === "Object") ? (b = x === "array" || y === "Array" ? o(p, p[0] === "[") : x === "tuple" ? l(p, p[0] === "(") : i(p, p[0] === "{"), v = p.length ? c(x === "array" || y === "Array" ? (C = A, C.unshift("["), C.push("]"), C) : (T = A, T.unshift("("), T.push(")"), T)) : b) : v = c(p), v;
    }
    e = /\[\]\(\)}{:,/.source, r = RegExp(`("(?:\\\\"|[^"])*")|('(?:\\\\'|[^'])*')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([` + e + "])|([^\\s" + e + "](?:\\s*[^\\s" + e + "]+)*)|\\s*"), po.exports = function(p, m, d) {
      var g, y;
      if (d == null && (d = {}), !d.explicit && p.length === 1 && p[0].type === "String")
        return m;
      if (g = t(h, m.split(r)), y = f(g, p, d), !y)
        throw new Error("Error parsing '" + m + "'.");
      return y;
    };
    function h(p) {
      return !p;
    }
  }).call(mr)), po.exports;
}
var vo = { exports: {} }, Eo = { exports: {} }, bo = { exports: {} }, kg;
function Z_() {
  return kg || (kg = 1, (function() {
    var t, e;
    t = /[\$\w]+/;
    function r(m) {
      var d;
      if (d = m[0], d == null)
        throw new Error("Unexpected end of input.");
      return d;
    }
    function s(m) {
      var d;
      if (d = r(m), !t.test(d))
        throw new Error("Expected text, got '" + d + "' instead.");
      return m.shift();
    }
    function n(m, d) {
      var g;
      if (g = r(m), g !== d)
        throw new Error("Expected '" + d + "', got '" + g + "' instead.");
      return m.shift();
    }
    function a(m, d) {
      var g;
      return g = m[0], g === d ? m.shift() : null;
    }
    function o(m) {
      var d;
      if (n(m, "["), r(m) === "]")
        throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
      return d = h(m), n(m, "]"), {
        structure: "array",
        of: d
      };
    }
    function l(m) {
      var d;
      if (d = [], n(m, "("), r(m) === ")")
        throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
      for (; d.push(h(m)), a(m, ","), r(m) !== ")"; )
        ;
      return n(m, ")"), {
        structure: "tuple",
        of: d
      };
    }
    function i(m) {
      var d, g, y, x, A;
      for (d = {}, n(m, "{"), g = !1; ; ) {
        if (a(m, "...")) {
          g = !0;
          break;
        }
        if (y = u(m), x = y[0], A = y[1], d[x] = A, a(m, ","), r(m) === "}")
          break;
      }
      return n(m, "}"), {
        structure: "fields",
        of: d,
        subset: g
      };
    }
    function u(m) {
      var d, g;
      return d = s(m), n(m, ":"), g = h(m), [d, g];
    }
    function c(m) {
      switch (m[0]) {
        case "[":
          return o(m);
        case "(":
          return l(m);
        case "{":
          return i(m);
      }
    }
    function f(m) {
      var d, g, y, x;
      if (d = r(m), g = d === "*", g || t.test(d))
        return y = g ? n(m, "*") : s(m), x = c(m), x ? (x.type = y, x) : {
          type: y
        };
      if (x = c(m), !x)
        throw new Error("Unexpected character: " + d);
      return x;
    }
    function h(m) {
      var d, g, y, x, A, b;
      if (r(m) === "::")
        throw new Error("No comment before comment separator '::' found.");
      for (d = m[1], d != null && d === "::" && (m.shift(), m.shift()), g = [], y = {}, r(m) === "Maybe" && (m.shift(), g = [
        {
          type: "Undefined"
        },
        {
          type: "Null"
        }
      ], y = {
        Undefined: !0,
        Null: !0
      }); x = f(m), A = x.type, b = x.structure, y[A] || g.push(x), b == null && (y[A] = !0), !!a(m, "|"); )
        ;
      return g;
    }
    e = RegExp("\\.\\.\\.|::|->|" + t.source + "|\\S", "g"), bo.exports = function(m) {
      var d, g;
      if (!m.length)
        throw new Error("No type specified.");
      if (d = m.match(e) || [], p("->", d))
        throw new Error("Function types are not supported. To validate that something is a function, you may use 'Function'.");
      try {
        return h(d);
      } catch (y) {
        throw g = y, new Error(g.message + " - Remaining tokens: " + JSON.stringify(d) + " - Initial input: '" + m + "'");
      }
    };
    function p(m, d) {
      for (var g = -1, y = d.length >>> 0; ++g < y; )
        if (m === d[g])
          return !0;
      return !1;
    }
  }).call(mr)), bo.exports;
}
var Co = { exports: {} }, Tg;
function e2() {
  return Tg || (Tg = 1, (function() {
    var t, e, r, s, n, a, o = {}.toString;
    t = pE(), e = t.any, r = t.all, s = t.isItNaN, n = {
      Number: {
        typeOf: "Number",
        validate: function(p) {
          return !s(p);
        }
      },
      NaN: {
        typeOf: "Number",
        validate: s
      },
      Int: {
        typeOf: "Number",
        validate: function(p) {
          return !s(p) && p % 1 === 0;
        }
      },
      Float: {
        typeOf: "Number",
        validate: function(p) {
          return !s(p);
        }
      },
      Date: {
        typeOf: "Date",
        validate: function(p) {
          return !s(p.getTime());
        }
      }
    }, a = {
      array: "Array",
      tuple: "Array"
    };
    function l(p, m, d) {
      return r(function(g) {
        return h(g, m.of, d);
      }, p);
    }
    function i(p, m, d) {
      var g, y, x, A, b;
      for (g = 0, y = 0, A = (x = m.of).length; y < A; ++y) {
        if (b = x[y], !h(p[g], b, d))
          return !1;
        g++;
      }
      return p.length <= g;
    }
    function u(p, m, d) {
      var g, y, x, A, b, v, C;
      g = {}, y = 0;
      for (x in p)
        g[x] = !0, y++;
      A = 0;
      for (b in v = m.of) {
        if (C = v[b], !h(p[b], C, d))
          return !1;
        g[b] && A++;
      }
      return m.subset || y === A;
    }
    function c(p, m, d) {
      if (!(p instanceof Object))
        return !1;
      switch (m.structure) {
        case "fields":
          return u(p, m, d);
        case "array":
          return l(p, m, d);
        case "tuple":
          return i(p, m, d);
      }
    }
    function f(p, m, d) {
      var g, y, x, A;
      if (g = m.type, y = m.structure, g)
        return g === "*" ? !0 : (x = d.customTypes[g] || n[g], x ? (x.typeOf === void 0 || x.typeOf === o.call(p).slice(8, -1)) && x.validate(p) : g === o.call(p).slice(8, -1) && (!y || c(p, m, d)));
      if (y)
        return (A = a[y]) && A !== o.call(p).slice(8, -1) ? !1 : c(p, m, d);
      throw new Error("No type defined. Input: " + p + ".");
    }
    function h(p, m, d) {
      if (o.call(m).slice(8, -1) !== "Array")
        throw new Error("Types must be in an array. Input: " + p + ".");
      return e(function(g) {
        return f(p, g, d);
      }, m);
    }
    Co.exports = function(p, m, d) {
      return d == null && (d = {}), d.customTypes == null && (d.customTypes = {}), h(m, p, d);
    };
  }).call(mr)), Co.exports;
}
var Fg;
function fE() {
  return Fg || (Fg = 1, (function() {
    var t, e, r, s;
    t = "0.4.0", e = Z_(), r = e2(), s = function(n, a, o) {
      return r(e(n), a, o);
    }, Eo.exports = {
      VERSION: t,
      typeCheck: s,
      parsedTypeCheck: r,
      parseType: e
    };
  }).call(mr)), Eo.exports;
}
var Pg;
function t2() {
  return Pg || (Pg = 1, (function() {
    var t, e, r = {}.toString;
    t = fE().parsedTypeCheck, e = {
      "*": function(i, u) {
        switch (r.call(i).slice(8, -1)) {
          case "Array":
            return o(i, {
              type: "Array"
            }, u);
          case "Object":
            return o(i, {
              type: "Object"
            }, u);
          default:
            return {
              type: "Just",
              value: l(i, [
                {
                  type: "Undefined"
                },
                {
                  type: "Null"
                },
                {
                  type: "NaN"
                },
                {
                  type: "Boolean"
                },
                {
                  type: "Number"
                },
                {
                  type: "Date"
                },
                {
                  type: "RegExp"
                },
                {
                  type: "Array"
                },
                {
                  type: "Object"
                },
                {
                  type: "String"
                }
              ], (u.explicit = !0, u))
            };
        }
      },
      Undefined: function(i) {
        return i === "undefined" || i === void 0 ? {
          type: "Just",
          value: void 0
        } : {
          type: "Nothing"
        };
      },
      Null: function(i) {
        return i === "null" ? {
          type: "Just",
          value: null
        } : {
          type: "Nothing"
        };
      },
      NaN: function(i) {
        return i === "NaN" ? {
          type: "Just",
          value: NaN
        } : {
          type: "Nothing"
        };
      },
      Boolean: function(i) {
        return i === "true" ? {
          type: "Just",
          value: !0
        } : i === "false" ? {
          type: "Just",
          value: !1
        } : {
          type: "Nothing"
        };
      },
      Number: function(i) {
        return {
          type: "Just",
          value: +i
        };
      },
      Int: function(i) {
        return {
          type: "Just",
          value: +i
        };
      },
      Float: function(i) {
        return {
          type: "Just",
          value: +i
        };
      },
      Date: function(i, u) {
        var c;
        return (c = /^\#([\s\S]*)\#$/.exec(i)) ? {
          type: "Just",
          value: new Date(+c[1] || c[1])
        } : u.explicit ? {
          type: "Nothing"
        } : {
          type: "Just",
          value: new Date(+i || i)
        };
      },
      RegExp: function(i, u) {
        var c;
        return (c = /^\/([\s\S]*)\/([gimy]*)$/.exec(i)) ? {
          type: "Just",
          value: new RegExp(c[1], c[2])
        } : u.explicit ? {
          type: "Nothing"
        } : {
          type: "Just",
          value: new RegExp(i)
        };
      },
      Array: function(i, u) {
        return s(i, {
          of: [{
            type: "*"
          }]
        }, u);
      },
      Object: function(i, u) {
        return a(i, {
          of: {}
        }, u);
      },
      String: function(i) {
        var u, c;
        return r.call(i).slice(8, -1) !== "String" ? {
          type: "Nothing"
        } : (u = function(f, h) {
          return f.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function(p, m) {
            switch (m[0]) {
              case h:
                return h;
              case "\\":
                return "\\";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return `
`;
              case "r":
                return "\r";
              case "t":
                return "	";
              case "u":
                return JSON.parse('"' + p + '"');
              default:
                return m;
            }
          });
        }, (c = i.match(/^'([\s\S]*)'$/)) ? {
          type: "Just",
          value: u(c[1], "'")
        } : (c = i.match(/^"([\s\S]*)"$/)) ? {
          type: "Just",
          value: u(c[1], '"')
        } : {
          type: "Just",
          value: i
        });
      }
    };
    function s(i, u, c) {
      var f, h;
      return r.call(i).slice(8, -1) !== "Array" ? {
        type: "Nothing"
      } : (f = u.of, {
        type: "Just",
        value: function() {
          var p, m, d, g = [];
          for (p = 0, d = (m = i).length; p < d; ++p)
            h = m[p], g.push(l(h, f, c));
          return g;
        }()
      });
    }
    function n(i, u, c) {
      var f, h, p, m, d, g, y;
      if (r.call(i).slice(8, -1) !== "Array")
        return {
          type: "Nothing"
        };
      for (f = [], h = 0, p = 0, d = (m = u.of).length; p < d; ++p)
        g = m[p], y = l(i[h], g, c), r.call(y).slice(8, -1) !== "Undefined" && f.push(y), h++;
      return i.length <= h ? {
        type: "Just",
        value: f
      } : {
        type: "Nothing"
      };
    }
    function a(i, u, c) {
      var f, h, p;
      return r.call(i).slice(8, -1) !== "Object" ? {
        type: "Nothing"
      } : (f = u.of, {
        type: "Just",
        value: function() {
          var m, d = {};
          for (h in m = i)
            p = m[h], d[l(h, [{
              type: "String"
            }], c)] = l(p, f[h] || [{
              type: "*"
            }], c);
          return d;
        }()
      });
    }
    function o(i, u, c) {
      var f, h, p, m;
      if (f = u.type, h = u.structure, f) {
        if (p = ((m = c.customTypes[f]) != null ? m.cast : void 0) || e[f], !p)
          throw new Error("Type not defined: " + f + ".");
        return p(i, c, l);
      } else
        switch (h) {
          case "array":
            return s(i, u, c);
          case "tuple":
            return n(i, u, c);
          case "fields":
            return a(i, u, c);
        }
    }
    function l(i, u, c) {
      var f, h, p, m, d, g;
      for (f = 0, h = u.length; f < h; ++f)
        if (p = u[f], m = o(i, p, c), d = m.type, g = m.value, d !== "Nothing" && t([p], g, {
          customTypes: c.customTypes
        }))
          return g;
      throw new Error("Value " + JSON.stringify(i) + " does not type check against " + JSON.stringify(u) + ".");
    }
    vo.exports = function(i, u, c) {
      return !c.explicit && u.length === 1 && u[0].type === "String" ? i : l(i, u, c);
    };
  }).call(mr)), vo.exports;
}
(function() {
  var t, e, r, s, n, a;
  t = Y_(), e = t2(), r = fE().parseType, s = "0.4.1", n = function(o, l, i) {
    return i == null && (i = {}), i.explicit == null && (i.explicit = !1), i.customTypes == null && (i.customTypes = {}), e(t(o, l, i), o, i);
  }, a = function(o, l, i) {
    return n(r(o), l, i);
  }, cE.exports = {
    VERSION: s,
    parse: a,
    parsedTypeParse: n
  };
}).call(mr);
function es(t) {
  return (es = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  })(t);
}
function Bi(t, e) {
  return function(r) {
    if (Array.isArray(r))
      return r;
  }(t) || function(r, s) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(r)))) {
      var n = [], a = !0, o = !1, l = void 0;
      try {
        for (var i, u = r[Symbol.iterator](); !(a = (i = u.next()).done) && (n.push(i.value), !s || n.length !== s); a = !0)
          ;
      } catch (c) {
        o = !0, l = c;
      } finally {
        try {
          a || u.return == null || u.return();
        } finally {
          if (o)
            throw l;
        }
      }
      return n;
    }
  }(t, e) || $u(t, e) || function() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function r2(t) {
  return function(e) {
    if (Array.isArray(e))
      return bl(e);
  }(t) || function(e) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(e))
      return Array.from(e);
  }(t) || $u(t) || function() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function $u(t, e) {
  if (t) {
    if (typeof t == "string")
      return bl(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? bl(t, e) : void 0;
  }
}
function bl(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, s = new Array(e); r < e; r++)
    s[r] = t[r];
  return s;
}
function Nr(t, e) {
  var r;
  if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
    if (Array.isArray(t) || (r = $u(t)) || e && t && typeof t.length == "number") {
      r && (t = r);
      var s = 0, n = function() {
      };
      return { s: n, n: function() {
        return s >= t.length ? { done: !0 } : { done: !1, value: t[s++] };
      }, e: function(i) {
        throw i;
      }, f: n };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, o = !0, l = !1;
  return { s: function() {
    r = t[Symbol.iterator]();
  }, n: function() {
    var i = r.next();
    return o = i.done, i;
  }, e: function(i) {
    l = !0, a = i;
  }, f: function() {
    try {
      o || r.return == null || r.return();
    } finally {
      if (l)
        throw a;
    }
  } };
}
function hE(t, e) {
  return t(e = { exports: {} }, e.exports), e.exports;
}
var Ya = hE(function(t, e) {
  (function r(s) {
    var n, a, o, l, i, u;
    function c(A) {
      var b, v, C = {};
      for (b in A)
        A.hasOwnProperty(b) && (v = A[b], C[b] = typeof v == "object" && v !== null ? c(v) : v);
      return C;
    }
    function f(A, b) {
      this.parent = A, this.key = b;
    }
    function h(A, b, v, C) {
      this.node = A, this.path = b, this.wrap = v, this.ref = C;
    }
    function p() {
    }
    function m(A) {
      return A != null && typeof A == "object" && typeof A.type == "string";
    }
    function d(A, b) {
      return (A === n.ObjectExpression || A === n.ObjectPattern) && b === "properties";
    }
    function g(A, b) {
      for (var v = A.length - 1; v >= 0; --v)
        if (A[v].node === b)
          return !0;
      return !1;
    }
    function y(A, b) {
      return new p().traverse(A, b);
    }
    function x(A, b) {
      var v;
      return v = function(C, T) {
        var w, B, I, _;
        for (B = C.length, I = 0; B; )
          T(C[_ = I + (w = B >>> 1)]) ? B = w : (I = _ + 1, B -= w + 1);
        return I;
      }(b, function(C) {
        return C.range[0] > A.range[0];
      }), A.extendedRange = [A.range[0], A.range[1]], v !== b.length && (A.extendedRange[1] = b[v].range[0]), (v -= 1) >= 0 && (A.extendedRange[0] = b[v].range[1]), A;
    }
    return n = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ChainExpression: "ChainExpression", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ComprehensionBlock: "ComprehensionBlock", ComprehensionExpression: "ComprehensionExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DebuggerStatement: "DebuggerStatement", DirectiveStatement: "DirectiveStatement", DoWhileStatement: "DoWhileStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", GeneratorExpression: "GeneratorExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportExpression: "ImportExpression", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", ModuleSpecifier: "ModuleSpecifier", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchStatement: "SwitchStatement", SwitchCase: "SwitchCase", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" }, o = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ComprehensionBlock: ["left", "right"], ComprehensionExpression: ["blocks", "filter", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], GeneratorExpression: ["blocks", "filter", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportExpression: ["source"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], Program: ["body"], Property: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] }, a = { Break: l = {}, Skip: i = {}, Remove: u = {} }, f.prototype.replace = function(A) {
      this.parent[this.key] = A;
    }, f.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    }, p.prototype.path = function() {
      var A, b, v, C, T;
      function w(B, I) {
        if (Array.isArray(I))
          for (v = 0, C = I.length; v < C; ++v)
            B.push(I[v]);
        else
          B.push(I);
      }
      if (!this.__current.path)
        return null;
      for (T = [], A = 2, b = this.__leavelist.length; A < b; ++A)
        w(T, this.__leavelist[A].path);
      return w(T, this.__current.path), T;
    }, p.prototype.type = function() {
      return this.current().type || this.__current.wrap;
    }, p.prototype.parents = function() {
      var A, b, v;
      for (v = [], A = 1, b = this.__leavelist.length; A < b; ++A)
        v.push(this.__leavelist[A].node);
      return v;
    }, p.prototype.current = function() {
      return this.__current.node;
    }, p.prototype.__execute = function(A, b) {
      var v, C;
      return C = void 0, v = this.__current, this.__current = b, this.__state = null, A && (C = A.call(this, b.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = v, C;
    }, p.prototype.notify = function(A) {
      this.__state = A;
    }, p.prototype.skip = function() {
      this.notify(i);
    }, p.prototype.break = function() {
      this.notify(l);
    }, p.prototype.remove = function() {
      this.notify(u);
    }, p.prototype.__initialize = function(A, b) {
      this.visitor = b, this.root = A, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, b.fallback === "iteration" ? this.__fallback = Object.keys : typeof b.fallback == "function" && (this.__fallback = b.fallback), this.__keys = o, b.keys && (this.__keys = Object.assign(Object.create(this.__keys), b.keys));
    }, p.prototype.traverse = function(A, b) {
      var v, C, T, w, B, I, _, S, F, N, k, j;
      for (this.__initialize(A, b), j = {}, v = this.__worklist, C = this.__leavelist, v.push(new h(A, null, null, null)), C.push(new h(null, null, null, null)); v.length; )
        if ((T = v.pop()) !== j) {
          if (T.node) {
            if (I = this.__execute(b.enter, T), this.__state === l || I === l)
              return;
            if (v.push(j), C.push(T), this.__state === i || I === i)
              continue;
            if (B = (w = T.node).type || T.wrap, !(N = this.__keys[B])) {
              if (!this.__fallback)
                throw new Error("Unknown node type " + B + ".");
              N = this.__fallback(w);
            }
            for (S = N.length; (S -= 1) >= 0; )
              if (k = w[_ = N[S]]) {
                if (Array.isArray(k)) {
                  for (F = k.length; (F -= 1) >= 0; )
                    if (k[F] && !g(C, k[F])) {
                      if (d(B, N[S]))
                        T = new h(k[F], [_, F], "Property", null);
                      else {
                        if (!m(k[F]))
                          continue;
                        T = new h(k[F], [_, F], null, null);
                      }
                      v.push(T);
                    }
                } else if (m(k)) {
                  if (g(C, k))
                    continue;
                  v.push(new h(k, _, null, null));
                }
              }
          }
        } else if (T = C.pop(), I = this.__execute(b.leave, T), this.__state === l || I === l)
          return;
    }, p.prototype.replace = function(A, b) {
      var v, C, T, w, B, I, _, S, F, N, k, j, O;
      function z(te) {
        var se, ye, Se, xe;
        if (te.ref.remove()) {
          for (ye = te.ref.key, xe = te.ref.parent, se = v.length; se--; )
            if ((Se = v[se]).ref && Se.ref.parent === xe) {
              if (Se.ref.key < ye)
                break;
              --Se.ref.key;
            }
        }
      }
      for (this.__initialize(A, b), k = {}, v = this.__worklist, C = this.__leavelist, I = new h(A, null, null, new f(j = { root: A }, "root")), v.push(I), C.push(I); v.length; )
        if ((I = v.pop()) !== k) {
          if ((B = this.__execute(b.enter, I)) !== void 0 && B !== l && B !== i && B !== u && (I.ref.replace(B), I.node = B), this.__state !== u && B !== u || (z(I), I.node = null), this.__state === l || B === l)
            return j.root;
          if ((T = I.node) && (v.push(k), C.push(I), this.__state !== i && B !== i)) {
            if (w = T.type || I.wrap, !(F = this.__keys[w])) {
              if (!this.__fallback)
                throw new Error("Unknown node type " + w + ".");
              F = this.__fallback(T);
            }
            for (_ = F.length; (_ -= 1) >= 0; )
              if (N = T[O = F[_]])
                if (Array.isArray(N)) {
                  for (S = N.length; (S -= 1) >= 0; )
                    if (N[S]) {
                      if (d(w, F[_]))
                        I = new h(N[S], [O, S], "Property", new f(N, S));
                      else {
                        if (!m(N[S]))
                          continue;
                        I = new h(N[S], [O, S], null, new f(N, S));
                      }
                      v.push(I);
                    }
                } else
                  m(N) && v.push(new h(N, O, null, new f(T, O)));
          }
        } else if (I = C.pop(), (B = this.__execute(b.leave, I)) !== void 0 && B !== l && B !== i && B !== u && I.ref.replace(B), this.__state !== u && B !== u || z(I), this.__state === l || B === l)
          return j.root;
      return j.root;
    }, s.Syntax = n, s.traverse = y, s.replace = function(A, b) {
      return new p().replace(A, b);
    }, s.attachComments = function(A, b, v) {
      var C, T, w, B, I = [];
      if (!A.range)
        throw new Error("attachComments needs range information");
      if (!v.length) {
        if (b.length) {
          for (w = 0, T = b.length; w < T; w += 1)
            (C = c(b[w])).extendedRange = [0, A.range[0]], I.push(C);
          A.leadingComments = I;
        }
        return A;
      }
      for (w = 0, T = b.length; w < T; w += 1)
        I.push(x(c(b[w]), v));
      return B = 0, y(A, { enter: function(_) {
        for (var S; B < I.length && !((S = I[B]).extendedRange[1] > _.range[0]); )
          S.extendedRange[1] === _.range[0] ? (_.leadingComments || (_.leadingComments = []), _.leadingComments.push(S), I.splice(B, 1)) : B += 1;
        return B === I.length ? a.Break : I[B].extendedRange[0] > _.range[1] ? a.Skip : void 0;
      } }), B = 0, y(A, { leave: function(_) {
        for (var S; B < I.length && (S = I[B], !(_.range[1] < S.extendedRange[0])); )
          _.range[1] === S.extendedRange[0] ? (_.trailingComments || (_.trailingComments = []), _.trailingComments.push(S), I.splice(B, 1)) : B += 1;
        return B === I.length ? a.Break : I[B].extendedRange[0] > _.range[1] ? a.Skip : void 0;
      } }), A;
    }, s.VisitorKeys = o, s.VisitorOption = a, s.Controller = p, s.cloneEnvironment = function() {
      return r({});
    }, s;
  })(e);
}), n2 = hE(function(t) {
  t.exports && (t.exports = function() {
    function e(r, s, n, a) {
      this.message = r, this.expected = s, this.found = n, this.location = a, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, e);
    }
    return function(r, s) {
      function n() {
        this.constructor = r;
      }
      n.prototype = s.prototype, r.prototype = new n();
    }(e, Error), e.buildMessage = function(r, s) {
      var n = { literal: function(i) {
        return '"' + o(i.text) + '"';
      }, class: function(i) {
        var u, c = "";
        for (u = 0; u < i.parts.length; u++)
          c += i.parts[u] instanceof Array ? l(i.parts[u][0]) + "-" + l(i.parts[u][1]) : l(i.parts[u]);
        return "[" + (i.inverted ? "^" : "") + c + "]";
      }, any: function(i) {
        return "any character";
      }, end: function(i) {
        return "end of input";
      }, other: function(i) {
        return i.description;
      } };
      function a(i) {
        return i.charCodeAt(0).toString(16).toUpperCase();
      }
      function o(i) {
        return i.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(u) {
          return "\\x0" + a(u);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(u) {
          return "\\x" + a(u);
        });
      }
      function l(i) {
        return i.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(u) {
          return "\\x0" + a(u);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(u) {
          return "\\x" + a(u);
        });
      }
      return "Expected " + function(i) {
        var u, c, f, h = new Array(i.length);
        for (u = 0; u < i.length; u++)
          h[u] = (f = i[u], n[f.type](f));
        if (h.sort(), h.length > 0) {
          for (u = 1, c = 1; u < h.length; u++)
            h[u - 1] !== h[u] && (h[c] = h[u], c++);
          h.length = c;
        }
        switch (h.length) {
          case 1:
            return h[0];
          case 2:
            return h[0] + " or " + h[1];
          default:
            return h.slice(0, -1).join(", ") + ", or " + h[h.length - 1];
        }
      }(r) + " but " + function(i) {
        return i ? '"' + o(i) + '"' : "end of input";
      }(s) + " found.";
    }, { SyntaxError: e, parse: function(r, s) {
      s = s !== void 0 ? s : {};
      var n, a, o, l, i = {}, u = { start: Z }, c = Z, f = qe(" ", !1), h = /^[^ [\],():#!=><~+.]/, p = Be([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], !0, !1), m = qe(">", !1), d = qe("~", !1), g = qe("+", !1), y = qe(",", !1), x = qe("!", !1), A = qe("*", !1), b = qe("#", !1), v = qe("[", !1), C = qe("]", !1), T = /^[><!]/, w = Be([">", "<", "!"], !1, !1), B = qe("=", !1), I = function(oe) {
        return (oe || "") + "=";
      }, _ = /^[><]/, S = Be([">", "<"], !1, !1), F = qe(".", !1), N = function(oe, be, ke) {
        return { type: "attribute", name: oe, operator: be, value: ke };
      }, k = qe('"', !1), j = /^[^\\"]/, O = Be(["\\", '"'], !0, !1), z = qe("\\", !1), te = { type: "any" }, se = function(oe, be) {
        return oe + be;
      }, ye = function(oe) {
        return { type: "literal", value: (be = oe.join(""), be.replace(/\\(.)/g, function(ke, re) {
          switch (re) {
            case "b":
              return "\b";
            case "f":
              return "\f";
            case "n":
              return `
`;
            case "r":
              return "\r";
            case "t":
              return "	";
            case "v":
              return "\v";
            default:
              return re;
          }
        })) };
        var be;
      }, Se = qe("'", !1), xe = /^[^\\']/, Ae = Be(["\\", "'"], !0, !1), _e = /^[0-9]/, H = Be([["0", "9"]], !1, !1), Q = qe("type(", !1), ge = /^[^ )]/, ae = Be([" ", ")"], !0, !1), ee = qe(")", !1), he = /^[imsu]/, R = Be(["i", "m", "s", "u"], !1, !1), D = qe("/", !1), U = /^[^\/]/, ne = Be(["/"], !0, !1), pe = qe(":not(", !1), Ee = qe(":matches(", !1), Re = qe(":has(", !1), We = qe(":first-child", !1), wt = qe(":last-child", !1), Lt = qe(":nth-child(", !1), et = qe(":nth-last-child(", !1), Ge = qe(":", !1), mt = qe("statement", !0), tr = qe("expression", !0), vr = qe("declaration", !0), Er = qe("function", !0), hr = qe("pattern", !0), P = 0, It = [{ line: 1, column: 1 }], St = 0, rr = [], Te = {};
      if ("startRule" in s) {
        if (!(s.startRule in u))
          throw new Error(`Can't start parsing from rule "` + s.startRule + '".');
        c = u[s.startRule];
      }
      function qe(oe, be) {
        return { type: "literal", text: oe, ignoreCase: be };
      }
      function Be(oe, be, ke) {
        return { type: "class", parts: oe, inverted: be, ignoreCase: ke };
      }
      function At(oe) {
        var be, ke = It[oe];
        if (ke)
          return ke;
        for (be = oe - 1; !It[be]; )
          be--;
        for (ke = { line: (ke = It[be]).line, column: ke.column }; be < oe; )
          r.charCodeAt(be) === 10 ? (ke.line++, ke.column = 1) : ke.column++, be++;
        return It[oe] = ke, ke;
      }
      function bt(oe, be) {
        var ke = At(oe), re = At(be);
        return { start: { offset: oe, line: ke.line, column: ke.column }, end: { offset: be, line: re.line, column: re.column } };
      }
      function Ce(oe) {
        P < St || (P > St && (St = P, rr = []), rr.push(oe));
      }
      function Z() {
        var oe, be, ke, re, M = 30 * P + 0, L = Te[M];
        return L ? (P = L.nextPos, L.result) : (oe = P, (be = W()) !== i && (ke = le()) !== i && W() !== i ? oe = be = (re = ke).length === 1 ? re[0] : { type: "matches", selectors: re } : (P = oe, oe = i), oe === i && (oe = P, (be = W()) !== i && (be = void 0), oe = be), Te[M] = { nextPos: P, result: oe }, oe);
      }
      function W() {
        var oe, be, ke = 30 * P + 1, re = Te[ke];
        if (re)
          return P = re.nextPos, re.result;
        for (oe = [], r.charCodeAt(P) === 32 ? (be = " ", P++) : (be = i, Ce(f)); be !== i; )
          oe.push(be), r.charCodeAt(P) === 32 ? (be = " ", P++) : (be = i, Ce(f));
        return Te[ke] = { nextPos: P, result: oe }, oe;
      }
      function G() {
        var oe, be, ke, re = 30 * P + 2, M = Te[re];
        if (M)
          return P = M.nextPos, M.result;
        if (be = [], h.test(r.charAt(P)) ? (ke = r.charAt(P), P++) : (ke = i, Ce(p)), ke !== i)
          for (; ke !== i; )
            be.push(ke), h.test(r.charAt(P)) ? (ke = r.charAt(P), P++) : (ke = i, Ce(p));
        else
          be = i;
        return be !== i && (be = be.join("")), oe = be, Te[re] = { nextPos: P, result: oe }, oe;
      }
      function J() {
        var oe, be, ke, re = 30 * P + 3, M = Te[re];
        return M ? (P = M.nextPos, M.result) : (oe = P, (be = W()) !== i ? (r.charCodeAt(P) === 62 ? (ke = ">", P++) : (ke = i, Ce(m)), ke !== i && W() !== i ? oe = be = "child" : (P = oe, oe = i)) : (P = oe, oe = i), oe === i && (oe = P, (be = W()) !== i ? (r.charCodeAt(P) === 126 ? (ke = "~", P++) : (ke = i, Ce(d)), ke !== i && W() !== i ? oe = be = "sibling" : (P = oe, oe = i)) : (P = oe, oe = i), oe === i && (oe = P, (be = W()) !== i ? (r.charCodeAt(P) === 43 ? (ke = "+", P++) : (ke = i, Ce(g)), ke !== i && W() !== i ? oe = be = "adjacent" : (P = oe, oe = i)) : (P = oe, oe = i), oe === i && (oe = P, r.charCodeAt(P) === 32 ? (be = " ", P++) : (be = i, Ce(f)), be !== i && (ke = W()) !== i ? oe = be = "descendant" : (P = oe, oe = i)))), Te[re] = { nextPos: P, result: oe }, oe);
      }
      function le() {
        var oe, be, ke, re, M, L, V, K, X = 30 * P + 4, de = Te[X];
        if (de)
          return P = de.nextPos, de.result;
        if (oe = P, (be = ce()) !== i) {
          for (ke = [], re = P, (M = W()) !== i ? (r.charCodeAt(P) === 44 ? (L = ",", P++) : (L = i, Ce(y)), L !== i && (V = W()) !== i && (K = ce()) !== i ? re = M = [M, L, V, K] : (P = re, re = i)) : (P = re, re = i); re !== i; )
            ke.push(re), re = P, (M = W()) !== i ? (r.charCodeAt(P) === 44 ? (L = ",", P++) : (L = i, Ce(y)), L !== i && (V = W()) !== i && (K = ce()) !== i ? re = M = [M, L, V, K] : (P = re, re = i)) : (P = re, re = i);
          ke !== i ? oe = be = [be].concat(ke.map(function(we) {
            return we[3];
          })) : (P = oe, oe = i);
        } else
          P = oe, oe = i;
        return Te[X] = { nextPos: P, result: oe }, oe;
      }
      function ce() {
        var oe, be, ke, re, M, L, V, K = 30 * P + 5, X = Te[K];
        if (X)
          return P = X.nextPos, X.result;
        if (oe = P, (be = Fe()) !== i) {
          for (ke = [], re = P, (M = J()) !== i && (L = Fe()) !== i ? re = M = [M, L] : (P = re, re = i); re !== i; )
            ke.push(re), re = P, (M = J()) !== i && (L = Fe()) !== i ? re = M = [M, L] : (P = re, re = i);
          ke !== i ? (V = be, oe = be = ke.reduce(function(de, we) {
            return { type: we[0], left: de, right: we[1] };
          }, V)) : (P = oe, oe = i);
        } else
          P = oe, oe = i;
        return Te[K] = { nextPos: P, result: oe }, oe;
      }
      function Fe() {
        var oe, be, ke, re, M, L, V, K = 30 * P + 6, X = Te[K];
        if (X)
          return P = X.nextPos, X.result;
        if (oe = P, r.charCodeAt(P) === 33 ? (be = "!", P++) : (be = i, Ce(x)), be === i && (be = null), be !== i) {
          if (ke = [], (re = Ve()) !== i)
            for (; re !== i; )
              ke.push(re), re = Ve();
          else
            ke = i;
          ke !== i ? (M = be, V = (L = ke).length === 1 ? L[0] : { type: "compound", selectors: L }, M && (V.subject = !0), oe = be = V) : (P = oe, oe = i);
        } else
          P = oe, oe = i;
        return Te[K] = { nextPos: P, result: oe }, oe;
      }
      function Ve() {
        var oe, be = 30 * P + 7, ke = Te[be];
        return ke ? (P = ke.nextPos, ke.result) : ((oe = function() {
          var re, M, L = 30 * P + 8, V = Te[L];
          return V ? (P = V.nextPos, V.result) : (r.charCodeAt(P) === 42 ? (M = "*", P++) : (M = i, Ce(A)), M !== i && (M = { type: "wildcard", value: M }), re = M, Te[L] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L, V = 30 * P + 9, K = Te[V];
          return K ? (P = K.nextPos, K.result) : (re = P, r.charCodeAt(P) === 35 ? (M = "#", P++) : (M = i, Ce(b)), M === i && (M = null), M !== i && (L = G()) !== i ? re = M = { type: "identifier", value: L } : (P = re, re = i), Te[V] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L, V, K = 30 * P + 10, X = Te[K];
          return X ? (P = X.nextPos, X.result) : (re = P, r.charCodeAt(P) === 91 ? (M = "[", P++) : (M = i, Ce(v)), M !== i && W() !== i && (L = function() {
            var de, we, Me, Ne, tt = 30 * P + 14, je = Te[tt];
            return je ? (P = je.nextPos, je.result) : (de = P, (we = Ye()) !== i && W() !== i && (Me = function() {
              var fe, De, ve, ue = 30 * P + 12, Pe = Te[ue];
              return Pe ? (P = Pe.nextPos, Pe.result) : (fe = P, r.charCodeAt(P) === 33 ? (De = "!", P++) : (De = i, Ce(x)), De === i && (De = null), De !== i ? (r.charCodeAt(P) === 61 ? (ve = "=", P++) : (ve = i, Ce(B)), ve !== i ? (De = I(De), fe = De) : (P = fe, fe = i)) : (P = fe, fe = i), Te[ue] = { nextPos: P, result: fe }, fe);
            }()) !== i && W() !== i ? ((Ne = function() {
              var fe, De, ve, ue, Pe, Oe = 30 * P + 18, at = Te[Oe];
              if (at)
                return P = at.nextPos, at.result;
              if (fe = P, r.substr(P, 5) === "type(" ? (De = "type(", P += 5) : (De = i, Ce(Q)), De !== i)
                if (W() !== i) {
                  if (ve = [], ge.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(ae)), ue !== i)
                    for (; ue !== i; )
                      ve.push(ue), ge.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(ae));
                  else
                    ve = i;
                  ve !== i && (ue = W()) !== i ? (r.charCodeAt(P) === 41 ? (Pe = ")", P++) : (Pe = i, Ce(ee)), Pe !== i ? (De = { type: "type", value: ve.join("") }, fe = De) : (P = fe, fe = i)) : (P = fe, fe = i);
                } else
                  P = fe, fe = i;
              else
                P = fe, fe = i;
              return Te[Oe] = { nextPos: P, result: fe }, fe;
            }()) === i && (Ne = function() {
              var fe, De, ve, ue, Pe, Oe, at = 30 * P + 20, ut = Te[at];
              if (ut)
                return P = ut.nextPos, ut.result;
              if (fe = P, r.charCodeAt(P) === 47 ? (De = "/", P++) : (De = i, Ce(D)), De !== i) {
                if (ve = [], U.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(ne)), ue !== i)
                  for (; ue !== i; )
                    ve.push(ue), U.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(ne));
                else
                  ve = i;
                ve !== i ? (r.charCodeAt(P) === 47 ? (ue = "/", P++) : (ue = i, Ce(D)), ue !== i ? ((Pe = function() {
                  var dt, Dt, zt = 30 * P + 19, kt = Te[zt];
                  if (kt)
                    return P = kt.nextPos, kt.result;
                  if (dt = [], he.test(r.charAt(P)) ? (Dt = r.charAt(P), P++) : (Dt = i, Ce(R)), Dt !== i)
                    for (; Dt !== i; )
                      dt.push(Dt), he.test(r.charAt(P)) ? (Dt = r.charAt(P), P++) : (Dt = i, Ce(R));
                  else
                    dt = i;
                  return Te[zt] = { nextPos: P, result: dt }, dt;
                }()) === i && (Pe = null), Pe !== i ? (Oe = Pe, De = { type: "regexp", value: new RegExp(ve.join(""), Oe ? Oe.join("") : "") }, fe = De) : (P = fe, fe = i)) : (P = fe, fe = i)) : (P = fe, fe = i);
              } else
                P = fe, fe = i;
              return Te[at] = { nextPos: P, result: fe }, fe;
            }()), Ne !== i ? (we = N(we, Me, Ne), de = we) : (P = de, de = i)) : (P = de, de = i), de === i && (de = P, (we = Ye()) !== i && W() !== i && (Me = function() {
              var fe, De, ve, ue = 30 * P + 11, Pe = Te[ue];
              return Pe ? (P = Pe.nextPos, Pe.result) : (fe = P, T.test(r.charAt(P)) ? (De = r.charAt(P), P++) : (De = i, Ce(w)), De === i && (De = null), De !== i ? (r.charCodeAt(P) === 61 ? (ve = "=", P++) : (ve = i, Ce(B)), ve !== i ? (De = I(De), fe = De) : (P = fe, fe = i)) : (P = fe, fe = i), fe === i && (_.test(r.charAt(P)) ? (fe = r.charAt(P), P++) : (fe = i, Ce(S))), Te[ue] = { nextPos: P, result: fe }, fe);
            }()) !== i && W() !== i ? ((Ne = function() {
              var fe, De, ve, ue, Pe, Oe, at = 30 * P + 15, ut = Te[at];
              if (ut)
                return P = ut.nextPos, ut.result;
              if (fe = P, r.charCodeAt(P) === 34 ? (De = '"', P++) : (De = i, Ce(k)), De !== i) {
                for (ve = [], j.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(O)), ue === i && (ue = P, r.charCodeAt(P) === 92 ? (Pe = "\\", P++) : (Pe = i, Ce(z)), Pe !== i ? (r.length > P ? (Oe = r.charAt(P), P++) : (Oe = i, Ce(te)), Oe !== i ? (Pe = se(Pe, Oe), ue = Pe) : (P = ue, ue = i)) : (P = ue, ue = i)); ue !== i; )
                  ve.push(ue), j.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(O)), ue === i && (ue = P, r.charCodeAt(P) === 92 ? (Pe = "\\", P++) : (Pe = i, Ce(z)), Pe !== i ? (r.length > P ? (Oe = r.charAt(P), P++) : (Oe = i, Ce(te)), Oe !== i ? (Pe = se(Pe, Oe), ue = Pe) : (P = ue, ue = i)) : (P = ue, ue = i));
                ve !== i ? (r.charCodeAt(P) === 34 ? (ue = '"', P++) : (ue = i, Ce(k)), ue !== i ? (De = ye(ve), fe = De) : (P = fe, fe = i)) : (P = fe, fe = i);
              } else
                P = fe, fe = i;
              if (fe === i)
                if (fe = P, r.charCodeAt(P) === 39 ? (De = "'", P++) : (De = i, Ce(Se)), De !== i) {
                  for (ve = [], xe.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(Ae)), ue === i && (ue = P, r.charCodeAt(P) === 92 ? (Pe = "\\", P++) : (Pe = i, Ce(z)), Pe !== i ? (r.length > P ? (Oe = r.charAt(P), P++) : (Oe = i, Ce(te)), Oe !== i ? (Pe = se(Pe, Oe), ue = Pe) : (P = ue, ue = i)) : (P = ue, ue = i)); ue !== i; )
                    ve.push(ue), xe.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(Ae)), ue === i && (ue = P, r.charCodeAt(P) === 92 ? (Pe = "\\", P++) : (Pe = i, Ce(z)), Pe !== i ? (r.length > P ? (Oe = r.charAt(P), P++) : (Oe = i, Ce(te)), Oe !== i ? (Pe = se(Pe, Oe), ue = Pe) : (P = ue, ue = i)) : (P = ue, ue = i));
                  ve !== i ? (r.charCodeAt(P) === 39 ? (ue = "'", P++) : (ue = i, Ce(Se)), ue !== i ? (De = ye(ve), fe = De) : (P = fe, fe = i)) : (P = fe, fe = i);
                } else
                  P = fe, fe = i;
              return Te[at] = { nextPos: P, result: fe }, fe;
            }()) === i && (Ne = function() {
              var fe, De, ve, ue, Pe, Oe, at, ut = 30 * P + 16, dt = Te[ut];
              if (dt)
                return P = dt.nextPos, dt.result;
              for (fe = P, De = P, ve = [], _e.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(H)); ue !== i; )
                ve.push(ue), _e.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(H));
              if (ve !== i ? (r.charCodeAt(P) === 46 ? (ue = ".", P++) : (ue = i, Ce(F)), ue !== i ? De = ve = [ve, ue] : (P = De, De = i)) : (P = De, De = i), De === i && (De = null), De !== i) {
                if (ve = [], _e.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(H)), ue !== i)
                  for (; ue !== i; )
                    ve.push(ue), _e.test(r.charAt(P)) ? (ue = r.charAt(P), P++) : (ue = i, Ce(H));
                else
                  ve = i;
                ve !== i ? (Oe = ve, at = (Pe = De) ? [].concat.apply([], Pe).join("") : "", De = { type: "literal", value: parseFloat(at + Oe.join("")) }, fe = De) : (P = fe, fe = i);
              } else
                P = fe, fe = i;
              return Te[ut] = { nextPos: P, result: fe }, fe;
            }()) === i && (Ne = function() {
              var fe, De, ve = 30 * P + 17, ue = Te[ve];
              return ue ? (P = ue.nextPos, ue.result) : ((De = G()) !== i && (De = { type: "literal", value: De }), fe = De, Te[ve] = { nextPos: P, result: fe }, fe);
            }()), Ne !== i ? (we = N(we, Me, Ne), de = we) : (P = de, de = i)) : (P = de, de = i), de === i && (de = P, (we = Ye()) !== i && (we = { type: "attribute", name: we }), de = we)), Te[tt] = { nextPos: P, result: de }, de);
          }()) !== i && W() !== i ? (r.charCodeAt(P) === 93 ? (V = "]", P++) : (V = i, Ce(C)), V !== i ? re = M = L : (P = re, re = i)) : (P = re, re = i), Te[K] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L, V, K, X, de, we, Me = 30 * P + 21, Ne = Te[Me];
          if (Ne)
            return P = Ne.nextPos, Ne.result;
          if (re = P, r.charCodeAt(P) === 46 ? (M = ".", P++) : (M = i, Ce(F)), M !== i)
            if ((L = G()) !== i) {
              for (V = [], K = P, r.charCodeAt(P) === 46 ? (X = ".", P++) : (X = i, Ce(F)), X !== i && (de = G()) !== i ? K = X = [X, de] : (P = K, K = i); K !== i; )
                V.push(K), K = P, r.charCodeAt(P) === 46 ? (X = ".", P++) : (X = i, Ce(F)), X !== i && (de = G()) !== i ? K = X = [X, de] : (P = K, K = i);
              V !== i ? (we = L, M = { type: "field", name: V.reduce(function(tt, je) {
                return tt + je[0] + je[1];
              }, we) }, re = M) : (P = re, re = i);
            } else
              P = re, re = i;
          else
            P = re, re = i;
          return Te[Me] = { nextPos: P, result: re }, re;
        }()) === i && (oe = function() {
          var re, M, L, V, K = 30 * P + 22, X = Te[K];
          return X ? (P = X.nextPos, X.result) : (re = P, r.substr(P, 5) === ":not(" ? (M = ":not(", P += 5) : (M = i, Ce(pe)), M !== i && W() !== i && (L = le()) !== i && W() !== i ? (r.charCodeAt(P) === 41 ? (V = ")", P++) : (V = i, Ce(ee)), V !== i ? re = M = { type: "not", selectors: L } : (P = re, re = i)) : (P = re, re = i), Te[K] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L, V, K = 30 * P + 23, X = Te[K];
          return X ? (P = X.nextPos, X.result) : (re = P, r.substr(P, 9) === ":matches(" ? (M = ":matches(", P += 9) : (M = i, Ce(Ee)), M !== i && W() !== i && (L = le()) !== i && W() !== i ? (r.charCodeAt(P) === 41 ? (V = ")", P++) : (V = i, Ce(ee)), V !== i ? re = M = { type: "matches", selectors: L } : (P = re, re = i)) : (P = re, re = i), Te[K] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L, V, K = 30 * P + 24, X = Te[K];
          return X ? (P = X.nextPos, X.result) : (re = P, r.substr(P, 5) === ":has(" ? (M = ":has(", P += 5) : (M = i, Ce(Re)), M !== i && W() !== i && (L = le()) !== i && W() !== i ? (r.charCodeAt(P) === 41 ? (V = ")", P++) : (V = i, Ce(ee)), V !== i ? re = M = { type: "has", selectors: L } : (P = re, re = i)) : (P = re, re = i), Te[K] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L = 30 * P + 25, V = Te[L];
          return V ? (P = V.nextPos, V.result) : (r.substr(P, 12) === ":first-child" ? (M = ":first-child", P += 12) : (M = i, Ce(We)), M !== i && (M = lt(1)), re = M, Te[L] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L = 30 * P + 26, V = Te[L];
          return V ? (P = V.nextPos, V.result) : (r.substr(P, 11) === ":last-child" ? (M = ":last-child", P += 11) : (M = i, Ce(wt)), M !== i && (M = xt(1)), re = M, Te[L] = { nextPos: P, result: re }, re);
        }()) === i && (oe = function() {
          var re, M, L, V, K, X = 30 * P + 27, de = Te[X];
          if (de)
            return P = de.nextPos, de.result;
          if (re = P, r.substr(P, 11) === ":nth-child(" ? (M = ":nth-child(", P += 11) : (M = i, Ce(Lt)), M !== i)
            if (W() !== i) {
              if (L = [], _e.test(r.charAt(P)) ? (V = r.charAt(P), P++) : (V = i, Ce(H)), V !== i)
                for (; V !== i; )
                  L.push(V), _e.test(r.charAt(P)) ? (V = r.charAt(P), P++) : (V = i, Ce(H));
              else
                L = i;
              L !== i && (V = W()) !== i ? (r.charCodeAt(P) === 41 ? (K = ")", P++) : (K = i, Ce(ee)), K !== i ? (M = lt(parseInt(L.join(""), 10)), re = M) : (P = re, re = i)) : (P = re, re = i);
            } else
              P = re, re = i;
          else
            P = re, re = i;
          return Te[X] = { nextPos: P, result: re }, re;
        }()) === i && (oe = function() {
          var re, M, L, V, K, X = 30 * P + 28, de = Te[X];
          if (de)
            return P = de.nextPos, de.result;
          if (re = P, r.substr(P, 16) === ":nth-last-child(" ? (M = ":nth-last-child(", P += 16) : (M = i, Ce(et)), M !== i)
            if (W() !== i) {
              if (L = [], _e.test(r.charAt(P)) ? (V = r.charAt(P), P++) : (V = i, Ce(H)), V !== i)
                for (; V !== i; )
                  L.push(V), _e.test(r.charAt(P)) ? (V = r.charAt(P), P++) : (V = i, Ce(H));
              else
                L = i;
              L !== i && (V = W()) !== i ? (r.charCodeAt(P) === 41 ? (K = ")", P++) : (K = i, Ce(ee)), K !== i ? (M = xt(parseInt(L.join(""), 10)), re = M) : (P = re, re = i)) : (P = re, re = i);
            } else
              P = re, re = i;
          else
            P = re, re = i;
          return Te[X] = { nextPos: P, result: re }, re;
        }()) === i && (oe = function() {
          var re, M, L, V = 30 * P + 29, K = Te[V];
          return K ? (P = K.nextPos, K.result) : (re = P, r.charCodeAt(P) === 58 ? (M = ":", P++) : (M = i, Ce(Ge)), M !== i ? (r.substr(P, 9).toLowerCase() === "statement" ? (L = r.substr(P, 9), P += 9) : (L = i, Ce(mt)), L === i && (r.substr(P, 10).toLowerCase() === "expression" ? (L = r.substr(P, 10), P += 10) : (L = i, Ce(tr)), L === i && (r.substr(P, 11).toLowerCase() === "declaration" ? (L = r.substr(P, 11), P += 11) : (L = i, Ce(vr)), L === i && (r.substr(P, 8).toLowerCase() === "function" ? (L = r.substr(P, 8), P += 8) : (L = i, Ce(Er)), L === i && (r.substr(P, 7).toLowerCase() === "pattern" ? (L = r.substr(P, 7), P += 7) : (L = i, Ce(hr)))))), L !== i ? re = M = { type: "class", name: L } : (P = re, re = i)) : (P = re, re = i), Te[V] = { nextPos: P, result: re }, re);
        }()), Te[be] = { nextPos: P, result: oe }, oe);
      }
      function Ye() {
        var oe, be, ke, re, M, L, V, K, X = 30 * P + 13, de = Te[X];
        if (de)
          return P = de.nextPos, de.result;
        if (oe = P, (be = G()) !== i) {
          for (ke = [], re = P, r.charCodeAt(P) === 46 ? (M = ".", P++) : (M = i, Ce(F)), M !== i && (L = G()) !== i ? re = M = [M, L] : (P = re, re = i); re !== i; )
            ke.push(re), re = P, r.charCodeAt(P) === 46 ? (M = ".", P++) : (M = i, Ce(F)), M !== i && (L = G()) !== i ? re = M = [M, L] : (P = re, re = i);
          ke !== i ? (V = be, K = ke, oe = be = [].concat.apply([V], K).join("")) : (P = oe, oe = i);
        } else
          P = oe, oe = i;
        return Te[X] = { nextPos: P, result: oe }, oe;
      }
      function lt(oe) {
        return { type: "nth-child", index: { type: "literal", value: oe } };
      }
      function xt(oe) {
        return { type: "nth-last-child", index: { type: "literal", value: oe } };
      }
      if ((n = c()) !== i && P === r.length)
        return n;
      throw n !== i && P < r.length && Ce({ type: "end" }), a = rr, o = St < r.length ? r.charAt(St) : null, l = St < r.length ? bt(St, St + 1) : bt(St, St), new e(e.buildMessage(a, o), a, o, l);
    } };
  }());
});
function Et(t, e, r, s) {
  if (!e)
    return !0;
  if (!t)
    return !1;
  switch (r || (r = []), e.type) {
    case "wildcard":
      return !0;
    case "identifier":
      return e.value.toLowerCase() === t.type.toLowerCase();
    case "field":
      var n = e.name.split("."), a = r[n.length - 1];
      return function A(b, v, C) {
        if (C.length === 0)
          return b === v;
        if (v == null)
          return !1;
        var T = v[C[0]], w = C.slice(1);
        if (Array.isArray(T)) {
          var B, I = Nr(T);
          try {
            for (I.s(); !(B = I.n()).done; )
              if (A(b, B.value, w))
                return !0;
          } catch (_) {
            I.e(_);
          } finally {
            I.f();
          }
          return !1;
        }
        return A(b, T, w);
      }(t, a, n);
    case "matches":
      var o, l = Nr(e.selectors);
      try {
        for (l.s(); !(o = l.n()).done; ) {
          var i = o.value;
          if (Et(t, i, r, s))
            return !0;
        }
      } catch (A) {
        l.e(A);
      } finally {
        l.f();
      }
      return !1;
    case "compound":
      var u, c = Nr(e.selectors);
      try {
        for (c.s(); !(u = c.n()).done; ) {
          var f = u.value;
          if (!Et(t, f, r, s))
            return !1;
        }
      } catch (A) {
        c.e(A);
      } finally {
        c.f();
      }
      return !0;
    case "not":
      var h, p = Nr(e.selectors);
      try {
        for (p.s(); !(h = p.n()).done; ) {
          var m = h.value;
          if (Et(t, m, r, s))
            return !1;
        }
      } catch (A) {
        p.e(A);
      } finally {
        p.f();
      }
      return !0;
    case "has":
      var d = function() {
        var A, b = [], v = Nr(e.selectors);
        try {
          var C = function() {
            var T = A.value, w = [];
            Ya.traverse(t, { enter: function(B, I) {
              I != null && w.unshift(I), Et(B, T, w, s) && b.push(B);
            }, leave: function() {
              w.shift();
            }, keys: s && s.visitorKeys, fallback: s && s.fallback || "iteration" });
          };
          for (v.s(); !(A = v.n()).done; )
            C();
        } catch (T) {
          v.e(T);
        } finally {
          v.f();
        }
        return { v: b.length !== 0 };
      }();
      if (es(d) === "object")
        return d.v;
    case "child":
      return !!Et(t, e.right, r, s) && Et(r[0], e.left, r.slice(1), s);
    case "descendant":
      if (Et(t, e.right, r, s)) {
        for (var g = 0, y = r.length; g < y; ++g)
          if (Et(r[g], e.left, r.slice(g + 1), s))
            return !0;
      }
      return !1;
    case "attribute":
      var x = function(A, b) {
        var v, C = Nr(b.split("."));
        try {
          for (C.s(); !(v = C.n()).done; ) {
            var T = v.value;
            if (A == null)
              return A;
            A = A[T];
          }
        } catch (w) {
          C.e(w);
        } finally {
          C.f();
        }
        return A;
      }(t, e.name);
      switch (e.operator) {
        case void 0:
          return x != null;
        case "=":
          switch (e.value.type) {
            case "regexp":
              return typeof x == "string" && e.value.value.test(x);
            case "literal":
              return "".concat(e.value.value) === "".concat(x);
            case "type":
              return e.value.value === es(x);
          }
          throw new Error("Unknown selector value type: ".concat(e.value.type));
        case "!=":
          switch (e.value.type) {
            case "regexp":
              return !e.value.value.test(x);
            case "literal":
              return "".concat(e.value.value) !== "".concat(x);
            case "type":
              return e.value.value !== es(x);
          }
          throw new Error("Unknown selector value type: ".concat(e.value.type));
        case "<=":
          return x <= e.value.value;
        case "<":
          return x < e.value.value;
        case ">":
          return x > e.value.value;
        case ">=":
          return x >= e.value.value;
      }
      throw new Error("Unknown operator: ".concat(e.operator));
    case "sibling":
      return Et(t, e.right, r, s) && Ig(t, e.left, r, "LEFT_SIDE", s) || e.left.subject && Et(t, e.left, r, s) && Ig(t, e.right, r, "RIGHT_SIDE", s);
    case "adjacent":
      return Et(t, e.right, r, s) && _g(t, e.left, r, "LEFT_SIDE", s) || e.right.subject && Et(t, e.left, r, s) && _g(t, e.right, r, "RIGHT_SIDE", s);
    case "nth-child":
      return Et(t, e.right, r, s) && Bg(t, r, function() {
        return e.index.value - 1;
      }, s);
    case "nth-last-child":
      return Et(t, e.right, r, s) && Bg(t, r, function(A) {
        return A - e.index.value;
      }, s);
    case "class":
      switch (e.name.toLowerCase()) {
        case "statement":
          if (t.type.slice(-9) === "Statement")
            return !0;
        case "declaration":
          return t.type.slice(-11) === "Declaration";
        case "pattern":
          if (t.type.slice(-7) === "Pattern")
            return !0;
        case "expression":
          return t.type.slice(-10) === "Expression" || t.type.slice(-7) === "Literal" || t.type === "Identifier" && (r.length === 0 || r[0].type !== "MetaProperty") || t.type === "MetaProperty";
        case "function":
          return t.type === "FunctionDeclaration" || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression";
      }
      throw new Error("Unknown class name: ".concat(e.name));
  }
  throw new Error("Unknown selector type: ".concat(e.type));
}
function Vu(t, e) {
  var r = t.type;
  return e && e.visitorKeys && e.visitorKeys[r] ? e.visitorKeys[r] : Ya.VisitorKeys[r] ? Ya.VisitorKeys[r] : e && typeof e.fallback == "function" ? e.fallback(t) : Object.keys(t).filter(function(s) {
    return s !== "type";
  });
}
function Cl(t) {
  return t !== null && es(t) === "object" && typeof t.type == "string";
}
function Ig(t, e, r, s, n) {
  var a = Bi(r, 1)[0];
  if (!a)
    return !1;
  var o, l = Nr(Vu(a, n));
  try {
    for (l.s(); !(o = l.n()).done; ) {
      var i = a[o.value];
      if (Array.isArray(i)) {
        var u = i.indexOf(t);
        if (u < 0)
          continue;
        var c = void 0, f = void 0;
        s === "LEFT_SIDE" ? (c = 0, f = u) : (c = u + 1, f = i.length);
        for (var h = c; h < f; ++h)
          if (Cl(i[h]) && Et(i[h], e, r, n))
            return !0;
      }
    }
  } catch (p) {
    l.e(p);
  } finally {
    l.f();
  }
  return !1;
}
function _g(t, e, r, s, n) {
  var a = Bi(r, 1)[0];
  if (!a)
    return !1;
  var o, l = Nr(Vu(a, n));
  try {
    for (l.s(); !(o = l.n()).done; ) {
      var i = a[o.value];
      if (Array.isArray(i)) {
        var u = i.indexOf(t);
        if (u < 0)
          continue;
        if (s === "LEFT_SIDE" && u > 0 && Cl(i[u - 1]) && Et(i[u - 1], e, r, n) || s === "RIGHT_SIDE" && u < i.length - 1 && Cl(i[u + 1]) && Et(i[u + 1], e, r, n))
          return !0;
      }
    }
  } catch (c) {
    l.e(c);
  } finally {
    l.f();
  }
  return !1;
}
function Bg(t, e, r, s) {
  var n = Bi(e, 1)[0];
  if (!n)
    return !1;
  var a, o = Nr(Vu(n, s));
  try {
    for (o.s(); !(a = o.n()).done; ) {
      var l = n[a.value];
      if (Array.isArray(l)) {
        var i = l.indexOf(t);
        if (i >= 0 && i === r(l.length))
          return !0;
      }
    }
  } catch (u) {
    o.e(u);
  } finally {
    o.f();
  }
  return !1;
}
function mE(t, e) {
  if (t == null || es(t) != "object")
    return [];
  e == null && (e = t);
  for (var r = t.subject ? [e] : [], s = 0, n = function(i) {
    for (var u = [], c = Object.keys(i), f = 0; f < c.length; f++)
      u.push([c[f], i[c[f]]]);
    return u;
  }(t); s < n.length; s++) {
    var a = Bi(n[s], 2), o = a[0], l = a[1];
    r.push.apply(r, r2(mE(l, o === "left" ? l : e)));
  }
  return r;
}
function dE(t, e, r, s) {
  if (e) {
    var n = [], a = mE(e);
    Ya.traverse(t, { enter: function(o, l) {
      if (l != null && n.unshift(l), Et(o, e, n, s))
        if (a.length)
          for (var i = 0, u = a.length; i < u; ++i) {
            Et(o, a[i], n, s) && r(o, l, n);
            for (var c = 0, f = n.length; c < f; ++c) {
              var h = n.slice(c + 1);
              Et(n[c], a[i], h, s) && r(n[c], l, h);
            }
          }
        else
          r(o, l, n);
    }, leave: function() {
      n.shift();
    }, keys: s && s.visitorKeys, fallback: s && s.fallback || "iteration" });
  }
}
function gE(t, e, r) {
  var s = [];
  return dE(t, e, function(n) {
    s.push(n);
  }, r), s;
}
function yE(t) {
  return n2.parse(t);
}
function xn(t, e, r) {
  return gE(t, yE(e), r);
}
xn.parse = yE, xn.match = gE, xn.traverse = dE, xn.matches = Et, xn.query = xn;
var s2 = B0, a2 = cA, i2 = gx, o2 = Wr, l2 = fl.exports, u2 = Kx, Xt = us, c2 = Eu.exports, p2 = T_, f2 = uE, h2 = os, m2 = yu.exports, d2 = cE.exports, g2 = xn;
function er(t) {
  return t && typeof t == "object" && "default" in t ? t : {
    default: t
  };
}
var Is = er(s2), xE = er(a2), vE = er(i2), Za = er(o2), Og = er(l2), y2 = er(u2), Oi = er(c2), x2 = er(p2), EE = er(f2), qt = er(h2), Li = er(m2), v2 = er(d2), bE = er(g2);
const CE = {
  "@babel/highlight": "7.14.5"
}, SE = {
  type: "range",
  registry: !0,
  raw: "eslint@^7.0.0",
  name: "eslint",
  escapedName: "eslint",
  rawSpec: "^7.0.0",
  saveSpec: null,
  fetchSpec: "^7.0.0"
}, AE = ["#DEV:/"], DE = {
  name: "Nicholas C. Zakas",
  email: "nicholas+npm@nczconsulting.com"
}, wE = {
  eslint: "bin/eslint.js"
}, kE = {
  url: "https://github.com/eslint/eslint/issues/"
}, TE = {
  "@babel/code-frame": "7.12.11",
  "@eslint/eslintrc": "^0.4.3",
  "@humanwhocodes/config-array": "^0.5.0",
  ajv: "^6.10.0",
  chalk: "^4.0.0",
  "cross-spawn": "^7.0.2",
  debug: "^4.0.1",
  doctrine: "^3.0.0",
  enquirer: "^2.3.5",
  "escape-string-regexp": "^4.0.0",
  "eslint-scope": "^5.1.1",
  "eslint-utils": "^2.1.0",
  "eslint-visitor-keys": "^2.0.0",
  espree: "^7.3.1",
  esquery: "^1.4.0",
  esutils: "^2.0.2",
  "fast-deep-equal": "^3.1.3",
  "file-entry-cache": "^6.0.1",
  "functional-red-black-tree": "^1.0.1",
  "glob-parent": "^5.1.2",
  globals: "^13.6.0",
  ignore: "^4.0.6",
  "import-fresh": "^3.0.0",
  imurmurhash: "^0.1.4",
  "is-glob": "^4.0.0",
  "js-yaml": "^3.13.1",
  "json-stable-stringify-without-jsonify": "^1.0.1",
  levn: "^0.4.1",
  "lodash.merge": "^4.6.2",
  minimatch: "^3.0.4",
  "natural-compare": "^1.4.0",
  optionator: "^0.9.1",
  progress: "^2.0.0",
  regexpp: "^3.1.0",
  semver: "^7.2.1",
  "strip-ansi": "^6.0.0",
  "strip-json-comments": "^3.1.0",
  table: "^6.0.9",
  "text-table": "^0.2.0",
  "v8-compile-cache": "^2.0.3"
}, FE = {
  "@babel/core": "^7.4.3",
  "@babel/preset-env": "^7.4.3",
  "babel-loader": "^8.0.5",
  chai: "^4.0.1",
  cheerio: "^0.22.0",
  "common-tags": "^1.8.0",
  "core-js": "^3.1.3",
  dateformat: "^3.0.3",
  ejs: "^3.0.2",
  eslint: "file:.",
  "eslint-config-eslint": "file:packages/eslint-config-eslint",
  "eslint-plugin-eslint-plugin": "^3.5.3",
  "eslint-plugin-internal-rules": "file:tools/internal-rules",
  "eslint-plugin-jsdoc": "^25.4.3",
  "eslint-plugin-node": "^11.1.0",
  "eslint-release": "^2.0.0",
  eslump: "^3.0.0",
  esprima: "^4.0.1",
  "fs-teardown": "0.1.1",
  glob: "^7.1.6",
  jsdoc: "^3.5.5",
  karma: "^6.1.1",
  "karma-chrome-launcher": "^3.1.0",
  "karma-mocha": "^2.0.1",
  "karma-mocha-reporter": "^2.2.5",
  "karma-webpack": "^5.0.0",
  "lint-staged": "^10.1.2",
  "load-perf": "^0.2.0",
  markdownlint: "^0.19.0",
  "markdownlint-cli": "^0.22.0",
  memfs: "^3.0.1",
  mocha: "^8.3.2",
  "mocha-junit-reporter": "^2.0.0",
  "node-polyfill-webpack-plugin": "^1.0.3",
  "npm-license": "^0.3.3",
  nyc: "^15.0.1",
  proxyquire: "^2.0.1",
  puppeteer: "^7.1.0",
  recast: "^0.19.0",
  "regenerator-runtime": "^0.13.2",
  shelljs: "^0.8.2",
  sinon: "^9.0.1",
  temp: "^0.9.0",
  webpack: "^5.23.0",
  "webpack-cli": "^4.5.0",
  yorkie: "^2.0.0"
}, PE = {
  node: "^10.12.0 || >=12.0.0"
}, IE = ["LICENSE", "README.md", "bin", "conf", "lib", "messages"], _E = {
  "pre-commit": "lint-staged"
}, BE = ["ast", "lint", "javascript", "ecmascript", "espree"], OE = {
  type: "git",
  url: "git+https://github.com/eslint/eslint.git"
}, LE = {
  docs: "node Makefile.js docs",
  fix: "node Makefile.js lint -- fix",
  fuzz: "node Makefile.js fuzz",
  "generate-alpharelease": "node Makefile.js generatePrerelease -- alpha",
  "generate-betarelease": "node Makefile.js generatePrerelease -- beta",
  "generate-rcrelease": "node Makefile.js generatePrerelease -- rc",
  "generate-release": "node Makefile.js generateRelease",
  gensite: "node Makefile.js gensite",
  lint: "node Makefile.js lint",
  perf: "node Makefile.js perf",
  "publish-release": "node Makefile.js publishRelease",
  test: "node Makefile.js test",
  "test:cli": "mocha",
  webpack: "node Makefile.js webpack"
};
var E2 = {
  _from: "eslint@^7.0.0",
  _id: "eslint@7.32.0",
  _inBundle: !1,
  _integrity: "sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==",
  _location: "/eslint",
  _phantomChildren: CE,
  _requested: SE,
  _requiredBy: AE,
  _resolved: "https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz",
  _shasum: "c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d",
  _spec: "eslint@^7.0.0",
  _where: "/home/runner/work/eslint4b/eslint4b",
  author: DE,
  bin: wE,
  bugs: kE,
  bundleDependencies: !1,
  dependencies: TE,
  deprecated: !1,
  description: "An AST-based pattern checker for JavaScript.",
  devDependencies: FE,
  engines: PE,
  files: IE,
  funding: "https://opencollective.com/eslint",
  gitHooks: _E,
  homepage: "https://eslint.org",
  keywords: BE,
  license: "MIT",
  "lint-staged": {
    "*.js": "eslint --fix",
    "*.md": "markdownlint"
  },
  main: "./lib/api.js",
  name: "eslint",
  repository: OE,
  scripts: LE,
  version: "7.32.0"
}, b2 = Object.freeze({
  __proto__: null,
  _from: "eslint@^7.0.0",
  _id: "eslint@7.32.0",
  _inBundle: !1,
  _integrity: "sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==",
  _location: "/eslint",
  _phantomChildren: CE,
  _requested: SE,
  _requiredBy: AE,
  _resolved: "https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz",
  _shasum: "c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d",
  _spec: "eslint@^7.0.0",
  _where: "/home/runner/work/eslint4b/eslint4b",
  author: DE,
  bin: wE,
  bugs: kE,
  bundleDependencies: !1,
  dependencies: TE,
  deprecated: !1,
  description: "An AST-based pattern checker for JavaScript.",
  devDependencies: FE,
  engines: PE,
  files: IE,
  funding: "https://opencollective.com/eslint",
  gitHooks: _E,
  homepage: "https://eslint.org",
  keywords: BE,
  license: "MIT",
  main: "./lib/api.js",
  name: "eslint",
  repository: OE,
  scripts: LE,
  version: "7.32.0",
  default: E2
}), Js = class {
  constructor() {
    this.current = null;
  }
  getOneToken() {
    return this.moveNext() ? this.current : null;
  }
  getAllTokens() {
    const t = [];
    for (; this.moveNext(); )
      t.push(this.current);
    return t;
  }
  moveNext() {
    throw new Error("Not implemented.");
  }
};
function C2(t) {
  return t.range[0];
}
var S2 = function(t, e) {
  const r = t.findIndex((s) => e <= C2(s));
  return r === -1 ? t.length : r;
}, A2 = function(t, e, r) {
  if (r in e)
    return e[r];
  if (r - 1 in e) {
    const s = e[r - 1], n = s >= 0 && s < t.length ? t[s] : null;
    return n && n.range[0] >= r ? s : s + 1;
  }
  return 0;
}, D2 = function(t, e, r) {
  if (r in e)
    return e[r] - 1;
  if (r - 1 in e) {
    const s = e[r - 1], n = s >= 0 && s < t.length ? t[s] : null;
    return n && n.range[1] > r ? s - 1 : s;
  }
  return t.length - 1;
}, qr = {
  search: S2,
  getFirstIndex: A2,
  getLastIndex: D2
}, w2 = class extends Js {
  constructor(t, e, r, s, n) {
    super(), this.tokens = t, this.comments = e, this.tokenIndex = qr.getLastIndex(t, r, n), this.commentIndex = qr.search(e, n) - 1, this.border = s;
  }
  moveNext() {
    const t = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null, e = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
    return t && (!e || t.range[1] > e.range[1]) ? (this.current = t, this.tokenIndex -= 1) : e ? (this.current = e, this.commentIndex -= 1) : this.current = null, !!this.current && (this.border === -1 || this.current.range[0] >= this.border);
  }
}, k2 = class extends Js {
  constructor(t, e, r, s, n) {
    super(), this.tokens = t, this.index = qr.getLastIndex(t, r, n), this.indexEnd = qr.getFirstIndex(t, r, s);
  }
  moveNext() {
    return this.index >= this.indexEnd ? (this.current = this.tokens[this.index], this.index -= 1, !0) : !1;
  }
  getOneToken() {
    return this.index >= this.indexEnd ? this.tokens[this.index] : null;
  }
}, Uu = class extends Js {
  constructor(t) {
    super(), this.cursor = t;
  }
  moveNext() {
    const t = this.cursor.moveNext();
    return this.current = this.cursor.current, t;
  }
}, T2 = class extends Uu {
  constructor(t, e) {
    super(t), this.predicate = e;
  }
  moveNext() {
    const t = this.predicate;
    for (; super.moveNext(); )
      if (t(this.current))
        return !0;
    return !1;
  }
}, F2 = class extends Js {
  constructor(t, e, r, s, n) {
    super(), this.tokens = t, this.comments = e, this.tokenIndex = qr.getFirstIndex(t, r, s), this.commentIndex = qr.search(e, s), this.border = n;
  }
  moveNext() {
    const t = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null, e = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
    return t && (!e || t.range[0] < e.range[0]) ? (this.current = t, this.tokenIndex += 1) : e ? (this.current = e, this.commentIndex += 1) : this.current = null, !!this.current && (this.border === -1 || this.current.range[1] <= this.border);
  }
}, qu = class extends Js {
  constructor(t, e, r, s, n) {
    super(), this.tokens = t, this.index = qr.getFirstIndex(t, r, s), this.indexEnd = qr.getLastIndex(t, r, n);
  }
  moveNext() {
    return this.index <= this.indexEnd ? (this.current = this.tokens[this.index], this.index += 1, !0) : !1;
  }
  getOneToken() {
    return this.index <= this.indexEnd ? this.tokens[this.index] : null;
  }
  getAllTokens() {
    return this.tokens.slice(this.index, this.indexEnd + 1);
  }
}, P2 = class extends Uu {
  constructor(t, e) {
    super(t), this.count = e;
  }
  moveNext() {
    return this.count > 0 ? (this.count -= 1, super.moveNext()) : !1;
  }
}, I2 = class extends Uu {
  constructor(t, e) {
    super(t), this.count = e;
  }
  moveNext() {
    for (; this.count > 0; )
      if (this.count -= 1, !super.moveNext())
        return !1;
    return super.moveNext();
  }
};
class RE {
  constructor(e, r) {
    this.TokenCursor = e, this.TokenCommentCursor = r;
  }
  createBaseCursor(e, r, s, n, a, o) {
    const l = o ? this.TokenCommentCursor : this.TokenCursor;
    return new l(e, r, s, n, a);
  }
  createCursor(e, r, s, n, a, o, l, i, u) {
    let c = this.createBaseCursor(e, r, s, n, a, o);
    return l && (c = new T2(c, l)), i >= 1 && (c = new I2(c, i)), u >= 0 && (c = new P2(c, u)), c;
  }
}
var _2 = new RE(qu, F2), B2 = new RE(k2, w2), Bt = {
  forward: _2,
  backward: B2
}, O2 = class extends qu {
  constructor(t, e, r, s, n, a, o) {
    super(t, e, r, s, n), this.index = Math.max(0, this.index - a), this.indexEnd = Math.min(t.length - 1, this.indexEnd + o);
  }
};
const {
  isCommentToken: NE
} = EE.default, Tt = Symbol("tokens"), vt = Symbol("comments"), Ft = Symbol("indexMap");
function L2(t, e) {
  const r = /* @__PURE__ */ Object.create(null);
  let s = 0, n = 0, a = 0, o = null;
  for (; s < t.length || n < e.length; ) {
    for (a = n < e.length ? e[n].range[0] : Number.MAX_SAFE_INTEGER; s < t.length && (o = t[s].range)[0] < a; )
      r[o[0]] = s, r[o[1] - 1] = s, s += 1;
    for (a = s < t.length ? t[s].range[0] : Number.MAX_SAFE_INTEGER; n < e.length && (o = e[n].range)[0] < a; )
      r[o[0]] = s, r[o[1] - 1] = s, n += 1;
  }
  return r;
}
function Nn(t, e, r, s, n, a, o) {
  let l = !1, i = 0, u = null;
  return typeof o == "number" ? i = o | 0 : typeof o == "function" ? u = o : o && (l = !!o.includeComments, i = o.skip | 0, u = o.filter || null), qt.default(i >= 0, "options.skip should be zero or a positive integer."), qt.default(!u || typeof u == "function", "options.filter should be a function."), t.createCursor(e, r, s, n, a, l, u, i, -1);
}
function Or(t, e, r, s, n, a, o) {
  let l = !1, i = 0, u = !1, c = null;
  return typeof o == "number" ? (i = o | 0, u = !0) : typeof o == "function" ? c = o : o && (l = !!o.includeComments, i = o.count | 0, u = typeof o.count == "number", c = o.filter || null), qt.default(i >= 0, "options.count should be zero or a positive integer."), qt.default(!c || typeof c == "function", "options.filter should be a function."), t.createCursor(e, r, s, n, a, l, c, 0, u ? i : -1);
}
function Lg(t, e, r, s, n, a, o) {
  return typeof a > "u" && typeof o > "u" ? new qu(t, e, r, s, n) : typeof a == "number" || typeof a > "u" ? new O2(t, e, r, s, n, a | 0, o | 0) : Or(Bt.forward, t, e, r, s, n, a);
}
function Rg(t) {
  const e = [];
  let r = t.getOneToken();
  for (; r && NE(r); )
    e.push(r), r = t.getOneToken();
  return e;
}
var R2 = class {
  constructor(t, e) {
    this[Tt] = t, this[vt] = e, this[Ft] = L2(t, e);
  }
  getTokenByRangeStart(t, e) {
    const r = e && e.includeComments, s = Bt.forward.createBaseCursor(this[Tt], this[vt], this[Ft], t, -1, r).getOneToken();
    return s && s.range[0] === t ? s : null;
  }
  getFirstToken(t, e) {
    return Nn(Bt.forward, this[Tt], this[vt], this[Ft], t.range[0], t.range[1], e).getOneToken();
  }
  getLastToken(t, e) {
    return Nn(Bt.backward, this[Tt], this[vt], this[Ft], t.range[0], t.range[1], e).getOneToken();
  }
  getTokenBefore(t, e) {
    return Nn(Bt.backward, this[Tt], this[vt], this[Ft], -1, t.range[0], e).getOneToken();
  }
  getTokenAfter(t, e) {
    return Nn(Bt.forward, this[Tt], this[vt], this[Ft], t.range[1], -1, e).getOneToken();
  }
  getFirstTokenBetween(t, e, r) {
    return Nn(Bt.forward, this[Tt], this[vt], this[Ft], t.range[1], e.range[0], r).getOneToken();
  }
  getLastTokenBetween(t, e, r) {
    return Nn(Bt.backward, this[Tt], this[vt], this[Ft], t.range[1], e.range[0], r).getOneToken();
  }
  getTokenOrCommentBefore(t, e) {
    return this.getTokenBefore(t, {
      includeComments: !0,
      skip: e
    });
  }
  getTokenOrCommentAfter(t, e) {
    return this.getTokenAfter(t, {
      includeComments: !0,
      skip: e
    });
  }
  getFirstTokens(t, e) {
    return Or(Bt.forward, this[Tt], this[vt], this[Ft], t.range[0], t.range[1], e).getAllTokens();
  }
  getLastTokens(t, e) {
    return Or(Bt.backward, this[Tt], this[vt], this[Ft], t.range[0], t.range[1], e).getAllTokens().reverse();
  }
  getTokensBefore(t, e) {
    return Or(Bt.backward, this[Tt], this[vt], this[Ft], -1, t.range[0], e).getAllTokens().reverse();
  }
  getTokensAfter(t, e) {
    return Or(Bt.forward, this[Tt], this[vt], this[Ft], t.range[1], -1, e).getAllTokens();
  }
  getFirstTokensBetween(t, e, r) {
    return Or(Bt.forward, this[Tt], this[vt], this[Ft], t.range[1], e.range[0], r).getAllTokens();
  }
  getLastTokensBetween(t, e, r) {
    return Or(Bt.backward, this[Tt], this[vt], this[Ft], t.range[1], e.range[0], r).getAllTokens().reverse();
  }
  getTokens(t, e, r) {
    return Lg(this[Tt], this[vt], this[Ft], t.range[0], t.range[1], e, r).getAllTokens();
  }
  getTokensBetween(t, e, r) {
    return Lg(this[Tt], this[vt], this[Ft], t.range[1], e.range[0], r, r).getAllTokens();
  }
  commentsExistBetween(t, e) {
    const r = qr.search(this[vt], t.range[1]);
    return r < this[vt].length && this[vt][r].range[1] <= e.range[0];
  }
  getCommentsBefore(t) {
    const e = Or(Bt.backward, this[Tt], this[vt], this[Ft], -1, t.range[0], {
      includeComments: !0
    });
    return Rg(e).reverse();
  }
  getCommentsAfter(t) {
    const e = Or(Bt.forward, this[Tt], this[vt], this[Ft], t.range[1], -1, {
      includeComments: !0
    });
    return Rg(e);
  }
  getCommentsInside(t) {
    return this.getTokens(t, {
      includeComments: !0,
      filter: NE
    });
  }
};
const {
  isCommentToken: fa
} = EE.default;
function N2(t) {
  if (!t.tokens)
    throw new Error("AST is missing the tokens array.");
  if (!t.comments)
    throw new Error("AST is missing the comments array.");
  if (!t.loc)
    throw new Error("AST is missing location information.");
  if (!t.range)
    throw new Error("AST is missing range information");
}
function j2(t) {
  return t.type === "ExportDefaultDeclaration" || t.type === "ExportNamedDeclaration" || t.type === "ExportAllDeclaration" || t.type === "ExportSpecifier";
}
function M2(t, e) {
  const r = [];
  let s = 0, n = 0;
  for (; s < t.length || n < e.length; )
    n >= e.length || s < t.length && t[s].range[0] < e[n].range[0] ? r.push(t[s++]) : r.push(e[n++]);
  return r;
}
function $2(t, e) {
  return t.range[0] <= e.range[0] && t.range[1] >= e.range[0] || e.range[0] <= t.range[0] && e.range[1] >= t.range[0];
}
function Ng(t, e, r, s) {
  if ($2(e, r))
    return !1;
  const [n, a] = e.range[1] <= r.range[0] ? [e, r] : [r, e], o = t.getLastToken(n) || n, l = t.getFirstToken(a) || a;
  let i = o;
  for (; i !== l; ) {
    const u = t.getTokenAfter(i, {
      includeComments: !0
    });
    if (i.range[1] !== u.range[0] || s && u !== l && u.type === "JSXText" && /\s/u.test(u.value))
      return !0;
    i = u;
  }
  return !1;
}
class V2 extends R2 {
  constructor(e, r) {
    let s, n, a, o, l;
    typeof e == "string" ? (s = e, n = r) : typeof e == "object" && e !== null && (s = e.text, n = e.ast, a = e.parserServices, o = e.scopeManager, l = e.visitorKeys), N2(n), super(n.tokens, n.comments), this.hasBOM = s.charCodeAt(0) === 65279, this.text = this.hasBOM ? s.slice(1) : s, this.ast = n, this.parserServices = a || {}, this.scopeManager = o || null, this.visitorKeys = l || Xt.traverser.DEFAULT_VISITOR_KEYS;
    const i = this.text.match(Xt.astUtils.shebangPattern);
    i && n.comments.length && n.comments[0].value === i[1] && (n.comments[0].type = "Shebang"), this.tokensAndComments = M2(n.tokens, n.comments), this.lines = [], this.lineStartIndices = [0];
    const c = Xt.astUtils.createGlobalLinebreakMatcher();
    let f;
    for (; f = c.exec(this.text); )
      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], f.index)), this.lineStartIndices.push(f.index + f[0].length);
    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1])), this._commentCache = /* @__PURE__ */ new WeakMap(), Object.freeze(this), Object.freeze(this.lines);
  }
  static splitLines(e) {
    return e.split(Xt.astUtils.createGlobalLinebreakMatcher());
  }
  getText(e, r, s) {
    return e ? this.text.slice(Math.max(e.range[0] - (r || 0), 0), e.range[1] + (s || 0)) : this.text;
  }
  getLines() {
    return this.lines;
  }
  getAllComments() {
    return this.ast.comments;
  }
  getComments(e) {
    if (this._commentCache.has(e))
      return this._commentCache.get(e);
    const r = {
      leading: [],
      trailing: []
    };
    if (e.type === "Program")
      e.body.length === 0 && (r.leading = e.comments);
    else {
      ((e.type === "BlockStatement" || e.type === "ClassBody") && e.body.length === 0 || e.type === "ObjectExpression" && e.properties.length === 0 || e.type === "ArrayExpression" && e.elements.length === 0 || e.type === "SwitchStatement" && e.cases.length === 0) && (r.trailing = this.getTokens(e, {
        includeComments: !0,
        filter: fa
      }));
      let s = this.getTokenBefore(e, {
        includeComments: !0
      });
      for (; s && fa(s) && !(e.parent && e.parent.type !== "Program" && s.start < e.parent.start); )
        r.leading.push(s), s = this.getTokenBefore(s, {
          includeComments: !0
        });
      for (r.leading.reverse(), s = this.getTokenAfter(e, {
        includeComments: !0
      }); s && fa(s) && !(e.parent && e.parent.type !== "Program" && s.end > e.parent.end); )
        r.trailing.push(s), s = this.getTokenAfter(s, {
          includeComments: !0
        });
    }
    return this._commentCache.set(e, r), r;
  }
  getJSDocComment(e) {
    const r = (n) => {
      const a = this.getTokenBefore(n, {
        includeComments: !0
      });
      return a && fa(a) && a.type === "Block" && a.value.charAt(0) === "*" && n.loc.start.line - a.loc.end.line <= 1 ? a : null;
    };
    let s = e.parent;
    switch (e.type) {
      case "ClassDeclaration":
      case "FunctionDeclaration":
        return r(j2(s) ? s : e);
      case "ClassExpression":
        return r(s.parent);
      case "ArrowFunctionExpression":
      case "FunctionExpression":
        if (s.type !== "CallExpression" && s.type !== "NewExpression") {
          for (; !this.getCommentsBefore(s).length && !/Function/u.test(s.type) && s.type !== "MethodDefinition" && s.type !== "Property" && (s = s.parent, !!s); )
            ;
          if (s && s.type !== "FunctionDeclaration" && s.type !== "Program")
            return r(s);
        }
        return r(e);
      default:
        return null;
    }
  }
  getNodeByRangeIndex(e) {
    let r = null;
    return Xt.traverser.traverse(this.ast, {
      visitorKeys: this.visitorKeys,
      enter(s) {
        s.range[0] <= e && e < s.range[1] ? r = s : this.skip();
      },
      leave(s) {
        s === r && this.break();
      }
    }), r;
  }
  isSpaceBetween(e, r) {
    return Ng(this, e, r, !1);
  }
  isSpaceBetweenTokens(e, r) {
    return Ng(this, e, r, !0);
  }
  getLocFromIndex(e) {
    if (typeof e != "number")
      throw new TypeError("Expected `index` to be a number.");
    if (e < 0 || e > this.text.length)
      throw new RangeError(`Index out of range (requested index ${e}, but source text has length ${this.text.length}).`);
    if (e === this.text.length)
      return {
        line: this.lines.length,
        column: this.lines[this.lines.length - 1].length
      };
    const r = e >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex((s) => e < s);
    return {
      line: r,
      column: e - this.lineStartIndices[r - 1]
    };
  }
  getIndexFromLoc(e) {
    if (typeof e != "object" || typeof e.line != "number" || typeof e.column != "number")
      throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
    if (e.line <= 0)
      throw new RangeError(`Line number out of range (line ${e.line} requested). Line numbers should be 1-based.`);
    if (e.line > this.lineStartIndices.length)
      throw new RangeError(`Line number out of range (line ${e.line} requested, but only ${this.lineStartIndices.length} lines present).`);
    const r = this.lineStartIndices[e.line - 1], s = e.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[e.line], n = r + e.column;
    if (e.line === this.lineStartIndices.length && n > s || e.line < this.lineStartIndices.length && n >= s)
      throw new RangeError(`Column number out of range (column ${e.column} requested, but the length of line ${e.line} is ${s - r}).`);
    return n;
  }
}
var U2 = V2, q2 = {
  SourceCode: U2
};
const Hr = Li.default("eslint:code-path");
function W2(t) {
  return t.id + (t.reachable ? "" : "!");
}
function ha(t, e) {
  const r = e ? `:${e}` : "";
  switch (t.type) {
    case "Identifier":
      return `${t.type}${r} (${t.name})`;
    case "Literal":
      return `${t.type}${r} (${t.value})`;
    default:
      return `${t.type}${r}`;
  }
}
var _t = {
  enabled: Hr.enabled,
  dump: Hr,
  dumpState: Hr.enabled ? function(t, e, r) {
    for (let s = 0; s < e.currentSegments.length; ++s) {
      const n = e.currentSegments[s].internal;
      if (r) {
        const a = n.nodes.length - 1;
        a >= 0 && n.nodes[a] === ha(t, "enter") ? n.nodes[a] = ha(t, void 0) : n.nodes.push(ha(t, "exit"));
      } else
        n.nodes.push(ha(t, "enter"));
    }
    Hr([`${e.currentSegments.map(W2).join(",")})`, `${t.type}${r ? ":exit" : ""}`].join(" "));
  } : Hr,
  dumpDot: Hr.enabled ? function(t) {
    let e = `
digraph {
node[shape=box,style="rounded,filled",fillcolor=white];
initial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];
`;
    t.returnedSegments.length > 0 && (e += `final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];
`), t.thrownSegments.length > 0 && (e += `thrown[label="",shape=circle,width=0.3,height=0.3,fixedsize];
`);
    const r = /* @__PURE__ */ Object.create(null), s = this.makeDotArrows(t, r);
    for (const n in r) {
      const a = r[n];
      e += `${n}[`, a.reachable ? e += 'label="' : e += 'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n', a.internal.nodes.length > 0 ? e += a.internal.nodes.join("\\n") : e += "????", e += `"];
`;
    }
    e += `${s}
`, e += "}", Hr("DOT", e);
  } : Hr,
  makeDotArrows(t, e) {
    const r = [[t.initialSegment, 0]], s = e || /* @__PURE__ */ Object.create(null);
    let n = t.initialSegment.id, a = `initial->${t.initialSegment.id}`;
    for (; r.length > 0; ) {
      const o = r.pop(), l = o[0], i = o[1];
      if (s[l.id] && i === 0)
        continue;
      s[l.id] = l;
      const u = l.allNextSegments[i];
      u && (n === l.id ? a += `->${u.id}` : a += `;
${l.id}->${u.id}`, n = u.id, r.unshift([l, 1 + i]), r.push([u, 0]));
    }
    return t.returnedSegments.forEach((o) => {
      n === o.id ? a += "->final" : a += `;
${o.id}->final`, n = null;
    }), t.thrownSegments.forEach((o) => {
      n === o.id ? a += "->thrown" : a += `;
${o.id}->thrown`, n = null;
    }), `${a};`;
  }
};
_t.enabled;
_t.dump;
_t.dumpState;
_t.dumpDot;
_t.makeDotArrows;
function So(t) {
  return t.reachable;
}
class Rr {
  constructor(e, r, s) {
    this.id = e, this.nextSegments = [], this.prevSegments = r.filter(So), this.allNextSegments = [], this.allPrevSegments = r, this.reachable = s, Object.defineProperty(this, "internal", {
      value: {
        used: !1,
        loopedPrevSegments: []
      }
    }), _t.enabled && (this.internal.nodes = []);
  }
  isLoopedPrevSegment(e) {
    return this.internal.loopedPrevSegments.indexOf(e) !== -1;
  }
  static newRoot(e) {
    return new Rr(e, [], !0);
  }
  static newNext(e, r) {
    return new Rr(e, Rr.flattenUnusedSegments(r), r.some(So));
  }
  static newUnreachable(e, r) {
    const s = new Rr(e, Rr.flattenUnusedSegments(r), !1);
    return Rr.markUsed(s), s;
  }
  static newDisconnected(e, r) {
    return new Rr(e, [], r.some(So));
  }
  static markUsed(e) {
    if (e.internal.used)
      return;
    e.internal.used = !0;
    let r;
    if (e.reachable)
      for (r = 0; r < e.allPrevSegments.length; ++r) {
        const s = e.allPrevSegments[r];
        s.allNextSegments.push(e), s.nextSegments.push(e);
      }
    else
      for (r = 0; r < e.allPrevSegments.length; ++r)
        e.allPrevSegments[r].allNextSegments.push(e);
  }
  static markPrevSegmentAsLooped(e, r) {
    e.internal.loopedPrevSegments.push(r);
  }
  static flattenUnusedSegments(e) {
    const r = /* @__PURE__ */ Object.create(null), s = [];
    for (let n = 0; n < e.length; ++n) {
      const a = e[n];
      if (!r[a.id])
        if (a.internal.used)
          r[a.id] = !0, s.push(a);
        else
          for (let o = 0; o < a.allPrevSegments.length; ++o) {
            const l = a.allPrevSegments[o];
            r[l.id] || (r[l.id] = !0, s.push(l));
          }
    }
    return s;
  }
}
var wr = Rr;
function z2(t) {
  return t.reachable;
}
function Ao(t, e, r, s) {
  const n = t.segmentsList, a = e >= 0 ? e : n.length + e, o = r >= 0 ? r : n.length + r, l = [];
  for (let i = 0; i < t.count; ++i) {
    const u = [];
    for (let c = a; c <= o; ++c)
      u.push(n[c][i]);
    l.push(s(t.idGenerator.next(), u));
  }
  return l;
}
function jg(t, e) {
  let r = e;
  for (; r.length > t.count; ) {
    const s = [];
    for (let n = 0, a = r.length / 2 | 0; n < a; ++n)
      s.push(wr.newNext(t.idGenerator.next(), [r[n], r[n + a]]));
    r = s;
  }
  return r;
}
class ei {
  constructor(e, r, s) {
    this.idGenerator = e, this.upper = r, this.count = s, this.segmentsList = [];
  }
  get head() {
    const e = this.segmentsList;
    return e.length === 0 ? [] : e[e.length - 1];
  }
  get empty() {
    return this.segmentsList.length === 0;
  }
  get reachable() {
    const e = this.head;
    return e.length > 0 && e.some(z2);
  }
  makeNext(e, r) {
    return Ao(this, e, r, wr.newNext);
  }
  makeUnreachable(e, r) {
    return Ao(this, e, r, wr.newUnreachable);
  }
  makeDisconnected(e, r) {
    return Ao(this, e, r, wr.newDisconnected);
  }
  add(e) {
    qt.default(e.length >= this.count, `${e.length} >= ${this.count}`), this.segmentsList.push(jg(this, e));
  }
  replaceHead(e) {
    qt.default(e.length >= this.count, `${e.length} >= ${this.count}`), this.segmentsList.splice(-1, 1, jg(this, e));
  }
  addAll(e) {
    qt.default(e.count === this.count);
    const r = e.segmentsList;
    for (let s = 0; s < r.length; ++s)
      this.segmentsList.push(r[s]);
  }
  clear() {
    this.segmentsList = [];
  }
  static newRoot(e) {
    const r = new ei(e, null, 1);
    return r.add([wr.newRoot(e.next())]), r;
  }
  static newEmpty(e, r) {
    return new ei(e.idGenerator, e, (r ? 2 : 1) * e.count);
  }
}
var Kt = ei;
function Mg(t, e, r, s) {
  for (let n = 0; n < s.length; ++n) {
    const a = s[n];
    t.push(a), e.indexOf(a) === -1 && r.push(a);
  }
}
function G2(t, e) {
  if (!e)
    return t.loopContext;
  let r = t.loopContext;
  for (; r; ) {
    if (r.label === e)
      return r;
    r = r.upper;
  }
  return null;
}
function H2(t, e) {
  let r = t.breakContext;
  for (; r; ) {
    if (e ? r.label === e : r.breakable)
      return r;
    r = r.upper;
  }
  return null;
}
function $g(t) {
  let e = t.tryContext;
  for (; e; ) {
    if (e.hasFinalizer && e.position !== "finally")
      return e;
    e = e.upper;
  }
  return t;
}
function Do(t) {
  let e = t.tryContext;
  for (; e; ) {
    if (e.position === "try" || e.hasFinalizer && e.position === "catch")
      return e;
    e = e.upper;
  }
  return t;
}
function ma(t, e) {
  t.splice(t.indexOf(e), 1);
}
function K2(t, e) {
  for (let r = 0; r < t.length; ++r) {
    const s = t[r], n = e[r];
    ma(s.nextSegments, n), ma(s.allNextSegments, n), ma(n.prevSegments, s), ma(n.allPrevSegments, s);
  }
}
function yn(t, e, r) {
  const s = wr.flattenUnusedSegments(e), n = wr.flattenUnusedSegments(r), a = Math.min(s.length, n.length);
  for (let o = 0; o < a; ++o) {
    const l = s[o], i = n[o];
    i.reachable && l.nextSegments.push(i), l.reachable && i.prevSegments.push(l), l.allNextSegments.push(i), i.allPrevSegments.push(l), i.allPrevSegments.length >= 2 && wr.markPrevSegmentAsLooped(i, l), t.notifyLooped(l, i);
  }
}
function Vg(t, e, r) {
  e.processed || (e.trueForkContext.add(r), e.falseForkContext.add(r), e.qqForkContext.add(r)), t.test !== !0 && t.brokenForkContext.addAll(e.falseForkContext), t.endOfTestSegments = e.trueForkContext.makeNext(0, -1);
}
class J2 {
  constructor(e, r) {
    this.idGenerator = e, this.notifyLooped = r, this.forkContext = Kt.newRoot(e), this.choiceContext = null, this.switchContext = null, this.tryContext = null, this.loopContext = null, this.breakContext = null, this.chainContext = null, this.currentSegments = [], this.initialSegment = this.forkContext.head[0];
    const s = this.finalSegments = [], n = this.returnedForkContext = [], a = this.thrownForkContext = [];
    n.add = Mg.bind(null, n, a, s), a.add = Mg.bind(null, a, n, s);
  }
  get headSegments() {
    return this.forkContext.head;
  }
  get parentForkContext() {
    const e = this.forkContext;
    return e && e.upper;
  }
  pushForkContext(e) {
    return this.forkContext = Kt.newEmpty(this.forkContext, e), this.forkContext;
  }
  popForkContext() {
    const e = this.forkContext;
    return this.forkContext = e.upper, this.forkContext.replaceHead(e.makeNext(0, -1)), e;
  }
  forkPath() {
    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
  }
  forkBypassPath() {
    this.forkContext.add(this.parentForkContext.head);
  }
  pushChoiceContext(e, r) {
    this.choiceContext = {
      upper: this.choiceContext,
      kind: e,
      isForkingAsResult: r,
      trueForkContext: Kt.newEmpty(this.forkContext),
      falseForkContext: Kt.newEmpty(this.forkContext),
      qqForkContext: Kt.newEmpty(this.forkContext),
      processed: !1
    };
  }
  popChoiceContext() {
    const e = this.choiceContext;
    this.choiceContext = e.upper;
    const r = this.forkContext, s = r.head;
    switch (e.kind) {
      case "&&":
      case "||":
      case "??":
        if (e.processed || (e.trueForkContext.add(s), e.falseForkContext.add(s), e.qqForkContext.add(s)), e.isForkingAsResult) {
          const a = this.choiceContext;
          return a.trueForkContext.addAll(e.trueForkContext), a.falseForkContext.addAll(e.falseForkContext), a.qqForkContext.addAll(e.qqForkContext), a.processed = !0, e;
        }
        break;
      case "test":
        e.processed ? (e.falseForkContext.clear(), e.falseForkContext.add(s)) : (e.trueForkContext.clear(), e.trueForkContext.add(s));
        break;
      case "loop":
        return e;
      default:
        throw new Error("unreachable");
    }
    const n = e.trueForkContext;
    return n.addAll(e.falseForkContext), r.replaceHead(n.makeNext(0, -1)), e;
  }
  makeLogicalRight() {
    const e = this.choiceContext, r = this.forkContext;
    if (e.processed) {
      let s;
      switch (e.kind) {
        case "&&":
          s = e.trueForkContext;
          break;
        case "||":
          s = e.falseForkContext;
          break;
        case "??":
          s = e.qqForkContext;
          break;
        default:
          throw new Error("unreachable");
      }
      r.replaceHead(s.makeNext(0, -1)), s.clear(), e.processed = !1;
    } else {
      switch (e.kind) {
        case "&&":
          e.falseForkContext.add(r.head);
          break;
        case "||":
          e.trueForkContext.add(r.head);
          break;
        case "??":
          e.trueForkContext.add(r.head), e.falseForkContext.add(r.head);
          break;
        default:
          throw new Error("unreachable");
      }
      r.replaceHead(r.makeNext(-1, -1));
    }
  }
  makeIfConsequent() {
    const e = this.choiceContext, r = this.forkContext;
    e.processed || (e.trueForkContext.add(r.head), e.falseForkContext.add(r.head), e.qqForkContext.add(r.head)), e.processed = !1, r.replaceHead(e.trueForkContext.makeNext(0, -1));
  }
  makeIfAlternate() {
    const e = this.choiceContext, r = this.forkContext;
    e.trueForkContext.clear(), e.trueForkContext.add(r.head), e.processed = !0, r.replaceHead(e.falseForkContext.makeNext(0, -1));
  }
  pushChainContext() {
    this.chainContext = {
      upper: this.chainContext,
      countChoiceContexts: 0
    };
  }
  popChainContext() {
    const e = this.chainContext;
    this.chainContext = e.upper;
    for (let r = e.countChoiceContexts; r > 0; --r)
      this.popChoiceContext();
  }
  makeOptionalNode() {
    this.chainContext && (this.chainContext.countChoiceContexts += 1, this.pushChoiceContext("??", !1));
  }
  makeOptionalRight() {
    this.chainContext && this.makeLogicalRight();
  }
  pushSwitchContext(e, r) {
    this.switchContext = {
      upper: this.switchContext,
      hasCase: e,
      defaultSegments: null,
      defaultBodySegments: null,
      foundDefault: !1,
      lastIsDefault: !1,
      countForks: 0
    }, this.pushBreakContext(!0, r);
  }
  popSwitchContext() {
    const e = this.switchContext;
    this.switchContext = e.upper;
    const r = this.forkContext, s = this.popBreakContext().brokenForkContext;
    if (e.countForks === 0) {
      s.empty || (s.add(r.makeNext(-1, -1)), r.replaceHead(s.makeNext(0, -1)));
      return;
    }
    const n = r.head;
    this.forkBypassPath();
    const a = r.head;
    s.add(n), e.lastIsDefault || (e.defaultBodySegments ? (K2(e.defaultSegments, e.defaultBodySegments), yn(this, a, e.defaultBodySegments)) : s.add(a));
    for (let o = 0; o < e.countForks; ++o)
      this.forkContext = this.forkContext.upper;
    this.forkContext.replaceHead(s.makeNext(0, -1));
  }
  makeSwitchCaseBody(e, r) {
    const s = this.switchContext;
    if (!s.hasCase)
      return;
    const n = this.forkContext, a = this.pushForkContext();
    a.add(n.makeNext(0, -1)), r ? (s.defaultSegments = n.head, e ? s.foundDefault = !0 : s.defaultBodySegments = a.head) : !e && s.foundDefault && (s.foundDefault = !1, s.defaultBodySegments = a.head), s.lastIsDefault = r, s.countForks += 1;
  }
  pushTryContext(e) {
    this.tryContext = {
      upper: this.tryContext,
      position: "try",
      hasFinalizer: e,
      returnedForkContext: e ? Kt.newEmpty(this.forkContext) : null,
      thrownForkContext: Kt.newEmpty(this.forkContext),
      lastOfTryIsReachable: !1,
      lastOfCatchIsReachable: !1
    };
  }
  popTryContext() {
    const e = this.tryContext;
    if (this.tryContext = e.upper, e.position === "catch") {
      this.popForkContext();
      return;
    }
    const r = e.returnedForkContext, s = e.thrownForkContext;
    if (r.empty && s.empty)
      return;
    const n = this.forkContext.head;
    this.forkContext = this.forkContext.upper;
    const a = n.slice(0, n.length / 2 | 0), o = n.slice(n.length / 2 | 0);
    r.empty || $g(this).returnedForkContext.add(o), s.empty || Do(this).thrownForkContext.add(o), this.forkContext.replaceHead(a), !e.lastOfTryIsReachable && !e.lastOfCatchIsReachable && this.forkContext.makeUnreachable();
  }
  makeCatchBlock() {
    const e = this.tryContext, r = this.forkContext, s = e.thrownForkContext;
    e.position = "catch", e.thrownForkContext = Kt.newEmpty(r), e.lastOfTryIsReachable = r.reachable, s.add(r.head);
    const n = s.makeNext(0, -1);
    this.pushForkContext(), this.forkBypassPath(), this.forkContext.add(n);
  }
  makeFinallyBlock() {
    const e = this.tryContext;
    let r = this.forkContext;
    const s = e.returnedForkContext, n = e.thrownForkContext, a = r.head;
    if (e.position === "catch" ? (this.popForkContext(), r = this.forkContext, e.lastOfCatchIsReachable = r.reachable) : e.lastOfTryIsReachable = r.reachable, e.position = "finally", s.empty && n.empty)
      return;
    const o = r.makeNext(-1, -1);
    for (let l = 0; l < r.count; ++l) {
      const i = [a[l]];
      for (let u = 0; u < s.segmentsList.length; ++u)
        i.push(s.segmentsList[u][l]);
      for (let u = 0; u < n.segmentsList.length; ++u)
        i.push(n.segmentsList[u][l]);
      o.push(wr.newNext(this.idGenerator.next(), i));
    }
    this.pushForkContext(!0), this.forkContext.add(o);
  }
  makeFirstThrowablePathInTryBlock() {
    const e = this.forkContext;
    if (!e.reachable)
      return;
    const r = Do(this);
    r === this || r.position !== "try" || !r.thrownForkContext.empty || (r.thrownForkContext.add(e.head), e.replaceHead(e.makeNext(-1, -1)));
  }
  pushLoopContext(e, r) {
    const s = this.forkContext, n = this.pushBreakContext(!0, r);
    switch (e) {
      case "WhileStatement":
        this.pushChoiceContext("loop", !1), this.loopContext = {
          upper: this.loopContext,
          type: e,
          label: r,
          test: void 0,
          continueDestSegments: null,
          brokenForkContext: n.brokenForkContext
        };
        break;
      case "DoWhileStatement":
        this.pushChoiceContext("loop", !1), this.loopContext = {
          upper: this.loopContext,
          type: e,
          label: r,
          test: void 0,
          entrySegments: null,
          continueForkContext: Kt.newEmpty(s),
          brokenForkContext: n.brokenForkContext
        };
        break;
      case "ForStatement":
        this.pushChoiceContext("loop", !1), this.loopContext = {
          upper: this.loopContext,
          type: e,
          label: r,
          test: void 0,
          endOfInitSegments: null,
          testSegments: null,
          endOfTestSegments: null,
          updateSegments: null,
          endOfUpdateSegments: null,
          continueDestSegments: null,
          brokenForkContext: n.brokenForkContext
        };
        break;
      case "ForInStatement":
      case "ForOfStatement":
        this.loopContext = {
          upper: this.loopContext,
          type: e,
          label: r,
          prevSegments: null,
          leftSegments: null,
          endOfLeftSegments: null,
          continueDestSegments: null,
          brokenForkContext: n.brokenForkContext
        };
        break;
      default:
        throw new Error(`unknown type: "${e}"`);
    }
  }
  popLoopContext() {
    const e = this.loopContext;
    this.loopContext = e.upper;
    const r = this.forkContext, s = this.popBreakContext().brokenForkContext;
    switch (e.type) {
      case "WhileStatement":
      case "ForStatement":
        this.popChoiceContext(), yn(this, r.head, e.continueDestSegments);
        break;
      case "DoWhileStatement": {
        const n = this.popChoiceContext();
        n.processed || (n.trueForkContext.add(r.head), n.falseForkContext.add(r.head)), e.test !== !0 && s.addAll(n.falseForkContext);
        const a = n.trueForkContext.segmentsList;
        for (let o = 0; o < a.length; ++o)
          yn(this, a[o], e.entrySegments);
        break;
      }
      case "ForInStatement":
      case "ForOfStatement":
        s.add(r.head), yn(this, r.head, e.leftSegments);
        break;
      default:
        throw new Error("unreachable");
    }
    s.empty ? r.replaceHead(r.makeUnreachable(-1, -1)) : r.replaceHead(s.makeNext(0, -1));
  }
  makeWhileTest(e) {
    const r = this.loopContext, s = this.forkContext, n = s.makeNext(0, -1);
    r.test = e, r.continueDestSegments = n, s.replaceHead(n);
  }
  makeWhileBody() {
    const e = this.loopContext, r = this.choiceContext, s = this.forkContext;
    r.processed || (r.trueForkContext.add(s.head), r.falseForkContext.add(s.head)), e.test !== !0 && e.brokenForkContext.addAll(r.falseForkContext), s.replaceHead(r.trueForkContext.makeNext(0, -1));
  }
  makeDoWhileBody() {
    const e = this.loopContext, r = this.forkContext, s = r.makeNext(-1, -1);
    e.entrySegments = s, r.replaceHead(s);
  }
  makeDoWhileTest(e) {
    const r = this.loopContext, s = this.forkContext;
    if (r.test = e, !r.continueForkContext.empty) {
      r.continueForkContext.add(s.head);
      const n = r.continueForkContext.makeNext(0, -1);
      s.replaceHead(n);
    }
  }
  makeForTest(e) {
    const r = this.loopContext, s = this.forkContext, n = s.head, a = s.makeNext(-1, -1);
    r.test = e, r.endOfInitSegments = n, r.continueDestSegments = r.testSegments = a, s.replaceHead(a);
  }
  makeForUpdate() {
    const e = this.loopContext, r = this.choiceContext, s = this.forkContext;
    e.testSegments ? Vg(e, r, s.head) : e.endOfInitSegments = s.head;
    const n = s.makeDisconnected(-1, -1);
    e.continueDestSegments = e.updateSegments = n, s.replaceHead(n);
  }
  makeForBody() {
    const e = this.loopContext, r = this.choiceContext, s = this.forkContext;
    e.updateSegments ? (e.endOfUpdateSegments = s.head, e.testSegments && yn(this, e.endOfUpdateSegments, e.testSegments)) : e.testSegments ? Vg(e, r, s.head) : e.endOfInitSegments = s.head;
    let n = e.endOfTestSegments;
    if (!n) {
      const a = Kt.newEmpty(s);
      a.add(e.endOfInitSegments), e.endOfUpdateSegments && a.add(e.endOfUpdateSegments), n = a.makeNext(0, -1);
    }
    e.continueDestSegments = e.continueDestSegments || n, s.replaceHead(n);
  }
  makeForInOfLeft() {
    const e = this.loopContext, r = this.forkContext, s = r.makeDisconnected(-1, -1);
    e.prevSegments = r.head, e.leftSegments = e.continueDestSegments = s, r.replaceHead(s);
  }
  makeForInOfRight() {
    const e = this.loopContext, r = this.forkContext, s = Kt.newEmpty(r);
    s.add(e.prevSegments);
    const n = s.makeNext(-1, -1);
    e.endOfLeftSegments = r.head, r.replaceHead(n);
  }
  makeForInOfBody() {
    const e = this.loopContext, r = this.forkContext, s = Kt.newEmpty(r);
    s.add(e.endOfLeftSegments);
    const n = s.makeNext(-1, -1);
    yn(this, r.head, e.leftSegments), e.brokenForkContext.add(r.head), r.replaceHead(n);
  }
  pushBreakContext(e, r) {
    return this.breakContext = {
      upper: this.breakContext,
      breakable: e,
      label: r,
      brokenForkContext: Kt.newEmpty(this.forkContext)
    }, this.breakContext;
  }
  popBreakContext() {
    const e = this.breakContext, r = this.forkContext;
    if (this.breakContext = e.upper, !e.breakable) {
      const s = e.brokenForkContext;
      s.empty || (s.add(r.head), r.replaceHead(s.makeNext(0, -1)));
    }
    return e;
  }
  makeBreak(e) {
    const r = this.forkContext;
    if (!r.reachable)
      return;
    const s = H2(this, e);
    s && s.brokenForkContext.add(r.head), r.replaceHead(r.makeUnreachable(-1, -1));
  }
  makeContinue(e) {
    const r = this.forkContext;
    if (!r.reachable)
      return;
    const s = G2(this, e);
    s && (s.continueDestSegments ? (yn(this, r.head, s.continueDestSegments), (s.type === "ForInStatement" || s.type === "ForOfStatement") && s.brokenForkContext.add(r.head)) : s.continueForkContext.add(r.head)), r.replaceHead(r.makeUnreachable(-1, -1));
  }
  makeReturn() {
    const e = this.forkContext;
    e.reachable && ($g(this).returnedForkContext.add(e.head), e.replaceHead(e.makeUnreachable(-1, -1)));
  }
  makeThrow() {
    const e = this.forkContext;
    e.reachable && (Do(this).thrownForkContext.add(e.head), e.replaceHead(e.makeUnreachable(-1, -1)));
  }
  makeFinal() {
    const e = this.currentSegments;
    e.length > 0 && e[0].reachable && this.returnedForkContext.add(e);
  }
}
var X2 = J2;
class Q2 {
  constructor(e) {
    this.prefix = String(e), this.n = 0;
  }
  next() {
    return this.n = 1 + this.n | 0, this.n < 0 && (this.n = 1), this.prefix + this.n;
  }
}
var jE = Q2;
class Y2 {
  constructor(e, r, s) {
    this.id = e, this.upper = r, this.childCodePaths = [], Object.defineProperty(this, "internal", {
      value: new X2(new jE(`${e}_`), s)
    }), r && r.childCodePaths.push(this);
  }
  static getState(e) {
    return e.internal;
  }
  get initialSegment() {
    return this.internal.initialSegment;
  }
  get finalSegments() {
    return this.internal.finalSegments;
  }
  get returnedSegments() {
    return this.internal.returnedForkContext;
  }
  get thrownSegments() {
    return this.internal.thrownForkContext;
  }
  get currentSegments() {
    return this.internal.currentSegments;
  }
  traverseSegments(e, r) {
    let s, n;
    typeof e == "function" ? (n = e, s = {}) : (s = e || {}, n = r);
    const a = s.first || this.internal.initialSegment, o = s.last;
    let l = null, i = 0, u = 0, c = null;
    const f = /* @__PURE__ */ Object.create(null), h = [[a, 0]];
    let p = null, m = !1;
    const d = {
      skip() {
        h.length <= 1 ? m = !0 : p = h[h.length - 2][0];
      },
      break() {
        m = !0;
      }
    };
    function g(y) {
      return f[y.id] || c.isLoopedPrevSegment(y);
    }
    for (; h.length > 0; ) {
      if (l = h[h.length - 1], c = l[0], i = l[1], i === 0) {
        if (f[c.id]) {
          h.pop();
          continue;
        }
        if (c !== a && c.prevSegments.length > 0 && !c.prevSegments.every(g)) {
          h.pop();
          continue;
        }
        if (p && c.prevSegments.indexOf(p) !== -1 && (p = null), f[c.id] = !0, !p && (n.call(this, c, d), c === o && d.skip(), m))
          break;
      }
      u = c.nextSegments.length - 1, i < u ? (l[1] += 1, h.push([c.nextSegments[i], 0])) : i === u ? (l[0] = c.nextSegments[i], l[1] = 0) : h.pop();
    }
  }
}
var kr = Y2;
const {
  breakableTypePattern: ME
} = Xt.astUtils;
function Z2(t) {
  return !!t.test;
}
function Ri(t) {
  return t === "&&" || t === "||" || t === "??";
}
function Ni(t) {
  return t === "&&=" || t === "||=" || t === "??=";
}
function Ug(t) {
  return t.parent.type === "LabeledStatement" ? t.parent.label.name : null;
}
function qg(t) {
  const e = t.parent;
  switch (e.type) {
    case "ConditionalExpression":
    case "IfStatement":
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
      return e.test === t;
    case "LogicalExpression":
      return Ri(e.operator);
    case "AssignmentExpression":
      return Ni(e.operator);
    default:
      return !1;
  }
}
function wo(t) {
  if (t.type === "Literal")
    return !!t.value;
}
function eB(t) {
  const e = t.parent;
  switch (e.type) {
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "ArrayPattern":
    case "RestElement":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "CatchClause":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ClassDeclaration":
    case "ClassExpression":
    case "VariableDeclarator":
      return e.id !== t;
    case "Property":
    case "MethodDefinition":
      return e.key !== t || e.computed || e.shorthand;
    case "AssignmentPattern":
      return e.key !== t;
    default:
      return !0;
  }
}
function vn(t, e) {
  const r = t.codePath, s = kr.getState(r), n = s.currentSegments, a = s.headSegments, o = Math.max(n.length, a.length);
  let l, i, u;
  for (l = 0; l < o; ++l)
    i = n[l], u = a[l], i !== u && i && (_t.dump(`onCodePathSegmentEnd ${i.id}`), i.reachable && t.emitter.emit("onCodePathSegmentEnd", i, e));
  for (s.currentSegments = a, l = 0; l < o; ++l)
    i = n[l], u = a[l], i !== u && u && (_t.dump(`onCodePathSegmentStart ${u.id}`), wr.markUsed(u), u.reachable && t.emitter.emit("onCodePathSegmentStart", u, e));
}
function tB(t, e) {
  const r = kr.getState(t.codePath), s = r.currentSegments;
  for (let n = 0; n < s.length; ++n) {
    const a = s[n];
    _t.dump(`onCodePathSegmentEnd ${a.id}`), a.reachable && t.emitter.emit("onCodePathSegmentEnd", a, e);
  }
  r.currentSegments = [];
}
function rB(t, e) {
  const r = t.codePath, s = kr.getState(r), n = e.parent;
  switch (n.type) {
    case "CallExpression":
      n.optional === !0 && n.arguments.length >= 1 && n.arguments[0] === e && s.makeOptionalRight();
      break;
    case "MemberExpression":
      n.optional === !0 && n.property === e && s.makeOptionalRight();
      break;
    case "LogicalExpression":
      n.right === e && Ri(n.operator) && s.makeLogicalRight();
      break;
    case "AssignmentExpression":
      n.right === e && Ni(n.operator) && s.makeLogicalRight();
      break;
    case "ConditionalExpression":
    case "IfStatement":
      n.consequent === e ? s.makeIfConsequent() : n.alternate === e && s.makeIfAlternate();
      break;
    case "SwitchCase":
      n.consequent[0] === e && s.makeSwitchCaseBody(!1, !n.test);
      break;
    case "TryStatement":
      n.handler === e ? s.makeCatchBlock() : n.finalizer === e && s.makeFinallyBlock();
      break;
    case "WhileStatement":
      n.test === e ? s.makeWhileTest(wo(e)) : (qt.default(n.body === e), s.makeWhileBody());
      break;
    case "DoWhileStatement":
      n.body === e ? s.makeDoWhileBody() : (qt.default(n.test === e), s.makeDoWhileTest(wo(e)));
      break;
    case "ForStatement":
      n.test === e ? s.makeForTest(wo(e)) : n.update === e ? s.makeForUpdate() : n.body === e && s.makeForBody();
      break;
    case "ForInStatement":
    case "ForOfStatement":
      n.left === e ? s.makeForInOfLeft() : n.right === e ? s.makeForInOfRight() : (qt.default(n.body === e), s.makeForInOfBody());
      break;
    case "AssignmentPattern":
      n.right === e && (s.pushForkContext(), s.forkBypassPath(), s.forkPath());
      break;
  }
}
function nB(t, e) {
  let r = t.codePath, s = r && kr.getState(r);
  const n = e.parent;
  switch (e.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      r && (vn(t, e), _t.dumpState(e, s, !1)), r = t.codePath = new kr(t.idGenerator.next(), r, t.onLooped), s = kr.getState(r), _t.dump(`onCodePathStart ${r.id}`), t.emitter.emit("onCodePathStart", r, e);
      break;
    case "ChainExpression":
      s.pushChainContext();
      break;
    case "CallExpression":
      e.optional === !0 && s.makeOptionalNode();
      break;
    case "MemberExpression":
      e.optional === !0 && s.makeOptionalNode();
      break;
    case "LogicalExpression":
      Ri(e.operator) && s.pushChoiceContext(e.operator, qg(e));
      break;
    case "AssignmentExpression":
      Ni(e.operator) && s.pushChoiceContext(e.operator.slice(0, -1), qg(e));
      break;
    case "ConditionalExpression":
    case "IfStatement":
      s.pushChoiceContext("test", !1);
      break;
    case "SwitchStatement":
      s.pushSwitchContext(e.cases.some(Z2), Ug(e));
      break;
    case "TryStatement":
      s.pushTryContext(!!e.finalizer);
      break;
    case "SwitchCase":
      n.discriminant !== e && n.cases[0] !== e && s.forkPath();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      s.pushLoopContext(e.type, Ug(e));
      break;
    case "LabeledStatement":
      ME.test(e.body.type) || s.pushBreakContext(!1, e.label.name);
      break;
  }
  vn(t, e), _t.dumpState(e, s, !1);
}
function sB(t, e) {
  const r = t.codePath, s = kr.getState(r);
  let n = !1;
  switch (e.type) {
    case "ChainExpression":
      s.popChainContext();
      break;
    case "IfStatement":
    case "ConditionalExpression":
      s.popChoiceContext();
      break;
    case "LogicalExpression":
      Ri(e.operator) && s.popChoiceContext();
      break;
    case "AssignmentExpression":
      Ni(e.operator) && s.popChoiceContext();
      break;
    case "SwitchStatement":
      s.popSwitchContext();
      break;
    case "SwitchCase":
      e.consequent.length === 0 && s.makeSwitchCaseBody(!0, !e.test), s.forkContext.reachable && (n = !0);
      break;
    case "TryStatement":
      s.popTryContext();
      break;
    case "BreakStatement":
      vn(t, e), s.makeBreak(e.label && e.label.name), n = !0;
      break;
    case "ContinueStatement":
      vn(t, e), s.makeContinue(e.label && e.label.name), n = !0;
      break;
    case "ReturnStatement":
      vn(t, e), s.makeReturn(), n = !0;
      break;
    case "ThrowStatement":
      vn(t, e), s.makeThrow(), n = !0;
      break;
    case "Identifier":
      eB(e) && (s.makeFirstThrowablePathInTryBlock(), n = !0);
      break;
    case "CallExpression":
    case "ImportExpression":
    case "MemberExpression":
    case "NewExpression":
    case "YieldExpression":
      s.makeFirstThrowablePathInTryBlock();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      s.popLoopContext();
      break;
    case "AssignmentPattern":
      s.popForkContext();
      break;
    case "LabeledStatement":
      ME.test(e.body.type) || s.popBreakContext();
      break;
  }
  n || vn(t, e), _t.dumpState(e, s, !0);
}
function aB(t, e) {
  switch (e.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression": {
      let r = t.codePath;
      kr.getState(r).makeFinal(), tB(t, e), _t.dump(`onCodePathEnd ${r.id}`), t.emitter.emit("onCodePathEnd", r, e), _t.dumpDot(r), r = t.codePath = t.codePath.upper, r && _t.dumpState(e, kr.getState(r), !0);
      break;
    }
    case "CallExpression":
      e.optional === !0 && e.arguments.length === 0 && kr.getState(t.codePath).makeOptionalRight();
      break;
  }
}
class iB {
  constructor(e) {
    this.original = e, this.emitter = e.emitter, this.codePath = null, this.idGenerator = new jE("s"), this.currentNode = null, this.onLooped = this.onLooped.bind(this);
  }
  enterNode(e) {
    this.currentNode = e, e.parent && rB(this, e), nB(this, e), this.original.enterNode(e), this.currentNode = null;
  }
  leaveNode(e) {
    this.currentNode = e, sB(this, e), this.original.leaveNode(e), aB(this, e), this.currentNode = null;
  }
  onLooped(e, r) {
    e.reachable && r.reachable && (_t.dump(`onCodePathSegmentLoop ${e.id} -> ${r.id}`), this.emitter.emit("onCodePathSegmentLoop", e, r, this.currentNode));
  }
}
var oB = iB;
function Fa(t, e) {
  return t.line - e.line || t.column - e.column;
}
function Wg(t) {
  const e = [];
  let r = 0, s = null;
  const n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
  for (const i of t.problems) {
    for (; r < t.directives.length && Fa(t.directives[r], i) <= 0; ) {
      const u = t.directives[r++];
      switch (u.type) {
        case "disable":
          u.ruleId === null ? (s = u, n.clear(), a.clear()) : (s && a.delete(u.ruleId), n.set(u.ruleId, u));
          break;
        case "enable":
          u.ruleId === null ? (s = null, n.clear()) : (s && a.add(u.ruleId), n.delete(u.ruleId));
          break;
      }
    }
    n.has(i.ruleId) ? o.add(n.get(i.ruleId)) : s && !a.has(i.ruleId) ? o.add(s) : e.push(i);
  }
  const l = t.directives.filter((i) => i.type === "disable" && !o.has(i)).map((i) => ({
    ruleId: null,
    message: i.ruleId ? `Unused eslint-disable directive (no problems were reported from '${i.ruleId}').` : "Unused eslint-disable directive (no problems were reported).",
    line: i.unprocessedDirective.line,
    column: i.unprocessedDirective.column,
    severity: t.reportUnusedDisableDirectives === "warn" ? 1 : 2,
    nodeType: null
  }));
  return {
    problems: e,
    unusedDisableDirectives: l
  };
}
var lB = ({
  directives: t,
  problems: e,
  reportUnusedDisableDirectives: r = "off"
}) => {
  const s = t.filter((l) => l.type === "disable" || l.type === "enable").map((l) => Object.assign({}, l, {
    unprocessedDirective: l
  })).sort(Fa), n = function(l, i) {
    const u = l.map(i);
    return [].concat(...u);
  }(t, (l) => {
    switch (l.type) {
      case "disable":
      case "enable":
        return [];
      case "disable-line":
        return [{
          type: "disable",
          line: l.line,
          column: 1,
          ruleId: l.ruleId,
          unprocessedDirective: l
        }, {
          type: "enable",
          line: l.line + 1,
          column: 0,
          ruleId: l.ruleId,
          unprocessedDirective: l
        }];
      case "disable-next-line":
        return [{
          type: "disable",
          line: l.line + 1,
          column: 1,
          ruleId: l.ruleId,
          unprocessedDirective: l
        }, {
          type: "enable",
          line: l.line + 2,
          column: 0,
          ruleId: l.ruleId,
          unprocessedDirective: l
        }];
      default:
        throw new TypeError(`Unrecognized directive type '${l.type}'`);
    }
  }).sort(Fa), a = Wg({
    problems: e,
    directives: s,
    reportUnusedDisableDirectives: r
  }), o = Wg({
    problems: a.problems,
    directives: n,
    reportUnusedDisableDirectives: r
  });
  return r !== "off" ? o.problems.concat(a.unusedDisableDirectives).concat(o.unusedDisableDirectives).sort(Fa) : o.problems;
};
const gs = Li.default("eslint:config-comment-parser");
var uB = class {
  parseStringConfig(t, e) {
    gs("Parsing String config");
    const r = {};
    return t.replace(/\s*([:,])\s*/gu, "$1").split(/\s|,+/u).forEach((n) => {
      if (!n)
        return;
      const [a, o = null] = n.split(":");
      r[a] = {
        value: o,
        comment: e
      };
    }), r;
  }
  parseJsonConfig(t, e) {
    gs("Parsing JSON config");
    let r = {};
    try {
      if (r = v2.default.parse("Object", t) || {}, Oi.default.isEverySeverityValid(r))
        return {
          success: !0,
          config: r
        };
    } catch {
      gs("Levn parsing failed; falling back to manual parsing.");
    }
    r = {};
    const s = t.replace(/([-a-zA-Z0-9/]+):/gu, '"$1":').replace(/(\]|[0-9])\s+(?=")/u, "$1,");
    try {
      r = JSON.parse(`{${s}}`);
    } catch (n) {
      return gs("Manual parsing failed."), {
        success: !1,
        error: {
          ruleId: null,
          fatal: !0,
          severity: 2,
          message: `Failed to parse JSON from '${s}': ${n.message}`,
          line: e.start.line,
          column: e.start.column + 1
        }
      };
    }
    return {
      success: !0,
      config: r
    };
  }
  parseListConfig(t) {
    gs("Parsing list config");
    const e = {};
    return t.replace(/\s*,\s*/gu, ",").split(/,+/u).forEach((r) => {
      const s = r.trim();
      s && (e[s] = !0);
    }), e;
  }
};
function cB(...t) {
  return [...new Set([].concat(...t))];
}
function pB(...t) {
  if (t.length === 0)
    return [];
  let e = [...new Set(t[0])];
  for (const r of t.slice(1))
    e = e.filter((s) => r.includes(s));
  return e;
}
function Pa(t) {
  switch (t.type) {
    case "identifier":
      return [t.value];
    case "matches": {
      const e = t.selectors.map(Pa);
      return e.every(Boolean) ? cB(...e) : null;
    }
    case "compound": {
      const e = t.selectors.map(Pa).filter((r) => r);
      return e.length ? pB(...e) : null;
    }
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return Pa(t.right);
    default:
      return null;
  }
}
function Ia(t) {
  switch (t.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return Ia(t.left) + Ia(t.right);
    case "compound":
    case "not":
    case "matches":
      return t.selectors.reduce((e, r) => e + Ia(r), 0);
    case "attribute":
    case "field":
    case "nth-child":
    case "nth-last-child":
      return 1;
    default:
      return 0;
  }
}
function _a(t) {
  switch (t.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return _a(t.left) + _a(t.right);
    case "compound":
    case "not":
    case "matches":
      return t.selectors.reduce((e, r) => e + _a(r), 0);
    case "identifier":
      return 1;
    default:
      return 0;
  }
}
function ys(t, e) {
  return t.attributeCount - e.attributeCount || t.identifierCount - e.identifierCount || (t.rawSelector <= e.rawSelector ? -1 : 1);
}
function fB(t) {
  try {
    return bE.default.parse(t.replace(/:exit$/u, ""));
  } catch (e) {
    throw e.location && e.location.start && typeof e.location.start.offset == "number" ? new SyntaxError(`Syntax error in selector "${t}" at position ${e.location.start.offset}: ${e.message}`) : e;
  }
}
const ko = /* @__PURE__ */ new Map();
function hB(t) {
  if (ko.has(t))
    return ko.get(t);
  const e = fB(t), r = {
    rawSelector: t,
    isExit: t.endsWith(":exit"),
    parsedSelector: e,
    listenerTypes: Pa(e),
    attributeCount: Ia(e),
    identifierCount: _a(e)
  };
  return ko.set(t, r), r;
}
class mB {
  constructor(e, r) {
    this.emitter = e, this.esqueryOptions = r, this.currentAncestry = [], this.enterSelectorsByNodeType = /* @__PURE__ */ new Map(), this.exitSelectorsByNodeType = /* @__PURE__ */ new Map(), this.anyTypeEnterSelectors = [], this.anyTypeExitSelectors = [], e.eventNames().forEach((s) => {
      const n = hB(s);
      if (n.listenerTypes) {
        const o = n.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
        n.listenerTypes.forEach((l) => {
          o.has(l) || o.set(l, []), o.get(l).push(n);
        });
        return;
      }
      (n.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors).push(n);
    }), this.anyTypeEnterSelectors.sort(ys), this.anyTypeExitSelectors.sort(ys), this.enterSelectorsByNodeType.forEach((s) => s.sort(ys)), this.exitSelectorsByNodeType.forEach((s) => s.sort(ys));
  }
  applySelector(e, r) {
    bE.default.matches(e, r.parsedSelector, this.currentAncestry, this.esqueryOptions) && this.emitter.emit(r.rawSelector, e);
  }
  applySelectors(e, r) {
    const s = (r ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(e.type) || [], n = r ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
    let a = 0, o = 0;
    for (; a < s.length || o < n.length; )
      a >= s.length || o < n.length && ys(n[o], s[a]) < 0 ? this.applySelector(e, n[o++]) : this.applySelector(e, s[a++]);
  }
  enterNode(e) {
    e.parent && this.currentAncestry.unshift(e.parent), this.applySelectors(e, !1);
  }
  leaveNode(e) {
    this.applySelectors(e, !0), this.currentAncestry.shift();
  }
}
var zg = mB;
function Gg(t, e) {
  return {
    range: [t, t],
    text: e
  };
}
const dB = Object.freeze({
  insertTextAfter(t, e) {
    return this.insertTextAfterRange(t.range, e);
  },
  insertTextAfterRange(t, e) {
    return Gg(t[1], e);
  },
  insertTextBefore(t, e) {
    return this.insertTextBeforeRange(t.range, e);
  },
  insertTextBeforeRange(t, e) {
    return Gg(t[0], e);
  },
  replaceText(t, e) {
    return this.replaceTextRange(t.range, e);
  },
  replaceTextRange(t, e) {
    return {
      range: t,
      text: e
    };
  },
  remove(t) {
    return this.removeRange(t.range);
  },
  removeRange(t) {
    return {
      range: t,
      text: ""
    };
  }
});
var gB = dB, Wu = (t, e) => e ? t.replace(/\{\{([^{}]+?)\}\}/gu, (r, s) => {
  const n = s.trim();
  return n in e ? e[n] : r;
}) : t;
function yB(...t) {
  return t.length === 1 ? Object.assign({}, t[0]) : typeof t[1] == "string" ? {
    node: t[0],
    message: t[1],
    data: t[2],
    fix: t[3]
  } : {
    node: t[0],
    loc: t[1],
    message: t[2],
    data: t[3],
    fix: t[4]
  };
}
function xB(t) {
  t.node ? qt.default(typeof t.node == "object", "Node must be an object") : qt.default(t.loc, "Node must be provided when reporting error if location is not provided");
}
function vB(t) {
  return t.loc ? t.loc.start ? t.loc : {
    start: t.loc,
    end: null
  } : t.node.loc;
}
function $E(t) {
  t && qt.default(t.range && typeof t.range[0] == "number" && typeof t.range[1] == "number", `Fix has invalid range: ${JSON.stringify(t, null, 2)}`);
}
function EB(t, e) {
  return t.range[0] - e.range[0] || t.range[1] - e.range[1];
}
function bB(t, e) {
  for (const l of t)
    $E(l);
  if (t.length === 0)
    return null;
  if (t.length === 1)
    return t[0];
  t.sort(EB);
  const r = e.text, s = t[0].range[0], n = t[t.length - 1].range[1];
  let a = "", o = Number.MIN_SAFE_INTEGER;
  for (const l of t)
    qt.default(l.range[0] >= o, "Fix objects must not be overlapped in a report."), l.range[0] >= 0 && (a += r.slice(Math.max(0, s, o), l.range[0])), a += l.text, o = l.range[1];
  return a += r.slice(Math.max(0, s, o), n), {
    range: [s, n],
    text: a
  };
}
function VE(t, e) {
  if (typeof t.fix != "function")
    return null;
  const r = t.fix(gB);
  return r && Symbol.iterator in r ? bB(Array.from(r), e) : ($E(r), r);
}
function CB(t, e, r) {
  return !t.suggest || !Array.isArray(t.suggest) ? [] : t.suggest.map((s) => {
    const n = s.desc || r[s.messageId];
    return {
      ...s,
      desc: Wu(n, s.data),
      fix: VE(s, e)
    };
  }).filter(({
    fix: s
  }) => s);
}
function SB(t) {
  const e = {
    ruleId: t.ruleId,
    severity: t.severity,
    message: t.message,
    line: t.loc.start.line,
    column: t.loc.start.column + 1,
    nodeType: t.node && t.node.type || null
  };
  return t.messageId && (e.messageId = t.messageId), t.loc.end && (e.endLine = t.loc.end.line, e.endColumn = t.loc.end.column + 1), t.fix && (e.fix = t.fix), t.suggestions && t.suggestions.length > 0 && (e.suggestions = t.suggestions), e;
}
function AB(t, e) {
  t && Array.isArray(t) && t.forEach((r) => {
    if (r.messageId) {
      const {
        messageId: s
      } = r;
      if (!e)
        throw new TypeError(`context.report() called with a suggest option with a messageId '${s}', but no messages were present in the rule metadata.`);
      if (!e[s])
        throw new TypeError(`context.report() called with a suggest option with a messageId '${s}' which is not present in the 'messages' config: ${JSON.stringify(e, null, 2)}`);
      if (r.desc)
        throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
    } else if (!r.desc)
      throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
    if (typeof r.fix != "function")
      throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${r}`);
  });
}
var DB = function(t) {
  return (...e) => {
    const r = yB(...e), s = t.messageIds;
    xB(r);
    let n;
    if (r.messageId) {
      if (!s)
        throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
      const a = r.messageId;
      if (r.message)
        throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
      if (!s || !Object.prototype.hasOwnProperty.call(s, a))
        throw new TypeError(`context.report() called with a messageId of '${a}' which is not present in the 'messages' config: ${JSON.stringify(s, null, 2)}`);
      n = s[a];
    } else if (r.message)
      n = r.message;
    else
      throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
    return AB(r.suggest, s), SB({
      ruleId: t.ruleId,
      severity: t.severity,
      node: r.node,
      message: Wu(n, r.data),
      messageId: r.messageId,
      loc: vB(r),
      fix: t.disableFixes ? null : VE(r, t.sourceCode),
      suggestions: t.disableFixes ? [] : CB(r, t.sourceCode, s)
    });
  };
}, To = /* @__PURE__ */ new Map();
function wB(t) {
  return typeof t == "function" ? Object.assign({
    create: t
  }, t) : t;
}
class kB {
  constructor() {
    this._rules = /* @__PURE__ */ Object.create(null);
  }
  define(e, r) {
    this._rules[e] = wB(r);
  }
  get(e) {
    return typeof this._rules[e] == "string" && this.define(e, null), this._rules[e] ? this._rules[e] : To.has(e) ? To.get(e) : null;
  }
  *[Symbol.iterator]() {
    yield* To;
    for (const e of Object.keys(this._rules))
      yield [e, this.get(e)];
  }
}
var UE = kB, TB = () => {
  const t = /* @__PURE__ */ Object.create(null);
  return Object.freeze({
    on(e, r) {
      e in t ? t[e].push(r) : t[e] = [r];
    },
    emit(e, ...r) {
      e in t && t[e].forEach((s) => s(...r));
    },
    eventNames() {
      return Object.keys(t);
    }
  });
};
const da = Li.default("eslint:source-code-fixer"), Fo = "\uFEFF";
function FB(t, e) {
  return t.fix.range[0] - e.fix.range[0] || t.fix.range[1] - e.fix.range[1];
}
function PB(t, e) {
  return t.line - e.line || t.column - e.column;
}
function qE() {
  Object.freeze(this);
}
qE.applyFixes = function(t, e, r) {
  if (da("Applying fixes"), r === !1)
    return da("shouldFix parameter was false, not attempting fixes"), {
      fixed: !1,
      messages: e,
      output: t
    };
  const s = [], n = [], a = t.startsWith(Fo) ? Fo : "", o = a ? t.slice(1) : t;
  let l = Number.NEGATIVE_INFINITY, i = a;
  function u(c) {
    const f = c.fix, h = f.range[0], p = f.range[1];
    return l >= h || h > p ? (s.push(c), !1) : ((h < 0 && p >= 0 || h === 0 && f.text.startsWith(Fo)) && (i = ""), i += o.slice(Math.max(0, l), Math.max(0, h)), i += f.text, l = p, !0);
  }
  if (e.forEach((c) => {
    Object.prototype.hasOwnProperty.call(c, "fix") ? n.push(c) : s.push(c);
  }), n.length) {
    da("Found fixes to apply");
    let c = !1;
    for (const f of n.sort(FB))
      typeof r != "function" || r(f) ? (u(f), c = !0) : s.push(f);
    return i += o.slice(Math.max(0, l)), {
      fixed: c,
      messages: s.sort(PB),
      output: i
    };
  }
  return da("No fixes to apply"), {
    fixed: !1,
    messages: e,
    output: a + o
  };
};
var WE = qE;
const zE = {
  "generator-star": ["generator-star-spacing"],
  "global-strict": ["strict"],
  "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
  "no-comma-dangle": ["comma-dangle"],
  "no-empty-class": ["no-empty-character-class"],
  "no-empty-label": ["no-labels"],
  "no-extra-strict": ["strict"],
  "no-reserved-keys": ["quote-props"],
  "no-space-before-semi": ["semi-spacing"],
  "no-wrap-func": ["no-extra-parens"],
  "space-after-function-name": ["space-before-function-paren"],
  "space-after-keywords": ["keyword-spacing"],
  "space-before-function-parentheses": ["space-before-function-paren"],
  "space-before-keywords": ["keyword-spacing"],
  "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
  "space-return-throw-case": ["keyword-spacing"],
  "space-unary-word-ops": ["space-unary-ops"],
  "spaced-line-comment": ["spaced-comment"]
};
var IB = {
  rules: zE
}, _B = Object.freeze({
  __proto__: null,
  rules: zE,
  default: IB
}), Hg = Xt.getCjsExportFromNamespace(b2), Kg = Xt.getCjsExportFromNamespace(_B);
const {
  SourceCode: GE
} = q2, Rt = Li.default("eslint:linter"), BB = 10, OB = "espree", LB = 5, _s = new uB(), RB = {
  start: {
    line: 1,
    column: 0
  },
  end: {
    line: 1,
    column: 1
  }
}, NB = Symbol.for("eslint.RuleTester.parser");
function jB(t, e, {
  exportedVariables: r,
  enabledGlobals: s
}) {
  for (const n of /* @__PURE__ */ new Set([...Object.keys(e), ...Object.keys(s)])) {
    const a = e[n] === void 0 ? void 0 : Oi.default.normalizeConfigGlobal(e[n]), l = s[n] && s[n].value || a, i = s[n] && s[n].comments;
    if (l === "off")
      continue;
    let u = t.set.get(n);
    u || (u = new xE.default.Variable(n, t), t.variables.push(u), t.set.set(n, u)), u.eslintImplicitGlobalSetting = a, u.eslintExplicitGlobal = i !== void 0, u.eslintExplicitGlobalComments = i, u.writeable = l === "writable";
  }
  Object.keys(r).forEach((n) => {
    const a = t.set.get(n);
    a && (a.eslintUsed = !0);
  }), t.through = t.through.filter((n) => {
    const a = n.identifier.name, o = t.set.get(a);
    return o ? (n.resolved = o, o.references.push(n), !1) : !0;
  });
}
function MB(t) {
  return Object.prototype.hasOwnProperty.call(Kg.rules, t) ? `Rule '${t}' was removed and replaced by: ${Kg.rules[t].join(", ")}` : `Definition for rule '${t}' was not found.`;
}
function En(t) {
  const {
    ruleId: e = null,
    loc: r = RB,
    message: s = MB(t.ruleId),
    severity: n = 2
  } = t;
  return {
    ruleId: e,
    message: s,
    line: r.start.line,
    column: r.start.column + 1,
    endLine: r.end.line,
    endColumn: r.end.column + 1,
    severity: n,
    nodeType: null
  };
}
function $B(t) {
  const {
    type: e,
    loc: r,
    value: s,
    ruleMapper: n
  } = t, a = Object.keys(_s.parseListConfig(s)), o = a.length ? a : [null], l = {
    directives: [],
    directiveProblems: []
  };
  for (const i of o)
    i === null || n(i) !== null ? l.directives.push({
      type: e,
      line: r.start.line,
      column: r.start.column + 1,
      ruleId: i
    }) : l.directiveProblems.push(En({
      ruleId: i,
      loc: r
    }));
  return l;
}
function HE(t) {
  return t.split(/\s-{2,}\s/u)[0].trim();
}
function VB(t, e, r, s) {
  const n = {}, a = /* @__PURE__ */ Object.create(null), o = {}, l = [], i = [], u = new x2.default({
    builtInRules: UE
  });
  return e.comments.filter((c) => c.type !== "Shebang").forEach((c) => {
    const f = HE(c.value), h = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u.exec(f);
    if (!h)
      return;
    const p = h[1], m = /^eslint-disable-(next-)?line$/u.test(p);
    if (c.type === "Line" && !m)
      return;
    if (s) {
      const g = c.type === "Block" ? `/*${p}*/` : `//${p}`;
      l.push(En({
        ruleId: null,
        message: `'${g}' has no effect because you have 'noInlineConfig' setting in ${s}.`,
        loc: c.loc,
        severity: 1
      }));
      return;
    }
    if (m && c.loc.start.line !== c.loc.end.line) {
      l.push(En({
        ruleId: null,
        message: `${p} comment should not span multiple lines.`,
        loc: c.loc
      }));
      return;
    }
    const d = f.slice(h.index + p.length);
    switch (p) {
      case "eslint-disable":
      case "eslint-enable":
      case "eslint-disable-next-line":
      case "eslint-disable-line": {
        const y = {
          type: p.slice(7),
          loc: c.loc,
          value: d,
          ruleMapper: r
        }, {
          directives: x,
          directiveProblems: A
        } = $B(y);
        i.push(...x), l.push(...A);
        break;
      }
      case "exported":
        Object.assign(o, _s.parseStringConfig(d, c));
        break;
      case "globals":
      case "global":
        for (const [g, {
          value: y
        }] of Object.entries(_s.parseStringConfig(d, c))) {
          let x;
          try {
            x = Oi.default.normalizeConfigGlobal(y);
          } catch (A) {
            l.push(En({
              ruleId: null,
              loc: c.loc,
              message: A.message
            }));
            continue;
          }
          a[g] ? (a[g].comments.push(c), a[g].value = x) : a[g] = {
            comments: [c],
            value: x
          };
        }
        break;
      case "eslint": {
        const g = _s.parseJsonConfig(d, c.loc);
        g.success ? Object.keys(g.config).forEach((y) => {
          const x = r(y), A = g.config[y];
          if (x === null) {
            l.push(En({
              ruleId: y,
              loc: c.loc
            }));
            return;
          }
          try {
            u.validateRuleOptions(x, y, A);
          } catch (b) {
            l.push(En({
              ruleId: y,
              message: b.message,
              loc: c.loc
            }));
            return;
          }
          n[y] = A;
        }) : l.push(g.error);
        break;
      }
    }
  }), {
    configuredRules: n,
    enabledGlobals: a,
    exportedVariables: o,
    problems: l,
    disableDirectives: i
  };
}
function UB(t, e) {
  return (t[NB] || t) === Za.default && e === "latest" ? Za.default.latestEcmaVersion : e >= 2015 ? e - 2009 : e;
}
const Jg = /\/\*\s*eslint-env\s(.+?)\*\//gsu;
function qB(t) {
  let e, r;
  for (Jg.lastIndex = 0; (e = Jg.exec(t)) !== null; )
    r = Object.assign(r || {}, _s.parseListConfig(HE(e[1])));
  return r;
}
function KE(t) {
  const e = t.split(Is.default.sep), r = e.lastIndexOf("<text>");
  return r === -1 ? t : e.slice(r).join(Is.default.sep);
}
function WB(t, e) {
  const r = e.noInlineConfig === !0, s = t.allowInlineConfig === !1, n = e.configNameOfNoInlineConfig ? ` (${e.configNameOfNoInlineConfig})` : "";
  let a = t.reportUnusedDisableDirectives;
  return typeof a == "boolean" && (a = a ? "error" : "off"), typeof a != "string" && (a = e.reportUnusedDisableDirectives ? "warn" : "off"), {
    filename: KE(t.filename || "<input>"),
    allowInlineConfig: !s,
    warnInlineConfig: r && !s ? `your config${n}` : null,
    reportUnusedDisableDirectives: a,
    disableFixes: !!t.disableFixes
  };
}
function zB(t, e, r) {
  const s = r.filter((o) => o.parserOptions).reduce((o, l) => Og.default(o, l.parserOptions), {}), n = Og.default(s, e || {});
  return n.sourceType === "module" && (n.ecmaFeatures = Object.assign({}, n.ecmaFeatures, {
    globalReturn: !1
  })), n.ecmaVersion = UB(t, n.ecmaVersion), n;
}
function GB(t, e) {
  return Object.assign({}, ...e.filter((r) => r.globals).map((r) => r.globals), t);
}
function HB(t) {
  return t.charCodeAt(0) === 65279 ? t.slice(1) : t;
}
function KB(t) {
  return Array.isArray(t) ? t.slice(1) : [];
}
function JE(t, e, r) {
  const s = e.ecmaFeatures || {}, n = e.ecmaVersion || LB;
  return xE.default.analyze(t, {
    ignoreEval: !0,
    nodejsScope: s.globalReturn,
    impliedStrict: s.impliedStrict,
    ecmaVersion: n,
    sourceType: e.sourceType || "script",
    childVisitorKeys: r || vE.default.KEYS,
    fallback: Xt.traverser.getKeys
  });
}
function JB(t, e, r, s) {
  const n = HB(t).replace(Xt.astUtils.shebangPattern, (o, l) => `//${l}`), a = Object.assign({}, r, {
    loc: !0,
    range: !0,
    raw: !0,
    tokens: !0,
    comment: !0,
    eslintVisitorKeys: !0,
    eslintScopeManager: !0,
    filePath: s
  });
  try {
    const o = typeof e.parseForESLint == "function" ? e.parseForESLint(n, a) : {
      ast: e.parse(n, a)
    }, l = o.ast, i = o.services || {}, u = o.visitorKeys || vE.default.KEYS, c = o.scopeManager || JE(l, a, u);
    return {
      success: !0,
      sourceCode: new GE({
        text: t,
        ast: l,
        parserServices: i,
        scopeManager: c,
        visitorKeys: u
      })
    };
  } catch (o) {
    const l = `Parsing error: ${o.message.replace(/^line \d+:/iu, "").trim()}`;
    return Rt(`%s
%s`, l, o.stack), {
      success: !1,
      error: {
        ruleId: null,
        fatal: !0,
        severity: 2,
        message: l,
        line: o.lineNumber,
        column: o.column
      }
    };
  }
}
function XE(t, e) {
  const r = e.type !== "Program";
  for (let s = e; s; s = s.parent) {
    const n = t.acquire(s, r);
    if (n)
      return n.type === "function-expression-name" ? n.childScopes[0] : n;
  }
  return t.scopes[0];
}
function XB(t, e, r, s) {
  const a = r.ecmaFeatures && r.ecmaFeatures.globalReturn || r.sourceType === "module", o = XE(t, e), l = o.type === "global" && a ? o.childScopes[0] : o;
  for (let i = l; i; i = i.upper) {
    const u = i.variables.find((c) => c.name === s);
    if (u)
      return u.eslintUsed = !0, !0;
  }
  return !1;
}
function QB(t, e) {
  try {
    return t.create(e);
  } catch (r) {
    throw r.message = `Error while loading rule '${e.id}': ${r.message}`, r;
  }
}
function YB(t) {
  const e = [];
  for (let r = t.parent; r; r = r.parent)
    e.push(r);
  return e.reverse();
}
const Xg = {
  getSource: "getText",
  getSourceLines: "getLines",
  getAllComments: "getAllComments",
  getNodeByRangeIndex: "getNodeByRangeIndex",
  getComments: "getComments",
  getCommentsBefore: "getCommentsBefore",
  getCommentsAfter: "getCommentsAfter",
  getCommentsInside: "getCommentsInside",
  getJSDocComment: "getJSDocComment",
  getFirstToken: "getFirstToken",
  getFirstTokens: "getFirstTokens",
  getLastToken: "getLastToken",
  getLastTokens: "getLastTokens",
  getTokenAfter: "getTokenAfter",
  getTokenBefore: "getTokenBefore",
  getTokenByRangeStart: "getTokenByRangeStart",
  getTokens: "getTokens",
  getTokensAfter: "getTokensAfter",
  getTokensBefore: "getTokensBefore",
  getTokensBetween: "getTokensBetween"
}, ZB = Object.freeze(Object.keys(Xg).reduce((t, e) => Object.assign(t, {
  [e](...r) {
    return this.getSourceCode()[Xg[e]](...r);
  }
}), {}));
function eO(t, e, r, s, n, a, o, l, i, u) {
  const c = TB(), f = [];
  let h = t.ast;
  Xt.traverser.traverse(t.ast, {
    enter(g, y) {
      g.parent = y, f.push({
        isEntering: !0,
        node: g
      });
    },
    leave(g) {
      f.push({
        isEntering: !1,
        node: g
      });
    },
    visitorKeys: t.visitorKeys
  });
  const p = Object.freeze(Object.assign(Object.create(ZB), {
    getAncestors: () => YB(h),
    getDeclaredVariables: t.scopeManager.getDeclaredVariables.bind(t.scopeManager),
    getCwd: () => i,
    getFilename: () => o,
    getPhysicalFilename: () => u || o,
    getScope: () => XE(t.scopeManager, h),
    getSourceCode: () => t,
    markVariableAsUsed: (g) => XB(t.scopeManager, h, s, g),
    parserOptions: s,
    parserPath: n,
    parserServices: t.parserServices,
    settings: a
  })), m = [];
  Object.keys(e).forEach((g) => {
    const y = Oi.default.getRuleSeverity(e[g]);
    if (y === 0)
      return;
    const x = r(g);
    if (x === null) {
      m.push(En({
        ruleId: g
      }));
      return;
    }
    const A = x.meta && x.meta.messages;
    let b = null;
    const v = Object.freeze(Object.assign(Object.create(p), {
      id: g,
      options: KB(e[g]),
      report(...T) {
        b === null && (b = DB({
          ruleId: g,
          severity: y,
          sourceCode: t,
          messageIds: A,
          disableFixes: l
        }));
        const w = b(...T);
        if (w.fix && x.meta && !x.meta.fixable)
          throw new Error("Fixable rules should export a `meta.fixable` property.");
        m.push(w);
      }
    })), C = QB(x, v);
    Object.keys(C).forEach((T) => {
      c.on(T, C[T]);
    });
  });
  const d = f[0].node.type === "Program" ? new oB(new zg(c, {
    visitorKeys: t.visitorKeys,
    fallback: Xt.traverser.getKeys
  })) : new zg(c, {
    visitorKeys: t.visitorKeys,
    fallback: Xt.traverser.getKeys
  });
  return f.forEach((g) => {
    h = g.node;
    try {
      g.isEntering ? d.enterNode(h) : d.leaveNode(h);
    } catch (y) {
      throw y.currentNode = h, y;
    }
  }), m;
}
function tO(t) {
  if (typeof t == "object") {
    const {
      hasBOM: e,
      text: r
    } = t;
    return (e ? "\uFEFF" : "") + r;
  }
  return String(t);
}
function rO(t, e) {
  return t.lastConfigArray && t.lastConfigArray.pluginEnvironments.get(e) || y2.default.get(e) || null;
}
function Qg(t, e) {
  return t.lastConfigArray && t.lastConfigArray.pluginRules.get(e) || t.ruleMap.get(e);
}
function nO(t) {
  if (t)
    return t;
  if (typeof Ze == "object")
    return Ze.cwd();
}
const Yr = /* @__PURE__ */ new WeakMap();
class sO {
  constructor({
    cwd: e
  } = {}) {
    Yr.set(this, {
      cwd: nO(e),
      lastConfigArray: null,
      lastSourceCode: null,
      parserMap: /* @__PURE__ */ new Map([["espree", Za.default]]),
      ruleMap: new UE()
    }), this.version = Hg.version;
  }
  static get version() {
    return Hg.version;
  }
  _verifyWithoutProcessors(e, r, s) {
    const n = Yr.get(this), a = r || {}, o = WB(s, a);
    let l;
    typeof e == "string" ? (n.lastSourceCode = null, l = e) : (n.lastSourceCode = e, l = e.text);
    let i = OB, u = Za.default;
    if (typeof a.parser == "object" && a.parser !== null)
      i = a.parser.filePath, u = a.parser.definition;
    else if (typeof a.parser == "string") {
      if (!n.parserMap.has(a.parser))
        return [{
          ruleId: null,
          fatal: !0,
          severity: 2,
          message: `Configured parser '${a.parser}' was not found.`,
          line: 0,
          column: 0
        }];
      i = a.parser, u = n.parserMap.get(a.parser);
    }
    const c = o.allowInlineConfig && !o.warnInlineConfig ? qB(l) : {}, f = Object.assign({
      builtin: !0
    }, a.env, c), h = Object.keys(f).filter((b) => f[b]).map((b) => rO(n, b)).filter((b) => b), p = zB(u, a.parserOptions || {}, h), m = GB(a.globals || {}, h), d = a.settings || {};
    if (n.lastSourceCode)
      n.lastSourceCode.scopeManager || (n.lastSourceCode = new GE({
        text: n.lastSourceCode.text,
        ast: n.lastSourceCode.ast,
        parserServices: n.lastSourceCode.parserServices,
        visitorKeys: n.lastSourceCode.visitorKeys,
        scopeManager: JE(n.lastSourceCode.ast, p)
      }));
    else {
      const b = JB(l, u, p, o.filename);
      if (!b.success)
        return [b.error];
      n.lastSourceCode = b.sourceCode;
    }
    const g = n.lastSourceCode, y = o.allowInlineConfig ? VB(o.filename, g.ast, (b) => Qg(n, b), o.warnInlineConfig) : {
      configuredRules: {},
      enabledGlobals: {},
      exportedVariables: {},
      problems: [],
      disableDirectives: []
    };
    jB(g.scopeManager.scopes[0], m, {
      exportedVariables: y.exportedVariables,
      enabledGlobals: y.enabledGlobals
    });
    const x = Object.assign({}, a.rules, y.configuredRules);
    let A;
    try {
      A = eO(g, x, (b) => Qg(n, b), p, i, d, o.filename, o.disableFixes, n.cwd, s.physicalFilename);
    } catch (b) {
      if (b.message += `
Occurred while linting ${o.filename}`, Rt("An error occurred while traversing"), Rt("Filename:", o.filename), b.currentNode) {
        const {
          line: v
        } = b.currentNode.loc.start;
        Rt("Line:", v), b.message += `:${v}`;
      }
      throw Rt("Parser Options:", p), Rt("Parser Path:", i), Rt("Settings:", d), b;
    }
    return lB({
      directives: y.disableDirectives,
      problems: A.concat(y.problems).sort((b, v) => b.line - v.line || b.column - v.column),
      reportUnusedDisableDirectives: o.reportUnusedDisableDirectives
    });
  }
  verify(e, r, s) {
    Rt("Verify");
    const n = typeof s == "string" ? {
      filename: s
    } : s || {};
    return r && typeof r.extractConfig == "function" ? this._verifyWithConfigArray(e, r, n) : n.preprocess || n.postprocess ? this._verifyWithProcessor(e, r, n) : this._verifyWithoutProcessors(e, r, n);
  }
  _verifyWithConfigArray(e, r, s) {
    Rt("With ConfigArray: %s", s.filename), Yr.get(this).lastConfigArray = r;
    const n = r.extractConfig(s.filename), a = n.processor && r.pluginProcessors.get(n.processor);
    if (a) {
      Rt("Apply the processor: %o", n.processor);
      const {
        preprocess: o,
        postprocess: l,
        supportsAutofix: i
      } = a, u = s.disableFixes || !i;
      return this._verifyWithProcessor(e, n, {
        ...s,
        disableFixes: u,
        postprocess: l,
        preprocess: o
      }, r);
    }
    return this._verifyWithoutProcessors(e, n, s);
  }
  _verifyWithProcessor(e, r, s, n) {
    const a = s.filename || "<input>", o = KE(a), l = s.physicalFilename || o, i = tO(e), u = s.preprocess || ((m) => [m]), c = s.postprocess || ((m) => [].concat(...m)), f = s.filterCodeBlock || ((m) => m.endsWith(".js")), h = Is.default.extname(a), p = u(i, o).map((m, d) => {
      if (Rt("A code block was found: %o", m.filename || "(unnamed)"), typeof m == "string")
        return this._verifyWithoutProcessors(m, r, s);
      const g = m.text, y = Is.default.join(a, `${d}_${m.filename}`);
      return f(y, g) ? n && (i !== g || Is.default.extname(y) !== h) ? (Rt("Resolving configuration again because the file content or extension was changed."), this._verifyWithConfigArray(g, n, {
        ...s,
        filename: y,
        physicalFilename: l
      })) : this._verifyWithoutProcessors(g, r, {
        ...s,
        filename: y,
        physicalFilename: l
      }) : (Rt("This code block was skipped."), []);
    });
    return c(p, o);
  }
  getSourceCode() {
    return Yr.get(this).lastSourceCode;
  }
  defineRule(e, r) {
    Yr.get(this).ruleMap.define(e, r);
  }
  defineRules(e) {
    Object.getOwnPropertyNames(e).forEach((r) => {
      this.defineRule(r, e[r]);
    });
  }
  getRules() {
    const {
      lastConfigArray: e,
      ruleMap: r
    } = Yr.get(this);
    return new Map(function* () {
      yield* r, e && (yield* e.pluginRules);
    }());
  }
  defineParser(e, r) {
    Yr.get(this).parserMap.set(e, r);
  }
  verifyAndFix(e, r, s) {
    let n = [], a, o = !1, l = 0, i = e;
    const u = s && s.filename || `${e.slice(0, 10)}...`, c = s && typeof s.fix < "u" ? s.fix : !0;
    do {
      if (l++, Rt(`Linting code for ${u} (pass ${l})`), n = this.verify(i, r, s), Rt(`Generating fixed text for ${u} (pass ${l})`), a = WE.applyFixes(i, n, c), n.length === 1 && n[0].fatal)
        break;
      o = o || a.fixed, i = a.output;
    } while (a.fixed && l < BB);
    return a.fixed && (a.messages = this.verify(i, r, s)), a.fixed = o, a.output = i, a;
  }
}
var aO = {
  Linter: sO,
  getLinterInternalSlots(t) {
    return Yr.get(t);
  }
};
const {
  Linter: iO
} = aO;
var oO = {
  Linter: iO,
  SourceCodeFixer: WE,
  interpolate: Wu
}, lO = oO.Linter;
A0.linter_1 = lO;
var ts = {}, QE = { exports: {} };
(function() {
  function t(o) {
    if (o == null)
      return !1;
    switch (o.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "Literal":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
        return !0;
    }
    return !1;
  }
  function e(o) {
    if (o == null)
      return !1;
    switch (o.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
        return !0;
    }
    return !1;
  }
  function r(o) {
    if (o == null)
      return !1;
    switch (o.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
        return !0;
    }
    return !1;
  }
  function s(o) {
    return r(o) || o != null && o.type === "FunctionDeclaration";
  }
  function n(o) {
    switch (o.type) {
      case "IfStatement":
        return o.alternate != null ? o.alternate : o.consequent;
      case "LabeledStatement":
      case "ForStatement":
      case "ForInStatement":
      case "WhileStatement":
      case "WithStatement":
        return o.body;
    }
    return null;
  }
  function a(o) {
    var l;
    if (o.type !== "IfStatement" || o.alternate == null)
      return !1;
    l = o.consequent;
    do {
      if (l.type === "IfStatement" && l.alternate == null)
        return !0;
      l = n(l);
    } while (l);
    return !1;
  }
  QE.exports = {
    isExpression: t,
    isStatement: r,
    isIterationStatement: e,
    isSourceElement: s,
    isProblematicIfStatement: a,
    trailingStatement: n
  };
})();
var zu = { exports: {} };
(function() {
  var t, e, r, s, n, a;
  e = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  }, t = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };
  function o(g) {
    return 48 <= g && g <= 57;
  }
  function l(g) {
    return 48 <= g && g <= 57 || // 0..9
    97 <= g && g <= 102 || // a..f
    65 <= g && g <= 70;
  }
  function i(g) {
    return g >= 48 && g <= 55;
  }
  r = [
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  function u(g) {
    return g === 32 || g === 9 || g === 11 || g === 12 || g === 160 || g >= 5760 && r.indexOf(g) >= 0;
  }
  function c(g) {
    return g === 10 || g === 13 || g === 8232 || g === 8233;
  }
  function f(g) {
    if (g <= 65535)
      return String.fromCharCode(g);
    var y = String.fromCharCode(Math.floor((g - 65536) / 1024) + 55296), x = String.fromCharCode((g - 65536) % 1024 + 56320);
    return y + x;
  }
  for (s = new Array(128), a = 0; a < 128; ++a)
    s[a] = a >= 97 && a <= 122 || // a..z
    a >= 65 && a <= 90 || // A..Z
    a === 36 || a === 95;
  for (n = new Array(128), a = 0; a < 128; ++a)
    n[a] = a >= 97 && a <= 122 || // a..z
    a >= 65 && a <= 90 || // A..Z
    a >= 48 && a <= 57 || // 0..9
    a === 36 || a === 95;
  function h(g) {
    return g < 128 ? s[g] : e.NonAsciiIdentifierStart.test(f(g));
  }
  function p(g) {
    return g < 128 ? n[g] : e.NonAsciiIdentifierPart.test(f(g));
  }
  function m(g) {
    return g < 128 ? s[g] : t.NonAsciiIdentifierStart.test(f(g));
  }
  function d(g) {
    return g < 128 ? n[g] : t.NonAsciiIdentifierPart.test(f(g));
  }
  zu.exports = {
    isDecimalDigit: o,
    isHexDigit: l,
    isOctalDigit: i,
    isWhiteSpace: u,
    isLineTerminator: c,
    isIdentifierStartES5: h,
    isIdentifierPartES5: p,
    isIdentifierStartES6: m,
    isIdentifierPartES6: d
  };
})();
var YE = { exports: {} };
(function() {
  var t = zu.exports;
  function e(h) {
    switch (h) {
      case "implements":
      case "interface":
      case "package":
      case "private":
      case "protected":
      case "public":
      case "static":
      case "let":
        return !0;
      default:
        return !1;
    }
  }
  function r(h, p) {
    return !p && h === "yield" ? !1 : s(h, p);
  }
  function s(h, p) {
    if (p && e(h))
      return !0;
    switch (h.length) {
      case 2:
        return h === "if" || h === "in" || h === "do";
      case 3:
        return h === "var" || h === "for" || h === "new" || h === "try";
      case 4:
        return h === "this" || h === "else" || h === "case" || h === "void" || h === "with" || h === "enum";
      case 5:
        return h === "while" || h === "break" || h === "catch" || h === "throw" || h === "const" || h === "yield" || h === "class" || h === "super";
      case 6:
        return h === "return" || h === "typeof" || h === "delete" || h === "switch" || h === "export" || h === "import";
      case 7:
        return h === "default" || h === "finally" || h === "extends";
      case 8:
        return h === "function" || h === "continue" || h === "debugger";
      case 10:
        return h === "instanceof";
      default:
        return !1;
    }
  }
  function n(h, p) {
    return h === "null" || h === "true" || h === "false" || r(h, p);
  }
  function a(h, p) {
    return h === "null" || h === "true" || h === "false" || s(h, p);
  }
  function o(h) {
    return h === "eval" || h === "arguments";
  }
  function l(h) {
    var p, m, d;
    if (h.length === 0 || (d = h.charCodeAt(0), !t.isIdentifierStartES5(d)))
      return !1;
    for (p = 1, m = h.length; p < m; ++p)
      if (d = h.charCodeAt(p), !t.isIdentifierPartES5(d))
        return !1;
    return !0;
  }
  function i(h, p) {
    return (h - 55296) * 1024 + (p - 56320) + 65536;
  }
  function u(h) {
    var p, m, d, g, y;
    if (h.length === 0)
      return !1;
    for (y = t.isIdentifierStartES6, p = 0, m = h.length; p < m; ++p) {
      if (d = h.charCodeAt(p), 55296 <= d && d <= 56319) {
        if (++p, p >= m || (g = h.charCodeAt(p), !(56320 <= g && g <= 57343)))
          return !1;
        d = i(d, g);
      }
      if (!y(d))
        return !1;
      y = t.isIdentifierPartES6;
    }
    return !0;
  }
  function c(h, p) {
    return l(h) && !n(h, p);
  }
  function f(h, p) {
    return u(h) && !a(h, p);
  }
  YE.exports = {
    isKeywordES5: r,
    isKeywordES6: s,
    isReservedWordES5: n,
    isReservedWordES6: a,
    isRestrictedWord: o,
    isIdentifierNameES5: l,
    isIdentifierNameES6: u,
    isIdentifierES5: c,
    isIdentifierES6: f
  };
})();
(function() {
  ts.ast = QE.exports, ts.code = zu.exports, ts.keyword = YE.exports;
})();
var uO = (t) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}, cO = hO, ot = 0, Qe = 1;
function Qt(t, e, r, s, n, a) {
  this._color = t, this.key = e, this.value = r, this.left = s, this.right = n, this._count = a;
}
function br(t) {
  return new Qt(t._color, t.key, t.value, t.left, t.right, t._count);
}
function tn(t, e) {
  return new Qt(t, e.key, e.value, e.left, e.right, e._count);
}
function ft(t) {
  t._count = 1 + (t.left ? t.left._count : 0) + (t.right ? t.right._count : 0);
}
function rn(t, e) {
  this._compare = t, this.root = e;
}
var $t = rn.prototype;
Object.defineProperty($t, "keys", {
  get: function() {
    var t = [];
    return this.forEach(function(e, r) {
      t.push(e);
    }), t;
  }
});
Object.defineProperty($t, "values", {
  get: function() {
    var t = [];
    return this.forEach(function(e, r) {
      t.push(r);
    }), t;
  }
});
Object.defineProperty($t, "length", {
  get: function() {
    return this.root ? this.root._count : 0;
  }
});
$t.insert = function(t, e) {
  for (var r = this._compare, s = this.root, n = [], a = []; s; ) {
    var o = r(t, s.key);
    n.push(s), a.push(o), o <= 0 ? s = s.left : s = s.right;
  }
  n.push(new Qt(ot, t, e, null, null, 1));
  for (var l = n.length - 2; l >= 0; --l) {
    var s = n[l];
    a[l] <= 0 ? n[l] = new Qt(s._color, s.key, s.value, n[l + 1], s.right, s._count + 1) : n[l] = new Qt(s._color, s.key, s.value, s.left, n[l + 1], s._count + 1);
  }
  for (var l = n.length - 1; l > 1; --l) {
    var i = n[l - 1], s = n[l];
    if (i._color === Qe || s._color === Qe)
      break;
    var u = n[l - 2];
    if (u.left === i)
      if (i.left === s) {
        var c = u.right;
        if (c && c._color === ot)
          i._color = Qe, u.right = tn(Qe, c), u._color = ot, l -= 1;
        else {
          if (u._color = ot, u.left = i.right, i._color = Qe, i.right = u, n[l - 2] = i, n[l - 1] = s, ft(u), ft(i), l >= 3) {
            var f = n[l - 3];
            f.left === u ? f.left = i : f.right = i;
          }
          break;
        }
      } else {
        var c = u.right;
        if (c && c._color === ot)
          i._color = Qe, u.right = tn(Qe, c), u._color = ot, l -= 1;
        else {
          if (i.right = s.left, u._color = ot, u.left = s.right, s._color = Qe, s.left = i, s.right = u, n[l - 2] = s, n[l - 1] = i, ft(u), ft(i), ft(s), l >= 3) {
            var f = n[l - 3];
            f.left === u ? f.left = s : f.right = s;
          }
          break;
        }
      }
    else if (i.right === s) {
      var c = u.left;
      if (c && c._color === ot)
        i._color = Qe, u.left = tn(Qe, c), u._color = ot, l -= 1;
      else {
        if (u._color = ot, u.right = i.left, i._color = Qe, i.left = u, n[l - 2] = i, n[l - 1] = s, ft(u), ft(i), l >= 3) {
          var f = n[l - 3];
          f.right === u ? f.right = i : f.left = i;
        }
        break;
      }
    } else {
      var c = u.left;
      if (c && c._color === ot)
        i._color = Qe, u.left = tn(Qe, c), u._color = ot, l -= 1;
      else {
        if (i.left = s.right, u._color = ot, u.right = s.left, s._color = Qe, s.right = i, s.left = u, n[l - 2] = s, n[l - 1] = i, ft(u), ft(i), ft(s), l >= 3) {
          var f = n[l - 3];
          f.right === u ? f.right = s : f.left = s;
        }
        break;
      }
    }
  }
  return n[0]._color = Qe, new rn(r, n[0]);
};
function Sl(t, e) {
  if (e.left) {
    var r = Sl(t, e.left);
    if (r)
      return r;
  }
  var r = t(e.key, e.value);
  if (r)
    return r;
  if (e.right)
    return Sl(t, e.right);
}
function Al(t, e, r, s) {
  var n = e(t, s.key);
  if (n <= 0) {
    if (s.left) {
      var a = Al(t, e, r, s.left);
      if (a)
        return a;
    }
    var a = r(s.key, s.value);
    if (a)
      return a;
  }
  if (s.right)
    return Al(t, e, r, s.right);
}
function Dl(t, e, r, s, n) {
  var a = r(t, n.key), o = r(e, n.key), l;
  if (a <= 0 && (n.left && (l = Dl(t, e, r, s, n.left), l) || o > 0 && (l = s(n.key, n.value), l)))
    return l;
  if (o > 0 && n.right)
    return Dl(t, e, r, s, n.right);
}
$t.forEach = function(e, r, s) {
  if (this.root)
    switch (arguments.length) {
      case 1:
        return Sl(e, this.root);
      case 2:
        return Al(r, this._compare, e, this.root);
      case 3:
        return this._compare(r, s) >= 0 ? void 0 : Dl(r, s, this._compare, e, this.root);
    }
};
Object.defineProperty($t, "begin", {
  get: function() {
    for (var t = [], e = this.root; e; )
      t.push(e), e = e.left;
    return new Yt(this, t);
  }
});
Object.defineProperty($t, "end", {
  get: function() {
    for (var t = [], e = this.root; e; )
      t.push(e), e = e.right;
    return new Yt(this, t);
  }
});
$t.at = function(t) {
  if (t < 0)
    return new Yt(this, []);
  for (var e = this.root, r = []; ; ) {
    if (r.push(e), e.left) {
      if (t < e.left._count) {
        e = e.left;
        continue;
      }
      t -= e.left._count;
    }
    if (!t)
      return new Yt(this, r);
    if (t -= 1, e.right) {
      if (t >= e.right._count)
        break;
      e = e.right;
    } else
      break;
  }
  return new Yt(this, []);
};
$t.ge = function(t) {
  for (var e = this._compare, r = this.root, s = [], n = 0; r; ) {
    var a = e(t, r.key);
    s.push(r), a <= 0 && (n = s.length), a <= 0 ? r = r.left : r = r.right;
  }
  return s.length = n, new Yt(this, s);
};
$t.gt = function(t) {
  for (var e = this._compare, r = this.root, s = [], n = 0; r; ) {
    var a = e(t, r.key);
    s.push(r), a < 0 && (n = s.length), a < 0 ? r = r.left : r = r.right;
  }
  return s.length = n, new Yt(this, s);
};
$t.lt = function(t) {
  for (var e = this._compare, r = this.root, s = [], n = 0; r; ) {
    var a = e(t, r.key);
    s.push(r), a > 0 && (n = s.length), a <= 0 ? r = r.left : r = r.right;
  }
  return s.length = n, new Yt(this, s);
};
$t.le = function(t) {
  for (var e = this._compare, r = this.root, s = [], n = 0; r; ) {
    var a = e(t, r.key);
    s.push(r), a >= 0 && (n = s.length), a < 0 ? r = r.left : r = r.right;
  }
  return s.length = n, new Yt(this, s);
};
$t.find = function(t) {
  for (var e = this._compare, r = this.root, s = []; r; ) {
    var n = e(t, r.key);
    if (s.push(r), n === 0)
      return new Yt(this, s);
    n <= 0 ? r = r.left : r = r.right;
  }
  return new Yt(this, []);
};
$t.remove = function(t) {
  var e = this.find(t);
  return e ? e.remove() : this;
};
$t.get = function(t) {
  for (var e = this._compare, r = this.root; r; ) {
    var s = e(t, r.key);
    if (s === 0)
      return r.value;
    s <= 0 ? r = r.left : r = r.right;
  }
};
function Yt(t, e) {
  this.tree = t, this._stack = e;
}
var fr = Yt.prototype;
Object.defineProperty(fr, "valid", {
  get: function() {
    return this._stack.length > 0;
  }
});
Object.defineProperty(fr, "node", {
  get: function() {
    return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
  },
  enumerable: !0
});
fr.clone = function() {
  return new Yt(this.tree, this._stack.slice());
};
function Yg(t, e) {
  t.key = e.key, t.value = e.value, t.left = e.left, t.right = e.right, t._color = e._color, t._count = e._count;
}
function pO(t) {
  for (var e, r, s, n, a = t.length - 1; a >= 0; --a) {
    if (e = t[a], a === 0) {
      e._color = Qe;
      return;
    }
    if (r = t[a - 1], r.left === e) {
      if (s = r.right, s.right && s.right._color === ot) {
        if (s = r.right = br(s), n = s.right = br(s.right), r.right = s.left, s.left = r, s.right = n, s._color = r._color, e._color = Qe, r._color = Qe, n._color = Qe, ft(r), ft(s), a > 1) {
          var o = t[a - 2];
          o.left === r ? o.left = s : o.right = s;
        }
        t[a - 1] = s;
        return;
      } else if (s.left && s.left._color === ot) {
        if (s = r.right = br(s), n = s.left = br(s.left), r.right = n.left, s.left = n.right, n.left = r, n.right = s, n._color = r._color, r._color = Qe, s._color = Qe, e._color = Qe, ft(r), ft(s), ft(n), a > 1) {
          var o = t[a - 2];
          o.left === r ? o.left = n : o.right = n;
        }
        t[a - 1] = n;
        return;
      }
      if (s._color === Qe)
        if (r._color === ot) {
          r._color = Qe, r.right = tn(ot, s);
          return;
        } else {
          r.right = tn(ot, s);
          continue;
        }
      else {
        if (s = br(s), r.right = s.left, s.left = r, s._color = r._color, r._color = ot, ft(r), ft(s), a > 1) {
          var o = t[a - 2];
          o.left === r ? o.left = s : o.right = s;
        }
        t[a - 1] = s, t[a] = r, a + 1 < t.length ? t[a + 1] = e : t.push(e), a = a + 2;
      }
    } else {
      if (s = r.left, s.left && s.left._color === ot) {
        if (s = r.left = br(s), n = s.left = br(s.left), r.left = s.right, s.right = r, s.left = n, s._color = r._color, e._color = Qe, r._color = Qe, n._color = Qe, ft(r), ft(s), a > 1) {
          var o = t[a - 2];
          o.right === r ? o.right = s : o.left = s;
        }
        t[a - 1] = s;
        return;
      } else if (s.right && s.right._color === ot) {
        if (s = r.left = br(s), n = s.right = br(s.right), r.left = n.right, s.right = n.left, n.right = r, n.left = s, n._color = r._color, r._color = Qe, s._color = Qe, e._color = Qe, ft(r), ft(s), ft(n), a > 1) {
          var o = t[a - 2];
          o.right === r ? o.right = n : o.left = n;
        }
        t[a - 1] = n;
        return;
      }
      if (s._color === Qe)
        if (r._color === ot) {
          r._color = Qe, r.left = tn(ot, s);
          return;
        } else {
          r.left = tn(ot, s);
          continue;
        }
      else {
        if (s = br(s), r.left = s.right, s.right = r, s._color = r._color, r._color = ot, ft(r), ft(s), a > 1) {
          var o = t[a - 2];
          o.right === r ? o.right = s : o.left = s;
        }
        t[a - 1] = s, t[a] = r, a + 1 < t.length ? t[a + 1] = e : t.push(e), a = a + 2;
      }
    }
  }
}
fr.remove = function() {
  var t = this._stack;
  if (t.length === 0)
    return this.tree;
  var e = new Array(t.length), r = t[t.length - 1];
  e[e.length - 1] = new Qt(r._color, r.key, r.value, r.left, r.right, r._count);
  for (var s = t.length - 2; s >= 0; --s) {
    var r = t[s];
    r.left === t[s + 1] ? e[s] = new Qt(r._color, r.key, r.value, e[s + 1], r.right, r._count) : e[s] = new Qt(r._color, r.key, r.value, r.left, e[s + 1], r._count);
  }
  if (r = e[e.length - 1], r.left && r.right) {
    var n = e.length;
    for (r = r.left; r.right; )
      e.push(r), r = r.right;
    var a = e[n - 1];
    e.push(new Qt(r._color, a.key, a.value, r.left, r.right, r._count)), e[n - 1].key = r.key, e[n - 1].value = r.value;
    for (var s = e.length - 2; s >= n; --s)
      r = e[s], e[s] = new Qt(r._color, r.key, r.value, r.left, e[s + 1], r._count);
    e[n - 1].left = e[n];
  }
  if (r = e[e.length - 1], r._color === ot) {
    var o = e[e.length - 2];
    o.left === r ? o.left = null : o.right === r && (o.right = null), e.pop();
    for (var s = 0; s < e.length; ++s)
      e[s]._count--;
    return new rn(this.tree._compare, e[0]);
  } else if (r.left || r.right) {
    r.left ? Yg(r, r.left) : r.right && Yg(r, r.right), r._color = Qe;
    for (var s = 0; s < e.length - 1; ++s)
      e[s]._count--;
    return new rn(this.tree._compare, e[0]);
  } else {
    if (e.length === 1)
      return new rn(this.tree._compare, null);
    for (var s = 0; s < e.length; ++s)
      e[s]._count--;
    var l = e[e.length - 2];
    pO(e), l.left === r ? l.left = null : l.right = null;
  }
  return new rn(this.tree._compare, e[0]);
};
Object.defineProperty(fr, "key", {
  get: function() {
    if (this._stack.length > 0)
      return this._stack[this._stack.length - 1].key;
  },
  enumerable: !0
});
Object.defineProperty(fr, "value", {
  get: function() {
    if (this._stack.length > 0)
      return this._stack[this._stack.length - 1].value;
  },
  enumerable: !0
});
Object.defineProperty(fr, "index", {
  get: function() {
    var t = 0, e = this._stack;
    if (e.length === 0) {
      var r = this.tree.root;
      return r ? r._count : 0;
    } else
      e[e.length - 1].left && (t = e[e.length - 1].left._count);
    for (var s = e.length - 2; s >= 0; --s)
      e[s + 1] === e[s].right && (++t, e[s].left && (t += e[s].left._count));
    return t;
  },
  enumerable: !0
});
fr.next = function() {
  var t = this._stack;
  if (t.length !== 0) {
    var e = t[t.length - 1];
    if (e.right)
      for (e = e.right; e; )
        t.push(e), e = e.left;
    else
      for (t.pop(); t.length > 0 && t[t.length - 1].right === e; )
        e = t[t.length - 1], t.pop();
  }
};
Object.defineProperty(fr, "hasNext", {
  get: function() {
    var t = this._stack;
    if (t.length === 0)
      return !1;
    if (t[t.length - 1].right)
      return !0;
    for (var e = t.length - 1; e > 0; --e)
      if (t[e - 1].left === t[e])
        return !0;
    return !1;
  }
});
fr.update = function(t) {
  var e = this._stack;
  if (e.length === 0)
    throw new Error("Can't update empty node!");
  var r = new Array(e.length), s = e[e.length - 1];
  r[r.length - 1] = new Qt(s._color, s.key, t, s.left, s.right, s._count);
  for (var n = e.length - 2; n >= 0; --n)
    s = e[n], s.left === e[n + 1] ? r[n] = new Qt(s._color, s.key, s.value, r[n + 1], s.right, s._count) : r[n] = new Qt(s._color, s.key, s.value, s.left, r[n + 1], s._count);
  return new rn(this.tree._compare, r[0]);
};
fr.prev = function() {
  var t = this._stack;
  if (t.length !== 0) {
    var e = t[t.length - 1];
    if (e.left)
      for (e = e.left; e; )
        t.push(e), e = e.right;
    else
      for (t.pop(); t.length > 0 && t[t.length - 1].left === e; )
        e = t[t.length - 1], t.pop();
  }
};
Object.defineProperty(fr, "hasPrev", {
  get: function() {
    var t = this._stack;
    if (t.length === 0)
      return !1;
    if (t[t.length - 1].left)
      return !0;
    for (var e = t.length - 1; e > 0; --e)
      if (t[e - 1].right === t[e])
        return !0;
    return !1;
  }
});
function fO(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function hO(t) {
  return new rn(t || fO, null);
}
var cn = {};
/*! @author Toru Nagashima <https://github.com/mysticatea> */
Object.defineProperty(cn, "__esModule", { value: !0 });
var mO = /* @__PURE__ */ Object.freeze({});
let Zg, ey;
function dO(t) {
  return t < 65 ? !1 : t < 91 ? !0 : t < 97 ? !1 : t < 123 ? !0 : eb(t);
}
function ZE(t) {
  return t < 48 ? !1 : t < 58 ? !0 : t < 65 ? !1 : t < 91 || t === 95 ? !0 : t < 97 ? !1 : t < 123 ? !0 : eb(t) || gO(t);
}
function eb(t) {
  return tb(t, Zg || (Zg = yO()));
}
function gO(t) {
  return tb(t, ey || (ey = xO()));
}
function yO() {
  return rb("4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 1i k 2 h 1p 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 6 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 x 0 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 c 2 3 f h f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 6 1k t e 1 b 17 r z 16 2 b z 3 8 8 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 1a 2 1a 2 3o 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t g70 4 wc 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1g 3 8 17 c 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f 4d 8m a l b 7 49 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 9p 15 7 1 27 s b 0 9 l 2z k s m d 1g 24 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o 2d 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 4f 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 6e 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 z 1k 7c 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i 5a 0 28 pl 2v 32 i 5f 24d tq 34i g6 6nu fs 8 u 36 t j 1b h 3 w k 6 i j5 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 17 8 6wo 7y 1e 2 i 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1th 18 b 6 h 0 aa 17 105 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyl z 378 c 65 3 4g1 f 5rk 2e8 f1 15v 3t6");
}
function xO() {
  return rb("53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 3c e 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1m 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 h 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 5 3 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 2 u 2 u 1 v 1 1t v a 0 3 9 y 2 3 9 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 1 1s 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1l 2 4 g0 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 n7q 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 ji 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 aa 1 4a a 4w 2 1i e w 9 g 3 1a a 1i 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 4h b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 5d h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 2c e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f ba 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 ewa 9 3r 4 1o 6 q 9 s6 0 2 1i 8 3 2a 0 c 1 f58 1 43r 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 7a 6 a 9 bn d 15j 6 32 6 6 9 3o7 9 gvt3 6n");
}
function tb(t, e) {
  let r = 0, s = e.length / 2 | 0, n = 0, a = 0, o = 0;
  for (; r < s; )
    if (n = (r + s) / 2 | 0, a = e[2 * n], o = e[2 * n + 1], t < a)
      s = n;
    else if (t > o)
      r = n + 1;
    else
      return !0;
  return !1;
}
function rb(t) {
  let e = 0;
  return t.split(" ").map((r) => e += parseInt(r, 36) | 0);
}
class Gu {
  constructor(e, r, s, n) {
    this._raw2018 = e, this._raw2019 = r, this._raw2020 = s, this._raw2021 = n;
  }
  get es2018() {
    return this._set2018 || (this._set2018 = new Set(this._raw2018.split(" ")));
  }
  get es2019() {
    return this._set2019 || (this._set2019 = new Set(this._raw2019.split(" ")));
  }
  get es2020() {
    return this._set2020 || (this._set2020 = new Set(this._raw2020.split(" ")));
  }
  get es2021() {
    return this._set2021 || (this._set2021 = new Set(this._raw2021.split(" ")));
  }
}
const vO = /* @__PURE__ */ new Set(["General_Category", "gc"]), EO = /* @__PURE__ */ new Set(["Script", "Script_Extensions", "sc", "scx"]), bO = new Gu("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "", ""), ga = new Gu("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho", "Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi"), Po = new Gu("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "", "EBase EComp EMod EPres ExtPict");
function ty(t, e, r) {
  return vO.has(e) ? t >= 2018 && bO.es2018.has(r) : EO.has(e) ? t >= 2018 && ga.es2018.has(r) || t >= 2019 && ga.es2019.has(r) || t >= 2020 && ga.es2020.has(r) || t >= 2021 && ga.es2021.has(r) : !1;
}
function CO(t, e) {
  return t >= 2018 && Po.es2018.has(e) || t >= 2019 && Po.es2019.has(e) || t >= 2021 && Po.es2021.has(e);
}
const SO = 8, AO = 9, nb = 10, DO = 11, wO = 12, sb = 13, ry = 33, Us = 36, Wn = 40, zn = 41, Ba = 42, wl = 43, kO = 44, Cs = 45, kl = 46, ya = 47, nn = 48, TO = 49, FO = 55, ti = 57, PO = 58, Io = 60, _o = 61, IO = 62, Lr = 63, ri = 65, _O = 66, BO = 68, ab = 70, OO = 80, LO = 83, RO = 87, NO = 90, ji = 95, ni = 97, ny = 98, jn = 99, sy = 100, Hu = 102, jO = 103, MO = 105, ay = 107, $O = 109, VO = 110, UO = 112, qO = 114, iy = 115, WO = 116, Bo = 117, zO = 118, GO = 119, HO = 120, KO = 121, JO = 122, Ss = 91, Ot = 92, Gn = 93, Oa = 94, As = 123, Tl = 124, Ds = 125, XO = 8204, QO = 8205, YO = 8232, ZO = 8233, eL = 0, tL = 1114111;
function ib(t) {
  return t >= ri && t <= NO || t >= ni && t <= JO;
}
function La(t) {
  return t >= nn && t <= ti;
}
function rL(t) {
  return t >= nn && t <= FO;
}
function oy(t) {
  return t >= nn && t <= ti || t >= ri && t <= ab || t >= ni && t <= Hu;
}
function nL(t) {
  return t === nb || t === sb || t === YO || t === ZO;
}
function sL(t) {
  return t >= eL && t <= tL;
}
function Oo(t) {
  return t >= ni && t <= Hu ? t - ni + 10 : t >= ri && t <= ab ? t - ri + 10 : t - nn;
}
function Lo(t) {
  return t >= 55296 && t <= 56319;
}
function Ro(t) {
  return t >= 56320 && t <= 57343;
}
function No(t, e) {
  return (t - 55296) * 1024 + (e - 56320) + 65536;
}
const ly = {
  at(t, e, r) {
    return r < e ? t.charCodeAt(r) : -1;
  },
  width(t) {
    return 1;
  }
}, aL = {
  at(t, e, r) {
    return r < e ? t.codePointAt(r) : -1;
  },
  width(t) {
    return t > 65535 ? 2 : 1;
  }
};
class iL {
  constructor() {
    this._impl = ly, this._s = "", this._i = 0, this._end = 0, this._cp1 = -1, this._w1 = 1, this._cp2 = -1, this._w2 = 1, this._cp3 = -1, this._w3 = 1, this._cp4 = -1;
  }
  get source() {
    return this._s;
  }
  get index() {
    return this._i;
  }
  get currentCodePoint() {
    return this._cp1;
  }
  get nextCodePoint() {
    return this._cp2;
  }
  get nextCodePoint2() {
    return this._cp3;
  }
  get nextCodePoint3() {
    return this._cp4;
  }
  reset(e, r, s, n) {
    this._impl = n ? aL : ly, this._s = e, this._end = s, this.rewind(r);
  }
  rewind(e) {
    const r = this._impl;
    this._i = e, this._cp1 = r.at(this._s, this._end, e), this._w1 = r.width(this._cp1), this._cp2 = r.at(this._s, this._end, e + this._w1), this._w2 = r.width(this._cp2), this._cp3 = r.at(this._s, this._end, e + this._w1 + this._w2), this._w3 = r.width(this._cp3), this._cp4 = r.at(this._s, this._end, e + this._w1 + this._w2 + this._w3);
  }
  advance() {
    if (this._cp1 !== -1) {
      const e = this._impl;
      this._i += this._w1, this._cp1 = this._cp2, this._w1 = this._w2, this._cp2 = this._cp3, this._w2 = e.width(this._cp2), this._cp3 = this._cp4, this._w3 = e.width(this._cp3), this._cp4 = e.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
    }
  }
  eat(e) {
    return this._cp1 === e ? (this.advance(), !0) : !1;
  }
  eat2(e, r) {
    return this._cp1 === e && this._cp2 === r ? (this.advance(), this.advance(), !0) : !1;
  }
  eat3(e, r, s) {
    return this._cp1 === e && this._cp2 === r && this._cp3 === s ? (this.advance(), this.advance(), this.advance(), !0) : !1;
  }
}
class oL extends SyntaxError {
  constructor(e, r, s, n) {
    e && (e.startsWith("/") || (e = `/${e}/${r ? "u" : ""}`), e = `: ${e}`), super(`Invalid regular expression${e}: ${n}`), this.index = s;
  }
}
function uy(t) {
  return t === Oa || t === Us || t === Ot || t === kl || t === Ba || t === wl || t === Lr || t === Wn || t === zn || t === Ss || t === Gn || t === As || t === Ds || t === Tl;
}
function lL(t) {
  return dO(t) || t === Us || t === ji;
}
function uL(t) {
  return ZE(t) || t === Us || t === ji || t === XO || t === QO;
}
function ob(t) {
  return ib(t) || t === ji;
}
function cL(t) {
  return ob(t) || La(t);
}
let Ku = class {
  constructor(e) {
    this._reader = new iL(), this._uFlag = !1, this._nFlag = !1, this._lastIntValue = 0, this._lastMinValue = 0, this._lastMaxValue = 0, this._lastStrValue = "", this._lastKeyValue = "", this._lastValValue = "", this._lastAssertionIsQuantifiable = !1, this._numCapturingParens = 0, this._groupNames = /* @__PURE__ */ new Set(), this._backreferenceNames = /* @__PURE__ */ new Set(), this._options = e || {};
  }
  validateLiteral(e, r = 0, s = e.length) {
    if (this._uFlag = this._nFlag = !1, this.reset(e, r, s), this.onLiteralEnter(r), this.eat(ya) && this.eatRegExpBody() && this.eat(ya)) {
      const n = this.index, a = e.includes("u", n);
      this.validateFlags(e, n, s), this.validatePattern(e, r + 1, n - 1, a);
    } else if (r >= s)
      this.raise("Empty");
    else {
      const n = String.fromCodePoint(this.currentCodePoint);
      this.raise(`Unexpected character '${n}'`);
    }
    this.onLiteralLeave(r, s);
  }
  validateFlags(e, r = 0, s = e.length) {
    const n = /* @__PURE__ */ new Set();
    let a = !1, o = !1, l = !1, i = !1, u = !1, c = !1, f = !1;
    for (let h = r; h < s; ++h) {
      const p = e.charCodeAt(h);
      n.has(p) && this.raise(`Duplicated flag '${e[h]}'`), n.add(p), p === jO ? a = !0 : p === MO ? o = !0 : p === $O ? l = !0 : p === Bo && this.ecmaVersion >= 2015 ? u = !0 : p === KO && this.ecmaVersion >= 2015 ? i = !0 : p === iy && this.ecmaVersion >= 2018 ? c = !0 : p === sy && this.ecmaVersion >= 2022 ? f = !0 : this.raise(`Invalid flag '${e[h]}'`);
    }
    this.onFlags(r, s, a, o, l, u, i, c, f);
  }
  validatePattern(e, r = 0, s = e.length, n = !1) {
    this._uFlag = n && this.ecmaVersion >= 2015, this._nFlag = n && this.ecmaVersion >= 2018, this.reset(e, r, s), this.consumePattern(), !this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0 && (this._nFlag = !0, this.rewind(r), this.consumePattern());
  }
  get strict() {
    return !!(this._options.strict || this._uFlag);
  }
  get ecmaVersion() {
    return this._options.ecmaVersion || 2022;
  }
  onLiteralEnter(e) {
    this._options.onLiteralEnter && this._options.onLiteralEnter(e);
  }
  onLiteralLeave(e, r) {
    this._options.onLiteralLeave && this._options.onLiteralLeave(e, r);
  }
  onFlags(e, r, s, n, a, o, l, i, u) {
    this._options.onFlags && this._options.onFlags(e, r, s, n, a, o, l, i, u);
  }
  onPatternEnter(e) {
    this._options.onPatternEnter && this._options.onPatternEnter(e);
  }
  onPatternLeave(e, r) {
    this._options.onPatternLeave && this._options.onPatternLeave(e, r);
  }
  onDisjunctionEnter(e) {
    this._options.onDisjunctionEnter && this._options.onDisjunctionEnter(e);
  }
  onDisjunctionLeave(e, r) {
    this._options.onDisjunctionLeave && this._options.onDisjunctionLeave(e, r);
  }
  onAlternativeEnter(e, r) {
    this._options.onAlternativeEnter && this._options.onAlternativeEnter(e, r);
  }
  onAlternativeLeave(e, r, s) {
    this._options.onAlternativeLeave && this._options.onAlternativeLeave(e, r, s);
  }
  onGroupEnter(e) {
    this._options.onGroupEnter && this._options.onGroupEnter(e);
  }
  onGroupLeave(e, r) {
    this._options.onGroupLeave && this._options.onGroupLeave(e, r);
  }
  onCapturingGroupEnter(e, r) {
    this._options.onCapturingGroupEnter && this._options.onCapturingGroupEnter(e, r);
  }
  onCapturingGroupLeave(e, r, s) {
    this._options.onCapturingGroupLeave && this._options.onCapturingGroupLeave(e, r, s);
  }
  onQuantifier(e, r, s, n, a) {
    this._options.onQuantifier && this._options.onQuantifier(e, r, s, n, a);
  }
  onLookaroundAssertionEnter(e, r, s) {
    this._options.onLookaroundAssertionEnter && this._options.onLookaroundAssertionEnter(e, r, s);
  }
  onLookaroundAssertionLeave(e, r, s, n) {
    this._options.onLookaroundAssertionLeave && this._options.onLookaroundAssertionLeave(e, r, s, n);
  }
  onEdgeAssertion(e, r, s) {
    this._options.onEdgeAssertion && this._options.onEdgeAssertion(e, r, s);
  }
  onWordBoundaryAssertion(e, r, s, n) {
    this._options.onWordBoundaryAssertion && this._options.onWordBoundaryAssertion(e, r, s, n);
  }
  onAnyCharacterSet(e, r, s) {
    this._options.onAnyCharacterSet && this._options.onAnyCharacterSet(e, r, s);
  }
  onEscapeCharacterSet(e, r, s, n) {
    this._options.onEscapeCharacterSet && this._options.onEscapeCharacterSet(e, r, s, n);
  }
  onUnicodePropertyCharacterSet(e, r, s, n, a, o) {
    this._options.onUnicodePropertyCharacterSet && this._options.onUnicodePropertyCharacterSet(e, r, s, n, a, o);
  }
  onCharacter(e, r, s) {
    this._options.onCharacter && this._options.onCharacter(e, r, s);
  }
  onBackreference(e, r, s) {
    this._options.onBackreference && this._options.onBackreference(e, r, s);
  }
  onCharacterClassEnter(e, r) {
    this._options.onCharacterClassEnter && this._options.onCharacterClassEnter(e, r);
  }
  onCharacterClassLeave(e, r, s) {
    this._options.onCharacterClassLeave && this._options.onCharacterClassLeave(e, r, s);
  }
  onCharacterClassRange(e, r, s, n) {
    this._options.onCharacterClassRange && this._options.onCharacterClassRange(e, r, s, n);
  }
  get source() {
    return this._reader.source;
  }
  get index() {
    return this._reader.index;
  }
  get currentCodePoint() {
    return this._reader.currentCodePoint;
  }
  get nextCodePoint() {
    return this._reader.nextCodePoint;
  }
  get nextCodePoint2() {
    return this._reader.nextCodePoint2;
  }
  get nextCodePoint3() {
    return this._reader.nextCodePoint3;
  }
  reset(e, r, s) {
    this._reader.reset(e, r, s, this._uFlag);
  }
  rewind(e) {
    this._reader.rewind(e);
  }
  advance() {
    this._reader.advance();
  }
  eat(e) {
    return this._reader.eat(e);
  }
  eat2(e, r) {
    return this._reader.eat2(e, r);
  }
  eat3(e, r, s) {
    return this._reader.eat3(e, r, s);
  }
  raise(e) {
    throw new oL(this.source, this._uFlag, this.index, e);
  }
  eatRegExpBody() {
    const e = this.index;
    let r = !1, s = !1;
    for (; ; ) {
      const n = this.currentCodePoint;
      if (n === -1 || nL(n)) {
        const a = r ? "character class" : "regular expression";
        this.raise(`Unterminated ${a}`);
      }
      if (s)
        s = !1;
      else if (n === Ot)
        s = !0;
      else if (n === Ss)
        r = !0;
      else if (n === Gn)
        r = !1;
      else if (n === ya && !r || n === Ba && this.index === e)
        break;
      this.advance();
    }
    return this.index !== e;
  }
  consumePattern() {
    const e = this.index;
    this._numCapturingParens = this.countCapturingParens(), this._groupNames.clear(), this._backreferenceNames.clear(), this.onPatternEnter(e), this.consumeDisjunction();
    const r = this.currentCodePoint;
    if (this.currentCodePoint !== -1) {
      r === zn && this.raise("Unmatched ')'"), r === Ot && this.raise("\\ at end of pattern"), (r === Gn || r === Ds) && this.raise("Lone quantifier brackets");
      const s = String.fromCodePoint(r);
      this.raise(`Unexpected character '${s}'`);
    }
    for (const s of this._backreferenceNames)
      this._groupNames.has(s) || this.raise("Invalid named capture referenced");
    this.onPatternLeave(e, this.index);
  }
  countCapturingParens() {
    const e = this.index;
    let r = !1, s = !1, n = 0, a = 0;
    for (; (a = this.currentCodePoint) !== -1; )
      s ? s = !1 : a === Ot ? s = !0 : a === Ss ? r = !0 : a === Gn ? r = !1 : a === Wn && !r && (this.nextCodePoint !== Lr || this.nextCodePoint2 === Io && this.nextCodePoint3 !== _o && this.nextCodePoint3 !== ry) && (n += 1), this.advance();
    return this.rewind(e), n;
  }
  consumeDisjunction() {
    const e = this.index;
    let r = 0;
    this.onDisjunctionEnter(e);
    do
      this.consumeAlternative(r++);
    while (this.eat(Tl));
    this.consumeQuantifier(!0) && this.raise("Nothing to repeat"), this.eat(As) && this.raise("Lone quantifier brackets"), this.onDisjunctionLeave(e, this.index);
  }
  consumeAlternative(e) {
    const r = this.index;
    for (this.onAlternativeEnter(r, e); this.currentCodePoint !== -1 && this.consumeTerm(); )
      ;
    this.onAlternativeLeave(r, this.index, e);
  }
  consumeTerm() {
    return this._uFlag || this.strict ? this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier() : this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
  }
  consumeOptionalQuantifier() {
    return this.consumeQuantifier(), !0;
  }
  consumeAssertion() {
    const e = this.index;
    if (this._lastAssertionIsQuantifiable = !1, this.eat(Oa))
      return this.onEdgeAssertion(e, this.index, "start"), !0;
    if (this.eat(Us))
      return this.onEdgeAssertion(e, this.index, "end"), !0;
    if (this.eat2(Ot, _O))
      return this.onWordBoundaryAssertion(e, this.index, "word", !0), !0;
    if (this.eat2(Ot, ny))
      return this.onWordBoundaryAssertion(e, this.index, "word", !1), !0;
    if (this.eat2(Wn, Lr)) {
      const r = this.ecmaVersion >= 2018 && this.eat(Io);
      let s = !1;
      if (this.eat(_o) || (s = this.eat(ry))) {
        const n = r ? "lookbehind" : "lookahead";
        return this.onLookaroundAssertionEnter(e, n, s), this.consumeDisjunction(), this.eat(zn) || this.raise("Unterminated group"), this._lastAssertionIsQuantifiable = !r && !this.strict, this.onLookaroundAssertionLeave(e, this.index, n, s), !0;
      }
      this.rewind(e);
    }
    return !1;
  }
  consumeQuantifier(e = !1) {
    const r = this.index;
    let s = 0, n = 0, a = !1;
    if (this.eat(Ba))
      s = 0, n = Number.POSITIVE_INFINITY;
    else if (this.eat(wl))
      s = 1, n = Number.POSITIVE_INFINITY;
    else if (this.eat(Lr))
      s = 0, n = 1;
    else if (this.eatBracedQuantifier(e))
      s = this._lastMinValue, n = this._lastMaxValue;
    else
      return !1;
    return a = !this.eat(Lr), e || this.onQuantifier(r, this.index, s, n, a), !0;
  }
  eatBracedQuantifier(e) {
    const r = this.index;
    if (this.eat(As)) {
      if (this._lastMinValue = 0, this._lastMaxValue = Number.POSITIVE_INFINITY, this.eatDecimalDigits() && (this._lastMinValue = this._lastMaxValue = this._lastIntValue, this.eat(kO) && (this._lastMaxValue = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY), this.eat(Ds)))
        return !e && this._lastMaxValue < this._lastMinValue && this.raise("numbers out of order in {} quantifier"), !0;
      !e && (this._uFlag || this.strict) && this.raise("Incomplete quantifier"), this.rewind(r);
    }
    return !1;
  }
  consumeAtom() {
    return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup();
  }
  consumeDot() {
    return this.eat(kl) ? (this.onAnyCharacterSet(this.index - 1, this.index, "any"), !0) : !1;
  }
  consumeReverseSolidusAtomEscape() {
    const e = this.index;
    if (this.eat(Ot)) {
      if (this.consumeAtomEscape())
        return !0;
      this.rewind(e);
    }
    return !1;
  }
  consumeUncapturingGroup() {
    const e = this.index;
    return this.eat3(Wn, Lr, PO) ? (this.onGroupEnter(e), this.consumeDisjunction(), this.eat(zn) || this.raise("Unterminated group"), this.onGroupLeave(e, this.index), !0) : !1;
  }
  consumeCapturingGroup() {
    const e = this.index;
    if (this.eat(Wn)) {
      let r = null;
      return this.ecmaVersion >= 2018 ? this.consumeGroupSpecifier() && (r = this._lastStrValue) : this.currentCodePoint === Lr && this.raise("Invalid group"), this.onCapturingGroupEnter(e, r), this.consumeDisjunction(), this.eat(zn) || this.raise("Unterminated group"), this.onCapturingGroupLeave(e, this.index, r), !0;
    }
    return !1;
  }
  consumeExtendedAtom() {
    return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
  }
  consumeReverseSolidusFollowedByC() {
    const e = this.index;
    return this.currentCodePoint === Ot && this.nextCodePoint === jn ? (this._lastIntValue = this.currentCodePoint, this.advance(), this.onCharacter(e, this.index, Ot), !0) : !1;
  }
  consumeInvalidBracedQuantifier() {
    return this.eatBracedQuantifier(!0) && this.raise("Nothing to repeat"), !1;
  }
  consumePatternCharacter() {
    const e = this.index, r = this.currentCodePoint;
    return r !== -1 && !uy(r) ? (this.advance(), this.onCharacter(e, this.index, r), !0) : !1;
  }
  consumeExtendedPatternCharacter() {
    const e = this.index, r = this.currentCodePoint;
    return r !== -1 && r !== Oa && r !== Us && r !== Ot && r !== kl && r !== Ba && r !== wl && r !== Lr && r !== Wn && r !== zn && r !== Ss && r !== Tl ? (this.advance(), this.onCharacter(e, this.index, r), !0) : !1;
  }
  consumeGroupSpecifier() {
    if (this.eat(Lr)) {
      if (this.eatGroupName()) {
        if (!this._groupNames.has(this._lastStrValue))
          return this._groupNames.add(this._lastStrValue), !0;
        this.raise("Duplicate capture group name");
      }
      this.raise("Invalid group");
    }
    return !1;
  }
  consumeAtomEscape() {
    return this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName() ? !0 : ((this.strict || this._uFlag) && this.raise("Invalid escape"), !1);
  }
  consumeBackreference() {
    const e = this.index;
    if (this.eatDecimalEscape()) {
      const r = this._lastIntValue;
      if (r <= this._numCapturingParens)
        return this.onBackreference(e - 1, this.index, r), !0;
      (this.strict || this._uFlag) && this.raise("Invalid escape"), this.rewind(e);
    }
    return !1;
  }
  consumeCharacterClassEscape() {
    const e = this.index;
    if (this.eat(sy))
      return this._lastIntValue = -1, this.onEscapeCharacterSet(e - 1, this.index, "digit", !1), !0;
    if (this.eat(BO))
      return this._lastIntValue = -1, this.onEscapeCharacterSet(e - 1, this.index, "digit", !0), !0;
    if (this.eat(iy))
      return this._lastIntValue = -1, this.onEscapeCharacterSet(e - 1, this.index, "space", !1), !0;
    if (this.eat(LO))
      return this._lastIntValue = -1, this.onEscapeCharacterSet(e - 1, this.index, "space", !0), !0;
    if (this.eat(GO))
      return this._lastIntValue = -1, this.onEscapeCharacterSet(e - 1, this.index, "word", !1), !0;
    if (this.eat(RO))
      return this._lastIntValue = -1, this.onEscapeCharacterSet(e - 1, this.index, "word", !0), !0;
    let r = !1;
    if (this._uFlag && this.ecmaVersion >= 2018 && (this.eat(UO) || (r = this.eat(OO)))) {
      if (this._lastIntValue = -1, this.eat(As) && this.eatUnicodePropertyValueExpression() && this.eat(Ds))
        return this.onUnicodePropertyCharacterSet(e - 1, this.index, "property", this._lastKeyValue, this._lastValValue || null, r), !0;
      this.raise("Invalid property name");
    }
    return !1;
  }
  consumeCharacterEscape() {
    const e = this.index;
    return this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._uFlag && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape() ? (this.onCharacter(e - 1, this.index, this._lastIntValue), !0) : !1;
  }
  consumeKGroupName() {
    const e = this.index;
    if (this.eat(ay)) {
      if (this.eatGroupName()) {
        const r = this._lastStrValue;
        return this._backreferenceNames.add(r), this.onBackreference(e - 1, this.index, r), !0;
      }
      this.raise("Invalid named reference");
    }
    return !1;
  }
  consumeCharacterClass() {
    const e = this.index;
    if (this.eat(Ss)) {
      const r = this.eat(Oa);
      return this.onCharacterClassEnter(e, r), this.consumeClassRanges(), this.eat(Gn) || this.raise("Unterminated character class"), this.onCharacterClassLeave(e, this.index, r), !0;
    }
    return !1;
  }
  consumeClassRanges() {
    const e = this.strict || this._uFlag;
    for (; ; ) {
      const r = this.index;
      if (!this.consumeClassAtom())
        break;
      const s = this._lastIntValue;
      if (!this.eat(Cs))
        continue;
      if (this.onCharacter(this.index - 1, this.index, Cs), !this.consumeClassAtom())
        break;
      const n = this._lastIntValue;
      if (s === -1 || n === -1) {
        e && this.raise("Invalid character class");
        continue;
      }
      s > n && this.raise("Range out of order in character class"), this.onCharacterClassRange(r, this.index, s, n);
    }
  }
  consumeClassAtom() {
    const e = this.index, r = this.currentCodePoint;
    if (r !== -1 && r !== Ot && r !== Gn)
      return this.advance(), this._lastIntValue = r, this.onCharacter(e, this.index, this._lastIntValue), !0;
    if (this.eat(Ot)) {
      if (this.consumeClassEscape())
        return !0;
      if (!this.strict && this.currentCodePoint === jn)
        return this._lastIntValue = Ot, this.onCharacter(e, this.index, this._lastIntValue), !0;
      (this.strict || this._uFlag) && this.raise("Invalid escape"), this.rewind(e);
    }
    return !1;
  }
  consumeClassEscape() {
    const e = this.index;
    if (this.eat(ny))
      return this._lastIntValue = SO, this.onCharacter(e - 1, this.index, this._lastIntValue), !0;
    if (this._uFlag && this.eat(Cs))
      return this._lastIntValue = Cs, this.onCharacter(e - 1, this.index, this._lastIntValue), !0;
    let r = 0;
    return !this.strict && !this._uFlag && this.currentCodePoint === jn && (La(r = this.nextCodePoint) || r === ji) ? (this.advance(), this.advance(), this._lastIntValue = r % 32, this.onCharacter(e - 1, this.index, this._lastIntValue), !0) : this.consumeCharacterClassEscape() || this.consumeCharacterEscape();
  }
  eatGroupName() {
    if (this.eat(Io)) {
      if (this.eatRegExpIdentifierName() && this.eat(IO))
        return !0;
      this.raise("Invalid capture group name");
    }
    return !1;
  }
  eatRegExpIdentifierName() {
    if (this.eatRegExpIdentifierStart()) {
      for (this._lastStrValue = String.fromCodePoint(this._lastIntValue); this.eatRegExpIdentifierPart(); )
        this._lastStrValue += String.fromCodePoint(this._lastIntValue);
      return !0;
    }
    return !1;
  }
  eatRegExpIdentifierStart() {
    const e = this.index, r = !this._uFlag && this.ecmaVersion >= 2020;
    let s = this.currentCodePoint;
    return this.advance(), s === Ot && this.eatRegExpUnicodeEscapeSequence(r) ? s = this._lastIntValue : r && Lo(s) && Ro(this.currentCodePoint) && (s = No(s, this.currentCodePoint), this.advance()), lL(s) ? (this._lastIntValue = s, !0) : (this.index !== e && this.rewind(e), !1);
  }
  eatRegExpIdentifierPart() {
    const e = this.index, r = !this._uFlag && this.ecmaVersion >= 2020;
    let s = this.currentCodePoint;
    return this.advance(), s === Ot && this.eatRegExpUnicodeEscapeSequence(r) ? s = this._lastIntValue : r && Lo(s) && Ro(this.currentCodePoint) && (s = No(s, this.currentCodePoint), this.advance()), uL(s) ? (this._lastIntValue = s, !0) : (this.index !== e && this.rewind(e), !1);
  }
  eatCControlLetter() {
    const e = this.index;
    if (this.eat(jn)) {
      if (this.eatControlLetter())
        return !0;
      this.rewind(e);
    }
    return !1;
  }
  eatZero() {
    return this.currentCodePoint === nn && !La(this.nextCodePoint) ? (this._lastIntValue = 0, this.advance(), !0) : !1;
  }
  eatControlEscape() {
    return this.eat(Hu) ? (this._lastIntValue = wO, !0) : this.eat(VO) ? (this._lastIntValue = nb, !0) : this.eat(qO) ? (this._lastIntValue = sb, !0) : this.eat(WO) ? (this._lastIntValue = AO, !0) : this.eat(zO) ? (this._lastIntValue = DO, !0) : !1;
  }
  eatControlLetter() {
    const e = this.currentCodePoint;
    return ib(e) ? (this.advance(), this._lastIntValue = e % 32, !0) : !1;
  }
  eatRegExpUnicodeEscapeSequence(e = !1) {
    const r = this.index, s = e || this._uFlag;
    if (this.eat(Bo)) {
      if (s && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || s && this.eatRegExpUnicodeCodePointEscape())
        return !0;
      (this.strict || s) && this.raise("Invalid unicode escape"), this.rewind(r);
    }
    return !1;
  }
  eatRegExpUnicodeSurrogatePairEscape() {
    const e = this.index;
    if (this.eatFixedHexDigits(4)) {
      const r = this._lastIntValue;
      if (Lo(r) && this.eat(Ot) && this.eat(Bo) && this.eatFixedHexDigits(4)) {
        const s = this._lastIntValue;
        if (Ro(s))
          return this._lastIntValue = No(r, s), !0;
      }
      this.rewind(e);
    }
    return !1;
  }
  eatRegExpUnicodeCodePointEscape() {
    const e = this.index;
    return this.eat(As) && this.eatHexDigits() && this.eat(Ds) && sL(this._lastIntValue) ? !0 : (this.rewind(e), !1);
  }
  eatIdentityEscape() {
    const e = this.currentCodePoint;
    return this.isValidIdentityEscape(e) ? (this._lastIntValue = e, this.advance(), !0) : !1;
  }
  isValidIdentityEscape(e) {
    return e === -1 ? !1 : this._uFlag ? uy(e) || e === ya : this.strict ? !ZE(e) : this._nFlag ? !(e === jn || e === ay) : e !== jn;
  }
  eatDecimalEscape() {
    this._lastIntValue = 0;
    let e = this.currentCodePoint;
    if (e >= TO && e <= ti) {
      do
        this._lastIntValue = 10 * this._lastIntValue + (e - nn), this.advance();
      while ((e = this.currentCodePoint) >= nn && e <= ti);
      return !0;
    }
    return !1;
  }
  eatUnicodePropertyValueExpression() {
    const e = this.index;
    if (this.eatUnicodePropertyName() && this.eat(_o) && (this._lastKeyValue = this._lastStrValue, this.eatUnicodePropertyValue())) {
      if (this._lastValValue = this._lastStrValue, ty(this.ecmaVersion, this._lastKeyValue, this._lastValValue))
        return !0;
      this.raise("Invalid property name");
    }
    if (this.rewind(e), this.eatLoneUnicodePropertyNameOrValue()) {
      const r = this._lastStrValue;
      if (ty(this.ecmaVersion, "General_Category", r))
        return this._lastKeyValue = "General_Category", this._lastValValue = r, !0;
      if (CO(this.ecmaVersion, r))
        return this._lastKeyValue = r, this._lastValValue = "", !0;
      this.raise("Invalid property name");
    }
    return !1;
  }
  eatUnicodePropertyName() {
    for (this._lastStrValue = ""; ob(this.currentCodePoint); )
      this._lastStrValue += String.fromCodePoint(this.currentCodePoint), this.advance();
    return this._lastStrValue !== "";
  }
  eatUnicodePropertyValue() {
    for (this._lastStrValue = ""; cL(this.currentCodePoint); )
      this._lastStrValue += String.fromCodePoint(this.currentCodePoint), this.advance();
    return this._lastStrValue !== "";
  }
  eatLoneUnicodePropertyNameOrValue() {
    return this.eatUnicodePropertyValue();
  }
  eatHexEscapeSequence() {
    const e = this.index;
    if (this.eat(HO)) {
      if (this.eatFixedHexDigits(2))
        return !0;
      (this._uFlag || this.strict) && this.raise("Invalid escape"), this.rewind(e);
    }
    return !1;
  }
  eatDecimalDigits() {
    const e = this.index;
    for (this._lastIntValue = 0; La(this.currentCodePoint); )
      this._lastIntValue = 10 * this._lastIntValue + Oo(this.currentCodePoint), this.advance();
    return this.index !== e;
  }
  eatHexDigits() {
    const e = this.index;
    for (this._lastIntValue = 0; oy(this.currentCodePoint); )
      this._lastIntValue = 16 * this._lastIntValue + Oo(this.currentCodePoint), this.advance();
    return this.index !== e;
  }
  eatLegacyOctalEscapeSequence() {
    if (this.eatOctalDigit()) {
      const e = this._lastIntValue;
      if (this.eatOctalDigit()) {
        const r = this._lastIntValue;
        e <= 3 && this.eatOctalDigit() ? this._lastIntValue = e * 64 + r * 8 + this._lastIntValue : this._lastIntValue = e * 8 + r;
      } else
        this._lastIntValue = e;
      return !0;
    }
    return !1;
  }
  eatOctalDigit() {
    const e = this.currentCodePoint;
    return rL(e) ? (this.advance(), this._lastIntValue = e - nn, !0) : (this._lastIntValue = 0, !1);
  }
  eatFixedHexDigits(e) {
    const r = this.index;
    this._lastIntValue = 0;
    for (let s = 0; s < e; ++s) {
      const n = this.currentCodePoint;
      if (!oy(n))
        return this.rewind(r), !1;
      this._lastIntValue = 16 * this._lastIntValue + Oo(n), this.advance();
    }
    return !0;
  }
};
const pL = {}, fL = {}, hL = {};
class mL {
  constructor(e) {
    this._node = pL, this._flags = fL, this._backreferences = [], this._capturingGroups = [], this.source = "", this.strict = !!(e && e.strict), this.ecmaVersion = e && e.ecmaVersion || 2022;
  }
  get pattern() {
    if (this._node.type !== "Pattern")
      throw new Error("UnknownError");
    return this._node;
  }
  get flags() {
    if (this._flags.type !== "Flags")
      throw new Error("UnknownError");
    return this._flags;
  }
  onFlags(e, r, s, n, a, o, l, i, u) {
    this._flags = {
      type: "Flags",
      parent: null,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      global: s,
      ignoreCase: n,
      multiline: a,
      unicode: o,
      sticky: l,
      dotAll: i,
      hasIndices: u
    };
  }
  onPatternEnter(e) {
    this._node = {
      type: "Pattern",
      parent: null,
      start: e,
      end: e,
      raw: "",
      alternatives: []
    }, this._backreferences.length = 0, this._capturingGroups.length = 0;
  }
  onPatternLeave(e, r) {
    this._node.end = r, this._node.raw = this.source.slice(e, r);
    for (const s of this._backreferences) {
      const n = s.ref, a = typeof n == "number" ? this._capturingGroups[n - 1] : this._capturingGroups.find((o) => o.name === n);
      s.resolved = a, a.references.push(s);
    }
  }
  onAlternativeEnter(e) {
    const r = this._node;
    if (r.type !== "Assertion" && r.type !== "CapturingGroup" && r.type !== "Group" && r.type !== "Pattern")
      throw new Error("UnknownError");
    this._node = {
      type: "Alternative",
      parent: r,
      start: e,
      end: e,
      raw: "",
      elements: []
    }, r.alternatives.push(this._node);
  }
  onAlternativeLeave(e, r) {
    const s = this._node;
    if (s.type !== "Alternative")
      throw new Error("UnknownError");
    s.end = r, s.raw = this.source.slice(e, r), this._node = s.parent;
  }
  onGroupEnter(e) {
    const r = this._node;
    if (r.type !== "Alternative")
      throw new Error("UnknownError");
    this._node = {
      type: "Group",
      parent: r,
      start: e,
      end: e,
      raw: "",
      alternatives: []
    }, r.elements.push(this._node);
  }
  onGroupLeave(e, r) {
    const s = this._node;
    if (s.type !== "Group" || s.parent.type !== "Alternative")
      throw new Error("UnknownError");
    s.end = r, s.raw = this.source.slice(e, r), this._node = s.parent;
  }
  onCapturingGroupEnter(e, r) {
    const s = this._node;
    if (s.type !== "Alternative")
      throw new Error("UnknownError");
    this._node = {
      type: "CapturingGroup",
      parent: s,
      start: e,
      end: e,
      raw: "",
      name: r,
      alternatives: [],
      references: []
    }, s.elements.push(this._node), this._capturingGroups.push(this._node);
  }
  onCapturingGroupLeave(e, r) {
    const s = this._node;
    if (s.type !== "CapturingGroup" || s.parent.type !== "Alternative")
      throw new Error("UnknownError");
    s.end = r, s.raw = this.source.slice(e, r), this._node = s.parent;
  }
  onQuantifier(e, r, s, n, a) {
    const o = this._node;
    if (o.type !== "Alternative")
      throw new Error("UnknownError");
    const l = o.elements.pop();
    if (l == null || l.type === "Quantifier" || l.type === "Assertion" && l.kind !== "lookahead")
      throw new Error("UnknownError");
    const i = {
      type: "Quantifier",
      parent: o,
      start: l.start,
      end: r,
      raw: this.source.slice(l.start, r),
      min: s,
      max: n,
      greedy: a,
      element: l
    };
    o.elements.push(i), l.parent = i;
  }
  onLookaroundAssertionEnter(e, r, s) {
    const n = this._node;
    if (n.type !== "Alternative")
      throw new Error("UnknownError");
    const a = this._node = {
      type: "Assertion",
      parent: n,
      start: e,
      end: e,
      raw: "",
      kind: r,
      negate: s,
      alternatives: []
    };
    n.elements.push(a);
  }
  onLookaroundAssertionLeave(e, r) {
    const s = this._node;
    if (s.type !== "Assertion" || s.parent.type !== "Alternative")
      throw new Error("UnknownError");
    s.end = r, s.raw = this.source.slice(e, r), this._node = s.parent;
  }
  onEdgeAssertion(e, r, s) {
    const n = this._node;
    if (n.type !== "Alternative")
      throw new Error("UnknownError");
    n.elements.push({
      type: "Assertion",
      parent: n,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      kind: s
    });
  }
  onWordBoundaryAssertion(e, r, s, n) {
    const a = this._node;
    if (a.type !== "Alternative")
      throw new Error("UnknownError");
    a.elements.push({
      type: "Assertion",
      parent: a,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      kind: s,
      negate: n
    });
  }
  onAnyCharacterSet(e, r, s) {
    const n = this._node;
    if (n.type !== "Alternative")
      throw new Error("UnknownError");
    n.elements.push({
      type: "CharacterSet",
      parent: n,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      kind: s
    });
  }
  onEscapeCharacterSet(e, r, s, n) {
    const a = this._node;
    if (a.type !== "Alternative" && a.type !== "CharacterClass")
      throw new Error("UnknownError");
    a.elements.push({
      type: "CharacterSet",
      parent: a,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      kind: s,
      negate: n
    });
  }
  onUnicodePropertyCharacterSet(e, r, s, n, a, o) {
    const l = this._node;
    if (l.type !== "Alternative" && l.type !== "CharacterClass")
      throw new Error("UnknownError");
    l.elements.push({
      type: "CharacterSet",
      parent: l,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      kind: s,
      key: n,
      value: a,
      negate: o
    });
  }
  onCharacter(e, r, s) {
    const n = this._node;
    if (n.type !== "Alternative" && n.type !== "CharacterClass")
      throw new Error("UnknownError");
    n.elements.push({
      type: "Character",
      parent: n,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      value: s
    });
  }
  onBackreference(e, r, s) {
    const n = this._node;
    if (n.type !== "Alternative")
      throw new Error("UnknownError");
    const a = {
      type: "Backreference",
      parent: n,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      ref: s,
      resolved: hL
    };
    n.elements.push(a), this._backreferences.push(a);
  }
  onCharacterClassEnter(e, r) {
    const s = this._node;
    if (s.type !== "Alternative")
      throw new Error("UnknownError");
    this._node = {
      type: "CharacterClass",
      parent: s,
      start: e,
      end: e,
      raw: "",
      negate: r,
      elements: []
    }, s.elements.push(this._node);
  }
  onCharacterClassLeave(e, r) {
    const s = this._node;
    if (s.type !== "CharacterClass" || s.parent.type !== "Alternative")
      throw new Error("UnknownError");
    s.end = r, s.raw = this.source.slice(e, r), this._node = s.parent;
  }
  onCharacterClassRange(e, r) {
    const s = this._node;
    if (s.type !== "CharacterClass")
      throw new Error("UnknownError");
    const n = s.elements, a = n.pop(), o = n.pop(), l = n.pop();
    if (!l || !a || !o || l.type !== "Character" || a.type !== "Character" || o.type !== "Character" || o.value !== Cs)
      throw new Error("UnknownError");
    const i = {
      type: "CharacterClassRange",
      parent: s,
      start: e,
      end: r,
      raw: this.source.slice(e, r),
      min: l,
      max: a
    };
    l.parent = i, a.parent = i, n.push(i);
  }
}
let lb = class {
  constructor(e) {
    this._state = new mL(e), this._validator = new Ku(this._state);
  }
  parseLiteral(e, r = 0, s = e.length) {
    this._state.source = e, this._validator.validateLiteral(e, r, s);
    const n = this._state.pattern, a = this._state.flags, o = {
      type: "RegExpLiteral",
      parent: null,
      start: r,
      end: s,
      raw: e,
      pattern: n,
      flags: a
    };
    return n.parent = o, a.parent = o, o;
  }
  parseFlags(e, r = 0, s = e.length) {
    return this._state.source = e, this._validator.validateFlags(e, r, s), this._state.flags;
  }
  parsePattern(e, r = 0, s = e.length, n = !1) {
    return this._state.source = e, this._validator.validatePattern(e, r, s, n), this._state.pattern;
  }
};
class dL {
  constructor(e) {
    this._handlers = e;
  }
  visit(e) {
    switch (e.type) {
      case "Alternative":
        this.visitAlternative(e);
        break;
      case "Assertion":
        this.visitAssertion(e);
        break;
      case "Backreference":
        this.visitBackreference(e);
        break;
      case "CapturingGroup":
        this.visitCapturingGroup(e);
        break;
      case "Character":
        this.visitCharacter(e);
        break;
      case "CharacterClass":
        this.visitCharacterClass(e);
        break;
      case "CharacterClassRange":
        this.visitCharacterClassRange(e);
        break;
      case "CharacterSet":
        this.visitCharacterSet(e);
        break;
      case "Flags":
        this.visitFlags(e);
        break;
      case "Group":
        this.visitGroup(e);
        break;
      case "Pattern":
        this.visitPattern(e);
        break;
      case "Quantifier":
        this.visitQuantifier(e);
        break;
      case "RegExpLiteral":
        this.visitRegExpLiteral(e);
        break;
      default:
        throw new Error(`Unknown type: ${e.type}`);
    }
  }
  visitAlternative(e) {
    this._handlers.onAlternativeEnter && this._handlers.onAlternativeEnter(e), e.elements.forEach(this.visit, this), this._handlers.onAlternativeLeave && this._handlers.onAlternativeLeave(e);
  }
  visitAssertion(e) {
    this._handlers.onAssertionEnter && this._handlers.onAssertionEnter(e), (e.kind === "lookahead" || e.kind === "lookbehind") && e.alternatives.forEach(this.visit, this), this._handlers.onAssertionLeave && this._handlers.onAssertionLeave(e);
  }
  visitBackreference(e) {
    this._handlers.onBackreferenceEnter && this._handlers.onBackreferenceEnter(e), this._handlers.onBackreferenceLeave && this._handlers.onBackreferenceLeave(e);
  }
  visitCapturingGroup(e) {
    this._handlers.onCapturingGroupEnter && this._handlers.onCapturingGroupEnter(e), e.alternatives.forEach(this.visit, this), this._handlers.onCapturingGroupLeave && this._handlers.onCapturingGroupLeave(e);
  }
  visitCharacter(e) {
    this._handlers.onCharacterEnter && this._handlers.onCharacterEnter(e), this._handlers.onCharacterLeave && this._handlers.onCharacterLeave(e);
  }
  visitCharacterClass(e) {
    this._handlers.onCharacterClassEnter && this._handlers.onCharacterClassEnter(e), e.elements.forEach(this.visit, this), this._handlers.onCharacterClassLeave && this._handlers.onCharacterClassLeave(e);
  }
  visitCharacterClassRange(e) {
    this._handlers.onCharacterClassRangeEnter && this._handlers.onCharacterClassRangeEnter(e), this.visitCharacter(e.min), this.visitCharacter(e.max), this._handlers.onCharacterClassRangeLeave && this._handlers.onCharacterClassRangeLeave(e);
  }
  visitCharacterSet(e) {
    this._handlers.onCharacterSetEnter && this._handlers.onCharacterSetEnter(e), this._handlers.onCharacterSetLeave && this._handlers.onCharacterSetLeave(e);
  }
  visitFlags(e) {
    this._handlers.onFlagsEnter && this._handlers.onFlagsEnter(e), this._handlers.onFlagsLeave && this._handlers.onFlagsLeave(e);
  }
  visitGroup(e) {
    this._handlers.onGroupEnter && this._handlers.onGroupEnter(e), e.alternatives.forEach(this.visit, this), this._handlers.onGroupLeave && this._handlers.onGroupLeave(e);
  }
  visitPattern(e) {
    this._handlers.onPatternEnter && this._handlers.onPatternEnter(e), e.alternatives.forEach(this.visit, this), this._handlers.onPatternLeave && this._handlers.onPatternLeave(e);
  }
  visitQuantifier(e) {
    this._handlers.onQuantifierEnter && this._handlers.onQuantifierEnter(e), this.visit(e.element), this._handlers.onQuantifierLeave && this._handlers.onQuantifierLeave(e);
  }
  visitRegExpLiteral(e) {
    this._handlers.onRegExpLiteralEnter && this._handlers.onRegExpLiteralEnter(e), this.visitPattern(e.pattern), this.visitFlags(e.flags), this._handlers.onRegExpLiteralLeave && this._handlers.onRegExpLiteralLeave(e);
  }
}
function gL(t, e) {
  return new lb(e).parseLiteral(String(t));
}
function yL(t, e) {
  return new Ku(e).validateLiteral(t);
}
function xL(t, e) {
  new dL(e).visit(t);
}
cn.AST = mO;
cn.RegExpParser = lb;
cn.RegExpValidator = Ku;
cn.parseRegExpLiteral = gL;
cn.validateRegExpLiteral = yL;
cn.visitRegExpAST = xL;
function cy(t) {
  return Array.isArray(t) ? t : [t];
}
const vL = /^\s+$/, EL = /^\\!/, bL = /^\\#/, jo = "/", py = typeof Symbol < "u" ? Symbol.for("node-ignore") : "node-ignore", CL = (t, e, r) => Object.defineProperty(t, e, { value: r }), SL = /([0-z])-([0-z])/g, AL = (t) => t.replace(
  SL,
  (e, r, s) => r.charCodeAt(0) <= s.charCodeAt(0) ? e : ""
), ub = [
  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    (t) => t.indexOf("\\") === 0 ? " " : ""
  ],
  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => " "
  ],
  // Escape metacharacters
  // which is written down by users but means special for regular expressions.
  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\^$.|*+(){]/g,
    (t) => `\\${t}`
  ],
  [
    // > [abc] matches any character inside the brackets
    // >    (in this case a, b, or c);
    /\[([^\]/]*)($|\])/g,
    (t, e, r) => r === "]" ? `[${AL(e)}]` : `\\${t}`
  ],
  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => "[^/]"
  ],
  // leading slash
  [
    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => "^"
  ],
  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => "\\/"
  ],
  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,
    // '**/foo' <-> 'foo'
    () => "^(?:.*\\/)?"
  ]
], cb = [
  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function() {
      return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
    }
  ],
  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,
    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer
    // Check if it is not the last `'/**'`
    (t, e, r) => e + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
  ],
  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'
    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,
    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (t, e) => `${e}[^\\/]*`
  ],
  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (t, e) => `${e ? `${e}[^/]+` : "[^/]*"}(?=$|\\/$)`
  ],
  [
    // unescape
    /\\\\\\/g,
    () => "\\"
  ]
], DL = [
  ...ub,
  // 'f'
  // matches
  // - /f(end)
  // - /f/
  // - (start)f(end)
  // - (start)f/
  // doesn't match
  // - oof
  // - foo
  // pseudo:
  // -> (^|/)f(/|$)
  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*/])$/,
    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    (t) => `${t}(?=$|\\/)`
  ],
  ...cb
], wL = [
  ...ub,
  // #24, #38
  // The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)
  // A negative pattern without a trailing wildcard should not
  // re-include the things inside that directory.
  // eg:
  // ['node_modules/*', '!node_modules']
  // should ignore `node_modules/a.js`
  [
    /(?:[^*])$/,
    (t) => `${t}(?=$|\\/$)`
  ],
  ...cb
], fy = /* @__PURE__ */ Object.create(null), kL = (t, e, r) => {
  const s = fy[t];
  if (s)
    return s;
  const a = (e ? wL : DL).reduce(
    (o, l) => o.replace(l[0], l[1].bind(t)),
    t
  );
  return fy[t] = r ? new RegExp(a, "i") : new RegExp(a);
}, TL = (t) => t && typeof t == "string" && !vL.test(t) && t.indexOf("#") !== 0, FL = (t, e) => {
  const r = t;
  let s = !1;
  t.indexOf("!") === 0 && (s = !0, t = t.substr(1)), t = t.replace(EL, "!").replace(bL, "#");
  const n = kL(t, s, e);
  return {
    origin: r,
    pattern: t,
    negative: s,
    regex: n
  };
};
class Fl {
  constructor({
    ignorecase: e = !0
  } = {}) {
    this._rules = [], this._ignorecase = e, CL(this, py, !0), this._initCache();
  }
  _initCache() {
    this._cache = /* @__PURE__ */ Object.create(null);
  }
  // @param {Array.<string>|string|Ignore} pattern
  add(e) {
    return this._added = !1, typeof e == "string" && (e = e.split(/\r?\n/g)), cy(e).forEach(this._addPattern, this), this._added && this._initCache(), this;
  }
  // legacy
  addPattern(e) {
    return this.add(e);
  }
  _addPattern(e) {
    if (e && e[py]) {
      this._rules = this._rules.concat(e._rules), this._added = !0;
      return;
    }
    if (TL(e)) {
      const r = FL(e, this._ignorecase);
      this._added = !0, this._rules.push(r);
    }
  }
  filter(e) {
    return cy(e).filter((r) => this._filter(r));
  }
  createFilter() {
    return (e) => this._filter(e);
  }
  ignores(e) {
    return !this._filter(e);
  }
  // @returns `Boolean` true if the `path` is NOT ignored
  _filter(e, r) {
    return e ? e in this._cache ? this._cache[e] : (r || (r = e.split(jo)), r.pop(), this._cache[e] = r.length ? this._filter(r.join(jo) + jo, r) && this._test(e) : this._test(e)) : !1;
  }
  // @returns {Boolean} true if a file is NOT ignored
  _test(e) {
    let r = 0;
    return this._rules.forEach((s) => {
      r ^ s.negative || (r = s.negative ^ s.regex.test(e));
    }), !r;
  }
}
if (
  // Detect `process` so that it can run in browsers.
  typeof Ze < "u" && (Ze.env && Ze.env.IGNORE_TEST_WIN32 || Ze.platform === "win32")
) {
  const t = Fl.prototype._filter, e = (r) => /^\\\\\?\\/.test(r) || /[^\x00-\x80]+/.test(r) ? r : r.replace(/\\/g, "/");
  Fl.prototype._filter = function(s, n) {
    return s = e(s), t.call(this, s, n);
  };
}
var PL = (t) => new Fl(t), pb = { exports: {} };
/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */
var hy = function(t, e) {
  var r, s, n = 1, a = 0, o = 0, l = String.alphabet;
  function i(u, c, f) {
    if (f) {
      for (r = c; f = i(u, r), f < 76 && f > 65; )
        ++r;
      return +u.slice(c - 1, r);
    }
    return f = l && l.indexOf(u.charAt(c)), f > -1 ? f + 76 : (f = u.charCodeAt(c) || 0, f < 45 || f > 127 ? f : f < 46 ? 65 : f < 48 ? f - 1 : f < 58 ? f + 18 : f < 65 ? f - 11 : f < 91 ? f + 11 : f < 97 ? f - 37 : f < 123 ? f + 5 : f - 63);
  }
  if ((t += "") != (e += "")) {
    for (; n; )
      if (s = i(t, a++), n = i(e, o++), s < 76 && n < 76 && s > 66 && n > 66 && (s = i(t, a, a), n = i(e, o, a = r), o = r), s != n)
        return s < n ? -1 : 1;
  }
  return 0;
};
try {
  pb.exports = hy;
} catch {
  String.naturalCompare = hy;
}
var fb = {}, ws = {}, Kn = {}, IL = "doctrine", _L = "JSDoc parser", BL = "https://github.com/eslint/doctrine", OL = "lib/doctrine.js", LL = "3.0.0", RL = {
  node: ">=6.0.0"
}, NL = {
  lib: "./lib"
}, jL = [
  "lib"
], ML = [
  {
    name: "Nicholas C. Zakas",
    email: "nicholas+npm@nczconsulting.com",
    web: "https://www.nczonline.net"
  },
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "https://github.com/Constellation"
  }
], $L = "eslint/doctrine", VL = {
  coveralls: "^3.0.1",
  dateformat: "^1.0.11",
  eslint: "^1.10.3",
  "eslint-release": "^1.0.0",
  linefix: "^0.1.1",
  mocha: "^3.4.2",
  "npm-license": "^0.3.1",
  nyc: "^10.3.2",
  semver: "^5.0.3",
  shelljs: "^0.5.3",
  "shelljs-nodecli": "^0.1.1",
  should: "^5.0.1"
}, UL = "Apache-2.0", qL = {
  pretest: "npm run lint",
  test: "nyc mocha",
  coveralls: "nyc report --reporter=text-lcov | coveralls",
  lint: "eslint lib/",
  "generate-release": "eslint-generate-release",
  "generate-alpharelease": "eslint-generate-prerelease alpha",
  "generate-betarelease": "eslint-generate-prerelease beta",
  "generate-rcrelease": "eslint-generate-prerelease rc",
  "publish-release": "eslint-publish-release"
}, WL = {
  esutils: "^2.0.2"
}, zL = {
  name: IL,
  description: _L,
  homepage: BL,
  main: OL,
  version: LL,
  engines: RL,
  directories: NL,
  files: jL,
  maintainers: ML,
  repository: $L,
  devDependencies: VL,
  license: UL,
  scripts: qL,
  dependencies: WL
};
(function() {
  var t;
  t = zL.version, Kn.VERSION = t;
  function e(s) {
    this.name = "DoctrineError", this.message = s;
  }
  e.prototype = function() {
    var s = function() {
    };
    return s.prototype = Error.prototype, new s();
  }(), e.prototype.constructor = e, Kn.DoctrineError = e;
  function r(s) {
    throw new e(s);
  }
  Kn.throwError = r, Kn.assert = os;
})();
(function() {
  var t, e, r, s, n, a, o, l, i, u, c, f;
  i = ts, u = Kn, t = {
    NullableLiteral: "NullableLiteral",
    AllLiteral: "AllLiteral",
    NullLiteral: "NullLiteral",
    UndefinedLiteral: "UndefinedLiteral",
    VoidLiteral: "VoidLiteral",
    UnionType: "UnionType",
    ArrayType: "ArrayType",
    RecordType: "RecordType",
    FieldType: "FieldType",
    FunctionType: "FunctionType",
    ParameterType: "ParameterType",
    RestType: "RestType",
    NonNullableType: "NonNullableType",
    OptionalType: "OptionalType",
    NullableType: "NullableType",
    NameExpression: "NameExpression",
    TypeApplication: "TypeApplication",
    StringLiteralType: "StringLiteralType",
    NumericLiteralType: "NumericLiteralType",
    BooleanLiteralType: "BooleanLiteralType"
  }, e = {
    ILLEGAL: 0,
    // ILLEGAL
    DOT_LT: 1,
    // .<
    REST: 2,
    // ...
    LT: 3,
    // <
    GT: 4,
    // >
    LPAREN: 5,
    // (
    RPAREN: 6,
    // )
    LBRACE: 7,
    // {
    RBRACE: 8,
    // }
    LBRACK: 9,
    // [
    RBRACK: 10,
    // ]
    COMMA: 11,
    // ,
    COLON: 12,
    // :
    STAR: 13,
    // *
    PIPE: 14,
    // |
    QUESTION: 15,
    // ?
    BANG: 16,
    // !
    EQUAL: 17,
    // =
    NAME: 18,
    // name token
    STRING: 19,
    // string
    NUMBER: 20,
    // number
    EOF: 21
  };
  function h(H) {
    return "><(){}[],:*|?!=".indexOf(String.fromCharCode(H)) === -1 && !i.code.isWhiteSpace(H) && !i.code.isLineTerminator(H);
  }
  function p(H, Q, ge, ae) {
    this._previous = H, this._index = Q, this._token = ge, this._value = ae;
  }
  p.prototype.restore = function() {
    a = this._previous, n = this._index, o = this._token, l = this._value;
  }, p.save = function() {
    return new p(a, n, o, l);
  };
  function m(H, Q) {
    return f && (H.range = [Q[0] + c, Q[1] + c]), H;
  }
  function d() {
    var H = r.charAt(n);
    return n += 1, H;
  }
  function g(H) {
    var Q, ge, ae, ee = 0;
    for (ge = H === "u" ? 4 : 2, Q = 0; Q < ge; ++Q)
      if (n < s && i.code.isHexDigit(r.charCodeAt(n)))
        ae = d(), ee = ee * 16 + "0123456789abcdef".indexOf(ae.toLowerCase());
      else
        return "";
    return String.fromCharCode(ee);
  }
  function y() {
    var H = "", Q, ge, ae, ee, he;
    for (Q = r.charAt(n), ++n; n < s; )
      if (ge = d(), ge === Q) {
        Q = "";
        break;
      } else if (ge === "\\")
        if (ge = d(), i.code.isLineTerminator(ge.charCodeAt(0)))
          ge === "\r" && r.charCodeAt(n) === 10 && ++n;
        else
          switch (ge) {
            case "n":
              H += `
`;
              break;
            case "r":
              H += "\r";
              break;
            case "t":
              H += "	";
              break;
            case "u":
            case "x":
              he = n, ee = g(ge), ee ? H += ee : (n = he, H += ge);
              break;
            case "b":
              H += "\b";
              break;
            case "f":
              H += "\f";
              break;
            case "v":
              H += "\v";
              break;
            default:
              i.code.isOctalDigit(ge.charCodeAt(0)) ? (ae = "01234567".indexOf(ge), n < s && i.code.isOctalDigit(r.charCodeAt(n)) && (ae = ae * 8 + "01234567".indexOf(d()), "0123".indexOf(ge) >= 0 && n < s && i.code.isOctalDigit(r.charCodeAt(n)) && (ae = ae * 8 + "01234567".indexOf(d()))), H += String.fromCharCode(ae)) : H += ge;
              break;
          }
      else {
        if (i.code.isLineTerminator(ge.charCodeAt(0)))
          break;
        H += ge;
      }
    return Q !== "" && u.throwError("unexpected quote"), l = H, e.STRING;
  }
  function x() {
    var H, Q;
    if (H = "", Q = r.charCodeAt(n), Q !== 46) {
      if (H = d(), Q = r.charCodeAt(n), H === "0") {
        if (Q === 120 || Q === 88) {
          for (H += d(); n < s && (Q = r.charCodeAt(n), !!i.code.isHexDigit(Q)); )
            H += d();
          return H.length <= 2 && u.throwError("unexpected token"), n < s && (Q = r.charCodeAt(n), i.code.isIdentifierStartES5(Q) && u.throwError("unexpected token")), l = parseInt(H, 16), e.NUMBER;
        }
        if (i.code.isOctalDigit(Q)) {
          for (H += d(); n < s && (Q = r.charCodeAt(n), !!i.code.isOctalDigit(Q)); )
            H += d();
          return n < s && (Q = r.charCodeAt(n), (i.code.isIdentifierStartES5(Q) || i.code.isDecimalDigit(Q)) && u.throwError("unexpected token")), l = parseInt(H, 8), e.NUMBER;
        }
        i.code.isDecimalDigit(Q) && u.throwError("unexpected token");
      }
      for (; n < s && (Q = r.charCodeAt(n), !!i.code.isDecimalDigit(Q)); )
        H += d();
    }
    if (Q === 46)
      for (H += d(); n < s && (Q = r.charCodeAt(n), !!i.code.isDecimalDigit(Q)); )
        H += d();
    if (Q === 101 || Q === 69)
      if (H += d(), Q = r.charCodeAt(n), (Q === 43 || Q === 45) && (H += d()), Q = r.charCodeAt(n), i.code.isDecimalDigit(Q))
        for (H += d(); n < s && (Q = r.charCodeAt(n), !!i.code.isDecimalDigit(Q)); )
          H += d();
      else
        u.throwError("unexpected token");
    return n < s && (Q = r.charCodeAt(n), i.code.isIdentifierStartES5(Q) && u.throwError("unexpected token")), l = parseFloat(H), e.NUMBER;
  }
  function A() {
    var H, Q;
    for (l = d(); n < s && h(r.charCodeAt(n)); ) {
      if (H = r.charCodeAt(n), H === 46) {
        if (n + 1 >= s)
          return e.ILLEGAL;
        if (Q = r.charCodeAt(n + 1), Q === 60)
          break;
      }
      l += d();
    }
    return e.NAME;
  }
  function b() {
    var H;
    for (a = n; n < s && i.code.isWhiteSpace(r.charCodeAt(n)); )
      d();
    if (n >= s)
      return o = e.EOF, o;
    switch (H = r.charCodeAt(n), H) {
      case 39:
      case 34:
        return o = y(), o;
      case 58:
        return d(), o = e.COLON, o;
      case 44:
        return d(), o = e.COMMA, o;
      case 40:
        return d(), o = e.LPAREN, o;
      case 41:
        return d(), o = e.RPAREN, o;
      case 91:
        return d(), o = e.LBRACK, o;
      case 93:
        return d(), o = e.RBRACK, o;
      case 123:
        return d(), o = e.LBRACE, o;
      case 125:
        return d(), o = e.RBRACE, o;
      case 46:
        if (n + 1 < s) {
          if (H = r.charCodeAt(n + 1), H === 60)
            return d(), d(), o = e.DOT_LT, o;
          if (H === 46 && n + 2 < s && r.charCodeAt(n + 2) === 46)
            return d(), d(), d(), o = e.REST, o;
          if (i.code.isDecimalDigit(H))
            return o = x(), o;
        }
        return o = e.ILLEGAL, o;
      case 60:
        return d(), o = e.LT, o;
      case 62:
        return d(), o = e.GT, o;
      case 42:
        return d(), o = e.STAR, o;
      case 124:
        return d(), o = e.PIPE, o;
      case 63:
        return d(), o = e.QUESTION, o;
      case 33:
        return d(), o = e.BANG, o;
      case 61:
        return d(), o = e.EQUAL, o;
      case 45:
        return o = x(), o;
      default:
        return i.code.isDecimalDigit(H) ? (o = x(), o) : (u.assert(h(H)), o = A(), o);
    }
  }
  function v(H, Q) {
    u.assert(o === H, Q || "consumed token not matched"), b();
  }
  function C(H, Q) {
    o !== H && u.throwError(Q || "unexpected token"), b();
  }
  function T() {
    var H, Q = n - 1;
    if (v(e.LPAREN, "UnionType should start with ("), H = [], o !== e.RPAREN)
      for (; H.push(te()), o !== e.RPAREN; )
        C(e.PIPE);
    return v(e.RPAREN, "UnionType should end with )"), m({
      type: t.UnionType,
      elements: H
    }, [Q, a]);
  }
  function w() {
    var H, Q = n - 1, ge;
    for (v(e.LBRACK, "ArrayType should start with ["), H = []; o !== e.RBRACK; ) {
      if (o === e.REST) {
        ge = n - 3, v(e.REST), H.push(m({
          type: t.RestType,
          expression: te()
        }, [ge, a]));
        break;
      } else
        H.push(te());
      o !== e.RBRACK && C(e.COMMA);
    }
    return C(e.RBRACK), m({
      type: t.ArrayType,
      elements: H
    }, [Q, a]);
  }
  function B() {
    var H = l;
    if (o === e.NAME || o === e.STRING)
      return b(), H;
    if (o === e.NUMBER)
      return v(e.NUMBER), String(H);
    u.throwError("unexpected token");
  }
  function I() {
    var H, Q = a;
    return H = B(), o === e.COLON ? (v(e.COLON), m({
      type: t.FieldType,
      key: H,
      value: te()
    }, [Q, a])) : m({
      type: t.FieldType,
      key: H,
      value: null
    }, [Q, a]);
  }
  function _() {
    var H, Q = n - 1, ge;
    if (v(e.LBRACE, "RecordType should start with {"), H = [], o === e.COMMA)
      v(e.COMMA);
    else
      for (; o !== e.RBRACE; )
        H.push(I()), o !== e.RBRACE && C(e.COMMA);
    return ge = n, C(e.RBRACE), m({
      type: t.RecordType,
      fields: H
    }, [Q, ge]);
  }
  function S() {
    var H = l, Q = n - H.length;
    return C(e.NAME), o === e.COLON && (H === "module" || H === "external" || H === "event") && (v(e.COLON), H += ":" + l, C(e.NAME)), m({
      type: t.NameExpression,
      name: H
    }, [Q, a]);
  }
  function F() {
    var H = [];
    for (H.push(se()); o === e.COMMA; )
      v(e.COMMA), H.push(se());
    return H;
  }
  function N() {
    var H, Q, ge = n - l.length;
    return H = S(), o === e.DOT_LT || o === e.LT ? (b(), Q = F(), C(e.GT), m({
      type: t.TypeApplication,
      expression: H,
      applications: Q
    }, [ge, a])) : H;
  }
  function k() {
    return v(e.COLON, "ResultType should start with :"), o === e.NAME && l === "void" ? (v(e.NAME), {
      type: t.VoidLiteral
    }) : te();
  }
  function j() {
    for (var H = [], Q = !1, ge, ae = !1, ee, he = n - 3, R; o !== e.RPAREN; )
      o === e.REST && (v(e.REST), ae = !0), ee = a, ge = te(), ge.type === t.NameExpression && o === e.COLON && (R = a - ge.name.length, v(e.COLON), ge = m({
        type: t.ParameterType,
        name: ge.name,
        expression: te()
      }, [R, a])), o === e.EQUAL ? (v(e.EQUAL), ge = m({
        type: t.OptionalType,
        expression: ge
      }, [ee, a]), Q = !0) : Q && u.throwError("unexpected token"), ae && (ge = m({
        type: t.RestType,
        expression: ge
      }, [he, a])), H.push(ge), o !== e.RPAREN && C(e.COMMA);
    return H;
  }
  function O() {
    var H, Q, ge, ae, ee, he = n - l.length;
    return u.assert(o === e.NAME && l === "function", "FunctionType should start with 'function'"), v(e.NAME), C(e.LPAREN), H = !1, ge = [], Q = null, o !== e.RPAREN && (o === e.NAME && (l === "this" || l === "new") ? (H = l === "new", v(e.NAME), C(e.COLON), Q = N(), o === e.COMMA && (v(e.COMMA), ge = j())) : ge = j()), C(e.RPAREN), ae = null, o === e.COLON && (ae = k()), ee = m({
      type: t.FunctionType,
      params: ge,
      result: ae
    }, [he, a]), Q && (ee.this = Q, H && (ee.new = !0)), ee;
  }
  function z() {
    var H, Q;
    switch (o) {
      case e.STAR:
        return v(e.STAR), m({
          type: t.AllLiteral
        }, [a - 1, a]);
      case e.LPAREN:
        return T();
      case e.LBRACK:
        return w();
      case e.LBRACE:
        return _();
      case e.NAME:
        if (Q = n - l.length, l === "null")
          return v(e.NAME), m({
            type: t.NullLiteral
          }, [Q, a]);
        if (l === "undefined")
          return v(e.NAME), m({
            type: t.UndefinedLiteral
          }, [Q, a]);
        if (l === "true" || l === "false")
          return v(e.NAME), m({
            type: t.BooleanLiteralType,
            value: l === "true"
          }, [Q, a]);
        if (H = p.save(), l === "function")
          try {
            return O();
          } catch {
            H.restore();
          }
        return N();
      case e.STRING:
        return b(), m({
          type: t.StringLiteralType,
          value: l
        }, [a - l.length - 2, a]);
      case e.NUMBER:
        return b(), m({
          type: t.NumericLiteralType,
          value: l
        }, [a - String(l).length, a]);
      default:
        u.throwError("unexpected token");
    }
  }
  function te() {
    var H, Q;
    return o === e.QUESTION ? (Q = n - 1, v(e.QUESTION), o === e.COMMA || o === e.EQUAL || o === e.RBRACE || o === e.RPAREN || o === e.PIPE || o === e.EOF || o === e.RBRACK || o === e.GT ? m({
      type: t.NullableLiteral
    }, [Q, a]) : m({
      type: t.NullableType,
      expression: z(),
      prefix: !0
    }, [Q, a])) : o === e.BANG ? (Q = n - 1, v(e.BANG), m({
      type: t.NonNullableType,
      expression: z(),
      prefix: !0
    }, [Q, a])) : (Q = a, H = z(), o === e.BANG ? (v(e.BANG), m({
      type: t.NonNullableType,
      expression: H,
      prefix: !1
    }, [Q, a])) : o === e.QUESTION ? (v(e.QUESTION), m({
      type: t.NullableType,
      expression: H,
      prefix: !1
    }, [Q, a])) : o === e.LBRACK ? (v(e.LBRACK), C(e.RBRACK, "expected an array-style type declaration (" + l + "[])"), m({
      type: t.TypeApplication,
      expression: m({
        type: t.NameExpression,
        name: "Array"
      }, [Q, a]),
      applications: [H]
    }, [Q, a])) : H);
  }
  function se() {
    var H, Q;
    if (H = te(), o !== e.PIPE)
      return H;
    for (Q = [H], v(e.PIPE); Q.push(te()), o === e.PIPE; )
      v(e.PIPE);
    return m({
      type: t.UnionType,
      elements: Q
    }, [0, n]);
  }
  function ye() {
    var H;
    return o === e.REST ? (v(e.REST), m({
      type: t.RestType,
      expression: se()
    }, [0, n])) : (H = se(), o === e.EQUAL ? (v(e.EQUAL), m({
      type: t.OptionalType,
      expression: H
    }, [0, n])) : H);
  }
  function Se(H, Q) {
    var ge;
    return r = H, s = r.length, n = 0, a = 0, f = Q && Q.range, c = Q && Q.startIndex || 0, b(), ge = se(), Q && Q.midstream ? {
      expression: ge,
      index: a
    } : (o !== e.EOF && u.throwError("not reach to EOF"), ge);
  }
  function xe(H, Q) {
    var ge;
    return r = H, s = r.length, n = 0, a = 0, f = Q && Q.range, c = Q && Q.startIndex || 0, b(), ge = ye(), Q && Q.midstream ? {
      expression: ge,
      index: a
    } : (o !== e.EOF && u.throwError("not reach to EOF"), ge);
  }
  function Ae(H, Q, ge) {
    var ae, ee, he;
    switch (H.type) {
      case t.NullableLiteral:
        ae = "?";
        break;
      case t.AllLiteral:
        ae = "*";
        break;
      case t.NullLiteral:
        ae = "null";
        break;
      case t.UndefinedLiteral:
        ae = "undefined";
        break;
      case t.VoidLiteral:
        ae = "void";
        break;
      case t.UnionType:
        for (ge ? ae = "" : ae = "(", ee = 0, he = H.elements.length; ee < he; ++ee)
          ae += Ae(H.elements[ee], Q), ee + 1 !== he && (ae += Q ? "|" : " | ");
        ge || (ae += ")");
        break;
      case t.ArrayType:
        for (ae = "[", ee = 0, he = H.elements.length; ee < he; ++ee)
          ae += Ae(H.elements[ee], Q), ee + 1 !== he && (ae += Q ? "," : ", ");
        ae += "]";
        break;
      case t.RecordType:
        for (ae = "{", ee = 0, he = H.fields.length; ee < he; ++ee)
          ae += Ae(H.fields[ee], Q), ee + 1 !== he && (ae += Q ? "," : ", ");
        ae += "}";
        break;
      case t.FieldType:
        H.value ? ae = H.key + (Q ? ":" : ": ") + Ae(H.value, Q) : ae = H.key;
        break;
      case t.FunctionType:
        for (ae = Q ? "function(" : "function (", H.this && (H.new ? ae += Q ? "new:" : "new: " : ae += Q ? "this:" : "this: ", ae += Ae(H.this, Q), H.params.length !== 0 && (ae += Q ? "," : ", ")), ee = 0, he = H.params.length; ee < he; ++ee)
          ae += Ae(H.params[ee], Q), ee + 1 !== he && (ae += Q ? "," : ", ");
        ae += ")", H.result && (ae += (Q ? ":" : ": ") + Ae(H.result, Q));
        break;
      case t.ParameterType:
        ae = H.name + (Q ? ":" : ": ") + Ae(H.expression, Q);
        break;
      case t.RestType:
        ae = "...", H.expression && (ae += Ae(H.expression, Q));
        break;
      case t.NonNullableType:
        H.prefix ? ae = "!" + Ae(H.expression, Q) : ae = Ae(H.expression, Q) + "!";
        break;
      case t.OptionalType:
        ae = Ae(H.expression, Q) + "=";
        break;
      case t.NullableType:
        H.prefix ? ae = "?" + Ae(H.expression, Q) : ae = Ae(H.expression, Q) + "?";
        break;
      case t.NameExpression:
        ae = H.name;
        break;
      case t.TypeApplication:
        for (ae = Ae(H.expression, Q) + ".<", ee = 0, he = H.applications.length; ee < he; ++ee)
          ae += Ae(H.applications[ee], Q), ee + 1 !== he && (ae += Q ? "," : ", ");
        ae += ">";
        break;
      case t.StringLiteralType:
        ae = '"' + H.value + '"';
        break;
      case t.NumericLiteralType:
        ae = String(H.value);
        break;
      case t.BooleanLiteralType:
        ae = String(H.value);
        break;
      default:
        u.throwError("Unknown type " + H.type);
    }
    return ae;
  }
  function _e(H, Q) {
    return Q == null && (Q = {}), Ae(H, Q.compact, Q.topLevel);
  }
  ws.parseType = Se, ws.parseParamType = xe, ws.stringify = _e, ws.Syntax = t;
})();
(function(t) {
  (function() {
    var e, r, s, n, a;
    n = ts, e = ws, r = Kn;
    function o(C, T, w) {
      return C.slice(T, w);
    }
    a = function() {
      var C = Object.prototype.hasOwnProperty;
      return function(w, B) {
        return C.call(w, B);
      };
    }();
    function l(C) {
      var T = {}, w;
      for (w in C)
        C.hasOwnProperty(w) && (T[w] = C[w]);
      return T;
    }
    function i(C) {
      return C >= 97 && C <= 122 || C >= 65 && C <= 90 || C >= 48 && C <= 57;
    }
    function u(C) {
      return C === "param" || C === "argument" || C === "arg";
    }
    function c(C) {
      return C === "return" || C === "returns";
    }
    function f(C) {
      return C === "property" || C === "prop";
    }
    function h(C) {
      return u(C) || f(C) || C === "alias" || C === "this" || C === "mixes" || C === "requires";
    }
    function p(C) {
      return h(C) || C === "const" || C === "constant";
    }
    function m(C) {
      return f(C) || u(C);
    }
    function d(C) {
      return f(C) || u(C);
    }
    function g(C) {
      return u(C) || c(C) || C === "define" || C === "enum" || C === "implements" || C === "this" || C === "type" || C === "typedef" || f(C);
    }
    function y(C) {
      return g(C) || C === "throws" || C === "const" || C === "constant" || C === "namespace" || C === "member" || C === "var" || C === "module" || C === "constructor" || C === "class" || C === "extends" || C === "augments" || C === "public" || C === "private" || C === "protected";
    }
    var x = "[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]", A = "(" + x + "*(?:\\*" + x + `?)?)(.+|[\r
\u2028\u2029])`;
    function b(C) {
      return C.replace(/^\/\*\*?/, "").replace(/\*\/$/, "").replace(new RegExp(A, "g"), "$2").replace(/\s*$/, "");
    }
    function v(C, T) {
      for (var w = C.replace(/^\/\*\*?/, ""), B = 0, I = new RegExp(A, "g"), _; _ = I.exec(w); )
        if (B += _[1].length, _.index + _[0].length > T + B)
          return T + B + C.length - w.length;
      return C.replace(/\*\/$/, "").replace(/\s*$/, "").length;
    }
    (function(C) {
      var T, w, B, I, _, S, F, N, k;
      function j() {
        var ae = _.charCodeAt(w);
        return w += 1, n.code.isLineTerminator(ae) && !(ae === 13 && _.charCodeAt(w) === 10) && (B += 1), String.fromCharCode(ae);
      }
      function O() {
        var ae = "";
        for (j(); w < I && i(_.charCodeAt(w)); )
          ae += j();
        return ae;
      }
      function z() {
        var ae, ee, he = w;
        for (ee = !1; he < I; ) {
          if (ae = _.charCodeAt(he), n.code.isLineTerminator(ae) && !(ae === 13 && _.charCodeAt(he + 1) === 10))
            ee = !0;
          else if (ee) {
            if (ae === 64)
              break;
            n.code.isWhiteSpace(ae) || (ee = !1);
          }
          he += 1;
        }
        return he;
      }
      function te(ae, ee, he) {
        for (var R, D, U, ne, pe = !1; w < ee; )
          if (R = _.charCodeAt(w), n.code.isWhiteSpace(R))
            j();
          else if (R === 123) {
            j();
            break;
          } else {
            pe = !0;
            break;
          }
        if (pe)
          return null;
        for (D = 1, U = ""; w < ee; )
          if (R = _.charCodeAt(w), n.code.isLineTerminator(R))
            j();
          else {
            if (R === 125) {
              if (D -= 1, D === 0) {
                j();
                break;
              }
            } else
              R === 123 && (D += 1);
            U === "" && (ne = w), U += j();
          }
        return D !== 0 ? r.throwError("Braces are not balanced") : d(ae) ? e.parseParamType(U, { startIndex: Ae(ne), range: he }) : e.parseType(U, { startIndex: Ae(ne), range: he });
      }
      function se(ae) {
        var ee;
        if (!n.code.isIdentifierStartES5(_.charCodeAt(w)) && !_[w].match(/[0-9]/))
          return null;
        for (ee = j(); w < ae && n.code.isIdentifierPartES5(_.charCodeAt(w)); )
          ee += j();
        return ee;
      }
      function ye(ae) {
        for (; w < ae && (n.code.isWhiteSpace(_.charCodeAt(w)) || n.code.isLineTerminator(_.charCodeAt(w))); )
          j();
      }
      function Se(ae, ee, he) {
        var R = "", D, U;
        if (ye(ae), w >= ae)
          return null;
        if (_.charCodeAt(w) === 91)
          if (ee)
            D = !0, R = j();
          else
            return null;
        if (R += se(ae), he)
          for (_.charCodeAt(w) === 58 && (R === "module" || R === "external" || R === "event") && (R += j(), R += se(ae)), _.charCodeAt(w) === 91 && _.charCodeAt(w + 1) === 93 && (R += j(), R += j()); _.charCodeAt(w) === 46 || _.charCodeAt(w) === 47 || _.charCodeAt(w) === 35 || _.charCodeAt(w) === 45 || _.charCodeAt(w) === 126; )
            R += j(), R += se(ae);
        if (D) {
          if (ye(ae), _.charCodeAt(w) === 61) {
            R += j(), ye(ae);
            for (var ne, pe = 1; w < ae; ) {
              if (ne = _.charCodeAt(w), n.code.isWhiteSpace(ne) && (U || (ye(ae), ne = _.charCodeAt(w))), ne === 39 && (U ? U === "'" && (U = "") : U = "'"), ne === 34 && (U ? U === '"' && (U = "") : U = '"'), ne === 91)
                pe++;
              else if (ne === 93 && --pe === 0)
                break;
              R += j();
            }
          }
          if (ye(ae), w >= ae || _.charCodeAt(w) !== 93)
            return null;
          R += j();
        }
        return R;
      }
      function xe() {
        for (; w < I && _.charCodeAt(w) !== 64; )
          j();
        return w >= I ? !1 : (r.assert(
          _.charCodeAt(w) === 64
          /* '@' */
        ), !0);
      }
      function Ae(ae) {
        return _ === S ? ae : v(S, ae);
      }
      function _e(ae, ee) {
        this._options = ae, this._title = ee.toLowerCase(), this._tag = {
          title: ee,
          description: null
        }, this._options.lineNumbers && (this._tag.lineNumber = B), this._first = w - ee.length - 1, this._last = 0, this._extra = {};
      }
      _e.prototype.addError = function(ee) {
        var he = Array.prototype.slice.call(arguments, 1), R = ee.replace(
          /%(\d)/g,
          function(D, U) {
            return r.assert(U < he.length, "Message reference must be in range"), he[U];
          }
        );
        return this._tag.errors || (this._tag.errors = []), k && r.throwError(R), this._tag.errors.push(R), F;
      }, _e.prototype.parseType = function() {
        if (g(this._title))
          try {
            if (this._tag.type = te(this._title, this._last, this._options.range), !this._tag.type && !u(this._title) && !c(this._title) && !this.addError("Missing or invalid tag type"))
              return !1;
          } catch (ae) {
            if (this._tag.type = null, !this.addError(ae.message))
              return !1;
          }
        else if (y(this._title))
          try {
            this._tag.type = te(this._title, this._last, this._options.range);
          } catch {
          }
        return !0;
      }, _e.prototype._parseNamePath = function(ae) {
        var ee;
        return ee = Se(this._last, N && d(this._title), !0), !ee && !ae && !this.addError("Missing or invalid tag name") ? !1 : (this._tag.name = ee, !0);
      }, _e.prototype.parseNamePath = function() {
        return this._parseNamePath(!1);
      }, _e.prototype.parseNamePathOptional = function() {
        return this._parseNamePath(!0);
      }, _e.prototype.parseName = function() {
        var ae, ee;
        if (p(this._title))
          if (this._tag.name = Se(this._last, N && d(this._title), m(this._title)), this._tag.name)
            ee = this._tag.name, ee.charAt(0) === "[" && ee.charAt(ee.length - 1) === "]" && (ae = ee.substring(1, ee.length - 1).split("="), ae.length > 1 && (this._tag.default = ae.slice(1).join("=")), this._tag.name = ae[0], this._tag.type && this._tag.type.type !== "OptionalType" && (this._tag.type = {
              type: "OptionalType",
              expression: this._tag.type
            }));
          else {
            if (!h(this._title))
              return !0;
            if (u(this._title) && this._tag.type && this._tag.type.name)
              this._extra.name = this._tag.type, this._tag.name = this._tag.type.name, this._tag.type = null;
            else if (!this.addError("Missing or invalid tag name"))
              return !1;
          }
        return !0;
      }, _e.prototype.parseDescription = function() {
        var ee = o(_, w, this._last).trim();
        return ee && (/^-\s+/.test(ee) && (ee = ee.substring(2)), this._tag.description = ee), !0;
      }, _e.prototype.parseCaption = function() {
        var ee = o(_, w, this._last).trim(), he = "<caption>", R = "</caption>", D = ee.indexOf(he), U = ee.indexOf(R);
        return D >= 0 && U >= 0 ? (this._tag.caption = ee.substring(
          D + he.length,
          U
        ).trim(), this._tag.description = ee.substring(U + R.length).trim()) : this._tag.description = ee, !0;
      }, _e.prototype.parseKind = function() {
        var ee, he;
        return he = {
          class: !0,
          constant: !0,
          event: !0,
          external: !0,
          file: !0,
          function: !0,
          member: !0,
          mixin: !0,
          module: !0,
          namespace: !0,
          typedef: !0
        }, ee = o(_, w, this._last).trim(), this._tag.kind = ee, !(!a(he, ee) && !this.addError("Invalid kind name '%0'", ee));
      }, _e.prototype.parseAccess = function() {
        var ee;
        return ee = o(_, w, this._last).trim(), this._tag.access = ee, !(ee !== "private" && ee !== "protected" && ee !== "public" && !this.addError("Invalid access name '%0'", ee));
      }, _e.prototype.parseThis = function() {
        var ee = o(_, w, this._last).trim();
        if (ee && ee.charAt(0) === "{") {
          var he = this.parseType();
          return he && this._tag.type.type === "NameExpression" || this._tag.type.type === "UnionType" ? (this._tag.name = this._tag.type.name, !0) : this.addError("Invalid name for this");
        } else
          return this.parseNamePath();
      }, _e.prototype.parseVariation = function() {
        var ee, he;
        return he = o(_, w, this._last).trim(), ee = parseFloat(he, 10), this._tag.variation = ee, !(isNaN(ee) && !this.addError("Invalid variation '%0'", he));
      }, _e.prototype.ensureEnd = function() {
        var ae = o(_, w, this._last).trim();
        return !(ae && !this.addError("Unknown content '%0'", ae));
      }, _e.prototype.epilogue = function() {
        var ee;
        return ee = this._tag.description, !(d(this._title) && !this._tag.type && ee && ee.charAt(0) === "[" && (this._tag.type = this._extra.name, this._tag.name || (this._tag.name = void 0), !N && !this.addError("Missing or invalid tag name")));
      }, T = {
        // http://usejsdoc.org/tags-access.html
        access: ["parseAccess"],
        // http://usejsdoc.org/tags-alias.html
        alias: ["parseNamePath", "ensureEnd"],
        // http://usejsdoc.org/tags-augments.html
        augments: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-constructor.html
        constructor: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // Synonym: http://usejsdoc.org/tags-constructor.html
        class: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // Synonym: http://usejsdoc.org/tags-extends.html
        extends: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-example.html
        example: ["parseCaption"],
        // http://usejsdoc.org/tags-deprecated.html
        deprecated: ["parseDescription"],
        // http://usejsdoc.org/tags-global.html
        global: ["ensureEnd"],
        // http://usejsdoc.org/tags-inner.html
        inner: ["ensureEnd"],
        // http://usejsdoc.org/tags-instance.html
        instance: ["ensureEnd"],
        // http://usejsdoc.org/tags-kind.html
        kind: ["parseKind"],
        // http://usejsdoc.org/tags-mixes.html
        mixes: ["parseNamePath", "ensureEnd"],
        // http://usejsdoc.org/tags-mixin.html
        mixin: ["parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-member.html
        member: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-method.html
        method: ["parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-module.html
        module: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // Synonym: http://usejsdoc.org/tags-method.html
        func: ["parseNamePathOptional", "ensureEnd"],
        // Synonym: http://usejsdoc.org/tags-method.html
        function: ["parseNamePathOptional", "ensureEnd"],
        // Synonym: http://usejsdoc.org/tags-member.html
        var: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-name.html
        name: ["parseNamePath", "ensureEnd"],
        // http://usejsdoc.org/tags-namespace.html
        namespace: ["parseType", "parseNamePathOptional", "ensureEnd"],
        // http://usejsdoc.org/tags-private.html
        private: ["parseType", "parseDescription"],
        // http://usejsdoc.org/tags-protected.html
        protected: ["parseType", "parseDescription"],
        // http://usejsdoc.org/tags-public.html
        public: ["parseType", "parseDescription"],
        // http://usejsdoc.org/tags-readonly.html
        readonly: ["ensureEnd"],
        // http://usejsdoc.org/tags-requires.html
        requires: ["parseNamePath", "ensureEnd"],
        // http://usejsdoc.org/tags-since.html
        since: ["parseDescription"],
        // http://usejsdoc.org/tags-static.html
        static: ["ensureEnd"],
        // http://usejsdoc.org/tags-summary.html
        summary: ["parseDescription"],
        // http://usejsdoc.org/tags-this.html
        this: ["parseThis", "ensureEnd"],
        // http://usejsdoc.org/tags-todo.html
        todo: ["parseDescription"],
        // http://usejsdoc.org/tags-typedef.html
        typedef: ["parseType", "parseNamePathOptional"],
        // http://usejsdoc.org/tags-variation.html
        variation: ["parseVariation"],
        // http://usejsdoc.org/tags-version.html
        version: ["parseDescription"]
      }, _e.prototype.parse = function() {
        var ee, he, R, D;
        if (!this._title && !this.addError("Missing or invalid title"))
          return null;
        for (this._last = z(this._title), this._options.range && (this._tag.range = [this._first, _.slice(0, this._last).replace(/\s*$/, "").length].map(Ae)), a(T, this._title) ? R = T[this._title] : R = ["parseType", "parseName", "parseDescription", "epilogue"], ee = 0, he = R.length; ee < he; ++ee)
          if (D = R[ee], !this[D]())
            return null;
        return this._tag;
      };
      function H(ae) {
        var ee, he, R;
        if (!xe())
          return null;
        for (ee = O(), he = new _e(ae, ee), R = he.parse(); w < he._last; )
          j();
        return R;
      }
      function Q(ae) {
        var ee = "", he, R;
        for (R = !0; w < I && (he = _.charCodeAt(w), !(R && he === 64)); )
          n.code.isLineTerminator(he) ? R = !0 : R && !n.code.isWhiteSpace(he) && (R = !1), ee += j();
        return ae ? ee : ee.trim();
      }
      function ge(ae, ee) {
        var he = [], R, D, U, ne, pe;
        if (ee === void 0 && (ee = {}), typeof ee.unwrap == "boolean" && ee.unwrap ? _ = b(ae) : _ = ae, S = ae, ee.tags)
          if (Array.isArray(ee.tags))
            for (U = {}, ne = 0, pe = ee.tags.length; ne < pe; ne++)
              typeof ee.tags[ne] == "string" ? U[ee.tags[ne]] = !0 : r.throwError('Invalid "tags" parameter: ' + ee.tags);
          else
            r.throwError('Invalid "tags" parameter: ' + ee.tags);
        for (I = _.length, w = 0, B = 0, F = ee.recoverable, N = ee.sloppy, k = ee.strict, D = Q(ee.preserveWhitespace); R = H(ee), !!R; )
          (!U || U.hasOwnProperty(R.title)) && he.push(R);
        return {
          description: D,
          tags: he
        };
      }
      C.parse = ge;
    })(s = {}), t.version = r.VERSION, t.parse = s.parse, t.parseType = e.parseType, t.parseParamType = e.parseParamType, t.unwrapComment = b, t.Syntax = l(e.Syntax), t.Error = r.DoctrineError, t.type = {
      Syntax: t.Syntax,
      parseType: e.parseType,
      parseParamType: e.parseParamType,
      stringify: e.stringify
    };
  })();
})(fb);
var Pl = us, GL = ts, HL = Wr, KL = uO, JL = cO, XL = cn, QL = gu.exports, YL = uE, ZL = PL, eR = pb.exports, tR = fb;
function Pr(t) {
  return t && typeof t == "object" && "default" in t ? t : {
    default: t
  };
}
var Il = Pr(GL), Bs = Pr(HL), Ju = Pr(KL), rR = Pr(JL), pn = Pr(XL), nR = Pr(QL), Vt = Pr(YL), _l = Pr(ZL), my = Pr(eR), sR = Pr(tR), E = Pl.createCommonjsModule(function(t) {
  const {
    breakableTypePattern: e,
    createGlobalLinebreakMatcher: r,
    lineBreakPattern: s,
    shebangPattern: n
  } = Pl.astUtils, a = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u, o = /^[\s*]*@this/mu, l = /* @__PURE__ */ new Set([`\r
`, "\r", `
`, "\u2028", "\u2029"]), i = /* @__PURE__ */ new Set(["Program", "BlockStatement", "SwitchCase"]), u = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u, c = /* @__PURE__ */ new Set(["&&=", "||=", "??="]);
  function f(R, D, U) {
    const ne = R.identifier, pe = D === 0 || U[D - 1].identifier !== ne;
    return ne && R.init === !1 && R.isWrite() && pe;
  }
  function h(R) {
    return R[0] !== R[0].toLocaleLowerCase();
  }
  function p(R) {
    return R.id && h(R.id.name);
  }
  function m(R) {
    for (let D = R; D; D = D.parent)
      if (a.test(D.type))
        return D;
    return null;
  }
  function d(R) {
    return !!(R && a.test(R.type));
  }
  function g(R) {
    return !!(R && /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u.test(R.type));
  }
  function y(R) {
    return R.type === "Literal" && R.value === null && !R.regex && !R.bigint;
  }
  function x(R) {
    return y(R) || R.type === "Identifier" && R.name === "undefined" || R.type === "UnaryExpression" && R.operator === "void";
  }
  function A(R) {
    return R.parent.type === "CallExpression" && R.parent.callee === R;
  }
  function b(R) {
    switch (R.type) {
      case "Literal":
        if (R.value === null) {
          if (y(R))
            return String(R.value);
          if (R.regex)
            return `/${R.regex.pattern}/${R.regex.flags}`;
          if (R.bigint)
            return R.bigint;
        } else
          return String(R.value);
        break;
      case "TemplateLiteral":
        if (R.expressions.length === 0 && R.quasis.length === 1)
          return R.quasis[0].value.cooked;
        break;
    }
    return null;
  }
  function v(R) {
    let D;
    switch (R && R.type) {
      case "ChainExpression":
        return v(R.expression);
      case "Property":
      case "MethodDefinition":
        D = R.key;
        break;
      case "MemberExpression":
        D = R.property;
        break;
    }
    return D ? D.type === "Identifier" && !R.computed ? D.name : b(D) : null;
  }
  function C(R) {
    return R && R.type === "ChainExpression" ? R.expression : R;
  }
  function T(R, D) {
    return typeof D == "string" ? R === D : D.test(R);
  }
  function w(R, D) {
    return R.type === "Identifier" && T(R.name, D);
  }
  function B(R, D, U) {
    const ne = C(R);
    if (ne.type !== "MemberExpression" || D && !w(ne.object, D))
      return !1;
    if (U) {
      const pe = v(ne);
      if (typeof pe != "string" || !T(pe, U))
        return !1;
    }
    return !0;
  }
  function I(R, D) {
    return R.regex || D.regex ? !!(R.regex && D.regex && R.regex.pattern === D.regex.pattern && R.regex.flags === D.regex.flags) : R.bigint || D.bigint ? R.bigint === D.bigint : R.value === D.value;
  }
  function _(R, D, U = !1) {
    if (R.type !== D.type)
      return R.type === "ChainExpression" ? _(R.expression, D, U) : D.type === "ChainExpression" ? _(R, D.expression, U) : !1;
    switch (R.type) {
      case "Super":
      case "ThisExpression":
        return !0;
      case "Identifier":
        return R.name === D.name;
      case "Literal":
        return I(R, D);
      case "ChainExpression":
        return _(R.expression, D.expression, U);
      case "MemberExpression": {
        if (!U) {
          const ne = v(R);
          if (ne !== null)
            return _(R.object, D.object, U) && ne === v(D);
        }
        return R.computed === D.computed && _(R.object, D.object, U) && _(R.property, D.property, U);
      }
      default:
        return !1;
    }
  }
  function S(R) {
    return B(R, "Reflect", "apply");
  }
  function F(R) {
    return B(R, /Array$/u, "from");
  }
  function N(R) {
    return B(R, null, /^(?:every|filter|find|findIndex|forEach|map|some)$/u);
  }
  function k(R) {
    return (D) => !R(D);
  }
  function j(R, D) {
    const U = D.getJSDocComment(R);
    return U && o.test(U.value) ? !0 : D.getCommentsBefore(R).some((ne) => o.test(ne.value));
  }
  function O(R) {
    return R.value === "=>" && R.type === "Punctuator";
  }
  function z(R) {
    return R.value === "," && R.type === "Punctuator";
  }
  function te(R) {
    return R.value === "." && R.type === "Punctuator";
  }
  function se(R) {
    return R.value === "?." && R.type === "Punctuator";
  }
  function ye(R) {
    return R.value === ";" && R.type === "Punctuator";
  }
  function Se(R) {
    return R.value === ":" && R.type === "Punctuator";
  }
  function xe(R) {
    return R.value === "(" && R.type === "Punctuator";
  }
  function Ae(R) {
    return R.value === ")" && R.type === "Punctuator";
  }
  function _e(R) {
    return R.value === "[" && R.type === "Punctuator";
  }
  function H(R) {
    return R.value === "]" && R.type === "Punctuator";
  }
  function Q(R) {
    return R.value === "{" && R.type === "Punctuator";
  }
  function ge(R) {
    return R.value === "}" && R.type === "Punctuator";
  }
  function ae(R, D) {
    return R.id ? D.getTokenAfter(R.id, xe) : D.getFirstToken(R, xe);
  }
  function ee(R) {
    return R.type === "LogicalExpression" && (R.operator === "&&" || R.operator === "||");
  }
  function he(R) {
    return R.type === "LogicalExpression" && R.operator === "??";
  }
  t.exports = {
    COMMENTS_IGNORE_PATTERN: /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u,
    LINEBREAKS: l,
    LINEBREAK_MATCHER: s,
    SHEBANG_MATCHER: n,
    STATEMENT_LIST_PARENTS: i,
    isTokenOnSameLine(R, D) {
      return R.loc.end.line === D.loc.start.line;
    },
    isNullOrUndefined: x,
    isCallee: A,
    isES5Constructor: p,
    getUpperFunction: m,
    isFunction: d,
    isLoop: g,
    isInLoop: function(R) {
      for (let D = R; D && !d(D); D = D.parent)
        if (g(D))
          return !0;
      return !1;
    },
    isArrayFromMethod: F,
    isParenthesised: function(R, D) {
      const U = R.getTokenBefore(D), ne = R.getTokenAfter(D);
      return !!(U && ne) && U.value === "(" && U.range[1] <= D.range[0] && ne.value === ")" && ne.range[0] >= D.range[1];
    },
    createGlobalLinebreakMatcher: r,
    equalTokens: function(R, D, U) {
      const ne = U.getTokens(R), pe = U.getTokens(D);
      if (ne.length !== pe.length)
        return !1;
      for (let Ee = 0; Ee < ne.length; ++Ee)
        if (ne[Ee].type !== pe[Ee].type || ne[Ee].value !== pe[Ee].value)
          return !1;
      return !0;
    },
    isArrowToken: O,
    isClosingBraceToken: ge,
    isClosingBracketToken: H,
    isClosingParenToken: Ae,
    isColonToken: Se,
    isCommaToken: z,
    isCommentToken: function(R) {
      return R.type === "Line" || R.type === "Block" || R.type === "Shebang";
    },
    isDotToken: te,
    isQuestionDotToken: se,
    isKeywordToken: function(R) {
      return R.type === "Keyword";
    },
    isNotClosingBraceToken: k(ge),
    isNotClosingBracketToken: k(H),
    isNotClosingParenToken: k(Ae),
    isNotColonToken: k(Se),
    isNotCommaToken: k(z),
    isNotDotToken: k(te),
    isNotQuestionDotToken: k(se),
    isNotOpeningBraceToken: k(Q),
    isNotOpeningBracketToken: k(_e),
    isNotOpeningParenToken: k(xe),
    isNotSemicolonToken: k(ye),
    isOpeningBraceToken: Q,
    isOpeningBracketToken: _e,
    isOpeningParenToken: xe,
    isSemicolonToken: ye,
    isStringLiteral(R) {
      return R.type === "Literal" && typeof R.value == "string" || R.type === "TemplateLiteral";
    },
    isBreakableStatement(R) {
      return e.test(R.type);
    },
    getModifyingReferences(R) {
      return R.filter(f);
    },
    isSurroundedBy(R, D) {
      return R[0] === D && R[R.length - 1] === D;
    },
    isDirectiveComment(R) {
      const D = R.value.trim();
      return R.type === "Line" && D.indexOf("eslint-") === 0 || R.type === "Block" && (D.indexOf("global ") === 0 || D.indexOf("eslint ") === 0 || D.indexOf("eslint-") === 0);
    },
    getTrailingStatement: Il.default.ast.trailingStatement,
    getVariableByName(R, D) {
      let U = R;
      for (; U; ) {
        const ne = U.set.get(D);
        if (ne)
          return ne;
        U = U.upper;
      }
      return null;
    },
    isDefaultThisBinding(R, D, {
      capIsConstructor: U = !0
    } = {}) {
      if (U && p(R) || j(R, D))
        return !1;
      const ne = R.id === null;
      let pe = R;
      for (; pe; ) {
        const Ee = pe.parent;
        switch (Ee.type) {
          case "LogicalExpression":
          case "ConditionalExpression":
          case "ChainExpression":
            pe = Ee;
            break;
          case "ReturnStatement": {
            const Re = m(Ee);
            if (Re === null || !A(Re))
              return !0;
            pe = Re.parent;
            break;
          }
          case "ArrowFunctionExpression":
            if (pe !== Ee.body || !A(Ee))
              return !0;
            pe = Ee.parent;
            break;
          case "Property":
          case "MethodDefinition":
            return Ee.value !== pe;
          case "AssignmentExpression":
          case "AssignmentPattern":
            return !(Ee.left.type === "MemberExpression" || U && ne && Ee.left.type === "Identifier" && h(Ee.left.name));
          case "VariableDeclarator":
            return !(U && ne && Ee.init === pe && Ee.id.type === "Identifier" && h(Ee.id.name));
          case "MemberExpression":
            if (Ee.object === pe && B(Ee, null, /^(?:bind|call|apply)$/u)) {
              const Re = Ee.parent.type === "ChainExpression" ? Ee.parent : Ee;
              return !(A(Re) && Re.parent.arguments.length >= 1 && !x(Re.parent.arguments[0]));
            }
            return !0;
          case "CallExpression":
            return S(Ee.callee) ? Ee.arguments.length !== 3 || Ee.arguments[0] !== pe || x(Ee.arguments[1]) : F(Ee.callee) ? Ee.arguments.length !== 3 || Ee.arguments[1] !== pe || x(Ee.arguments[2]) : N(Ee.callee) ? Ee.arguments.length !== 2 || Ee.arguments[0] !== pe || x(Ee.arguments[1]) : !0;
          default:
            return !0;
        }
      }
      return !0;
    },
    getPrecedence(R) {
      switch (R.type) {
        case "SequenceExpression":
          return 0;
        case "AssignmentExpression":
        case "ArrowFunctionExpression":
        case "YieldExpression":
          return 1;
        case "ConditionalExpression":
          return 3;
        case "LogicalExpression":
          switch (R.operator) {
            case "||":
            case "??":
              return 4;
            case "&&":
              return 5;
          }
        case "BinaryExpression":
          switch (R.operator) {
            case "|":
              return 6;
            case "^":
              return 7;
            case "&":
              return 8;
            case "==":
            case "!=":
            case "===":
            case "!==":
              return 9;
            case "<":
            case "<=":
            case ">":
            case ">=":
            case "in":
            case "instanceof":
              return 10;
            case "<<":
            case ">>":
            case ">>>":
              return 11;
            case "+":
            case "-":
              return 12;
            case "*":
            case "/":
            case "%":
              return 13;
            case "**":
              return 15;
          }
        case "UnaryExpression":
        case "AwaitExpression":
          return 16;
        case "UpdateExpression":
          return 17;
        case "CallExpression":
        case "ChainExpression":
        case "ImportExpression":
          return 18;
        case "NewExpression":
          return 19;
        default:
          return 20;
      }
    },
    isEmptyBlock(R) {
      return !!(R && R.type === "BlockStatement" && R.body.length === 0);
    },
    isEmptyFunction(R) {
      return d(R) && t.exports.isEmptyBlock(R.body);
    },
    getDirectivePrologue(R) {
      const D = [];
      if (R.type === "Program" || R.type === "FunctionDeclaration" || R.type === "FunctionExpression" || R.type === "ArrowFunctionExpression" && R.body.type === "BlockStatement") {
        const U = R.type === "Program" ? R.body : R.body.body;
        for (const ne of U)
          if (ne.type === "ExpressionStatement" && ne.expression.type === "Literal")
            D.push(ne);
          else
            break;
      }
      return D;
    },
    isDecimalInteger(R) {
      return R.type === "Literal" && typeof R.value == "number" && u.test(R.raw);
    },
    isDecimalIntegerNumericToken(R) {
      return R.type === "Numeric" && u.test(R.value);
    },
    getFunctionNameWithKind(R) {
      const D = R.parent, U = [];
      if (D.type === "MethodDefinition" && D.static && U.push("static"), R.async && U.push("async"), R.generator && U.push("generator"), R.type === "ArrowFunctionExpression")
        U.push("arrow", "function");
      else if (D.type === "Property" || D.type === "MethodDefinition") {
        if (D.kind === "constructor")
          return "constructor";
        D.kind === "get" ? U.push("getter") : D.kind === "set" ? U.push("setter") : U.push("method");
      } else
        U.push("function");
      if (R.id)
        U.push(`'${R.id.name}'`);
      else {
        const ne = v(D);
        ne !== null && U.push(`'${ne}'`);
      }
      return U.join(" ");
    },
    getFunctionHeadLoc(R, D) {
      const U = R.parent;
      let ne = null, pe = null;
      if (R.type === "ArrowFunctionExpression") {
        const Ee = D.getTokenBefore(R.body, O);
        ne = Ee.loc.start, pe = Ee.loc.end;
      } else
        U.type === "Property" || U.type === "MethodDefinition" ? (ne = U.loc.start, pe = ae(R, D).loc.start) : (ne = R.loc.start, pe = ae(R, D).loc.start);
      return {
        start: Object.assign({}, ne),
        end: Object.assign({}, pe)
      };
    },
    getNextLocation(R, {
      line: D,
      column: U
    }) {
      return U < R.lines[D - 1].length ? {
        line: D,
        column: U + 1
      } : D < R.lines.length ? {
        line: D + 1,
        column: 0
      } : null;
    },
    getParenthesisedText(R, D) {
      let U = R.getFirstToken(D), ne = R.getLastToken(D);
      for (; R.getTokenBefore(U) && R.getTokenBefore(U).type === "Punctuator" && R.getTokenBefore(U).value === "(" && R.getTokenAfter(ne) && R.getTokenAfter(ne).type === "Punctuator" && R.getTokenAfter(ne).value === ")"; )
        U = R.getTokenBefore(U), ne = R.getTokenAfter(ne);
      return R.getText().slice(U.range[0], ne.range[1]);
    },
    couldBeError(R) {
      switch (R.type) {
        case "Identifier":
        case "CallExpression":
        case "NewExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
        case "AwaitExpression":
        case "ChainExpression":
          return !0;
        case "AssignmentExpression":
          return ["=", "&&="].includes(R.operator) ? t.exports.couldBeError(R.right) : ["||=", "??="].includes(R.operator) ? t.exports.couldBeError(R.left) || t.exports.couldBeError(R.right) : !1;
        case "SequenceExpression": {
          const D = R.expressions;
          return D.length !== 0 && t.exports.couldBeError(D[D.length - 1]);
        }
        case "LogicalExpression":
          return R.operator === "&&" ? t.exports.couldBeError(R.right) : t.exports.couldBeError(R.left) || t.exports.couldBeError(R.right);
        case "ConditionalExpression":
          return t.exports.couldBeError(R.consequent) || t.exports.couldBeError(R.alternate);
        default:
          return !1;
      }
    },
    isNumericLiteral(R) {
      return R.type === "Literal" && (typeof R.value == "number" || !!R.bigint);
    },
    canTokensBeAdjacent(R, D) {
      const U = {
        ecmaVersion: Bs.default.latestEcmaVersion,
        comment: !0,
        range: !0
      };
      let ne;
      if (typeof R == "string") {
        let Ee;
        try {
          Ee = Bs.default.tokenize(R, U);
        } catch {
          return !1;
        }
        const Re = Ee.comments;
        if (ne = Ee[Ee.length - 1], Re.length) {
          const We = Re[Re.length - 1];
          We.range[0] > ne.range[0] && (ne = We);
        }
      } else
        ne = R;
      if (ne.type === "Shebang")
        return !1;
      let pe;
      if (typeof D == "string") {
        let Ee;
        try {
          Ee = Bs.default.tokenize(D, U);
        } catch {
          return !1;
        }
        const Re = Ee.comments;
        if (pe = Ee[0], Re.length) {
          const We = Re[0];
          We.range[0] < pe.range[0] && (pe = We);
        }
      } else
        pe = D;
      if (ne.type === "Punctuator" || pe.type === "Punctuator") {
        if (ne.type === "Punctuator" && pe.type === "Punctuator") {
          const Ee = /* @__PURE__ */ new Set(["+", "++"]), Re = /* @__PURE__ */ new Set(["-", "--"]);
          return !(Ee.has(ne.value) && Ee.has(pe.value) || Re.has(ne.value) && Re.has(pe.value));
        }
        return ne.type === "Punctuator" && ne.value === "/" ? !["Block", "Line", "RegularExpression"].includes(pe.type) : !0;
      }
      return !!(ne.type === "String" || pe.type === "String" || ne.type === "Template" || pe.type === "Template" || ne.type !== "Numeric" && pe.type === "Numeric" && pe.value.startsWith(".") || ne.type === "Block" || pe.type === "Block" || pe.type === "Line");
    },
    getNameLocationInGlobalDirectiveComment(R, D, U) {
      const ne = new RegExp(`[\\s,]${Ju.default(U)}(?:$|[\\s,:])`, "gu");
      ne.lastIndex = D.value.indexOf("global") + 6;
      const pe = ne.exec(D.value), Ee = R.getLocFromIndex(D.range[0] + 2 + (pe ? pe.index + 1 : 0)), Re = {
        line: Ee.line,
        column: Ee.column + (pe ? U.length : 1)
      };
      return {
        start: Ee,
        end: Re
      };
    },
    hasOctalOrNonOctalDecimalEscapeSequence(R) {
      return /^(?:[^\\]|\\.)*\\(?:[1-9]|0[0-9])/su.test(R);
    },
    isLogicalExpression: ee,
    isCoalesceExpression: he,
    isMixedLogicalAndCoalesceExpressions: function(R, D) {
      return ee(R) && he(D) || he(R) && ee(D);
    },
    isNullLiteral: y,
    getStaticStringValue: b,
    getStaticPropertyName: v,
    skipChainExpression: C,
    isSpecificId: w,
    isSpecificMemberAccess: B,
    equalLiteralValue: I,
    isSameReference: _,
    isLogicalAssignmentOperator: function(R) {
      return c.has(R);
    }
  };
});
E.COMMENTS_IGNORE_PATTERN;
E.LINEBREAKS;
E.LINEBREAK_MATCHER;
E.SHEBANG_MATCHER;
E.STATEMENT_LIST_PARENTS;
E.isTokenOnSameLine;
E.isNullOrUndefined;
E.isCallee;
E.isES5Constructor;
E.getUpperFunction;
E.isFunction;
E.isLoop;
E.isInLoop;
E.isArrayFromMethod;
E.isParenthesised;
E.createGlobalLinebreakMatcher;
E.equalTokens;
E.isArrowToken;
E.isClosingBraceToken;
E.isClosingBracketToken;
E.isClosingParenToken;
E.isColonToken;
E.isCommaToken;
E.isCommentToken;
E.isDotToken;
E.isQuestionDotToken;
E.isKeywordToken;
E.isNotClosingBraceToken;
E.isNotClosingBracketToken;
E.isNotClosingParenToken;
E.isNotColonToken;
E.isNotCommaToken;
E.isNotDotToken;
E.isNotQuestionDotToken;
E.isNotOpeningBraceToken;
E.isNotOpeningBracketToken;
E.isNotOpeningParenToken;
E.isNotSemicolonToken;
E.isOpeningBraceToken;
E.isOpeningBracketToken;
E.isOpeningParenToken;
E.isSemicolonToken;
E.isStringLiteral;
E.isBreakableStatement;
E.getModifyingReferences;
E.isSurroundedBy;
E.isDirectiveComment;
E.getTrailingStatement;
E.getVariableByName;
E.isDefaultThisBinding;
E.getPrecedence;
E.isEmptyBlock;
E.isEmptyFunction;
E.getDirectivePrologue;
E.isDecimalInteger;
E.isDecimalIntegerNumericToken;
E.getFunctionNameWithKind;
E.getFunctionHeadLoc;
E.getNextLocation;
E.getParenthesisedText;
E.couldBeError;
E.isNumericLiteral;
E.canTokensBeAdjacent;
E.getNameLocationInGlobalDirectiveComment;
E.hasOctalOrNonOctalDecimalEscapeSequence;
E.isLogicalExpression;
E.isCoalesceExpression;
E.isMixedLogicalAndCoalesceExpressions;
E.isNullLiteral;
E.getStaticStringValue;
E.getStaticPropertyName;
E.skipChainExpression;
E.isSpecificId;
E.isSpecificMemberAccess;
E.equalLiteralValue;
E.isSameReference;
E.isLogicalAssignmentOperator;
function aR(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    const s = t[r], n = e[r];
    if (s.type !== n.type || s.value !== n.value)
      return !1;
  }
  return !0;
}
function iR(t, e) {
  return typeof t == "string" && typeof e == "string" ? t === e : Array.isArray(t) && Array.isArray(e) ? aR(t, e) : !1;
}
function oR(t) {
  return t.kind === "get" || t.kind === "set";
}
function xa(t, e, r, s) {
  const n = t.parent;
  return n.type === "CallExpression" && E.isSpecificMemberAccess(n.callee, r, s) && n.arguments[e] === t;
}
function lR(t) {
  if (xa(t, 2, "Object", "defineProperty") || xa(t, 2, "Reflect", "defineProperty"))
    return !0;
  const e = t.parent.parent;
  return e.type === "ObjectExpression" && (xa(e, 1, "Object", "create") || xa(e, 1, "Object", "defineProperties"));
}
var Xu = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce getter and setter pairs in objects and classes",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/accessor-pairs"
    },
    schema: [{
      type: "object",
      properties: {
        getWithoutSet: {
          type: "boolean",
          default: !1
        },
        setWithoutGet: {
          type: "boolean",
          default: !0
        },
        enforceForClassMembers: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
      missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
      missingGetterInObjectLiteral: "Getter is not present for {{ name }}.",
      missingSetterInObjectLiteral: "Setter is not present for {{ name }}.",
      missingGetterInClass: "Getter is not present for class {{ name }}.",
      missingSetterInClass: "Setter is not present for class {{ name }}."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.getWithoutSet === !0, s = e.setWithoutGet !== !1, n = e.enforceForClassMembers !== !1, a = t.getSourceCode();
    function o(g, y) {
      g.type === "Property" ? t.report({
        node: g,
        messageId: `${y}InObjectLiteral`,
        loc: E.getFunctionHeadLoc(g.value, a),
        data: {
          name: E.getFunctionNameWithKind(g.value)
        }
      }) : g.type === "MethodDefinition" ? t.report({
        node: g,
        messageId: `${y}InClass`,
        loc: E.getFunctionHeadLoc(g.value, a),
        data: {
          name: E.getFunctionNameWithKind(g.value)
        }
      }) : t.report({
        node: g,
        messageId: `${y}InPropertyDescriptor`
      });
    }
    function l(g, y) {
      for (const x of g)
        o(x, y);
    }
    function i(g) {
      const y = E.getStaticPropertyName(g);
      return {
        key: y !== null ? y : a.getTokens(g.key),
        getters: g.kind === "get" ? [g] : [],
        setters: g.kind === "set" ? [g] : []
      };
    }
    function u(g, y) {
      const x = g.find((A) => iR(A.key, y.key));
      return x ? (x.getters.push(...y.getters), x.setters.push(...y.setters)) : g.push(y), g;
    }
    function c(g) {
      const y = g.filter(oR).map(i).reduce(u, []);
      for (const {
        getters: x,
        setters: A
      } of y)
        s && A.length && !x.length && l(A, "missingGetter"), r && x.length && !A.length && l(x, "missingSetter");
    }
    function f(g) {
      c(g.properties.filter((y) => y.type === "Property"));
    }
    function h(g) {
      const y = g.properties.filter((b) => b.type === "Property" && b.kind === "init" && !b.computed).map(({
        key: b
      }) => b.name), x = y.includes("get"), A = y.includes("set");
      s && A && !x && o(g, "missingGetter"), r && x && !A && o(g, "missingSetter");
    }
    function p(g) {
      f(g), lR(g) && h(g);
    }
    function m(g) {
      const y = g.body.filter((x) => x.type === "MethodDefinition");
      c(y.filter((x) => x.static)), c(y.filter((x) => !x.static));
    }
    const d = {};
    return (s || r) && (d.ObjectExpression = p, n && (d.ClassBody = m)), d;
  }
};
Xu.meta;
Xu.create;
var Qu = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce linebreaks after opening and before closing array brackets",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/array-bracket-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent"]
      }, {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minItems: {
            type: ["integer", "null"],
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
      unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
      missingOpeningLinebreak: "A linebreak is required after '['.",
      missingClosingLinebreak: "A linebreak is required before ']'."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(u) {
      let c = !1, f = !1, h = 0;
      return u ? u === "consistent" ? (c = !0, h = Number.POSITIVE_INFINITY) : u === "always" || u.minItems === 0 ? h = 0 : u === "never" ? h = Number.POSITIVE_INFINITY : (f = !!u.multiline, h = u.minItems || Number.POSITIVE_INFINITY) : (c = !1, f = !0, h = Number.POSITIVE_INFINITY), {
        consistent: c,
        multiline: f,
        minItems: h
      };
    }
    function s(u) {
      const c = r(u);
      return {
        ArrayExpression: c,
        ArrayPattern: c
      };
    }
    function n(u, c) {
      t.report({
        node: u,
        loc: c.loc,
        messageId: "unexpectedOpeningLinebreak",
        fix(f) {
          const h = e.getTokenAfter(c, {
            includeComments: !0
          });
          return E.isCommentToken(h) ? null : f.removeRange([c.range[1], h.range[0]]);
        }
      });
    }
    function a(u, c) {
      t.report({
        node: u,
        loc: c.loc,
        messageId: "unexpectedClosingLinebreak",
        fix(f) {
          const h = e.getTokenBefore(c, {
            includeComments: !0
          });
          return E.isCommentToken(h) ? null : f.removeRange([h.range[1], c.range[0]]);
        }
      });
    }
    function o(u, c) {
      t.report({
        node: u,
        loc: c.loc,
        messageId: "missingOpeningLinebreak",
        fix(f) {
          return f.insertTextAfter(c, `
`);
        }
      });
    }
    function l(u, c) {
      t.report({
        node: u,
        loc: c.loc,
        messageId: "missingClosingLinebreak",
        fix(f) {
          return f.insertTextBefore(c, `
`);
        }
      });
    }
    function i(u) {
      const c = u.elements, h = s(t.options[0])[u.type], p = e.getFirstToken(u), m = e.getLastToken(u), d = e.getTokenAfter(p, {
        includeComments: !0
      }), g = e.getTokenBefore(m, {
        includeComments: !0
      }), y = e.getTokenAfter(p), x = e.getTokenBefore(m);
      c.length >= h.minItems || h.multiline && c.length > 0 && d.loc.start.line !== g.loc.end.line || c.length === 0 && d.type === "Block" && d.loc.start.line !== g.loc.end.line && d === g || h.consistent && p.loc.end.line !== y.loc.start.line ? (E.isTokenOnSameLine(p, y) && o(u, p), E.isTokenOnSameLine(x, m) && l(u, m)) : (E.isTokenOnSameLine(p, y) || n(u, p), E.isTokenOnSameLine(x, m) || a(u, m));
    }
    return {
      ArrayPattern: i,
      ArrayExpression: i
    };
  }
};
Qu.meta;
Qu.create;
var Yu = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside array brackets",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/array-bracket-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        singleValue: {
          type: "boolean"
        },
        objectsInArrays: {
          type: "boolean"
        },
        arraysInArrays: {
          type: "boolean"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'."
    }
  },
  create(t) {
    const e = t.options[0] === "always", r = t.getSourceCode();
    function s(h) {
      return t.options[1] ? t.options[1][h] === !e : !1;
    }
    const n = {
      spaced: e,
      singleElementException: s("singleValue"),
      objectsInArraysException: s("objectsInArrays"),
      arraysInArraysException: s("arraysInArrays")
    };
    function a(h, p) {
      const m = r.getTokenAfter(p);
      t.report({
        node: h,
        loc: {
          start: p.loc.end,
          end: m.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: {
          tokenValue: p.value
        },
        fix(d) {
          return d.removeRange([p.range[1], m.range[0]]);
        }
      });
    }
    function o(h, p) {
      const m = r.getTokenBefore(p);
      t.report({
        node: h,
        loc: {
          start: m.loc.end,
          end: p.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: {
          tokenValue: p.value
        },
        fix(d) {
          return d.removeRange([m.range[1], p.range[0]]);
        }
      });
    }
    function l(h, p) {
      t.report({
        node: h,
        loc: p.loc,
        messageId: "missingSpaceAfter",
        data: {
          tokenValue: p.value
        },
        fix(m) {
          return m.insertTextAfter(p, " ");
        }
      });
    }
    function i(h, p) {
      t.report({
        node: h,
        loc: p.loc,
        messageId: "missingSpaceBefore",
        data: {
          tokenValue: p.value
        },
        fix(m) {
          return m.insertTextBefore(p, " ");
        }
      });
    }
    function u(h) {
      return h && (h.type === "ObjectExpression" || h.type === "ObjectPattern");
    }
    function c(h) {
      return h && (h.type === "ArrayExpression" || h.type === "ArrayPattern");
    }
    function f(h) {
      if (n.spaced && h.elements.length === 0)
        return;
      const p = r.getFirstToken(h), m = r.getFirstToken(h, 1), d = h.typeAnnotation ? r.getTokenBefore(h.typeAnnotation) : r.getLastToken(h), g = r.getTokenBefore(d), y = h.elements[0], x = h.elements[h.elements.length - 1], A = n.objectsInArraysException && u(y) || n.arraysInArraysException && c(y) || n.singleElementException && h.elements.length === 1 ? !n.spaced : n.spaced, b = n.objectsInArraysException && u(x) || n.arraysInArraysException && c(x) || n.singleElementException && h.elements.length === 1 ? !n.spaced : n.spaced;
      E.isTokenOnSameLine(p, m) && (A && !r.isSpaceBetweenTokens(p, m) && l(h, p), !A && r.isSpaceBetweenTokens(p, m) && a(h, p)), p !== g && E.isTokenOnSameLine(g, d) && (b && !r.isSpaceBetweenTokens(g, d) && i(h, d), !b && r.isSpaceBetweenTokens(g, d) && o(h, d));
    }
    return {
      ArrayPattern: f,
      ArrayExpression: f
    };
  }
};
Yu.meta;
Yu.create;
const uR = /^(?:Arrow)?FunctionExpression$/u, cR = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;
function pR(t) {
  return t.reachable;
}
function fR(t) {
  return E.isSpecificMemberAccess(t, null, cR);
}
function dy(t) {
  return ["from", "of", "isArray"].includes(t) ? "Array.".concat(t) : "Array.prototype.".concat(t);
}
function hR(t) {
  let e = t;
  for (; e; ) {
    const r = e.parent;
    switch (r.type) {
      case "LogicalExpression":
      case "ConditionalExpression":
      case "ChainExpression":
        e = r;
        break;
      case "ReturnStatement": {
        const s = E.getUpperFunction(r);
        if (s === null || !E.isCallee(s))
          return null;
        e = s.parent;
        break;
      }
      case "CallExpression":
        return E.isArrayFromMethod(r.callee) && r.arguments.length >= 2 && r.arguments[1] === e ? "from" : fR(r.callee) && r.arguments.length >= 1 && r.arguments[0] === e ? E.getStaticPropertyName(r.callee) : null;
      default:
        return null;
    }
  }
  return null;
}
var Zu = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce `return` statements in callbacks of array methods",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/array-callback-return"
    },
    schema: [{
      type: "object",
      properties: {
        allowImplicit: {
          type: "boolean",
          default: !1
        },
        checkForEach: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",
      expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.",
      expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.",
      expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}."
    }
  },
  create(t) {
    const e = t.options[0] || {
      allowImplicit: !1,
      checkForEach: !1
    }, r = t.getSourceCode();
    let s = {
      arrayMethodName: null,
      upper: null,
      codePath: null,
      hasReturn: !1,
      shouldCheck: !1,
      node: null
    };
    function n(a) {
      if (!s.shouldCheck)
        return;
      let o = null;
      if (s.arrayMethodName === "forEach" ? e.checkForEach && a.type === "ArrowFunctionExpression" && a.expression && (o = "expectedNoReturnValue") : a.body.type === "BlockStatement" && s.codePath.currentSegments.some(pR) && (o = s.hasReturn ? "expectedAtEnd" : "expectedInside"), o) {
        const l = E.getFunctionNameWithKind(a);
        t.report({
          node: a,
          loc: E.getFunctionHeadLoc(a, r),
          messageId: o,
          data: {
            name: l,
            arrayMethodName: dy(s.arrayMethodName)
          }
        });
      }
    }
    return {
      onCodePathStart(a, o) {
        let l = null;
        uR.test(o.type) && (l = hR(o)), s = {
          arrayMethodName: l,
          upper: s,
          codePath: a,
          hasReturn: !1,
          shouldCheck: l && !o.async && !o.generator,
          node: o
        };
      },
      onCodePathEnd() {
        s = s.upper;
      },
      ReturnStatement(a) {
        if (!s.shouldCheck)
          return;
        s.hasReturn = !0;
        let o = null;
        s.arrayMethodName === "forEach" ? e.checkForEach && a.argument && (o = "expectedNoReturnValue") : !e.allowImplicit && !a.argument && (o = "expectedReturnValue"), o && t.report({
          node: a,
          messageId: o,
          data: {
            name: E.getFunctionNameWithKind(s.node),
            arrayMethodName: dy(s.arrayMethodName)
          }
        });
      },
      "FunctionExpression:exit": n,
      "ArrowFunctionExpression:exit": n
    };
  }
};
Zu.meta;
Zu.create;
var ec = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce line breaks after each array element",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/array-element-newline"
    },
    fixable: "whitespace",
    schema: {
      definitions: {
        basicConfig: {
          oneOf: [{
            enum: ["always", "never", "consistent"]
          }, {
            type: "object",
            properties: {
              multiline: {
                type: "boolean"
              },
              minItems: {
                type: ["integer", "null"],
                minimum: 0
              }
            },
            additionalProperties: !1
          }]
        }
      },
      items: [{
        oneOf: [{
          $ref: "#/definitions/basicConfig"
        }, {
          type: "object",
          properties: {
            ArrayExpression: {
              $ref: "#/definitions/basicConfig"
            },
            ArrayPattern: {
              $ref: "#/definitions/basicConfig"
            }
          },
          additionalProperties: !1,
          minProperties: 1
        }]
      }]
    },
    messages: {
      unexpectedLineBreak: "There should be no linebreak here.",
      missingLineBreak: "There should be a linebreak after this element."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(l) {
      let i = !1, u = !1, c;
      const f = l || "always";
      return !f || f === "always" || f.minItems === 0 ? c = 0 : f === "never" ? c = Number.POSITIVE_INFINITY : f === "consistent" ? (i = !0, c = Number.POSITIVE_INFINITY) : (u = !!f.multiline, c = f.minItems || Number.POSITIVE_INFINITY), {
        consistent: i,
        multiline: u,
        minItems: c
      };
    }
    function s(l) {
      if (l && (l.ArrayExpression || l.ArrayPattern)) {
        let u, c;
        return l.ArrayExpression && (u = r(l.ArrayExpression)), l.ArrayPattern && (c = r(l.ArrayPattern)), {
          ArrayExpression: u,
          ArrayPattern: c
        };
      }
      const i = r(l);
      return {
        ArrayExpression: i,
        ArrayPattern: i
      };
    }
    function n(l) {
      const i = e.getTokenBefore(l, {
        includeComments: !0
      });
      t.report({
        loc: {
          start: i.loc.end,
          end: l.loc.start
        },
        messageId: "unexpectedLineBreak",
        fix(u) {
          if (E.isCommentToken(i))
            return null;
          if (!E.isTokenOnSameLine(i, l))
            return u.replaceTextRange([i.range[1], l.range[0]], " ");
          const c = e.getTokenBefore(i, {
            includeComments: !0
          });
          return E.isCommentToken(c) ? null : u.replaceTextRange([c.range[1], i.range[0]], "");
        }
      });
    }
    function a(l) {
      const i = e.getTokenBefore(l, {
        includeComments: !0
      });
      t.report({
        loc: {
          start: i.loc.end,
          end: l.loc.start
        },
        messageId: "missingLineBreak",
        fix(u) {
          return u.replaceTextRange([i.range[1], l.range[0]], `
`);
        }
      });
    }
    function o(l) {
      const i = l.elements, c = s(t.options[0])[l.type];
      if (!c)
        return;
      let f = !1;
      c.multiline && (f = i.filter((m) => m !== null).some((m) => m.loc.start.line !== m.loc.end.line));
      const h = l.elements.map((m, d) => {
        const g = i[d - 1];
        if (d === 0 || m === null || g === null)
          return !1;
        const y = e.getFirstTokenBetween(g, m, E.isCommaToken), x = e.getTokenBefore(y), A = e.getTokenAfter(y);
        return !E.isTokenOnSameLine(x, A);
      }).filter((m) => m === !0).length, p = i.length >= c.minItems || c.multiline && f || c.consistent && h > 0 && h < l.elements.length;
      i.forEach((m, d) => {
        const g = i[d - 1];
        if (d === 0 || m === null || g === null)
          return;
        const y = e.getFirstTokenBetween(g, m, E.isCommaToken), x = e.getTokenBefore(y), A = e.getTokenAfter(y);
        p ? E.isTokenOnSameLine(x, A) && a(A) : E.isTokenOnSameLine(x, A) || n(A);
      });
    }
    return {
      ArrayPattern: o,
      ArrayExpression: o
    };
  }
};
ec.meta;
ec.create;
var tc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require braces around arrow function bodies",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/arrow-body-style"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "never"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["as-needed"]
        }, {
          type: "object",
          properties: {
            requireReturnForObjectLiteral: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
      unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
      unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
      unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
      expectedBlock: "Expected block statement surrounding arrow body."
    }
  },
  create(t) {
    const e = t.options, r = e[0] === "always", s = !e[0] || e[0] === "as-needed", n = e[0] === "never", a = e[1] && e[1].requireReturnForObjectLiteral, o = t.getSourceCode();
    let l = null;
    function i(h) {
      return h && h.type === "Punctuator" && /^[([/`+-]/u.test(h.value);
    }
    function u(h) {
      let p = h;
      for (; !E.isParenthesised(o, p); )
        p = p.parent;
      return o.getTokenAfter(p);
    }
    function c(h) {
      return h && h.parent ? h.parent.type === "ForStatement" && h.parent.init === h ? !0 : c(h.parent) : !1;
    }
    function f(h) {
      const p = h.body;
      if (p.type === "BlockStatement") {
        const m = p.body;
        if (m.length !== 1 && !n || s && a && m[0].type === "ReturnStatement" && m[0].argument && m[0].argument.type === "ObjectExpression")
          return;
        if (n || s && m[0].type === "ReturnStatement") {
          let d;
          m.length === 0 ? d = "unexpectedEmptyBlock" : m.length > 1 ? d = "unexpectedOtherBlock" : m[0].argument === null ? d = "unexpectedSingleBlock" : E.isOpeningBraceToken(o.getFirstToken(m[0], {
            skip: 1
          })) ? d = "unexpectedObjectBlock" : d = "unexpectedSingleBlock", t.report({
            node: h,
            loc: p.loc,
            messageId: d,
            fix(g) {
              const y = [];
              if (m.length !== 1 || m[0].type !== "ReturnStatement" || !m[0].argument || i(o.getTokenAfter(p)))
                return y;
              const x = o.getFirstToken(p), A = o.getLastToken(p), b = o.getFirstToken(m[0], 1), v = o.getLastToken(m[0]);
              return o.commentsExistBetween(x, b) || o.commentsExistBetween(v, A) ? y.push(g.remove(x), g.remove(A), g.remove(o.getTokenAfter(x))) : y.push(g.removeRange([x.range[0], b.range[0]]), g.removeRange([v.range[1], A.range[1]])), (E.isOpeningBraceToken(b) || m[0].argument.type === "SequenceExpression" || l.hasInOperator && c(h)) && (E.isParenthesised(o, m[0].argument) || y.push(g.insertTextBefore(b, "("), g.insertTextAfter(v, ")"))), E.isSemicolonToken(v) && y.push(g.remove(v)), y;
            }
          });
        }
      } else
        (r || s && a && p.type === "ObjectExpression") && t.report({
          node: h,
          loc: p.loc,
          messageId: "expectedBlock",
          fix(m) {
            const d = [], g = o.getTokenBefore(p, E.isArrowToken), [y, x] = o.getTokensAfter(g, {
              count: 2
            }), A = o.getLastToken(h);
            let b = null;
            if (E.isOpeningParenToken(y) && E.isOpeningBraceToken(x)) {
              const v = o.getNodeByRangeIndex(x.range[0]);
              v.type === "ObjectExpression" && (b = v);
            }
            if (b) {
              const v = y, C = x;
              E.isTokenOnSameLine(v, C) ? d.push(m.replaceText(v, "{return ")) : d.push(m.replaceText(v, "{"), m.insertTextBefore(C, "return ")), d.push(m.remove(u(b))), d.push(m.insertTextAfter(A, "}"));
            } else
              d.push(m.insertTextBefore(y, "{return ")), d.push(m.insertTextAfter(A, "}"));
            return d;
          }
        });
    }
    return {
      "BinaryExpression[operator='in']"() {
        let h = l;
        for (; h; )
          h.hasInOperator = !0, h = h.upper;
      },
      ArrowFunctionExpression() {
        l = {
          upper: l,
          hasInOperator: !1
        };
      },
      "ArrowFunctionExpression:exit"(h) {
        f(h), l = l.upper;
      }
    };
  }
};
tc.meta;
tc.create;
function mR(t) {
  return t.body.type === "BlockStatement";
}
var rc = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses around arrow function arguments",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/arrow-parens"
    },
    fixable: "code",
    schema: [{
      enum: ["always", "as-needed"]
    }, {
      type: "object",
      properties: {
        requireForBlockBody: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedParens: "Unexpected parentheses around single function argument.",
      expectedParens: "Expected parentheses around arrow function argument.",
      unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
      expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
    }
  },
  create(t) {
    const e = t.options[0] === "as-needed", r = e && t.options[1] && t.options[1].requireForBlockBody === !0, s = t.getSourceCode();
    function n(i) {
      const u = s.getTokenBefore(i.params[0]);
      return u && E.isOpeningParenToken(u) && i.range[0] <= u.range[0] ? u : null;
    }
    function a(i) {
      return s.getTokenAfter(i.params[0], E.isClosingParenToken);
    }
    function o(i, u) {
      return s.commentsExistBetween(u, a(i));
    }
    function l(i, u) {
      const c = i.async ? 1 : 0;
      return s.getFirstToken(i, {
        skip: c
      }) !== u;
    }
    return {
      "ArrowFunctionExpression[params.length=1]"(i) {
        const u = !e || r && mR(i), c = n(i), f = c !== null, [h] = i.params;
        u && !f && t.report({
          node: i,
          messageId: r ? "expectedParensBlock" : "expectedParens",
          loc: h.loc,
          *fix(p) {
            yield p.insertTextBefore(h, "("), yield p.insertTextAfter(h, ")");
          }
        }), !u && f && h.type === "Identifier" && !h.typeAnnotation && !i.returnType && !o(i, c) && !l(i, c) && t.report({
          node: i,
          messageId: r ? "unexpectedParensInline" : "unexpectedParens",
          loc: h.loc,
          *fix(p) {
            const m = s.getTokenBefore(c), d = a(i);
            m && m.range[1] === c.range[0] && !E.canTokensBeAdjacent(m, s.getFirstToken(h)) && (yield p.insertTextBefore(c, " ")), yield p.removeRange([c.range[0], h.range[0]]), yield p.removeRange([h.range[1], d.range[1]]);
          }
        });
      }
    };
  }
};
rc.meta;
rc.create;
var nc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after the arrow in arrow functions",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/arrow-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: !0
        },
        after: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expectedBefore: "Missing space before =>.",
      unexpectedBefore: "Unexpected space before =>.",
      expectedAfter: "Missing space after =>.",
      unexpectedAfter: "Unexpected space after =>."
    }
  },
  create(t) {
    const e = Object.assign({}, t.options[0]);
    e.before = e.before !== !1, e.after = e.after !== !1;
    const r = t.getSourceCode();
    function s(a) {
      const o = r.getTokenBefore(a.body, E.isArrowToken);
      return {
        before: r.getTokenBefore(o),
        arrow: o,
        after: r.getTokenAfter(o)
      };
    }
    function n(a) {
      const o = a.arrow.range[0] - a.before.range[1], l = a.after.range[0] - a.arrow.range[1];
      return {
        before: o,
        after: l
      };
    }
    return {
      ArrowFunctionExpression: function(a) {
        const o = s(a), l = n(o);
        e.before ? l.before === 0 && t.report({
          node: o.before,
          messageId: "expectedBefore",
          fix(i) {
            return i.insertTextBefore(o.arrow, " ");
          }
        }) : l.before > 0 && t.report({
          node: o.before,
          messageId: "unexpectedBefore",
          fix(i) {
            return i.removeRange([o.before.range[1], o.arrow.range[0]]);
          }
        }), e.after ? l.after === 0 && t.report({
          node: o.after,
          messageId: "expectedAfter",
          fix(i) {
            return i.insertTextAfter(o.arrow, " ");
          }
        }) : l.after > 0 && t.report({
          node: o.after,
          messageId: "unexpectedAfter",
          fix(i) {
            return i.removeRange([o.arrow.range[1], o.after.range[0]]);
          }
        });
      }
    };
  }
};
nc.meta;
nc.create;
var sc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the use of variables within the scope they are defined",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/block-scoped-var"
    },
    schema: [],
    messages: {
      outOfScope: "'{{name}}' used outside of binding context."
    }
  },
  create(t) {
    let e = [];
    function r(o) {
      e.push(o.range);
    }
    function s() {
      e.pop();
    }
    function n(o) {
      const l = o.identifier;
      t.report({
        node: l,
        messageId: "outOfScope",
        data: {
          name: l.name
        }
      });
    }
    function a(o) {
      if (o.kind !== "var")
        return;
      const l = e[e.length - 1];
      function i(c) {
        const f = c.identifier.range;
        return f[0] < l[0] || f[1] > l[1];
      }
      const u = t.getDeclaredVariables(o);
      for (let c = 0; c < u.length; ++c)
        u[c].references.filter(i).forEach(n);
    }
    return {
      Program(o) {
        e = [o.range];
      },
      BlockStatement: r,
      "BlockStatement:exit": s,
      ForStatement: r,
      "ForStatement:exit": s,
      ForInStatement: r,
      "ForInStatement:exit": s,
      ForOfStatement: r,
      "ForOfStatement:exit": s,
      SwitchStatement: r,
      "SwitchStatement:exit": s,
      CatchClause: r,
      "CatchClause:exit": s,
      VariableDeclaration: a
    };
  }
};
sc.meta;
sc.create;
var ac = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/block-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      missing: "Requires a space {{location}} '{{token}}'.",
      extra: "Unexpected space(s) {{location}} '{{token}}'."
    }
  },
  create(t) {
    const e = t.options[0] !== "never", r = e ? "missing" : "extra", s = t.getSourceCode();
    function n(l) {
      return l.type === "SwitchStatement" ? l.cases.length > 0 ? s.getTokenBefore(l.cases[0]) : s.getLastToken(l, 1) : s.getFirstToken(l);
    }
    function a(l, i) {
      return !E.isTokenOnSameLine(l, i) || s.isSpaceBetweenTokens(l, i) === e;
    }
    function o(l) {
      const i = n(l), u = s.getLastToken(l), c = s.getTokenAfter(i, {
        includeComments: !0
      }), f = s.getTokenBefore(u, {
        includeComments: !0
      });
      if (!(i.type !== "Punctuator" || i.value !== "{" || u.type !== "Punctuator" || u.value !== "}" || c === u) && !(!e && c.type === "Line")) {
        if (!a(i, c)) {
          let h = i.loc;
          r === "extra" && (h = {
            start: i.loc.end,
            end: c.loc.start
          }), t.report({
            node: l,
            loc: h,
            messageId: r,
            data: {
              location: "after",
              token: i.value
            },
            fix(p) {
              return e ? p.insertTextBefore(c, " ") : p.removeRange([i.range[1], c.range[0]]);
            }
          });
        }
        if (!a(f, u)) {
          let h = u.loc;
          r === "extra" && (h = {
            start: f.loc.end,
            end: u.loc.start
          }), t.report({
            node: l,
            loc: h,
            messageId: r,
            data: {
              location: "before",
              token: u.value
            },
            fix(p) {
              return e ? p.insertTextAfter(f, " ") : p.removeRange([f.range[1], u.range[0]]);
            }
          });
        }
      }
    }
    return {
      BlockStatement: o,
      SwitchStatement: o
    };
  }
};
ac.meta;
ac.create;
var ic = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent brace style for blocks",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/brace-style"
    },
    schema: [{
      enum: ["1tbs", "stroustrup", "allman"]
    }, {
      type: "object",
      properties: {
        allowSingleLine: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "whitespace",
    messages: {
      nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
      sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
      blockSameLine: "Statement inside of curly braces should be on next line.",
      nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
      singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
      sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
    }
  },
  create(t) {
    const e = t.options[0] || "1tbs", r = t.options[1] || {}, s = t.getSourceCode();
    function n(l, i) {
      const u = [l.range[1], i.range[0]];
      return s.text.slice(u[0], u[1]).trim() ? null : (f) => f.replaceTextRange(u, " ");
    }
    function a(l, i) {
      const u = s.getTokenBefore(l), c = s.getTokenAfter(l), f = s.getTokenBefore(i), h = r.allowSingleLine && E.isTokenOnSameLine(l, i);
      e !== "allman" && !E.isTokenOnSameLine(u, l) && t.report({
        node: l,
        messageId: "nextLineOpen",
        fix: n(u, l)
      }), e === "allman" && E.isTokenOnSameLine(u, l) && !h && t.report({
        node: l,
        messageId: "sameLineOpen",
        fix: (p) => p.insertTextBefore(l, `
`)
      }), E.isTokenOnSameLine(l, c) && c !== i && !h && t.report({
        node: l,
        messageId: "blockSameLine",
        fix: (p) => p.insertTextAfter(l, `
`)
      }), f !== l && !h && E.isTokenOnSameLine(f, i) && t.report({
        node: i,
        messageId: "singleLineClose",
        fix: (p) => p.insertTextBefore(i, `
`)
      });
    }
    function o(l) {
      const i = s.getTokenAfter(l);
      e === "1tbs" && !E.isTokenOnSameLine(l, i) && t.report({
        node: l,
        messageId: "nextLineClose",
        fix: n(l, i)
      }), e !== "1tbs" && E.isTokenOnSameLine(l, i) && t.report({
        node: l,
        messageId: "sameLineClose",
        fix: (u) => u.insertTextAfter(l, `
`)
      });
    }
    return {
      BlockStatement(l) {
        E.STATEMENT_LIST_PARENTS.has(l.parent.type) || a(s.getFirstToken(l), s.getLastToken(l));
      },
      ClassBody(l) {
        a(s.getFirstToken(l), s.getLastToken(l));
      },
      SwitchStatement(l) {
        const i = s.getLastToken(l), u = s.getTokenBefore(l.cases.length ? l.cases[0] : i);
        a(u, i);
      },
      IfStatement(l) {
        l.consequent.type === "BlockStatement" && l.alternate && o(s.getLastToken(l.consequent));
      },
      TryStatement(l) {
        o(s.getLastToken(l.block)), l.handler && l.finalizer && o(s.getLastToken(l.handler.body));
      }
    };
  }
};
ic.meta;
ic.create;
var oc = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "require `return` statements after callbacks",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/callback-return"
    },
    schema: [{
      type: "array",
      items: {
        type: "string"
      }
    }],
    messages: {
      missingReturn: "Expected return with your callback function."
    }
  },
  create(t) {
    const e = t.options[0] || ["callback", "cb", "next"], r = t.getSourceCode();
    function s(l, i) {
      return l.parent ? i.indexOf(l.parent.type) === -1 ? s(l.parent, i) : l.parent : null;
    }
    function n(l) {
      if (l.type === "Identifier")
        return !0;
      if (l.type === "MemberExpression") {
        if (l.object.type === "Identifier")
          return !0;
        if (l.object.type === "MemberExpression")
          return n(l.object);
      }
      return !1;
    }
    function a(l) {
      return n(l.callee) && e.indexOf(r.getText(l.callee)) > -1;
    }
    function o(l, i) {
      return !i || i.type !== "ExpressionStatement" ? !1 : i.expression === l || (i.expression.type === "BinaryExpression" || i.expression.type === "LogicalExpression") && i.expression.right === l;
    }
    return {
      CallExpression(l) {
        if (!a(l))
          return;
        const i = s(l, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
        if (i.type !== "ReturnStatement" && i.type !== "ArrowFunctionExpression") {
          if (i.type === "BlockStatement") {
            const u = i.body[i.body.length - 1];
            if (o(l, u)) {
              const c = i.parent.type;
              if (c === "FunctionExpression" || c === "FunctionDeclaration" || c === "ArrowFunctionExpression")
                return;
            }
            if (u.type === "ReturnStatement" && o(l, i.body[i.body.length - 2]))
              return;
          }
          s(l, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]) && t.report({
            node: l,
            messageId: "missingReturn"
          });
        }
      }
    };
  }
};
oc.meta;
oc.create;
var lc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce camelcase naming convention",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/camelcase"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreDestructuring: {
          type: "boolean",
          default: !1
        },
        ignoreImports: {
          type: "boolean",
          default: !1
        },
        ignoreGlobals: {
          type: "boolean",
          default: !1
        },
        properties: {
          enum: ["always", "never"]
        },
        allow: {
          type: "array",
          items: [{
            type: "string"
          }],
          minItems: 0,
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      notCamelCase: "Identifier '{{name}}' is not in camel case."
    }
  },
  create(t) {
    const e = t.options[0] || {};
    let r = e.properties || "";
    const s = e.ignoreDestructuring, n = e.ignoreImports, a = e.ignoreGlobals, o = e.allow || [];
    let l;
    r !== "always" && r !== "never" && (r = "always");
    const i = [], u = /* @__PURE__ */ new Set(["CallExpression", "NewExpression"]);
    function c(y) {
      return y.includes("_") && y !== y.toUpperCase();
    }
    function f(y) {
      return o.some((x) => y === x || y.match(new RegExp(x, "u")));
    }
    function h(y) {
      let x = y;
      for (; x; ) {
        const A = x.parent;
        if (A && A.type === "Property" && A.computed && A.key === x)
          return !1;
        if (x.type === "ObjectPattern")
          return !0;
        x = A;
      }
      return !1;
    }
    function p(y) {
      if (y.parent.type === "MemberExpression" && y.parent.property === y && !y.parent.computed) {
        const x = y.parent.parent;
        return x.type === "Property" && x.value === y.parent && x.parent.type === "ObjectPattern" || x.type === "ArrayPattern" || x.type === "RestElement" || x.type === "AssignmentPattern" && x.left === y.parent;
      }
      return !1;
    }
    function m(y) {
      const x = l.set.get(y.name);
      return x && x.defs.length === 0 && x.references.some((A) => A.identifier === y);
    }
    function d(y) {
      const x = y.parent;
      return x.type === "Property" && x.parent.type === "ObjectExpression" && !x.computed && x.key === y;
    }
    function g(y) {
      i.includes(y) || (i.push(y), t.report({
        node: y,
        messageId: "notCamelCase",
        data: {
          name: y.name
        }
      }));
    }
    return {
      Program() {
        l = t.getScope();
      },
      Identifier(y) {
        const x = y.name, A = c(x.replace(/^_+|_+$/gu, "")), b = y.parent.type === "MemberExpression" ? y.parent.parent : y.parent;
        if (!f(x) && !(a && m(y) && !d(y)))
          if (y.parent.type === "MemberExpression") {
            if (r === "never")
              return;
            (y.parent.object.type === "Identifier" && y.parent.object.name === y.name && A || b.type === "AssignmentExpression" && A && (b.right.type !== "MemberExpression" || b.left.type === "MemberExpression" && b.left.property.name === y.name) || p(y) && A) && g(y);
          } else if (y.parent.type === "Property" || y.parent.type === "AssignmentPattern") {
            if (y.parent.parent && y.parent.parent.type === "ObjectPattern") {
              y.parent.shorthand && y.parent.value.left && A && g(y);
              const v = y.parent.key.name === y.parent.value.name;
              if (A && y.parent.computed && g(y), y.parent.key === y && y.parent.value !== y)
                return;
              y.parent.value.name && A && !(v && s) && g(y);
            }
            if (r === "never" || s && h(y))
              return;
            A && !u.has(b.type) && y.parent.right !== y && g(y);
          } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].includes(y.parent.type)) {
            if (y.parent.type === "ImportSpecifier" && n)
              return;
            y.parent.local && y.parent.local.name === y.name && A && g(y);
          } else
            A && !u.has(b.type) && g(y);
      }
    };
  }
};
lc.meta;
lc.create;
/**
 * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
 * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
 * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
 * @author Kevin Partington
 * @license MIT License (from JSCS). See below.
 */
var gy = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u;
const dR = E.COMMENTS_IGNORE_PATTERN, gR = /\s/gu, yR = /^\s*[^:/?#\s]+:\/\/[^?#]/u, Mo = {
  type: "object",
  properties: {
    ignorePattern: {
      type: "string"
    },
    ignoreInlineComments: {
      type: "boolean"
    },
    ignoreConsecutiveComments: {
      type: "boolean"
    }
  },
  additionalProperties: !1
}, xR = {
  ignorePattern: "",
  ignoreInlineComments: !1,
  ignoreConsecutiveComments: !1
};
function yy(t, e) {
  return Object.assign({}, xR, t[e] || t);
}
function vR(t = {}) {
  return {
    Line: yy(t, "line"),
    Block: yy(t, "block")
  };
}
function ER(t) {
  Object.keys(t).forEach((e) => {
    const r = t[e].ignorePattern;
    if (r) {
      const s = RegExp(`^\\s*(?:${r})`, "u");
      t[e].ignorePatternRegExp = s;
    }
  });
}
var uc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce or disallow capitalization of the first letter of a comment",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/capitalized-comments"
    },
    fixable: "code",
    schema: [{
      enum: ["always", "never"]
    }, {
      oneOf: [Mo, {
        type: "object",
        properties: {
          line: Mo,
          block: Mo
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
      unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
    }
  },
  create(t) {
    const e = t.options[0] || "always", r = vR(t.options[1]), s = t.getSourceCode();
    ER(r);
    function n(i) {
      const u = s.getTokenBefore(i, {
        includeComments: !0
      }), c = s.getTokenAfter(i, {
        includeComments: !0
      });
      return !!(u && c && i.loc.start.line === u.loc.end.line && i.loc.end.line === c.loc.start.line);
    }
    function a(i) {
      const u = s.getTokenBefore(i, {
        includeComments: !0
      });
      return !!(u && ["Block", "Line"].indexOf(u.type) !== -1);
    }
    function o(i, u) {
      if (dR.test(i.value))
        return !0;
      const c = i.value.replace(/\*/gu, "");
      if (u.ignorePatternRegExp && u.ignorePatternRegExp.test(c) || u.ignoreInlineComments && n(i) || u.ignoreConsecutiveComments && a(i) || yR.test(c))
        return !0;
      const f = c.replace(gR, "");
      if (f.length === 0)
        return !0;
      const h = f[0];
      if (!gy.test(h))
        return !0;
      const p = h !== h.toLocaleLowerCase(), m = h !== h.toLocaleUpperCase();
      return !(e === "always" && m || e === "never" && p);
    }
    function l(i) {
      const u = r[i.type];
      if (!o(i, u)) {
        const f = e === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
        t.report({
          node: null,
          loc: i.loc,
          messageId: f,
          fix(h) {
            const p = i.value.match(gy);
            return h.replaceTextRange([i.range[0] + p.index + 2, i.range[0] + p.index + 3], e === "always" ? p[0].toLocaleUpperCase() : p[0].toLocaleLowerCase());
          }
        });
      }
    }
    return {
      Program() {
        s.getAllComments().filter((u) => u.type !== "Shebang").forEach(l);
      }
    };
  }
};
uc.meta;
uc.create;
var cc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce that class methods utilize `this`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/class-methods-use-this"
    },
    schema: [{
      type: "object",
      properties: {
        exceptMethods: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missingThis: "Expected 'this' to be used by class {{name}}."
    }
  },
  create(t) {
    const e = Object.assign({}, t.options[0]), r = new Set(e.exceptMethods || []), s = [];
    function n() {
      s.push(!1);
    }
    function a(u) {
      return !u.static && u.kind !== "constructor" && u.type === "MethodDefinition";
    }
    function o(u) {
      return a(u) && (u.computed || !r.has(u.key.name));
    }
    function l(u) {
      const c = s.pop();
      o(u.parent) && !c && t.report({
        node: u,
        messageId: "missingThis",
        data: {
          name: E.getFunctionNameWithKind(u)
        }
      });
    }
    function i() {
      s.length && (s[s.length - 1] = !0);
    }
    return {
      FunctionDeclaration: n,
      "FunctionDeclaration:exit": l,
      FunctionExpression: n,
      "FunctionExpression:exit": l,
      ThisExpression: i,
      Super: i
    };
  }
};
cc.meta;
cc.create;
const Mn = Object.freeze({
  arrays: "never",
  objects: "never",
  imports: "never",
  exports: "never",
  functions: "never"
});
function bR(t) {
  return !(t.type === "RestElement" || t.type === "RestProperty" || t.type === "ExperimentalRestProperty");
}
function CR(t, e) {
  return typeof t == "string" ? {
    arrays: t,
    objects: t,
    imports: t,
    exports: t,
    functions: !e || e < 8 ? "ignore" : t
  } : typeof t == "object" && t !== null ? {
    arrays: t.arrays || Mn.arrays,
    objects: t.objects || Mn.objects,
    imports: t.imports || Mn.imports,
    exports: t.exports || Mn.exports,
    functions: t.functions || Mn.functions
  } : Mn;
}
var pc = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow trailing commas",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/comma-dangle"
    },
    fixable: "code",
    schema: {
      definitions: {
        value: {
          enum: ["always-multiline", "always", "never", "only-multiline"]
        },
        valueWithIgnore: {
          enum: ["always-multiline", "always", "ignore", "never", "only-multiline"]
        }
      },
      type: "array",
      items: [{
        oneOf: [{
          $ref: "#/definitions/value"
        }, {
          type: "object",
          properties: {
            arrays: {
              $ref: "#/definitions/valueWithIgnore"
            },
            objects: {
              $ref: "#/definitions/valueWithIgnore"
            },
            imports: {
              $ref: "#/definitions/valueWithIgnore"
            },
            exports: {
              $ref: "#/definitions/valueWithIgnore"
            },
            functions: {
              $ref: "#/definitions/valueWithIgnore"
            }
          },
          additionalProperties: !1
        }]
      }]
    },
    messages: {
      unexpected: "Unexpected trailing comma.",
      missing: "Missing trailing comma."
    }
  },
  create(t) {
    const e = CR(t.options[0], t.parserOptions.ecmaVersion), r = t.getSourceCode();
    function s(u) {
      function c(f) {
        return f[f.length - 1];
      }
      switch (u.type) {
        case "ObjectExpression":
        case "ObjectPattern":
          return c(u.properties);
        case "ArrayExpression":
        case "ArrayPattern":
          return c(u.elements);
        case "ImportDeclaration":
        case "ExportNamedDeclaration":
          return c(u.specifiers);
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
          return c(u.params);
        case "CallExpression":
        case "NewExpression":
          return c(u.arguments);
        default:
          return null;
      }
    }
    function n(u, c) {
      switch (u.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "CallExpression":
        case "NewExpression":
          return r.getLastToken(u, 1);
        default: {
          const f = r.getTokenAfter(c);
          return E.isCommaToken(f) ? f : r.getLastToken(c);
        }
      }
    }
    function a(u) {
      const c = s(u);
      if (!c)
        return !1;
      const f = n(u, c);
      return r.getTokenAfter(f).loc.end.line !== f.loc.end.line;
    }
    function o(u) {
      const c = s(u);
      if (!c || u.type === "ImportDeclaration" && c.type !== "ImportSpecifier")
        return;
      const f = n(u, c);
      E.isCommaToken(f) && t.report({
        node: c,
        loc: f.loc,
        messageId: "unexpected",
        fix(h) {
          return h.remove(f);
        }
      });
    }
    function l(u) {
      const c = s(u);
      if (!c || u.type === "ImportDeclaration" && c.type !== "ImportSpecifier")
        return;
      if (!bR(c)) {
        o(u);
        return;
      }
      const f = n(u, c);
      f.value !== "," && t.report({
        node: c,
        loc: {
          start: f.loc.end,
          end: E.getNextLocation(r, f.loc.end)
        },
        messageId: "missing",
        fix(h) {
          return h.insertTextAfter(f, ",");
        }
      });
    }
    const i = {
      always: l,
      "always-multiline": function(u) {
        a(u) ? l(u) : o(u);
      },
      "only-multiline": function(u) {
        a(u) || o(u);
      },
      never: o,
      ignore: () => {
      }
    };
    return {
      ObjectExpression: i[e.objects],
      ObjectPattern: i[e.objects],
      ArrayExpression: i[e.arrays],
      ArrayPattern: i[e.arrays],
      ImportDeclaration: i[e.imports],
      ExportNamedDeclaration: i[e.exports],
      FunctionDeclaration: i[e.functions],
      FunctionExpression: i[e.functions],
      ArrowFunctionExpression: i[e.functions],
      CallExpression: i[e.functions],
      NewExpression: i[e.functions]
    };
  }
};
pc.meta;
pc.create;
var fc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after commas",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/comma-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: !1
        },
        after: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missing: "A space is required {{loc}} ','.",
      unexpected: "There should be no space {{loc}} ','."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = e.tokensAndComments, s = {
      before: t.options[0] ? t.options[0].before : !1,
      after: t.options[0] ? t.options[0].after : !0
    }, n = [];
    function a(i, u, c) {
      t.report({
        node: i,
        fix(f) {
          if (s[u])
            return u === "before" ? f.insertTextBefore(i, " ") : f.insertTextAfter(i, " ");
          let h, p;
          return u === "before" ? (h = c.range[1], p = i.range[0]) : (h = i.range[1], p = c.range[0]), f.replaceTextRange([h, p], "");
        },
        messageId: s[u] ? "missing" : "unexpected",
        data: {
          loc: u
        }
      });
    }
    function o(i, u) {
      i.left && E.isTokenOnSameLine(i.left, i.comma) && s.before !== e.isSpaceBetweenTokens(i.left, i.comma) && a(u, "before", i.left), !(i.right && E.isClosingParenToken(i.right)) && (i.right && !s.after && i.right.type === "Line" || i.right && E.isTokenOnSameLine(i.comma, i.right) && s.after !== e.isSpaceBetweenTokens(i.comma, i.right) && a(u, "after", i.right));
    }
    function l(i) {
      let u = e.getFirstToken(i);
      i.elements.forEach((c) => {
        let f;
        c === null ? (f = e.getTokenAfter(u), E.isCommaToken(f) && n.push(f)) : f = e.getTokenAfter(c), u = f;
      });
    }
    return {
      "Program:exit"() {
        r.forEach((i, u) => {
          if (!E.isCommaToken(i) || i && i.type === "JSXText")
            return;
          const c = r[u - 1], f = r[u + 1];
          o({
            comma: i,
            left: E.isCommaToken(c) || n.includes(i) ? null : c,
            right: E.isCommaToken(f) ? null : f
          }, i);
        });
      },
      ArrayExpression: l,
      ArrayPattern: l
    };
  }
};
fc.meta;
fc.create;
var hc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent comma style",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/comma-style"
    },
    fixable: "code",
    schema: [{
      enum: ["first", "last"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          additionalProperties: {
            type: "boolean"
          }
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
      expectedCommaFirst: "',' should be placed first.",
      expectedCommaLast: "',' should be placed last."
    }
  },
  create(t) {
    const e = t.options[0] || "last", r = t.getSourceCode(), s = {
      ArrayPattern: !0,
      ArrowFunctionExpression: !0,
      CallExpression: !0,
      FunctionDeclaration: !0,
      FunctionExpression: !0,
      ImportDeclaration: !0,
      ObjectPattern: !0,
      NewExpression: !0
    };
    if (t.options.length === 2 && Object.prototype.hasOwnProperty.call(t.options[1], "exceptions")) {
      const u = Object.keys(t.options[1].exceptions);
      for (let c = 0; c < u.length; c++)
        s[u[c]] = t.options[1].exceptions[u[c]];
    }
    function n(u, c) {
      switch (u) {
        case "between":
          return `,${c.replace(E.LINEBREAK_MATCHER, "")}`;
        case "first":
          return `${c},`;
        case "last":
          return `,${c}`;
        default:
          return "";
      }
    }
    function a(u, c, f, h) {
      const p = r.text.slice(c.range[1], f.range[0]) + r.text.slice(f.range[1], h.range[0]), m = [c.range[1], h.range[0]];
      return function(d) {
        return d.replaceTextRange(m, n(u, p));
      };
    }
    function o(u, c, f, h) {
      if (!(E.isTokenOnSameLine(c, f) && E.isTokenOnSameLine(u, c)))
        if (!E.isTokenOnSameLine(c, f) && !E.isTokenOnSameLine(u, c)) {
          const p = r.getCommentsAfter(c)[0], m = p && p.type === "Block" && E.isTokenOnSameLine(c, p) ? e : "between";
          t.report({
            node: h,
            loc: c.loc,
            messageId: "unexpectedLineBeforeAndAfterComma",
            fix: a(m, u, c, f)
          });
        } else
          e === "first" && !E.isTokenOnSameLine(c, f) ? t.report({
            node: h,
            loc: c.loc,
            messageId: "expectedCommaFirst",
            fix: a(e, u, c, f)
          }) : e === "last" && E.isTokenOnSameLine(c, f) && t.report({
            node: h,
            loc: c.loc,
            messageId: "expectedCommaLast",
            fix: a(e, u, c, f)
          });
    }
    function l(u, c) {
      const f = u[c], h = u.type === "ArrayExpression" || u.type === "ArrayPattern";
      if (f.length > 1 || h) {
        let p = r.getFirstToken(u);
        if (f.forEach((m) => {
          const d = m ? r.getTokenBefore(m) : p, g = m ? r.getFirstToken(m) : r.getTokenAfter(d);
          if (E.isCommaToken(d) && o(p, d, g, m || g), m) {
            const y = r.getTokenAfter(m, E.isNotClosingParenToken);
            p = y ? r.getTokenBefore(y) : r.ast.tokens[r.ast.tokens.length - 1];
          } else
            p = g;
        }), h) {
          const m = r.getLastToken(u), d = r.getTokenBefore(m);
          E.isCommaToken(d) && o(r.getTokenBefore(d), d, m, m);
        }
      }
    }
    const i = {};
    return s.VariableDeclaration || (i.VariableDeclaration = function(u) {
      l(u, "declarations");
    }), s.ObjectExpression || (i.ObjectExpression = function(u) {
      l(u, "properties");
    }), s.ObjectPattern || (i.ObjectPattern = function(u) {
      l(u, "properties");
    }), s.ArrayExpression || (i.ArrayExpression = function(u) {
      l(u, "elements");
    }), s.ArrayPattern || (i.ArrayPattern = function(u) {
      l(u, "elements");
    }), s.FunctionDeclaration || (i.FunctionDeclaration = function(u) {
      l(u, "params");
    }), s.FunctionExpression || (i.FunctionExpression = function(u) {
      l(u, "params");
    }), s.ArrowFunctionExpression || (i.ArrowFunctionExpression = function(u) {
      l(u, "params");
    }), s.CallExpression || (i.CallExpression = function(u) {
      l(u, "arguments");
    }), s.ImportDeclaration || (i.ImportDeclaration = function(u) {
      l(u, "specifiers");
    }), s.NewExpression || (i.NewExpression = function(u) {
      l(u, "arguments");
    }), i;
  }
};
hc.meta;
hc.create;
function SR(t) {
  return t.length <= 1 ? t.toUpperCase() : t[0].toUpperCase() + t.slice(1);
}
var Xs = {
  upperCaseFirst: SR
};
const {
  upperCaseFirst: AR
} = Xs;
var mc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum cyclomatic complexity allowed in a program",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/complexity"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."
    }
  },
  create(t) {
    const e = t.options[0];
    let r = 20;
    typeof e == "object" && (Object.prototype.hasOwnProperty.call(e, "maximum") || Object.prototype.hasOwnProperty.call(e, "max")) ? r = e.maximum || e.max : typeof e == "number" && (r = e);
    const s = [];
    function n() {
      s.push(1);
    }
    function a(l) {
      const i = AR(E.getFunctionNameWithKind(l)), u = s.pop();
      u > r && t.report({
        node: l,
        messageId: "complex",
        data: {
          name: i,
          complexity: u,
          max: r
        }
      });
    }
    function o() {
      s.length && s[s.length - 1]++;
    }
    return {
      FunctionDeclaration: n,
      FunctionExpression: n,
      ArrowFunctionExpression: n,
      "FunctionDeclaration:exit": a,
      "FunctionExpression:exit": a,
      "ArrowFunctionExpression:exit": a,
      CatchClause: o,
      ConditionalExpression: o,
      LogicalExpression: o,
      ForStatement: o,
      ForInStatement: o,
      ForOfStatement: o,
      IfStatement: o,
      SwitchCase: function(l) {
        l.test && o();
      },
      WhileStatement: o,
      DoWhileStatement: o,
      AssignmentExpression(l) {
        E.isLogicalAssignmentOperator(l.operator) && o();
      }
    };
  }
};
mc.meta;
mc.create;
var dc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside computed property brackets",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/computed-property-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        enforceForClassMembers: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
      missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
      missingSpaceAfter: "A space is required after '{{tokenValue}}'."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] === "always", s = !t.options[1] || t.options[1].enforceForClassMembers;
    function n(c, f, h) {
      t.report({
        node: c,
        loc: {
          start: f.loc.end,
          end: h.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: {
          tokenValue: f.value
        },
        fix(p) {
          return p.removeRange([f.range[1], h.range[0]]);
        }
      });
    }
    function a(c, f, h) {
      t.report({
        node: c,
        loc: {
          start: h.loc.end,
          end: f.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: {
          tokenValue: f.value
        },
        fix(p) {
          return p.removeRange([h.range[1], f.range[0]]);
        }
      });
    }
    function o(c, f) {
      t.report({
        node: c,
        loc: f.loc,
        messageId: "missingSpaceAfter",
        data: {
          tokenValue: f.value
        },
        fix(h) {
          return h.insertTextAfter(f, " ");
        }
      });
    }
    function l(c, f) {
      t.report({
        node: c,
        loc: f.loc,
        messageId: "missingSpaceBefore",
        data: {
          tokenValue: f.value
        },
        fix(h) {
          return h.insertTextBefore(f, " ");
        }
      });
    }
    function i(c) {
      return function(f) {
        if (!f.computed)
          return;
        const h = f[c], p = e.getTokenBefore(h, E.isOpeningBracketToken), m = e.getTokenAfter(p, {
          includeComments: !0
        }), d = e.getTokenAfter(h, E.isClosingBracketToken), g = e.getTokenBefore(d, {
          includeComments: !0
        });
        E.isTokenOnSameLine(p, m) && (r ? !e.isSpaceBetweenTokens(p, m) && E.isTokenOnSameLine(p, m) && o(f, p) : e.isSpaceBetweenTokens(p, m) && n(f, p, m)), E.isTokenOnSameLine(g, d) && (r ? !e.isSpaceBetweenTokens(g, d) && E.isTokenOnSameLine(g, d) && l(f, d) : e.isSpaceBetweenTokens(g, d) && a(f, d, g));
      };
    }
    const u = {
      Property: i("key"),
      MemberExpression: i("property")
    };
    return s && (u.MethodDefinition = i("key")), u;
  }
};
dc.meta;
dc.create;
const {
  upperCaseFirst: DR
} = Xs;
function wR(t) {
  return !t.reachable;
}
function kR(t) {
  return t.type === "FunctionExpression" && t.parent && t.parent.type === "MethodDefinition" && t.parent.kind === "constructor";
}
var gc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `return` statements to either always or never specify values",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/consistent-return"
    },
    schema: [{
      type: "object",
      properties: {
        treatUndefinedAsUnspecified: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missingReturn: "Expected to return a value at the end of {{name}}.",
      missingReturnValue: "{{name}} expected a return value.",
      unexpectedReturnValue: "{{name}} expected no return value."
    }
  },
  create(t) {
    const r = (t.options[0] || {}).treatUndefinedAsUnspecified === !0;
    let s = null;
    function n(a) {
      let o, l;
      !s.hasReturnValue || s.codePath.currentSegments.every(wR) || E.isES5Constructor(a) || kR(a) || (a.type === "Program" ? (o = {
        line: 1,
        column: 0
      }, l = "program") : a.type === "ArrowFunctionExpression" ? o = t.getSourceCode().getTokenBefore(a.body, E.isArrowToken).loc : a.parent.type === "MethodDefinition" || a.parent.type === "Property" && a.parent.method ? o = a.parent.key.loc : o = (a.id || t.getSourceCode().getFirstToken(a)).loc, l || (l = E.getFunctionNameWithKind(a)), t.report({
        node: a,
        loc: o,
        messageId: "missingReturn",
        data: {
          name: l
        }
      }));
    }
    return {
      onCodePathStart(a, o) {
        s = {
          upper: s,
          codePath: a,
          hasReturn: !1,
          hasReturnValue: !1,
          messageId: "",
          node: o
        };
      },
      onCodePathEnd() {
        s = s.upper;
      },
      ReturnStatement(a) {
        const o = a.argument;
        let l = !!o;
        r && l && (l = !E.isSpecificId(o, "undefined") && o.operator !== "void"), s.hasReturn ? s.hasReturnValue !== l && t.report({
          node: a,
          messageId: s.messageId,
          data: s.data
        }) : (s.hasReturn = !0, s.hasReturnValue = l, s.messageId = l ? "missingReturnValue" : "unexpectedReturnValue", s.data = {
          name: s.node.type === "Program" ? "Program" : DR(E.getFunctionNameWithKind(s.node))
        });
      },
      "Program:exit": n,
      "FunctionDeclaration:exit": n,
      "FunctionExpression:exit": n,
      "ArrowFunctionExpression:exit": n
    };
  }
};
gc.meta;
gc.create;
var yc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent naming when capturing the current execution context",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/consistent-this"
    },
    schema: {
      type: "array",
      items: {
        type: "string",
        minLength: 1
      },
      uniqueItems: !0
    },
    messages: {
      aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
      unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
    }
  },
  create(t) {
    let e = [];
    t.options.length === 0 ? e.push("that") : e = t.options;
    function r(o, l) {
      t.report({
        node: o,
        messageId: "aliasNotAssignedToThis",
        data: {
          name: l
        }
      });
    }
    function s(o, l, i) {
      const u = i.type === "ThisExpression";
      e.indexOf(l) !== -1 ? (!u || o.operator && o.operator !== "=") && r(o, l) : u && t.report({
        node: o,
        messageId: "unexpectedAlias",
        data: {
          name: l
        }
      });
    }
    function n(o, l) {
      const i = l.set.get(o);
      i && (i.defs.some((u) => u.node.type === "VariableDeclarator" && u.node.init !== null) || i.references.some((u) => {
        const c = u.writeExpr;
        return u.from === l && c && c.type === "ThisExpression" && c.parent.operator === "=";
      }) || i.defs.map((u) => u.node).forEach((u) => {
        r(u, o);
      }));
    }
    function a() {
      const o = t.getScope();
      e.forEach((l) => {
        n(l, o);
      });
    }
    return {
      "Program:exit": a,
      "FunctionExpression:exit": a,
      "FunctionDeclaration:exit": a,
      VariableDeclarator(o) {
        const l = o.id, i = l.type === "ArrayPattern" || l.type === "ObjectPattern";
        o.init !== null && !i && s(o, l.name, o.init);
      },
      AssignmentExpression(o) {
        o.left.type === "Identifier" && s(o, o.left.name, o.right);
      }
    };
  }
};
yc.meta;
yc.create;
function TR(t) {
  return t.reachable;
}
function FR(t) {
  return t.type === "FunctionExpression" && t.parent.type === "MethodDefinition" && t.parent.kind === "constructor";
}
function Sr(t) {
  if (!t)
    return !1;
  switch (t.type) {
    case "ClassExpression":
    case "FunctionExpression":
    case "ThisExpression":
    case "MemberExpression":
    case "CallExpression":
    case "NewExpression":
    case "ChainExpression":
    case "YieldExpression":
    case "TaggedTemplateExpression":
    case "MetaProperty":
      return !0;
    case "Identifier":
      return t.name !== "undefined";
    case "AssignmentExpression":
      return ["=", "&&="].includes(t.operator) ? Sr(t.right) : ["||=", "??="].includes(t.operator) ? Sr(t.left) || Sr(t.right) : !1;
    case "LogicalExpression":
      return t.operator === "&&" ? Sr(t.right) : Sr(t.left) || Sr(t.right);
    case "ConditionalExpression":
      return Sr(t.alternate) || Sr(t.consequent);
    case "SequenceExpression": {
      const e = t.expressions[t.expressions.length - 1];
      return Sr(e);
    }
    default:
      return !1;
  }
}
var xc = {
  meta: {
    type: "problem",
    docs: {
      description: "require `super()` calls in constructors",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/constructor-super"
    },
    schema: [],
    messages: {
      missingSome: "Lacked a call of 'super()' in some code paths.",
      missingAll: "Expected to call 'super()'.",
      duplicate: "Unexpected duplicate 'super()'.",
      badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
      unexpected: "Unexpected 'super()'."
    }
  },
  create(t) {
    let e = null, r = /* @__PURE__ */ Object.create(null);
    function s(a) {
      return a.reachable && r[a.id].calledInSomePaths;
    }
    function n(a) {
      return a.nextSegments.length === 1 && a.nextSegments[0].isLoopedPrevSegment(a) ? !0 : a.reachable && r[a.id].calledInEveryPaths;
    }
    return {
      onCodePathStart(a, o) {
        if (FR(o)) {
          const i = o.parent.parent.parent.superClass;
          e = {
            upper: e,
            isConstructor: !0,
            hasExtends: !!i,
            superIsConstructor: Sr(i),
            codePath: a
          };
        } else
          e = {
            upper: e,
            isConstructor: !1,
            hasExtends: !1,
            superIsConstructor: !1,
            codePath: a
          };
      },
      onCodePathEnd(a, o) {
        const l = e.hasExtends;
        if (e = e.upper, !l)
          return;
        const i = a.returnedSegments, u = i.every(n), c = i.some(s);
        u || t.report({
          messageId: c ? "missingSome" : "missingAll",
          node: o.parent
        });
      },
      onCodePathSegmentStart(a) {
        if (!(e && e.isConstructor && e.hasExtends))
          return;
        const o = r[a.id] = {
          calledInSomePaths: !1,
          calledInEveryPaths: !1,
          validNodes: []
        }, l = a.prevSegments;
        l.length > 0 && (o.calledInSomePaths = l.some(s), o.calledInEveryPaths = l.every(n));
      },
      onCodePathSegmentLoop(a, o) {
        if (!(e && e.isConstructor && e.hasExtends))
          return;
        const l = o.prevSegments.length >= 2;
        e.codePath.traverseSegments({
          first: o,
          last: a
        }, (i) => {
          const u = r[i.id], c = i.prevSegments;
          if (u.calledInSomePaths = c.some(s), u.calledInEveryPaths = c.every(n), u.calledInSomePaths || l) {
            const f = u.validNodes;
            u.validNodes = [];
            for (let h = 0; h < f.length; ++h) {
              const p = f[h];
              t.report({
                messageId: "duplicate",
                node: p
              });
            }
          }
        });
      },
      "CallExpression:exit"(a) {
        if (e && e.isConstructor && a.callee.type === "Super")
          if (e.hasExtends) {
            const o = e.codePath.currentSegments;
            let l = !1, i = null;
            for (let u = 0; u < o.length; ++u) {
              const c = o[u];
              c.reachable && (i = r[c.id], l = l || i.calledInSomePaths, i.calledInSomePaths = i.calledInEveryPaths = !0);
            }
            i && (l ? t.report({
              messageId: "duplicate",
              node: a
            }) : e.superIsConstructor ? i.validNodes.push(a) : t.report({
              messageId: "badSuper",
              node: a
            }));
          } else
            e.codePath.currentSegments.some(TR) && t.report({
              messageId: "unexpected",
              node: a
            });
      },
      ReturnStatement(a) {
        if (!(e && e.isConstructor && e.hasExtends) || !a.argument)
          return;
        const o = e.codePath.currentSegments;
        for (let l = 0; l < o.length; ++l) {
          const i = o[l];
          if (i.reachable) {
            const u = r[i.id];
            u.calledInSomePaths = u.calledInEveryPaths = !0;
          }
        }
      },
      "Program:exit"() {
        r = /* @__PURE__ */ Object.create(null);
      }
    };
  }
};
xc.meta;
xc.create;
var vc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent brace style for all control statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/curly"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["all"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["multi", "multi-line", "multi-or-nest"]
        }, {
          enum: ["consistent"]
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      missingCurlyAfter: "Expected { after '{{name}}'.",
      missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
      unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
      unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
    }
  },
  create(t) {
    const e = t.options[0] === "multi", r = t.options[0] === "multi-line", s = t.options[0] === "multi-or-nest", n = t.options[1] === "consistent", a = t.getSourceCode();
    function o(g) {
      const y = a.getTokenBefore(g), x = a.getLastToken(g), A = E.isSemicolonToken(x) ? a.getTokenBefore(x) : x;
      return y.loc.start.line === A.loc.end.line;
    }
    function l(g) {
      if (g.type === "EmptyStatement")
        return !0;
      const y = a.getFirstToken(g), x = a.getLastToken(g), A = E.isSemicolonToken(x) ? a.getTokenBefore(x) : x;
      return y.loc.start.line === A.loc.end.line;
    }
    function i(g) {
      return g.type === "VariableDeclaration" ? g.kind === "const" || g.kind === "let" : g.type === "FunctionDeclaration" || g.type === "ClassDeclaration";
    }
    function u(g) {
      return g.value === "else" && g.type === "Keyword";
    }
    function c(g) {
      const y = a.getTokenAfter(g);
      return !!y && u(y);
    }
    function f(g) {
      const y = a.getTokenBefore(g), x = a.getTokenAfter(g), A = a.getNodeByRangeIndex(y.range[0]);
      return E.isSemicolonToken(y) || !x || A.type === "BlockStatement" && A.parent.type !== "FunctionExpression" && A.parent.type !== "ArrowFunctionExpression" ? !1 : !!(y.loc.end.line === x.loc.start.line || /^[([/`+-]/u.test(x.value) || y.type === "Punctuator" && (y.value === "++" || y.value === "--"));
    }
    function h(g) {
      switch (g.type) {
        case "IfStatement":
          return g.alternate ? h(g.alternate) : !0;
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
        case "LabeledStatement":
        case "WithStatement":
        case "WhileStatement":
          return h(g.body);
        default:
          return !1;
      }
    }
    function p(g) {
      const y = g.body[0];
      return i(y) || h(y) && c(g);
    }
    function m(g, y, x, A) {
      const b = y.type === "BlockStatement";
      let v = null;
      if (b && (y.body.length !== 1 || p(y)))
        v = !0;
      else if (e)
        v = !1;
      else if (r)
        o(y) || (v = !0);
      else if (s)
        if (b) {
          const C = y.body[0], T = a.getCommentsBefore(C);
          v = !l(C) || T.length > 0;
        } else
          v = !l(y);
      else
        v = !0;
      return {
        actual: b,
        expected: v,
        check() {
          this.expected !== null && this.expected !== this.actual && (this.expected ? t.report({
            node: g,
            loc: y.loc,
            messageId: A && A.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
            data: {
              name: x
            },
            fix: (C) => C.replaceText(y, `{${a.getText(y)}}`)
          }) : t.report({
            node: g,
            loc: y.loc,
            messageId: A && A.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
            data: {
              name: x
            },
            fix(C) {
              const T = g.type === "DoWhileStatement" && a.getTokenBefore(y).range[1] === y.range[0] && !E.canTokensBeAdjacent("do", a.getFirstToken(y, {
                skip: 1
              })), w = a.getFirstToken(y), B = a.getLastToken(y), I = a.getTokenBefore(B);
              if (f(B))
                return null;
              const _ = a.getText().slice(w.range[1], I.range[0]) + a.getText(I) + a.getText().slice(I.range[1], B.range[0]);
              return C.replaceText(y, (T ? " " : "") + _);
            }
          }));
        }
      };
    }
    function d(g) {
      const y = [];
      for (let x = g; x; x = x.alternate)
        if (y.push(m(x, x.consequent, "if", {
          condition: !0
        })), x.alternate && x.alternate.type !== "IfStatement") {
          y.push(m(x, x.alternate, "else"));
          break;
        }
      if (n) {
        const x = y.some((A) => A.expected !== null ? A.expected : A.actual);
        y.forEach((A) => {
          A.expected = x;
        });
      }
      return y;
    }
    return {
      IfStatement(g) {
        const y = g.parent;
        y.type === "IfStatement" && y.alternate === g || d(g).forEach((A) => {
          A.check();
        });
      },
      WhileStatement(g) {
        m(g, g.body, "while", {
          condition: !0
        }).check();
      },
      DoWhileStatement(g) {
        m(g, g.body, "do").check();
      },
      ForStatement(g) {
        m(g, g.body, "for", {
          condition: !0
        }).check();
      },
      ForInStatement(g) {
        m(g, g.body, "for-in").check();
      },
      ForOfStatement(g) {
        m(g, g.body, "for-of").check();
      }
    };
  }
};
vc.meta;
vc.create;
var Ec = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce default clauses in switch statements to be last",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/default-case-last"
    },
    schema: [],
    messages: {
      notLast: "Default clause should be the last clause."
    }
  },
  create(t) {
    return {
      SwitchStatement(e) {
        const r = e.cases, s = r.findIndex((n) => n.test === null);
        if (s !== -1 && s !== r.length - 1) {
          const n = r[s];
          t.report({
            node: n,
            messageId: "notLast"
          });
        }
      }
    };
  }
};
Ec.meta;
Ec.create;
const PR = /^no default$/iu;
var bc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `default` cases in `switch` statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/default-case"
    },
    schema: [{
      type: "object",
      properties: {
        commentPattern: {
          type: "string"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missingDefaultCase: "Expected a default case."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.commentPattern ? new RegExp(e.commentPattern, "u") : PR, s = t.getSourceCode();
    function n(a) {
      return a[a.length - 1];
    }
    return {
      SwitchStatement(a) {
        if (!a.cases.length)
          return;
        if (!a.cases.some((l) => l.test === null)) {
          let l;
          const i = n(a.cases), u = s.getCommentsAfter(i);
          u.length && (l = n(u)), (!l || !r.test(l.value.trim())) && t.report({
            node: a,
            messageId: "missingDefaultCase"
          });
        }
      }
    };
  }
};
bc.meta;
bc.create;
var Cc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce default parameters to be last",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/default-param-last"
    },
    schema: [],
    messages: {
      shouldBeLast: "Default parameters should be last."
    }
  },
  create(t) {
    function e(r) {
      let s = !1;
      for (let n = r.params.length - 1; n >= 0; n -= 1) {
        const a = r.params[n];
        if (a.type !== "AssignmentPattern" && a.type !== "RestElement") {
          s = !0;
          continue;
        }
        s && a.type === "AssignmentPattern" && t.report({
          node: a,
          messageId: "shouldBeLast"
        });
      }
    }
    return {
      FunctionDeclaration: e,
      FunctionExpression: e,
      ArrowFunctionExpression: e
    };
  }
};
Cc.meta;
Cc.create;
var Sc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent newlines before and after dots",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/dot-location"
    },
    schema: [{
      enum: ["object", "property"]
    }],
    fixable: "code",
    messages: {
      expectedDotAfterObject: "Expected dot to be on same line as object.",
      expectedDotBeforeProperty: "Expected dot to be on same line as property."
    }
  },
  create(t) {
    const e = t.options[0], r = t.getSourceCode();
    function s(n) {
      const a = n.property, o = r.getTokenBefore(a);
      if (e === "object" || !e) {
        const l = r.getTokenBefore(o);
        E.isTokenOnSameLine(l, o) || t.report({
          node: n,
          loc: o.loc,
          messageId: "expectedDotAfterObject",
          *fix(i) {
            o.value.startsWith(".") && E.isDecimalIntegerNumericToken(l) ? yield i.insertTextAfter(l, ` ${o.value}`) : yield i.insertTextAfter(l, o.value), yield i.remove(o);
          }
        });
      } else
        E.isTokenOnSameLine(o, a) || t.report({
          node: n,
          loc: o.loc,
          messageId: "expectedDotBeforeProperty",
          *fix(l) {
            yield l.remove(o), yield l.insertTextBefore(a, o.value);
          }
        });
    }
    return {
      MemberExpression: function(n) {
        n.computed || s(n);
      }
    };
  }
};
Sc.meta;
Sc.create;
var si = ["abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"];
const IR = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u, _R = /* @__PURE__ */ new Set(["string", "boolean"]);
var Ac = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce dot notation whenever possible",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/dot-notation"
    },
    schema: [{
      type: "object",
      properties: {
        allowKeywords: {
          type: "boolean",
          default: !0
        },
        allowPattern: {
          type: "string",
          default: ""
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      useDot: "[{{key}}] is better written in dot notation.",
      useBrackets: ".{{key}} is a syntax error."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allowKeywords === void 0 || e.allowKeywords, s = t.getSourceCode();
    let n;
    e.allowPattern && (n = new RegExp(e.allowPattern, "u"));
    function a(o, l) {
      if (IR.test(l) && (r || si.indexOf(String(l)) === -1) && !(n && n.test(l))) {
        const i = o.property.type === "Literal" ? JSON.stringify(l) : `\`${l}\``;
        t.report({
          node: o.property,
          messageId: "useDot",
          data: {
            key: i
          },
          *fix(u) {
            const c = s.getTokenAfter(o.object, E.isOpeningBracketToken), f = s.getLastToken(o), h = s.getTokenAfter(o);
            s.commentsExistBetween(c, f) || (o.optional || (yield u.insertTextBefore(c, E.isDecimalInteger(o.object) ? " ." : ".")), yield u.replaceTextRange([c.range[0], f.range[1]], l), h && f.range[1] === h.range[0] && !E.canTokensBeAdjacent(String(l), h) && (yield u.insertTextAfter(o, " ")));
          }
        });
      }
    }
    return {
      MemberExpression(o) {
        o.computed && o.property.type === "Literal" && (_R.has(typeof o.property.value) || E.isNullLiteral(o.property)) && a(o, o.property.value), o.computed && o.property.type === "TemplateLiteral" && o.property.expressions.length === 0 && a(o, o.property.quasis[0].value.cooked), !r && !o.computed && si.indexOf(String(o.property.name)) !== -1 && t.report({
          node: o.property,
          messageId: "useBrackets",
          data: {
            key: o.property.name
          },
          *fix(l) {
            const i = s.getTokenBefore(o.property);
            o.object.type === "Identifier" && o.object.name === "let" && !o.optional || s.commentsExistBetween(i, o.property) || (o.optional || (yield l.remove(i)), yield l.replaceText(o.property, `["${o.property.name}"]`));
          }
        });
      }
    };
  }
};
Ac.meta;
Ac.create;
var Dc = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow newline at the end of files",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/eol-last"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never", "unix", "windows"]
    }],
    messages: {
      missing: "Newline required at end of file but not found.",
      unexpected: "Newline not allowed at end of file."
    }
  },
  create(t) {
    return {
      Program: function(e) {
        const r = t.getSourceCode(), s = r.getText(), n = r.lines[r.lines.length - 1], a = {
          column: n.length,
          line: r.lines.length
        }, o = s.endsWith(`
`);
        if (!s.length)
          return;
        let l = t.options[0] || "always", i = !1;
        l === "unix" && (l = "always"), l === "windows" && (l = "always", i = !0), l === "always" && !o ? t.report({
          node: e,
          loc: a,
          messageId: "missing",
          fix(u) {
            return u.insertTextAfterRange([0, s.length], i ? `\r
` : `
`);
          }
        }) : l === "never" && o && t.report({
          node: e,
          loc: a,
          messageId: "unexpected",
          fix(u) {
            const c = /(?:\r?\n)+$/u.exec(r.text), f = c.index, h = r.text.length;
            return u.replaceTextRange([f, h], "");
          }
        });
      }
    };
  }
};
Dc.meta;
Dc.create;
var wc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require the use of `===` and `!==`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/eqeqeq"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            null: {
              enum: ["always", "never", "ignore"]
            }
          },
          additionalProperties: !1
        }],
        additionalItems: !1
      }, {
        type: "array",
        items: [{
          enum: ["smart", "allow-null"]
        }],
        additionalItems: !1
      }]
    },
    fixable: "code",
    messages: {
      unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."
    }
  },
  create(t) {
    const e = t.options[0] || "always", r = t.options[1] || {}, s = t.getSourceCode(), n = e === "always" ? r.null || "always" : "ignore";
    function a(c) {
      return c.type === "UnaryExpression" && c.operator === "typeof";
    }
    function o(c) {
      return a(c.left) || a(c.right);
    }
    function l(c) {
      return c.left.type === "Literal" && c.right.type === "Literal" && typeof c.left.value == typeof c.right.value;
    }
    function i(c) {
      return E.isNullLiteral(c.right) || E.isNullLiteral(c.left);
    }
    function u(c, f) {
      const h = s.getFirstTokenBetween(c.left, c.right, (p) => p.value === c.operator);
      t.report({
        node: c,
        loc: h.loc,
        messageId: "unexpected",
        data: {
          expectedOperator: f,
          actualOperator: c.operator
        },
        fix(p) {
          return o(c) || l(c) ? p.replaceText(h, f) : null;
        }
      });
    }
    return {
      BinaryExpression(c) {
        const f = i(c);
        if (c.operator !== "==" && c.operator !== "!=") {
          n === "never" && f && u(c, c.operator.slice(0, -1));
          return;
        }
        e === "smart" && (o(c) || l(c) || f) || n !== "always" && f || u(c, `${c.operator}=`);
      }
    };
  }
};
wc.meta;
wc.create;
var kc = {
  meta: {
    type: "problem",
    docs: {
      description: 'enforce "for" loop update clause moving the counter in the right direction.',
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/for-direction"
    },
    fixable: null,
    schema: [],
    messages: {
      incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
    }
  },
  create(t) {
    function e(a) {
      t.report({
        node: a,
        messageId: "incorrectDirection"
      });
    }
    function r(a, o) {
      if (a.right.type === "UnaryExpression") {
        if (a.right.operator === "-")
          return -o;
      } else if (a.right.type === "Identifier")
        return 0;
      return o;
    }
    function s(a, o) {
      if (a.argument.type === "Identifier" && a.argument.name === o) {
        if (a.operator === "++")
          return 1;
        if (a.operator === "--")
          return -1;
      }
      return 0;
    }
    function n(a, o) {
      if (a.left.name === o) {
        if (a.operator === "+=")
          return r(a, 1);
        if (a.operator === "-=")
          return r(a, -1);
      }
      return 0;
    }
    return {
      ForStatement(a) {
        if (a.test && a.test.type === "BinaryExpression" && a.test.left.type === "Identifier" && a.update) {
          const o = a.test.left.name, l = a.test.operator, i = a.update;
          let u;
          if (l === "<" || l === "<=")
            u = -1;
          else if (l === ">" || l === ">=")
            u = 1;
          else
            return;
          i.type === "UpdateExpression" ? s(i, o) === u && e(a) : i.type === "AssignmentExpression" && n(i, o) === u && e(a);
        }
      }
    };
  }
};
kc.meta;
kc.create;
var Tc = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing between function identifiers and their invocations",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/func-call-spacing"
    },
    fixable: "whitespace",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["never"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            allowNewlines: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
      unexpectedNewline: "Unexpected newline between function name and paren.",
      missing: "Missing space between function name and paren."
    }
  },
  create(t) {
    const e = t.options[0] !== "always", r = !e && t.options[1] && t.options[1].allowNewlines, s = t.getSourceCode(), n = s.getText();
    function a(o, l, i) {
      const u = n.slice(l.range[1], i.range[0]).replace(/\/\*.*?\*\//gu, ""), c = /\s/u.test(u), f = c && E.LINEBREAK_MATCHER.test(u);
      e && c ? t.report({
        node: o,
        loc: {
          start: l.loc.end,
          end: {
            line: i.loc.start.line,
            column: i.loc.start.column - 1
          }
        },
        messageId: "unexpectedWhitespace",
        fix(h) {
          return s.commentsExistBetween(l, i) ? null : o.optional ? h.replaceTextRange([l.range[1], i.range[0]], "?.") : f ? null : h.removeRange([l.range[1], i.range[0]]);
        }
      }) : !e && !c ? t.report({
        node: o,
        loc: {
          start: {
            line: l.loc.end.line,
            column: l.loc.end.column - 1
          },
          end: i.loc.start
        },
        messageId: "missing",
        fix(h) {
          return o.optional ? null : h.insertTextBefore(i, " ");
        }
      }) : !e && !r && f && t.report({
        node: o,
        loc: {
          start: l.loc.end,
          end: i.loc.start
        },
        messageId: "unexpectedNewline",
        fix(h) {
          if (!o.optional || s.commentsExistBetween(l, i))
            return null;
          const p = [l.range[1], i.range[0]], m = s.getTokenAfter(l);
          return m.range[0] === l.range[1] ? h.replaceTextRange(p, "?. ") : m.range[1] === i.range[0] ? h.replaceTextRange(p, " ?.") : h.replaceTextRange(p, " ?. ");
        }
      });
    }
    return {
      "CallExpression, NewExpression"(o) {
        const l = s.getLastToken(o), i = s.getLastToken(o.callee), u = s.getFirstTokenBetween(i, l, E.isOpeningParenToken), c = u && s.getTokenBefore(u, E.isNotQuestionDotToken);
        u && u.range[1] < o.range[1] && a(o, c, u);
      },
      ImportExpression(o) {
        const l = s.getFirstToken(o), i = s.getTokenAfter(l);
        a(o, l, i);
      }
    };
  }
};
Tc.meta;
Tc.create;
function BR(t) {
  return t.type === "MemberExpression" && t.object.type === "Identifier" && t.object.name === "module" && (t.property.type === "Identifier" && t.property.name === "exports" || t.property.type === "Literal" && t.property.value === "exports");
}
function xy(t, e) {
  return e >= 6 ? Il.default.keyword.isIdentifierES6(t) : Il.default.keyword.isIdentifierES5(t);
}
const OR = {
  enum: ["always", "never"]
}, vy = {
  type: "object",
  properties: {
    considerPropertyDescriptor: {
      type: "boolean"
    },
    includeCommonJSModuleExports: {
      type: "boolean"
    }
  },
  additionalProperties: !1
};
var Fc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require function names to match the name of the variable or property to which they are assigned",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/func-name-matching"
    },
    schema: {
      anyOf: [{
        type: "array",
        additionalItems: !1,
        items: [OR, vy]
      }, {
        type: "array",
        additionalItems: !1,
        items: [vy]
      }]
    },
    messages: {
      matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
      matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
      notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
      notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
    }
  },
  create(t) {
    const e = (typeof t.options[0] == "object" ? t.options[0] : t.options[1]) || {}, r = typeof t.options[0] == "string" ? t.options[0] : "always", s = e.considerPropertyDescriptor, n = e.includeCommonJSModuleExports, a = t.parserOptions && t.parserOptions.ecmaVersion ? t.parserOptions.ecmaVersion : 5;
    function o(c, f, h) {
      return h ? h.type === "CallExpression" && E.isSpecificMemberAccess(h.callee, c, f) : !1;
    }
    function l(c, f) {
      return r === "always" && c !== f || r === "never" && c === f;
    }
    function i(c, f, h, p) {
      let m;
      r === "always" && p ? m = "matchProperty" : r === "always" ? m = "matchVariable" : p ? m = "notMatchProperty" : m = "notMatchVariable", t.report({
        node: c,
        messageId: m,
        data: {
          name: f,
          funcName: h
        }
      });
    }
    function u(c) {
      return c.type === "Literal" && typeof c.value == "string";
    }
    return {
      VariableDeclarator(c) {
        !c.init || c.init.type !== "FunctionExpression" || c.id.type !== "Identifier" || c.init.id && l(c.id.name, c.init.id.name) && i(c, c.id.name, c.init.id.name, !1);
      },
      AssignmentExpression(c) {
        if (c.right.type !== "FunctionExpression" || c.left.computed && c.left.property.type !== "Literal" || !n && BR(c.left) || c.left.type !== "Identifier" && c.left.type !== "MemberExpression")
          return;
        const f = c.left.type === "MemberExpression", h = f ? E.getStaticPropertyName(c.left) : c.left.name;
        c.right.id && xy(h) && l(h, c.right.id.name) && i(c, h, c.right.id.name, f);
      },
      Property(c) {
        if (!(c.value.type !== "FunctionExpression" || !c.value.id || c.computed && !u(c.key))) {
          if (c.key.type === "Identifier") {
            const f = c.value.id.name;
            let h = c.key.name;
            if (s && h === "value")
              if (o("Object", "defineProperty", c.parent.parent) || o("Reflect", "defineProperty", c.parent.parent)) {
                const p = c.parent.parent.arguments[1];
                u(p) && l(p.value, f) && i(c, p.value, f, !0);
              } else
                o("Object", "defineProperties", c.parent.parent.parent.parent) || o("Object", "create", c.parent.parent.parent.parent) ? (h = c.parent.parent.key.name, !c.parent.parent.computed && l(h, f) && i(c, h, f, !0)) : l(h, f) && i(c, h, f, !0);
            else
              l(h, f) && i(c, h, f, !0);
            return;
          }
          u(c.key) && xy(c.key.value, a) && l(c.key.value, c.value.id.name) && i(c, c.key.value, c.value.id.name, !0);
        }
      }
    };
  }
};
Fc.meta;
Fc.create;
function LR(t) {
  return t && t.defs[0].type === "FunctionName";
}
var Pc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow named `function` expressions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/func-names"
    },
    schema: {
      definitions: {
        value: {
          enum: ["always", "as-needed", "never"]
        }
      },
      items: [{
        $ref: "#/definitions/value"
      }, {
        type: "object",
        properties: {
          generators: {
            $ref: "#/definitions/value"
          }
        },
        additionalProperties: !1
      }]
    },
    messages: {
      unnamed: "Unexpected unnamed {{name}}.",
      named: "Unexpected named {{name}}."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(i) {
      return i.generator && t.options.length > 1 && t.options[1].generators ? t.options[1].generators : t.options[0] || "always";
    }
    function s(i) {
      const u = i.parent;
      return u.type === "MethodDefinition" || u.type === "Property" && (u.method || u.kind === "get" || u.kind === "set");
    }
    function n(i) {
      const u = i.parent;
      return s(i) || u.type === "VariableDeclarator" && u.id.type === "Identifier" && u.init === i || u.type === "Property" && u.value === i || u.type === "AssignmentExpression" && u.left.type === "Identifier" && u.right === i || u.type === "AssignmentPattern" && u.left.type === "Identifier" && u.right === i;
    }
    function a(i) {
      t.report({
        node: i,
        messageId: "unnamed",
        loc: E.getFunctionHeadLoc(i, e),
        data: {
          name: E.getFunctionNameWithKind(i)
        }
      });
    }
    function o(i) {
      t.report({
        node: i,
        messageId: "named",
        loc: E.getFunctionHeadLoc(i, e),
        data: {
          name: E.getFunctionNameWithKind(i)
        }
      });
    }
    function l(i) {
      const u = t.getDeclaredVariables(i)[0];
      if (LR(u) && u.references.length > 0)
        return;
      const c = !!(i.id && i.id.name), f = r(i);
      f === "never" ? c && i.type !== "FunctionDeclaration" && o(i) : f === "as-needed" ? !c && !n(i) && a(i) : !c && !s(i) && a(i);
    }
    return {
      "FunctionExpression:exit": l,
      "ExportDefaultDeclaration > FunctionDeclaration": l
    };
  }
};
Pc.meta;
Pc.create;
var Ic = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the consistent use of either `function` declarations or expressions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/func-style"
    },
    schema: [{
      enum: ["declaration", "expression"]
    }, {
      type: "object",
      properties: {
        allowArrowFunctions: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expression: "Expected a function expression.",
      declaration: "Expected a function declaration."
    }
  },
  create(t) {
    const e = t.options[0], r = t.options[1] && t.options[1].allowArrowFunctions, s = e === "declaration", n = [], a = {
      FunctionDeclaration(o) {
        n.push(!1), !s && o.parent.type !== "ExportDefaultDeclaration" && t.report({
          node: o,
          messageId: "expression"
        });
      },
      "FunctionDeclaration:exit"() {
        n.pop();
      },
      FunctionExpression(o) {
        n.push(!1), s && o.parent.type === "VariableDeclarator" && t.report({
          node: o.parent,
          messageId: "declaration"
        });
      },
      "FunctionExpression:exit"() {
        n.pop();
      },
      ThisExpression() {
        n.length > 0 && (n[n.length - 1] = !0);
      }
    };
    return r || (a.ArrowFunctionExpression = function() {
      n.push(!1);
    }, a["ArrowFunctionExpression:exit"] = function(o) {
      const l = n.pop();
      s && !l && o.parent.type === "VariableDeclarator" && t.report({
        node: o.parent,
        messageId: "declaration"
      });
    }), a;
  }
};
Ic.meta;
Ic.create;
var _c = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce line breaks between arguments of a function call",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/function-call-argument-newline"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never", "consistent"]
    }],
    messages: {
      unexpectedLineBreak: "There should be no line break here.",
      missingLineBreak: "There should be a line break after this argument."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = {
      unexpected: {
        messageId: "unexpectedLineBreak",
        check: (a, o) => a.loc.end.line !== o.loc.start.line,
        createFix: (a, o) => (l) => l.replaceTextRange([o.range[1], a.range[0]], " ")
      },
      missing: {
        messageId: "missingLineBreak",
        check: (a, o) => a.loc.end.line === o.loc.start.line,
        createFix: (a, o) => (l) => l.replaceTextRange([o.range[1], a.range[0]], `
`)
      }
    };
    function s(a, o) {
      for (let l = 1; l < a.arguments.length; l++) {
        const i = e.getLastToken(a.arguments[l - 1]), u = e.getFirstToken(a.arguments[l]);
        if (o.check(i, u)) {
          const c = e.getTokenBefore(u, {
            includeComments: !0
          }), f = c.type === "Line";
          t.report({
            node: a,
            loc: {
              start: c.loc.end,
              end: u.loc.start
            },
            messageId: o.messageId,
            fix: f ? null : o.createFix(u, c)
          });
        }
      }
    }
    function n(a) {
      if (a.arguments.length < 2)
        return;
      const o = t.options[0] || "always";
      if (o === "never")
        s(a, r.unexpected);
      else if (o === "always")
        s(a, r.missing);
      else if (o === "consistent") {
        const l = e.getLastToken(a.arguments[0]), i = e.getFirstToken(a.arguments[1]);
        l.loc.end.line === i.loc.start.line ? s(a, r.unexpected) : s(a, r.missing);
      }
    }
    return {
      CallExpression: n,
      NewExpression: n
    };
  }
};
_c.meta;
_c.create;
var Bc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks inside function parentheses",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/function-paren-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consistent", "multiline", "multiline-arguments"]
      }, {
        type: "object",
        properties: {
          minItems: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      expectedBefore: "Expected newline before ')'.",
      expectedAfter: "Expected newline after '('.",
      expectedBetween: "Expected newline between arguments/params.",
      unexpectedBefore: "Unexpected newline before ')'.",
      unexpectedAfter: "Unexpected newline after '('."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || "multiline", s = r === "multiline-arguments";
    let n;
    typeof r == "object" ? n = r.minItems : r === "always" ? n = 0 : r === "never" ? n = 1 / 0 : n = null;
    function a(u, c) {
      return s && u.length === 1 ? c : r === "multiline" || s ? u.some((f, h) => h !== u.length - 1 && f.loc.end.line !== u[h + 1].loc.start.line) : r === "consistent" ? c : u.length >= n;
    }
    function o(u, c) {
      const f = u.leftParen, h = u.rightParen, p = e.getTokenAfter(f), m = e.getTokenBefore(h), d = !E.isTokenOnSameLine(f, p), g = !E.isTokenOnSameLine(m, h), y = a(c, d);
      d && !y ? t.report({
        node: f,
        messageId: "unexpectedAfter",
        fix(x) {
          return e.getText().slice(f.range[1], p.range[0]).trim() ? null : x.removeRange([f.range[1], p.range[0]]);
        }
      }) : !d && y && t.report({
        node: f,
        messageId: "expectedAfter",
        fix: (x) => x.insertTextAfter(f, `
`)
      }), g && !y ? t.report({
        node: h,
        messageId: "unexpectedBefore",
        fix(x) {
          return e.getText().slice(m.range[1], h.range[0]).trim() ? null : x.removeRange([m.range[1], h.range[0]]);
        }
      }) : !g && y && t.report({
        node: h,
        messageId: "expectedBefore",
        fix: (x) => x.insertTextBefore(h, `
`)
      });
    }
    function l(u, c) {
      const f = u.leftParen, h = e.getTokenAfter(f), p = !E.isTokenOnSameLine(f, h), m = a(c, p);
      for (let d = 0; d <= c.length - 2; d++) {
        const g = c[d], y = c[d + 1];
        !(g.loc.end.line !== y.loc.start.line) && m && t.report({
          node: g,
          messageId: "expectedBetween",
          fix: (A) => A.insertTextBefore(y, `
`)
        });
      }
    }
    function i(u) {
      switch (u.type) {
        case "NewExpression":
          if (!u.arguments.length && !(E.isOpeningParenToken(e.getLastToken(u, {
            skip: 1
          })) && E.isClosingParenToken(e.getLastToken(u))))
            return null;
        case "CallExpression":
          return {
            leftParen: e.getTokenAfter(u.callee, E.isOpeningParenToken),
            rightParen: e.getLastToken(u)
          };
        case "FunctionDeclaration":
        case "FunctionExpression": {
          const c = e.getFirstToken(u, E.isOpeningParenToken), f = u.params.length ? e.getTokenAfter(u.params[u.params.length - 1], E.isClosingParenToken) : e.getTokenAfter(c);
          return {
            leftParen: c,
            rightParen: f
          };
        }
        case "ArrowFunctionExpression": {
          const c = e.getFirstToken(u, {
            skip: u.async ? 1 : 0
          });
          return E.isOpeningParenToken(c) ? {
            leftParen: c,
            rightParen: e.getTokenBefore(u.body, E.isClosingParenToken)
          } : null;
        }
        case "ImportExpression": {
          const c = e.getFirstToken(u, 1), f = e.getLastToken(u);
          return {
            leftParen: c,
            rightParen: f
          };
        }
        default:
          throw new TypeError(`unexpected node with type ${u.type}`);
      }
    }
    return {
      [["ArrowFunctionExpression", "CallExpression", "FunctionDeclaration", "FunctionExpression", "ImportExpression", "NewExpression"]](u) {
        const c = i(u);
        let f;
        u.type === "ImportExpression" ? f = [u.source] : E.isFunction(u) ? f = u.params : f = u.arguments, c && (o(c, f), s && l(c, f));
      }
    };
  }
};
Bc.meta;
Bc.create;
const $o = {
  oneOf: [{
    enum: ["before", "after", "both", "neither"]
  }, {
    type: "object",
    properties: {
      before: {
        type: "boolean"
      },
      after: {
        type: "boolean"
      }
    },
    additionalProperties: !1
  }]
};
var Oc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing around `*` operators in generator functions",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/generator-star-spacing"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["before", "after", "both", "neither"]
      }, {
        type: "object",
        properties: {
          before: {
            type: "boolean"
          },
          after: {
            type: "boolean"
          },
          named: $o,
          anonymous: $o,
          method: $o
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },
  create(t) {
    const e = {
      before: {
        before: !0,
        after: !1
      },
      after: {
        before: !1,
        after: !0
      },
      both: {
        before: !0,
        after: !0
      },
      neither: {
        before: !1,
        after: !1
      }
    };
    function r(c, f) {
      return c ? typeof c == "string" ? e[c] : Object.assign({}, f, c) : f;
    }
    const s = function(c) {
      const f = r(c, e.before);
      return {
        named: r(c.named, f),
        anonymous: r(c.anonymous, f),
        method: r(c.method, f)
      };
    }(t.options[0] || {}), n = t.getSourceCode();
    function a(c) {
      return c.value === "*" && c.type === "Punctuator";
    }
    function o(c) {
      return n.getFirstToken(c.parent.method || c.parent.type === "MethodDefinition" ? c.parent : c, a);
    }
    function l(c) {
      return c[0].toUpperCase() + c.slice(1);
    }
    function i(c, f, h, p) {
      if (!!(p.range[0] - h.range[1]) !== s[c][f]) {
        const m = h.value === "*", d = s[c][f], g = m ? h : p, y = `${d ? "missing" : "unexpected"}${l(f)}`;
        t.report({
          node: g,
          messageId: y,
          fix(x) {
            return d ? m ? x.insertTextAfter(g, " ") : x.insertTextBefore(g, " ") : x.removeRange([h.range[1], p.range[0]]);
          }
        });
      }
    }
    function u(c) {
      if (!c.generator)
        return;
      const f = o(c), h = n.getTokenBefore(f), p = n.getTokenAfter(f);
      let m = "named";
      c.parent.type === "MethodDefinition" || c.parent.type === "Property" && c.parent.method ? m = "method" : c.id || (m = "anonymous"), m === "method" && f === n.getFirstToken(c.parent) || i(m, "before", h, f), i(m, "after", f, p);
    }
    return {
      FunctionDeclaration: u,
      FunctionExpression: u
    };
  }
};
Oc.meta;
Oc.create;
const RR = /^(?:Arrow)?FunctionExpression$/u;
function NR(t) {
  return t.reachable;
}
var Lc = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce `return` statements in getters",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/getter-return"
    },
    fixable: null,
    schema: [{
      type: "object",
      properties: {
        allowImplicit: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expected: "Expected to return a value in {{name}}.",
      expectedAlways: "Expected {{name}} to always return a value."
    }
  },
  create(t) {
    const e = t.options[0] || {
      allowImplicit: !1
    }, r = t.getSourceCode();
    let s = {
      upper: null,
      codePath: null,
      hasReturn: !1,
      shouldCheck: !1,
      node: null
    };
    function n(o) {
      s.shouldCheck && s.codePath.currentSegments.some(NR) && t.report({
        node: o,
        loc: E.getFunctionHeadLoc(o, r),
        messageId: s.hasReturn ? "expectedAlways" : "expected",
        data: {
          name: E.getFunctionNameWithKind(s.node)
        }
      });
    }
    function a(o) {
      const l = o.parent;
      return !!(RR.test(o.type) && o.body.type === "BlockStatement" && (l.kind === "get" || l.type === "Property" && E.getStaticPropertyName(l) === "get" && l.parent.type === "ObjectExpression" && (l.parent.parent.type === "CallExpression" && E.getStaticPropertyName(l.parent.parent.callee) === "defineProperty" || l.parent.parent.type === "Property" && l.parent.parent.parent.type === "ObjectExpression" && l.parent.parent.parent.parent.type === "CallExpression" && E.getStaticPropertyName(l.parent.parent.parent.parent.callee) === "defineProperties")));
    }
    return {
      onCodePathStart(o, l) {
        s = {
          upper: s,
          codePath: o,
          hasReturn: !1,
          shouldCheck: a(l),
          node: l
        };
      },
      onCodePathEnd() {
        s = s.upper;
      },
      ReturnStatement(o) {
        s.shouldCheck && (s.hasReturn = !0, !e.allowImplicit && !o.argument && t.report({
          node: o,
          messageId: "expected",
          data: {
            name: E.getFunctionNameWithKind(s.node)
          }
        }));
      },
      "FunctionExpression:exit": n,
      "ArrowFunctionExpression:exit": n
    };
  }
};
Lc.meta;
Lc.create;
const jR = ["AssignmentExpression", "VariableDeclarator", "MemberExpression", "ExpressionStatement", "CallExpression", "ConditionalExpression", "Program", "VariableDeclaration", "ChainExpression"];
function MR(t, e) {
  const r = t.references.filter((s) => s.identifier.range[0] === e.range[0] && s.identifier.range[1] === e.range[1]);
  return r.length === 1 ? r[0] : null;
}
function $R(t, e) {
  const r = MR(t, e);
  return r && r.resolved && r.resolved.defs.length > 0;
}
var Rc = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "require `require()` calls to be placed at top-level module scope",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/global-require"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected require()."
    }
  },
  create(t) {
    return {
      CallExpression(e) {
        const r = t.getScope();
        e.callee.name === "require" && !$R(r, e.callee) && (t.getAncestors().every((n) => jR.indexOf(n.type) > -1) || t.report({
          node: e,
          messageId: "unexpected"
        }));
      }
    };
  }
};
Rc.meta;
Rc.create;
function VR(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    const s = t[r], n = e[r];
    if (s.type !== n.type || s.value !== n.value)
      return !1;
  }
  return !0;
}
function UR(t, e) {
  return typeof t == "string" && typeof e == "string" ? t === e : Array.isArray(t) && Array.isArray(e) ? VR(t, e) : !1;
}
function qR(t) {
  return t.kind === "get" || t.kind === "set";
}
var Nc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require grouped accessor pairs in object literals and classes",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/grouped-accessor-pairs"
    },
    schema: [{
      enum: ["anyOrder", "getBeforeSet", "setBeforeGet"]
    }],
    messages: {
      notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
      invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
    }
  },
  create(t) {
    const e = t.options[0] || "anyOrder", r = t.getSourceCode();
    function s(l, i, u) {
      t.report({
        node: u,
        messageId: l,
        loc: E.getFunctionHeadLoc(u.value, r),
        data: {
          formerName: E.getFunctionNameWithKind(i.value),
          latterName: E.getFunctionNameWithKind(u.value)
        }
      });
    }
    function n(l) {
      const i = E.getStaticPropertyName(l);
      return {
        key: i !== null ? i : r.getTokens(l.key),
        getters: l.kind === "get" ? [l] : [],
        setters: l.kind === "set" ? [l] : []
      };
    }
    function a(l, i) {
      const u = l.find((c) => UR(c.key, i.key));
      return u ? (u.getters.push(...i.getters), u.setters.push(...i.setters)) : l.push(i), l;
    }
    function o(l, i) {
      const u = l.filter(i).filter(qR).map(n).reduce(a, []);
      for (const {
        getters: c,
        setters: f
      } of u)
        if (c.length === 1 && f.length === 1) {
          const [h] = c, [p] = f, m = l.indexOf(h), d = l.indexOf(p), g = m < d ? h : p, y = m < d ? p : h;
          Math.abs(m - d) > 1 ? s("notGrouped", g, y) : (e === "getBeforeSet" && m > d || e === "setBeforeGet" && m < d) && s("invalidOrder", g, y);
        }
    }
    return {
      ObjectExpression(l) {
        o(l.properties, (i) => i.type === "Property");
      },
      ClassBody(l) {
        o(l.body, (i) => i.type === "MethodDefinition" && !i.static), o(l.body, (i) => i.type === "MethodDefinition" && i.static);
      }
    };
  }
};
Nc.meta;
Nc.create;
var jc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `for-in` loops to include an `if` statement",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/guard-for-in"
    },
    schema: [],
    messages: {
      wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
    }
  },
  create(t) {
    return {
      ForInStatement(e) {
        const r = e.body;
        if (r.type !== "EmptyStatement" && r.type !== "IfStatement" && !(r.type === "BlockStatement" && r.body.length === 0) && !(r.type === "BlockStatement" && r.body.length === 1 && r.body[0].type === "IfStatement")) {
          if (r.type === "BlockStatement" && r.body.length >= 1 && r.body[0].type === "IfStatement") {
            const s = r.body[0];
            if (s.consequent.type === "ContinueStatement" || s.consequent.type === "BlockStatement" && s.consequent.body.length === 1 && s.consequent.body[0].type === "ContinueStatement")
              return;
          }
          t.report({
            node: e,
            messageId: "wrap"
          });
        }
      }
    };
  }
};
jc.meta;
jc.create;
var Mc = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "require error handling in callbacks",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/handle-callback-err"
    },
    schema: [{
      type: "string"
    }],
    messages: {
      expected: "Expected error to be handled."
    }
  },
  create(t) {
    const e = t.options[0] || "err";
    function r(o) {
      return o[0] === "^";
    }
    function s(o) {
      return r(e) ? new RegExp(e, "u").test(o) : o === e;
    }
    function n(o) {
      return o.variables.filter((l) => l.defs[0] && l.defs[0].type === "Parameter");
    }
    function a(o) {
      const l = t.getScope(), i = n(l), u = i[0];
      u && s(u.name) && u.references.length === 0 && t.report({
        node: o,
        messageId: "expected"
      });
    }
    return {
      FunctionDeclaration: a,
      FunctionExpression: a,
      ArrowFunctionExpression: a
    };
  }
};
Mc.meta;
Mc.create;
function WR(t) {
  const e = t.parent;
  return e.type === "AssignmentExpression" && e.left === t || e.type === "ArrayPattern" || e.type === "RestElement" || e.type === "Property" && e.value === t && e.parent.type === "ObjectPattern" || e.type === "AssignmentPattern" && e.left === t;
}
function zR(t) {
  const e = t.parent;
  return e.type === "ImportSpecifier" && e.imported !== e.local && e.imported === t || e.type === "ExportSpecifier" && e.parent.source && e.local !== e.exported && e.local === t;
}
function GR(t) {
  const e = t.parent;
  return !e.computed && e.type === "Property" && e.parent.type === "ObjectPattern" && e.value !== t && e.key === t;
}
function HR(t) {
  const e = t.parent;
  return e.type === "Property" && e.parent.type === "ObjectExpression" && e.shorthand;
}
var $c = {
  meta: {
    deprecated: !0,
    replacedBy: ["id-denylist"],
    type: "suggestion",
    docs: {
      description: "disallow specified identifiers",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/id-blacklist"
    },
    schema: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: !0
    },
    messages: {
      restricted: "Identifier '{{name}}' is restricted."
    }
  },
  create(t) {
    const e = new Set(t.options), r = /* @__PURE__ */ new Set();
    let s;
    function n(i) {
      return e.has(i);
    }
    function a(i) {
      const u = s.set.get(i.name);
      return u && u.defs.length === 0 && u.references.some((c) => c.identifier === i);
    }
    function o(i) {
      const u = i.parent;
      return u.type === "MemberExpression" && u.property === i && !u.computed ? WR(u) : u.type !== "CallExpression" && u.type !== "NewExpression" && !zR(i) && !GR(i) && !(a(i) && !HR(i));
    }
    function l(i) {
      r.has(i) || (t.report({
        node: i,
        messageId: "restricted",
        data: {
          name: i.name
        }
      }), r.add(i));
    }
    return {
      Program() {
        s = t.getScope();
      },
      Identifier(i) {
        n(i.name) && o(i) && l(i);
      }
    };
  }
};
$c.meta;
$c.create;
function KR(t) {
  const e = t.parent;
  return e.type === "AssignmentExpression" && e.left === t || e.type === "ArrayPattern" || e.type === "RestElement" || e.type === "Property" && e.value === t && e.parent.type === "ObjectPattern" || e.type === "AssignmentPattern" && e.left === t;
}
function JR(t) {
  const e = t.parent;
  return e.type === "ImportSpecifier" && e.imported !== e.local && e.imported === t || e.type === "ExportSpecifier" && e.parent.source && e.local !== e.exported && e.local === t;
}
function XR(t) {
  const e = t.parent;
  return !e.computed && e.type === "Property" && e.parent.type === "ObjectPattern" && e.value !== t && e.key === t;
}
function QR(t) {
  const e = t.parent;
  return e.type === "Property" && e.parent.type === "ObjectExpression" && e.shorthand;
}
var Vc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified identifiers",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/id-denylist"
    },
    schema: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: !0
    },
    messages: {
      restricted: "Identifier '{{name}}' is restricted."
    }
  },
  create(t) {
    const e = new Set(t.options), r = /* @__PURE__ */ new Set();
    let s;
    function n(i) {
      return e.has(i);
    }
    function a(i) {
      const u = s.set.get(i.name);
      return u && u.defs.length === 0 && u.references.some((c) => c.identifier === i);
    }
    function o(i) {
      const u = i.parent;
      return u.type === "MemberExpression" && u.property === i && !u.computed ? KR(u) : u.type !== "CallExpression" && u.type !== "NewExpression" && !JR(i) && !XR(i) && !(a(i) && !QR(i));
    }
    function l(i) {
      r.has(i) || (t.report({
        node: i,
        messageId: "restricted",
        data: {
          name: i.name
        }
      }), r.add(i));
    }
    return {
      Program() {
        s = t.getScope();
      },
      Identifier(i) {
        n(i.name) && o(i) && l(i);
      }
    };
  }
};
Vc.meta;
Vc.create;
var Uc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce minimum and maximum identifier lengths",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/id-length"
    },
    schema: [{
      type: "object",
      properties: {
        min: {
          type: "integer",
          default: 2
        },
        max: {
          type: "integer"
        },
        exceptions: {
          type: "array",
          uniqueItems: !0,
          items: {
            type: "string"
          }
        },
        exceptionPatterns: {
          type: "array",
          uniqueItems: !0,
          items: {
            type: "string"
          }
        },
        properties: {
          enum: ["always", "never"]
        }
      },
      additionalProperties: !1
    }],
    messages: {
      tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
      tooLong: "Identifier name '{{name}}' is too long (> {{max}})."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = typeof e.min < "u" ? e.min : 2, s = typeof e.max < "u" ? e.max : 1 / 0, n = e.properties !== "never", a = new Set(e.exceptions), o = (e.exceptionPatterns || []).map((c) => new RegExp(c, "u")), l = /* @__PURE__ */ new Set();
    function i(c) {
      return o.some((f) => f.test(c));
    }
    const u = {
      MemberExpression: n && function(c) {
        return !c.computed && (c.parent.left === c && c.parent.type === "AssignmentExpression" || c.parent.type === "Property" && c.parent.value === c && c.parent.parent.type === "ObjectPattern" && c.parent.parent.parent.left === c.parent.parent);
      },
      AssignmentPattern(c, f) {
        return c.left === f;
      },
      VariableDeclarator(c, f) {
        return c.id === f;
      },
      Property(c, f) {
        return c.parent.type === "ObjectPattern" ? c.value !== c.key && c.value === f || c.value === c.key && c.key === f && n : n && !c.computed && c.key === f;
      },
      ImportDefaultSpecifier: !0,
      RestElement: !0,
      FunctionExpression: !0,
      ArrowFunctionExpression: !0,
      ClassDeclaration: !0,
      FunctionDeclaration: !0,
      MethodDefinition: !0,
      CatchClause: !0,
      ArrayPattern: !0
    };
    return {
      Identifier(c) {
        const f = c.name, h = c.parent, p = f.length < r, m = f.length > s;
        if (!(p || m) || a.has(f) || i(f))
          return;
        const d = u[h.type];
        d && !l.has(c) && (d === !0 || d(h, c)) && (l.add(c), t.report({
          node: c,
          messageId: p ? "tooShort" : "tooLong",
          data: {
            name: f,
            min: r,
            max: s
          }
        }));
      }
    };
  }
};
Uc.meta;
Uc.create;
var qc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require identifiers to match a specified regular expression",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/id-match"
    },
    schema: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        properties: {
          type: "boolean",
          default: !1
        },
        onlyDeclarations: {
          type: "boolean",
          default: !1
        },
        ignoreDestructuring: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'."
    }
  },
  create(t) {
    const e = t.options[0] || "^.+$", r = new RegExp(e, "u"), s = t.options[1] || {}, n = !!s.properties, a = !!s.onlyDeclarations, o = !!s.ignoreDestructuring, l = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(["CallExpression", "NewExpression"]), u = /* @__PURE__ */ new Set(["FunctionDeclaration", "VariableDeclarator"]), c = /* @__PURE__ */ new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);
    function f(d) {
      return !r.test(d);
    }
    function h(d) {
      let {
        parent: g
      } = d;
      for (; g; ) {
        if (g.type === "ObjectPattern")
          return !0;
        g = g.parent;
      }
      return !1;
    }
    function p(d, g) {
      return (!a || u.has(d.type)) && !i.has(d.type) && f(g);
    }
    function m(d) {
      l.has(d) || (t.report({
        node: d,
        messageId: "notMatch",
        data: {
          name: d.name,
          pattern: e
        }
      }), l.set(d, !0));
    }
    return {
      Identifier(d) {
        const g = d.name, y = d.parent, x = y.type === "MemberExpression" ? y.parent : y;
        if (y.type === "MemberExpression") {
          if (!n)
            return;
          y.object.type === "Identifier" && y.object.name === g || x.type === "AssignmentExpression" && x.left.type === "MemberExpression" && x.left.property.name === d.name ? f(g) && m(d) : x.type === "AssignmentExpression" && x.right.type !== "MemberExpression" && f(g) && m(d);
        } else if (y.type === "Property" || y.type === "AssignmentPattern") {
          if (y.parent && y.parent.type === "ObjectPattern") {
            y.shorthand && y.value.left && f(g) && m(d);
            const A = y.key.name === y.value.name;
            if (!A && y.key === d)
              return;
            y.value.name && f(g) && !(A && o) && m(d);
          }
          if (!n || o && h(d))
            return;
          y.right !== d && p(x, g) && m(d);
        } else
          c.has(y.type) ? y.local && y.local.name === d.name && f(g) && m(d) : p(x, g) && m(d);
      }
    };
  }
};
qc.meta;
qc.create;
const {
  isCommentToken: YR,
  isNotOpeningParenToken: ZR
} = E;
var Wc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the location of arrow function bodies",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/implicit-arrow-linebreak"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["beside", "below"]
    }],
    messages: {
      expected: "Expected a linebreak before this expression.",
      unexpected: "Expected no linebreak before this expression."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || "beside";
    function s(n) {
      if (n.body.type === "BlockStatement")
        return;
      const a = e.getTokenBefore(n.body, ZR), o = e.getTokenAfter(a);
      a.loc.end.line === o.loc.start.line && r === "below" ? t.report({
        node: o,
        messageId: "expected",
        fix: (l) => l.insertTextBefore(o, `
`)
      }) : a.loc.end.line !== o.loc.start.line && r === "beside" && t.report({
        node: o,
        messageId: "unexpected",
        fix(l) {
          return e.getFirstTokenBetween(a, o, {
            includeComments: !0,
            filter: YR
          }) ? null : l.replaceTextRange([a.range[1], o.range[0]], " ");
        }
      });
    }
    return {
      ArrowFunctionExpression: (n) => s(n)
    };
  }
};
Wc.meta;
Wc.create;
var zc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent indentation",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/indent-legacy"
    },
    deprecated: !0,
    replacedBy: ["indent"],
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["tab"]
      }, {
        type: "integer",
        minimum: 0
      }]
    }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0
        },
        VariableDeclarator: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            type: "object",
            properties: {
              var: {
                type: "integer",
                minimum: 0
              },
              let: {
                type: "integer",
                minimum: 0
              },
              const: {
                type: "integer",
                minimum: 0
              }
            }
          }]
        },
        outerIIFEBody: {
          type: "integer",
          minimum: 0
        },
        MemberExpression: {
          type: "integer",
          minimum: 0
        },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            },
            body: {
              type: "integer",
              minimum: 0
            }
          }
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            },
            body: {
              type: "integer",
              minimum: 0
            }
          }
        },
        CallExpression: {
          type: "object",
          properties: {
            parameters: {
              oneOf: [{
                type: "integer",
                minimum: 0
              }, {
                enum: ["first"]
              }]
            }
          }
        },
        ArrayExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["first"]
          }]
        },
        ObjectExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["first"]
          }]
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expected: "Expected indentation of {{expected}} but found {{actual}}."
    }
  },
  create(t) {
    let r = "space", s = 4;
    const n = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: 1,
        let: 1,
        const: 1
      },
      outerIIFEBody: null,
      FunctionDeclaration: {
        parameters: null,
        body: 1
      },
      FunctionExpression: {
        parameters: null,
        body: 1
      },
      CallExpression: {
        arguments: null
      },
      ArrayExpression: 1,
      ObjectExpression: 1
    }, a = t.getSourceCode();
    if (t.options.length && (t.options[0] === "tab" ? (s = 1, r = "tab") : typeof t.options[0] == "number" && (s = t.options[0], r = "space"), t.options[1])) {
      const k = t.options[1];
      n.SwitchCase = k.SwitchCase || 0;
      const j = k.VariableDeclarator;
      typeof j == "number" ? n.VariableDeclarator = {
        var: j,
        let: j,
        const: j
      } : typeof j == "object" && Object.assign(n.VariableDeclarator, j), typeof k.outerIIFEBody == "number" && (n.outerIIFEBody = k.outerIIFEBody), typeof k.MemberExpression == "number" && (n.MemberExpression = k.MemberExpression), typeof k.FunctionDeclaration == "object" && Object.assign(n.FunctionDeclaration, k.FunctionDeclaration), typeof k.FunctionExpression == "object" && Object.assign(n.FunctionExpression, k.FunctionExpression), typeof k.CallExpression == "object" && Object.assign(n.CallExpression, k.CallExpression), (typeof k.ArrayExpression == "number" || typeof k.ArrayExpression == "string") && (n.ArrayExpression = k.ArrayExpression), (typeof k.ObjectExpression == "number" || typeof k.ObjectExpression == "string") && (n.ObjectExpression = k.ObjectExpression);
    }
    const o = {};
    function l(k, j, O) {
      const z = `${k} ${r}${k === 1 ? "" : "s"}`, te = `space${j === 1 ? "" : "s"}`, se = `tab${O === 1 ? "" : "s"}`;
      let ye;
      return j > 0 && O > 0 ? ye = `${j} ${te} and ${O} ${se}` : j > 0 ? ye = r === "space" ? j : `${j} ${te}` : O > 0 ? ye = r === "tab" ? O : `${O} ${se}` : ye = "0", {
        expected: z,
        actual: ye
      };
    }
    function i(k, j, O, z, te, se) {
      if (O && z)
        return;
      const ye = (r === "space" ? " " : "	").repeat(j), Se = se ? [k.range[1] - k.loc.end.column, k.range[1] - k.loc.end.column + O + z] : [k.range[0] - k.loc.start.column, k.range[0] - k.loc.start.column + O + z];
      t.report({
        node: k,
        loc: te,
        messageId: "expected",
        data: l(j, O, z),
        fix: (xe) => xe.replaceTextRange(Se, ye)
      });
    }
    function u(k, j) {
      const O = j ? a.getLastToken(k) : a.getFirstToken(k), z = a.getText(O, O.loc.start.column).split(""), te = z.slice(0, z.findIndex((Se) => Se !== " " && Se !== "	")), se = te.filter((Se) => Se === " ").length, ye = te.filter((Se) => Se === "	").length;
      return {
        space: se,
        tab: ye,
        goodChar: r === "space" ? se : ye,
        badChar: r === "space" ? ye : se
      };
    }
    function c(k, j) {
      const O = j === !0 ? a.getLastToken(k, 1) : a.getTokenBefore(k), z = j === !0 ? k.loc.end.line : k.loc.start.line, te = O ? O.loc.end.line : -1;
      return z !== te;
    }
    function f(k, j) {
      const O = u(k, !1);
      if (k.type !== "ArrayExpression" && k.type !== "ObjectExpression" && (O.goodChar !== j || O.badChar !== 0) && c(k) && i(k, j, O.space, O.tab), k.type === "IfStatement" && k.alternate) {
        const z = a.getTokenBefore(k.alternate);
        f(z, j), c(k.alternate) || f(k.alternate, j);
      }
      if (k.type === "TryStatement" && k.handler) {
        const z = a.getFirstToken(k.handler);
        f(z, j);
      }
      if (k.type === "TryStatement" && k.finalizer) {
        const z = a.getTokenBefore(k.finalizer);
        f(z, j);
      }
      if (k.type === "DoWhileStatement") {
        const z = a.getTokenAfter(k.body);
        f(z, j);
      }
    }
    function h(k, j) {
      k.forEach((O) => f(O, j));
    }
    function p(k, j) {
      const O = a.getLastToken(k), z = u(O, !0);
      (z.goodChar !== j || z.badChar !== 0) && c(k, !0) && i(k, j, z.space, z.tab, {
        line: O.loc.start.line,
        column: O.loc.start.column
      }, !0);
    }
    function m(k, j) {
      const O = a.getLastToken(k, E.isClosingParenToken);
      if (a.getText(O, O.loc.start.column).slice(0, -1).trim())
        return;
      const te = u(O, !0);
      te.goodChar !== j && i(k, j, te.space, te.tab, {
        line: O.loc.start.line,
        column: O.loc.start.column
      }, !0);
    }
    function d(k, j) {
      const O = u(k, !1);
      (O.goodChar !== j || O.badChar !== 0) && c(k) && i(k, j, O.space, O.tab, {
        line: k.loc.start.line,
        column: k.loc.start.column
      });
    }
    function g(k, j, O) {
      let z = k.parent;
      const te = new Set(O || ["Program"]);
      for (; z.type !== j && !te.has(z.type) && z.type !== "Program"; )
        z = z.parent;
      return z.type === j ? z : null;
    }
    function y(k) {
      return g(k, "VariableDeclarator");
    }
    function x(k, j) {
      return j && j.parent.loc.start.line === k.loc.start.line && j.parent.declarations.length > 1;
    }
    function A(k) {
      const j = k.parent;
      return j.arguments.length >= 2 && j.arguments[1] === k ? j.arguments[0].loc.end.line > j.arguments[0].loc.start.line : !1;
    }
    function b(k) {
      const j = k.parent;
      let O = j.parent;
      if (j.type !== "CallExpression" || j.callee !== k)
        return !1;
      for (; O.type === "UnaryExpression" && (O.operator === "!" || O.operator === "~" || O.operator === "+" || O.operator === "-") || O.type === "AssignmentExpression" || O.type === "LogicalExpression" || O.type === "SequenceExpression" || O.type === "VariableDeclarator"; )
        O = O.parent;
      return (O.type === "ExpressionStatement" || O.type === "VariableDeclaration") && O.parent && O.parent.type === "Program";
    }
    function v(k) {
      const j = k.parent;
      let O;
      if (j.parent && (j.parent.type === "Property" || j.parent.type === "ArrayExpression") ? O = u(j, !1).goodChar : O = u(j).goodChar, j.parent.type === "CallExpression") {
        const se = j.parent;
        j.type !== "FunctionExpression" && j.type !== "ArrowFunctionExpression" ? se && se.loc.start.line < k.loc.start.line && (O = u(se).goodChar) : A(j) && se.callee.loc.start.line === se.callee.loc.end.line && !c(j) && (O = u(se).goodChar);
      }
      let z = s;
      n.outerIIFEBody !== null && b(j) ? z = n.outerIIFEBody * s : j.type === "FunctionExpression" ? z = n.FunctionExpression.body * s : j.type === "FunctionDeclaration" && (z = n.FunctionDeclaration.body * s), O += z;
      const te = y(k);
      te && x(k, te) && (O += s * n.VariableDeclarator[te.parent.kind]), k.body.length > 0 && h(k.body, O), p(k, O - z);
    }
    function C(k) {
      const j = a.getLastToken(k), O = k.loc.start.line, z = j.loc.end.line;
      return O === z;
    }
    function T(k) {
      if (C(k))
        return;
      let j = k.type === "ArrayExpression" ? k.elements : k.properties;
      j = j.filter((se) => se !== null);
      let O, z;
      const te = y(k);
      if (c(k)) {
        const se = k.parent;
        if (O = u(se).goodChar, (!te || te.loc.start.line !== k.loc.start.line) && (se.type !== "VariableDeclarator" || te === te.parent.declarations[0]))
          if (se.type === "VariableDeclarator" && te.loc.start.line === se.loc.start.line)
            O += s * n.VariableDeclarator[te.parent.kind];
          else if (se.type === "ObjectExpression" || se.type === "ArrayExpression") {
            const ye = k.parent.type === "ObjectExpression" ? k.parent.properties : k.parent.elements;
            ye[0] && ye[0].loc.start.line === se.loc.start.line && ye[0].loc.end.line !== se.loc.start.line || (typeof n[se.type] == "number" ? O += n[se.type] * s : O = ye[0].loc.start.column);
          } else
            se.type === "CallExpression" || se.type === "NewExpression" ? typeof n.CallExpression.arguments == "number" ? O += n.CallExpression.arguments * s : n.CallExpression.arguments === "first" ? se.arguments.indexOf(k) !== -1 && (O = se.arguments[0].loc.start.column) : O += s : (se.type === "LogicalExpression" || se.type === "ArrowFunctionExpression") && (O += s);
        d(k, O);
      } else
        O = u(k).goodChar;
      n[k.type] === "first" ? z = j.length ? j[0].loc.start.column : 0 : z = O + s * n[k.type], x(k, te) && (z += s * n.VariableDeclarator[te.parent.kind]), h(j, z), !(j.length > 0 && j[j.length - 1].loc.end.line === k.loc.end.line) && p(k, O + (x(k, te) ? n.VariableDeclarator[te.parent.kind] * s : 0));
    }
    function w(k) {
      return k.type === "BlockStatement" || k.type === "ClassBody" || k.body && k.body.type === "BlockStatement" || k.consequent && k.consequent.type === "BlockStatement";
    }
    function B(k) {
      if (C(k))
        return;
      if (k.parent && (k.parent.type === "FunctionExpression" || k.parent.type === "FunctionDeclaration" || k.parent.type === "ArrowFunctionExpression")) {
        v(k);
        return;
      }
      let j, O = [];
      k.parent && ["IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"].indexOf(k.parent.type) !== -1 && w(k) ? j = u(k.parent).goodChar : k.parent && k.parent.type === "CatchClause" ? j = u(k.parent.parent).goodChar : j = u(k).goodChar, k.type === "IfStatement" && k.consequent.type !== "BlockStatement" ? O = [k.consequent] : Array.isArray(k.body) ? O = k.body : O = [k.body], O.length > 0 && h(O, j + s), k.type === "BlockStatement" && p(k, j);
    }
    function I(k) {
      return k.declarations.reduce((j, O) => {
        const z = j[j.length - 1];
        return (O.loc.start.line !== k.loc.start.line && !z || z && z.loc.start.line !== O.loc.start.line) && j.push(O), j;
      }, []);
    }
    function _(k) {
      const j = I(k), O = u(k).goodChar, z = j[j.length - 1], te = O + s * n.VariableDeclarator[k.kind];
      if (h(j, te), a.getLastToken(k).loc.end.line <= z.loc.end.line)
        return;
      const se = a.getTokenBefore(z);
      se.value === "," ? p(k, u(se).goodChar) : p(k, te - s);
    }
    function S(k) {
      k.body.type !== "BlockStatement" && B(k);
    }
    function F(k, j) {
      const O = k.type === "SwitchStatement" ? k : k.parent, z = typeof j > "u" ? u(O).goodChar : j;
      let te;
      return o[O.loc.start.line] ? o[O.loc.start.line] : (O.cases.length > 0 && n.SwitchCase === 0 ? te = z : te = z + s * n.SwitchCase, o[O.loc.start.line] = te, te);
    }
    function N(k) {
      const j = a.getText(k).replace(a.getText(k.argument), "");
      return /^return\s*?\(\s*?\);*?/u.test(j);
    }
    return {
      Program(k) {
        k.body.length > 0 && h(k.body, u(k).goodChar);
      },
      ClassBody: B,
      BlockStatement: B,
      WhileStatement: S,
      ForStatement: S,
      ForInStatement: S,
      ForOfStatement: S,
      DoWhileStatement: S,
      IfStatement(k) {
        k.consequent.type !== "BlockStatement" && k.consequent.loc.start.line > k.loc.start.line && B(k);
      },
      VariableDeclaration(k) {
        k.declarations[k.declarations.length - 1].loc.start.line > k.declarations[0].loc.start.line && _(k);
      },
      ObjectExpression(k) {
        T(k);
      },
      ArrayExpression(k) {
        T(k);
      },
      MemberExpression(k) {
        if (typeof n.MemberExpression > "u" || C(k) || g(k, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"]) || g(k, "AssignmentExpression", ["FunctionExpression"]))
          return;
        const j = u(k).goodChar + s * n.MemberExpression, O = [k.property], z = a.getTokenBefore(k.property);
        z.type === "Punctuator" && z.value === "." && O.push(z), h(O, j);
      },
      SwitchStatement(k) {
        const j = u(k).goodChar, O = F(k, j);
        h(k.cases, O), p(k, j);
      },
      SwitchCase(k) {
        if (C(k))
          return;
        const j = F(k);
        h(k.consequent, j + s);
      },
      FunctionDeclaration(k) {
        C(k) || (n.FunctionDeclaration.parameters === "first" && k.params.length ? h(k.params.slice(1), k.params[0].loc.start.column) : n.FunctionDeclaration.parameters !== null && h(k.params, u(k).goodChar + s * n.FunctionDeclaration.parameters));
      },
      FunctionExpression(k) {
        C(k) || (n.FunctionExpression.parameters === "first" && k.params.length ? h(k.params.slice(1), k.params[0].loc.start.column) : n.FunctionExpression.parameters !== null && h(k.params, u(k).goodChar + s * n.FunctionExpression.parameters));
      },
      ReturnStatement(k) {
        if (C(k))
          return;
        const j = u(k).goodChar;
        N(k) ? m(k, j) : f(k, j);
      },
      CallExpression(k) {
        C(k) || (n.CallExpression.arguments === "first" && k.arguments.length ? h(k.arguments.slice(1), k.arguments[0].loc.start.column) : n.CallExpression.arguments !== null && h(k.arguments, u(k).goodChar + s * n.CallExpression.arguments));
      }
    };
  }
};
zc.meta;
zc.create;
const eN = /* @__PURE__ */ new Set(["AssignmentExpression", "AssignmentPattern", "ArrayExpression", "ArrayPattern", "ArrowFunctionExpression", "AwaitExpression", "BlockStatement", "BinaryExpression", "BreakStatement", "CallExpression", "CatchClause", "ChainExpression", "ClassBody", "ClassDeclaration", "ClassExpression", "ConditionalExpression", "ContinueStatement", "DoWhileStatement", "DebuggerStatement", "EmptyStatement", "ExperimentalRestProperty", "ExperimentalSpreadProperty", "ExpressionStatement", "ForStatement", "ForInStatement", "ForOfStatement", "FunctionDeclaration", "FunctionExpression", "Identifier", "IfStatement", "Literal", "LabeledStatement", "LogicalExpression", "MemberExpression", "MetaProperty", "MethodDefinition", "NewExpression", "ObjectExpression", "ObjectPattern", "Program", "Property", "RestElement", "ReturnStatement", "SequenceExpression", "SpreadElement", "Super", "SwitchCase", "SwitchStatement", "TaggedTemplateExpression", "TemplateElement", "TemplateLiteral", "ThisExpression", "ThrowStatement", "TryStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "JSXFragment", "JSXOpeningFragment", "JSXClosingFragment", "JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression", "JSXEmptyExpression", "JSXExpressionContainer", "JSXElement", "JSXClosingElement", "JSXOpeningElement", "JSXAttribute", "JSXSpreadAttribute", "JSXText", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "ExportSpecifier", "ImportDeclaration", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier", "ImportExpression"]);
class tN {
  constructor() {
    this._rbTree = rR.default();
  }
  insert(e, r) {
    const s = this._rbTree.find(e);
    s.valid ? this._rbTree = s.update(r) : this._rbTree = this._rbTree.insert(e, r);
  }
  findLe(e) {
    const r = this._rbTree.le(e);
    return r && {
      key: r.key,
      value: r.value
    };
  }
  deleteRange(e, r) {
    if (e === r)
      return;
    const s = this._rbTree.ge(e);
    for (; s.valid && s.key < r; )
      this._rbTree = this._rbTree.remove(s.key), s.next();
  }
}
class rN {
  constructor(e) {
    this.sourceCode = e, this.firstTokensByLineNumber = e.tokensAndComments.reduce((r, s) => (r.has(s.loc.start.line) || r.set(s.loc.start.line, s), !r.has(s.loc.end.line) && e.text.slice(s.range[1] - s.loc.end.column, s.range[1]).trim() && r.set(s.loc.end.line, s), r), /* @__PURE__ */ new Map());
  }
  getFirstTokenOfLine(e) {
    return this.firstTokensByLineNumber.get(e.loc.start.line);
  }
  isFirstTokenOfLine(e) {
    return this.getFirstTokenOfLine(e) === e;
  }
  getTokenIndent(e) {
    return this.sourceCode.text.slice(e.range[0] - e.loc.start.column, e.range[0]);
  }
}
class nN {
  constructor(e, r, s) {
    this._tokenInfo = e, this._indentSize = r, this._indentType = s, this._tree = new tN(), this._tree.insert(0, {
      offset: 0,
      from: null,
      force: !1
    }), this._lockedFirstTokens = /* @__PURE__ */ new WeakMap(), this._desiredIndentCache = /* @__PURE__ */ new WeakMap(), this._ignoredTokens = /* @__PURE__ */ new WeakSet();
  }
  _getOffsetDescriptor(e) {
    return this._tree.findLe(e.range[0]).value;
  }
  matchOffsetOf(e, r) {
    this._lockedFirstTokens.set(r, e);
  }
  setDesiredOffset(e, r, s) {
    return this.setDesiredOffsets(e.range, r, s);
  }
  setDesiredOffsets(e, r, s, n) {
    const a = {
      offset: s,
      from: r,
      force: n
    }, o = this._tree.findLe(e[1]).value, l = r && r.range[0] >= e[0] && r.range[1] <= e[1], i = l && this._getOffsetDescriptor(r);
    this._tree.deleteRange(e[0] + 1, e[1]), this._tree.insert(e[0], a), l && (this._tree.insert(r.range[0], i), this._tree.insert(r.range[1], a)), this._tree.insert(e[1], o);
  }
  getDesiredIndent(e) {
    if (!this._desiredIndentCache.has(e))
      if (this._ignoredTokens.has(e))
        this._desiredIndentCache.set(e, this._tokenInfo.getTokenIndent(e));
      else if (this._lockedFirstTokens.has(e)) {
        const r = this._lockedFirstTokens.get(e);
        this._desiredIndentCache.set(e, this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(r)) + this._indentType.repeat(r.loc.start.column - this._tokenInfo.getFirstTokenOfLine(r).loc.start.column));
      } else {
        const r = this._getOffsetDescriptor(e), s = r.from && r.from.loc.start.line === e.loc.start.line && !/^\s*?\n/u.test(e.value) && !r.force ? 0 : r.offset * this._indentSize;
        this._desiredIndentCache.set(e, (r.from ? this.getDesiredIndent(r.from) : "") + this._indentType.repeat(s));
      }
    return this._desiredIndentCache.get(e);
  }
  ignoreToken(e) {
    this._tokenInfo.isFirstTokenOfLine(e) && this._ignoredTokens.add(e);
  }
  getFirstDependency(e) {
    return this._getOffsetDescriptor(e).from;
  }
}
const Cr = {
  oneOf: [{
    type: "integer",
    minimum: 0
  }, {
    enum: ["first", "off"]
  }]
};
var Gc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent indentation",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/indent"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["tab"]
      }, {
        type: "integer",
        minimum: 0
      }]
    }, {
      type: "object",
      properties: {
        SwitchCase: {
          type: "integer",
          minimum: 0,
          default: 0
        },
        VariableDeclarator: {
          oneOf: [Cr, {
            type: "object",
            properties: {
              var: Cr,
              let: Cr,
              const: Cr
            },
            additionalProperties: !1
          }]
        },
        outerIIFEBody: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["off"]
          }]
        },
        MemberExpression: {
          oneOf: [{
            type: "integer",
            minimum: 0
          }, {
            enum: ["off"]
          }]
        },
        FunctionDeclaration: {
          type: "object",
          properties: {
            parameters: Cr,
            body: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: !1
        },
        FunctionExpression: {
          type: "object",
          properties: {
            parameters: Cr,
            body: {
              type: "integer",
              minimum: 0
            }
          },
          additionalProperties: !1
        },
        CallExpression: {
          type: "object",
          properties: {
            arguments: Cr
          },
          additionalProperties: !1
        },
        ArrayExpression: Cr,
        ObjectExpression: Cr,
        ImportDeclaration: Cr,
        flatTernaryExpressions: {
          type: "boolean",
          default: !1
        },
        offsetTernaryExpressions: {
          type: "boolean",
          default: !1
        },
        ignoredNodes: {
          type: "array",
          items: {
            type: "string",
            not: {
              pattern: ":exit$"
            }
          }
        },
        ignoreComments: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
    }
  },
  create(t) {
    let r = "space", s = 4;
    const n = {
      SwitchCase: 0,
      VariableDeclarator: {
        var: 1,
        let: 1,
        const: 1
      },
      outerIIFEBody: 1,
      FunctionDeclaration: {
        parameters: 1,
        body: 1
      },
      FunctionExpression: {
        parameters: 1,
        body: 1
      },
      CallExpression: {
        arguments: 1
      },
      MemberExpression: 1,
      ArrayExpression: 1,
      ObjectExpression: 1,
      ImportDeclaration: 1,
      flatTernaryExpressions: !1,
      ignoredNodes: [],
      ignoreComments: !1
    };
    t.options.length && (t.options[0] === "tab" ? (s = 1, r = "tab") : (s = t.options[0], r = "space"), t.options[1] && (Object.assign(n, t.options[1]), (typeof n.VariableDeclarator == "number" || n.VariableDeclarator === "first") && (n.VariableDeclarator = {
      var: n.VariableDeclarator,
      let: n.VariableDeclarator,
      const: n.VariableDeclarator
    })));
    const a = t.getSourceCode(), o = new rN(a), l = new nN(o, s, r === "space" ? " " : "	"), i = /* @__PURE__ */ new WeakSet();
    function u(S, F, N) {
      const k = `${S} ${r}${S === 1 ? "" : "s"}`, j = `space${F === 1 ? "" : "s"}`, O = `tab${N === 1 ? "" : "s"}`;
      let z;
      return F > 0 ? z = r === "space" ? F : `${F} ${j}` : N > 0 ? z = r === "tab" ? N : `${N} ${O}` : z = "0", {
        expected: k,
        actual: z
      };
    }
    function c(S, F) {
      const N = Array.from(o.getTokenIndent(S)), k = N.filter((O) => O === " ").length, j = N.filter((O) => O === "	").length;
      t.report({
        node: S,
        messageId: "wrongIndentation",
        data: u(F.length, k, j),
        loc: {
          start: {
            line: S.loc.start.line,
            column: 0
          },
          end: {
            line: S.loc.start.line,
            column: S.loc.start.column
          }
        },
        fix(O) {
          const z = [S.range[0] - S.loc.start.column, S.range[0]];
          return O.replaceTextRange(z, F);
        }
      });
    }
    function f(S, F) {
      const N = o.getTokenIndent(S);
      return N === F || N.includes(" ") && N.includes("	");
    }
    function h(S) {
      if (!S.parent || S.parent.type !== "CallExpression" || S.parent.callee !== S)
        return !1;
      let F = S.parent && S.parent.parent;
      for (; F.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(F.operator) > -1 || F.type === "AssignmentExpression" || F.type === "LogicalExpression" || F.type === "SequenceExpression" || F.type === "VariableDeclarator"; )
        F = F.parent;
      return (F.type === "ExpressionStatement" || F.type === "VariableDeclaration") && F.parent.type === "Program";
    }
    function p(S) {
      const N = S.match(/\s*$/u)[0].match(E.createGlobalLinebreakMatcher());
      return N === null ? 0 : N.length;
    }
    function m(S, F, N, k) {
      function j(O) {
        let z = a.getTokenBefore(O);
        for (; E.isOpeningParenToken(z) && z !== F; )
          z = a.getTokenBefore(z);
        return a.getTokenAfter(z);
      }
      l.setDesiredOffsets([F.range[1], N.range[0]], F, typeof k == "number" ? k : 1), l.setDesiredOffset(N, F, 0), !(k === "first" && S.length && !S[0]) && S.forEach((O, z) => {
        if (O && (k === "off" && l.ignoreToken(j(O)), z !== 0))
          if (k === "first" && o.isFirstTokenOfLine(j(O)))
            l.matchOffsetOf(j(S[0]), j(O));
          else {
            const te = S[z - 1], se = te && j(te), ye = te && a.getLastToken(te);
            te && ye.loc.end.line - p(ye.value) > F.loc.end.line && l.setDesiredOffsets([te.range[1], O.range[1]], se, 0);
          }
      });
    }
    function d(S) {
      if (S.type !== "BlockStatement") {
        const F = a.getTokenBefore(S, E.isNotOpeningParenToken);
        let N = a.getFirstToken(S), k = a.getLastToken(S);
        for (; E.isOpeningParenToken(a.getTokenBefore(N)) && E.isClosingParenToken(a.getTokenAfter(k)); )
          N = a.getTokenBefore(N), k = a.getTokenAfter(k);
        l.setDesiredOffsets([N.range[0], k.range[1]], F, 1);
        const j = a.getLastToken(S);
        S.type !== "EmptyStatement" && E.isSemicolonToken(j) && l.setDesiredOffset(j, F, 0);
      }
    }
    function g(S) {
      let F;
      S.arguments.length ? F = a.getFirstTokenBetween(S.callee, S.arguments[0], E.isOpeningParenToken) : F = a.getLastToken(S, 1);
      const N = a.getLastToken(S);
      if (i.add(F), i.add(N), S.optional) {
        const O = a.getTokenAfter(S.callee, E.isQuestionDotToken), z = a.getTokensBetween(S.callee, O, {
          filter: E.isClosingParenToken
        }).length, te = z ? a.getTokenBefore(S.callee, {
          skip: z - 1
        }) : a.getFirstToken(S.callee), se = a.getTokenBefore(O), ye = se.loc.end.line === F.loc.start.line ? se : te;
        l.setDesiredOffset(O, ye, 1);
      }
      const k = S.callee.type === "TaggedTemplateExpression" ? a.getFirstToken(S.callee.quasi) : F, j = a.getTokenBefore(k);
      l.setDesiredOffset(F, j, 0), m(S.arguments, F, N, n.CallExpression.arguments);
    }
    function y(S) {
      const F = [], N = [];
      S.forEach((k) => {
        E.isOpeningParenToken(k) ? F.push(k) : E.isClosingParenToken(k) && N.unshift({
          left: F.pop(),
          right: k
        });
      }), N.forEach((k) => {
        const j = k.left, O = k.right;
        if (!i.has(j) && !i.has(O)) {
          const z = new Set(a.getTokensBetween(j, O));
          z.forEach((te) => {
            z.has(l.getFirstDependency(te)) || l.setDesiredOffset(te, j, 1);
          });
        }
        l.setDesiredOffset(O, j, 0);
      });
    }
    function x(S) {
      const F = new Set(a.getTokens(S, {
        includeComments: !0
      }));
      F.forEach((N) => {
        if (!F.has(l.getFirstDependency(N))) {
          const k = o.getFirstTokenOfLine(N);
          N === k ? l.ignoreToken(N) : l.setDesiredOffset(N, k, 0);
        }
      });
    }
    function A(S, F) {
      let N = F;
      for (; N.parent && !N.parent.type.endsWith("Statement") && !N.parent.type.endsWith("Declaration"); )
        N = N.parent;
      return N = N.parent, !N || N.loc.start.line === S.loc.start.line;
    }
    function b(S, F) {
      const N = S.loc.end.line, k = F.loc.start.line;
      if (N === k || N === k - 1)
        return !1;
      for (let j = N + 1; j < k; ++j)
        if (!o.firstTokensByLineNumber.has(j))
          return !0;
      return !1;
    }
    const v = /* @__PURE__ */ new Set(), C = {
      "ArrayExpression, ArrayPattern"(S) {
        const F = a.getFirstToken(S), N = a.getTokenAfter([...S.elements].reverse().find((k) => k) || F, E.isClosingBracketToken);
        m(S.elements, F, N, n.ArrayExpression);
      },
      "ObjectExpression, ObjectPattern"(S) {
        const F = a.getFirstToken(S), N = a.getTokenAfter(S.properties.length ? S.properties[S.properties.length - 1] : F, E.isClosingBraceToken);
        m(S.properties, F, N, n.ObjectExpression);
      },
      ArrowFunctionExpression(S) {
        const F = a.getFirstToken(S, {
          skip: S.async ? 1 : 0
        });
        if (E.isOpeningParenToken(F)) {
          const N = F, k = a.getTokenBefore(S.body, E.isClosingParenToken);
          i.add(N), i.add(k), m(S.params, N, k, n.FunctionExpression.parameters);
        }
        d(S.body);
      },
      AssignmentExpression(S) {
        const F = a.getFirstTokenBetween(S.left, S.right, (N) => N.value === S.operator);
        l.setDesiredOffsets([F.range[0], S.range[1]], a.getLastToken(S.left), 1), l.ignoreToken(F), l.ignoreToken(a.getTokenAfter(F));
      },
      "BinaryExpression, LogicalExpression"(S) {
        const F = a.getFirstTokenBetween(S.left, S.right, (k) => k.value === S.operator), N = a.getTokenAfter(F);
        l.ignoreToken(F), l.ignoreToken(N), l.setDesiredOffset(N, F, 0);
      },
      "BlockStatement, ClassBody"(S) {
        let F;
        S.parent && h(S.parent) ? F = n.outerIIFEBody : S.parent && (S.parent.type === "FunctionExpression" || S.parent.type === "ArrowFunctionExpression") ? F = n.FunctionExpression.body : S.parent && S.parent.type === "FunctionDeclaration" ? F = n.FunctionDeclaration.body : F = 1, E.STATEMENT_LIST_PARENTS.has(S.parent.type) || l.setDesiredOffset(a.getFirstToken(S), a.getFirstToken(S.parent), 0), m(S.body, a.getFirstToken(S), a.getLastToken(S), F);
      },
      CallExpression: g,
      "ClassDeclaration[superClass], ClassExpression[superClass]"(S) {
        const F = a.getFirstToken(S), N = a.getTokenBefore(S.superClass, E.isNotOpeningParenToken);
        l.setDesiredOffsets([N.range[0], S.body.range[0]], F, 1);
      },
      ConditionalExpression(S) {
        const F = a.getFirstToken(S);
        if (!n.flatTernaryExpressions || !E.isTokenOnSameLine(S.test, S.consequent) || A(F, S)) {
          const N = a.getFirstTokenBetween(S.test, S.consequent, (te) => te.type === "Punctuator" && te.value === "?"), k = a.getFirstTokenBetween(S.consequent, S.alternate, (te) => te.type === "Punctuator" && te.value === ":"), j = a.getTokenAfter(N), O = a.getTokenBefore(k), z = a.getTokenAfter(k);
          l.setDesiredOffset(N, F, 1), l.setDesiredOffset(k, F, 1), l.setDesiredOffset(j, F, j.type === "Punctuator" && n.offsetTernaryExpressions ? 2 : 1), O.loc.end.line === z.loc.start.line ? l.setDesiredOffset(z, j, 0) : l.setDesiredOffset(z, F, z.type === "Punctuator" && n.offsetTernaryExpressions ? 2 : 1);
        }
      },
      "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": (S) => d(S.body),
      ExportNamedDeclaration(S) {
        if (S.declaration === null) {
          const F = a.getLastToken(S, E.isClosingBraceToken);
          m(S.specifiers, a.getFirstToken(S, {
            skip: 1
          }), F, 1), S.source && l.setDesiredOffsets([F.range[1], S.range[1]], a.getFirstToken(S), 1);
        }
      },
      ForStatement(S) {
        const F = a.getFirstToken(S, 1);
        S.init && l.setDesiredOffsets(S.init.range, F, 1), S.test && l.setDesiredOffsets(S.test.range, F, 1), S.update && l.setDesiredOffsets(S.update.range, F, 1), d(S.body);
      },
      "FunctionDeclaration, FunctionExpression"(S) {
        const F = a.getTokenBefore(S.body), N = a.getTokenBefore(S.params.length ? S.params[0] : F);
        i.add(N), i.add(F), m(S.params, N, F, n[S.type].parameters);
      },
      IfStatement(S) {
        d(S.consequent), S.alternate && S.alternate.type !== "IfStatement" && d(S.alternate);
      },
      ImportDeclaration(S) {
        if (S.specifiers.some((j) => j.type === "ImportSpecifier")) {
          const j = a.getFirstToken(S, E.isOpeningBraceToken), O = a.getLastToken(S, E.isClosingBraceToken);
          m(S.specifiers.filter((z) => z.type === "ImportSpecifier"), j, O, n.ImportDeclaration);
        }
        const F = a.getLastToken(S, (j) => j.type === "Identifier" && j.value === "from"), N = a.getLastToken(S, (j) => j.type === "String"), k = a.getLastToken(S, (j) => j.type === "Punctuator" && j.value === ";");
        if (F) {
          const j = k && k.range[1] === N.range[1] ? S.range[1] : N.range[1];
          l.setDesiredOffsets([F.range[0], j], a.getFirstToken(S), 1);
        }
      },
      ImportExpression(S) {
        const F = a.getFirstToken(S, 1), N = a.getLastToken(S);
        i.add(F), i.add(N), l.setDesiredOffset(F, a.getTokenBefore(F), 0), m([S.source], F, N, n.CallExpression.arguments);
      },
      "MemberExpression, JSXMemberExpression, MetaProperty"(S) {
        const F = S.type === "MetaProperty" ? S.meta : S.object, N = a.getFirstTokenBetween(F, S.property, E.isNotClosingParenToken), k = a.getTokenAfter(N), j = a.getTokensBetween(F, S.property, {
          filter: E.isClosingParenToken
        }).length, O = j ? a.getTokenBefore(F, {
          skip: j - 1
        }) : a.getFirstToken(F), z = a.getTokenBefore(N), te = S.computed ? N : k;
        S.computed && (l.setDesiredOffset(a.getLastToken(S), N, 0), l.setDesiredOffsets(S.property.range, N, 1));
        const se = z.loc.end.line === te.loc.start.line ? z : O;
        typeof n.MemberExpression == "number" ? (l.setDesiredOffset(N, se, n.MemberExpression), l.setDesiredOffset(k, S.computed ? N : se, n.MemberExpression)) : (l.ignoreToken(N), l.ignoreToken(k), l.setDesiredOffset(N, se, 0), l.setDesiredOffset(k, N, 0));
      },
      NewExpression(S) {
        (S.arguments.length > 0 || E.isClosingParenToken(a.getLastToken(S)) && E.isOpeningParenToken(a.getLastToken(S, 1))) && g(S);
      },
      Property(S) {
        if (!S.shorthand && !S.method && S.kind === "init") {
          const F = a.getFirstTokenBetween(S.key, S.value, E.isColonToken);
          l.ignoreToken(a.getTokenAfter(F));
        }
      },
      SwitchStatement(S) {
        const F = a.getTokenAfter(S.discriminant, E.isOpeningBraceToken), N = a.getLastToken(S);
        l.setDesiredOffsets([F.range[1], N.range[0]], F, n.SwitchCase), S.cases.length && a.getTokensBetween(S.cases[S.cases.length - 1], N, {
          includeComments: !0,
          filter: E.isCommentToken
        }).forEach((k) => l.ignoreToken(k));
      },
      SwitchCase(S) {
        if (!(S.consequent.length === 1 && S.consequent[0].type === "BlockStatement")) {
          const F = a.getFirstToken(S), N = a.getTokenAfter(S);
          l.setDesiredOffsets([F.range[1], N.range[0]], F, 1);
        }
      },
      TemplateLiteral(S) {
        S.expressions.forEach((F, N) => {
          const k = S.quasis[N], j = S.quasis[N + 1], O = k.loc.start.line === k.loc.end.line ? a.getFirstToken(k) : null;
          l.setDesiredOffsets([k.range[1], j.range[0]], O, 1), l.setDesiredOffset(a.getFirstToken(j), O, 0);
        });
      },
      VariableDeclaration(S) {
        let F = Object.prototype.hasOwnProperty.call(n.VariableDeclarator, S.kind) ? n.VariableDeclarator[S.kind] : 1;
        const N = a.getFirstToken(S), k = a.getLastToken(S);
        if (n.VariableDeclarator[S.kind] === "first") {
          if (S.declarations.length > 1) {
            m(S.declarations, N, k, "first");
            return;
          }
          F = 1;
        }
        S.declarations[S.declarations.length - 1].loc.start.line > S.loc.start.line ? l.setDesiredOffsets(S.range, N, F, !0) : l.setDesiredOffsets(S.range, N, F), E.isSemicolonToken(k) && l.ignoreToken(k);
      },
      VariableDeclarator(S) {
        if (S.init) {
          const F = a.getTokenBefore(S.init, E.isNotOpeningParenToken), N = a.getTokenAfter(F);
          l.ignoreToken(F), l.ignoreToken(N), l.setDesiredOffsets([N.range[0], S.range[1]], F, 1), l.setDesiredOffset(F, a.getLastToken(S.id), 0);
        }
      },
      "JSXAttribute[value]"(S) {
        const F = a.getFirstTokenBetween(S.name, S.value, (N) => N.type === "Punctuator" && N.value === "=");
        l.setDesiredOffsets([F.range[0], S.value.range[1]], a.getFirstToken(S.name), 1);
      },
      JSXElement(S) {
        S.closingElement && m(S.children, a.getFirstToken(S.openingElement), a.getFirstToken(S.closingElement), 1);
      },
      JSXOpeningElement(S) {
        const F = a.getFirstToken(S);
        let N;
        S.selfClosing ? (N = a.getLastToken(S, {
          skip: 1
        }), l.setDesiredOffset(a.getLastToken(S), N, 0)) : N = a.getLastToken(S), l.setDesiredOffsets(S.name.range, a.getFirstToken(S)), m(S.attributes, F, N, 1);
      },
      JSXClosingElement(S) {
        const F = a.getFirstToken(S);
        l.setDesiredOffsets(S.name.range, F, 1);
      },
      JSXFragment(S) {
        const F = a.getFirstToken(S.openingFragment), N = a.getFirstToken(S.closingFragment);
        m(S.children, F, N, 1);
      },
      JSXOpeningFragment(S) {
        const F = a.getFirstToken(S), N = a.getLastToken(S);
        l.setDesiredOffsets(S.range, F, 1), l.matchOffsetOf(F, N);
      },
      JSXClosingFragment(S) {
        const F = a.getFirstToken(S), N = a.getLastToken(S, {
          skip: 1
        }), k = a.getLastToken(S), j = E.isTokenOnSameLine(N, k) ? N : k;
        l.setDesiredOffsets(S.range, F, 1), l.matchOffsetOf(F, j);
      },
      JSXExpressionContainer(S) {
        const F = a.getFirstToken(S), N = a.getLastToken(S);
        l.setDesiredOffsets([F.range[1], N.range[0]], F, 1);
      },
      JSXSpreadAttribute(S) {
        const F = a.getFirstToken(S), N = a.getLastToken(S);
        l.setDesiredOffsets([F.range[1], N.range[0]], F, 1);
      },
      "*"(S) {
        const F = a.getFirstToken(S);
        F && !v.has(F) && l.setDesiredOffsets(S.range, F, 0);
      }
    }, T = [], w = {};
    for (const [S, F] of Object.entries(C))
      w[S] = (N) => T.push({
        listener: F,
        node: N
      });
    const B = /* @__PURE__ */ new Set();
    function I(S) {
      B.add(S), v.add(a.getFirstToken(S));
    }
    const _ = n.ignoredNodes.reduce((S, F) => Object.assign(S, {
      [F]: I
    }), {});
    return Object.assign(w, _, {
      "*:exit"(S) {
        eN.has(S.type) || I(S);
      },
      "Program:exit"() {
        n.ignoreComments && a.getAllComments().forEach((F) => l.ignoreToken(F)), T.filter((F) => !B.has(F.node)).forEach((F) => F.listener(F.node)), B.forEach(x), y(a.ast.tokens);
        const S = a.ast.comments.reduce((F, N) => {
          const k = a.getTokenBefore(N, {
            includeComments: !0
          });
          return F.set(N, F.has(k) ? F.get(k) : k);
        }, /* @__PURE__ */ new WeakMap());
        a.lines.forEach((F, N) => {
          const k = N + 1;
          if (!o.firstTokensByLineNumber.has(k))
            return;
          const j = o.firstTokensByLineNumber.get(k);
          if (j.loc.start.line === k) {
            if (E.isCommentToken(j)) {
              const O = S.get(j), z = O ? a.getTokenAfter(O) : a.ast.tokens[0], te = O && !b(O, j), se = z && !b(j, z);
              if (z && E.isSemicolonToken(z) && !E.isTokenOnSameLine(j, z) && l.setDesiredOffset(j, z, 0), te && f(j, l.getDesiredIndent(O)) || se && f(j, l.getDesiredIndent(z)))
                return;
            }
            f(j, l.getDesiredIndent(j)) || c(j, l.getDesiredIndent(j));
          }
        });
      }
    });
  }
};
Gc.meta;
Gc.create;
function hb(t) {
  return t.type === "ForInStatement" || t.type === "ForOfStatement" || t.type === "ForStatement";
}
function sN(t) {
  const e = t.parent, r = e.parent;
  return hb(r) ? r.type === "ForStatement" ? r.init === e : r.left === e : !!t.init;
}
var Hc = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow initialization in variable declarations",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/init-declarations"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["never"]
        }, {
          type: "object",
          properties: {
            ignoreForLoopInit: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      initialized: "Variable '{{idName}}' should be initialized on declaration.",
      notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
    }
  },
  create(t) {
    const e = t.options[0] || "always", r = t.options[1] || {};
    return {
      "VariableDeclaration:exit"(s) {
        const n = s.kind, a = s.declarations;
        for (let o = 0; o < a.length; ++o) {
          const l = a[o], i = l.id, u = sN(l), c = r.ignoreForLoopInit && hb(s.parent);
          let f = "";
          e === "always" && !u ? f = "initialized" : e === "never" && n !== "const" && u && !c && (f = "notInitialized"), i.type === "Identifier" && f && t.report({
            node: l,
            messageId: f,
            data: {
              idName: i.name
            }
          });
        }
      }
    };
  }
};
Hc.meta;
Hc.create;
const aN = {
  "prefer-double": {
    quote: '"',
    description: "singlequote",
    convert(t) {
      return t.replace(/'/gu, '"');
    }
  },
  "prefer-single": {
    quote: "'",
    description: "doublequote",
    convert(t) {
      return t.replace(/"/gu, "'");
    }
  }
};
var Kc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the consistent use of either double or single quotes in JSX attributes",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/jsx-quotes"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["prefer-single", "prefer-double"]
    }],
    messages: {
      unexpected: "Unexpected usage of {{description}}."
    }
  },
  create(t) {
    const e = t.options[0] || "prefer-double", r = aN[e];
    function s(n) {
      return n.value.indexOf(r.quote) !== -1 || E.isSurroundedBy(n.raw, r.quote);
    }
    return {
      JSXAttribute(n) {
        const a = n.value;
        a && E.isStringLiteral(a) && !s(a) && t.report({
          node: a,
          messageId: "unexpected",
          data: {
            description: r.description
          },
          fix(o) {
            return o.replaceText(a, r.convert(a.raw));
          }
        });
      }
    };
  }
};
Kc.meta;
Kc.create;
function iN(t) {
  return E.LINEBREAK_MATCHER.test(t);
}
function Ra(t) {
  return t[t.length - 1];
}
function Ey(t) {
  return t.loc.end.line === t.loc.start.line;
}
function oN(t) {
  const [e] = t, r = Ra(t);
  return e.loc.start.line === r.loc.end.line;
}
function xs(t, e) {
  return t.mode = e.mode || "strict", typeof e.beforeColon < "u" ? t.beforeColon = +e.beforeColon : t.beforeColon = 0, typeof e.afterColon < "u" ? t.afterColon = +e.afterColon : t.afterColon = 1, typeof e.align < "u" && (typeof e.align == "object" ? t.align = e.align : t.align = {
    on: e.align,
    mode: t.mode,
    beforeColon: t.beforeColon,
    afterColon: t.afterColon
  }), t;
}
function lN(t, e) {
  return typeof e.align == "object" ? (t.align = xs({}, e.align), t.align.on = e.align.on || "colon", t.align.mode = e.align.mode || "strict", t.multiLine = xs({}, e.multiLine || e), t.singleLine = xs({}, e.singleLine || e)) : (t.multiLine = xs({}, e.multiLine || e), t.singleLine = xs({}, e.singleLine || e), t.multiLine.align && (t.align = {
    on: t.multiLine.align.on,
    mode: t.multiLine.align.mode || t.multiLine.mode,
    beforeColon: t.multiLine.align.beforeColon,
    afterColon: t.multiLine.align.afterColon
  })), t;
}
var Jc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing between keys and values in object literal properties",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/key-spacing"
    },
    fixable: "whitespace",
    schema: [{
      anyOf: [{
        type: "object",
        properties: {
          align: {
            anyOf: [{
              enum: ["colon", "value"]
            }, {
              type: "object",
              properties: {
                mode: {
                  enum: ["strict", "minimum"]
                },
                on: {
                  enum: ["colon", "value"]
                },
                beforeColon: {
                  type: "boolean"
                },
                afterColon: {
                  type: "boolean"
                }
              },
              additionalProperties: !1
            }]
          },
          mode: {
            enum: ["strict", "minimum"]
          },
          beforeColon: {
            type: "boolean"
          },
          afterColon: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }, {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          },
          multiLine: {
            type: "object",
            properties: {
              align: {
                anyOf: [{
                  enum: ["colon", "value"]
                }, {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    on: {
                      enum: ["colon", "value"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: !1
                }]
              },
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          }
        },
        additionalProperties: !1
      }, {
        type: "object",
        properties: {
          singleLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          },
          multiLine: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          },
          align: {
            type: "object",
            properties: {
              mode: {
                enum: ["strict", "minimum"]
              },
              on: {
                enum: ["colon", "value"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      extraKey: "Extra space after {{computed}}key '{{key}}'.",
      extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
      missingKey: "Missing space after {{computed}}key '{{key}}'.",
      missingValue: "Missing space before value for {{computed}}key '{{key}}'."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = lN({}, e), s = r.multiLine, n = r.singleLine, a = r.align || null, o = t.getSourceCode();
    function l(b, v) {
      const C = b.loc.start.line, T = v.loc.start.line;
      if (T - C <= 1)
        return !0;
      const w = o.getCommentsBefore(v);
      if (w.length && w[0].loc.start.line - C <= 1 && T - Ra(w).loc.end.line <= 1) {
        for (let B = 1; B < w.length; B++)
          if (w[B].loc.start.line - w[B - 1].loc.end.line > 1)
            return !1;
        return !0;
      }
      return !1;
    }
    function i(b) {
      return !(b.method || b.shorthand || b.kind !== "init" || b.type !== "Property");
    }
    function u(b) {
      const v = o.getTokenAfter(b, E.isColonToken);
      return o.getTokenBefore(v);
    }
    function c(b) {
      return o.getTokenAfter(b, E.isColonToken);
    }
    function f(b) {
      const v = b.key;
      return b.computed ? o.getText().slice(v.range[0], v.range[1]) : E.getStaticPropertyName(b);
    }
    function h(b, v, C, T, w) {
      const B = C.length - T, I = c(b.key), _ = o.getTokenBefore(I, {
        includeComments: !0
      }), S = o.getTokenAfter(I, {
        includeComments: !0
      }), F = v === "key", N = B > 0, k = Math.abs(B), j = Array(k + 1).join(" "), O = F ? _.loc.end : I.loc.start, z = F ? I.loc.start : S.loc.start, te = F ? _.loc : S.loc, se = N ? {
        start: O,
        end: z
      } : te;
      if ((B && w === "strict" || B < 0 && w === "minimum" || B > 0 && !T && w === "minimum") && !(T && iN(C))) {
        let ye;
        if (N) {
          let xe;
          F ? xe = [_.range[1], _.range[1] + k] : xe = [S.range[0] - k, S.range[0]], ye = function(Ae) {
            return Ae.removeRange(xe);
          };
        } else
          F ? ye = function(xe) {
            return xe.insertTextAfter(_, j);
          } : ye = function(xe) {
            return xe.insertTextBefore(S, j);
          };
        let Se = "";
        N ? Se = v === "key" ? "extraKey" : "extraValue" : Se = v === "key" ? "missingKey" : "missingValue", t.report({
          node: b[v],
          loc: se,
          messageId: Se,
          data: {
            computed: b.computed ? "computed " : "",
            key: f(b)
          },
          fix: ye
        });
      }
    }
    function p(b) {
      const v = o.getFirstToken(b);
      return u(b.key).range[1] - v.range[0];
    }
    function m(b) {
      const v = /(\s*):(\s*)/u.exec(o.getText().slice(b.key.range[1], b.value.range[0]));
      return v ? {
        beforeColon: v[1],
        afterColon: v[2]
      } : null;
    }
    function d(b) {
      return b.properties.length === 1 ? [b.properties] : b.properties.reduce((v, C) => {
        const T = Ra(v), w = Ra(T);
        return !w || l(w, C) ? T.push(C) : v.push([C]), v;
      }, [[]]);
    }
    function g(b) {
      const v = b.length, C = b.map(p), T = a.on;
      let w = Math.max(...C), B, I, _;
      a && v > 1 ? (B = a.beforeColon, I = a.afterColon, _ = a.mode) : (B = s.beforeColon, I = s.afterColon, _ = a.mode), w += T === "colon" ? B : I;
      for (let S = 0; S < v; S++) {
        const F = b[S], N = m(F);
        if (N) {
          const k = C[S];
          T === "value" ? (h(F, "key", N.beforeColon, B, _), h(F, "value", N.afterColon, w - k, _)) : (h(F, "key", N.beforeColon, w - k, _), h(F, "value", N.afterColon, I, _));
        }
      }
    }
    function y(b, v) {
      const C = m(b);
      C && (h(b, "key", C.beforeColon, v.beforeColon, v.mode), h(b, "value", C.afterColon, v.afterColon, v.mode));
    }
    function x(b, v) {
      const C = b.length;
      for (let T = 0; T < C; T++)
        y(b[T], v);
    }
    function A(b) {
      d(b).forEach((v) => {
        const C = v.filter(i);
        C.length > 0 && oN(C) ? x(C, s) : g(C);
      });
    }
    return a ? {
      ObjectExpression(b) {
        Ey(b) ? x(b.properties.filter(i), n) : A(b);
      }
    } : {
      Property(b) {
        y(b, Ey(b.parent) ? n : s);
      }
    };
  }
};
Jc.meta;
Jc.create;
const uN = /^[)\]}>]$/u, cN = /^(?:[([{<~!]|\+\+?|--?)$/u, va = /^[)\]}>*]$/u, by = /^[{*]$/u, pN = /\$\{$/u, fN = /^\}/u, Ea = /^(?:JSXElement|RegularExpression|String|Template)$/u, Zr = si.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
(function() {
  Zr.sort();
  for (let t = 1; t < Zr.length; ++t)
    if (Zr[t] === Zr[t - 1])
      throw new Error(`Duplication was found in the keyword list: ${Zr[t]}`);
})();
function Cy(t) {
  return t.type === "Template" && pN.test(t.value);
}
function Sy(t) {
  return t.type === "Template" && fN.test(t.value);
}
var Xc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after keywords",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/keyword-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: !0
        },
        after: {
          type: "boolean",
          default: !0
        },
        overrides: {
          type: "object",
          properties: Zr.reduce((t, e) => (t[e] = {
            type: "object",
            properties: {
              before: {
                type: "boolean"
              },
              after: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          }, t), {}),
          additionalProperties: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expectedBefore: 'Expected space(s) before "{{value}}".',
      expectedAfter: 'Expected space(s) after "{{value}}".',
      unexpectedBefore: 'Unexpected space(s) before "{{value}}".',
      unexpectedAfter: 'Unexpected space(s) after "{{value}}".'
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(x, A) {
      const b = e.getTokenBefore(x);
      b && (Ea.test(b.type) || A.test(b.value)) && !Cy(b) && E.isTokenOnSameLine(b, x) && !e.isSpaceBetweenTokens(b, x) && t.report({
        loc: x.loc,
        messageId: "expectedBefore",
        data: x,
        fix(v) {
          return v.insertTextBefore(x, " ");
        }
      });
    }
    function s(x, A) {
      const b = e.getTokenBefore(x);
      b && (Ea.test(b.type) || A.test(b.value)) && !Cy(b) && E.isTokenOnSameLine(b, x) && e.isSpaceBetweenTokens(b, x) && t.report({
        loc: {
          start: b.loc.end,
          end: x.loc.start
        },
        messageId: "unexpectedBefore",
        data: x,
        fix(v) {
          return v.removeRange([b.range[1], x.range[0]]);
        }
      });
    }
    function n(x, A) {
      const b = e.getTokenAfter(x);
      b && (Ea.test(b.type) || A.test(b.value)) && !Sy(b) && E.isTokenOnSameLine(x, b) && !e.isSpaceBetweenTokens(x, b) && t.report({
        loc: x.loc,
        messageId: "expectedAfter",
        data: x,
        fix(v) {
          return v.insertTextAfter(x, " ");
        }
      });
    }
    function a(x, A) {
      const b = e.getTokenAfter(x);
      b && (Ea.test(b.type) || A.test(b.value)) && !Sy(b) && E.isTokenOnSameLine(x, b) && e.isSpaceBetweenTokens(x, b) && t.report({
        loc: {
          start: x.loc.end,
          end: b.loc.start
        },
        messageId: "unexpectedAfter",
        data: x,
        fix(v) {
          return v.removeRange([x.range[1], b.range[0]]);
        }
      });
    }
    function o(x = {}) {
      const A = x.before !== !1, b = x.after !== !1, v = {
        before: A ? r : s,
        after: b ? n : a
      }, C = x && x.overrides || {}, T = /* @__PURE__ */ Object.create(null);
      for (let w = 0; w < Zr.length; ++w) {
        const B = Zr[w], I = C[B];
        if (I) {
          const _ = "before" in I ? I.before : A, S = "after" in I ? I.after : b;
          T[B] = {
            before: _ ? r : s,
            after: S ? n : a
          };
        } else
          T[B] = v;
      }
      return T;
    }
    const l = o(t.options[0]);
    function i(x, A) {
      l[x.value].before(x, A || uN);
    }
    function u(x, A) {
      l[x.value].after(x, A || cN);
    }
    function c(x) {
      i(x), u(x);
    }
    function f(x) {
      const A = x && e.getFirstToken(x);
      A && A.type === "Keyword" && c(A);
    }
    function h(x) {
      const A = x && e.getFirstToken(x);
      A && A.type === "Keyword" && i(A);
    }
    function p(x) {
      if (x) {
        const A = e.getTokenBefore(x, E.isKeywordToken);
        c(A);
      }
    }
    function m(x) {
      const A = x && e.getFirstToken(x);
      A && (A.type === "Keyword" && A.value === "function" || A.value === "async") && i(A);
    }
    function d(x) {
      f(x), p(x.superClass);
    }
    function g(x) {
      const A = e.getFirstToken(x);
      if (i(A, va), u(A, by), x.type === "ExportDefaultDeclaration" && c(e.getTokenAfter(A)), x.type === "ExportAllDeclaration" && x.exported) {
        const b = e.getTokenBefore(x.exported);
        i(b, va);
      }
      if (x.source) {
        const b = e.getTokenBefore(x.source);
        i(b, va), u(b, by);
      }
    }
    function y(x) {
      if (x.static && f(x), x.kind === "get" || x.kind === "set" || (x.method || x.type === "MethodDefinition") && x.value.async) {
        const A = e.getTokenBefore(x.key, (b) => {
          switch (b.value) {
            case "get":
            case "set":
            case "async":
              return !0;
            default:
              return !1;
          }
        });
        if (!A)
          throw new Error("Failed to find token get, set, or async beside method name");
        c(A);
      }
    }
    return {
      DebuggerStatement: f,
      WithStatement: f,
      BreakStatement: f,
      ContinueStatement: f,
      ReturnStatement: f,
      ThrowStatement: f,
      TryStatement: function(x) {
        f(x), f(x.handler), p(x.finalizer);
      },
      IfStatement: function(x) {
        f(x), p(x.alternate);
      },
      SwitchStatement: f,
      SwitchCase: f,
      DoWhileStatement: function(x) {
        f(x), p(x.test);
      },
      ForInStatement: function(x) {
        f(x), p(x.right);
      },
      ForOfStatement: function(x) {
        x.await ? (i(e.getFirstToken(x, 0)), u(e.getFirstToken(x, 1))) : f(x), c(e.getTokenBefore(x.right, E.isNotOpeningParenToken));
      },
      ForStatement: f,
      WhileStatement: f,
      ClassDeclaration: d,
      ExportNamedDeclaration: g,
      ExportDefaultDeclaration: g,
      ExportAllDeclaration: g,
      FunctionDeclaration: m,
      ImportDeclaration: g,
      VariableDeclaration: f,
      ArrowFunctionExpression: m,
      AwaitExpression: function(x) {
        i(e.getFirstToken(x));
      },
      ClassExpression: d,
      FunctionExpression: m,
      NewExpression: h,
      Super: h,
      ThisExpression: h,
      UnaryExpression: h,
      YieldExpression: h,
      ImportNamespaceSpecifier: function(x) {
        const A = e.getFirstToken(x, 1);
        i(A, va);
      },
      MethodDefinition: y,
      Property: y
    };
  }
};
Xc.meta;
Xc.create;
var Qc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce position of line comments",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/line-comment-position"
    },
    schema: [{
      oneOf: [{
        enum: ["above", "beside"]
      }, {
        type: "object",
        properties: {
          position: {
            enum: ["above", "beside"]
          },
          ignorePattern: {
            type: "string"
          },
          applyDefaultPatterns: {
            type: "boolean"
          },
          applyDefaultIgnorePatterns: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      above: "Expected comment to be above code.",
      beside: "Expected comment to be beside code."
    }
  },
  create(t) {
    const e = t.options[0];
    let r, s, n = !0;
    !e || typeof e == "string" ? r = !e || e === "above" : (r = !e.position || e.position === "above", s = e.ignorePattern, Object.prototype.hasOwnProperty.call(e, "applyDefaultIgnorePatterns") ? n = e.applyDefaultIgnorePatterns : n = e.applyDefaultPatterns !== !1);
    const a = E.COMMENTS_IGNORE_PATTERN, o = new RegExp(s, "u"), l = t.getSourceCode();
    return {
      Program() {
        l.getAllComments().filter((u) => u.type === "Line").forEach((u) => {
          if (n && (a.test(u.value) || /^\s*falls?\s?through/u.test(u.value)) || s && o.test(u.value))
            return;
          const c = l.getTokenBefore(u, {
            includeComments: !0
          }), f = c && c.loc.end.line === u.loc.start.line;
          r ? f && t.report({
            node: u,
            messageId: "above"
          }) : f || t.report({
            node: u,
            messageId: "beside"
          });
        });
      }
    };
  }
};
Qc.meta;
Qc.create;
var Yc = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent linebreak style",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/linebreak-style"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["unix", "windows"]
    }],
    messages: {
      expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
      expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s, n) {
      return function(a) {
        return a.replaceTextRange(s, n);
      };
    }
    return {
      Program: function(s) {
        const n = t.options[0] || "unix", a = n === "unix", o = a ? `
` : `\r
`, l = e.getText(), i = E.createGlobalLinebreakMatcher();
        let u, c = 0;
        for (; (u = i.exec(l)) !== null; ) {
          if (c++, u[0] === o)
            continue;
          const f = u.index, h = [f, f + u[0].length];
          t.report({
            node: s,
            loc: {
              start: {
                line: c,
                column: e.lines[c - 1].length
              },
              end: {
                line: c + 1,
                column: 0
              }
            },
            messageId: a ? "expectedLF" : "expectedCRLF",
            fix: r(h, o)
          });
        }
      }
    };
  }
};
Yc.meta;
Yc.create;
function hN(t) {
  return t.map((r, s) => ({
    code: r.trim(),
    num: s + 1
  })).filter((r) => !r.code).map((r) => r.num);
}
function mN(t) {
  const e = [];
  return t.forEach((r) => {
    const s = r.loc.start.line, n = r.loc.end.line;
    e.push(s, n);
  }), e;
}
var Zc = {
  meta: {
    type: "layout",
    docs: {
      description: "require empty lines around comments",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/lines-around-comment"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        beforeBlockComment: {
          type: "boolean",
          default: !0
        },
        afterBlockComment: {
          type: "boolean",
          default: !1
        },
        beforeLineComment: {
          type: "boolean",
          default: !1
        },
        afterLineComment: {
          type: "boolean",
          default: !1
        },
        allowBlockStart: {
          type: "boolean",
          default: !1
        },
        allowBlockEnd: {
          type: "boolean",
          default: !1
        },
        allowClassStart: {
          type: "boolean"
        },
        allowClassEnd: {
          type: "boolean"
        },
        allowObjectStart: {
          type: "boolean"
        },
        allowObjectEnd: {
          type: "boolean"
        },
        allowArrayStart: {
          type: "boolean"
        },
        allowArrayEnd: {
          type: "boolean"
        },
        ignorePattern: {
          type: "string"
        },
        applyDefaultIgnorePatterns: {
          type: "boolean"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      after: "Expected line after comment.",
      before: "Expected line before comment."
    }
  },
  create(t) {
    const e = Object.assign({}, t.options[0]), r = e.ignorePattern, s = E.COMMENTS_IGNORE_PATTERN, n = new RegExp(r, "u"), a = e.applyDefaultIgnorePatterns !== !1;
    e.beforeBlockComment = typeof e.beforeBlockComment < "u" ? e.beforeBlockComment : !0;
    const o = t.getSourceCode(), l = o.lines, i = l.length + 1, u = o.getAllComments(), c = mN(u), f = hN(l), h = c.concat(f);
    function p(_) {
      let S = _;
      do
        S = o.getTokenBefore(S, {
          includeComments: !0
        });
      while (S && E.isCommentToken(S));
      if (S && E.isTokenOnSameLine(S, _))
        return !0;
      S = _;
      do
        S = o.getTokenAfter(S, {
          includeComments: !0
        });
      while (S && E.isCommentToken(S));
      return !!(S && E.isTokenOnSameLine(_, S));
    }
    function m(_, S) {
      return _.type === S || _.body && _.body.type === S || _.consequent && _.consequent.type === S;
    }
    function d(_) {
      return o.getNodeByRangeIndex(_.range[0]);
    }
    function g(_, S) {
      const F = d(_);
      return F && m(F, S) && _.loc.start.line - F.loc.start.line === 1;
    }
    function y(_, S) {
      const F = d(_);
      return F && m(F, S) && F.loc.end.line - _.loc.end.line === 1;
    }
    function x(_) {
      return g(_, "ClassBody") || g(_, "BlockStatement") || g(_, "SwitchCase");
    }
    function A(_) {
      return y(_, "ClassBody") || y(_, "BlockStatement") || y(_, "SwitchCase") || y(_, "SwitchStatement");
    }
    function b(_) {
      return g(_, "ClassBody");
    }
    function v(_) {
      return y(_, "ClassBody");
    }
    function C(_) {
      return g(_, "ObjectExpression") || g(_, "ObjectPattern");
    }
    function T(_) {
      return y(_, "ObjectExpression") || y(_, "ObjectPattern");
    }
    function w(_) {
      return g(_, "ArrayExpression") || g(_, "ArrayPattern");
    }
    function B(_) {
      return y(_, "ArrayExpression") || y(_, "ArrayPattern");
    }
    function I(_, S) {
      if (a && s.test(_.value) || r && n.test(_.value))
        return;
      let F = S.after, N = S.before;
      const k = _.loc.start.line - 1, j = _.loc.end.line + 1, O = p(_), z = e.allowBlockStart && x(_) && !(e.allowClassStart === !1 && b(_)), te = e.allowBlockEnd && A(_) && !(e.allowClassEnd === !1 && v(_)), se = e.allowClassStart && b(_), ye = e.allowClassEnd && v(_), Se = e.allowObjectStart && C(_), xe = e.allowObjectEnd && T(_), Ae = e.allowArrayStart && w(_), _e = e.allowArrayEnd && B(_);
      if (k < 1 && (N = !1), j >= i && (F = !1), O)
        return;
      const H = o.getTokenBefore(_, {
        includeComments: !0
      }), Q = o.getTokenAfter(_, {
        includeComments: !0
      });
      if (!(z || se || Se || Ae) && N && !h.includes(k) && !(E.isCommentToken(H) && E.isTokenOnSameLine(H, _))) {
        const ge = _.range[0] - _.loc.start.column, ae = [ge, ge];
        t.report({
          node: _,
          messageId: "before",
          fix(ee) {
            return ee.insertTextBeforeRange(ae, `
`);
          }
        });
      }
      !(te || ye || xe || _e) && F && !h.includes(j) && !(E.isCommentToken(Q) && E.isTokenOnSameLine(_, Q)) && t.report({
        node: _,
        messageId: "after",
        fix(ge) {
          return ge.insertTextAfter(_, `
`);
        }
      });
    }
    return {
      Program() {
        u.forEach((_) => {
          _.type === "Line" ? (e.beforeLineComment || e.afterLineComment) && I(_, {
            after: e.afterLineComment,
            before: e.beforeLineComment
          }) : _.type === "Block" && (e.beforeBlockComment || e.afterBlockComment) && I(_, {
            after: e.afterBlockComment,
            before: e.beforeBlockComment
          });
        });
      }
    };
  }
};
Zc.meta;
Zc.create;
var ep = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow newlines around directives",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/lines-around-directive"
    },
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          before: {
            enum: ["always", "never"]
          },
          after: {
            enum: ["always", "never"]
          }
        },
        additionalProperties: !1,
        minProperties: 2
      }]
    }],
    fixable: "whitespace",
    messages: {
      expected: 'Expected newline {{location}} "{{value}}" directive.',
      unexpected: 'Unexpected newline {{location}} "{{value}}" directive.'
    },
    deprecated: !0,
    replacedBy: ["padding-line-between-statements"]
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || "always", s = typeof r == "string" ? r : r.before, n = typeof r == "string" ? r : r.after;
    function a(c) {
      const f = e.getTokenBefore(c, {
        includeComments: !0
      }), h = f ? f.loc.end.line : 0;
      return c.loc.start.line - h >= 2;
    }
    function o(c) {
      const f = e.getLastToken(c), h = e.getTokenBefore(f);
      return E.isSemicolonToken(f) && f.loc.start.line > h.loc.end.line ? h : f;
    }
    function l(c) {
      const f = o(c);
      return e.getTokenAfter(f, {
        includeComments: !0
      }).loc.start.line - f.loc.end.line >= 2;
    }
    function i(c, f, h) {
      t.report({
        node: c,
        messageId: h ? "expected" : "unexpected",
        data: {
          value: c.expression.value,
          location: f
        },
        fix(p) {
          const m = o(c);
          return h ? f === "before" ? p.insertTextBefore(c, `
`) : p.insertTextAfter(m, `
`) : p.removeRange(f === "before" ? [c.range[0] - 1, c.range[0]] : [m.range[1], m.range[1] + 1]);
        }
      });
    }
    function u(c) {
      const f = E.getDirectivePrologue(c);
      if (!f.length)
        return;
      const h = f[0], p = e.getCommentsBefore(h);
      p.length ? (s === "always" && !a(h) && i(h, "before", !0), s === "never" && a(h) && i(h, "before", !1)) : c.type === "Program" && s === "never" && !p.length && a(h) && i(h, "before", !1);
      const m = f[f.length - 1], d = c.type === "Program" ? c.body : c.body.body;
      m === d[d.length - 1] && !m.trailingComments || (n === "always" && !l(m) && i(m, "after", !0), n === "never" && l(m) && i(m, "after", !1));
    }
    return {
      Program: u,
      FunctionDeclaration: u,
      FunctionExpression: u,
      ArrowFunctionExpression: u
    };
  }
};
ep.meta;
ep.create;
var tp = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow an empty line between class members",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/lines-between-class-members"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptAfterSingleLine: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      never: "Unexpected blank line between class members.",
      always: "Expected blank line between class members."
    }
  },
  create(t) {
    const e = [];
    e[0] = t.options[0] || "always", e[1] = t.options[1] || {
      exceptAfterSingleLine: !1
    };
    const r = t.getSourceCode();
    function s(o, l, i) {
      const u = r.getTokenAfter(o, {
        includeComments: !0
      });
      return u !== l && u.loc.start.line - o.loc.end.line <= i ? s(u, l, i) : o;
    }
    function n(o, l, i) {
      const u = r.getTokenBefore(o, {
        includeComments: !0
      });
      return u !== l && o.loc.start.line - u.loc.end.line <= i ? n(u, l, i) : o;
    }
    function a(o, l) {
      return r.getTokensBetween(o, l, {
        includeComments: !0
      }).length !== 0;
    }
    return {
      ClassBody(o) {
        const l = o.body;
        for (let i = 0; i < l.length - 1; i++) {
          const u = r.getFirstToken(l[i]), c = r.getLastToken(l[i]), f = r.getFirstToken(l[i + 1]), p = !!E.isTokenOnSameLine(u, c) && e[1].exceptAfterSingleLine, m = s(c, f, 1), d = n(f, c, 1), g = d.loc.start.line - m.loc.end.line > 1, y = a(m, d), x = s(c, f, 0);
          (e[0] === "always" && !p && !g || e[0] === "never" && g) && t.report({
            node: l[i + 1],
            messageId: g ? "never" : "always",
            fix(A) {
              return y ? null : g ? A.replaceTextRange([m.range[1], d.range[0]], `
`) : A.insertTextAfter(x, `
`);
            }
          });
        }
      }
    };
  }
};
tp.meta;
tp.create;
var rp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of classes per file",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-classes-per-file"
    },
    schema: [{
      type: "integer",
      minimum: 1
    }],
    messages: {
      maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."
    }
  },
  create(t) {
    const e = t.options[0] || 1;
    let r = 0;
    return {
      Program() {
        r = 0;
      },
      "Program:exit"(s) {
        r > e && t.report({
          node: s,
          messageId: "maximumExceeded",
          data: {
            classCount: r,
            max: e
          }
        });
      },
      "ClassDeclaration, ClassExpression"() {
        r++;
      }
    };
  }
};
rp.meta;
rp.create;
var np = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that blocks can be nested",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-depth"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."
    }
  },
  create(t) {
    const e = [], r = t.options[0];
    let s = 4;
    typeof r == "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) && (s = r.maximum || r.max), typeof r == "number" && (s = r);
    function n() {
      e.push(0);
    }
    function a() {
      e.pop();
    }
    function o(i) {
      const u = ++e[e.length - 1];
      u > s && t.report({
        node: i,
        messageId: "tooDeeply",
        data: {
          depth: u,
          maxDepth: s
        }
      });
    }
    function l() {
      e[e.length - 1]--;
    }
    return {
      Program: n,
      FunctionDeclaration: n,
      FunctionExpression: n,
      ArrowFunctionExpression: n,
      IfStatement(i) {
        i.parent.type !== "IfStatement" && o(i);
      },
      SwitchStatement: o,
      TryStatement: o,
      DoWhileStatement: o,
      WhileStatement: o,
      WithStatement: o,
      ForStatement: o,
      ForInStatement: o,
      ForOfStatement: o,
      "IfStatement:exit": l,
      "SwitchStatement:exit": l,
      "TryStatement:exit": l,
      "DoWhileStatement:exit": l,
      "WhileStatement:exit": l,
      "WithStatement:exit": l,
      "ForStatement:exit": l,
      "ForInStatement:exit": l,
      "ForOfStatement:exit": l,
      "FunctionDeclaration:exit": a,
      "FunctionExpression:exit": a,
      "ArrowFunctionExpression:exit": a,
      "Program:exit": a
    };
  }
};
np.meta;
np.create;
const mb = {
  type: "object",
  properties: {
    code: {
      type: "integer",
      minimum: 0
    },
    comments: {
      type: "integer",
      minimum: 0
    },
    tabWidth: {
      type: "integer",
      minimum: 0
    },
    ignorePattern: {
      type: "string"
    },
    ignoreComments: {
      type: "boolean"
    },
    ignoreStrings: {
      type: "boolean"
    },
    ignoreUrls: {
      type: "boolean"
    },
    ignoreTemplateLiterals: {
      type: "boolean"
    },
    ignoreRegExpLiterals: {
      type: "boolean"
    },
    ignoreTrailingComments: {
      type: "boolean"
    }
  },
  additionalProperties: !1
}, Ay = {
  anyOf: [mb, {
    type: "integer",
    minimum: 0
  }]
};
var sp = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce a maximum line length",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-len"
    },
    schema: [Ay, Ay, mb],
    messages: {
      max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
      maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(w, B) {
      let I = 0;
      return w.replace(/\t/gu, (_, S) => {
        const F = S + I, N = B ? F % B : 0;
        I += B - N - 1;
      }), Array.from(w).length + I;
    }
    const s = Object.assign({}, t.options[t.options.length - 1]);
    typeof t.options[0] == "number" && (s.code = t.options[0]), typeof t.options[1] == "number" && (s.tabWidth = t.options[1]);
    const n = typeof s.code == "number" ? s.code : 80, a = typeof s.tabWidth == "number" ? s.tabWidth : 4, o = !!s.ignoreComments, l = !!s.ignoreStrings, i = !!s.ignoreTemplateLiterals, u = !!s.ignoreRegExpLiterals, c = !!s.ignoreTrailingComments || !!s.ignoreComments, f = !!s.ignoreUrls, h = s.comments;
    let p = s.ignorePattern || null;
    p && (p = new RegExp(p, "u"));
    function m(w, B, I) {
      return I && I.loc.start.line === B && B <= I.loc.end.line && (I.loc.end.line > B || I.loc.end.column === w.length);
    }
    function d(w, B, I) {
      const _ = I.loc.start, S = I.loc.end, F = !w.slice(0, I.loc.start.column).trim();
      return I && (_.line < B || _.line === B && F) && (S.line > B || S.line === B && S.column === w.length);
    }
    function g(w) {
      if (!w || !w.parent || w.type !== "JSXEmptyExpression" || w.parent.type !== "JSXExpressionContainer")
        return !1;
      const B = w.parent;
      return B.loc.start.line === B.loc.end.line;
    }
    function y(w, B) {
      return w.slice(0, B.loc.start.column).replace(/\s+$/u, "");
    }
    function x(w, B, I) {
      Array.isArray(w[B]) || (w[B] = []), w[B].push(I);
    }
    function A() {
      return e.ast.tokens.filter((w) => w.type === "String" || w.type === "JSXText" && e.getNodeByRangeIndex(w.range[0] - 1).type === "JSXAttribute");
    }
    function b() {
      return e.ast.tokens.filter((w) => w.type === "Template");
    }
    function v() {
      return e.ast.tokens.filter((w) => w.type === "RegularExpression");
    }
    function C(w, B) {
      for (let I = B.loc.start.line; I <= B.loc.end.line; ++I)
        x(w, I, B);
      return w;
    }
    function T() {
      const w = [];
      return e.getAllComments().forEach((B) => {
        const I = e.getNodeByRangeIndex(B.range[0]);
        g(I) ? w[w.length - 1] !== I.parent && w.push(I.parent) : w.push(B);
      }), w;
    }
    return {
      Program: function(w) {
        const B = e.lines, I = o || h || c ? T() : [];
        let _ = 0;
        const F = A().reduce(C, {}), k = b().reduce(C, {}), O = v().reduce(C, {});
        B.forEach((z, te) => {
          const se = te + 1;
          let ye = !1, Se;
          if (_ < I.length) {
            let H = null;
            do
              H = I[++_];
            while (H && H.loc.start.line <= se);
            if (H = I[--_], d(z, se, H))
              ye = !0, Se = z;
            else if (c && m(z, se, H)) {
              Se = y(z, H);
              let Q = _;
              for (; m(Se, se, I[--Q]); )
                Se = y(Se, I[Q]);
            } else
              Se = z;
          } else
            Se = z;
          if (p && p.test(Se) || f && /[^:/?#]:\/\/[^?#]/u.test(Se) || l && F[se] || i && k[se] || u && O[se])
            return;
          const xe = r(Se, a), Ae = ye && h;
          if (ye && o)
            return;
          const _e = {
            start: {
              line: se,
              column: 0
            },
            end: {
              line: se,
              column: Se.length
            }
          };
          Ae ? xe > h && t.report({
            node: w,
            loc: _e,
            messageId: "maxComment",
            data: {
              lineLength: xe,
              maxCommentLength: h
            }
          }) : xe > n && t.report({
            node: w,
            loc: _e,
            messageId: "max",
            data: {
              lineLength: xe,
              maxLength: n
            }
          });
        });
      }
    };
  }
};
sp.meta;
sp.create;
const {
  upperCaseFirst: dN
} = Xs, gN = {
  type: "object",
  properties: {
    max: {
      type: "integer",
      minimum: 0
    },
    skipComments: {
      type: "boolean"
    },
    skipBlankLines: {
      type: "boolean"
    },
    IIFEs: {
      type: "boolean"
    }
  },
  additionalProperties: !1
}, yN = {
  oneOf: [gN, {
    type: "integer",
    minimum: 1
  }]
};
function xN(t) {
  const e = /* @__PURE__ */ new Map();
  return t.forEach((r) => {
    for (let s = r.loc.start.line; s <= r.loc.end.line; s++)
      e.set(s, r);
  }), e;
}
var ap = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of lines of code in a function",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-lines-per-function"
    },
    schema: [yN],
    messages: {
      exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = e.lines, s = t.options[0];
    let n = 50, a = !1, o = !1, l = !1;
    typeof s == "object" ? (n = typeof s.max == "number" ? s.max : 50, a = !!s.skipComments, o = !!s.skipBlankLines, l = !!s.IIFEs) : typeof s == "number" && (n = s);
    const i = xN(e.getAllComments());
    function u(p, m, d) {
      const g = d.loc.start, y = d.loc.end, x = g.line === m && !p.slice(0, g.column).trim(), A = y.line === m && !p.slice(y.column).trim();
      return d && (g.line < m || x) && (y.line > m || A);
    }
    function c(p) {
      return (p.type === "FunctionExpression" || p.type === "ArrowFunctionExpression") && p.parent && p.parent.type === "CallExpression" && p.parent.callee === p;
    }
    function f(p) {
      return !p.parent || p !== p.parent.value ? !1 : p.parent.type === "MethodDefinition" ? !0 : p.parent.type === "Property" ? p.parent.method === !0 || p.parent.kind === "get" || p.parent.kind === "set" : !1;
    }
    function h(p) {
      const m = f(p) ? p.parent : p;
      if (!l && c(m))
        return;
      let d = 0;
      for (let g = m.loc.start.line - 1; g < m.loc.end.line; ++g) {
        const y = r[g];
        a && i.has(g + 1) && u(y, g + 1, i.get(g + 1)) || o && y.match(/^\s*$/u) || d++;
      }
      if (d > n) {
        const g = dN(E.getFunctionNameWithKind(p));
        t.report({
          node: m,
          messageId: "exceed",
          data: {
            name: g,
            lineCount: d,
            maxLines: n
          }
        });
      }
    }
    return {
      FunctionDeclaration: h,
      FunctionExpression: h,
      ArrowFunctionExpression: h
    };
  }
};
ap.meta;
ap.create;
function vN(t, e) {
  return [...Array(e - t).keys()].map((r) => r + t);
}
var ip = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of lines per file",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-lines"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          max: {
            type: "integer",
            minimum: 0
          },
          skipComments: {
            type: "boolean"
          },
          skipBlankLines: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}."
    }
  },
  create(t) {
    const e = t.options[0];
    let r = 300;
    typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "max") ? r = e.max : typeof e == "number" && (r = e);
    const s = e && e.skipComments, n = e && e.skipBlankLines, a = t.getSourceCode();
    function o(u) {
      return u && (u.type === "Block" || u.type === "Line");
    }
    function l(u) {
      let c = u.loc.start.line, f = u.loc.end.line, h = u;
      do
        h = a.getTokenBefore(h, {
          includeComments: !0
        });
      while (o(h));
      h && E.isTokenOnSameLine(h, u) && (c += 1), h = u;
      do
        h = a.getTokenAfter(h, {
          includeComments: !0
        });
      while (o(h));
      return h && E.isTokenOnSameLine(u, h) && (f -= 1), c <= f ? vN(c, f + 1) : [];
    }
    function i(u, c) {
      const f = u.map(c);
      return [].concat(...f);
    }
    return {
      "Program:exit"() {
        let u = a.lines.map((c, f) => ({
          lineNumber: f + 1,
          text: c
        }));
        if (u.length > 1 && u[u.length - 1].text === "" && u.pop(), n && (u = u.filter((c) => c.text.trim() !== "")), s) {
          const c = a.getAllComments(), f = i(c, (h) => l(h));
          u = u.filter((h) => !f.includes(h.lineNumber));
        }
        if (u.length > r) {
          const c = {
            start: {
              line: u[r].lineNumber,
              column: 0
            },
            end: {
              line: a.lines.length,
              column: a.lines[a.lines.length - 1].length
            }
          };
          t.report({
            loc: c,
            messageId: "exceed",
            data: {
              max: r,
              actual: u.length
            }
          });
        }
      }
    };
  }
};
ip.meta;
ip.create;
var op = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum depth that callbacks can be nested",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-nested-callbacks"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
    }
  },
  create(t) {
    const e = t.options[0];
    let r = 10;
    typeof e == "object" && (Object.prototype.hasOwnProperty.call(e, "maximum") || Object.prototype.hasOwnProperty.call(e, "max")) ? r = e.maximum || e.max : typeof e == "number" && (r = e);
    const s = [];
    function n(o) {
      if (o.parent.type === "CallExpression" && s.push(o), s.length > r) {
        const i = {
          num: s.length,
          max: r
        };
        t.report({
          node: o,
          messageId: "exceed",
          data: i
        });
      }
    }
    function a() {
      s.pop();
    }
    return {
      ArrowFunctionExpression: n,
      "ArrowFunctionExpression:exit": a,
      FunctionExpression: n,
      "FunctionExpression:exit": a
    };
  }
};
op.meta;
op.create;
const {
  upperCaseFirst: EN
} = Xs;
var lp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of parameters in function definitions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-params"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0];
    let s = 3;
    typeof r == "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) && (s = r.maximum || r.max), typeof r == "number" && (s = r);
    function n(a) {
      a.params.length > s && t.report({
        loc: E.getFunctionHeadLoc(a, e),
        node: a,
        messageId: "exceed",
        data: {
          name: EN(E.getFunctionNameWithKind(a)),
          count: a.params.length,
          max: s
        }
      });
    }
    return {
      FunctionDeclaration: n,
      ArrowFunctionExpression: n,
      FunctionExpression: n
    };
  }
};
lp.meta;
lp.create;
var up = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce a maximum number of statements allowed per line",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-statements-per-line"
    },
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 1,
          default: 1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || {}, s = typeof r.max < "u" ? r.max : 1;
    let n = 0, a = 0, o;
    function l() {
      o && t.report({
        node: o,
        messageId: "exceed",
        data: {
          numberOfStatementsOnThisLine: a,
          maxStatementsPerLine: s,
          statements: a === 1 ? "statement" : "statements"
        }
      }), o = null;
    }
    function i(f) {
      return e.getLastToken(f, E.isNotSemicolonToken);
    }
    function u(f) {
      const h = f.loc.start.line;
      /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u.test(f.parent.type) && f.parent.alternate !== f || (h === n ? a += 1 : (l(), a = 1, n = h), a === s + 1 && (o = o || f));
    }
    function c(f) {
      const h = i(f).loc.end.line;
      h !== n && (l(), a = 1, n = h);
    }
    return {
      BreakStatement: u,
      ClassDeclaration: u,
      ContinueStatement: u,
      DebuggerStatement: u,
      DoWhileStatement: u,
      ExpressionStatement: u,
      ForInStatement: u,
      ForOfStatement: u,
      ForStatement: u,
      FunctionDeclaration: u,
      IfStatement: u,
      ImportDeclaration: u,
      LabeledStatement: u,
      ReturnStatement: u,
      SwitchStatement: u,
      ThrowStatement: u,
      TryStatement: u,
      VariableDeclaration: u,
      WhileStatement: u,
      WithStatement: u,
      ExportNamedDeclaration: u,
      ExportDefaultDeclaration: u,
      ExportAllDeclaration: u,
      "BreakStatement:exit": c,
      "ClassDeclaration:exit": c,
      "ContinueStatement:exit": c,
      "DebuggerStatement:exit": c,
      "DoWhileStatement:exit": c,
      "ExpressionStatement:exit": c,
      "ForInStatement:exit": c,
      "ForOfStatement:exit": c,
      "ForStatement:exit": c,
      "FunctionDeclaration:exit": c,
      "IfStatement:exit": c,
      "ImportDeclaration:exit": c,
      "LabeledStatement:exit": c,
      "ReturnStatement:exit": c,
      "SwitchStatement:exit": c,
      "ThrowStatement:exit": c,
      "TryStatement:exit": c,
      "VariableDeclaration:exit": c,
      "WhileStatement:exit": c,
      "WithStatement:exit": c,
      "ExportNamedDeclaration:exit": c,
      "ExportDefaultDeclaration:exit": c,
      "ExportAllDeclaration:exit": c,
      "Program:exit": l
    };
  }
};
up.meta;
up.create;
const {
  upperCaseFirst: bN
} = Xs;
var cp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a maximum number of statements allowed in function blocks",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/max-statements"
    },
    schema: [{
      oneOf: [{
        type: "integer",
        minimum: 0
      }, {
        type: "object",
        properties: {
          maximum: {
            type: "integer",
            minimum: 0
          },
          max: {
            type: "integer",
            minimum: 0
          }
        },
        additionalProperties: !1
      }]
    }, {
      type: "object",
      properties: {
        ignoreTopLevelFunctions: {
          type: "boolean"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
    }
  },
  create(t) {
    const e = [], r = t.options[0], s = t.options[1] && t.options[1].ignoreTopLevelFunctions || !1, n = [];
    let a = 10;
    typeof r == "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) ? a = r.maximum || r.max : typeof r == "number" && (a = r);
    function o(u, c, f) {
      if (c > f) {
        const h = bN(E.getFunctionNameWithKind(u));
        t.report({
          node: u,
          messageId: "exceed",
          data: {
            name: h,
            count: c,
            max: f
          }
        });
      }
    }
    function l() {
      e.push(0);
    }
    function i(u) {
      const c = e.pop();
      s && e.length === 0 ? n.push({
        node: u,
        count: c
      }) : o(u, c, a);
    }
    return {
      FunctionDeclaration: l,
      FunctionExpression: l,
      ArrowFunctionExpression: l,
      BlockStatement: function(u) {
        e[e.length - 1] += u.body.length;
      },
      "FunctionDeclaration:exit": i,
      "FunctionExpression:exit": i,
      "ArrowFunctionExpression:exit": i,
      "Program:exit"() {
        n.length !== 1 && n.forEach((u) => {
          const c = u.count, f = u.node;
          o(f, c, a);
        });
      }
    };
  }
};
cp.meta;
cp.create;
var pp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce a particular style for multiline comments",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/multiline-comment-style"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["starred-block", "separate-lines", "bare-block"]
    }],
    messages: {
      expectedBlock: "Expected a block comment instead of consecutive line comments.",
      expectedBareBlock: "Expected a block comment without padding stars.",
      startNewline: "Expected a linebreak after '/*'.",
      endNewline: "Expected a linebreak before '*/'.",
      missingStar: "Expected a '*' at the start of this line.",
      alignment: "Expected this line to be aligned with the start of the comment.",
      expectedLines: "Expected multiple line comments instead of a block comment."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || "starred-block";
    function s(d) {
      return /^\s*\*/u.test(d);
    }
    function n([d]) {
      if (d.type !== "Block")
        return !1;
      const g = d.value.split(E.LINEBREAK_MATCHER);
      return g.length > 0 && g.every((y, x) => (x === 0 || x === g.length - 1 ? /^\s*$/u : /^\s*\*/u).test(y));
    }
    function a([d]) {
      if (d.type !== "Block")
        return !1;
      const g = d.value.split(E.LINEBREAK_MATCHER);
      return /^\*\s*$/u.test(g[0]) && g.slice(1, -1).every((y) => /^\s* /u.test(y)) && /^\s*$/u.test(g[g.length - 1]);
    }
    function o(d) {
      const g = d.map(({
        value: y
      }) => y).filter((y) => y.trim().length).every((y) => y.startsWith(" "));
      return d.map(({
        value: y
      }) => g ? y.replace(/^ /u, "") : y);
    }
    function l(d) {
      const g = d.value.split(E.LINEBREAK_MATCHER).filter((x, A, b) => !(A === 0 || A === b.length - 1)).map((x) => x.replace(/^\s*$/u, "")), y = g.map((x) => x.replace(/\s*\*/u, "")).filter((x) => x.trim().length).every((x) => x.startsWith(" "));
      return g.map((x) => x.replace(y ? /\s*\* ?/u : /\s*\*/u, ""));
    }
    function i(d) {
      const g = d.value.split(E.LINEBREAK_MATCHER).map((A) => A.replace(/^\s*$/u, "")), y = `${e.text.slice(d.range[0] - d.loc.start.column, d.range[0])}   `;
      let x = "";
      for (const [A, b] of g.entries()) {
        if (!b.trim().length || A === 0)
          continue;
        const [, v] = b.match(/^(\s*\*?\s*)/u);
        if (v.length < y.length) {
          const C = y.slice(v.length - y.length);
          C.length > x.length && (x = C);
        }
      }
      return g.map((A) => {
        const b = A.match(/^(\s*\*?\s*)(.*)/u), [, v, C] = b;
        return v.length > y.length ? `${v.slice(y.length - (x.length + v.length))}${C}` : v.length < y.length ? `${v.slice(y.length)}${C}` : C;
      });
    }
    function u(d) {
      const [g] = d;
      return g.type === "Line" ? o(d) : n(d) ? l(g) : i(g);
    }
    function c(d) {
      return e.text.slice(d.range[0] - d.loc.start.column, d.range[0]);
    }
    function f(d, g) {
      const y = c(d);
      return `/*
${g.map((x) => `${y} * ${x}`).join(`
`)}
${y} */`;
    }
    function h(d, g) {
      return g.map((y) => `// ${y}`).join(`
${c(d)}`);
    }
    function p(d, g) {
      return `/* ${g.join(`
${c(d)}   `)} */`;
    }
    const m = {
      "starred-block"(d) {
        const [g] = d, y = u(d);
        if (!y.some((x) => x.includes("*/")))
          if (d.length > 1)
            t.report({
              loc: {
                start: g.loc.start,
                end: d[d.length - 1].loc.end
              },
              messageId: "expectedBlock",
              fix(x) {
                const A = [g.range[0], d[d.length - 1].range[1]];
                return y.some((b) => b.startsWith("/")) ? null : x.replaceTextRange(A, f(g, y));
              }
            });
          else {
            const x = g.value.split(E.LINEBREAK_MATCHER), b = `${c(g)} *`;
            if (!/^\*?\s*$/u.test(x[0])) {
              const v = g.value.startsWith("*") ? g.range[0] + 1 : g.range[0];
              t.report({
                loc: {
                  start: g.loc.start,
                  end: {
                    line: g.loc.start.line,
                    column: g.loc.start.column + 2
                  }
                },
                messageId: "startNewline",
                fix: (C) => C.insertTextAfterRange([v, v + 2], `
${b}`)
              });
            }
            /^\s*$/u.test(x[x.length - 1]) || t.report({
              loc: {
                start: {
                  line: g.loc.end.line,
                  column: g.loc.end.column - 2
                },
                end: g.loc.end
              },
              messageId: "endNewline",
              fix: (v) => v.replaceTextRange([g.range[1] - 2, g.range[1]], `
${b}/`)
            });
            for (let v = g.loc.start.line + 1; v <= g.loc.end.line; v++) {
              const C = e.lines[v - 1], T = s(C) ? "alignment" : "missingStar";
              C.startsWith(b) || t.report({
                loc: {
                  start: {
                    line: v,
                    column: 0
                  },
                  end: {
                    line: v,
                    column: C.length
                  }
                },
                messageId: T,
                fix(w) {
                  const B = e.getIndexFromLoc({
                    line: v,
                    column: 0
                  });
                  if (T === "alignment") {
                    const [, F = ""] = C.match(/^(\s*\*)/u) || [], N = B + F.length;
                    return w.replaceTextRange([B, N], b);
                  }
                  const [, I = ""] = C.match(/^(\s*)/u) || [], _ = B + I.length;
                  let S;
                  for (const [F, N] of x.entries()) {
                    if (!/\S+/u.test(N))
                      continue;
                    const k = e.lines[g.loc.start.line - 1 + F], [, j = "", O = ""] = k.match(/^(\s*(?:\/?\*)?(\s*))/u) || [];
                    S = `${I.slice(j.length)}${O}`, /^\s*\//u.test(C) && S.length === 0 && (S += " ");
                    break;
                  }
                  return w.replaceTextRange([B, _], `${b}${S}`);
                }
              });
            }
          }
      },
      "separate-lines"(d) {
        const [g] = d;
        if (g.type !== "Block" || a(d))
          return;
        const y = u(d), x = e.getTokenAfter(g, {
          includeComments: !0
        });
        x && g.loc.end.line === x.loc.start.line || t.report({
          loc: {
            start: g.loc.start,
            end: {
              line: g.loc.start.line,
              column: g.loc.start.column + 2
            }
          },
          messageId: "expectedLines",
          fix(A) {
            return A.replaceText(g, h(g, y));
          }
        });
      },
      "bare-block"(d) {
        if (a(d))
          return;
        const [g] = d, y = u(d);
        g.type === "Line" && y.length > 1 && !y.some((x) => x.includes("*/")) && t.report({
          loc: {
            start: g.loc.start,
            end: d[d.length - 1].loc.end
          },
          messageId: "expectedBlock",
          fix(x) {
            return x.replaceTextRange([g.range[0], d[d.length - 1].range[1]], p(g, y));
          }
        }), n(d) && t.report({
          loc: {
            start: g.loc.start,
            end: {
              line: g.loc.start.line,
              column: g.loc.start.column + 2
            }
          },
          messageId: "expectedBareBlock",
          fix(x) {
            return x.replaceText(g, p(g, y));
          }
        });
      }
    };
    return {
      Program() {
        return e.getAllComments().filter((d) => d.type !== "Shebang").filter((d) => !E.COMMENTS_IGNORE_PATTERN.test(d.value)).filter((d) => {
          const g = e.getTokenBefore(d, {
            includeComments: !0
          });
          return !g || g.loc.end.line < d.loc.start.line;
        }).reduce((d, g, y, x) => {
          const A = e.getTokenBefore(g, {
            includeComments: !0
          });
          return g.type === "Line" && y && x[y - 1].type === "Line" && A && A.loc.end.line === g.loc.start.line - 1 && A === x[y - 1] ? d[d.length - 1].push(g) : d.push([g]), d;
        }, []).filter((d) => !(d.length === 1 && d[0].loc.start.line === d[0].loc.end.line)).forEach(m[r]);
      }
    };
  }
};
pp.meta;
pp.create;
var fp = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce newlines between operands of ternary expressions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/multiline-ternary"
    },
    schema: [{
      enum: ["always", "always-multiline", "never"]
    }],
    messages: {
      expectedTestCons: "Expected newline between test and consequent of ternary expression.",
      expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
      unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
      unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
    },
    fixable: "whitespace"
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0];
    return {
      ConditionalExpression(s) {
        const n = e.getTokenAfter(s.test, E.isNotClosingParenToken), a = e.getTokenAfter(s.consequent, E.isNotClosingParenToken), o = e.getFirstToken(s), l = e.getTokenBefore(n), i = e.getTokenAfter(n), u = e.getTokenBefore(a), c = e.getTokenAfter(a), f = E.isTokenOnSameLine(l, i), h = E.isTokenOnSameLine(u, c), p = !!e.getCommentsInside(s).length;
        if (r === "never")
          f || t.report({
            node: s.test,
            loc: {
              start: o.loc.start,
              end: l.loc.end
            },
            messageId: "unexpectedTestCons",
            fix: (m) => {
              if (p)
                return null;
              const d = [], g = E.isTokenOnSameLine(l, n), y = E.isTokenOnSameLine(n, i);
              return g || d.push(m.removeRange([l.range[1], n.range[0]])), y || d.push(m.removeRange([n.range[1], i.range[0]])), d;
            }
          }), h || t.report({
            node: s.consequent,
            loc: {
              start: i.loc.start,
              end: u.loc.end
            },
            messageId: "unexpectedConsAlt",
            fix: (m) => {
              if (p)
                return null;
              const d = [], g = E.isTokenOnSameLine(u, a), y = E.isTokenOnSameLine(a, c);
              return g || d.push(m.removeRange([u.range[1], a.range[0]])), y || d.push(m.removeRange([a.range[1], c.range[0]])), d;
            }
          });
        else {
          if (r === "always-multiline" && s.loc.start.line === s.loc.end.line)
            return;
          f && t.report({
            node: s.test,
            loc: {
              start: o.loc.start,
              end: l.loc.end
            },
            messageId: "expectedTestCons",
            fix: (m) => p ? null : m.replaceTextRange([l.range[1], n.range[0]], `
`)
          }), h && t.report({
            node: s.consequent,
            loc: {
              start: i.loc.start,
              end: u.loc.end
            },
            messageId: "expectedConsAlt",
            fix: (m) => p ? null : m.replaceTextRange([u.range[1], a.range[0]], `
`)
          });
        }
      }
    };
  }
};
fp.meta;
fp.create;
const Vo = ["Array", "Boolean", "Date", "Error", "Function", "Number", "Object", "RegExp", "String", "Symbol", "BigInt"];
function db(t, e, r) {
  if (Object.prototype.hasOwnProperty.call(t, e) && !Array.isArray(t[e]))
    throw new TypeError(`${e}, if provided, must be an Array`);
  return t[e] || r;
}
function gb(t, e) {
  return t[e] = !0, t;
}
function CN(t) {
  let e = db(t, "capIsNewExceptions", Vo);
  return e !== Vo && (e = e.concat(Vo)), e.reduce(gb, {});
}
var hp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require constructor names to begin with a capital letter",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/new-cap"
    },
    schema: [{
      type: "object",
      properties: {
        newIsCap: {
          type: "boolean",
          default: !0
        },
        capIsNew: {
          type: "boolean",
          default: !0
        },
        newIsCapExceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        newIsCapExceptionPattern: {
          type: "string"
        },
        capIsNewExceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        capIsNewExceptionPattern: {
          type: "string"
        },
        properties: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
      lower: "A constructor name should not start with a lowercase letter."
    }
  },
  create(t) {
    const e = Object.assign({}, t.options[0]);
    e.newIsCap = e.newIsCap !== !1, e.capIsNew = e.capIsNew !== !1;
    const r = e.properties === !1, s = db(e, "newIsCapExceptions", []).reduce(gb, {}), n = e.newIsCapExceptionPattern ? new RegExp(e.newIsCapExceptionPattern, "u") : null, a = CN(e), o = e.capIsNewExceptionPattern ? new RegExp(e.capIsNewExceptionPattern, "u") : null, l = {}, i = t.getSourceCode();
    function u(p) {
      return p.callee.type === "Identifier" ? p.callee.name : E.getStaticPropertyName(p.callee) || "";
    }
    function c(p) {
      const m = p.charAt(0), d = m.toLowerCase(), g = m.toUpperCase();
      return d === g ? "non-alpha" : m === d ? "lower" : "upper";
    }
    function f(p, m, d, g) {
      const y = i.getText(m.callee);
      if (p[d] || p[y] || g && g.test(y))
        return !0;
      const x = E.skipChainExpression(m.callee);
      return d === "UTC" && x.type === "MemberExpression" ? x.object.type === "Identifier" && x.object.name === "Date" : r && x.type === "MemberExpression";
    }
    function h(p, m) {
      let d = E.skipChainExpression(p.callee);
      d.type === "MemberExpression" && (d = d.property), t.report({
        node: p,
        loc: d.loc,
        messageId: m
      });
    }
    return e.newIsCap && (l.NewExpression = function(p) {
      const m = u(p);
      m && (c(m) !== "lower" || f(s, p, m, n) || h(p, "lower"));
    }), e.capIsNew && (l.CallExpression = function(p) {
      const m = u(p);
      m && (c(m) !== "upper" || f(a, p, m, o) || h(p, "upper"));
    }), l;
  }
};
hp.meta;
hp.create;
var mp = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce or disallow parentheses when invoking a constructor with no arguments",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/new-parens"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "never"]
        }],
        minItems: 0,
        maxItems: 1
      }]
    },
    messages: {
      missing: "Missing '()' invoking a constructor.",
      unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
    }
  },
  create(t) {
    const r = t.options[0] !== "never", s = t.getSourceCode();
    return {
      NewExpression(n) {
        if (n.arguments.length !== 0)
          return;
        const a = s.getLastToken(n), l = a && E.isClosingParenToken(a) && E.isOpeningParenToken(s.getTokenBefore(a)) && n.callee.range[1] < n.range[1];
        r ? l || t.report({
          node: n,
          messageId: "missing",
          fix: (i) => i.insertTextAfter(n, "()")
        }) : l && t.report({
          node: n,
          messageId: "unnecessary",
          fix: (i) => [i.remove(s.getTokenBefore(a)), i.remove(a), i.insertTextBefore(n, "("), i.insertTextAfter(n, ")")]
        });
      }
    };
  }
};
mp.meta;
mp.create;
var dp = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow an empty line after variable declarations",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/newline-after-var"
    },
    schema: [{
      enum: ["never", "always"]
    }],
    fixable: "whitespace",
    messages: {
      expected: "Expected blank line after variable declarations.",
      unexpected: "Unexpected blank line after variable declarations."
    },
    deprecated: !0,
    replacedBy: ["padding-line-between-statements"]
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] === "never" ? "never" : "always", s = e.getAllComments().reduce((f, h) => (f[h.loc.start.line] = h.loc.end.line, f), {});
    function n(f) {
      const h = e.getLastToken(f);
      if (h.type === "Punctuator" && h.value === ";") {
        const p = e.getTokenBefore(h);
        if (p.loc.end.line !== h.loc.start.line)
          return p;
      }
      return h;
    }
    function a(f) {
      return f === "var" || f === "let" || f === "const";
    }
    function o(f) {
      return f === "ForStatement" || f === "ForInStatement" || f === "ForOfStatement";
    }
    function l(f) {
      return f === "ExportNamedDeclaration" || f === "ExportSpecifier" || f === "ExportDefaultDeclaration" || f === "ExportAllDeclaration";
    }
    function i(f) {
      const h = e.getTokenAfter(f);
      return !h || h.type === "Punctuator" && h.value === "}";
    }
    function u(f) {
      const h = s[f];
      return s[h + 1] ? u(h + 1) : h;
    }
    function c(f, h) {
      return f.loc.start.line > u(h) + 1;
    }
    return {
      VariableDeclaration: function(f) {
        const h = n(f), p = h === e.getLastToken(f) ? e.getTokenAfter(f) : e.getLastToken(f), m = h.loc.end.line + 1;
        if (!p || o(f.parent.type) || l(f.parent.type) || p.type === "Keyword" && a(p.value) || i(f))
          return;
        const d = p.loc.start.line > m, g = typeof s[m] < "u";
        r === "never" && d && !g && t.report({
          node: f,
          messageId: "unexpected",
          data: {
            identifier: f.name
          },
          fix(y) {
            const x = e.getText().slice(h.range[1], p.range[0]).split(E.LINEBREAK_MATCHER);
            return y.replaceTextRange([h.range[1], p.range[0]], `${x.slice(0, -1).join("")}
${x[x.length - 1]}`);
          }
        }), r === "always" && (!d || g && !c(p, m)) && t.report({
          node: f,
          messageId: "expected",
          data: {
            identifier: f.name
          },
          fix(y) {
            return (d ? u(m) : h.loc.end.line) === p.loc.start.line ? y.insertTextBefore(p, `

`) : y.insertTextBeforeRange([p.range[0] - p.loc.start.column, p.range[1]], `
`);
          }
        });
      }
    };
  }
};
dp.meta;
dp.create;
var gp = {
  meta: {
    type: "layout",
    docs: {
      description: "require an empty line before `return` statements",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/newline-before-return"
    },
    fixable: "whitespace",
    schema: [],
    messages: {
      expected: "Expected newline before return statement."
    },
    deprecated: !0,
    replacedBy: ["padding-line-between-statements"]
  },
  create(t) {
    const e = t.getSourceCode();
    function r(i, u) {
      const c = e.getTokenBefore(i);
      return u.some((f) => c.value === f);
    }
    function s(i) {
      const u = i.parent.type;
      return i.parent.body ? Array.isArray(i.parent.body) ? i.parent.body[0] === i : i.parent.body === i : u === "IfStatement" ? r(i, ["else", ")"]) : u === "DoWhileStatement" ? r(i, ["do"]) : u === "SwitchCase" ? r(i, [":"]) : r(i, [")"]);
    }
    function n(i, u) {
      const c = e.getCommentsBefore(i);
      let f = 0;
      return c.length && c.forEach((h) => {
        f++, h.type === "Block" && (f += h.loc.end.line - h.loc.start.line), h.loc.start.line === u && f--, h.loc.end.line === i.loc.start.line && f--;
      }), f;
    }
    function a(i) {
      const u = e.getTokenBefore(i);
      let c;
      return u ? c = u.loc.end.line : c = 0, c;
    }
    function o(i) {
      const u = i.loc.start.line, c = a(i), f = n(i, c);
      return u - c - f > 1;
    }
    function l(i) {
      const u = e.getCommentsBefore(i), c = u[u.length - 1], f = e.getTokenBefore(i);
      return u.length === 0 || c.loc.end.line === f.loc.end.line && c.loc.end.line !== i.loc.start.line;
    }
    return {
      ReturnStatement(i) {
        !s(i) && !o(i) && t.report({
          node: i,
          messageId: "expected",
          fix(u) {
            if (l(i)) {
              const c = e.getTokenBefore(i), f = i.loc.start.line === c.loc.end.line ? `

` : `
`;
              return u.insertTextBefore(i, f);
            }
            return null;
          }
        });
      }
    };
  }
};
gp.meta;
gp.create;
var yp = {
  meta: {
    type: "layout",
    docs: {
      description: "require a newline after each call in a method chain",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/newline-per-chained-call"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        ignoreChainWithDepth: {
          type: "integer",
          minimum: 1,
          maximum: 10,
          default: 2
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expected: "Expected line break before `{{callee}}`."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.ignoreChainWithDepth || 2, s = t.getSourceCode();
    function n(o) {
      return o.computed ? o.optional ? "?.[" : "[" : o.optional ? "?." : ".";
    }
    function a(o) {
      const l = n(o), i = s.getText(o.property).split(E.LINEBREAK_MATCHER), u = o.computed && i.length === 1 ? "]" : "";
      return l + i[0] + u;
    }
    return {
      "CallExpression:exit"(o) {
        const l = E.skipChainExpression(o.callee);
        if (l.type !== "MemberExpression")
          return;
        let i = E.skipChainExpression(l.object), u = 1;
        for (; i && i.callee; )
          u += 1, i = E.skipChainExpression(E.skipChainExpression(i.callee).object);
        if (u > r && E.isTokenOnSameLine(l.object, l.property)) {
          const c = s.getTokenAfter(l.object, E.isNotClosingParenToken);
          t.report({
            node: l.property,
            loc: {
              start: c.loc.start,
              end: l.loc.end
            },
            messageId: "expected",
            data: {
              callee: a(l)
            },
            fix(f) {
              return f.insertTextBefore(c, `
`);
            }
          });
        }
      }
    };
  }
};
yp.meta;
yp.create;
const {
  getStaticPropertyName: SN,
  getVariableByName: AN,
  skipChainExpression: DN
} = E;
function Dy(t) {
  return /^(alert|confirm|prompt)$/u.test(t);
}
function wN(t, e) {
  const r = t.references.filter((s) => s.identifier.range[0] === e.range[0] && s.identifier.range[1] === e.range[1]);
  return r.length === 1 ? r[0] : null;
}
function yb(t, e) {
  const r = wN(t, e);
  return r && r.resolved && r.resolved.defs.length > 0;
}
function kN(t, e) {
  return t.type === "global" && e.type === "ThisExpression" ? !0 : e.type === "Identifier" && (e.name === "window" || e.name === "globalThis" && AN(t, "globalThis")) ? !yb(t, e) : !1;
}
var xp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `alert`, `confirm`, and `prompt`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-alert"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected {{name}}."
    }
  },
  create(t) {
    return {
      CallExpression(e) {
        const r = DN(e.callee), s = t.getScope();
        if (r.type === "Identifier") {
          const n = r.name;
          !yb(s, r) && Dy(r.name) && t.report({
            node: e,
            messageId: "unexpected",
            data: {
              name: n
            }
          });
        } else if (r.type === "MemberExpression" && kN(s, r.object)) {
          const n = SN(r);
          Dy(n) && t.report({
            node: e,
            messageId: "unexpected",
            data: {
              name: n
            }
          });
        }
      }
    };
  }
};
xp.meta;
xp.create;
var vp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `Array` constructors",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-array-constructor"
    },
    schema: [],
    messages: {
      preferLiteral: "The array literal notation [] is preferable."
    }
  },
  create(t) {
    function e(r) {
      r.arguments.length !== 1 && r.callee.type === "Identifier" && r.callee.name === "Array" && t.report({
        node: r,
        messageId: "preferLiteral"
      });
    }
    return {
      CallExpression: e,
      NewExpression: e
    };
  }
};
vp.meta;
vp.create;
var Ep = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow using an async function as a Promise executor",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-async-promise-executor"
    },
    fixable: null,
    schema: [],
    messages: {
      async: "Promise executor functions should not be async."
    }
  },
  create(t) {
    return {
      "NewExpression[callee.name='Promise'][arguments.0.async=true]"(e) {
        t.report({
          node: t.getSourceCode().getFirstToken(e.arguments[0], (r) => r.value === "async"),
          messageId: "async"
        });
      }
    };
  }
};
Ep.meta;
Ep.create;
function TN(t) {
  const e = t.type;
  return e === "FunctionDeclaration" || e === "FunctionExpression" || e === "ArrowFunctionExpression" || e === "ForOfStatement" && t.await === !0;
}
function FN(t, e) {
  switch (e.type) {
    case "ForStatement":
      return t === e.test || t === e.update || t === e.body;
    case "ForOfStatement":
    case "ForInStatement":
      return t === e.body;
    case "WhileStatement":
    case "DoWhileStatement":
      return t === e.test || t === e.body;
    default:
      return !1;
  }
}
var bp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `await` inside of loops",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-await-in-loop"
    },
    schema: [],
    messages: {
      unexpectedAwait: "Unexpected `await` inside a loop."
    }
  },
  create(t) {
    function e(r) {
      if (r.type === "ForOfStatement" && !r.await)
        return;
      let s = r, n = s.parent;
      for (; n && !TN(n); ) {
        if (FN(s, n)) {
          t.report({
            node: r,
            messageId: "unexpectedAwait"
          });
          return;
        }
        s = n, n = n.parent;
      }
    }
    return {
      AwaitExpression: e,
      ForOfStatement: e
    };
  }
};
bp.meta;
bp.create;
const wy = ["^", "|", "&", "<<", ">>", ">>>", "^=", "|=", "&=", "<<=", ">>=", ">>>=", "~"];
var Cp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow bitwise operators",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-bitwise"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            enum: wy
          },
          uniqueItems: !0
        },
        int32Hint: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "Unexpected use of '{{operator}}'."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allow || [], s = e.int32Hint === !0;
    function n(u) {
      t.report({
        node: u,
        messageId: "unexpected",
        data: {
          operator: u.operator
        }
      });
    }
    function a(u) {
      return wy.indexOf(u.operator) !== -1;
    }
    function o(u) {
      return r.indexOf(u.operator) !== -1;
    }
    function l(u) {
      return s && u.operator === "|" && u.right && u.right.type === "Literal" && u.right.value === 0;
    }
    function i(u) {
      a(u) && !o(u) && !l(u) && n(u);
    }
    return {
      AssignmentExpression: i,
      BinaryExpression: i,
      UnaryExpression: i
    };
  }
};
Cp.meta;
Cp.create;
var Sp = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "problem",
    docs: {
      description: "disallow use of the `Buffer()` constructor",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-buffer-constructor"
    },
    schema: [],
    messages: {
      deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
    }
  },
  create(t) {
    return {
      "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(e) {
        t.report({
          node: e,
          messageId: "deprecated",
          data: {
            expr: e.type === "CallExpression" ? "Buffer()" : "new Buffer()"
          }
        });
      }
    };
  }
};
Sp.meta;
Sp.create;
var Ap = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `arguments.caller` or `arguments.callee`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-caller"
    },
    schema: [],
    messages: {
      unexpected: "Avoid arguments.{{prop}}."
    }
  },
  create(t) {
    return {
      MemberExpression(e) {
        const r = e.object.name, s = e.property.name;
        r === "arguments" && !e.computed && s && s.match(/^calle[er]$/u) && t.report({
          node: e,
          messageId: "unexpected",
          data: {
            prop: s
          }
        });
      }
    };
  }
};
Ap.meta;
Ap.create;
var Dp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow lexical declarations in case clauses",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-case-declarations"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected lexical declaration in case block."
    }
  },
  create(t) {
    function e(r) {
      switch (r.type) {
        case "FunctionDeclaration":
        case "ClassDeclaration":
          return !0;
        case "VariableDeclaration":
          return r.kind !== "var";
        default:
          return !1;
      }
    }
    return {
      SwitchCase(r) {
        for (let s = 0; s < r.consequent.length; s++) {
          const n = r.consequent[s];
          e(n) && t.report({
            node: n,
            messageId: "unexpected"
          });
        }
      }
    };
  }
};
Dp.meta;
Dp.create;
var wp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-catch-shadow"
    },
    replacedBy: ["no-shadow"],
    deprecated: !0,
    schema: [],
    messages: {
      mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
    }
  },
  create(t) {
    function e(r, s) {
      return E.getVariableByName(r, s) !== null;
    }
    return {
      "CatchClause[param!=null]"(r) {
        let s = t.getScope();
        s.block === r && (s = s.upper), e(s, r.param.name) && t.report({
          node: r,
          messageId: "mutable",
          data: {
            name: r.param.name
          }
        });
      }
    };
  }
};
wp.meta;
wp.create;
var kp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning class members",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-class-assign"
    },
    schema: [],
    messages: {
      class: "'{{name}}' is a class."
    }
  },
  create(t) {
    function e(s) {
      E.getModifyingReferences(s.references).forEach((n) => {
        t.report({
          node: n.identifier,
          messageId: "class",
          data: {
            name: n.identifier.name
          }
        });
      });
    }
    function r(s) {
      t.getDeclaredVariables(s).forEach(e);
    }
    return {
      ClassDeclaration: r,
      ClassExpression: r
    };
  }
};
kp.meta;
kp.create;
var Tp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow comparing against -0",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-compare-neg-zero"
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Do not use the '{{operator}}' operator to compare against -0."
    }
  },
  create(t) {
    function e(s) {
      return s.type === "UnaryExpression" && s.operator === "-" && s.argument.type === "Literal" && s.argument.value === 0;
    }
    const r = /* @__PURE__ */ new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
    return {
      BinaryExpression(s) {
        r.has(s.operator) && (e(s.left) || e(s.right)) && t.report({
          node: s,
          messageId: "unexpected",
          data: {
            operator: s.operator
          }
        });
      }
    };
  }
};
Tp.meta;
Tp.create;
const PN = /* @__PURE__ */ new Set(["IfStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ConditionalExpression"]), IN = {
  DoWhileStatement: "a 'do...while' statement",
  ForStatement: "a 'for' statement",
  IfStatement: "an 'if' statement",
  WhileStatement: "a 'while' statement"
};
var Fp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignment operators in conditional expressions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-cond-assign"
    },
    schema: [{
      enum: ["except-parens", "always"]
    }],
    messages: {
      unexpected: "Unexpected assignment within {{type}}.",
      missing: "Expected a conditional expression and instead saw an assignment."
    }
  },
  create(t) {
    const e = t.options[0] || "except-parens", r = t.getSourceCode();
    function s(i) {
      return i.parent && PN.has(i.parent.type) && i === i.parent.test;
    }
    function n(i) {
      let u = i;
      do
        if (s(u))
          return u.parent;
      while ((u = u.parent) && !E.isFunction(u));
      return null;
    }
    function a(i) {
      const u = r.getTokenBefore(i, 1), c = r.getTokenAfter(i, 1);
      return E.isParenthesised(r, i) && u && E.isOpeningParenToken(u) && u.range[1] <= i.range[0] && E.isClosingParenToken(c) && c.range[0] >= i.range[1];
    }
    function o(i) {
      i.test && i.test.type === "AssignmentExpression" && (i.type === "ForStatement" ? !E.isParenthesised(r, i.test) : !a(i.test)) && t.report({
        node: i.test,
        messageId: "missing"
      });
    }
    function l(i) {
      const u = n(i);
      u && t.report({
        node: i,
        messageId: "unexpected",
        data: {
          type: IN[u.type] || u.type
        }
      });
    }
    return e === "always" ? {
      AssignmentExpression: l
    } : {
      DoWhileStatement: o,
      ForStatement: o,
      IfStatement: o,
      WhileStatement: o,
      ConditionalExpression: o
    };
  }
};
Fp.meta;
Fp.create;
function _N(t) {
  return t && t.type === "ConditionalExpression";
}
var Pp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow arrow functions where they could be confused with comparisons",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-confusing-arrow"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        allowParens: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      confusing: "Arrow function used ambiguously with a conditional expression."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allowParens || e.allowParens === void 0, s = t.getSourceCode();
    return {
      ArrowFunctionExpression: function(n) {
        const a = n.body;
        _N(a) && !(r && E.isParenthesised(s, a)) && t.report({
          node: n,
          messageId: "confusing",
          fix(o) {
            return r && o.replaceText(n.body, `(${s.getText(n.body)})`);
          }
        });
      }
    };
  }
};
Pp.meta;
Pp.create;
var Ip = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `console`",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-console"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            type: "string"
          },
          minItems: 1,
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "Unexpected console statement."
    }
  },
  create(t) {
    const r = (t.options[0] || {}).allow || [];
    function s(l) {
      const i = l.identifier;
      return i && i.name === "console";
    }
    function n(l) {
      const i = E.getStaticPropertyName(l);
      return i && r.indexOf(i) !== -1;
    }
    function a(l) {
      const i = l.identifier, u = i.parent;
      return u.type === "MemberExpression" && u.object === i && !n(u);
    }
    function o(l) {
      const i = l.identifier.parent;
      t.report({
        node: i,
        loc: i.loc,
        messageId: "unexpected"
      });
    }
    return {
      "Program:exit"() {
        const l = t.getScope(), i = E.getVariableByName(l, "console"), u = i && i.defs.length > 0, c = i ? i.references : l.through.filter(s);
        u || c.filter(a).forEach(o);
      }
    };
  }
};
Ip.meta;
Ip.create;
var _p = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning `const` variables",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-const-assign"
    },
    schema: [],
    messages: {
      const: "'{{name}}' is constant."
    }
  },
  create(t) {
    function e(r) {
      E.getModifyingReferences(r.references).forEach((s) => {
        t.report({
          node: s.identifier,
          messageId: "const",
          data: {
            name: s.identifier.name
          }
        });
      });
    }
    return {
      VariableDeclaration(r) {
        r.kind === "const" && t.getDeclaredVariables(r).forEach(e);
      }
    };
  }
};
_p.meta;
_p.create;
var Bp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow constant expressions in conditions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-constant-condition"
    },
    schema: [{
      type: "object",
      properties: {
        checkLoops: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "Unexpected constant condition."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.checkLoops !== !1, s = [];
    let n = /* @__PURE__ */ new Set();
    function a(m) {
      return m.value === null ? m.raw === "null" ? !1 : typeof m.regex == "object" ? !0 : null : !!m.value;
    }
    function o(m, d) {
      switch (m.type) {
        case "Literal":
          return d === "||" && a(m) === !0 || d === "&&" && a(m) === !1;
        case "UnaryExpression":
          return d === "&&" && m.operator === "void";
        case "LogicalExpression":
          return d === m.operator && (o(m.left, d) || o(m.right, d));
        case "AssignmentExpression":
          return ["||=", "&&="].includes(m.operator) && d === m.operator.slice(0, -1) && o(m.right, d);
      }
      return !1;
    }
    function l(m, d) {
      if (!m)
        return !0;
      switch (m.type) {
        case "Literal":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ObjectExpression":
          return !0;
        case "TemplateLiteral":
          return d && m.quasis.some((g) => g.value.cooked.length) || m.expressions.every((g) => l(g, d));
        case "ArrayExpression":
          return m.parent.type === "BinaryExpression" && m.parent.operator === "+" ? m.elements.every((g) => l(g, !1)) : !0;
        case "UnaryExpression":
          return m.operator === "void" || m.operator === "typeof" && d ? !0 : m.operator === "!" ? l(m.argument, !0) : l(m.argument, !1);
        case "BinaryExpression":
          return l(m.left, !1) && l(m.right, !1) && m.operator !== "in";
        case "LogicalExpression": {
          const g = l(m.left, d), y = l(m.right, d), x = g && o(m.left, m.operator), A = d && y && o(m.right, m.operator);
          return g && y || x || A;
        }
        case "AssignmentExpression":
          return m.operator === "=" ? l(m.right, d) : ["||=", "&&="].includes(m.operator) && d ? o(m.right, m.operator.slice(0, -1)) : !1;
        case "SequenceExpression":
          return l(m.expressions[m.expressions.length - 1], d);
      }
      return !1;
    }
    function i(m) {
      m.test && l(m.test, !0) && n.add(m);
    }
    function u(m) {
      n.has(m) && (n.delete(m), t.report({
        node: m.test,
        messageId: "unexpected"
      }));
    }
    function c(m) {
      m.test && l(m.test, !0) && t.report({
        node: m.test,
        messageId: "unexpected"
      });
    }
    function f() {
      s.push(n), n = /* @__PURE__ */ new Set();
    }
    function h() {
      n = s.pop();
    }
    function p(m) {
      r && i(m);
    }
    return {
      ConditionalExpression: c,
      IfStatement: c,
      WhileStatement: p,
      "WhileStatement:exit": u,
      DoWhileStatement: p,
      "DoWhileStatement:exit": u,
      ForStatement: p,
      "ForStatement > .test": (m) => p(m.parent),
      "ForStatement:exit": u,
      FunctionDeclaration: f,
      "FunctionDeclaration:exit": h,
      FunctionExpression: f,
      "FunctionExpression:exit": h,
      YieldExpression: () => n.clear()
    };
  }
};
Bp.meta;
Bp.create;
var Op = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow returning value from constructor",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-constructor-return"
    },
    schema: {},
    fixable: null,
    messages: {
      unexpected: "Unexpected return statement in constructor."
    }
  },
  create(t) {
    const e = [];
    return {
      onCodePathStart(r, s) {
        e.push(s);
      },
      onCodePathEnd() {
        e.pop();
      },
      ReturnStatement(r) {
        const s = e[e.length - 1];
        s.parent && s.parent.type === "MethodDefinition" && s.parent.kind === "constructor" && (r.parent.parent === s || r.argument) && t.report({
          node: r,
          messageId: "unexpected"
        });
      }
    };
  }
};
Op.meta;
Op.create;
var Lp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `continue` statements",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-continue"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected use of continue statement."
    }
  },
  create(t) {
    return {
      ContinueStatement(e) {
        t.report({
          node: e,
          messageId: "unexpected"
        });
      }
    };
  }
};
Lp.meta;
Lp.create;
const BN = pn.default.RegExpValidator, ON = new class {
  constructor() {
    this._source = "", this._controlChars = [], this._validator = new BN(this);
  }
  onPatternEnter() {
    this._controlChars = [];
  }
  onCharacter(t, e, r) {
    r >= 0 && r <= 31 && (this._source.codePointAt(t) === r || this._source.slice(t, e).startsWith("\\x") || this._source.slice(t, e).startsWith("\\u")) && this._controlChars.push(`\\x${`0${r.toString(16)}`.slice(-2)}`);
  }
  collectControlChars(t) {
    try {
      this._source = t, this._validator.validatePattern(t);
    } catch {
    }
    return this._controlChars;
  }
}();
var Rp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control characters in regular expressions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-control-regex"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
    }
  },
  create(t) {
    function e(r) {
      return r.regex ? r.regex.pattern : typeof r.value == "string" && (r.parent.type === "NewExpression" || r.parent.type === "CallExpression") && r.parent.callee.type === "Identifier" && r.parent.callee.name === "RegExp" && r.parent.arguments[0] === r ? r.value : null;
    }
    return {
      Literal(r) {
        const s = e(r);
        if (s) {
          const n = ON.collectControlChars(s);
          n.length > 0 && t.report({
            node: r,
            messageId: "unexpected",
            data: {
              controlChars: n.join(", ")
            }
          });
        }
      }
    };
  }
};
Rp.meta;
Rp.create;
var Np = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of `debugger`",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-debugger"
    },
    fixable: null,
    schema: [],
    messages: {
      unexpected: "Unexpected 'debugger' statement."
    }
  },
  create(t) {
    return {
      DebuggerStatement(e) {
        t.report({
          node: e,
          messageId: "unexpected"
        });
      }
    };
  }
};
Np.meta;
Np.create;
var jp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow deleting variables",
      category: "Variables",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-delete-var"
    },
    schema: [],
    messages: {
      unexpected: "Variables should not be deleted."
    }
  },
  create(t) {
    return {
      UnaryExpression(e) {
        e.operator === "delete" && e.argument.type === "Identifier" && t.report({
          node: e,
          messageId: "unexpected"
        });
      }
    };
  }
};
jp.meta;
jp.create;
var Mp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow division operators explicitly at the beginning of regular expressions",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-div-regex"
    },
    fixable: "code",
    schema: [],
    messages: {
      unexpected: "A regular expression literal can be confused with '/='."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      Literal(r) {
        const s = e.getFirstToken(r);
        s.type === "RegularExpression" && s.value[1] === "=" && t.report({
          node: r,
          messageId: "unexpected",
          fix(n) {
            return n.replaceTextRange([s.range[0] + 1, s.range[0] + 2], "[=]");
          }
        });
      }
    };
  }
};
Mp.meta;
Mp.create;
var $p = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate arguments in `function` definitions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-dupe-args"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate param '{{name}}'."
    }
  },
  create(t) {
    function e(s) {
      return s.type === "Parameter";
    }
    function r(s) {
      const n = t.getDeclaredVariables(s);
      for (let a = 0; a < n.length; ++a) {
        const o = n[a];
        o.defs.filter(e).length >= 2 && t.report({
          node: s,
          messageId: "unexpected",
          data: {
            name: o.name
          }
        });
      }
    }
    return {
      FunctionDeclaration: r,
      FunctionExpression: r
    };
  }
};
$p.meta;
$p.create;
var Vp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate class members",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-dupe-class-members"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate name '{{name}}'."
    }
  },
  create(t) {
    let e = [];
    function r(s, n) {
      const a = e[e.length - 1], o = `$${s}`;
      return a[o] || (a[o] = {
        nonStatic: {
          init: !1,
          get: !1,
          set: !1
        },
        static: {
          init: !1,
          get: !1,
          set: !1
        }
      }), a[o][n ? "static" : "nonStatic"];
    }
    return {
      Program() {
        e = [];
      },
      ClassBody() {
        e.push(/* @__PURE__ */ Object.create(null));
      },
      "ClassBody:exit"() {
        e.pop();
      },
      MethodDefinition(s) {
        const n = E.getStaticPropertyName(s);
        if (n === null || s.kind === "constructor")
          return;
        const a = r(n, s.static);
        let o = !1;
        s.kind === "get" ? (o = a.init || a.get, a.get = !0) : s.kind === "set" ? (o = a.init || a.set, a.set = !0) : (o = a.init || a.get || a.set, a.init = !0), o && t.report({
          node: s,
          messageId: "unexpected",
          data: {
            name: n
          }
        });
      }
    };
  }
};
Vp.meta;
Vp.create;
function LN(t, e, r) {
  return e.every((s) => r.some((n) => t(s, n)));
}
function ai(t, e) {
  return e.type === "LogicalExpression" && e.operator === t ? [...ai(t, e.left), ...ai(t, e.right)] : [e];
}
const ky = ai.bind(null, "||"), Uo = ai.bind(null, "&&");
var Up = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate conditions in if-else-if chains",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-dupe-else-if"
    },
    schema: [],
    messages: {
      unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(n, a) {
      return n.type !== a.type ? !1 : n.type === "LogicalExpression" && (n.operator === "||" || n.operator === "&&") && n.operator === a.operator ? r(n.left, a.left) && r(n.right, a.right) || r(n.left, a.right) && r(n.right, a.left) : E.equalTokens(n, a, e);
    }
    const s = LN.bind(null, r);
    return {
      IfStatement(n) {
        const a = n.test, o = a.type === "LogicalExpression" && a.operator === "&&" ? [a, ...Uo(a)] : [a];
        let l = n, i = o.map((u) => ky(u).map(Uo));
        for (; l.parent && l.parent.type === "IfStatement" && l.parent.alternate === l; ) {
          l = l.parent;
          const u = ky(l.test).map(Uo);
          if (i = i.map((c) => c.filter((f) => !u.some((h) => s(h, f)))), i.some((c) => c.length === 0)) {
            t.report({
              node: a,
              messageId: "unexpected"
            });
            break;
          }
        }
      }
    };
  }
};
Up.meta;
Up.create;
const Ty = /^(?:init|get)$/u, Fy = /^(?:init|set)$/u;
class RN {
  constructor(e, r) {
    this.upper = e, this.node = r, this.properties = /* @__PURE__ */ new Map();
  }
  getPropertyInfo(e) {
    const r = E.getStaticPropertyName(e);
    return this.properties.has(r) || this.properties.set(r, {
      get: !1,
      set: !1
    }), this.properties.get(r);
  }
  isPropertyDefined(e) {
    const r = this.getPropertyInfo(e);
    return Ty.test(e.kind) && r.get || Fy.test(e.kind) && r.set;
  }
  defineProperty(e) {
    const r = this.getPropertyInfo(e);
    Ty.test(e.kind) && (r.get = !0), Fy.test(e.kind) && (r.set = !0);
  }
}
var qp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate keys in object literals",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-dupe-keys"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate key '{{name}}'."
    }
  },
  create(t) {
    let e = null;
    return {
      ObjectExpression(r) {
        e = new RN(e, r);
      },
      "ObjectExpression:exit"() {
        e = e.upper;
      },
      Property(r) {
        const s = E.getStaticPropertyName(r);
        r.parent.type === "ObjectExpression" && s !== null && (e.isPropertyDefined(r) && t.report({
          node: e.node,
          loc: r.key.loc,
          messageId: "unexpected",
          data: {
            name: s
          }
        }), e.defineProperty(r));
      }
    };
  }
};
qp.meta;
qp.create;
var Wp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate case labels",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-duplicate-case"
    },
    schema: [],
    messages: {
      unexpected: "Duplicate case label."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s, n) {
      return s.type !== n.type ? !1 : E.equalTokens(s, n, e);
    }
    return {
      SwitchStatement(s) {
        const n = [];
        for (const a of s.cases)
          if (a.test) {
            const o = a.test;
            n.some((l) => r(l, o)) ? t.report({
              node: a,
              messageId: "unexpected"
            }) : n.push(o);
          }
      }
    };
  }
};
Wp.meta;
Wp.create;
const NN = ["ImportSpecifier", "ExportSpecifier"], jN = ["ImportNamespaceSpecifier", "ExportNamespaceSpecifier"];
function Jn(t, e) {
  return (e === "named" ? NN : jN).includes(t);
}
function Py(t) {
  if (t.specifiers && t.specifiers.length > 0) {
    const e = t.specifiers, r = e.findIndex(({
      type: n
    }) => Jn(n, "named") || Jn(n, "namespace")), s = r > -1 ? r : 0;
    return e[s].type;
  }
  return t.type === "ExportAllDeclaration" ? t.exported ? "ExportNamespaceSpecifier" : "ExportAll" : "SideEffectImport";
}
function MN(t, e) {
  const r = Py(t), s = Py(e);
  return !(r === "ExportAll" && s !== "ExportAll" && s !== "SideEffectImport" || r !== "ExportAll" && r !== "SideEffectImport" && s === "ExportAll" || Jn(r, "namespace") && Jn(s, "named") || Jn(s, "namespace") && Jn(r, "named"));
}
function ba(t, e) {
  let r = 0;
  for (; r < e.length; ) {
    if (MN(t, e[r]))
      return !0;
    r++;
  }
  return !1;
}
function Iy(t, e) {
  return t.filter(({
    declarationType: r
  }) => r === e).map(({
    node: r
  }) => r);
}
function xb(t) {
  return t && t.source && t.source.value ? t.source.value.trim() : "";
}
function $N(t, e, r, s, n) {
  const a = xb(e);
  if (r.has(a)) {
    const o = r.get(a), l = [], i = Iy(o, "import");
    let u;
    n && (u = Iy(o, "export")), s === "import" ? (ba(e, i) && l.push("import"), n && ba(e, u) && l.push("importAs")) : s === "export" && (ba(e, u) && l.push("export"), ba(e, i) && l.push("exportAs")), l.forEach((c) => t.report({
      node: e,
      messageId: c,
      data: {
        module: a
      }
    }));
  }
}
function qo(t, e, r, s) {
  return function(n) {
    const a = xb(n);
    if (a) {
      $N(t, n, e, r, s);
      const o = {
        node: n,
        declarationType: r
      };
      let l = [o];
      e.has(a) && (l = [...e.get(a), o]), e.set(a, l);
    }
  };
}
var zp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow duplicate module imports",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-duplicate-imports"
    },
    schema: [{
      type: "object",
      properties: {
        includeExports: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      import: "'{{module}}' import is duplicated.",
      importAs: "'{{module}}' import is duplicated as export.",
      export: "'{{module}}' export is duplicated.",
      exportAs: "'{{module}}' export is duplicated as import."
    }
  },
  create(t) {
    const e = (t.options[0] || {}).includeExports, r = /* @__PURE__ */ new Map(), s = {
      ImportDeclaration: qo(t, r, "import", e)
    };
    return e && (s.ExportNamedDeclaration = qo(t, r, "export", e), s.ExportAllDeclaration = qo(t, r, "export", e)), s;
  }
};
zp.meta;
zp.create;
class VN {
  constructor(e, r) {
    this.fixer = e, this.sourceCode = r, this.retainedRange = null;
  }
  retainRange(e) {
    return this.retainedRange = e, this;
  }
  retainEnclosingFunction(e) {
    const r = E.getUpperFunction(e);
    return this.retainRange(r ? r.range : this.sourceCode.ast.range);
  }
  retainSurroundingTokens(e) {
    const r = this.sourceCode.getTokenBefore(e) || e, s = this.sourceCode.getTokenAfter(e) || e;
    return this.retainRange([r.range[0], s.range[1]]);
  }
  replaceTextRange(e, r) {
    let s;
    return this.retainedRange ? s = [Math.min(this.retainedRange[0], e[0]), Math.max(this.retainedRange[1], e[1])] : s = e, this.fixer.replaceTextRange(s, this.sourceCode.text.slice(s[0], e[0]) + r + this.sourceCode.text.slice(e[1], s[1]));
  }
  remove(e) {
    return this.replaceTextRange(e.range, "");
  }
}
var Qs = VN, Gp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `else` blocks after `return` statements in `if` statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-else-return"
    },
    schema: [{
      type: "object",
      properties: {
        allowElseIf: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      unexpected: "Unnecessary 'else' after 'return'."
    }
  },
  create(t) {
    function e(f, h) {
      if (f.length === 0)
        return !0;
      const p = h.variableScope;
      if (h.variables.filter(({
        defs: g
      }) => g.length > 0).some(({
        name: g
      }) => f.includes(g)) || h !== p && h.upper.type === "catch" && h.upper.variables.some(({
        name: g
      }) => f.includes(g)) || h.variables.filter(({
        defs: g,
        references: y
      }) => g.length === 0 && y.length > 0).some(({
        name: g
      }) => f.includes(g)) || h.through.some((g) => f.includes(g.identifier.name)))
        return !1;
      if (h !== p) {
        const g = h.block.range;
        if (p.variables.filter(({
          name: x
        }) => f.includes(x)).some((x) => x.defs.some(({
          node: {
            range: A
          }
        }) => g[0] <= A[0] && A[1] <= g[1])))
          return !1;
      }
      return !0;
    }
    function r(f, h) {
      if (f.type === "FunctionDeclaration")
        return !1;
      if (f.type !== "BlockStatement")
        return !0;
      const p = h.childScopes.find(({
        block: d
      }) => d === f);
      if (!p)
        return !0;
      const m = p.variables.map(({
        name: d
      }) => d);
      return e(m, h);
    }
    function s(f) {
      const h = t.getScope();
      t.report({
        node: f,
        messageId: "unexpected",
        fix: (p) => {
          if (!r(f, h))
            return null;
          const m = t.getSourceCode(), d = m.getFirstToken(f), g = m.getTokenBefore(d), y = m.getText(f), x = m.getTokenBefore(g);
          let A, b;
          d.type === "Punctuator" && d.value === "{" ? b = m.getTokenAfter(d) : b = d;
          const v = f.parent.consequent.type !== "BlockStatement" && x.value !== ";", C = /^[([/+`-]/u.test(b.value);
          if (v && C)
            return null;
          const T = m.getLastToken(f), w = m.getTokenBefore(T);
          if (w.value !== ";") {
            const B = m.getTokenAfter(T), I = B && /^[([/+`-]/u.test(B.value), _ = B && B.loc.start.line === w.loc.start.line;
            if (I || _ && B.value !== "}")
              return null;
          }
          return d.type === "Punctuator" && d.value === "{" ? A = y.slice(1, -1) : A = y, new Qs(p, m).retainEnclosingFunction(f).replaceTextRange([g.range[0], f.range[1]], A);
        }
      });
    }
    function n(f) {
      return f.type === "ReturnStatement";
    }
    function a(f) {
      if (f.type === "BlockStatement") {
        const h = f.body, p = h[h.length - 1];
        return p && n(p);
      }
      return n(f);
    }
    function o(f) {
      return f.alternate && f.consequent;
    }
    function l(f) {
      return f.type === "IfStatement" && o(f) && a(f.alternate) && a(f.consequent);
    }
    function i(f) {
      return n(f) || l(f);
    }
    function u(f) {
      return f.type === "BlockStatement" ? f.body.some(i) : i(f);
    }
    return {
      "IfStatement:exit": !(t.options[0] && t.options[0].allowElseIf === !1) ? function(f) {
        const h = f.parent;
        if (!E.STATEMENT_LIST_PARENTS.has(h.type))
          return;
        const p = [];
        let m;
        for (let d = f; d.type === "IfStatement"; d = d.alternate) {
          if (!d.alternate)
            return;
          p.push(d.consequent), m = d.alternate;
        }
        p.every(u) && s(m);
      } : function(f) {
        const h = f.parent;
        if (!E.STATEMENT_LIST_PARENTS.has(h.type))
          return;
        const p = f.alternate;
        p && u(f.consequent) && s(p);
      }
    };
  }
};
Gp.meta;
Gp.create;
const UN = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuys]*$/u;
var Hp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow empty character classes in regular expressions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-empty-character-class"
    },
    schema: [],
    messages: {
      unexpected: "Empty class."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      Literal(r) {
        const s = e.getFirstToken(r);
        s.type === "RegularExpression" && !UN.test(s.value) && t.report({
          node: r,
          messageId: "unexpected"
        });
      }
    };
  }
};
Hp.meta;
Hp.create;
const qN = Object.freeze(["functions", "arrowFunctions", "generatorFunctions", "methods", "generatorMethods", "getters", "setters", "constructors", "asyncFunctions", "asyncMethods"]);
function WN(t) {
  const e = t.parent;
  let r = "";
  if (t.type === "ArrowFunctionExpression")
    return "arrowFunctions";
  if (e.type === "Property") {
    if (e.kind === "get")
      return "getters";
    if (e.kind === "set")
      return "setters";
    r = e.method ? "methods" : "functions";
  } else if (e.type === "MethodDefinition") {
    if (e.kind === "get")
      return "getters";
    if (e.kind === "set")
      return "setters";
    if (e.kind === "constructor")
      return "constructors";
    r = "methods";
  } else
    r = "functions";
  let s = "";
  if (t.generator)
    s = "generator";
  else if (t.async)
    s = "async";
  else
    return r;
  return s + r[0].toUpperCase() + r.slice(1);
}
var Kp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow empty functions",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-empty-function"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            enum: qN
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "Unexpected empty {{name}}."
    }
  },
  create(t) {
    const r = (t.options[0] || {}).allow || [], s = t.getSourceCode();
    function n(a) {
      const o = WN(a), l = E.getFunctionNameWithKind(a), i = s.getTokens(a.body, {
        includeComments: !0,
        filter: E.isCommentToken
      });
      r.indexOf(o) === -1 && a.body.type === "BlockStatement" && a.body.body.length === 0 && i.length === 0 && t.report({
        node: a,
        loc: a.body.loc,
        messageId: "unexpected",
        data: {
          name: l
        }
      });
    }
    return {
      ArrowFunctionExpression: n,
      FunctionDeclaration: n,
      FunctionExpression: n
    };
  }
};
Kp.meta;
Kp.create;
var Jp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow empty destructuring patterns",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-empty-pattern"
    },
    schema: [],
    messages: {
      unexpected: "Unexpected empty {{type}} pattern."
    }
  },
  create(t) {
    return {
      ObjectPattern(e) {
        e.properties.length === 0 && t.report({
          node: e,
          messageId: "unexpected",
          data: {
            type: "object"
          }
        });
      },
      ArrayPattern(e) {
        e.elements.length === 0 && t.report({
          node: e,
          messageId: "unexpected",
          data: {
            type: "array"
          }
        });
      }
    };
  }
};
Jp.meta;
Jp.create;
var Xp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow empty block statements",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-empty"
    },
    schema: [{
      type: "object",
      properties: {
        allowEmptyCatch: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "Empty {{type}} statement."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allowEmptyCatch || !1, s = t.getSourceCode();
    return {
      BlockStatement(n) {
        n.body.length === 0 && (E.isFunction(n.parent) || r && n.parent.type === "CatchClause" || s.getCommentsInside(n).length > 0 || t.report({
          node: n,
          messageId: "unexpected",
          data: {
            type: "block"
          }
        }));
      },
      SwitchStatement(n) {
        (typeof n.cases > "u" || n.cases.length === 0) && t.report({
          node: n,
          messageId: "unexpected",
          data: {
            type: "switch"
          }
        });
      }
    };
  }
};
Xp.meta;
Xp.create;
var Qp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `null` comparisons without type-checking operators",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-eq-null"
    },
    schema: [],
    messages: {
      unexpected: "Use '===' to compare with null."
    }
  },
  create(t) {
    return {
      BinaryExpression(e) {
        const r = e.operator === "==" || e.operator === "!=";
        (e.right.type === "Literal" && e.right.raw === "null" && r || e.left.type === "Literal" && e.left.raw === "null" && r) && t.report({
          node: e,
          messageId: "unexpected"
        });
      }
    };
  }
};
Qp.meta;
Qp.create;
const _y = Object.freeze(["global", "window", "globalThis"]);
function Wo(t, e) {
  return E.isSpecificMemberAccess(t, null, e);
}
var Yp = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `eval()`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-eval"
    },
    schema: [{
      type: "object",
      properties: {
        allowIndirect: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "eval can be harmful."
    }
  },
  create(t) {
    const e = !!(t.options[0] && t.options[0].allowIndirect), r = t.getSourceCode();
    let s = null;
    function n(u) {
      const c = t.getScope().isStrict;
      s = {
        upper: s,
        node: u,
        strict: c,
        defaultThis: !1,
        initialized: c
      };
    }
    function a() {
      s = s.upper;
    }
    function o(u) {
      const c = u.parent, f = u.type === "MemberExpression" ? u.property : u, h = c.type === "CallExpression" && c.callee === u ? c : u;
      t.report({
        node: h,
        loc: f.loc,
        messageId: "unexpected"
      });
    }
    function l(u) {
      for (let c = 0; c < _y.length; ++c) {
        const f = _y[c], h = E.getVariableByName(u, f);
        if (!h)
          continue;
        const p = h.references;
        for (let m = 0; m < p.length; ++m) {
          let g = p[m].identifier.parent;
          for (; Wo(g, f); )
            g = g.parent;
          Wo(g, "eval") && o(g);
        }
      }
    }
    function i(u) {
      const c = E.getVariableByName(u, "eval");
      if (!c)
        return;
      const f = c.references;
      for (let h = 0; h < f.length; ++h) {
        const m = f[h].identifier;
        m.name === "eval" && !E.isCallee(m) && o(m);
      }
    }
    return e ? {
      "CallExpression:exit"(u) {
        const c = u.callee;
        !u.optional && E.isSpecificId(c, "eval") && o(c);
      }
    } : {
      "CallExpression:exit"(u) {
        const c = u.callee;
        E.isSpecificId(c, "eval") && o(c);
      },
      Program(u) {
        const c = t.getScope(), f = t.parserOptions.ecmaFeatures || {}, h = c.isStrict || u.sourceType === "module" || f.globalReturn && c.childScopes[0].isStrict;
        s = {
          upper: null,
          node: u,
          strict: h,
          defaultThis: !0,
          initialized: !0
        };
      },
      "Program:exit"() {
        const u = t.getScope();
        a(), i(u), l(u);
      },
      FunctionDeclaration: n,
      "FunctionDeclaration:exit": a,
      FunctionExpression: n,
      "FunctionExpression:exit": a,
      ArrowFunctionExpression: n,
      "ArrowFunctionExpression:exit": a,
      ThisExpression(u) {
        Wo(u.parent, "eval") && (s.initialized || (s.initialized = !0, s.defaultThis = E.isDefaultThisBinding(s.node, r)), !s.strict && s.defaultThis && o(u.parent));
      }
    };
  }
};
Yp.meta;
Yp.create;
var Zp = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning exceptions in `catch` clauses",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-ex-assign"
    },
    schema: [],
    messages: {
      unexpected: "Do not assign to the exception parameter."
    }
  },
  create(t) {
    function e(r) {
      E.getModifyingReferences(r.references).forEach((s) => {
        t.report({
          node: s.identifier,
          messageId: "unexpected"
        });
      });
    }
    return {
      CatchClause(r) {
        t.getDeclaredVariables(r).forEach(e);
      }
    };
  }
};
Zp.meta;
Zp.create;
var ef = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow extending native types",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-extend-native"
    },
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpected: "{{builtin}} prototype is read only, properties should not be added."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = new Set(e.exceptions || []), s = new Set(Object.keys(nR.default.builtin).filter((u) => u[0].toUpperCase() === u[0]).filter((u) => !r.has(u)));
    function n(u, c) {
      t.report({
        node: u,
        messageId: "unexpected",
        data: {
          builtin: c
        }
      });
    }
    function a(u) {
      return !!(u && u.parent && u.parent.type === "MemberExpression" && u.parent.object === u && E.getStaticPropertyName(u.parent) === "prototype");
    }
    function o(u) {
      return u.parent.type === "MemberExpression" && u.parent.object === u && u.parent.parent.type === "AssignmentExpression" && u.parent.parent.left === u.parent;
    }
    function l(u) {
      return u.parent.type === "CallExpression" && u.parent.arguments[0] === u && E.isSpecificMemberAccess(u.parent.callee, "Object", /^definePropert(?:y|ies)$/u);
    }
    function i(u) {
      if (!a(u))
        return;
      const c = u.parent.parent.type === "ChainExpression" ? u.parent.parent : u.parent;
      o(c) ? n(c.parent.parent, u.name) : l(c) && n(c.parent, u.name);
    }
    return {
      "Program:exit"() {
        const u = t.getScope();
        s.forEach((c) => {
          const f = u.set.get(c);
          f && f.references && f.references.map((h) => h.identifier).forEach(i);
        });
      }
    };
  }
};
ef.meta;
ef.create;
const zN = /* @__PURE__ */ new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]);
var tf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary calls to `.bind()`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-extra-bind"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "The function binding is unnecessary."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r = null;
    function s(u) {
      return zN.has(u.type);
    }
    function n(u) {
      const c = u.parent, f = c.parent.type === "ChainExpression" ? c.parent.parent : c.parent;
      t.report({
        node: f,
        messageId: "unexpected",
        loc: c.property.loc,
        fix(h) {
          if (!s(f.arguments[0]))
            return null;
          const p = [[e.getTokenAfter(c.object, E.isNotClosingParenToken), e.getLastToken(c)], [e.getTokenAfter(c, E.isNotClosingParenToken), e.getLastToken(f)]], m = p[0][0], d = p[1][1];
          return e.commentsExistBetween(m, d) ? null : p.map(([g, y]) => h.removeRange([g.range[0], y.range[1]]));
        }
      });
    }
    function a(u) {
      if (!E.isSpecificMemberAccess(u.parent, null, "bind"))
        return !1;
      const c = u.parent.parent.type === "ChainExpression" ? u.parent.parent : u.parent;
      return c.parent.type === "CallExpression" && c.parent.callee === c && c.parent.arguments.length === 1 && c.parent.arguments[0].type !== "SpreadElement";
    }
    function o(u) {
      r = {
        isBound: a(u),
        thisFound: !1,
        upper: r
      };
    }
    function l(u) {
      r.isBound && !r.thisFound && n(u), r = r.upper;
    }
    function i() {
      r && (r.thisFound = !0);
    }
    return {
      "ArrowFunctionExpression:exit": function(u) {
        a(u) && n(u);
      },
      FunctionDeclaration: o,
      "FunctionDeclaration:exit": l,
      FunctionExpression: o,
      "FunctionExpression:exit": l,
      ThisExpression: i
    };
  }
};
tf.meta;
tf.create;
const Kr = E.getPrecedence;
var rf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary boolean casts",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-extra-boolean-cast"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForLogicalOperands: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      unexpectedCall: "Redundant Boolean call.",
      unexpectedNegation: "Redundant double negation."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = ["IfStatement", "DoWhileStatement", "WhileStatement", "ConditionalExpression", "ForStatement"];
    function s(c) {
      return (c.type === "CallExpression" || c.type === "NewExpression") && c.callee.type === "Identifier" && c.callee.name === "Boolean";
    }
    function n(c) {
      return c.type === "LogicalExpression" && (c.operator === "||" || c.operator === "&&") && t.options.length && t.options[0].enforceForLogicalOperands === !0;
    }
    function a(c) {
      return s(c.parent) && c === c.parent.arguments[0] || r.indexOf(c.parent.type) !== -1 && c === c.parent.test || c.parent.type === "UnaryExpression" && c.parent.operator === "!";
    }
    function o(c) {
      return c.parent.type === "ChainExpression" ? o(c.parent) : a(c) || n(c.parent) && o(c.parent);
    }
    function l(c) {
      return !!e.getCommentsInside(c).length;
    }
    function i(c) {
      return Vt.default.isParenthesized(1, c, e);
    }
    function u(c, f) {
      if (c.parent.type === "ChainExpression")
        return u(c.parent, f);
      if (i(c))
        return !1;
      const h = c.parent;
      switch (h.type) {
        case "CallExpression":
        case "NewExpression":
          return f.type === "SequenceExpression";
        case "IfStatement":
        case "DoWhileStatement":
        case "WhileStatement":
        case "ForStatement":
          return !1;
        case "ConditionalExpression":
          return Kr(f) <= Kr(h);
        case "UnaryExpression":
          return Kr(f) < Kr(h);
        case "LogicalExpression":
          return E.isMixedLogicalAndCoalesceExpressions(f, h) ? !0 : c === h.left ? Kr(f) < Kr(h) : Kr(f) <= Kr(h);
        default:
          throw new Error(`Unexpected parent type: ${h.type}`);
      }
    }
    return {
      UnaryExpression(c) {
        const f = c.parent;
        c.operator !== "!" || f.type !== "UnaryExpression" || f.operator !== "!" || o(f) && t.report({
          node: f,
          messageId: "unexpectedNegation",
          fix(h) {
            if (l(f))
              return null;
            if (u(f, c.argument))
              return h.replaceText(f, `(${e.getText(c.argument)})`);
            let p = "";
            const m = e.getTokenBefore(f), d = e.getFirstToken(c.argument);
            return m && m.range[1] === f.range[0] && !E.canTokensBeAdjacent(m, d) && (p = " "), h.replaceText(f, p + e.getText(c.argument));
          }
        });
      },
      CallExpression(c) {
        c.callee.type !== "Identifier" || c.callee.name !== "Boolean" || o(c) && t.report({
          node: c,
          messageId: "unexpectedCall",
          fix(f) {
            const h = c.parent;
            if (c.arguments.length === 0) {
              if (h.type === "UnaryExpression" && h.operator === "!") {
                if (l(h))
                  return null;
                let p = "";
                const m = e.getTokenBefore(h);
                return m && m.range[1] === h.range[0] && !E.canTokensBeAdjacent(m, "true") && (p = " "), f.replaceText(h, p + "true");
              }
              return l(c) ? null : f.replaceText(c, "false");
            }
            if (c.arguments.length === 1) {
              const p = c.arguments[0];
              return p.type === "SpreadElement" || l(c) ? null : u(c, p) ? f.replaceText(c, `(${e.getText(p)})`) : f.replaceText(c, e.getText(p));
            }
            return null;
          }
        });
      }
    };
  }
};
rf.meta;
rf.create;
var nf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary labels",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-extra-label"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpected: "This label '{{name}}' is unnecessary."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r = null;
    function s(i) {
      r = {
        label: i.parent.type === "LabeledStatement" ? i.parent.label : null,
        breakable: !0,
        upper: r
      };
    }
    function n() {
      r = r.upper;
    }
    function a(i) {
      E.isBreakableStatement(i.body) || (r = {
        label: i.label,
        breakable: !1,
        upper: r
      });
    }
    function o(i) {
      E.isBreakableStatement(i.body) || (r = r.upper);
    }
    function l(i) {
      if (!i.label)
        return;
      const u = i.label;
      for (let c = r; c !== null; c = c.upper)
        if (c.breakable || c.label && c.label.name === u.name) {
          c.breakable && c.label && c.label.name === u.name && t.report({
            node: u,
            messageId: "unexpected",
            data: u,
            fix(f) {
              const h = e.getFirstToken(i);
              return e.commentsExistBetween(h, u) ? null : f.removeRange([h.range[1], u.range[1]]);
            }
          });
          return;
        }
    }
    return {
      WhileStatement: s,
      "WhileStatement:exit": n,
      DoWhileStatement: s,
      "DoWhileStatement:exit": n,
      ForStatement: s,
      "ForStatement:exit": n,
      ForInStatement: s,
      "ForInStatement:exit": n,
      ForOfStatement: s,
      "ForOfStatement:exit": n,
      SwitchStatement: s,
      "SwitchStatement:exit": n,
      LabeledStatement: a,
      "LabeledStatement:exit": o,
      BreakStatement: l,
      ContinueStatement: l
    };
  }
};
nf.meta;
nf.create;
const {
  isParenthesized: By
} = Vt.default;
var sf = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow unnecessary parentheses",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-extra-parens"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["functions"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["all"]
        }, {
          type: "object",
          properties: {
            conditionalAssign: {
              type: "boolean"
            },
            nestedBinaryExpressions: {
              type: "boolean"
            },
            returnAssign: {
              type: "boolean"
            },
            ignoreJSX: {
              enum: ["none", "all", "single-line", "multi-line"]
            },
            enforceForArrowConditionals: {
              type: "boolean"
            },
            enforceForSequenceExpressions: {
              type: "boolean"
            },
            enforceForNewInMemberExpressions: {
              type: "boolean"
            },
            enforceForFunctionPrototypeMethods: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      unexpected: "Unnecessary parentheses around expression."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = /* @__PURE__ */ new WeakSet(), s = E.getPrecedence, n = t.options[0] !== "functions", a = n && t.options[1] && t.options[1].conditionalAssign === !1, o = n && t.options[1] && t.options[1].nestedBinaryExpressions === !1, l = n && t.options[1] && t.options[1].returnAssign === !1, i = n && t.options[1] && t.options[1].ignoreJSX, u = n && t.options[1] && t.options[1].enforceForArrowConditionals === !1, c = n && t.options[1] && t.options[1].enforceForSequenceExpressions === !1, f = n && t.options[1] && t.options[1].enforceForNewInMemberExpressions === !1, h = n && t.options[1] && t.options[1].enforceForFunctionPrototypeMethods === !1, p = s({
      type: "AssignmentExpression"
    }), m = s({
      type: "UpdateExpression"
    });
    let d;
    function g(D) {
      const U = E.skipChainExpression(D);
      if (U.type !== "CallExpression")
        return !1;
      const ne = E.skipChainExpression(U.callee);
      return ne.type === "MemberExpression" && ne.object.type === "FunctionExpression" && ["call", "apply"].includes(E.getStaticPropertyName(ne));
    }
    function y(D) {
      if (D.type === "JSXElement" || D.type === "JSXFragment") {
        const U = D.loc.start.line === D.loc.end.line;
        switch (i) {
          case "all":
            return !1;
          case "multi-line":
            return U;
          case "single-line":
            return !U;
        }
      }
      return D.type === "SequenceExpression" && c || g(D) && h ? !1 : n || D.type === "FunctionExpression" || D.type === "ArrowFunctionExpression";
    }
    function x(D) {
      return By(1, D, e);
    }
    function A(D) {
      return By(2, D, e);
    }
    function b(D) {
      return y(D) && x(D);
    }
    function v(D) {
      return y(D) && A(D);
    }
    function C(D, U) {
      return !!(y(D) && x(D) && (s(D) >= U || A(D)));
    }
    function T(D) {
      return a && D.test.type === "AssignmentExpression";
    }
    function w(D) {
      for (let U = D; U; U = U.parent)
        if (U.type === "ReturnStatement" || U.type === "ArrowFunctionExpression" && U.body.type !== "BlockStatement")
          return !0;
      return !1;
    }
    function B(D) {
      const U = e.getLastToken(D), ne = e.getTokenBefore(U);
      return D.arguments.length > 0 || E.isOpeningParenToken(ne) && E.isClosingParenToken(U) && D.callee.range[1] < D.range[1];
    }
    function I(D) {
      return !!(D.type === "AssignmentExpression" || D.type === "ConditionalExpression" && (D.consequent.type === "AssignmentExpression" || D.alternate.type === "AssignmentExpression") || D.left && D.left.type === "AssignmentExpression" || D.right && D.right.type === "AssignmentExpression");
    }
    function _(D) {
      return !l || !w(D) ? !1 : D.type === "ReturnStatement" ? D.argument && I(D.argument) : D.type === "ArrowFunctionExpression" && D.body.type !== "BlockStatement" ? I(D.body) : I(D);
    }
    function S(D, U) {
      return D.loc.end.line === U.loc.start.line ? b(U) : v(U);
    }
    function F(D) {
      const U = e.getTokenBefore(D), ne = e.getTokenBefore(U, {
        includeComments: !0
      }), pe = e.getTokenAfter(U, {
        includeComments: !0
      });
      return ne && ne.range[1] === U.range[0] && U.range[1] === pe.range[0] && !E.canTokensBeAdjacent(ne, pe);
    }
    function N(D) {
      const U = e.getTokensAfter(D, {
        count: 2
      }), ne = U[0], pe = U[1], Ee = e.getLastToken(D);
      return ne && pe && !e.isSpaceBetweenTokens(ne, pe) && !E.canTokensBeAdjacent(Ee, pe);
    }
    function k(D) {
      const U = E.skipChainExpression(D);
      return U.type === "CallExpression" && U.callee.type === "FunctionExpression";
    }
    function j(D) {
      return D && (D.type === "Identifier" || D.type === "MemberExpression");
    }
    function O(D) {
      const U = e.getTokenBefore(D), ne = e.getTokenAfter(D);
      if (!A(D) && (r.has(e.getFirstToken(D)) || k(D) && !x(D.callee)))
        return;
      function pe() {
        t.report({
          node: D,
          loc: U.loc,
          messageId: "unexpected",
          fix(Ee) {
            const Re = e.text.slice(U.range[1], ne.range[0]);
            return Ee.replaceTextRange([U.range[0], ne.range[1]], (F(D) ? " " : "") + Re + (N(D) ? " " : ""));
          }
        });
      }
      if (d) {
        d.reports.push({
          node: D,
          finishReport: pe
        });
        return;
      }
      pe();
    }
    function z(D) {
      C(D.argument, s(D)) && O(D.argument);
    }
    function te(D) {
      let U = D.object, ne = D.object.type;
      for (; ne === "MemberExpression"; )
        U = U.object, ne = U.type;
      return ne === "CallExpression";
    }
    function se(D) {
      const U = D.callee;
      C(U, s(D)) && (v(U) || !(k(D) || U.type === "NewExpression" && !B(U) && !(D.type === "NewExpression" && !B(D)) || D.type === "NewExpression" && U.type === "MemberExpression" && te(U) || !D.optional && U.type === "ChainExpression")) && O(D.callee), D.arguments.filter((ne) => C(ne, p)).forEach(O);
    }
    function ye(D) {
      const U = s(D), ne = s(D.left), pe = s(D.right), Ee = D.operator === "**", Re = o && (D.left.type === "BinaryExpression" || D.left.type === "LogicalExpression"), We = o && (D.right.type === "BinaryExpression" || D.right.type === "LogicalExpression");
      !Re && b(D.left) && (!(["AwaitExpression", "UnaryExpression"].includes(D.left.type) && Ee) && !E.isMixedLogicalAndCoalesceExpressions(D.left, D) && (ne > U || ne === U && !Ee) || A(D.left)) && O(D.left), !We && b(D.right) && (!E.isMixedLogicalAndCoalesceExpressions(D.right, D) && (pe > U || pe === U && Ee) || A(D.right)) && O(D.right);
    }
    function Se(D) {
      if (!D.superClass)
        return;
      (s(D.superClass) > m ? b(D.superClass) : v(D.superClass)) && O(D.superClass);
    }
    function xe(D) {
      C(D.argument, p) && O(D.argument);
    }
    function Ae(D) {
      const U = x(D) ? e.getTokenBefore(D) : e.getFirstToken(D), ne = e.getTokenAfter(U, E.isNotOpeningParenToken), pe = ne ? e.getTokenAfter(ne) : null, Ee = ne ? e.getTokenAfter(ne, E.isNotClosingParenToken) : null;
      E.isOpeningParenToken(U) && (E.isOpeningBraceToken(ne) || ne.type === "Keyword" && (ne.value === "function" || ne.value === "class" || ne.value === "let" && Ee && (E.isOpeningBracketToken(Ee) || Ee.type === "Identifier")) || ne && ne.type === "Identifier" && ne.value === "async" && pe && pe.type === "Keyword" && pe.value === "function") && r.add(ne), (D.parent.type === "ExportDefaultDeclaration" ? C(D, p) : b(D)) && O(D);
    }
    function _e(D, U) {
      const ne = [D];
      let pe = D;
      for (; pe !== U; ) {
        if (pe = pe.parent, pe === null)
          throw new Error("Nodes are not in the ancestor-descendant relationship.");
        ne.push(pe);
      }
      return ne;
    }
    function H(D, U) {
      return _e(U, D).reverse();
    }
    function Q(D, U) {
      switch (D.type) {
        case "ArrayExpression":
        case "ArrayPattern":
        case "BlockStatement":
        case "ObjectExpression":
        case "ObjectPattern":
        case "TemplateLiteral":
          return !0;
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return D.params.includes(U);
        case "CallExpression":
        case "NewExpression":
          return D.arguments.includes(U);
        case "MemberExpression":
          return D.computed && D.property === U;
        case "ConditionalExpression":
          return D.consequent === U;
        default:
          return !1;
      }
    }
    function ge() {
      d = {
        upper: d,
        inExpressionNodes: [],
        reports: []
      };
    }
    function ae() {
      const {
        upper: D,
        inExpressionNodes: U,
        reports: ne
      } = d;
      D ? (D.inExpressionNodes.push(...U), D.reports.push(...ne)) : ne.forEach(({
        finishReport: pe
      }) => pe()), d = D;
    }
    function ee(D) {
      return d.reports.some((U) => U.node === D);
    }
    function he(D) {
      d.reports = d.reports.filter((U) => U.node !== D);
    }
    function R(D) {
      return D.type === "MemberExpression" ? D.parent.type === "NewExpression" && D.parent.callee === D ? !0 : D.parent.object === D && R(D.parent) : !1;
    }
    return {
      ArrayExpression(D) {
        D.elements.filter((U) => U && C(U, p)).forEach(O);
      },
      ArrayPattern(D) {
        D.elements.filter((U) => j(U) && b(U)).forEach(O);
      },
      ArrowFunctionExpression(D) {
        if (!_(D) && !(D.body.type === "ConditionalExpression" && u) && D.body.type !== "BlockStatement") {
          const U = e.getFirstToken(D.body, E.isNotOpeningParenToken), ne = e.getTokenBefore(U);
          E.isOpeningParenToken(ne) && E.isOpeningBraceToken(U) && r.add(U), C(D.body, p) && O(D.body);
        }
      },
      AssignmentExpression(D) {
        j(D.left) && b(D.left) && O(D.left), !_(D) && C(D.right, s(D)) && O(D.right);
      },
      BinaryExpression(D) {
        d && D.operator === "in" && d.inExpressionNodes.push(D), ye(D);
      },
      CallExpression: se,
      ClassBody(D) {
        D.body.filter((U) => U.type === "MethodDefinition" && U.computed && U.key).filter((U) => C(U.key, p)).forEach((U) => O(U.key));
      },
      ConditionalExpression(D) {
        _(D) || (!T(D) && C(D.test, s({
          type: "LogicalExpression",
          operator: "||"
        })) && O(D.test), C(D.consequent, p) && O(D.consequent), C(D.alternate, p) && O(D.alternate));
      },
      DoWhileStatement(D) {
        b(D.test) && !T(D) && O(D.test);
      },
      ExportDefaultDeclaration: (D) => Ae(D.declaration),
      ExpressionStatement: (D) => Ae(D.expression),
      ForInStatement(D) {
        if (D.left.type !== "VariableDeclaration") {
          const U = e.getFirstToken(D.left, E.isNotOpeningParenToken);
          U.value === "let" && E.isOpeningBracketToken(e.getTokenAfter(U, E.isNotClosingParenToken)) && r.add(U);
        }
        b(D.left) && O(D.left), b(D.right) && O(D.right);
      },
      ForOfStatement(D) {
        if (D.left.type !== "VariableDeclaration") {
          const U = e.getFirstToken(D.left, E.isNotOpeningParenToken);
          U.value === "let" && r.add(U);
        }
        b(D.left) && O(D.left), C(D.right, p) && O(D.right);
      },
      ForStatement(D) {
        if (D.test && b(D.test) && !T(D) && O(D.test), D.update && b(D.update) && O(D.update), D.init) {
          if (D.init.type !== "VariableDeclaration") {
            const U = e.getFirstToken(D.init, E.isNotOpeningParenToken);
            U.value === "let" && E.isOpeningBracketToken(e.getTokenAfter(U, E.isNotClosingParenToken)) && r.add(U);
          }
          ge(), b(D.init) && O(D.init);
        }
      },
      "ForStatement > *.init:exit"(D) {
        d.reports.length && d.inExpressionNodes.forEach((U) => {
          const ne = H(D, U);
          let pe;
          for (let Ee = 0; Ee < ne.length; Ee++) {
            const Re = ne[Ee];
            if (Ee < ne.length - 1) {
              const We = ne[Ee + 1];
              if (Q(Re, We))
                return;
            }
            if (x(Re))
              if (ee(Re)) {
                if (A(Re))
                  return;
                pe || (pe = Re);
              } else
                return;
          }
          he(pe);
        }), ae();
      },
      IfStatement(D) {
        b(D.test) && !T(D) && O(D.test);
      },
      ImportExpression(D) {
        const {
          source: U
        } = D;
        U.type === "SequenceExpression" ? v(U) && O(U) : b(U) && O(U);
      },
      LogicalExpression: ye,
      MemberExpression(D) {
        const ne = R(D) && te(D) ? v(D.object) : b(D.object) && !(g(D.parent) && D.parent.callee === D && h);
        ne && s(D.object) >= s(D) && (D.computed || !(E.isDecimalInteger(D.object) || D.object.type === "Literal" && D.object.regex)) && O(D.object), ne && D.object.type === "CallExpression" && O(D.object), ne && !f && D.object.type === "NewExpression" && B(D.object) && O(D.object), ne && D.optional && D.object.type === "ChainExpression" && O(D.object), D.computed && b(D.property) && O(D.property);
      },
      NewExpression: se,
      ObjectExpression(D) {
        D.properties.filter((U) => U.value && C(U.value, p)).forEach((U) => O(U.value));
      },
      ObjectPattern(D) {
        D.properties.filter((U) => {
          const ne = U.value;
          return j(ne) && b(ne);
        }).forEach((U) => O(U.value));
      },
      Property(D) {
        if (D.computed) {
          const {
            key: U
          } = D;
          U && C(U, p) && O(U);
        }
      },
      RestElement(D) {
        const U = D.argument;
        j(U) && b(U) && O(U);
      },
      ReturnStatement(D) {
        const U = e.getFirstToken(D);
        _(D) || D.argument && S(U, D.argument) && !(D.argument.type === "Literal" && D.argument.regex) && O(D.argument);
      },
      SequenceExpression(D) {
        const U = s(D);
        D.expressions.filter((ne) => C(ne, U)).forEach(O);
      },
      SwitchCase(D) {
        D.test && b(D.test) && O(D.test);
      },
      SwitchStatement(D) {
        b(D.discriminant) && O(D.discriminant);
      },
      ThrowStatement(D) {
        const U = e.getFirstToken(D);
        S(U, D.argument) && O(D.argument);
      },
      UnaryExpression: z,
      UpdateExpression(D) {
        if (D.prefix)
          z(D);
        else {
          const {
            argument: U
          } = D, ne = e.getLastToken(D);
          U.loc.end.line === ne.loc.start.line ? z(D) : v(U) && O(U);
        }
      },
      AwaitExpression: z,
      VariableDeclarator(D) {
        D.init && C(D.init, p) && !(D.init.type === "Literal" && D.init.regex) && O(D.init);
      },
      WhileStatement(D) {
        b(D.test) && !T(D) && O(D.test);
      },
      WithStatement(D) {
        b(D.object) && O(D.object);
      },
      YieldExpression(D) {
        if (D.argument) {
          const U = e.getFirstToken(D);
          (s(D.argument) >= s(D) && S(U, D.argument) || v(D.argument)) && O(D.argument);
        }
      },
      ClassDeclaration: Se,
      ClassExpression: Se,
      SpreadElement: xe,
      SpreadProperty: xe,
      ExperimentalSpreadProperty: xe,
      TemplateLiteral(D) {
        D.expressions.filter((U) => U && b(U)).forEach(O);
      },
      AssignmentPattern(D) {
        const {
          left: U,
          right: ne
        } = D;
        j(U) && b(U) && O(U), ne && C(ne, p) && O(ne);
      }
    };
  }
};
sf.meta;
sf.create;
var af = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary semicolons",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-extra-semi"
    },
    fixable: "code",
    schema: [],
    messages: {
      unexpected: "Unnecessary semicolon."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(n) {
      t.report({
        node: n,
        messageId: "unexpected",
        fix(a) {
          return new Qs(a, t.getSourceCode()).retainSurroundingTokens(n).remove(n);
        }
      });
    }
    function s(n) {
      for (let a = n; a.type === "Punctuator" && !E.isClosingBraceToken(a); a = e.getTokenAfter(a))
        E.isSemicolonToken(a) && r(a);
    }
    return {
      EmptyStatement(n) {
        const a = n.parent;
        ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement", "IfStatement", "LabeledStatement", "WithStatement"].indexOf(a.type) === -1 && r(n);
      },
      ClassBody(n) {
        s(e.getFirstToken(n, 1));
      },
      MethodDefinition(n) {
        s(e.getTokenAfter(n));
      }
    };
  }
};
af.meta;
af.create;
const GN = /falls?\s?through/iu;
function HN(t, e, r, s) {
  const n = r.getSourceCode();
  if (t.consequent.length === 1 && t.consequent[0].type === "BlockStatement") {
    const o = n.getLastToken(t.consequent[0]), l = n.getCommentsBefore(o).pop();
    if (l && s.test(l.value))
      return !0;
  }
  const a = n.getCommentsBefore(e).pop();
  return !!(a && s.test(a.value));
}
function KN(t) {
  return t.reachable;
}
function JN(t, e) {
  return e.loc.start.line > t.loc.end.line + 1;
}
var of = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow fallthrough of `case` statements",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-fallthrough"
    },
    schema: [{
      type: "object",
      properties: {
        commentPattern: {
          type: "string",
          default: ""
        }
      },
      additionalProperties: !1
    }],
    messages: {
      case: "Expected a 'break' statement before 'case'.",
      default: "Expected a 'break' statement before 'default'."
    }
  },
  create(t) {
    const e = t.options[0] || {};
    let r = null;
    const s = t.getSourceCode();
    let n = null, a = null;
    return e.commentPattern ? a = new RegExp(e.commentPattern, "u") : a = GN, {
      onCodePathStart(o) {
        r = o;
      },
      onCodePathEnd() {
        r = r.upper;
      },
      SwitchCase(o) {
        n && !HN(n, o, t, a) && t.report({
          messageId: o.test ? "case" : "default",
          node: o
        }), n = null;
      },
      "SwitchCase:exit"(o) {
        const l = s.getTokenAfter(o);
        r.currentSegments.some(KN) && (o.consequent.length > 0 || JN(o, l)) && o.parent.cases[o.parent.cases.length - 1] !== o && (n = o);
      }
    };
  }
};
of.meta;
of.create;
var lf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow leading or trailing decimal points in numeric literals",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-floating-decimal"
    },
    schema: [],
    fixable: "code",
    messages: {
      leading: "A leading decimal point can be confused with a dot.",
      trailing: "A trailing decimal point can be confused with a dot."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      Literal(r) {
        typeof r.value == "number" && (r.raw.startsWith(".") && t.report({
          node: r,
          messageId: "leading",
          fix(s) {
            const n = e.getTokenBefore(r), a = n && n.range[1] === r.range[0] && !E.canTokensBeAdjacent(n, `0${r.raw}`);
            return s.insertTextBefore(r, a ? " 0" : "0");
          }
        }), r.raw.indexOf(".") === r.raw.length - 1 && t.report({
          node: r,
          messageId: "trailing",
          fix: (s) => s.insertTextAfter(r, "0")
        }));
      }
    };
  }
};
lf.meta;
lf.create;
var uf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow reassigning `function` declarations",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-func-assign"
    },
    schema: [],
    messages: {
      isAFunction: "'{{name}}' is a function."
    }
  },
  create(t) {
    function e(n) {
      E.getModifyingReferences(n).forEach((a) => {
        t.report({
          node: a.identifier,
          messageId: "isAFunction",
          data: {
            name: a.identifier.name
          }
        });
      });
    }
    function r(n) {
      n.defs[0].type === "FunctionName" && e(n.references);
    }
    function s(n) {
      t.getDeclaredVariables(n).forEach(r);
    }
    return {
      FunctionDeclaration: s,
      FunctionExpression: s
    };
  }
};
uf.meta;
uf.create;
var cf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignments to native objects or read-only global variables",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-global-assign"
    },
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified."
    }
  },
  create(t) {
    const e = t.options[0], r = e && e.exceptions || [];
    function s(a, o, l) {
      const i = a.identifier;
      a.init === !1 && a.isWrite() && (o === 0 || l[o - 1].identifier !== i) && t.report({
        node: i,
        messageId: "globalShouldNotBeModified",
        data: {
          name: i.name
        }
      });
    }
    function n(a) {
      a.writeable === !1 && r.indexOf(a.name) === -1 && a.references.forEach(s);
    }
    return {
      Program() {
        t.getScope().variables.forEach(n);
      }
    };
  }
};
cf.meta;
cf.create;
const XN = /^(?:i|lastI)ndexOf$/u, QN = ["~", "!!", "+", "*"];
function YN(t) {
  return {
    boolean: "boolean" in t ? t.boolean : !0,
    number: "number" in t ? t.number : !0,
    string: "string" in t ? t.string : !0,
    disallowTemplateShorthand: "disallowTemplateShorthand" in t ? t.disallowTemplateShorthand : !1,
    allow: t.allow || []
  };
}
function ZN(t) {
  return t.operator === "!" && t.argument.type === "UnaryExpression" && t.argument.operator === "!";
}
function e3(t) {
  if (t.operator !== "~")
    return !1;
  const e = E.skipChainExpression(t.argument);
  return e.type === "CallExpression" && E.isSpecificMemberAccess(e.callee, null, XN);
}
function t3(t) {
  return t.operator === "*" && (t.left.type === "Literal" && t.left.value === 1 || t.right.type === "Literal" && t.right.value === 1);
}
function Bl(t) {
  return t.type === "Literal" && typeof t.value == "number" || t.type === "CallExpression" && (t.callee.name === "Number" || t.callee.name === "parseInt" || t.callee.name === "parseFloat");
}
function r3(t) {
  const e = t.left, r = t.right;
  return r.type !== "BinaryExpression" && !Bl(r) ? r : e.type !== "BinaryExpression" && !Bl(e) ? e : null;
}
function Ol(t) {
  return E.isStringLiteral(t) || t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "String";
}
function ii(t) {
  return E.isStringLiteral(t) && (t.value === "" || t.type === "TemplateLiteral" && t.quasis.length === 1 && t.quasis[0].value.cooked === "");
}
function n3(t) {
  return t.operator === "+" && (ii(t.left) && !Ol(t.right) || ii(t.right) && !Ol(t.left));
}
function s3(t) {
  return t.operator === "+=" && ii(t.right);
}
function Oy(t) {
  return ii(t.left) ? t.right : t.left;
}
var pf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow shorthand type conversions",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-implicit-coercion"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        boolean: {
          type: "boolean",
          default: !0
        },
        number: {
          type: "boolean",
          default: !0
        },
        string: {
          type: "boolean",
          default: !0
        },
        disallowTemplateShorthand: {
          type: "boolean",
          default: !1
        },
        allow: {
          type: "array",
          items: {
            enum: QN
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      useRecommendation: "use `{{recommendation}}` instead."
    }
  },
  create(t) {
    const e = YN(t.options[0] || {}), r = t.getSourceCode();
    function s(n, a, o) {
      t.report({
        node: n,
        messageId: "useRecommendation",
        data: {
          recommendation: a
        },
        fix(l) {
          if (!o)
            return null;
          const i = r.getTokenBefore(n);
          return i && i.range[1] === n.range[0] && !E.canTokensBeAdjacent(i, a) ? l.replaceText(n, ` ${a}`) : l.replaceText(n, a);
        }
      });
    }
    return {
      UnaryExpression(n) {
        let a = e.allow.indexOf("!!") >= 0;
        if (!a && e.boolean && ZN(n)) {
          const o = `Boolean(${r.getText(n.argument.argument)})`;
          s(n, o, !0);
        }
        if (a = e.allow.indexOf("~") >= 0, !a && e.boolean && e3(n)) {
          const o = n.argument.type === "ChainExpression" ? ">= 0" : "!== -1", l = `${r.getText(n.argument)} ${o}`;
          s(n, l, !1);
        }
        if (a = e.allow.indexOf("+") >= 0, !a && e.number && n.operator === "+" && !Bl(n.argument)) {
          const o = `Number(${r.getText(n.argument)})`;
          s(n, o, !0);
        }
      },
      "BinaryExpression:exit"(n) {
        let a = e.allow.indexOf("*") >= 0;
        const o = !a && e.number && t3(n) && r3(n);
        if (o) {
          const l = `Number(${r.getText(o)})`;
          s(n, l, !0);
        }
        if (a = e.allow.indexOf("+") >= 0, !a && e.string && n3(n)) {
          const l = `String(${r.getText(Oy(n))})`;
          s(n, l, !0);
        }
      },
      AssignmentExpression(n) {
        if (!(e.allow.indexOf("+") >= 0) && e.string && s3(n)) {
          const o = r.getText(Oy(n));
          s(n, `${o} = String(${o})`, !0);
        }
      },
      TemplateLiteral(n) {
        if (!e.disallowTemplateShorthand || n.parent.type === "TaggedTemplateExpression" || n.expressions.length !== 1 || n.quasis[0].value.cooked !== "" || n.quasis[1].value.cooked !== "" || Ol(n.expressions[0]))
          return;
        const a = r.getText(n.expressions[0]);
        s(n, `String(${a})`, !0);
      }
    };
  }
};
pf.meta;
pf.create;
var ff = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow declarations in the global scope",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-implicit-globals"
    },
    schema: [{
      type: "object",
      properties: {
        lexicalBindings: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
      globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",
      globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.",
      assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.",
      redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable."
    }
  },
  create(t) {
    const e = t.options[0] && t.options[0].lexicalBindings === !0;
    function r(s, n, a) {
      t.report({
        node: s,
        messageId: n,
        data: {
          kind: a
        }
      });
    }
    return {
      Program() {
        const s = t.getScope();
        s.variables.forEach((n) => {
          const a = n.writeable === !1;
          n.writeable !== !0 && n.defs.forEach((l) => {
            const i = l.node;
            (l.type === "FunctionName" || l.type === "Variable" && l.parent.kind === "var") && (a ? r(i, "redeclarationOfReadonlyGlobal") : r(i, "globalNonLexicalBinding", l.type === "FunctionName" ? "function" : `'${l.parent.kind}'`)), e && (l.type === "ClassName" || l.type === "Variable" && (l.parent.kind === "let" || l.parent.kind === "const")) && (a ? r(i, "redeclarationOfReadonlyGlobal") : r(i, "globalLexicalBinding", l.type === "ClassName" ? "class" : `'${l.parent.kind}'`));
          });
        }), s.implicit.variables.forEach((n) => {
          const a = s.set.get(n.name);
          let o;
          if (a) {
            if (a.writeable)
              return;
            o = "assignmentToReadonlyGlobal";
          } else
            o = "globalVariableLeak";
          n.defs.forEach((l) => {
            r(l.node, o);
          });
        });
      }
    };
  }
};
ff.meta;
ff.create;
const {
  getStaticValue: a3
} = Vt.default;
var hf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `eval()`-like methods",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-implied-eval"
    },
    schema: [],
    messages: {
      impliedEval: "Implied eval. Consider passing a function instead of a string."
    }
  },
  create(t) {
    const e = Object.freeze(["global", "window", "globalThis"]), r = /^(?:set(?:Interval|Timeout)|execScript)$/u;
    function s(o) {
      return o.type === "Literal" && typeof o.value == "string" || o.type === "TemplateLiteral" ? !0 : o.type === "BinaryExpression" && o.operator === "+" ? s(o.left) || s(o.right) : !1;
    }
    function n(o) {
      const [l] = o.arguments;
      if (l) {
        const i = a3(l, t.getScope());
        (i && typeof i.value == "string" || s(l)) && t.report({
          node: o,
          messageId: "impliedEval"
        });
      }
    }
    function a(o) {
      const {
        references: l,
        name: i
      } = o;
      l.forEach((u) => {
        let f = u.identifier.parent;
        for (; E.isSpecificMemberAccess(f, null, i); )
          f = f.parent;
        if (E.isSpecificMemberAccess(f, null, r)) {
          const h = f.parent.type === "ChainExpression" ? f.parent : f, p = h.parent;
          p.type === "CallExpression" && p.callee === h && n(p);
        }
      });
    }
    return {
      CallExpression(o) {
        E.isSpecificId(o.callee, r) && n(o);
      },
      "Program:exit"() {
        const o = t.getScope();
        e.map((l) => E.getVariableByName(o, l)).filter((l) => !!l && l.defs.length === 0).forEach(a);
      }
    };
  }
};
hf.meta;
hf.create;
const {
  findVariable: i3
} = Vt.default, Ly = {
  Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,
  Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u
};
function o3(t) {
  const {
    parent: e
  } = t;
  return e.type === "AssignmentExpression" && e.left === t || e.type === "ArrayPattern" || e.type === "Property" && e.value === t && e.parent.type === "ObjectPattern" || e.type === "RestElement" || e.type === "AssignmentPattern" && e.left === t;
}
function l3(t) {
  const e = t.parent.type === "ChainExpression" ? t.parent : t, {
    parent: r
  } = e;
  return r.type === "UpdateExpression" && r.argument === e || r.type === "UnaryExpression" && r.operator === "delete" && r.argument === e;
}
function u3(t) {
  const {
    parent: e
  } = t;
  return e.type === "ForInStatement" && e.left === t || e.type === "ForOfStatement" && e.left === t;
}
function c3(t, e) {
  const {
    parent: r
  } = t;
  if (r.type !== "CallExpression" || r.arguments[0] !== t)
    return !1;
  const s = E.skipChainExpression(r.callee);
  if (!E.isSpecificMemberAccess(s, "Object", Ly.Object) && !E.isSpecificMemberAccess(s, "Reflect", Ly.Reflect))
    return !1;
  const n = i3(e, s.object);
  return n !== null && n.scope.type === "global";
}
function p3(t, e) {
  const {
    parent: r
  } = t;
  return r.type === "MemberExpression" && r.object === t && (o3(r) || l3(r) || u3(r)) || c3(t, e);
}
function Ry(t) {
  let e = t.parent;
  for (; e && e.type !== "AssignmentExpression" && e.type !== "UpdateExpression" && e.type !== "UnaryExpression" && e.type !== "CallExpression" && e.type !== "ForInStatement" && e.type !== "ForOfStatement"; )
    e = e.parent;
  return e || t;
}
var mf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assigning to imported bindings",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-import-assign"
    },
    schema: [],
    messages: {
      readonly: "'{{name}}' is read-only.",
      readonlyMember: "The members of '{{name}}' are read-only."
    }
  },
  create(t) {
    return {
      ImportDeclaration(e) {
        const r = t.getScope();
        for (const s of t.getDeclaredVariables(e)) {
          const n = s.defs.some((o) => o.node.type === "ImportNamespaceSpecifier");
          let a = null;
          for (const o of s.references) {
            const l = o.identifier;
            l !== a && (a = l, o.isWrite() ? t.report({
              node: Ry(l),
              messageId: "readonly",
              data: {
                name: l.name
              }
            }) : n && p3(l, r) && t.report({
              node: Ry(l),
              messageId: "readonlyMember",
              data: {
                name: l.name
              }
            }));
          }
        }
      }
    };
  }
};
mf.meta;
mf.create;
var df = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow inline comments after code",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-inline-comments"
    },
    schema: [{
      type: "object",
      properties: {
        ignorePattern: {
          type: "string"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedInlineComment: "Unexpected comment inline with code."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0];
    let s;
    r && r.ignorePattern && (s = new RegExp(r.ignorePattern, "u"));
    function n(a) {
      const o = String(e.lines[a.loc.start.line - 1]), l = String(e.lines[a.loc.end.line - 1]), i = o.slice(0, a.loc.start.column).trim(), u = l.slice(a.loc.end.column).trim(), c = !i, f = !u;
      if (!(c && f) && !(s && s.test(a.value))) {
        if ((c || i === "{") && (f || u === "}")) {
          const h = e.getNodeByRangeIndex(a.range[0]);
          if (h && h.type === "JSXEmptyExpression")
            return;
        }
        E.isDirectiveComment(a) || t.report({
          node: a,
          messageId: "unexpectedInlineComment"
        });
      }
    }
    return {
      Program() {
        e.getAllComments().filter((a) => a.type !== "Shebang").forEach(n);
      }
    };
  }
};
df.meta;
df.create;
const f3 = /* @__PURE__ */ new Set(["Program", "ExportNamedDeclaration", "ExportDefaultDeclaration"]), h3 = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);
var gf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow variable or `function` declarations in nested blocks",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-inner-declarations"
    },
    schema: [{
      enum: ["functions", "both"]
    }],
    messages: {
      moveDeclToRoot: "Move {{type}} declaration to {{body}} root."
    }
  },
  create(t) {
    function e(r) {
      const s = r.parent;
      if (s.type === "BlockStatement" && h3.has(s.parent.type) || f3.has(s.type))
        return;
      const n = E.getUpperFunction(s);
      t.report({
        node: r,
        messageId: "moveDeclToRoot",
        data: {
          type: r.type === "FunctionDeclaration" ? "function" : "variable",
          body: n === null ? "program" : "function body"
        }
      });
    }
    return {
      FunctionDeclaration: e,
      VariableDeclaration(r) {
        t.options[0] === "both" && r.kind === "var" && e(r);
      }
    };
  }
};
gf.meta;
gf.create;
const m3 = pn.default.RegExpValidator, Ny = new m3(), d3 = /[gimuys]/gu, jy = void 0;
var yf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow invalid regular expression strings in `RegExp` constructors",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-invalid-regexp"
    },
    schema: [{
      type: "object",
      properties: {
        allowConstructorFlags: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: !1
    }],
    messages: {
      regexMessage: "{{message}}."
    }
  },
  create(t) {
    const e = t.options[0];
    let r = null;
    if (e && e.allowConstructorFlags) {
      const l = e.allowConstructorFlags.join("").replace(d3, "");
      l && (r = new RegExp(`[${l}]`, "giu"));
    }
    function s(l) {
      return l && l.type === "Literal" && typeof l.value == "string";
    }
    function n(l) {
      return l.arguments.length < 2 ? "" : s(l.arguments[1]) ? l.arguments[1].value : null;
    }
    function a(l, i) {
      try {
        return Ny.validatePattern(l, jy, jy, i), null;
      } catch (u) {
        return u.message;
      }
    }
    function o(l) {
      try {
        return Ny.validateFlags(l), null;
      } catch {
        return `Invalid flags supplied to RegExp constructor '${l}'`;
      }
    }
    return {
      "CallExpression, NewExpression"(l) {
        if (l.callee.type !== "Identifier" || l.callee.name !== "RegExp" || !s(l.arguments[0]))
          return;
        const i = l.arguments[0].value;
        let u = n(l);
        u && r && (u = u.replace(r, ""));
        const c = u && o(u) || (u === null ? a(i, !0) && a(i, !1) : a(i, u.includes("u")));
        c && t.report({
          node: l,
          messageId: "regexMessage",
          data: {
            message: c
          }
        });
      }
    };
  }
};
yf.meta;
yf.create;
var xf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `this` keywords outside of classes or class-like objects",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-invalid-this"
    },
    schema: [{
      type: "object",
      properties: {
        capIsConstructor: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedThis: "Unexpected 'this'."
    }
  },
  create(t) {
    const r = (t.options[0] || {}).capIsConstructor !== !1, s = [], n = t.getSourceCode();
    s.getCurrent = function() {
      const l = this[this.length - 1];
      return l.init || (l.init = !0, l.valid = !E.isDefaultThisBinding(l.node, n, {
        capIsConstructor: r
      })), l;
    };
    function a(l) {
      s.push({
        init: !t.getScope().isStrict,
        node: l,
        valid: !0
      });
    }
    function o() {
      s.pop();
    }
    return {
      Program(l) {
        const i = t.getScope(), u = t.parserOptions.ecmaFeatures || {};
        s.push({
          init: !0,
          node: l,
          valid: !(i.isStrict || l.sourceType === "module" || u.globalReturn && i.childScopes[0].isStrict)
        });
      },
      "Program:exit"() {
        s.pop();
      },
      FunctionDeclaration: a,
      "FunctionDeclaration:exit": o,
      FunctionExpression: a,
      "FunctionExpression:exit": o,
      ThisExpression(l) {
        const i = s.getCurrent();
        i && !i.valid && t.report({
          node: l,
          messageId: "unexpectedThis"
        });
      }
    };
  }
};
xf.meta;
xf.create;
const Ca = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u, g3 = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu, y3 = /[\u2028\u2029]/mgu, x3 = E.createGlobalLinebreakMatcher();
var vf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow irregular whitespace",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-irregular-whitespace"
    },
    schema: [{
      type: "object",
      properties: {
        skipComments: {
          type: "boolean",
          default: !1
        },
        skipStrings: {
          type: "boolean",
          default: !0
        },
        skipTemplates: {
          type: "boolean",
          default: !1
        },
        skipRegExps: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      noIrregularWhitespace: "Irregular whitespace not allowed."
    }
  },
  create(t) {
    let e = [];
    const r = t.options[0] || {}, s = !!r.skipComments, n = r.skipStrings !== !1, a = !!r.skipRegExps, o = !!r.skipTemplates, l = t.getSourceCode(), i = l.getAllComments();
    function u(y) {
      const x = y.loc.start, A = y.loc.end;
      e = e.filter(({
        loc: {
          start: b
        }
      }) => b.line < x.line || b.line === x.line && b.column < x.column || b.line === A.line && b.column >= A.column || b.line > A.line);
    }
    function c(y) {
      const x = n && typeof y.value == "string", A = a && !!y.regex;
      (x || A) && Ca.test(y.raw) && u(y);
    }
    function f(y) {
      typeof y.value.raw == "string" && Ca.test(y.value.raw) && u(y);
    }
    function h(y) {
      Ca.test(y.value) && u(y);
    }
    function p(y) {
      l.lines.forEach((A, b) => {
        const v = b + 1;
        let C;
        for (; (C = g3.exec(A)) !== null; )
          e.push({
            node: y,
            messageId: "noIrregularWhitespace",
            loc: {
              start: {
                line: v,
                column: C.index
              },
              end: {
                line: v,
                column: C.index + C[0].length
              }
            }
          });
      });
    }
    function m(y) {
      const x = l.getText(), A = l.lines, b = x.match(x3);
      let v = -1, C;
      for (; (C = y3.exec(x)) !== null; ) {
        const T = b.indexOf(C[0], v + 1) || 0;
        e.push({
          node: y,
          messageId: "noIrregularWhitespace",
          loc: {
            start: {
              line: T + 1,
              column: A[T].length
            },
            end: {
              line: T + 2,
              column: 0
            }
          }
        }), v = T;
      }
    }
    function d() {
    }
    const g = {};
    return Ca.test(l.getText()) ? (g.Program = function(y) {
      p(y), m(y);
    }, g.Identifier = c, g.Literal = c, g.TemplateElement = o ? f : d, g["Program:exit"] = function() {
      s && i.forEach(h), e.forEach((y) => t.report(y));
    }) : g.Program = d, g;
  }
};
vf.meta;
vf.create;
const {
  getStaticPropertyName: v3
} = E;
var Ef = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of the `__iterator__` property",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-iterator"
    },
    schema: [],
    messages: {
      noIterator: "Reserved name '__iterator__'."
    }
  },
  create(t) {
    return {
      MemberExpression(e) {
        v3(e) === "__iterator__" && t.report({
          node: e,
          messageId: "noIterator"
        });
      }
    };
  }
};
Ef.meta;
Ef.create;
var bf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow labels that share a name with a variable",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-label-var"
    },
    schema: [],
    messages: {
      identifierClashWithLabel: "Found identifier with same name as label."
    }
  },
  create(t) {
    function e(r, s) {
      return E.getVariableByName(r, s) !== null;
    }
    return {
      LabeledStatement(r) {
        const s = t.getScope();
        e(s, r.label.name) && t.report({
          node: r,
          messageId: "identifierClashWithLabel"
        });
      }
    };
  }
};
bf.meta;
bf.create;
var Cf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow labeled statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-labels"
    },
    schema: [{
      type: "object",
      properties: {
        allowLoop: {
          type: "boolean",
          default: !1
        },
        allowSwitch: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedLabel: "Unexpected labeled statement.",
      unexpectedLabelInBreak: "Unexpected label in break statement.",
      unexpectedLabelInContinue: "Unexpected label in continue statement."
    }
  },
  create(t) {
    const e = t.options[0], r = e && e.allowLoop, s = e && e.allowSwitch;
    let n = null;
    function a(i) {
      return E.isLoop(i) ? "loop" : i.type === "SwitchStatement" ? "switch" : "other";
    }
    function o(i) {
      switch (i) {
        case "loop":
          return r;
        case "switch":
          return s;
        default:
          return !1;
      }
    }
    function l(i) {
      let u = n;
      for (; u; ) {
        if (u.label === i)
          return u.kind;
        u = u.upper;
      }
      return "other";
    }
    return {
      LabeledStatement(i) {
        n = {
          label: i.label.name,
          kind: a(i.body),
          upper: n
        };
      },
      "LabeledStatement:exit"(i) {
        o(n.kind) || t.report({
          node: i,
          messageId: "unexpectedLabel"
        }), n = n.upper;
      },
      BreakStatement(i) {
        i.label && !o(l(i.label.name)) && t.report({
          node: i,
          messageId: "unexpectedLabelInBreak"
        });
      },
      ContinueStatement(i) {
        i.label && !o(l(i.label.name)) && t.report({
          node: i,
          messageId: "unexpectedLabelInContinue"
        });
      }
    };
  }
};
Cf.meta;
Cf.create;
var Sf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary nested blocks",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-lone-blocks"
    },
    schema: [],
    messages: {
      redundantBlock: "Block is redundant.",
      redundantNestedBlock: "Nested block is redundant."
    }
  },
  create(t) {
    const e = [];
    let r;
    function s(o) {
      const l = o.parent.type === "BlockStatement" ? "redundantNestedBlock" : "redundantBlock";
      t.report({
        node: o,
        messageId: l
      });
    }
    function n(o) {
      return o.parent.type === "BlockStatement" || o.parent.type === "Program" || o.parent.type === "SwitchCase" && !(o.parent.consequent[0] === o && o.parent.consequent.length === 1);
    }
    function a() {
      if (e.length === 0)
        return;
      const o = t.getAncestors().pop();
      e[e.length - 1] === o && e.pop();
    }
    return r = {
      BlockStatement(o) {
        n(o) && s(o);
      }
    }, t.parserOptions.ecmaVersion >= 6 && (r = {
      BlockStatement(o) {
        n(o) && e.push(o);
      },
      "BlockStatement:exit"(o) {
        e.length > 0 && e[e.length - 1] === o ? (e.pop(), s(o)) : o.parent.type === "BlockStatement" && o.parent.body.length === 1 && s(o);
      }
    }, r.VariableDeclaration = function(o) {
      (o.kind === "let" || o.kind === "const") && a();
    }, r.FunctionDeclaration = function() {
      t.getScope().isStrict && a();
    }, r.ClassDeclaration = a), r;
  }
};
Sf.meta;
Sf.create;
var Af = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `if` statements as the only statement in `else` blocks",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-lonely-if"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedLonelyIf: "Unexpected if as the only statement in an else block."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      IfStatement(r) {
        const s = t.getAncestors(), n = s.pop(), a = s.pop();
        n && n.type === "BlockStatement" && n.body.length === 1 && a && a.type === "IfStatement" && n === a.alternate && t.report({
          node: r,
          messageId: "unexpectedLonelyIf",
          fix(o) {
            const l = e.getFirstToken(n), i = e.getLastToken(n), u = e.getTokenBefore(l), c = e.getTokenAfter(i), f = e.getLastToken(r.consequent), h = e.getText();
            return h.slice(l.range[1], r.range[0]).trim() || h.slice(r.range[1], i.range[0]).trim() || r.consequent.type !== "BlockStatement" && f.value !== ";" && c && (r.consequent.loc.end.line === c.loc.start.line || /^[([/+`-]/u.test(c.value) || f.value === "++" || f.value === "--") ? null : o.replaceTextRange([l.range[0], i.range[1]], (u.range[1] === l.range[0] ? " " : "") + e.getText(r));
          }
        });
      }
    };
  }
};
Af.meta;
Af.create;
function vb(t) {
  for (let e = t; e.parent; e = e.parent) {
    const r = e.parent;
    switch (r.type) {
      case "WhileStatement":
      case "DoWhileStatement":
        return r;
      case "ForStatement":
        if (r.init !== e)
          return r;
        break;
      case "ForInStatement":
      case "ForOfStatement":
        if (r.right !== e)
          return r;
        break;
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "FunctionDeclaration":
        return null;
    }
  }
  return null;
}
function E3(t, e) {
  const r = e ? e.range[1] : 0;
  let s = t, n = t;
  for (; n && n.range[0] >= r; )
    s = n, n = vb(n);
  return s;
}
function b3(t, e) {
  const r = e.resolved, s = r && r.defs[0], n = s && s.parent, a = n && n.type === "VariableDeclaration" ? n.kind : "";
  if (a === "const" || a === "let" && n.range[0] > t.range[0] && n.range[1] < t.range[1])
    return !0;
  const o = E3(t, a === "let" ? n : null).range[0];
  return !!r && r.references.every(function(l) {
    const i = l.identifier;
    return !l.isWrite() || r.scope.variableScope === l.from.variableScope && i.range[0] < o;
  });
}
var Df = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow function declarations that contain unsafe references inside loop statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-loop-func"
    },
    schema: [],
    messages: {
      unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."
    }
  },
  create(t) {
    function e(r) {
      const s = vb(r);
      if (!s)
        return;
      const a = t.getScope().through.filter((o) => !b3(s, o)).map((o) => o.identifier.name);
      a.length > 0 && t.report({
        node: r,
        messageId: "unsafeRefs",
        data: {
          varNames: `'${a.join("', '")}'`
        }
      });
    }
    return {
      ArrowFunctionExpression: e,
      FunctionExpression: e,
      FunctionDeclaration: e
    };
  }
};
Df.meta;
Df.create;
var wf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow literal numbers that lose precision",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-loss-of-precision"
    },
    schema: [],
    messages: {
      noLossOfPrecision: "This number literal will lose precision at runtime."
    }
  },
  create(t) {
    function e(p) {
      return typeof p.value == "number";
    }
    function r(p) {
      return p.raw.replace(/_/gu, "");
    }
    function s(p) {
      return ["0x", "0X", "0b", "0B", "0o", "0O"].every((m) => !p.raw.startsWith(m)) && !/^0[0-7]+$/u.test(p.raw);
    }
    function n(p) {
      const m = r(p).toUpperCase();
      let d = 0;
      return m.startsWith("0B") ? d = 2 : m.startsWith("0X") ? d = 16 : d = 8, !m.endsWith(p.value.toString(d).toUpperCase());
    }
    function a(p) {
      return `${p.slice(0, 1)}.${p.slice(1)}`;
    }
    function o(p) {
      return p.replace(/^0*/u, "");
    }
    function l(p) {
      return p.replace(/0*$/u, "");
    }
    function i(p) {
      const m = l(o(p));
      return {
        magnitude: p.startsWith("0") ? p.length - 2 : p.length - 1,
        coefficient: a(m)
      };
    }
    function u(p) {
      const m = o(p);
      if (m.startsWith(".")) {
        const d = m.split(".").pop(), g = o(d);
        return {
          magnitude: g.length - d.length - 1,
          coefficient: a(g)
        };
      }
      return {
        magnitude: m.indexOf(".") - 1,
        coefficient: a(m.replace(".", ""))
      };
    }
    function c(p) {
      const m = p.replace("E", "e").split("e"), d = m[0], g = p.includes(".") ? u(d) : i(d), y = g.coefficient, x = m.length > 1 ? parseInt(m[1], 10) + g.magnitude : g.magnitude;
      return `${y}e${x}`;
    }
    function f(p) {
      const m = c(r(p)), d = m.split("e")[0].replace(".", "").length;
      if (d > 100)
        return !0;
      const g = p.value.toPrecision(d), y = c(g);
      return m !== y;
    }
    function h(p) {
      return s(p) ? f(p) : n(p);
    }
    return {
      Literal(p) {
        p.value && e(p) && h(p) && t.report({
          messageId: "noLossOfPrecision",
          node: p
        });
      }
    };
  }
};
wf.meta;
wf.create;
const C3 = 4294967295;
function S3(t) {
  return typeof t == "string" ? BigInt(t.slice(0, -1)) : t;
}
var kf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow magic numbers",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-magic-numbers"
    },
    schema: [{
      type: "object",
      properties: {
        detectObjects: {
          type: "boolean",
          default: !1
        },
        enforceConst: {
          type: "boolean",
          default: !1
        },
        ignore: {
          type: "array",
          items: {
            anyOf: [{
              type: "number"
            }, {
              type: "string",
              pattern: "^[+-]?(?:0|[1-9][0-9]*)n$"
            }]
          },
          uniqueItems: !0
        },
        ignoreArrayIndexes: {
          type: "boolean",
          default: !1
        },
        ignoreDefaultValues: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      useConst: "Number constants declarations must use 'const'.",
      noMagic: "No magic number: {{raw}}."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = !!e.detectObjects, s = !!e.enforceConst, n = (e.ignore || []).map(S3), a = !!e.ignoreArrayIndexes, o = !!e.ignoreDefaultValues, l = r ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
    function i(p) {
      return n.indexOf(p) !== -1;
    }
    function u(p) {
      const m = p.parent;
      return m.type === "AssignmentPattern" && m.right === p;
    }
    function c(p) {
      const m = p.parent;
      return m.type === "CallExpression" && p === m.arguments[1] && (E.isSpecificId(m.callee, "parseInt") || E.isSpecificMemberAccess(m.callee, "Number", "parseInt"));
    }
    function f(p) {
      return p.parent.type.indexOf("JSX") === 0;
    }
    function h(p, m) {
      const d = p.parent;
      return d.type === "MemberExpression" && d.property === p && (Number.isInteger(m) || typeof m == "bigint") && m >= 0 && m < C3;
    }
    return {
      Literal(p) {
        if (!E.isNumericLiteral(p))
          return;
        let m, d, g;
        p.parent.type === "UnaryExpression" && p.parent.operator === "-" ? (m = p.parent, d = -p.value, g = `-${p.raw}`) : (m = p, d = p.value, g = p.raw);
        const y = m.parent;
        i(d) || o && u(m) || c(m) || f(m) || a && h(m, d) || (y.type === "VariableDeclarator" ? s && y.parent.kind !== "const" && t.report({
          node: m,
          messageId: "useConst"
        }) : (l.indexOf(y.type) === -1 || y.type === "AssignmentExpression" && y.left.type === "Identifier") && t.report({
          node: m,
          messageId: "noMagic",
          data: {
            raw: g
          }
        }));
      }
    };
  }
};
kf.meta;
kf.create;
var A3 = function(t) {
  return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(t));
}, D3 = function(t) {
  return t >= 127995 && t <= 127999;
}, w3 = function(t) {
  return t >= 127462 && t <= 127487;
}, k3 = function(t, e) {
  return t >= 55296 && t < 56320 && e >= 56320 && e < 57344;
}, T3 = {
  isCombiningCharacter: A3,
  isEmojiModifier: D3,
  isRegionalIndicatorSymbol: w3,
  isSurrogatePair: k3
};
const {
  CALL: F3,
  CONSTRUCT: P3,
  ReferenceTracker: I3,
  getStringIfConstant: My
} = Vt.default, {
  RegExpParser: _3,
  visitRegExpAST: B3
} = pn.default, {
  isCombiningCharacter: $y,
  isEmojiModifier: Vy,
  isRegionalIndicatorSymbol: Uy,
  isSurrogatePair: O3
} = T3;
function* L3(t) {
  let e = [];
  for (const r of t)
    switch (r.type) {
      case "Character":
        e.push(r.value);
        break;
      case "CharacterClassRange":
        e.push(r.min.value), yield e, e = [r.max.value];
        break;
      case "CharacterSet":
        e.length > 0 && (yield e, e = []);
        break;
    }
  e.length > 0 && (yield e);
}
const Eb = {
  surrogatePairWithoutUFlag(t) {
    return t.some((e, r) => r !== 0 && O3(t[r - 1], e));
  },
  combiningClass(t) {
    return t.some((e, r) => r !== 0 && $y(e) && !$y(t[r - 1]));
  },
  emojiModifier(t) {
    return t.some((e, r) => r !== 0 && Vy(e) && !Vy(t[r - 1]));
  },
  regionalIndicatorSymbol(t) {
    return t.some((e, r) => r !== 0 && Uy(e) && Uy(t[r - 1]));
  },
  zwj(t) {
    const e = t.length - 1;
    return t.some((r, s) => s !== 0 && s !== e && r === 8205 && t[s - 1] !== 8205 && t[s + 1] !== 8205);
  }
}, qy = Object.keys(Eb);
var Tf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow characters which are made with multiple code points in character class syntax",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-misleading-character-class"
    },
    schema: [],
    messages: {
      surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
      combiningClass: "Unexpected combined character in character class.",
      emojiModifier: "Unexpected modified Emoji in character class.",
      regionalIndicatorSymbol: "Unexpected national flag in character class.",
      zwj: "Unexpected joined character sequence in character class."
    }
  },
  create(t) {
    const e = new _3();
    function r(s, n, a) {
      const o = {
        surrogatePairWithoutUFlag: !1,
        combiningClass: !1,
        variationSelector: !1,
        emojiModifier: !1,
        regionalIndicatorSymbol: !1,
        zwj: !1
      };
      let l;
      try {
        l = e.parsePattern(n, 0, n.length, a.includes("u"));
      } catch {
        return;
      }
      B3(l, {
        onCharacterClassEnter(i) {
          for (const u of L3(i.elements))
            for (const c of qy)
              o[c] = o[c] || Eb[c](u);
        }
      });
      for (const i of qy)
        o[i] && t.report({
          node: s,
          messageId: i
        });
    }
    return {
      "Literal[regex]"(s) {
        r(s, s.regex.pattern, s.regex.flags);
      },
      Program() {
        const s = t.getScope(), n = new I3(s);
        for (const {
          node: a
        } of n.iterateGlobalReferences({
          RegExp: {
            [F3]: !0,
            [P3]: !0
          }
        })) {
          const [o, l] = a.arguments, i = My(o, s), u = My(l, s);
          typeof i == "string" && r(a, i, u || "");
        }
      }
    };
  }
};
Tf.meta;
Tf.create;
const bb = ["+", "-", "*", "/", "%", "**"], Cb = ["&", "|", "^", "~", "<<", ">>", ">>>"], Sb = ["==", "!=", "===", "!==", ">", ">=", "<", "<="], Ab = ["&&", "||"], Db = ["in", "instanceof"], R3 = ["?:"], N3 = ["??"], j3 = [].concat(bb, Cb, Sb, Ab, Db, R3, N3), M3 = [bb, Cb, Sb, Ab, Db], $3 = /^(?:Binary|Logical|Conditional)Expression$/u;
function V3(t = {}) {
  const r = t.groups && t.groups.length > 0 ? t.groups : M3, s = t.allowSamePrecedence !== !1;
  return {
    groups: r,
    allowSamePrecedence: s
  };
}
function U3(t, e, r) {
  return t.some((s) => s.indexOf(e) !== -1 && s.indexOf(r) !== -1);
}
function zo(t) {
  return t.type === "ConditionalExpression" ? t.test : t.left;
}
var Ff = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow mixed binary operators",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-mixed-operators"
    },
    schema: [{
      type: "object",
      properties: {
        groups: {
          type: "array",
          items: {
            type: "array",
            items: {
              enum: j3
            },
            minItems: 2,
            uniqueItems: !0
          },
          uniqueItems: !0
        },
        allowSamePrecedence: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = V3(t.options[0]);
    function s(i) {
      const u = i, c = i.parent;
      return !U3(r.groups, u.operator, c.type === "ConditionalExpression" ? "?:" : c.operator) || r.allowSamePrecedence && E.getPrecedence(u) === E.getPrecedence(c);
    }
    function n(i) {
      return i.operator !== i.parent.operator && !E.isParenthesised(e, i);
    }
    function a(i) {
      return e.getTokenAfter(zo(i), E.isNotClosingParenToken);
    }
    function o(i) {
      const u = i.parent, c = zo(u) === i ? i : u, f = zo(u) !== i ? i : u, h = {
        leftOperator: c.operator || "?:",
        rightOperator: f.operator || "?:"
      };
      t.report({
        node: c,
        loc: a(c).loc,
        messageId: "unexpectedMixedOperator",
        data: h
      }), t.report({
        node: f,
        loc: a(f).loc,
        messageId: "unexpectedMixedOperator",
        data: h
      });
    }
    function l(i) {
      $3.test(i.parent.type) && n(i) && !s(i) && o(i);
    }
    return {
      BinaryExpression: l,
      LogicalExpression: l
    };
  }
};
Ff.meta;
Ff.create;
var Pf = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow `require` calls to be mixed with regular variable declarations",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-mixed-requires"
    },
    schema: [{
      oneOf: [{
        type: "boolean"
      }, {
        type: "object",
        properties: {
          grouping: {
            type: "boolean"
          },
          allowCall: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      noMixRequire: "Do not mix 'require' and other declarations.",
      noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires."
    }
  },
  create(t) {
    const e = t.options[0];
    let r = !1, s = !1;
    typeof e == "object" ? (r = e.grouping, s = e.allowCall) : r = !!e;
    const n = function() {
      return ["assert", "buffer", "child_process", "cluster", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "net", "os", "path", "punycode", "querystring", "readline", "repl", "smalloc", "stream", "string_decoder", "tls", "tty", "url", "util", "v8", "vm", "zlib"];
    }(), a = "require", o = "uninitialized", l = "other", i = "computed";
    function u(p) {
      return p ? p.type === "CallExpression" && p.callee.type === "Identifier" && p.callee.name === "require" ? a : s && p.type === "CallExpression" && p.callee.type === "CallExpression" ? u(p.callee) : p.type === "MemberExpression" ? u(p.object) : l : o;
    }
    function c(p) {
      if (p.type === "MemberExpression")
        return c(p.object);
      if (p.arguments.length === 0)
        return i;
      const m = p.arguments[0];
      return m.type !== "Literal" || typeof m.value != "string" ? i : n.indexOf(m.value) !== -1 ? "core" : /^\.{0,2}\//u.test(m.value) ? "file" : "module";
    }
    function f(p) {
      const m = {};
      return p.forEach((d) => {
        const g = u(d.init);
        m[g] = !0;
      }), !!(m[a] && (m[o] || m[l]));
    }
    function h(p) {
      const m = {};
      return p.forEach((d) => {
        u(d.init) === a && (m[c(d.init)] = !0);
      }), Object.keys(m).length <= 1;
    }
    return {
      VariableDeclaration(p) {
        f(p.declarations) ? t.report({
          node: p,
          messageId: "noMixRequire"
        }) : r && !h(p.declarations) && t.report({
          node: p,
          messageId: "noMixCoreModuleFileComputed"
        });
      }
    };
  }
};
Pf.meta;
Pf.create;
var If = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow mixed spaces and tabs for indentation",
      category: "Stylistic Issues",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-mixed-spaces-and-tabs"
    },
    schema: [{
      enum: ["smart-tabs", !0, !1]
    }],
    messages: {
      mixedSpacesAndTabs: "Mixed spaces and tabs."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r;
    switch (t.options[0]) {
      case !0:
      case "smart-tabs":
        r = !0;
        break;
      default:
        r = !1;
    }
    return {
      "Program:exit"(s) {
        const n = e.lines, a = e.getAllComments(), o = /* @__PURE__ */ new Set();
        a.forEach((i) => {
          for (let u = i.loc.start.line + 1; u <= i.loc.end.line; u++)
            o.add(u);
        });
        let l = /^(?=( +|\t+))\1(?:\t| )/u;
        r && (l = /^(?=(\t*))\1(?=( +))\2\t/u), n.forEach((i, u) => {
          const c = l.exec(i);
          if (c) {
            const f = u + 1, h = {
              start: {
                line: f,
                column: c[0].length - 2
              },
              end: {
                line: f,
                column: c[0].length
              }
            };
            if (!o.has(f)) {
              const p = e.getNodeByRangeIndex(e.getIndexFromLoc(h.start));
              p && ["Literal", "TemplateElement"].includes(p.type) || t.report({
                node: s,
                loc: h,
                messageId: "mixedSpacesAndTabs"
              });
            }
          }
        });
      }
    };
  }
};
If.meta;
If.create;
var _f = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow use of chained assignment expressions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-multi-assign"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreNonDeclaration: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedChain: "Unexpected chained assignment."
    }
  },
  create(t) {
    const r = (t.options[0] || {
      ignoreNonDeclaration: !1
    }).ignoreNonDeclaration ? ["VariableDeclarator"] : ["AssignmentExpression", "VariableDeclarator"];
    return {
      AssignmentExpression(s) {
        r.indexOf(s.parent.type) !== -1 && t.report({
          node: s,
          messageId: "unexpectedChain"
        });
      }
    };
  }
};
_f.meta;
_f.create;
var Bf = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow multiple spaces",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-multi-spaces"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "object",
          patternProperties: {
            "^([A-Z][a-z]*)+$": {
              type: "boolean"
            }
          },
          additionalProperties: !1
        },
        ignoreEOLComments: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      multipleSpaces: "Multiple spaces found before '{{displayValue}}'."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || {}, s = r.ignoreEOLComments, n = Object.assign({
      Property: !0
    }, r.exceptions), a = Object.keys(n).filter((l) => n[l]).length > 0;
    function o(l) {
      const i = l.value.split(`
`), u = i[0], c = `${u.slice(0, 12)}...`;
      return i.length === 1 && u.length <= 12 ? u : c;
    }
    return {
      Program() {
        e.tokensAndComments.forEach((l, i, u) => {
          if (i === u.length - 1)
            return;
          const c = u[i + 1];
          if (!e.text.slice(l.range[1], c.range[0]).includes("  ") || l.loc.end.line < c.loc.start.line || s && E.isCommentToken(c) && (i === u.length - 2 || c.loc.end.line < u[i + 2].loc.start.line))
            return;
          if (a) {
            const h = e.getNodeByRangeIndex(c.range[0] - 1);
            if (h && n[h.type])
              return;
          }
          let f;
          c.type === "Block" ? f = `/*${o(c)}*/` : c.type === "Line" ? f = `//${o(c)}` : f = c.value, t.report({
            node: c,
            loc: {
              start: l.loc.end,
              end: c.loc.start
            },
            messageId: "multipleSpaces",
            data: {
              displayValue: f
            },
            fix: (h) => h.replaceTextRange([l.range[1], c.range[0]], " ")
          });
        });
      }
    };
  }
};
Bf.meta;
Bf.create;
var Of = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiline strings",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-multi-str"
    },
    schema: [],
    messages: {
      multilineString: "Multiline support is limited to browsers supporting ES5 only."
    }
  },
  create(t) {
    function e(r) {
      return r.type.indexOf("JSX") === 0;
    }
    return {
      Literal(r) {
        E.LINEBREAK_MATCHER.test(r.raw) && !e(r.parent) && t.report({
          node: r,
          messageId: "multilineString"
        });
      }
    };
  }
};
Of.meta;
Of.create;
var Lf = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow multiple empty lines",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-multiple-empty-lines"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 0
        },
        maxEOF: {
          type: "integer",
          minimum: 0
        },
        maxBOF: {
          type: "integer",
          minimum: 0
        }
      },
      required: ["max"],
      additionalProperties: !1
    }],
    messages: {
      blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
      blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
      consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
    }
  },
  create(t) {
    let e = 2, r = e, s = e;
    t.options.length && (e = t.options[0].max, r = typeof t.options[0].maxEOF < "u" ? t.options[0].maxEOF : e, s = typeof t.options[0].maxBOF < "u" ? t.options[0].maxBOF : e);
    const n = t.getSourceCode(), a = n.lines[n.lines.length - 1] === "" ? n.lines.slice(0, -1) : n.lines, o = /* @__PURE__ */ new Set();
    return {
      TemplateLiteral(l) {
        l.quasis.forEach((i) => {
          for (let u = i.loc.start.line; u < i.loc.end.line; u++)
            o.add(u);
        });
      },
      "Program:exit"(l) {
        return a.reduce((i, u, c) => ((u.trim() || o.has(c + 1)) && i.push(c + 1), i), []).concat(a.length + 1).reduce((i, u) => {
          let c, f;
          return i === 0 ? (c = "blankBeginningOfFile", f = s) : u === a.length + 1 ? (c = "blankEndOfFile", f = r) : (c = "consecutiveBlank", f = e), u - i - 1 > f && t.report({
            node: l,
            loc: {
              start: {
                line: i + f + 1,
                column: 0
              },
              end: {
                line: u,
                column: 0
              }
            },
            messageId: c,
            data: {
              max: f,
              pluralizedLines: f === 1 ? "line" : "lines"
            },
            fix(h) {
              const p = n.getIndexFromLoc({
                line: i + 1,
                column: 0
              }), m = u - f, d = m <= a.length ? n.getIndexFromLoc({
                line: m,
                column: 0
              }) : n.text.length;
              return h.removeRange([p, d]);
            }
          }), u;
        }, 0);
      }
    };
  }
};
Lf.meta;
Lf.create;
var Rf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignments to native objects or read-only global variables",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-native-reassign"
    },
    deprecated: !0,
    replacedBy: ["no-global-assign"],
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      nativeReassign: "Read-only global '{{name}}' should not be modified."
    }
  },
  create(t) {
    const e = t.options[0], r = e && e.exceptions || [];
    function s(a, o, l) {
      const i = a.identifier;
      a.init === !1 && a.isWrite() && (o === 0 || l[o - 1].identifier !== i) && t.report({
        node: i,
        messageId: "nativeReassign",
        data: i
      });
    }
    function n(a) {
      a.writeable === !1 && r.indexOf(a.name) === -1 && a.references.forEach(s);
    }
    return {
      Program() {
        t.getScope().variables.forEach(n);
      }
    };
  }
};
Rf.meta;
Rf.create;
var Nf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow negated conditions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-negated-condition"
    },
    schema: [],
    messages: {
      unexpectedNegated: "Unexpected negated condition."
    }
  },
  create(t) {
    function e(a) {
      return a.alternate && a.alternate.type !== "IfStatement";
    }
    function r(a) {
      return a.type === "UnaryExpression" && a.operator === "!";
    }
    function s(a) {
      return a.type === "BinaryExpression" && (a.operator === "!=" || a.operator === "!==");
    }
    function n(a) {
      return r(a.test) || s(a.test);
    }
    return {
      IfStatement(a) {
        e(a) && n(a) && t.report({
          node: a,
          messageId: "unexpectedNegated"
        });
      },
      ConditionalExpression(a) {
        n(a) && t.report({
          node: a,
          messageId: "unexpectedNegated"
        });
      }
    };
  }
};
Nf.meta;
Nf.create;
var jf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow negating the left operand in `in` expressions",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-negated-in-lhs"
    },
    replacedBy: ["no-unsafe-negation"],
    deprecated: !0,
    schema: [],
    messages: {
      negatedLHS: "The 'in' expression's left operand is negated."
    }
  },
  create(t) {
    return {
      BinaryExpression(e) {
        e.operator === "in" && e.left.type === "UnaryExpression" && e.left.operator === "!" && t.report({
          node: e,
          messageId: "negatedLHS"
        });
      }
    };
  }
};
jf.meta;
jf.create;
var Mf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow nested ternary expressions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-nested-ternary"
    },
    schema: [],
    messages: {
      noNestedTernary: "Do not nest ternary expressions."
    }
  },
  create(t) {
    return {
      ConditionalExpression(e) {
        (e.alternate.type === "ConditionalExpression" || e.consequent.type === "ConditionalExpression") && t.report({
          node: e,
          messageId: "noNestedTernary"
        });
      }
    };
  }
};
Mf.meta;
Mf.create;
var $f = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with the `Function` object",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-new-func"
    },
    schema: [],
    messages: {
      noFunctionConstructor: "The Function constructor is eval."
    }
  },
  create(t) {
    return {
      "Program:exit"() {
        const r = t.getScope().set.get("Function");
        r && r.defs.length === 0 && r.references.forEach((s) => {
          const n = s.identifier, {
            parent: a
          } = n;
          a && (a.type === "NewExpression" || a.type === "CallExpression") && n === a.callee && t.report({
            node: a,
            messageId: "noFunctionConstructor"
          });
        });
      }
    };
  }
};
$f.meta;
$f.create;
var Vf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `Object` constructors",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-new-object"
    },
    schema: [],
    messages: {
      preferLiteral: "The object literal notation {} is preferrable."
    }
  },
  create(t) {
    return {
      NewExpression(e) {
        const r = E.getVariableByName(t.getScope(), e.callee.name);
        r && r.identifiers.length > 0 || e.callee.name === "Object" && t.report({
          node: e,
          messageId: "preferLiteral"
        });
      }
    };
  }
};
Vf.meta;
Vf.create;
var Uf = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with calls to `require`",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-new-require"
    },
    schema: [],
    messages: {
      noNewRequire: "Unexpected use of new with require."
    }
  },
  create(t) {
    return {
      NewExpression(e) {
        e.callee.type === "Identifier" && e.callee.name === "require" && t.report({
          node: e,
          messageId: "noNewRequire"
        });
      }
    };
  }
};
Uf.meta;
Uf.create;
var qf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `new` operators with the `Symbol` object",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-new-symbol"
    },
    schema: [],
    messages: {
      noNewSymbol: "`Symbol` cannot be called as a constructor."
    }
  },
  create(t) {
    return {
      "Program:exit"() {
        const r = t.getScope().set.get("Symbol");
        r && r.defs.length === 0 && r.references.forEach((s) => {
          const n = s.identifier, a = n.parent;
          a && a.type === "NewExpression" && a.callee === n && t.report({
            node: n,
            messageId: "noNewSymbol"
          });
        });
      }
    };
  }
};
qf.meta;
qf.create;
var Wf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-new-wrappers"
    },
    schema: [],
    messages: {
      noConstructor: "Do not use {{fn}} as a constructor."
    }
  },
  create(t) {
    return {
      NewExpression(e) {
        ["String", "Number", "Boolean"].indexOf(e.callee.name) > -1 && t.report({
          node: e,
          messageId: "noConstructor",
          data: {
            fn: e.callee.name
          }
        });
      }
    };
  }
};
Wf.meta;
Wf.create;
var zf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `new` operators outside of assignments or comparisons",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-new"
    },
    schema: [],
    messages: {
      noNewStatement: "Do not use 'new' for side effects."
    }
  },
  create(t) {
    return {
      "ExpressionStatement > NewExpression"(e) {
        t.report({
          node: e.parent,
          messageId: "noNewStatement"
        });
      }
    };
  }
};
zf.meta;
zf.create;
const q3 = /\\[89]/u;
function Wy(t) {
  return `\\u${t.charCodeAt(0).toString(16).padStart(4, "0")}`;
}
var Gf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `\\8` and `\\9` escape sequences in string literals",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-nonoctal-decimal-escape",
      suggestion: !0
    },
    schema: [],
    messages: {
      decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.",
      refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",
      escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s, n, a) {
      return {
        messageId: s,
        data: {
          original: e.getText().slice(...n),
          replacement: a
        },
        fix(o) {
          return o.replaceTextRange(n, a);
        }
      };
    }
    return {
      Literal(s) {
        if (typeof s.value != "string" || !q3.test(s.raw))
          return;
        let n;
        for (; n = /(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy.exec(s.raw); ) {
          const {
            previousEscape: a,
            decimalEscape: o
          } = n.groups, l = s.range[0] + n.index + n[0].length, i = l - o.length, u = [i, l], c = [];
          a === "\\0" ? c.push(r("refactor", [i - a.length, l], `${Wy("\0")}${o[1]}`), r("refactor", u, Wy(o[1]))) : c.push(r("refactor", u, o[1])), c.push(r("escapeBackslash", u, `\\${o}`)), t.report({
            node: s,
            loc: {
              start: e.getLocFromIndex(i),
              end: e.getLocFromIndex(l)
            },
            messageId: "decimalEscape",
            data: {
              decimalEscape: o
            },
            suggest: c
          });
        }
      }
    };
  }
};
Gf.meta;
Gf.create;
const {
  CALL: W3,
  CONSTRUCT: z3,
  ReferenceTracker: G3
} = Vt.default, H3 = E.getStaticPropertyName, K3 = ["Atomics", "JSON", "Math", "Reflect"];
function wb(t) {
  return t.type === "ChainExpression" ? wb(t.expression) : t.type === "MemberExpression" ? H3(t) : t.name;
}
var Hf = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow calling global object properties as functions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-obj-calls"
    },
    schema: [],
    messages: {
      unexpectedCall: "'{{name}}' is not a function.",
      unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function."
    }
  },
  create(t) {
    return {
      Program() {
        const e = t.getScope(), r = new G3(e), s = {};
        for (const n of K3)
          s[n] = {
            [W3]: !0,
            [z3]: !0
          };
        for (const {
          node: n,
          path: a
        } of r.iterateGlobalReferences(s)) {
          const o = wb(n.callee), l = a[0], i = o === l ? "unexpectedCall" : "unexpectedRefCall";
          t.report({
            node: n,
            messageId: i,
            data: {
              name: o,
              ref: l
            }
          });
        }
      }
    };
  }
};
Hf.meta;
Hf.create;
var Kf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow octal escape sequences in string literals",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-octal-escape"
    },
    schema: [],
    messages: {
      octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."
    }
  },
  create(t) {
    return {
      Literal(e) {
        if (typeof e.value != "string")
          return;
        const r = e.raw.match(/^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su);
        r && t.report({
          node: e,
          messageId: "octalEscapeSequence",
          data: {
            sequence: r[1]
          }
        });
      }
    };
  }
};
Kf.meta;
Kf.create;
var Jf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow octal literals",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-octal"
    },
    schema: [],
    messages: {
      noOcatal: "Octal literals should not be used."
    }
  },
  create(t) {
    return {
      Literal(e) {
        typeof e.value == "number" && /^0[0-9]/u.test(e.raw) && t.report({
          node: e,
          messageId: "noOcatal"
        });
      }
    };
  }
};
Jf.meta;
Jf.create;
const J3 = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
var Xf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow reassigning `function` parameters",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-param-reassign"
    },
    schema: [{
      oneOf: [{
        type: "object",
        properties: {
          props: {
            enum: [!1]
          }
        },
        additionalProperties: !1
      }, {
        type: "object",
        properties: {
          props: {
            enum: [!0]
          },
          ignorePropertyModificationsFor: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: !0
          },
          ignorePropertyModificationsForRegex: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: !0
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.",
      assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'."
    }
  },
  create(t) {
    const e = t.options[0] && t.options[0].props, r = t.options[0] && t.options[0].ignorePropertyModificationsFor || [], s = t.options[0] && t.options[0].ignorePropertyModificationsForRegex || [];
    function n(u) {
      let c = u.identifier, f = c.parent;
      for (; f && (!J3.test(f.type) || f.type === "ForInStatement" || f.type === "ForOfStatement"); ) {
        switch (f.type) {
          case "AssignmentExpression":
            return f.left === c;
          case "UpdateExpression":
            return !0;
          case "UnaryExpression":
            if (f.operator === "delete")
              return !0;
            break;
          case "ForInStatement":
          case "ForOfStatement":
            return f.left === c;
          case "CallExpression":
            if (f.callee !== c)
              return !1;
            break;
          case "MemberExpression":
            if (f.property === c)
              return !1;
            break;
          case "Property":
            if (f.key === c)
              return !1;
            break;
          case "ConditionalExpression":
            if (f.test === c)
              return !1;
            break;
        }
        c = f, f = c.parent;
      }
      return !1;
    }
    function a(u) {
      return r.includes(u) || s.some((c) => new RegExp(c, "u").test(u));
    }
    function o(u, c, f) {
      const h = u.identifier;
      h && !u.init && (c === 0 || f[c - 1].identifier !== h) && (u.isWrite() ? t.report({
        node: h,
        messageId: "assignmentToFunctionParam",
        data: {
          name: h.name
        }
      }) : e && n(u) && !a(h.name) && t.report({
        node: h,
        messageId: "assignmentToFunctionParamProp",
        data: {
          name: h.name
        }
      }));
    }
    function l(u) {
      u.defs[0].type === "Parameter" && u.references.forEach(o);
    }
    function i(u) {
      t.getDeclaredVariables(u).forEach(l);
    }
    return {
      "FunctionDeclaration:exit": i,
      "FunctionExpression:exit": i,
      "ArrowFunctionExpression:exit": i
    };
  }
};
Xf.meta;
Xf.create;
var Qf = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow string concatenation with `__dirname` and `__filename`",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-path-concat"
    },
    schema: [],
    messages: {
      usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths."
    }
  },
  create(t) {
    const e = /^__(?:dir|file)name$/u;
    return {
      BinaryExpression(r) {
        const s = r.left, n = r.right;
        r.operator === "+" && (s.type === "Identifier" && e.test(s.name) || n.type === "Identifier" && e.test(n.name)) && t.report({
          node: r,
          messageId: "usePathFunctions"
        });
      }
    };
  }
};
Qf.meta;
Qf.create;
function X3(t) {
  const e = t.parent;
  return e.type === "ForStatement" && e.update === t;
}
function kb(t) {
  const e = t.parent;
  return e.type === "SequenceExpression" ? kb(e) : X3(t);
}
var Yf = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the unary operators `++` and `--`",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-plusplus"
    },
    schema: [{
      type: "object",
      properties: {
        allowForLoopAfterthoughts: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedUnaryOp: "Unary operator '{{operator}}' used."
    }
  },
  create(t) {
    const e = t.options[0];
    let r = !1;
    return typeof e == "object" && (r = e.allowForLoopAfterthoughts === !0), {
      UpdateExpression(s) {
        r && kb(s) || t.report({
          node: s,
          messageId: "unexpectedUnaryOp",
          data: {
            operator: s.operator
          }
        });
      }
    };
  }
};
Yf.meta;
Yf.create;
var Zf = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow the use of `process.env`",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-process-env"
    },
    schema: [],
    messages: {
      unexpectedProcessEnv: "Unexpected use of process.env."
    }
  },
  create(t) {
    return {
      MemberExpression(e) {
        const r = e.object.name, s = e.property.name;
        r === "process" && !e.computed && s && s === "env" && t.report({
          node: e,
          messageId: "unexpectedProcessEnv"
        });
      }
    };
  }
};
Zf.meta;
Zf.create;
var eh = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow the use of `process.exit()`",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-process-exit"
    },
    schema: [],
    messages: {
      noProcessExit: "Don't use process.exit(); throw an error instead."
    }
  },
  create(t) {
    return {
      "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(e) {
        t.report({
          node: e.parent,
          messageId: "noProcessExit"
        });
      }
    };
  }
};
eh.meta;
eh.create;
const {
  findVariable: Q3
} = Vt.default, Y3 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "FunctionExpression"]);
function Z3(t, e) {
  const r = Q3(e, t);
  return r !== null && r.scope.type === "global" && r.defs.length === 0;
}
function ej(t) {
  const e = t.upper;
  return e.type === "function-expression-name" ? e.upper : e;
}
function tj(t, e) {
  const r = t.parent;
  return r.type === "NewExpression" && r.arguments[0] === t && r.callee.type === "Identifier" && r.callee.name === "Promise" && Z3(r.callee, ej(e));
}
var th = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow returning values from Promise executor functions",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-promise-executor-return"
    },
    schema: [],
    messages: {
      returnsValue: "Return values from promise executor functions cannot be read."
    }
  },
  create(t) {
    let e = null;
    function r(s) {
      t.report({
        node: s,
        messageId: "returnsValue"
      });
    }
    return {
      onCodePathStart(s, n) {
        e = {
          upper: e,
          shouldCheck: Y3.has(n.type) && tj(n, t.getScope())
        }, e.shouldCheck && n.type === "ArrowFunctionExpression" && n.expression && r(n.body);
      },
      onCodePathEnd() {
        e = e.upper;
      },
      ReturnStatement(s) {
        e.shouldCheck && s.argument && r(s);
      }
    };
  }
};
th.meta;
th.create;
const {
  getStaticPropertyName: rj
} = E;
var rh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of the `__proto__` property",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-proto"
    },
    schema: [],
    messages: {
      unexpectedProto: "The '__proto__' property is deprecated."
    }
  },
  create(t) {
    return {
      MemberExpression(e) {
        rj(e) === "__proto__" && t.report({
          node: e,
          messageId: "unexpectedProto"
        });
      }
    };
  }
};
rh.meta;
rh.create;
var nh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow calling some `Object.prototype` methods directly on objects",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-prototype-builtins"
    },
    schema: [],
    messages: {
      prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object."
    }
  },
  create(t) {
    const e = ["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"];
    return {
      CallExpression: function(r) {
        const s = E.skipChainExpression(r.callee);
        if (s.type !== "MemberExpression")
          return;
        const n = E.getStaticPropertyName(s);
        n !== null && e.indexOf(n) > -1 && t.report({
          messageId: "prototypeBuildIn",
          loc: s.property.loc,
          data: {
            prop: n
          },
          node: r
        });
      }
    };
  }
};
nh.meta;
nh.create;
var sh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable redeclaration",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-redeclare"
    },
    messages: {
      redeclared: "'{{id}}' is already defined.",
      redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
      redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }]
  },
  create(t) {
    const e = {
      builtinGlobals: !!(t.options.length === 0 || t.options[0].builtinGlobals)
    }, r = t.getSourceCode();
    function* s(o) {
      e.builtinGlobals && (o.eslintImplicitGlobalSetting === "readonly" || o.eslintImplicitGlobalSetting === "writable") && (yield {
        type: "builtin"
      });
      for (const l of o.identifiers)
        yield {
          type: "syntax",
          node: l,
          loc: l.loc
        };
      if (o.eslintExplicitGlobalComments)
        for (const l of o.eslintExplicitGlobalComments)
          yield {
            type: "comment",
            node: l,
            loc: E.getNameLocationInGlobalDirectiveComment(r, l, o.name)
          };
    }
    function n(o) {
      for (const l of o.variables) {
        const [i, ...u] = s(l);
        if (u.length === 0)
          continue;
        const c = i.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax", f = {
          id: l.name
        };
        for (const {
          type: h,
          node: p,
          loc: m
        } of u) {
          const d = h === i.type ? "redeclared" : c;
          t.report({
            node: p,
            loc: m,
            messageId: d,
            data: f
          });
        }
      }
    }
    function a(o) {
      const l = t.getScope();
      l.block === o && n(l);
    }
    return {
      Program() {
        const o = t.getScope();
        n(o), o.type === "global" && o.childScopes[0] && o.block === o.childScopes[0].block && n(o.childScopes[0]);
      },
      FunctionDeclaration: a,
      FunctionExpression: a,
      ArrowFunctionExpression: a,
      BlockStatement: a,
      ForStatement: a,
      ForInStatement: a,
      ForOfStatement: a,
      SwitchStatement: a
    };
  }
};
sh.meta;
sh.create;
const nj = new pn.default.RegExpParser(), sj = / {2}/u;
function zy(t) {
  return t && t.type === "Literal" && typeof t.value == "string";
}
var ah = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow multiple spaces in regular expressions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-regex-spaces"
    },
    schema: [],
    fixable: "code",
    messages: {
      multipleSpaces: "Spaces are hard to count. Use {{{length}}}."
    }
  },
  create(t) {
    function e(s, n, a, o, l) {
      if (!sj.test(a))
        return;
      const i = [];
      let u;
      try {
        u = nj.parsePattern(n, 0, n.length, l.includes("u"));
      } catch {
        return;
      }
      pn.default.visitRegExpAST(u, {
        onCharacterClassEnter(f) {
          i.push(f);
        }
      });
      let c;
      for (; c = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu.exec(n); ) {
        const {
          1: {
            length: f
          },
          index: h
        } = c;
        if (i.every(({
          start: p,
          end: m
        }) => h < p || m <= h)) {
          t.report({
            node: s,
            messageId: "multipleSpaces",
            data: {
              length: f
            },
            fix(p) {
              return n !== a ? null : p.replaceTextRange([o + h, o + h + f], ` {${f}}`);
            }
          });
          return;
        }
      }
    }
    function r(s) {
      const n = t.getScope(), a = E.getVariableByName(n, "RegExp"), o = a && a.defs.length > 0, l = s.arguments[0], i = s.arguments[1];
      if (s.callee.type === "Identifier" && s.callee.name === "RegExp" && zy(l) && !o) {
        const u = l.value, c = l.raw.slice(1, -1), f = l.range[0] + 1, h = zy(i) ? i.value : "";
        e(s, u, c, f, h);
      }
    }
    return {
      Literal: function(s) {
        if (s.regex) {
          const n = s.regex.pattern, a = s.raw.slice(1, s.raw.lastIndexOf("/")), o = s.range[0] + 1, l = s.regex.flags;
          e(s, n, a, o, l);
        }
      },
      CallExpression: r,
      NewExpression: r
    };
  }
};
ah.meta;
ah.create;
var ih = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified names in exports",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-restricted-exports"
    },
    schema: [{
      type: "object",
      properties: {
        restrictedNamedExports: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      restrictedNamed: "'{{name}}' is restricted from being used as an exported name."
    }
  },
  create(t) {
    const e = new Set(t.options[0] && t.options[0].restrictedNamedExports);
    function r(s) {
      const n = s.name;
      e.has(n) && t.report({
        node: s,
        messageId: "restrictedNamed",
        data: {
          name: n
        }
      });
    }
    return {
      ExportAllDeclaration(s) {
        s.exported && r(s.exported);
      },
      ExportNamedDeclaration(s) {
        const n = s.declaration;
        n ? n.type === "FunctionDeclaration" || n.type === "ClassDeclaration" ? r(n.id) : n.type === "VariableDeclaration" && t.getDeclaredVariables(n).map((a) => a.defs.find((o) => o.parent === n)).map((a) => a.name).forEach(r) : s.specifiers.map((a) => a.exported).forEach(r);
      }
    };
  }
};
ih.meta;
ih.create;
var oh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified global variables",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-restricted-globals"
    },
    schema: {
      type: "array",
      items: {
        oneOf: [{
          type: "string"
        }, {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          required: ["name"],
          additionalProperties: !1
        }]
      },
      uniqueItems: !0,
      minItems: 0
    },
    messages: {
      defaultMessage: "Unexpected use of '{{name}}'.",
      customMessage: "Unexpected use of '{{name}}'. {{customMessage}}"
    }
  },
  create(t) {
    if (t.options.length === 0)
      return {};
    const e = t.options.reduce((n, a) => (typeof a == "string" ? n[a] = null : n[a.name] = a.message, n), {});
    function r(n) {
      const a = n.identifier.name, o = e[a], l = o ? "customMessage" : "defaultMessage";
      t.report({
        node: n.identifier,
        messageId: l,
        data: {
          name: a,
          customMessage: o
        }
      });
    }
    function s(n) {
      return Object.prototype.hasOwnProperty.call(e, n);
    }
    return {
      Program() {
        const n = t.getScope();
        n.variables.forEach((a) => {
          !a.defs.length && s(a.name) && a.references.forEach(r);
        }), n.through.forEach((a) => {
          s(a.identifier.name) && r(a);
        });
      }
    };
  }
};
oh.meta;
oh.create;
const Gy = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        },
        importNames: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: !1,
      required: ["name"]
    }]
  },
  uniqueItems: !0
}, aj = {
  anyOf: [{
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0
  }, {
    type: "array",
    items: {
      type: "object",
      properties: {
        group: {
          type: "array",
          items: {
            type: "string"
          },
          minItems: 1,
          uniqueItems: !0
        },
        message: {
          type: "string",
          minLength: 1
        }
      },
      additionalProperties: !1,
      required: ["group"]
    },
    uniqueItems: !0
  }]
};
var lh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `import`",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-restricted-imports"
    },
    messages: {
      path: "'{{importSource}}' import is restricted from being used.",
      pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}",
      patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
      patternWithCustomMessage: "'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}",
      everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
      everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}",
      importName: "'{{importName}}' import from '{{importSource}}' is restricted.",
      importNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"
    },
    schema: {
      anyOf: [Gy, {
        type: "array",
        items: [{
          type: "object",
          properties: {
            paths: Gy,
            patterns: aj
          },
          additionalProperties: !1
        }],
        additionalItems: !1
      }]
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = Array.isArray(t.options) ? t.options : [], s = typeof r[0] == "object" && (Object.prototype.hasOwnProperty.call(r[0], "paths") || Object.prototype.hasOwnProperty.call(r[0], "patterns")), n = (s ? r[0].paths : t.options) || [], a = n.reduce((h, p) => (typeof p == "string" ? h[p] = {
      message: null
    } : h[p.name] = {
      message: p.message,
      importNames: p.importNames
    }, h), {}), o = (s ? r[0].patterns : []) || [], l = o.length > 0 && typeof o[0] == "string" ? [{
      matcher: _l.default().add(o)
    }] : o.map(({
      group: h,
      message: p
    }) => ({
      matcher: _l.default().add(h),
      customMessage: p
    }));
    if (Object.keys(n).length === 0 && l.length === 0)
      return {};
    function i(h, p, m) {
      if (!Object.prototype.hasOwnProperty.call(a, h))
        return;
      const d = a[h].message, g = a[h].importNames;
      if (g) {
        if (p.has("*")) {
          const y = p.get("*")[0];
          t.report({
            node: m,
            messageId: d ? "everythingWithCustomMessage" : "everything",
            loc: y.loc,
            data: {
              importSource: h,
              importNames: g,
              customMessage: d
            }
          });
        }
        g.forEach((y) => {
          p.has(y) && p.get(y).forEach((A) => {
            t.report({
              node: m,
              messageId: d ? "importNameWithCustomMessage" : "importName",
              loc: A.loc,
              data: {
                importSource: h,
                customMessage: d,
                importName: y
              }
            });
          });
        });
      } else
        t.report({
          node: m,
          messageId: d ? "pathWithCustomMessage" : "path",
          data: {
            importSource: h,
            customMessage: d
          }
        });
    }
    function u(h, p) {
      const m = h.source.value.trim();
      t.report({
        node: h,
        messageId: p.customMessage ? "patternWithCustomMessage" : "patterns",
        data: {
          importSource: m,
          customMessage: p.customMessage
        }
      });
    }
    function c(h, p) {
      return p.matcher.ignores(h);
    }
    function f(h) {
      const p = h.source.value.trim(), m = /* @__PURE__ */ new Map();
      if (h.type === "ExportAllDeclaration") {
        const d = e.getFirstToken(h, 1);
        m.set("*", [{
          loc: d.loc
        }]);
      } else if (h.specifiers)
        for (const d of h.specifiers) {
          let g;
          const y = {
            loc: d.loc
          };
          d.type === "ImportDefaultSpecifier" ? g = "default" : d.type === "ImportNamespaceSpecifier" ? g = "*" : d.imported ? g = d.imported.name : d.local && (g = d.local.name), g && (m.has(g) ? m.get(g).push(y) : m.set(g, [y]));
        }
      i(p, m, h), l.forEach((d) => {
        c(p, d) && u(h, d);
      });
    }
    return {
      ImportDeclaration: f,
      ExportNamedDeclaration(h) {
        h.source && f(h);
      },
      ExportAllDeclaration: f
    };
  }
};
lh.meta;
lh.create;
const ij = {
  type: "array",
  items: {
    type: "string"
  },
  uniqueItems: !0
}, Hy = {
  type: "array",
  items: {
    anyOf: [{
      type: "string"
    }, {
      type: "object",
      properties: {
        name: {
          type: "string"
        },
        message: {
          type: "string",
          minLength: 1
        }
      },
      additionalProperties: !1,
      required: ["name"]
    }]
  },
  uniqueItems: !0
};
var uh = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow specified modules when loaded by `require`",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-restricted-modules"
    },
    schema: {
      anyOf: [Hy, {
        type: "array",
        items: {
          type: "object",
          properties: {
            paths: Hy,
            patterns: ij
          },
          additionalProperties: !1
        },
        additionalItems: !1
      }]
    },
    messages: {
      defaultMessage: "'{{name}}' module is restricted from being used.",
      customMessage: "'{{name}}' module is restricted from being used. {{customMessage}}",
      patternMessage: "'{{name}}' module is restricted from being used by a pattern."
    }
  },
  create(t) {
    const e = Array.isArray(t.options) ? t.options : [], r = typeof e[0] == "object" && (Object.prototype.hasOwnProperty.call(e[0], "paths") || Object.prototype.hasOwnProperty.call(e[0], "patterns")), s = (r ? e[0].paths : t.options) || [], n = (r ? e[0].patterns : []) || [], a = s.reduce((p, m) => (typeof m == "string" ? p[m] = null : p[m.name] = m.message, p), {});
    if (Object.keys(s).length === 0 && n.length === 0)
      return {};
    const o = _l.default().add(n);
    function l(p) {
      return p && p.type === "Literal" && typeof p.value == "string";
    }
    function i(p) {
      return p && p.type === "TemplateLiteral" && p.expressions.length === 0;
    }
    function u(p) {
      return p.callee.type === "Identifier" && p.callee.name === "require";
    }
    function c(p) {
      return l(p) ? p.value.trim() : i(p) ? p.quasis[0].value.cooked.trim() : null;
    }
    function f(p, m) {
      const d = a[m], g = d ? "customMessage" : "defaultMessage";
      t.report({
        node: p,
        messageId: g,
        data: {
          name: m,
          customMessage: d
        }
      });
    }
    function h(p) {
      return Object.prototype.hasOwnProperty.call(a, p);
    }
    return {
      CallExpression(p) {
        if (u(p) && p.arguments.length) {
          const m = c(p.arguments[0]);
          m && (h(m) && f(p, m), n.length > 0 && o.ignores(m) && t.report({
            node: p,
            messageId: "patternMessage",
            data: {
              name: m
            }
          }));
        }
      }
    };
  }
};
uh.meta;
uh.create;
var ch = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow certain properties on certain objects",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-restricted-properties"
    },
    schema: {
      type: "array",
      items: {
        anyOf: [{
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: !1,
          required: ["object"]
        }, {
          type: "object",
          properties: {
            object: {
              type: "string"
            },
            property: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          additionalProperties: !1,
          required: ["property"]
        }]
      },
      uniqueItems: !0
    },
    messages: {
      restrictedObjectProperty: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
      restrictedProperty: "'{{propertyName}}' is restricted from being used.{{message}}"
    }
  },
  create(t) {
    const e = t.options;
    if (e.length === 0)
      return {};
    const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
    e.forEach((l) => {
      const i = l.object, u = l.property;
      typeof i > "u" ? n.set(u, {
        message: l.message
      }) : typeof u > "u" ? s.set(i, {
        message: l.message
      }) : (r.has(i) || r.set(i, /* @__PURE__ */ new Map()), r.get(i).set(u, {
        message: l.message
      }));
    });
    function a(l, i, u) {
      if (u === null)
        return;
      const c = r.get(i), f = c ? c.get(u) : s.get(i), h = n.get(u);
      if (f) {
        const p = f.message ? ` ${f.message}` : "";
        t.report({
          node: l,
          messageId: "restrictedObjectProperty",
          data: {
            objectName: i,
            propertyName: u,
            message: p
          }
        });
      } else if (h) {
        const p = h.message ? ` ${h.message}` : "";
        t.report({
          node: l,
          messageId: "restrictedProperty",
          data: {
            propertyName: u,
            message: p
          }
        });
      }
    }
    function o(l) {
      if (l.right.type === "Identifier") {
        const i = l.right.name;
        l.left.type === "ObjectPattern" && l.left.properties.forEach((u) => {
          a(l.left, i, E.getStaticPropertyName(u));
        });
      }
    }
    return {
      MemberExpression(l) {
        a(l, l.object && l.object.name, E.getStaticPropertyName(l));
      },
      VariableDeclarator(l) {
        if (l.init && l.init.type === "Identifier") {
          const i = l.init.name;
          l.id.type === "ObjectPattern" && l.id.properties.forEach((u) => {
            a(l.id, i, E.getStaticPropertyName(u));
          });
        }
      },
      AssignmentExpression: o,
      AssignmentPattern: o
    };
  }
};
ch.meta;
ch.create;
var ph = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified syntax",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-restricted-syntax"
    },
    schema: {
      type: "array",
      items: {
        oneOf: [{
          type: "string"
        }, {
          type: "object",
          properties: {
            selector: {
              type: "string"
            },
            message: {
              type: "string"
            }
          },
          required: ["selector"],
          additionalProperties: !1
        }]
      },
      uniqueItems: !0,
      minItems: 0
    },
    messages: {
      restrictedSyntax: "{{message}}"
    }
  },
  create(t) {
    return t.options.reduce((e, r) => {
      const s = typeof r == "string", n = !s && !!r.message, a = s ? r : r.selector, o = n ? r.message : `Using '${a}' is not allowed.`;
      return Object.assign(e, {
        [a](l) {
          t.report({
            node: l,
            messageId: "restrictedSyntax",
            data: {
              message: o
            }
          });
        }
      });
    }, {});
  }
};
ph.meta;
ph.create;
const oj = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;
var fh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow assignment operators in `return` statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-return-assign"
    },
    schema: [{
      enum: ["except-parens", "always"]
    }],
    messages: {
      returnAssignment: "Return statement should not contain assignment.",
      arrowAssignment: "Arrow function should not return assignment."
    }
  },
  create(t) {
    const e = (t.options[0] || "except-parens") !== "except-parens", r = t.getSourceCode();
    return {
      AssignmentExpression(s) {
        if (!e && E.isParenthesised(r, s))
          return;
        let n = s, a = n.parent;
        for (; a && !oj.test(a.type); )
          n = a, a = a.parent;
        a && a.type === "ReturnStatement" ? t.report({
          node: a,
          messageId: "returnAssignment"
        }) : a && a.type === "ArrowFunctionExpression" && a.body === n && t.report({
          node: a,
          messageId: "arrowAssignment"
        });
      }
    };
  }
};
fh.meta;
fh.create;
var hh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary `return await`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-return-await"
    },
    fixable: null,
    schema: [],
    messages: {
      redundantUseOfAwait: "Redundant use of `await` on a return value."
    }
  },
  create(t) {
    function e(n) {
      t.report({
        node: t.getSourceCode().getFirstToken(n),
        loc: n.loc,
        messageId: "redundantUseOfAwait"
      });
    }
    function r(n) {
      let a = n;
      for (; !E.isFunction(a) && a.type !== "Program"; ) {
        if (a.parent.type === "TryStatement" && (a === a.parent.block || a === a.parent.handler && a.parent.finalizer))
          return !0;
        a = a.parent;
      }
      return !1;
    }
    function s(n) {
      return n.parent.type === "ArrowFunctionExpression" ? !0 : n.parent.type === "ReturnStatement" ? !r(n.parent) : n.parent.type === "ConditionalExpression" && (n === n.parent.consequent || n === n.parent.alternate) || n.parent.type === "LogicalExpression" && n === n.parent.right || n.parent.type === "SequenceExpression" && n === n.parent.expressions[n.parent.expressions.length - 1] ? s(n.parent) : !1;
    }
    return {
      AwaitExpression(n) {
        s(n) && !r(n) && e(n);
      }
    };
  }
};
hh.meta;
hh.create;
var mh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `javascript:` urls",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-script-url"
    },
    schema: [],
    messages: {
      unexpectedScriptURL: "Script URL is a form of eval."
    }
  },
  create(t) {
    function e(r) {
      const s = E.getStaticStringValue(r);
      typeof s == "string" && s.toLowerCase().indexOf("javascript:") === 0 && t.report({
        node: r,
        messageId: "unexpectedScriptURL"
      });
    }
    return {
      Literal(r) {
        r.value && typeof r.value == "string" && e(r);
      },
      TemplateLiteral(r) {
        r.parent && r.parent.type === "TaggedTemplateExpression" || e(r);
      }
    };
  }
};
mh.meta;
mh.create;
const lj = /\s+/gu;
function ks(t, e, r, s) {
  if (!(!t || !e))
    if (t.type === "Identifier" && e.type === "Identifier" && t.name === e.name)
      s(e);
    else if (t.type === "ArrayPattern" && e.type === "ArrayExpression") {
      const n = Math.min(t.elements.length, e.elements.length);
      for (let a = 0; a < n; ++a) {
        const o = t.elements[a], l = e.elements[a];
        if (o && o.type === "RestElement" && a < e.elements.length - 1 || (ks(o, l, r, s), l && l.type === "SpreadElement"))
          break;
      }
    } else if (t.type === "RestElement" && e.type === "SpreadElement")
      ks(t.argument, e.argument, r, s);
    else if (t.type === "ObjectPattern" && e.type === "ObjectExpression" && e.properties.length >= 1) {
      let n = 0;
      for (let a = e.properties.length - 1; a >= 0; --a) {
        const o = e.properties[a].type;
        if (o === "SpreadElement" || o === "ExperimentalSpreadProperty") {
          n = a + 1;
          break;
        }
      }
      for (let a = 0; a < t.properties.length; ++a)
        for (let o = n; o < e.properties.length; ++o)
          ks(t.properties[a], e.properties[o], r, s);
    } else if (t.type === "Property" && e.type === "Property" && e.kind === "init" && !e.method) {
      const n = E.getStaticPropertyName(t);
      n !== null && n === E.getStaticPropertyName(e) && ks(t.value, e.value, r, s);
    } else
      r && E.skipChainExpression(t).type === "MemberExpression" && E.skipChainExpression(e).type === "MemberExpression" && E.isSameReference(t, e) && s(e);
}
var dh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments where both sides are exactly the same",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-self-assign"
    },
    schema: [{
      type: "object",
      properties: {
        props: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      selfAssignment: "'{{name}}' is assigned to itself."
    }
  },
  create(t) {
    const e = t.getSourceCode(), [{
      props: r = !0
    } = {}] = t.options;
    function s(n) {
      t.report({
        node: n,
        messageId: "selfAssignment",
        data: {
          name: e.getText(n).replace(lj, "")
        }
      });
    }
    return {
      AssignmentExpression(n) {
        n.operator === "=" && ks(n.left, n.right, r, s);
      }
    };
  }
};
dh.meta;
dh.create;
var gh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow comparisons where both sides are exactly the same",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-self-compare"
    },
    schema: [],
    messages: {
      comparingToSelf: "Comparing to itself is potentially pointless."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s, n) {
      const a = e.getTokens(s), o = e.getTokens(n);
      return a.length === o.length && a.every((l, i) => l.type === o[i].type && l.value === o[i].value);
    }
    return {
      BinaryExpression(s) {
        (/* @__PURE__ */ new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="])).has(s.operator) && r(s.left, s.right) && t.report({
          node: s,
          messageId: "comparingToSelf"
        });
      }
    };
  }
};
gh.meta;
gh.create;
const uj = {
  allowInParentheses: !0
};
var yh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow comma operators",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-sequences"
    },
    schema: [{
      properties: {
        allowInParentheses: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedCommaExpression: "Unexpected use of comma operator."
    }
  },
  create(t) {
    const e = Object.assign({}, uj, t.options[0]), r = t.getSourceCode(), s = {
      DoWhileStatement: "test",
      IfStatement: "test",
      SwitchStatement: "discriminant",
      WhileStatement: "test",
      WithStatement: "object",
      ArrowFunctionExpression: "body"
    };
    function n(l) {
      return l.parent && s[l.parent.type] && l === l.parent[s[l.parent.type]];
    }
    function a(l) {
      return E.isParenthesised(r, l);
    }
    function o(l) {
      const i = r.getTokenBefore(l, 1), u = r.getTokenAfter(l, 1);
      return a(l) && i && u && E.isOpeningParenToken(i) && i.range[1] <= l.range[0] && E.isClosingParenToken(u) && u.range[0] >= l.range[1];
    }
    return {
      SequenceExpression(l) {
        if (l.parent.type === "ForStatement" && (l === l.parent.init || l === l.parent.update))
          return;
        if (e.allowInParentheses) {
          if (n(l)) {
            if (o(l))
              return;
          } else if (a(l))
            return;
        }
        const i = r.getTokenAfter(l.expressions[0], E.isCommaToken);
        t.report({
          node: l,
          loc: i.loc,
          messageId: "unexpectedCommaExpression"
        });
      }
    };
  }
};
yh.meta;
yh.create;
const {
  findVariable: cj
} = Vt.default;
function pj(t, e) {
  const r = cj(e, t);
  return r !== null && r.scope.type === "global" && r.defs.length === 0;
}
function Sa(t, e, r, s, n) {
  const a = t.parent;
  return a.type === "CallExpression" && a.arguments[n] === t && E.isSpecificMemberAccess(a.callee, r, s) && pj(E.skipChainExpression(a.callee).object, e);
}
function fj(t, e) {
  if (Sa(t, e, "Object", "defineProperty", 2) || Sa(t, e, "Reflect", "defineProperty", 2))
    return !0;
  const r = t.parent;
  if (r.type === "Property" && r.value === t) {
    const s = r.parent;
    if (s.type === "ObjectExpression" && (Sa(s, e, "Object", "create", 1) || Sa(s, e, "Object", "defineProperties", 1)))
      return !0;
  }
  return !1;
}
function hj(t, e) {
  const r = t.parent;
  return !!(r.kind === "set" && r.value === t || r.type === "Property" && r.value === t && E.getStaticPropertyName(r) === "set" && r.parent.type === "ObjectExpression" && fj(r.parent, e));
}
function mj(t) {
  const e = t.upper;
  return e.type === "function-expression-name" ? e.upper : e;
}
var xh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow returning values from setters",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-setter-return"
    },
    schema: [],
    messages: {
      returnsValue: "Setter cannot return a value."
    }
  },
  create(t) {
    let e = null;
    function r(a) {
      const o = mj(t.getScope());
      e = {
        upper: e,
        isSetter: hj(a, o)
      };
    }
    function s() {
      e = e.upper;
    }
    function n(a) {
      t.report({
        node: a,
        messageId: "returnsValue"
      });
    }
    return {
      FunctionDeclaration: r,
      FunctionExpression: r,
      ArrowFunctionExpression(a) {
        r(a), e.isSetter && a.expression && n(a.body);
      },
      "FunctionDeclaration:exit": s,
      "FunctionExpression:exit": s,
      "ArrowFunctionExpression:exit": s,
      ReturnStatement(a) {
        e && e.isSetter && a.argument && n(a);
      }
    };
  }
};
xh.meta;
xh.create;
function dj(t) {
  return t.name === "undefined" && t.references.every((e) => !e.isWrite()) && t.defs.every((e) => e.node.type === "VariableDeclarator" && e.node.init === null);
}
var vh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow identifiers from shadowing restricted names",
      category: "Variables",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-shadow-restricted-names"
    },
    schema: [],
    messages: {
      shadowingRestrictedName: "Shadowing of global property '{{name}}'."
    }
  },
  create(t) {
    const e = /* @__PURE__ */ new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]);
    return {
      "VariableDeclaration, :function, CatchClause"(r) {
        for (const s of t.getDeclaredVariables(r))
          s.defs.length > 0 && e.has(s.name) && !dj(s) && t.report({
            node: s.defs[0].name,
            messageId: "shadowingRestrictedName",
            data: {
              name: s.name
            }
          });
      }
    };
  }
};
vh.meta;
vh.create;
var Eh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow variable declarations from shadowing variables declared in the outer scope",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-shadow"
    },
    schema: [{
      type: "object",
      properties: {
        builtinGlobals: {
          type: "boolean",
          default: !1
        },
        hoist: {
          enum: ["all", "functions", "never"],
          default: "functions"
        },
        allow: {
          type: "array",
          items: {
            type: "string"
          }
        }
      },
      additionalProperties: !1
    }],
    messages: {
      noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
      noShadowGlobal: "'{{name}}' is already a global variable."
    }
  },
  create(t) {
    const e = {
      builtinGlobals: t.options[0] && t.options[0].builtinGlobals,
      hoist: t.options[0] && t.options[0].hoist || "functions",
      allow: t.options[0] && t.options[0].allow || []
    };
    function r(u) {
      return e.allow.indexOf(u.name) !== -1;
    }
    function s(u) {
      const c = u.scope.block;
      return c.type === "ClassDeclaration" && c.id === u.identifiers[0];
    }
    function n(u, c) {
      const f = c.scope, h = c.defs[0], p = h && h.parent && h.parent.range, m = u.scope, d = u.defs[0], g = d && d.name.range;
      return p && g && p[0] < g[0] && g[1] < p[1] && (d.type === "FunctionName" && d.node.type === "FunctionExpression" || d.node.type === "ClassExpression") && f === m.upper;
    }
    function a(u) {
      const c = u.defs[0];
      return c && c.name.range;
    }
    function o(u) {
      const c = u.identifiers[0];
      let f;
      return c ? f = {
        global: !1,
        line: c.loc.start.line,
        column: c.loc.start.column + 1
      } : f = {
        global: !0
      }, f;
    }
    function l(u, c) {
      const f = c.defs[0], h = a(u), p = a(c);
      return h && p && h[1] < p[0] && (e.hoist !== "functions" || !f || f.node.type !== "FunctionDeclaration");
    }
    function i(u) {
      const c = u.variables;
      for (let f = 0; f < c.length; ++f) {
        const h = c[f];
        if (h.identifiers.length === 0 || s(h) || r(h))
          continue;
        const p = E.getVariableByName(u.upper, h.name);
        if (p && (p.identifiers.length > 0 || e.builtinGlobals && "writeable" in p) && !n(h, p) && !(e.hoist !== "all" && l(h, p))) {
          const m = o(p), d = m.global ? "noShadowGlobal" : "noShadow", g = {
            name: h.name
          };
          m.global || (g.shadowedLine = m.line, g.shadowedColumn = m.column), t.report({
            node: h.identifiers[0],
            messageId: d,
            data: g
          });
        }
      }
    }
    return {
      "Program:exit"() {
        const c = t.getScope().childScopes.slice();
        for (; c.length; ) {
          const f = c.pop();
          c.push(...f.childScopes), i(f);
        }
      }
    };
  }
};
Eh.meta;
Eh.create;
var bh = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow spacing between function identifiers and their applications (deprecated)",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-spaced-func"
    },
    deprecated: !0,
    replacedBy: ["func-call-spacing"],
    fixable: "whitespace",
    schema: [],
    messages: {
      noSpacedFunction: "Unexpected space between function name and paren."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s) {
      const n = e.getLastToken(s.callee);
      let a = n, o = e.getTokenAfter(n);
      for (; o && o.range[1] < s.range[1] && o.value !== "("; )
        a = o, o = e.getTokenAfter(o);
      o && o.range[1] < s.range[1] && e.isSpaceBetweenTokens(a, o) && t.report({
        node: s,
        loc: n.loc.start,
        messageId: "noSpacedFunction",
        fix(l) {
          return l.removeRange([a.range[1], o.range[0]]);
        }
      });
    }
    return {
      CallExpression: r,
      NewExpression: r
    };
  }
};
bh.meta;
bh.create;
var Ch = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow sparse arrays",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-sparse-arrays"
    },
    schema: [],
    messages: {
      unexpectedSparseArray: "Unexpected comma in middle of array."
    }
  },
  create(t) {
    return {
      ArrayExpression(e) {
        e.elements.indexOf(null) > -1 && t.report({
          node: e,
          messageId: "unexpectedSparseArray"
        });
      }
    };
  }
};
Ch.meta;
Ch.create;
var Sh = {
  meta: {
    deprecated: !0,
    replacedBy: [],
    type: "suggestion",
    docs: {
      description: "disallow synchronous methods",
      category: "Node.js and CommonJS",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-sync"
    },
    schema: [{
      type: "object",
      properties: {
        allowAtRootLevel: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      noSync: "Unexpected sync method: '{{propertyName}}'."
    }
  },
  create(t) {
    return {
      [t.options[0] && t.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]"](r) {
        t.report({
          node: r,
          messageId: "noSync",
          data: {
            propertyName: r.property.name
          }
        });
      }
    };
  }
};
Sh.meta;
Sh.create;
const gj = /\t+/gu, yj = /\S/u;
var Ah = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow all tabs",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-tabs"
    },
    schema: [{
      type: "object",
      properties: {
        allowIndentationTabs: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedTab: "Unexpected tab character."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options && t.options[0] && t.options[0].allowIndentationTabs;
    return {
      Program(s) {
        e.getLines().forEach((n, a) => {
          let o;
          for (; (o = gj.exec(n)) !== null; )
            r && !yj.test(n.slice(0, o.index)) || t.report({
              node: s,
              loc: {
                start: {
                  line: a + 1,
                  column: o.index
                },
                end: {
                  line: a + 1,
                  column: o.index + o[0].length
                }
              },
              messageId: "unexpectedTab"
            });
        });
      }
    };
  }
};
Ah.meta;
Ah.create;
var Dh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow template literal placeholder syntax in regular strings",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-template-curly-in-string"
    },
    schema: [],
    messages: {
      unexpectedTemplateExpression: "Unexpected template string expression."
    }
  },
  create(t) {
    return {
      Literal(e) {
        typeof e.value == "string" && /\$\{[^}]+\}/u.test(e.value) && t.report({
          node: e,
          messageId: "unexpectedTemplateExpression"
        });
      }
    };
  }
};
Dh.meta;
Dh.create;
var wh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow ternary operators",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-ternary"
    },
    schema: [],
    messages: {
      noTernaryOperator: "Ternary operator used."
    }
  },
  create(t) {
    return {
      ConditionalExpression(e) {
        t.report({
          node: e,
          messageId: "noTernaryOperator"
        });
      }
    };
  }
};
wh.meta;
wh.create;
function xj(t) {
  return t.type === "FunctionExpression" && t.parent.type === "MethodDefinition" && t.parent.kind === "constructor";
}
var kh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow `this`/`super` before calling `super()` in constructors",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-this-before-super"
    },
    schema: [],
    messages: {
      noBeforeSuper: "'{{kind}}' is not allowed before 'super()'."
    }
  },
  create(t) {
    let e = null, r = /* @__PURE__ */ Object.create(null);
    function s(i) {
      return !i.reachable || r[i.id].superCalled;
    }
    function n() {
      return !!(e && e.isConstructor && e.hasExtends);
    }
    function a() {
      return n() && !e.codePath.currentSegments.every(s);
    }
    function o(i) {
      const u = e.codePath.currentSegments;
      for (let c = 0; c < u.length; ++c) {
        const f = u[c];
        f.reachable && r[f.id].invalidNodes.push(i);
      }
    }
    function l() {
      const i = e.codePath.currentSegments;
      for (let u = 0; u < i.length; ++u) {
        const c = i[u];
        c.reachable && (r[c.id].superCalled = !0);
      }
    }
    return {
      onCodePathStart(i, u) {
        if (xj(u)) {
          const c = u.parent.parent.parent;
          e = {
            upper: e,
            isConstructor: !0,
            hasExtends: !!(c.superClass && !E.isNullOrUndefined(c.superClass)),
            codePath: i
          };
        } else
          e = {
            upper: e,
            isConstructor: !1,
            hasExtends: !1,
            codePath: i
          };
      },
      onCodePathEnd(i) {
        const u = e.hasExtends;
        e = e.upper, u && i.traverseSegments((c, f) => {
          const h = r[c.id];
          for (let p = 0; p < h.invalidNodes.length; ++p) {
            const m = h.invalidNodes[p];
            t.report({
              messageId: "noBeforeSuper",
              node: m,
              data: {
                kind: m.type === "Super" ? "super" : "this"
              }
            });
          }
          h.superCalled && f.skip();
        });
      },
      onCodePathSegmentStart(i) {
        n() && (r[i.id] = {
          superCalled: i.prevSegments.length > 0 && i.prevSegments.every(s),
          invalidNodes: []
        });
      },
      onCodePathSegmentLoop(i, u) {
        n() && e.codePath.traverseSegments({
          first: u,
          last: i
        }, (c, f) => {
          const h = r[c.id];
          h.superCalled ? (h.invalidNodes = [], f.skip()) : c.prevSegments.length > 0 && c.prevSegments.every(s) && (h.superCalled = !0, h.invalidNodes = []);
        });
      },
      ThisExpression(i) {
        a() && o(i);
      },
      Super(i) {
        !E.isCallee(i) && a() && o(i);
      },
      "CallExpression:exit"(i) {
        i.callee.type === "Super" && a() && l();
      },
      "Program:exit"() {
        r = /* @__PURE__ */ Object.create(null);
      }
    };
  }
};
kh.meta;
kh.create;
var Th = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow throwing literals as exceptions",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-throw-literal"
    },
    schema: [],
    messages: {
      object: "Expected an error object to be thrown.",
      undef: "Do not throw undefined."
    }
  },
  create(t) {
    return {
      ThrowStatement(e) {
        E.couldBeError(e.argument) ? e.argument.type === "Identifier" && e.argument.name === "undefined" && t.report({
          node: e,
          messageId: "undef"
        }) : t.report({
          node: e,
          messageId: "object"
        });
      }
    };
  }
};
Th.meta;
Th.create;
var Fh = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow trailing whitespace at the end of lines",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-trailing-spaces"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        skipBlankLines: {
          type: "boolean",
          default: !1
        },
        ignoreComments: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      trailingSpace: "Trailing spaces not allowed."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || {}, s = r.skipBlankLines || !1, n = r.ignoreComments || !1;
    function a(l, i, u) {
      t.report({
        node: l,
        loc: i,
        messageId: "trailingSpace",
        fix(c) {
          return c.removeRange(u);
        }
      });
    }
    function o(l) {
      const i = /* @__PURE__ */ new Set();
      return l.forEach((u) => {
        const c = u.type === "Block" ? u.loc.end.line - 1 : u.loc.end.line;
        for (let f = u.loc.start.line; f <= c; f++)
          i.add(f);
      }), i;
    }
    return {
      Program: function(l) {
        const i = new RegExp("[ 	-]+$", "u"), u = new RegExp("^[ 	-]*$", "u"), c = e.lines, f = e.getText().match(E.createGlobalLinebreakMatcher()), h = e.getAllComments(), p = o(h);
        let m = 0, d = [];
        for (let g = 0, y = c.length; g < y; g++) {
          const x = g + 1, A = f && f[g] ? f[g].length : 1, b = c[g].length + A, v = i.exec(c[g]);
          if (v) {
            const C = {
              start: {
                line: x,
                column: v.index
              },
              end: {
                line: x,
                column: b - A
              }
            }, T = m + C.start.column, w = m + C.end.column, B = e.getNodeByRangeIndex(T);
            if (B && B.type === "TemplateElement" && T > B.parent.range[0] && w < B.parent.range[1]) {
              m += b;
              continue;
            }
            if (s && u.test(c[g])) {
              m += b;
              continue;
            }
            d = [T, w], (!n || !p.has(x)) && a(l, C, d);
          }
          m += b;
        }
      }
    };
  }
};
Fh.meta;
Fh.create;
var Ph = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow initializing variables to `undefined`",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-undef-init"
    },
    schema: [],
    fixable: "code",
    messages: {
      unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      VariableDeclarator(r) {
        const s = e.getText(r.id), n = r.init && r.init.name, a = t.getScope(), o = E.getVariableByName(a, "undefined"), l = o && o.defs.length > 0, i = e.getLastToken(r);
        n === "undefined" && r.parent.kind !== "const" && !l && t.report({
          node: r,
          messageId: "unnecessaryUndefinedInit",
          data: {
            name: s
          },
          fix(u) {
            return r.parent.kind === "var" || r.id.type === "ArrayPattern" || r.id.type === "ObjectPattern" || e.commentsExistBetween(r.id, i) ? null : u.removeRange([r.id.range[1], r.range[1]]);
          }
        });
      }
    };
  }
};
Ph.meta;
Ph.create;
function vj(t) {
  const e = t.parent;
  return e.type === "UnaryExpression" && e.operator === "typeof";
}
var Ih = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
      category: "Variables",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-undef"
    },
    schema: [{
      type: "object",
      properties: {
        typeof: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      undef: "'{{name}}' is not defined."
    }
  },
  create(t) {
    const e = t.options[0], r = e && e.typeof === !0 || !1;
    return {
      "Program:exit"() {
        t.getScope().through.forEach((n) => {
          const a = n.identifier;
          !r && vj(a) || t.report({
            node: a,
            messageId: "undef",
            data: a
          });
        });
      }
    };
  }
};
Ih.meta;
Ih.create;
var _h = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `undefined` as an identifier",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-undefined"
    },
    schema: [],
    messages: {
      unexpectedUndefined: "Unexpected use of undefined."
    }
  },
  create(t) {
    function e(s) {
      t.report({
        node: s,
        messageId: "unexpectedUndefined"
      });
    }
    function r(s) {
      const n = s.set.get("undefined");
      if (!n)
        return;
      const a = n.references, o = n.defs;
      a.filter((l) => !l.init).forEach((l) => e(l.identifier)), o.forEach((l) => e(l.name));
    }
    return {
      "Program:exit"() {
        const n = [t.getScope()];
        for (; n.length; ) {
          const a = n.pop();
          n.push(...a.childScopes), r(a);
        }
      }
    };
  }
};
_h.meta;
_h.create;
var Bh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow dangling underscores in identifiers",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-underscore-dangle"
    },
    schema: [{
      type: "object",
      properties: {
        allow: {
          type: "array",
          items: {
            type: "string"
          }
        },
        allowAfterThis: {
          type: "boolean",
          default: !1
        },
        allowAfterSuper: {
          type: "boolean",
          default: !1
        },
        allowAfterThisConstructor: {
          type: "boolean",
          default: !1
        },
        enforceInMethodNames: {
          type: "boolean",
          default: !1
        },
        allowFunctionParams: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allow ? e.allow : [], s = typeof e.allowAfterThis < "u" ? e.allowAfterThis : !1, n = typeof e.allowAfterSuper < "u" ? e.allowAfterSuper : !1, a = typeof e.allowAfterThisConstructor < "u" ? e.allowAfterThisConstructor : !1, o = typeof e.enforceInMethodNames < "u" ? e.enforceInMethodNames : !1, l = typeof e.allowFunctionParams < "u" ? e.allowFunctionParams : !0;
    function i(g) {
      return r.some((y) => y === g);
    }
    function u(g) {
      const y = g.length;
      return g !== "_" && (g[0] === "_" || g[y - 1] === "_");
    }
    function c(g) {
      return g === "__proto__";
    }
    function f(g) {
      return g === "_";
    }
    function h(g) {
      return g.object.type === "MemberExpression" && g.object.property.name === "constructor" && g.object.object.type === "ThisExpression";
    }
    function p(g) {
      l || g.params.forEach((y) => {
        const {
          type: x
        } = y;
        let A;
        if (x === "RestElement" ? A = y.argument : x === "AssignmentPattern" ? A = y.left : A = y, A.type === "Identifier") {
          const b = A.name;
          u(b) && !i(b) && t.report({
            node: y,
            messageId: "unexpectedUnderscore",
            data: {
              identifier: b
            }
          });
        }
      });
    }
    function m(g) {
      if (g.type === "FunctionDeclaration" && g.id) {
        const y = g.id.name;
        typeof y < "u" && u(y) && !i(y) && t.report({
          node: g,
          messageId: "unexpectedUnderscore",
          data: {
            identifier: y
          }
        });
      }
      p(g);
    }
    function d(g) {
      const y = g.key.name, x = g.type === "MethodDefinition" || g.type === "Property" && g.method;
      typeof y < "u" && o && x && u(y) && !i(y) && t.report({
        node: g,
        messageId: "unexpectedUnderscore",
        data: {
          identifier: y
        }
      });
    }
    return {
      FunctionDeclaration: m,
      VariableDeclarator: function(g) {
        const y = g.id.name;
        typeof y < "u" && u(y) && !f(y) && !i(y) && t.report({
          node: g,
          messageId: "unexpectedUnderscore",
          data: {
            identifier: y
          }
        });
      },
      MemberExpression: function(g) {
        const y = g.property.name, x = g.object.type === "ThisExpression", A = g.object.type === "Super", b = h(g);
        typeof y < "u" && u(y) && !(x && s) && !(A && n) && !(b && a) && !c(y) && !i(y) && t.report({
          node: g,
          messageId: "unexpectedUnderscore",
          data: {
            identifier: y
          }
        });
      },
      MethodDefinition: d,
      Property: d,
      FunctionExpression: m,
      ArrowFunctionExpression: m
    };
  }
};
Bh.meta;
Bh.create;
var Oh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow confusing multiline expressions",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-unexpected-multiline"
    },
    schema: [],
    messages: {
      function: "Unexpected newline between function and ( of function call.",
      property: "Unexpected newline between object and [ of property access.",
      taggedTemplate: "Unexpected newline between template tag and template literal.",
      division: "Unexpected newline between numerator and division operator."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s, n) {
      const a = e.getTokenAfter(s, E.isNotClosingParenToken), o = e.getTokenBefore(a);
      a.loc.start.line !== o.loc.end.line && t.report({
        node: s,
        loc: a.loc,
        messageId: n
      });
    }
    return {
      MemberExpression(s) {
        !s.computed || s.optional || r(s.object, "property");
      },
      TaggedTemplateExpression(s) {
        const {
          quasi: n
        } = s;
        e.getTokenBefore(n).loc.end.line !== n.loc.start.line && t.report({
          node: s,
          loc: {
            start: n.loc.start,
            end: {
              line: n.loc.start.line,
              column: n.loc.start.column + 1
            }
          },
          messageId: "taggedTemplate"
        });
      },
      CallExpression(s) {
        s.arguments.length === 0 || s.optional || r(s.callee, "function");
      },
      "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(s) {
        const n = e.getTokenAfter(s, (o) => o.value === "/"), a = e.getTokenAfter(n);
        a.type === "Identifier" && /^[gimsuy]+$/u.test(a.value) && n.range[1] === a.range[0] && r(s.left, "division");
      }
    };
  }
};
Oh.meta;
Oh.create;
const Ej = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u, bj = /^(?:DoWhile|For|While)Statement$/u, Cj = /^(?:BinaryExpression|ConditionalExpression)$/u, Sj = /^(?:ArrowFunction|Class|Function)Expression$/u, Aj = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;
function Dj(t) {
  if (t.init) {
    const e = t.resolved && t.resolved.defs[0];
    if (!e || e.type !== "Variable" || e.parent.kind !== "var")
      return !1;
  }
  return t.isWrite();
}
function wj(t) {
  return !t.modified;
}
function kj(t) {
  return !(t.modified || t.group);
}
function Aa(t, e) {
  const r = t.range, s = e.identifier.range;
  return r[0] <= s[0] && s[1] <= r[1];
}
const Tj = {
  WhileStatement: Aa,
  DoWhileStatement: Aa,
  ForStatement(t, e) {
    return Aa(t, e) && !(t.init && Aa(t.init, e));
  }
};
function Fj(t) {
  let e = t.identifier;
  for (; e; ) {
    if (e.type === "FunctionDeclaration")
      return e.id ? e : null;
    e = e.parent;
  }
  return null;
}
function Pj(t, e) {
  for (let r = 0; r < t.length; ++r) {
    const s = t[r];
    for (let n = 0; !s.modified && n < e.length; ++n) {
      const a = e[n];
      let o, l;
      const i = s.isInLoop(a) || !!((o = Fj(a)) && (l = E.getVariableByName(a.from.upper, o.id.name)) && l.references.some(s.isInLoop));
      s.modified = i;
    }
  }
}
var Lh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unmodified loop conditions",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-unmodified-loop-condition"
    },
    schema: [],
    messages: {
      loopConditionNotModified: "'{{name}}' is not modified in this loop."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r = null;
    function s(u) {
      const c = u.reference.identifier;
      t.report({
        node: c,
        messageId: "loopConditionNotModified",
        data: c
      });
    }
    function n(u) {
      for (let c = 0; c < u.length; ++c) {
        const f = u[c];
        if (f.group) {
          let h = r.get(f.group);
          h || (h = [], r.set(f.group, h)), h.push(f);
        }
      }
    }
    function a(u) {
      u.every(wj) && u.forEach(s);
    }
    function o(u) {
      let c = !1;
      return Pl.traverser.traverse(u, {
        visitorKeys: e.visitorKeys,
        enter(f) {
          Aj.test(f.type) ? (c = !0, this.break()) : Sj.test(f.type) && this.skip();
        }
      }), c;
    }
    function l(u) {
      if (u.init)
        return null;
      let c = null, f = u.identifier, h = f.parent;
      for (; h; ) {
        if (Ej.test(h.type)) {
          if (bj.test(h.type) && h.test === f)
            return {
              reference: u,
              group: c,
              isInLoop: Tj[h.type].bind(null, h),
              modified: !1
            };
          break;
        }
        if (Cj.test(h.type)) {
          if (o(h))
            break;
          c = h;
        }
        f = h, h = h.parent;
      }
      return null;
    }
    function i(u) {
      const c = u.references.map(l).filter(Boolean);
      if (c.length === 0)
        return;
      n(c);
      const f = u.references.filter(Dj);
      f.length > 0 && Pj(c, f), c.filter(kj).forEach(s);
    }
    return {
      "Program:exit"() {
        const u = [t.getScope()];
        r = /* @__PURE__ */ new Map();
        let c;
        for (; c = u.pop(); )
          u.push(...c.childScopes), c.variables.forEach(i);
        r.forEach(a), r = null;
      }
    };
  }
};
Lh.meta;
Lh.create;
const Ij = /* @__PURE__ */ new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]), Ky = {
  "==": "!=",
  "!=": "==",
  "===": "!==",
  "!==": "==="
}, _j = E.getPrecedence({
  type: "LogicalExpression",
  operator: "||"
});
var Rh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow ternary operators when simpler alternatives exist",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-unneeded-ternary"
    },
    schema: [{
      type: "object",
      properties: {
        defaultAssignment: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.",
      unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment."
    }
  },
  create(t) {
    const r = (t.options[0] || {}).defaultAssignment !== !1, s = t.getSourceCode();
    function n(i) {
      return i.type === "Literal" && typeof i.value == "boolean";
    }
    function a(i) {
      if (i.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(Ky, i.operator)) {
        const u = s.getFirstTokenBetween(i.left, i.right, (f) => f.value === i.operator), c = s.getText();
        return c.slice(i.range[0], u.range[0]) + Ky[i.operator] + c.slice(u.range[1], i.range[1]);
      }
      return E.getPrecedence(i) < E.getPrecedence({
        type: "UnaryExpression"
      }) ? `!(${E.getParenthesisedText(s, i)})` : `!${E.getParenthesisedText(s, i)}`;
    }
    function o(i) {
      return i.type === "BinaryExpression" && Ij.has(i.operator) || i.type === "UnaryExpression" && i.operator === "!";
    }
    function l(i) {
      return i.test.type === "Identifier" && i.consequent.type === "Identifier" && i.test.name === i.consequent.name;
    }
    return {
      ConditionalExpression(i) {
        n(i.alternate) && n(i.consequent) ? t.report({
          node: i,
          messageId: "unnecessaryConditionalExpression",
          fix(u) {
            return i.consequent.value === i.alternate.value ? i.test.type === "Identifier" ? u.replaceText(i, i.consequent.value.toString()) : null : i.alternate.value ? u.replaceText(i, a(i.test)) : u.replaceText(i, o(i.test) ? E.getParenthesisedText(s, i.test) : `!${a(i.test)}`);
          }
        }) : !r && l(i) && t.report({
          node: i,
          messageId: "unnecessaryConditionalAssignment",
          fix: (u) => {
            const f = (E.getPrecedence(i.alternate) < _j || E.isCoalesceExpression(i.alternate)) && !E.isParenthesised(s, i.alternate) ? `(${s.getText(i.alternate)})` : E.getParenthesisedText(s, i.alternate), h = E.getParenthesisedText(s, i.test);
            return u.replaceText(i, `${h} || ${f}`);
          }
        });
      }
    };
  }
};
Rh.meta;
Rh.create;
const Jy = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
function Bj(t) {
  const e = t.parent;
  if (e)
    switch (e.type) {
      case "WhileStatement":
        return t === e.test;
      case "DoWhileStatement":
        return t === e.body;
      case "ForStatement":
        return t === (e.update || e.test || e.body);
      case "ForInStatement":
      case "ForOfStatement":
        return t === e.left;
    }
  return !1;
}
function Oj(t, e) {
  return t.filter((r) => !e.includes(r));
}
var Nh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow loops with a body that allows only one iteration",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-unreachable-loop"
    },
    schema: [{
      type: "object",
      properties: {
        ignore: {
          type: "array",
          items: {
            enum: Jy
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      invalid: "Invalid loop. Its body allows only one iteration."
    }
  },
  create(t) {
    const e = t.options[0] && t.options[0].ignore || [], r = Oj(Jy, e), s = r.join(","), n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
    let o = null;
    return {
      onCodePathStart(l) {
        o = l;
      },
      onCodePathEnd() {
        o = o.upper;
      },
      [s](l) {
        o.currentSegments.some((i) => i.reachable) && a.add(l);
      },
      onCodePathSegmentStart(l, i) {
        if (Bj(i)) {
          const u = i.parent;
          n.set(l, u);
        }
      },
      onCodePathSegmentLoop(l, i, u) {
        const c = n.get(i);
        (u === c || u.type === "ContinueStatement") && a.delete(c);
      },
      "Program:exit"() {
        a.forEach((l) => t.report({
          node: l,
          messageId: "invalid"
        }));
      }
    };
  }
};
Nh.meta;
Nh.create;
function Lj(t) {
  return !!t.init;
}
function Rj(t) {
  return !t.reachable;
}
class Nj {
  constructor(e) {
    this.sourceCode = e, this.startNode = null, this.endNode = null;
  }
  get location() {
    return {
      start: this.startNode.loc.start,
      end: this.endNode.loc.end
    };
  }
  get isEmpty() {
    return !(this.startNode && this.endNode);
  }
  contains(e) {
    return e.range[0] >= this.startNode.range[0] && e.range[1] <= this.endNode.range[1];
  }
  isConsecutive(e) {
    return this.contains(this.sourceCode.getTokenBefore(e));
  }
  merge(e) {
    this.endNode = e;
  }
  reset(e) {
    this.startNode = this.endNode = e;
  }
}
var jh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-unreachable"
    },
    schema: [],
    messages: {
      unreachableCode: "Unreachable code."
    }
  },
  create(t) {
    let e = null;
    const r = new Nj(t.getSourceCode());
    function s(n) {
      let a = null;
      if (n && e.currentSegments.every(Rj)) {
        if (r.isEmpty) {
          r.reset(n);
          return;
        }
        if (r.contains(n))
          return;
        if (r.isConsecutive(n)) {
          r.merge(n);
          return;
        }
        a = n;
      }
      r.isEmpty || t.report({
        messageId: "unreachableCode",
        loc: r.location,
        node: r.startNode
      }), r.reset(a);
    }
    return {
      onCodePathStart(n) {
        e = n;
      },
      onCodePathEnd() {
        e = e.upper;
      },
      BlockStatement: s,
      BreakStatement: s,
      ClassDeclaration: s,
      ContinueStatement: s,
      DebuggerStatement: s,
      DoWhileStatement: s,
      ExpressionStatement: s,
      ForInStatement: s,
      ForOfStatement: s,
      ForStatement: s,
      IfStatement: s,
      ImportDeclaration: s,
      LabeledStatement: s,
      ReturnStatement: s,
      SwitchStatement: s,
      ThrowStatement: s,
      TryStatement: s,
      VariableDeclaration(n) {
        (n.kind !== "var" || n.declarations.some(Lj)) && s(n);
      },
      WhileStatement: s,
      WithStatement: s,
      ExportNamedDeclaration: s,
      ExportDefaultDeclaration: s,
      ExportAllDeclaration: s,
      "Program:exit"() {
        s();
      }
    };
  }
};
jh.meta;
jh.create;
const jj = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u, Mj = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u, $j = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;
var Mh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow control flow statements in `finally` blocks",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-unsafe-finally"
    },
    schema: [],
    messages: {
      unsafeUsage: "Unsafe usage of {{nodeType}}."
    }
  },
  create(t) {
    function e(n) {
      return n.parent.type === "TryStatement" && n.parent.finalizer === n;
    }
    function r(n, a) {
      let o = !1, l;
      n.type === "BreakStatement" && !n.label ? l = Mj : n.type === "ContinueStatement" ? l = $j : l = jj;
      for (let i = n; i && !l.test(i.type); i = i.parent)
        if (i.parent.label && a && i.parent.label.name === a.name && (o = !0), e(i))
          return !(a && o);
      return !1;
    }
    function s(n) {
      r(n, n.label) && t.report({
        messageId: "unsafeUsage",
        data: {
          nodeType: n.type
        },
        node: n,
        line: n.loc.line,
        column: n.loc.column
      });
    }
    return {
      ReturnStatement: s,
      ThrowStatement: s,
      BreakStatement: s,
      ContinueStatement: s
    };
  }
};
Mh.meta;
Mh.create;
function Vj(t) {
  return t === "in" || t === "instanceof";
}
function Uj(t) {
  return t === "<" || t === ">" || t === ">=" || t === "<=";
}
function qj(t) {
  return t.type === "UnaryExpression" && t.operator === "!";
}
var $h = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow negating the left operand of relational operators",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-unsafe-negation",
      suggestion: !0
    },
    schema: [{
      type: "object",
      properties: {
        enforceForOrderingRelations: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: null,
    messages: {
      unexpected: "Unexpected negating the left operand of '{{operator}}' operator.",
      suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",
      suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior."
    }
  },
  create(t) {
    const e = t.getSourceCode(), s = (t.options[0] || {}).enforceForOrderingRelations === !0;
    return {
      BinaryExpression(n) {
        const a = n.operator, o = s && Uj(a);
        (Vj(a) || o) && qj(n.left) && !E.isParenthesised(e, n.left) && t.report({
          node: n,
          loc: n.left.loc,
          messageId: "unexpected",
          data: {
            operator: a
          },
          suggest: [{
            messageId: "suggestNegatedExpression",
            data: {
              operator: a
            },
            fix(l) {
              const u = [e.getFirstToken(n.left).range[1], n.range[1]], c = e.text.slice(u[0], u[1]);
              return l.replaceTextRange(u, `(${c})`);
            }
          }, {
            messageId: "suggestParenthesisedNegation",
            fix(l) {
              return l.replaceText(n.left, `(${e.getText(n.left)})`);
            }
          }]
        });
      }
    };
  }
};
$h.meta;
$h.create;
const Xy = /* @__PURE__ */ new Set(["+", "-", "/", "*", "%", "**"]), Wj = /* @__PURE__ */ new Set(["+=", "-=", "/=", "*=", "%=", "**="]), zj = /* @__PURE__ */ new Set(["in", "instanceof"]);
function Qy(t) {
  return t.type === "ObjectPattern" || t.type === "ArrayPattern";
}
var Vh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow use of optional chaining in contexts where the `undefined` value is not allowed",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-unsafe-optional-chaining"
    },
    schema: [{
      type: "object",
      properties: {
        disallowArithmeticOperators: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: null,
    messages: {
      unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",
      unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN."
    }
  },
  create(t) {
    const r = (t.options[0] || {}).disallowArithmeticOperators || !1;
    function s(i) {
      t.report({
        messageId: "unsafeOptionalChain",
        node: i
      });
    }
    function n(i) {
      t.report({
        messageId: "unsafeArithmetic",
        node: i
      });
    }
    function a(i, u) {
      if (i)
        switch (i.type) {
          case "LogicalExpression":
            i.operator === "||" || i.operator === "??" ? a(i.right, u) : i.operator === "&&" && (a(i.left, u), a(i.right, u));
            break;
          case "SequenceExpression":
            a(i.expressions[i.expressions.length - 1], u);
            break;
          case "ConditionalExpression":
            a(i.consequent, u), a(i.alternate, u);
            break;
          case "AwaitExpression":
            a(i.argument, u);
            break;
          case "ChainExpression":
            u(i);
            break;
        }
    }
    function o(i) {
      a(i, s);
    }
    function l(i) {
      a(i, n);
    }
    return {
      "AssignmentExpression, AssignmentPattern"(i) {
        Qy(i.left) && o(i.right);
      },
      "ClassDeclaration, ClassExpression"(i) {
        o(i.superClass);
      },
      CallExpression(i) {
        i.optional || o(i.callee);
      },
      NewExpression(i) {
        o(i.callee);
      },
      VariableDeclarator(i) {
        Qy(i.id) && o(i.init);
      },
      MemberExpression(i) {
        i.optional || o(i.object);
      },
      TaggedTemplateExpression(i) {
        o(i.tag);
      },
      ForOfStatement(i) {
        o(i.right);
      },
      SpreadElement(i) {
        i.parent && i.parent.type !== "ObjectExpression" && o(i.argument);
      },
      BinaryExpression(i) {
        zj.has(i.operator) && o(i.right), r && Xy.has(i.operator) && (l(i.right), l(i.left));
      },
      WithStatement(i) {
        o(i.object);
      },
      UnaryExpression(i) {
        r && Xy.has(i.operator) && l(i.argument);
      },
      AssignmentExpression(i) {
        r && Wj.has(i.operator) && l(i.right);
      }
    };
  }
};
Vh.meta;
Vh.create;
function Jt() {
  return !0;
}
function Gj() {
  return !1;
}
var Uh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unused expressions",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-unused-expressions"
    },
    schema: [{
      type: "object",
      properties: {
        allowShortCircuit: {
          type: "boolean",
          default: !1
        },
        allowTernary: {
          type: "boolean",
          default: !1
        },
        allowTaggedTemplates: {
          type: "boolean",
          default: !1
        },
        enforceForJSX: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unusedExpression: "Expected an assignment or function call and instead saw an expression."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allowShortCircuit || !1, s = e.allowTernary || !1, n = e.allowTaggedTemplates || !1, a = e.enforceForJSX || !1;
    function o(f) {
      return f.type === "ExpressionStatement" && f.expression.type === "Literal" && typeof f.expression.value == "string";
    }
    function l(f, h) {
      for (let p = 0; p < h.length; ++p)
        if (!f(h[p]))
          return h.slice(0, p);
      return h.slice();
    }
    function i(f) {
      return l(o, f.body);
    }
    function u(f, h) {
      const p = h[h.length - 1], m = h[h.length - 2];
      return (p.type === "Program" || p.type === "BlockStatement" && /Function/u.test(m.type)) && i(p).indexOf(f) >= 0;
    }
    const c = Object.assign(/* @__PURE__ */ Object.create(null), {
      isDisallowed(f) {
        return (c[f.type] || Gj)(f);
      },
      ArrayExpression: Jt,
      ArrowFunctionExpression: Jt,
      BinaryExpression: Jt,
      ChainExpression(f) {
        return c.isDisallowed(f.expression);
      },
      ClassExpression: Jt,
      ConditionalExpression(f) {
        return s ? c.isDisallowed(f.consequent) || c.isDisallowed(f.alternate) : !0;
      },
      FunctionExpression: Jt,
      Identifier: Jt,
      JSXElement() {
        return a;
      },
      JSXFragment() {
        return a;
      },
      Literal: Jt,
      LogicalExpression(f) {
        return r ? c.isDisallowed(f.right) : !0;
      },
      MemberExpression: Jt,
      MetaProperty: Jt,
      ObjectExpression: Jt,
      SequenceExpression: Jt,
      TaggedTemplateExpression() {
        return !n;
      },
      TemplateLiteral: Jt,
      ThisExpression: Jt,
      UnaryExpression(f) {
        return f.operator !== "void" && f.operator !== "delete";
      }
    });
    return {
      ExpressionStatement(f) {
        c.isDisallowed(f.expression) && !u(f, t.getAncestors()) && t.report({
          node: f,
          messageId: "unusedExpression"
        });
      }
    };
  }
};
Uh.meta;
Uh.create;
var qh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unused labels",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-unused-labels"
    },
    schema: [],
    fixable: "code",
    messages: {
      unused: "'{{name}}:' is defined but never used."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r = null;
    function s(o) {
      r = {
        label: o.label.name,
        used: !1,
        upper: r
      };
    }
    function n(o) {
      r.used || t.report({
        node: o.label,
        messageId: "unused",
        data: o.label,
        fix(l) {
          return e.getTokenAfter(o.label, {
            includeComments: !0
          }) === e.getTokenBefore(o.body, {
            includeComments: !0
          }) ? l.removeRange([o.range[0], o.body.range[0]]) : null;
        }
      }), r = r.upper;
    }
    function a(o) {
      if (!o.label)
        return;
      const l = o.label.name;
      let i = r;
      for (; i; ) {
        if (i.label === l) {
          i.used = !0;
          break;
        }
        i = i.upper;
      }
    }
    return {
      LabeledStatement: s,
      "LabeledStatement:exit": n,
      BreakStatement: a,
      ContinueStatement: a
    };
  }
};
qh.meta;
qh.create;
var Wh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow unused variables",
      category: "Variables",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-unused-vars"
    },
    schema: [{
      oneOf: [{
        enum: ["all", "local"]
      }, {
        type: "object",
        properties: {
          vars: {
            enum: ["all", "local"]
          },
          varsIgnorePattern: {
            type: "string"
          },
          args: {
            enum: ["all", "after-used", "none"]
          },
          ignoreRestSiblings: {
            type: "boolean"
          },
          argsIgnorePattern: {
            type: "string"
          },
          caughtErrors: {
            enum: ["all", "none"]
          },
          caughtErrorsIgnorePattern: {
            type: "string"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = {
      vars: "all",
      args: "after-used",
      ignoreRestSiblings: !1,
      caughtErrors: "none"
    }, s = t.options[0];
    s && (typeof s == "string" ? r.vars = s : (r.vars = s.vars || r.vars, r.args = s.args || r.args, r.ignoreRestSiblings = s.ignoreRestSiblings || r.ignoreRestSiblings, r.caughtErrors = s.caughtErrors || r.caughtErrors, s.varsIgnorePattern && (r.varsIgnorePattern = new RegExp(s.varsIgnorePattern, "u")), s.argsIgnorePattern && (r.argsIgnorePattern = new RegExp(s.argsIgnorePattern, "u")), s.caughtErrorsIgnorePattern && (r.caughtErrorsIgnorePattern = new RegExp(s.caughtErrorsIgnorePattern, "u"))));
    function n(C) {
      const T = C.defs && C.defs[0] && C.defs[0].type;
      let w, B;
      T === "CatchClause" && r.caughtErrorsIgnorePattern ? (w = "args", B = r.caughtErrorsIgnorePattern.toString()) : T === "Parameter" && r.argsIgnorePattern ? (w = "args", B = r.argsIgnorePattern.toString()) : T !== "Parameter" && r.varsIgnorePattern && (w = "vars", B = r.varsIgnorePattern.toString());
      const I = w ? `. Allowed unused ${w} must match ${B}` : "";
      return {
        varName: C.name,
        action: "defined",
        additional: I
      };
    }
    function a(C) {
      const T = r.varsIgnorePattern ? `. Allowed unused vars must match ${r.varsIgnorePattern.toString()}` : "";
      return {
        varName: C.name,
        action: "assigned a value",
        additional: T
      };
    }
    function o(C) {
      const T = C.defs[0];
      if (T) {
        let w = T.node;
        if (w.type === "VariableDeclarator")
          w = w.parent;
        else if (T.type === "Parameter")
          return !1;
        return w.parent.type.indexOf("Export") === 0;
      }
      return !1;
    }
    function l(C) {
      return C.type === "Property" && C.parent.type === "ObjectPattern" && /^(?:RestElement|(?:Experimental)?RestProperty)$/u.test(C.parent.properties[C.parent.properties.length - 1].type);
    }
    function i(C) {
      if (r.ignoreRestSiblings) {
        const T = C.defs.some((B) => l(B.name.parent)), w = C.references.some((B) => l(B.identifier.parent));
        return T || w;
      }
      return !1;
    }
    function u(C) {
      return C.isRead();
    }
    function c(C, T) {
      let w = C.from;
      for (; w; ) {
        if (T.indexOf(w.block) >= 0)
          return !0;
        w = w.upper;
      }
      return !1;
    }
    function f(C) {
      const T = [];
      return C.defs.forEach((w) => {
        const {
          type: B,
          node: I
        } = w;
        B === "FunctionName" && T.push(I), B === "Variable" && I.init && (I.init.type === "FunctionExpression" || I.init.type === "ArrowFunctionExpression") && T.push(I.init);
      }), T;
    }
    function h(C, T) {
      return C.range[0] >= T.range[0] && C.range[1] <= T.range[1];
    }
    function p(C, T) {
      const w = C.identifier, B = w.parent, I = B.parent, _ = C.from.variableScope, S = C.resolved.scope.variableScope, F = _ !== S || E.isInLoop(w);
      return T && h(w, T) ? T : B.type === "AssignmentExpression" && I.type === "ExpressionStatement" && w === B.left && !F ? B.right : null;
    }
    function m(C, T) {
      let w = C, B = C.parent;
      for (; B && h(B, T); ) {
        switch (B.type) {
          case "SequenceExpression":
            if (B.expressions[B.expressions.length - 1] !== w)
              return !1;
            break;
          case "CallExpression":
          case "NewExpression":
            return B.callee !== w;
          case "AssignmentExpression":
          case "TaggedTemplateExpression":
          case "YieldExpression":
            return !0;
          default:
            if (/(?:Statement|Declaration)$/u.test(B.type))
              return !0;
        }
        w = B, B = B.parent;
      }
      return !1;
    }
    function d(C, T) {
      const w = E.getUpperFunction(C);
      return w && h(w, T) && m(w, T);
    }
    function g(C) {
      const T = C.parent;
      return T.type === "ExpressionStatement" ? !0 : T.type === "SequenceExpression" ? T.expressions[T.expressions.length - 1] === C ? g(T) : !0 : !1;
    }
    function y(C, T) {
      const w = C.identifier, B = w.parent;
      return C.isRead() && (B.type === "AssignmentExpression" && B.left === w && g(B) || B.type === "UpdateExpression" && g(B) || T && h(w, T) && !d(w, T));
    }
    function x(C) {
      let T = C.identifier.parent;
      return T.type === "VariableDeclarator" && (T = T.parent.parent), T.type !== "ForInStatement" || (T.body.type === "BlockStatement" ? T = T.body.body[0] : T = T.body, !T) ? !1 : T.type === "ReturnStatement";
    }
    function A(C) {
      const T = f(C), w = T.length > 0;
      let B = null;
      return C.references.some((I) => {
        if (x(I))
          return !0;
        const _ = y(I, B);
        return B = p(I, B), u(I) && !_ && !(w && c(I, T));
      });
    }
    function b(C) {
      const T = C.defs[0], w = t.getDeclaredVariables(T.node);
      return !w.slice(w.indexOf(C) + 1).some((I) => I.references.length > 0 || I.eslintUsed);
    }
    function v(C, T) {
      const w = C.variables, B = C.childScopes;
      let I, _;
      if (C.type !== "global" || r.vars === "all")
        for (I = 0, _ = w.length; I < _; ++I) {
          const S = w[I];
          if (C.type === "class" && C.block.id === S.identifiers[0] || C.functionExpressionScope || S.eslintUsed || C.type === "function" && S.name === "arguments" && S.identifiers.length === 0)
            continue;
          const F = S.defs[0];
          if (F) {
            const N = F.type;
            if (N === "CatchClause" && (r.caughtErrors === "none" || r.caughtErrorsIgnorePattern && r.caughtErrorsIgnorePattern.test(F.name.name)))
              continue;
            if (N === "Parameter") {
              if ((F.node.parent.type === "Property" || F.node.parent.type === "MethodDefinition") && F.node.parent.kind === "set" || r.args === "none" || r.argsIgnorePattern && r.argsIgnorePattern.test(F.name.name) || r.args === "after-used" && E.isFunction(F.name.parent) && !b(S))
                continue;
            } else if (r.varsIgnorePattern && r.varsIgnorePattern.test(F.name.name))
              continue;
          }
          !A(S) && !o(S) && !i(S) && T.push(S);
        }
      for (I = 0, _ = B.length; I < _; ++I)
        v(B[I], T);
      return T;
    }
    return {
      "Program:exit"(C) {
        const T = v(t.getScope(), []);
        for (let w = 0, B = T.length; w < B; ++w) {
          const I = T[w];
          if (I.defs.length > 0) {
            const _ = I.references.filter((F) => F.isWrite() && F.from.variableScope === I.scope.variableScope);
            let S;
            _.length > 0 && (S = _[_.length - 1]), t.report({
              node: S ? S.identifier : I.identifiers[0],
              messageId: "unusedVar",
              data: I.references.some((F) => F.isWrite()) ? a(I) : n(I)
            });
          } else if (I.eslintExplicitGlobalComments) {
            const _ = I.eslintExplicitGlobalComments[0];
            t.report({
              node: C,
              loc: E.getNameLocationInGlobalDirectiveComment(e, _, I.name),
              messageId: "unusedVar",
              data: n(I)
            });
          }
        }
      }
    };
  }
};
Wh.meta;
Wh.create;
const Hj = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u, Kj = /^For(?:In|Of)Statement$/u;
function Jj(t) {
  let e = !0, r = !0, s = !0;
  return typeof t == "string" ? e = t !== "nofunc" : typeof t == "object" && t !== null && (e = t.functions !== !1, r = t.classes !== !1, s = t.variables !== !1), {
    functions: e,
    classes: r,
    variables: s
  };
}
function Xj(t) {
  return t.defs[0].type === "FunctionName";
}
function Qj(t, e) {
  return t.defs[0].type === "ClassName" && t.scope.variableScope !== e.from.variableScope;
}
function Yj(t, e) {
  return t.defs[0].type === "Variable" && t.scope.variableScope !== e.from.variableScope;
}
function Go(t, e) {
  return t && t.range[0] <= e && e <= t.range[1];
}
function Zj(t, e) {
  if (t.scope !== e.from)
    return !1;
  let r = t.identifiers[0].parent;
  const s = e.identifier.range[1];
  for (; r; ) {
    if (r.type === "VariableDeclarator") {
      if (Go(r.init, s) || Kj.test(r.parent.parent.type) && Go(r.parent.parent.right, s))
        return !0;
      break;
    } else if (r.type === "AssignmentPattern") {
      if (Go(r.right, s))
        return !0;
    } else if (Hj.test(r.type))
      break;
    r = r.parent;
  }
  return !1;
}
var zh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow the use of variables before they are defined",
      category: "Variables",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-use-before-define"
    },
    schema: [{
      oneOf: [{
        enum: ["nofunc"]
      }, {
        type: "object",
        properties: {
          functions: {
            type: "boolean"
          },
          classes: {
            type: "boolean"
          },
          variables: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      usedBeforeDefined: "'{{name}}' was used before it was defined."
    }
  },
  create(t) {
    const e = Jj(t.options[0]);
    function r(n, a) {
      return Xj(n) ? e.functions : Qj(n, a) ? e.classes : Yj(n, a) ? e.variables : !0;
    }
    function s(n) {
      n.references.forEach((a) => {
        const o = a.resolved;
        a.init || !o || o.identifiers.length === 0 || o.identifiers[0].range[1] < a.identifier.range[1] && !Zj(o, a) || !r(o, a) || t.report({
          node: a.identifier,
          messageId: "usedBeforeDefined",
          data: a.identifier
        });
      }), n.childScopes.forEach(s);
    }
    return {
      Program() {
        s(t.getScope());
      }
    };
  }
};
zh.meta;
zh.create;
const {
  CALL: e6,
  CONSTRUCT: t6,
  ReferenceTracker: r6,
  getStringIfConstant: Yy
} = Vt.default, {
  RegExpParser: n6,
  visitRegExpAST: s6
} = pn.default, a6 = new n6();
function Zy(t) {
  const e = [];
  let r = t;
  do
    e.push(r), r = r.parent;
  while (r);
  return e;
}
function Tb(t) {
  return t.type === "Assertion" && (t.kind === "lookahead" || t.kind === "lookbehind");
}
function i6(t) {
  return Tb(t) && t.negate;
}
var Gh = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow useless backreferences in regular expressions",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-backreference"
    },
    schema: [],
    messages: {
      nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",
      forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",
      backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",
      disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",
      intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround."
    }
  },
  create(t) {
    function e(r, s, n) {
      let a;
      try {
        a = a6.parsePattern(s, 0, s.length, n.includes("u"));
      } catch {
        return;
      }
      s6(a, {
        onBackreferenceEnter(o) {
          const l = o.resolved, i = Zy(o), u = Zy(l);
          let c = null;
          if (i.includes(l))
            c = "nested";
          else {
            let f = i.length - 1, h = u.length - 1;
            do
              f--, h--;
            while (i[f] === u[h]);
            const p = h + 1, m = u.slice(0, p), d = u.slice(p), g = d.find(Tb), y = g && g.kind === "lookbehind";
            !y && o.end <= l.start ? c = "forward" : y && l.end <= o.start ? c = "backward" : m[m.length - 1].type === "Alternative" ? c = "disjunctive" : m.some(i6) && (c = "intoNegativeLookaround");
          }
          c && t.report({
            node: r,
            messageId: c,
            data: {
              bref: o.raw,
              group: l.raw
            }
          });
        }
      });
    }
    return {
      "Literal[regex]"(r) {
        const {
          pattern: s,
          flags: n
        } = r.regex;
        e(r, s, n);
      },
      Program() {
        const r = t.getScope(), s = new r6(r), n = {
          RegExp: {
            [e6]: !0,
            [t6]: !0
          }
        };
        for (const {
          node: a
        } of s.iterateGlobalReferences(n)) {
          const [o, l] = a.arguments, i = Yy(o, r), u = Yy(l, r);
          typeof i == "string" && e(a, i, u || "");
        }
      }
    };
  }
};
Gh.meta;
Gh.create;
function o6(t) {
  const e = E.skipChainExpression(t.callee);
  return e.type === "MemberExpression" && e.property.type === "Identifier" && e.computed === !1 && (e.property.name === "call" && t.arguments.length >= 1 || e.property.name === "apply" && t.arguments.length === 2 && t.arguments[1].type === "ArrayExpression");
}
function l6(t, e, r) {
  return t ? E.equalTokens(t, e, r) : E.isNullOrUndefined(e);
}
var Hh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary calls to `.call()` and `.apply()`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-call"
    },
    schema: [],
    messages: {
      unnecessaryCall: "Unnecessary '.{{name}}()'."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      CallExpression(r) {
        if (!o6(r))
          return;
        const s = E.skipChainExpression(r.callee), n = E.skipChainExpression(s.object), a = n.type === "MemberExpression" ? n.object : null, o = r.arguments[0];
        l6(a, o, e) && t.report({
          node: r,
          messageId: "unnecessaryCall",
          data: {
            name: s.property.name
          }
        });
      }
    };
  }
};
Hh.meta;
Hh.create;
var Kh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary `catch` clauses",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-useless-catch"
    },
    schema: [],
    messages: {
      unnecessaryCatchClause: "Unnecessary catch clause.",
      unnecessaryCatch: "Unnecessary try/catch wrapper."
    }
  },
  create(t) {
    return {
      CatchClause(e) {
        e.param && e.param.type === "Identifier" && e.body.body.length && e.body.body[0].type === "ThrowStatement" && e.body.body[0].argument.type === "Identifier" && e.body.body[0].argument.name === e.param.name && (e.parent.finalizer ? t.report({
          node: e,
          messageId: "unnecessaryCatchClause"
        }) : t.report({
          node: e.parent,
          messageId: "unnecessaryCatch"
        }));
      }
    };
  }
};
Kh.meta;
Kh.create;
var Jh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary computed property keys in objects and classes",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-computed-key"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForClassMembers: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] && t.options[0].enforceForClassMembers;
    function s(n) {
      if (!n.computed)
        return;
      const a = n.key, o = typeof a.value;
      let l;
      n.type === "MethodDefinition" ? l = n.static ? "prototype" : "constructor" : l = "__proto__", a.type === "Literal" && (o === "string" || o === "number") && a.value !== l && t.report({
        node: n,
        messageId: "unnecessarilyComputedProperty",
        data: {
          property: e.getText(a)
        },
        fix(i) {
          const u = e.getTokenBefore(a, E.isOpeningBracketToken), c = e.getTokenAfter(a, E.isClosingBracketToken);
          if (e.commentsExistBetween(u, c))
            return null;
          const f = e.getTokenBefore(u), p = (f.range[1] === u.range[0] && !E.canTokensBeAdjacent(f, e.getFirstToken(a)) ? " " : "") + a.raw;
          return i.replaceTextRange([u.range[0], c.range[1]], p);
        }
      });
    }
    return {
      Property: s,
      MethodDefinition: r ? s : function() {
      }
    };
  }
};
Jh.meta;
Jh.create;
function Fb(t) {
  return t.type === "BinaryExpression" && t.operator === "+";
}
function u6(t) {
  return t.value === "+" && t.type === "Punctuator";
}
function c6(t) {
  let e = t.left;
  for (; Fb(e); )
    e = e.right;
  return e;
}
function p6(t) {
  let e = t.right;
  for (; Fb(e); )
    e = e.left;
  return e;
}
var Xh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary concatenation of literals or template literals",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-concat"
    },
    schema: [],
    messages: {
      unexpectedConcat: "Unexpected string concatenation of literals."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      BinaryExpression(r) {
        if (r.operator !== "+")
          return;
        const s = c6(r), n = p6(r);
        if (E.isStringLiteral(s) && E.isStringLiteral(n) && E.isTokenOnSameLine(s, n)) {
          const a = e.getFirstTokenBetween(s, n, u6);
          t.report({
            node: r,
            loc: a.loc,
            messageId: "unexpectedConcat"
          });
        }
      }
    };
  }
};
Xh.meta;
Xh.create;
function f6(t) {
  return t.length === 1 && t[0].type === "ExpressionStatement" && t[0].expression.type === "CallExpression" && t[0].expression.callee.type === "Super";
}
function h6(t) {
  return t.type === "Identifier" || t.type === "RestElement";
}
function m6(t) {
  return t.length === 1 && t[0].type === "SpreadElement" && t[0].argument.type === "Identifier" && t[0].argument.name === "arguments";
}
function Pb(t, e) {
  return t.type === "Identifier" && e.type === "Identifier" && t.name === e.name;
}
function d6(t, e) {
  return t.type === "RestElement" && e.type === "SpreadElement" && Pb(t.argument, e.argument);
}
function g6(t, e) {
  return Pb(t, e) || d6(t, e);
}
function y6(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let r = 0; r < t.length; ++r)
    if (!g6(t[r], e[r]))
      return !1;
  return !0;
}
function x6(t, e) {
  return f6(t) && e.every(h6) && (m6(t[0].expression.arguments) || y6(e, t[0].expression.arguments));
}
var Qh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary constructors",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-constructor"
    },
    schema: [],
    messages: {
      noUselessConstructor: "Useless constructor."
    }
  },
  create(t) {
    return {
      MethodDefinition: function(e) {
        if (e.kind !== "constructor" || !e.value.body)
          return;
        const r = e.value.body.body, s = e.value.params;
        (e.parent.parent.superClass ? x6(r, s) : r.length === 0) && t.report({
          node: e,
          messageId: "noUselessConstructor"
        });
      }
    };
  }
};
Qh.meta;
Qh.create;
function Ib(t, e) {
  return new Set(function* () {
    yield* t, yield* e;
  }());
}
const v6 = Ib(new Set("\\nrvtbfux"), E.LINEBREAKS), _b = new Set("\\bcdDfnpPrsStvwWxu0123456789]"), E6 = Ib(_b, new Set("^/.$*+?[{}|()Bk"));
function b6(t) {
  const e = [];
  return t.split("").reduce((r, s, n) => {
    if (!r.escapeNextChar) {
      if (s === "\\")
        return Object.assign(r, {
          escapeNextChar: !0
        });
      if (s === "[" && !r.inCharClass)
        return Object.assign(r, {
          inCharClass: !0,
          startingCharClass: !0
        });
      if (s === "]" && r.inCharClass)
        return e.length && e[e.length - 1].inCharClass && (e[e.length - 1].endsCharClass = !0), Object.assign(r, {
          inCharClass: !1,
          startingCharClass: !1
        });
    }
    return e.push({
      text: s,
      index: n,
      escaped: r.escapeNextChar,
      inCharClass: r.inCharClass,
      startsCharClass: r.startingCharClass,
      endsCharClass: !1
    }), Object.assign(r, {
      escapeNextChar: !1,
      startingCharClass: !1
    });
  }, {
    escapeNextChar: !1,
    inCharClass: !1,
    startingCharClass: !1
  }), e;
}
var Yh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow unnecessary escape characters",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-useless-escape",
      suggestion: !0
    },
    messages: {
      unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
      removeEscape: "Remove the `\\`. This maintains the current functionality.",
      escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
    },
    schema: []
  },
  create(t) {
    const e = t.getSourceCode();
    function r(a, o, l) {
      const i = a.range[0] + o, u = [i, i + 1], c = e.getLocFromIndex(i);
      t.report({
        node: a,
        loc: {
          start: c,
          end: {
            line: c.line,
            column: c.column + 1
          }
        },
        messageId: "unnecessaryEscape",
        data: {
          character: l
        },
        suggest: [{
          messageId: "removeEscape",
          fix(f) {
            return f.removeRange(u);
          }
        }, {
          messageId: "escapeBackslash",
          fix(f) {
            return f.insertTextBeforeRange(u, "\\");
          }
        }]
      });
    }
    function s(a, o) {
      const l = a.type === "TemplateElement", i = o[0][1];
      let u = !v6.has(i), c;
      l ? (c = i === "`", i === "$" ? u = o.input[o.index + 2] !== "{" : i === "{" && (u = o.input[o.index - 1] !== "$")) : c = i === a.raw[0], u && !c && r(a, o.index, o[0].slice(1));
    }
    function n(a) {
      const o = a.type === "TemplateElement";
      if (!(o && a.parent && a.parent.parent && a.parent.parent.type === "TaggedTemplateExpression" && a.parent === a.parent.parent.quasi))
        if (typeof a.value == "string" || o) {
          if (a.parent.type === "JSXAttribute" || a.parent.type === "JSXElement" || a.parent.type === "JSXFragment")
            return;
          const l = o ? e.getText(a) : a.raw;
          let i;
          for (; i = /\\[^\d]/gu.exec(l); )
            s(a, i);
        } else
          a.regex && b6(a.regex.pattern).filter((l) => !(l.text === "-" && l.inCharClass && !l.startsCharClass && !l.endsCharClass)).filter((l) => !(l.text === "^" && l.startsCharClass)).filter((l) => l.escaped).filter((l) => !(l.inCharClass ? _b : E6).has(l.text)).forEach((l) => r(a, l.index, l.text));
    }
    return {
      Literal: n,
      TemplateElement: n
    };
  }
};
Yh.meta;
Yh.create;
var Zh = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow renaming import, export, and destructured assignments to the same name",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-rename"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        ignoreDestructuring: {
          type: "boolean",
          default: !1
        },
        ignoreImport: {
          type: "boolean",
          default: !1
        },
        ignoreExport: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || {}, s = r.ignoreDestructuring === !0, n = r.ignoreImport === !0, a = r.ignoreExport === !0;
    function o(l, i, u) {
      const c = i.type === "Identifier" ? i.name : i.value;
      return t.report({
        node: l,
        messageId: "unnecessarilyRenamed",
        data: {
          name: c,
          type: u
        },
        fix(f) {
          const h = l.type === "Property" ? l.value : l.local;
          return e.getCommentsInside(l).length > e.getCommentsInside(h).length || h.type === "AssignmentPattern" && E.isParenthesised(e, h.left) ? null : f.replaceText(l, e.getText(h));
        }
      });
    }
    return {
      ObjectPattern: function(l) {
        if (!s)
          for (const i of l.properties) {
            if (i.type !== "Property" || i.shorthand || i.computed)
              continue;
            const u = i.key.type === "Identifier" && i.key.name || i.key.type === "Literal" && i.key.value, c = i.value.type === "AssignmentPattern" ? i.value.left.name : i.value.name;
            u === c && o(i, i.key, "Destructuring assignment");
          }
      },
      ImportSpecifier: function(l) {
        n || l.imported.name === l.local.name && l.imported.range[0] !== l.local.range[0] && o(l, l.imported, "Import");
      },
      ExportSpecifier: function(l) {
        a || l.local.name === l.exported.name && l.local.range[0] !== l.exported.range[0] && o(l, l.local, "Export");
      }
    };
  }
};
Zh.meta;
Zh.create;
function C6(t, e) {
  const r = t.indexOf(e);
  r !== -1 && t.splice(r, 1);
}
function S6(t) {
  return E.STATEMENT_LIST_PARENTS.has(t.parent.type);
}
function A6(t) {
  for (let e = t; e && e.parent && !E.isFunction(e); e = e.parent)
    if (e.parent.type === "TryStatement" && e.parent.finalizer === e)
      return !0;
  return !1;
}
var em = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow redundant return statements",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-useless-return"
    },
    fixable: "code",
    schema: [],
    messages: {
      unnecessaryReturn: "Unnecessary return statement."
    }
  },
  create(t) {
    const e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakSet(), s = t.getSourceCode();
    let n = null;
    function a(u) {
      const c = e.get(u);
      return !c || c.returned;
    }
    function o(u, c, f) {
      const h = f || /* @__PURE__ */ new WeakSet();
      for (const p of c) {
        if (!p.reachable) {
          h.has(p) || (h.add(p), o(u, p.allPrevSegments.filter(a), h));
          continue;
        }
        u.push(...e.get(p).uselessReturns);
      }
      return u;
    }
    function l(u) {
      if (!u.reachable) {
        r.add(u), u.allPrevSegments.filter(a).filter((f) => !r.has(f)).forEach(l);
        return;
      }
      const c = e.get(u);
      for (const f of c.uselessReturns)
        C6(n.uselessReturns, f);
      c.uselessReturns = [];
    }
    function i() {
      n.codePath.currentSegments.forEach(l);
    }
    return {
      onCodePathStart(u) {
        n = {
          upper: n,
          uselessReturns: [],
          codePath: u
        };
      },
      onCodePathEnd() {
        for (const u of n.uselessReturns)
          t.report({
            node: u,
            loc: u.loc,
            messageId: "unnecessaryReturn",
            fix(c) {
              return S6(u) && !s.getCommentsInside(u).length ? new Qs(c, s).retainEnclosingFunction(u).remove(u) : null;
            }
          });
        n = n.upper;
      },
      onCodePathSegmentStart(u) {
        const c = {
          uselessReturns: o([], u.allPrevSegments),
          returned: !1
        };
        e.set(u, c);
      },
      ReturnStatement(u) {
        if (u.argument && i(), !(u.argument || E.isInLoop(u) || A6(u) || !n.codePath.currentSegments.some((c) => c.reachable))) {
          for (const c of n.codePath.currentSegments) {
            const f = e.get(c);
            f && (f.uselessReturns.push(u), f.returned = !0);
          }
          n.uselessReturns.push(u);
        }
      },
      ClassDeclaration: i,
      ContinueStatement: i,
      DebuggerStatement: i,
      DoWhileStatement: i,
      EmptyStatement: i,
      ExpressionStatement: i,
      ForInStatement: i,
      ForOfStatement: i,
      ForStatement: i,
      IfStatement: i,
      ImportDeclaration: i,
      LabeledStatement: i,
      SwitchStatement: i,
      ThrowStatement: i,
      TryStatement: i,
      VariableDeclaration: i,
      WhileStatement: i,
      WithStatement: i,
      ExportNamedDeclaration: i,
      ExportDefaultDeclaration: i,
      ExportAllDeclaration: i
    };
  }
};
em.meta;
em.create;
function D6(t) {
  return !!t.scope && t.scope.type === "global";
}
function e0(t) {
  let e = t;
  for (; e.type !== "function" && e.type !== "global"; )
    e = e.upper;
  return e;
}
function w6(t) {
  const e = e0(t.scope);
  return t.references.some((r) => e0(r.from) !== e);
}
function t0(t) {
  return (t.parent.type === "ForOfStatement" || t.parent.type === "ForInStatement") && t === t.parent.left;
}
function k6(t) {
  return t.declarations.every((e) => e.init !== null);
}
const T6 = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;
function F6(t) {
  for (let e = t; e; e = e.parent)
    if (T6.test(e.type))
      return e;
  return null;
}
function P6(t) {
  return t.defs.length >= 2;
}
function I6(t) {
  function e(r) {
    const s = t.range, n = r.identifier.range;
    return n[0] < s[0] || n[1] > s[1];
  }
  return function(r) {
    return r.references.some(e);
  };
}
function _6(t) {
  const e = t.range[0], r = t.range[1];
  return (s) => {
    const n = s.defs[0].name, a = n.range[0], o = n.parent.type === "AssignmentPattern" ? n.parent.right : null, l = o && o.range[0], i = o && o.range[1];
    return s.references.some((u) => {
      const c = u.identifier.range[0], f = u.identifier.range[1];
      return !u.init && (c < a || o !== null && c >= l && f <= i || c >= e && f <= r);
    });
  };
}
function B6(t) {
  return t.name === "let";
}
var tm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `let` or `const` instead of `var`",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-var"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedVar: "Unexpected var, use let or const instead."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(a) {
      return a.init ? t.getDeclaredVariables(a).some(_6(a.init)) : !1;
    }
    function s(a) {
      const o = t.getDeclaredVariables(a), l = F6(a);
      return !(a.parent.type === "SwitchCase" || a.declarations.some(r) || o.some(D6) || o.some(P6) || o.some(I6(l)) || o.some(B6) || E.isInLoop(a) && (o.some(w6) || !t0(a) && !k6(a)) || !t0(a) && !(a.parent.type === "ForStatement" && a.parent.init === a) && !E.STATEMENT_LIST_PARENTS.has(a.parent.type));
    }
    function n(a) {
      t.report({
        node: a,
        messageId: "unexpectedVar",
        fix(o) {
          const l = e.getFirstToken(a, {
            filter: (i) => i.value === "var"
          });
          return s(a) ? o.replaceText(l, "let") : null;
        }
      });
    }
    return {
      "VariableDeclaration:exit"(a) {
        a.kind === "var" && n(a);
      }
    };
  }
};
tm.meta;
tm.create;
var rm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `void` operators",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-void"
    },
    messages: {
      noVoid: "Expected 'undefined' and instead saw 'void'."
    },
    schema: [{
      type: "object",
      properties: {
        allowAsStatement: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }]
  },
  create(t) {
    const e = t.options[0] && t.options[0].allowAsStatement;
    return {
      'UnaryExpression[operator="void"]'(r) {
        e && r.parent && r.parent.type === "ExpressionStatement" || t.report({
          node: r,
          messageId: "noVoid"
        });
      }
    };
  }
};
rm.meta;
rm.create;
const O6 = 40;
var nm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow specified warning terms in comments",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-warning-comments"
    },
    schema: [{
      type: "object",
      properties: {
        terms: {
          type: "array",
          items: {
            type: "string"
          }
        },
        location: {
          enum: ["start", "anywhere"]
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || {}, s = r.terms || ["todo", "fixme", "xxx"], n = r.location || "start", a = s.map(function(i) {
      const u = Ju.default(i);
      let c;
      const f = /\w$/u.test(i) ? "\\b" : "";
      return n === "start" ? c = "^\\s*" : /^\w/u.test(i) ? c = "\\b" : c = "", n === "start" ? new RegExp(c + u + f, "iu") : new RegExp(c + u + f + "|\\b" + i + "\\b", "iu");
    });
    function o(i) {
      const u = [];
      return a.forEach((c, f) => {
        c.test(i) && u.push(s[f]);
      }), u;
    }
    function l(i) {
      const u = i.value;
      if (E.isDirectiveComment(i) && /\bno-warning-comments\b/u.test(u))
        return;
      o(u).forEach((f) => {
        let h = "", p = !1;
        for (const m of u.trim().split(/\s+/u)) {
          const d = h ? `${h} ${m}` : m;
          if (d.length <= O6)
            h = d;
          else {
            p = !0;
            break;
          }
        }
        t.report({
          node: i,
          messageId: "unexpectedComment",
          data: {
            matchedTerm: f,
            comment: `${h}${p ? "..." : ""}`
          }
        });
      });
    }
    return {
      Program() {
        e.getAllComments().filter((u) => u.type !== "Shebang").forEach(l);
      }
    };
  }
};
nm.meta;
nm.create;
var sm = {
  meta: {
    type: "layout",
    docs: {
      description: "disallow whitespace before properties",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/no-whitespace-before-property"
    },
    fixable: "whitespace",
    schema: [],
    messages: {
      unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s, n, a) {
      t.report({
        node: s,
        messageId: "unexpectedWhitespace",
        data: {
          propName: e.getText(s.property)
        },
        fix(o) {
          let l = "";
          return !s.computed && !s.optional && E.isDecimalInteger(s.object) || e.commentsExistBetween(n, a) ? null : (s.optional ? l = "?." : s.computed || (l = "."), o.replaceTextRange([n.range[1], a.range[0]], l));
        }
      });
    }
    return {
      MemberExpression(s) {
        let n, a;
        E.isTokenOnSameLine(s.object, s.property) && (s.computed ? (n = e.getTokenBefore(s.property, E.isOpeningBracketToken), a = e.getTokenBefore(n, s.optional ? 1 : 0)) : (n = e.getFirstToken(s.property), a = e.getTokenBefore(n, 1)), e.isSpaceBetweenTokens(a, n) && r(s, a, n));
      }
    };
  }
};
sm.meta;
sm.create;
var am = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `with` statements",
      category: "Best Practices",
      recommended: !0,
      url: "https://eslint.org/docs/rules/no-with"
    },
    schema: [],
    messages: {
      unexpectedWith: "Unexpected use of 'with' statement."
    }
  },
  create(t) {
    return {
      WithStatement(e) {
        t.report({
          node: e,
          messageId: "unexpectedWith"
        });
      }
    };
  }
};
am.meta;
am.create;
const $n = {
  enum: ["beside", "below", "any"]
};
var im = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the location of single-line statements",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/nonblock-statement-body-position"
    },
    fixable: "whitespace",
    schema: [$n, {
      properties: {
        overrides: {
          properties: {
            if: $n,
            else: $n,
            while: $n,
            do: $n,
            for: $n
          },
          additionalProperties: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      expectNoLinebreak: "Expected no linebreak before this statement.",
      expectLinebreak: "Expected a linebreak before this statement."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(n) {
      return t.options[1] && t.options[1].overrides && t.options[1].overrides[n] || t.options[0] || "beside";
    }
    function s(n, a) {
      const o = r(a);
      if (n.type === "BlockStatement" || o === "any")
        return;
      const l = e.getTokenBefore(n);
      l.loc.end.line === n.loc.start.line && o === "below" ? t.report({
        node: n,
        messageId: "expectLinebreak",
        fix: (i) => i.insertTextBefore(n, `
`)
      }) : l.loc.end.line !== n.loc.start.line && o === "beside" && t.report({
        node: n,
        messageId: "expectNoLinebreak",
        fix(i) {
          return e.getText().slice(l.range[1], n.range[0]).trim() ? null : i.replaceTextRange([l.range[1], n.range[0]], " ");
        }
      });
    }
    return {
      IfStatement(n) {
        s(n.consequent, "if"), n.alternate && n.alternate.type !== "IfStatement" && s(n.alternate, "else");
      },
      WhileStatement: (n) => s(n.body, "while"),
      DoWhileStatement: (n) => s(n.body, "do"),
      ForStatement: (n) => s(n.body, "for"),
      ForInStatement: (n) => s(n.body, "for"),
      ForOfStatement: (n) => s(n.body, "for")
    };
  }
};
im.meta;
im.create;
const vs = {
  oneOf: [{
    enum: ["always", "never"]
  }, {
    type: "object",
    properties: {
      multiline: {
        type: "boolean"
      },
      minProperties: {
        type: "integer",
        minimum: 0
      },
      consistent: {
        type: "boolean"
      }
    },
    additionalProperties: !1,
    minProperties: 1
  }]
};
function Es(t) {
  let e = !1, r = Number.POSITIVE_INFINITY, s = !1;
  return t ? t === "always" ? r = 0 : t === "never" ? r = Number.POSITIVE_INFINITY : (e = !!t.multiline, r = t.minProperties || Number.POSITIVE_INFINITY, s = !!t.consistent) : s = !0, {
    multiline: e,
    minProperties: r,
    consistent: s
  };
}
function Bb(t) {
  return typeof t == "object" && t !== null;
}
function L6(t) {
  return Bb(t) || typeof t == "string";
}
function R6(t) {
  if (Bb(t) && Object.values(t).some(L6))
    return {
      ObjectExpression: Es(t.ObjectExpression),
      ObjectPattern: Es(t.ObjectPattern),
      ImportDeclaration: Es(t.ImportDeclaration),
      ExportNamedDeclaration: Es(t.ExportDeclaration)
    };
  const e = Es(t);
  return {
    ObjectExpression: e,
    ObjectPattern: e,
    ImportDeclaration: e,
    ExportNamedDeclaration: e
  };
}
function N6(t, e, r, s) {
  let n;
  return t.type === "ObjectExpression" || t.type === "ObjectPattern" ? n = t.properties : n = t.specifiers.filter((a) => a.type === "ImportSpecifier" || a.type === "ExportSpecifier"), n.length >= e.minProperties || e.multiline && n.length > 0 && r.loc.start.line !== s.loc.end.line;
}
var om = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent line breaks after opening and before closing braces",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/object-curly-newline"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [vs, {
        type: "object",
        properties: {
          ObjectExpression: vs,
          ObjectPattern: vs,
          ImportDeclaration: vs,
          ExportDeclaration: vs
        },
        additionalProperties: !1,
        minProperties: 1
      }]
    }],
    messages: {
      unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
      unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
      expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
      expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = R6(t.options[0]);
    function s(n) {
      const a = r[n.type];
      if (n.type === "ImportDeclaration" && !n.specifiers.some((p) => p.type === "ImportSpecifier") || n.type === "ExportNamedDeclaration" && !n.specifiers.some((p) => p.type === "ExportSpecifier"))
        return;
      const o = e.getFirstToken(n, (p) => p.value === "{");
      let l;
      n.typeAnnotation ? l = e.getTokenBefore(n.typeAnnotation) : l = e.getLastToken(n, (p) => p.value === "}");
      let i = e.getTokenAfter(o, {
        includeComments: !0
      }), u = e.getTokenBefore(l, {
        includeComments: !0
      });
      const c = N6(n, a, i, u), f = E.isCommentToken(i), h = E.isCommentToken(u);
      if (i = e.getTokenAfter(o), u = e.getTokenBefore(l), c)
        E.isTokenOnSameLine(o, i) && t.report({
          messageId: "expectedLinebreakAfterOpeningBrace",
          node: n,
          loc: o.loc,
          fix(p) {
            return f ? null : p.insertTextAfter(o, `
`);
          }
        }), E.isTokenOnSameLine(u, l) && t.report({
          messageId: "expectedLinebreakBeforeClosingBrace",
          node: n,
          loc: l.loc,
          fix(p) {
            return h ? null : p.insertTextBefore(l, `
`);
          }
        });
      else {
        const p = a.consistent, m = !E.isTokenOnSameLine(o, i), d = !E.isTokenOnSameLine(u, l);
        (!p && m || p && m && !d) && t.report({
          messageId: "unexpectedLinebreakAfterOpeningBrace",
          node: n,
          loc: o.loc,
          fix(g) {
            return f ? null : g.removeRange([o.range[1], i.range[0]]);
          }
        }), (!p && d || p && !m && d) && t.report({
          messageId: "unexpectedLinebreakBeforeClosingBrace",
          node: n,
          loc: l.loc,
          fix(g) {
            return h ? null : g.removeRange([u.range[1], l.range[0]]);
          }
        });
      }
    }
    return {
      ObjectExpression: s,
      ObjectPattern: s,
      ImportDeclaration: s,
      ExportNamedDeclaration: s
    };
  }
};
om.meta;
om.create;
var lm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside braces",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/object-curly-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        arraysInObjects: {
          type: "boolean"
        },
        objectsInObjects: {
          type: "boolean"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      requireSpaceBefore: "A space is required before '{{token}}'.",
      requireSpaceAfter: "A space is required after '{{token}}'.",
      unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
      unexpectedSpaceAfter: "There should be no space after '{{token}}'."
    }
  },
  create(t) {
    const e = t.options[0] === "always", r = t.getSourceCode();
    function s(h) {
      return t.options[1] ? t.options[1][h] === !e : !1;
    }
    const n = {
      spaced: e,
      arraysInObjectsException: s("arraysInObjects"),
      objectsInObjectsException: s("objectsInObjects")
    };
    function a(h, p) {
      const m = t.getSourceCode().getTokenAfter(p, {
        includeComments: !0
      });
      t.report({
        node: h,
        loc: {
          start: p.loc.end,
          end: m.loc.start
        },
        messageId: "unexpectedSpaceAfter",
        data: {
          token: p.value
        },
        fix(d) {
          return d.removeRange([p.range[1], m.range[0]]);
        }
      });
    }
    function o(h, p) {
      const m = t.getSourceCode().getTokenBefore(p, {
        includeComments: !0
      });
      t.report({
        node: h,
        loc: {
          start: m.loc.end,
          end: p.loc.start
        },
        messageId: "unexpectedSpaceBefore",
        data: {
          token: p.value
        },
        fix(d) {
          return d.removeRange([m.range[1], p.range[0]]);
        }
      });
    }
    function l(h, p) {
      t.report({
        node: h,
        loc: p.loc,
        messageId: "requireSpaceAfter",
        data: {
          token: p.value
        },
        fix(m) {
          return m.insertTextAfter(p, " ");
        }
      });
    }
    function i(h, p) {
      t.report({
        node: h,
        loc: p.loc,
        messageId: "requireSpaceBefore",
        data: {
          token: p.value
        },
        fix(m) {
          return m.insertTextBefore(p, " ");
        }
      });
    }
    function u(h, p, m, d, g) {
      if (E.isTokenOnSameLine(p, m)) {
        const y = r.isSpaceBetweenTokens(p, m);
        n.spaced && !y && l(h, p), !n.spaced && y && m.type !== "Line" && a(h, p);
      }
      if (E.isTokenOnSameLine(d, g)) {
        const x = (n.arraysInObjectsException && E.isClosingBracketToken(d) || n.objectsInObjectsException && E.isClosingBraceToken(d)) && r.getNodeByRangeIndex(d.range[0]).type, A = n.arraysInObjectsException && x === "ArrayExpression" || n.objectsInObjectsException && (x === "ObjectExpression" || x === "ObjectPattern") ? !n.spaced : n.spaced, b = r.isSpaceBetweenTokens(d, g);
        A && !b && i(h, g), !A && b && o(h, g);
      }
    }
    function c(h) {
      const p = h.properties[h.properties.length - 1];
      return r.getTokenAfter(p, E.isClosingBraceToken);
    }
    function f(h) {
      if (h.properties.length === 0)
        return;
      const p = r.getFirstToken(h), m = c(h), d = r.getTokenAfter(p, {
        includeComments: !0
      }), g = r.getTokenBefore(m, {
        includeComments: !0
      });
      u(h, p, d, g, m);
    }
    return {
      ObjectPattern: f,
      ObjectExpression: f,
      ImportDeclaration: function(h) {
        if (h.specifiers.length === 0)
          return;
        let p = h.specifiers[0];
        const m = h.specifiers[h.specifiers.length - 1];
        if (m.type !== "ImportSpecifier")
          return;
        p.type !== "ImportSpecifier" && (p = h.specifiers[1]);
        const d = r.getTokenBefore(p), g = r.getTokenAfter(m, E.isNotCommaToken), y = r.getTokenAfter(d, {
          includeComments: !0
        }), x = r.getTokenBefore(g, {
          includeComments: !0
        });
        u(h, d, y, x, g);
      },
      ExportNamedDeclaration: function(h) {
        if (h.specifiers.length === 0)
          return;
        const p = h.specifiers[0], m = h.specifiers[h.specifiers.length - 1], d = r.getTokenBefore(p), g = r.getTokenAfter(m, E.isNotCommaToken), y = r.getTokenAfter(d, {
          includeComments: !0
        }), x = r.getTokenBefore(g, {
          includeComments: !0
        });
        u(h, d, y, x, g);
      }
    };
  }
};
lm.meta;
lm.create;
var um = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce placing object properties on separate lines",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/object-property-newline"
    },
    schema: [{
      type: "object",
      properties: {
        allowAllPropertiesOnSameLine: {
          type: "boolean",
          default: !1
        },
        allowMultiplePropertiesPerLine: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "whitespace",
    messages: {
      propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
      propertiesOnNewline: "Object properties must go on a new line."
    }
  },
  create(t) {
    const e = t.options[0] && (t.options[0].allowAllPropertiesOnSameLine || t.options[0].allowMultiplePropertiesPerLine), r = e ? "propertiesOnNewlineAll" : "propertiesOnNewline", s = t.getSourceCode();
    return {
      ObjectExpression(n) {
        if (e && n.properties.length > 1) {
          const a = s.getFirstToken(n.properties[0]), o = s.getLastToken(n.properties[n.properties.length - 1]);
          if (a.loc.end.line === o.loc.start.line)
            return;
        }
        for (let a = 1; a < n.properties.length; a++) {
          const o = s.getLastToken(n.properties[a - 1]), l = s.getFirstToken(n.properties[a]);
          o.loc.end.line === l.loc.start.line && t.report({
            node: n,
            loc: l.loc,
            messageId: r,
            fix(i) {
              const c = [s.getTokenBefore(l).range[1], l.range[0]];
              return s.text.slice(c[0], c[1]).trim() ? null : i.replaceTextRange(c, `
`);
            }
          });
        }
      }
    };
  }
};
um.meta;
um.create;
const Jr = {
  always: "always",
  never: "never",
  methods: "methods",
  properties: "properties",
  consistent: "consistent",
  consistentAsNeeded: "consistent-as-needed"
};
var cm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow method and property shorthand syntax for object literals",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/object-shorthand"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always", "methods", "properties"]
        }, {
          type: "object",
          properties: {
            avoidQuotes: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }, {
        type: "array",
        items: [{
          enum: ["always", "methods"]
        }, {
          type: "object",
          properties: {
            ignoreConstructors: {
              type: "boolean"
            },
            avoidQuotes: {
              type: "boolean"
            },
            avoidExplicitReturnArrows: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      expectedAllPropertiesShorthanded: "Expected shorthand for all properties.",
      expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.",
      expectedPropertyShorthand: "Expected property shorthand.",
      expectedPropertyLongform: "Expected longform property syntax.",
      expectedMethodShorthand: "Expected method shorthand.",
      expectedMethodLongform: "Expected longform method syntax.",
      unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties."
    }
  },
  create(t) {
    const e = t.options[0] || Jr.always, r = e === Jr.methods || e === Jr.always, s = e === Jr.properties || e === Jr.always, n = e === Jr.never, a = e === Jr.consistent, o = e === Jr.consistentAsNeeded, l = t.options[1] || {}, i = l.ignoreConstructors, u = l.avoidQuotes, c = !!l.avoidExplicitReturnArrows, f = t.getSourceCode();
    function h(I) {
      const _ = /[^_$0-9]/u.exec(I);
      if (!_)
        return !1;
      const S = I.charAt(_.index);
      return S === S.toUpperCase();
    }
    function p(I) {
      return I.kind !== "set" && I.kind !== "get" && I.type !== "SpreadElement" && I.type !== "SpreadProperty" && I.type !== "ExperimentalSpreadProperty";
    }
    function m(I) {
      return I.type === "Literal" && typeof I.value == "string";
    }
    function d(I) {
      return I.shorthand || I.method;
    }
    function g(I) {
      const _ = I.value;
      return _.type === "FunctionExpression" ? !_.id : _.type === "Identifier" ? E.getStaticPropertyName(I) === _.name : !1;
    }
    function y(I, _) {
      const S = I.properties.filter(p);
      if (S.length > 0) {
        const F = S.filter(d);
        F.length !== S.length && (F.length > 0 ? t.report({
          node: I,
          messageId: "unexpectedMix"
        }) : _ && S.every(g) && t.report({
          node: I,
          messageId: "expectedAllPropertiesShorthanded"
        }));
      }
    }
    function x(I, _) {
      const S = _.computed ? f.getFirstToken(_, E.isOpeningBracketToken) : f.getFirstToken(_.key), F = _.computed ? f.getFirstTokenBetween(_.key, _.value, E.isClosingBracketToken) : f.getLastToken(_.key), N = f.text.slice(S.range[0], F.range[1]);
      let k = "";
      if (f.commentsExistBetween(F, _.value))
        return null;
      _.value.async && (k += "async "), _.value.generator && (k += "*");
      const j = [S.range[0], _.range[1]], O = k + N;
      if (_.value.type === "FunctionExpression") {
        const H = f.getTokens(_.value).find((ge) => ge.type === "Keyword" && ge.value === "function"), Q = _.value.generator ? f.getTokenAfter(H) : H;
        return I.replaceTextRange(j, O + f.text.slice(Q.range[1], _.value.range[1]));
      }
      const z = f.getTokenBefore(_.value.body, E.isArrowToken), te = f.text.slice(z.range[1], _.value.range[1]);
      let se = !1, ye;
      if (_.value.params.length === 0 ? ye = f.getFirstToken(_.value, E.isOpeningParenToken) : ye = f.getTokenBefore(_.value.params[0]), _.value.params.length === 1) {
        const H = E.isOpeningParenToken(ye), Q = ye.range[0] < _.range[0];
        se = !H || Q;
      }
      const Se = se ? _.value.params[0].range[0] : ye.range[0], xe = f.getTokenBefore(z).range[1], Ae = f.text.slice(Se, xe), _e = se ? `(${Ae})` : Ae;
      return I.replaceTextRange(j, O + _e + te);
    }
    function A(I, _) {
      const S = _.computed ? f.getTokens(_).find((j) => j.value === "[") : f.getFirstToken(_.key), F = _.computed ? f.getTokensBetween(_.key, _.value).find((j) => j.value === "]") : f.getLastToken(_.key), N = f.text.slice(S.range[0], F.range[1]);
      let k = "function";
      return _.value.async && (k = `async ${k}`), _.value.generator && (k = `${k}*`), I.replaceTextRange([_.range[0], F.range[1]], `${N}: ${k}`);
    }
    const b = [], v = /* @__PURE__ */ new WeakSet(), C = /* @__PURE__ */ new WeakSet();
    function T() {
      b.unshift(/* @__PURE__ */ new Set()), t.getScope().variables.filter((I) => I.name === "arguments").forEach((I) => {
        I.references.map((_) => _.identifier).forEach((_) => C.add(_));
      });
    }
    function w() {
      b.shift();
    }
    function B() {
      b[0].forEach((I) => v.add(I));
    }
    return {
      Program: T,
      FunctionDeclaration: T,
      FunctionExpression: T,
      "Program:exit": w,
      "FunctionDeclaration:exit": w,
      "FunctionExpression:exit": w,
      ArrowFunctionExpression(I) {
        b[0].add(I);
      },
      "ArrowFunctionExpression:exit"(I) {
        b[0].delete(I);
      },
      ThisExpression: B,
      Super: B,
      MetaProperty(I) {
        I.meta.name === "new" && I.property.name === "target" && B();
      },
      Identifier(I) {
        C.has(I) && B();
      },
      ObjectExpression(I) {
        a ? y(I, !1) : o && y(I, !0);
      },
      "Property:exit"(I) {
        const _ = I.method || I.shorthand;
        if (I.parent.type !== "ObjectPattern" && !(I.kind === "get" || I.kind === "set") && !(I.computed && I.value.type !== "FunctionExpression" && I.value.type !== "ArrowFunctionExpression")) {
          if (_)
            if (I.method && (n || u && m(I.key))) {
              const S = n ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
              t.report({
                node: I,
                messageId: S,
                fix: (F) => A(F, I)
              });
            } else
              n && t.report({
                node: I,
                messageId: "expectedPropertyLongform",
                fix: (S) => S.insertTextAfter(I.key, `: ${I.key.name}`)
              });
          else if (r && !I.value.id && (I.value.type === "FunctionExpression" || I.value.type === "ArrowFunctionExpression")) {
            if (i && I.key.type === "Identifier" && h(I.key.name) || u && m(I.key))
              return;
            (I.value.type === "FunctionExpression" || I.value.type === "ArrowFunctionExpression" && I.value.body.type === "BlockStatement" && c && !v.has(I.value)) && t.report({
              node: I,
              messageId: "expectedMethodShorthand",
              fix: (S) => x(S, I)
            });
          } else if (I.value.type === "Identifier" && I.key.name === I.value.name && s)
            t.report({
              node: I,
              messageId: "expectedPropertyShorthand",
              fix(S) {
                return S.replaceText(I, I.value.name);
              }
            });
          else if (I.value.type === "Identifier" && I.key.type === "Literal" && I.key.value === I.value.name && s) {
            if (u)
              return;
            t.report({
              node: I,
              messageId: "expectedPropertyShorthand",
              fix(S) {
                return S.replaceText(I, I.value.name);
              }
            });
          }
        }
      }
    };
  }
};
cm.meta;
cm.create;
var pm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow newlines around variable declarations",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/one-var-declaration-per-line"
    },
    schema: [{
      enum: ["always", "initializations"]
    }],
    fixable: "whitespace",
    messages: {
      expectVarOnNewline: "Expected variable declaration to be on a new line."
    }
  },
  create(t) {
    const e = t.options[0] === "always";
    function r(s) {
      return s === "ForStatement" || s === "ForInStatement" || s === "ForOfStatement";
    }
    return {
      VariableDeclaration: function(s) {
        if (r(s.parent.type))
          return;
        const n = s.declarations;
        let a;
        n.forEach((o) => {
          a && a.loc.end.line === o.loc.start.line && (e || a.init || o.init) && t.report({
            node: s,
            messageId: "expectVarOnNewline",
            loc: o.loc,
            fix: (l) => l.insertTextBefore(o, `
`)
          }), a = o;
        });
      }
    };
  }
};
pm.meta;
pm.create;
function j6(t) {
  return E.STATEMENT_LIST_PARENTS.has(t.parent.type);
}
var fm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce variables to be declared either together or separately in functions",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/one-var"
    },
    fixable: "code",
    schema: [{
      oneOf: [{
        enum: ["always", "never", "consecutive"]
      }, {
        type: "object",
        properties: {
          separateRequires: {
            type: "boolean"
          },
          var: {
            enum: ["always", "never", "consecutive"]
          },
          let: {
            enum: ["always", "never", "consecutive"]
          },
          const: {
            enum: ["always", "never", "consecutive"]
          }
        },
        additionalProperties: !1
      }, {
        type: "object",
        properties: {
          initialized: {
            enum: ["always", "never", "consecutive"]
          },
          uninitialized: {
            enum: ["always", "never", "consecutive"]
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
      combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.",
      splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.",
      splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.",
      splitRequires: "Split requires to be separated into a single block.",
      combine: "Combine this with the previous '{{type}}' statement.",
      split: "Split '{{type}}' declarations into multiple statements."
    }
  },
  create(t) {
    const e = "always", r = "never", s = "consecutive", n = t.options[0] || "always", a = {};
    typeof n == "string" ? (a.var = {
      uninitialized: n,
      initialized: n
    }, a.let = {
      uninitialized: n,
      initialized: n
    }, a.const = {
      uninitialized: n,
      initialized: n
    }) : typeof n == "object" && (a.separateRequires = !!n.separateRequires, a.var = {
      uninitialized: n.var,
      initialized: n.var
    }, a.let = {
      uninitialized: n.let,
      initialized: n.let
    }, a.const = {
      uninitialized: n.const,
      initialized: n.const
    }, Object.prototype.hasOwnProperty.call(n, "uninitialized") && (a.var.uninitialized = n.uninitialized, a.let.uninitialized = n.uninitialized, a.const.uninitialized = n.uninitialized), Object.prototype.hasOwnProperty.call(n, "initialized") && (a.var.initialized = n.initialized, a.let.initialized = n.initialized, a.const.initialized = n.initialized));
    const o = t.getSourceCode(), l = [], i = [];
    function u() {
      i.push({
        let: {
          initialized: !1,
          uninitialized: !1
        },
        const: {
          initialized: !1,
          uninitialized: !1
        }
      });
    }
    function c() {
      l.push({
        initialized: !1,
        uninitialized: !1
      }), u();
    }
    function f() {
      i.pop();
    }
    function h() {
      l.pop(), f();
    }
    function p(b) {
      return b.init && b.init.type === "CallExpression" && b.init.callee.name === "require";
    }
    function m(b, v, C) {
      for (let T = 0; T < v.length; T++)
        v[T].init === null ? a[b] && a[b].uninitialized === e && (C.uninitialized = !0) : a[b] && a[b].initialized === e && (a.separateRequires && p(v[T]) ? C.required = !0 : C.initialized = !0);
    }
    function d(b) {
      let v;
      return b === "var" ? v = l[l.length - 1] : b === "let" ? v = i[i.length - 1].let : b === "const" && (v = i[i.length - 1].const), v;
    }
    function g(b) {
      const v = {
        uninitialized: 0,
        initialized: 0
      };
      for (let C = 0; C < b.length; C++)
        b[C].init === null ? v.uninitialized++ : v.initialized++;
      return v;
    }
    function y(b, v) {
      const C = g(v), T = a[b] || {}, w = d(b), B = v.some(p);
      return T.uninitialized === e && T.initialized === e && (w.uninitialized || w.initialized) && !B || C.uninitialized > 0 && T.uninitialized === e && w.uninitialized || C.initialized > 0 && T.initialized === e && w.initialized && !B || w.required && B ? !1 : (m(b, v, w), !0);
    }
    function x(b) {
      const v = b[0], C = Array.isArray(v.parent.parent.body) ? v.parent.parent.body : [], T = C.findIndex((B) => B.range[0] === v.parent.range[0]), w = C[T - 1];
      return (B) => {
        const I = o.getTokenBefore(v), _ = o.getTokenBefore(I), S = [];
        return w && w.kind === o.getText(I) && (_.value === ";" ? S.push(B.replaceText(_, ",")) : S.push(B.insertTextAfter(_, ",")), S.push(B.replaceText(I, ""))), S;
      };
    }
    function A(b) {
      const {
        parent: v
      } = b;
      return j6(v.type === "ExportNamedDeclaration" ? v : b) ? (C) => b.declarations.map((T) => {
        const w = o.getTokenAfter(T);
        if (w === null)
          return null;
        const B = o.getTokenAfter(w, {
          includeComments: !0
        });
        if (w.value !== ",")
          return null;
        const I = b.parent.type === "ExportNamedDeclaration" ? "export " : "";
        if (B.range[0] === w.range[1])
          return C.replaceText(w, `; ${I}${b.kind} `);
        if (B.loc.start.line > w.loc.end.line || B.type === "Line" || B.type === "Block") {
          let _ = B;
          for (; _.type === "Line" || _.type === "Block"; )
            _ = o.getTokenAfter(_, {
              includeComments: !0
            });
          return C.replaceTextRange([w.range[0], _.range[0]], `;${o.text.slice(w.range[1], _.range[0])}${I}${b.kind} `);
        }
        return C.replaceText(w, `; ${I}${b.kind}`);
      }).filter((T) => T) : null;
    }
    return {
      Program: c,
      FunctionDeclaration: c,
      FunctionExpression: c,
      ArrowFunctionExpression: c,
      BlockStatement: u,
      ForStatement: u,
      ForInStatement: u,
      ForOfStatement: u,
      SwitchStatement: u,
      VariableDeclaration: function(b) {
        const v = b.parent, C = b.kind;
        if (!a[C])
          return;
        const T = b.declarations, w = g(T), B = T.some(p) && !T.every(p);
        a[C].initialized === e && a.separateRequires && B && t.report({
          node: b,
          messageId: "splitRequires"
        });
        const I = v.body && v.body.length > 0 && v.body.indexOf(b) || 0;
        if (I > 0) {
          const _ = v.body[I - 1], S = _.type === "VariableDeclaration", F = T.concat(_.declarations || []);
          if (S && _.kind === C && !(F.some(p) && !F.every(p))) {
            const N = g(_.declarations);
            a[C].initialized === s && a[C].uninitialized === s ? t.report({
              node: b,
              messageId: "combine",
              data: {
                type: C
              },
              fix: x(T)
            }) : a[C].initialized === s && w.initialized > 0 && N.initialized > 0 ? t.report({
              node: b,
              messageId: "combineInitialized",
              data: {
                type: C
              },
              fix: x(T)
            }) : a[C].uninitialized === s && w.uninitialized > 0 && N.uninitialized > 0 && t.report({
              node: b,
              messageId: "combineUninitialized",
              data: {
                type: C
              },
              fix: x(T)
            });
          }
        }
        if (!y(C, T)) {
          if (a[C].initialized === e && a[C].uninitialized === e)
            t.report({
              node: b,
              messageId: "combine",
              data: {
                type: C
              },
              fix: x(T)
            });
          else if (a[C].initialized === e && w.initialized > 0 && t.report({
            node: b,
            messageId: "combineInitialized",
            data: {
              type: C
            },
            fix: x(T)
          }), a[C].uninitialized === e && w.uninitialized > 0) {
            if (b.parent.left === b && (b.parent.type === "ForInStatement" || b.parent.type === "ForOfStatement"))
              return;
            t.report({
              node: b,
              messageId: "combineUninitialized",
              data: {
                type: C
              },
              fix: x(T)
            });
          }
        }
        (v.type !== "ForStatement" || v.init !== b) && w.uninitialized + w.initialized > 1 && (a[C].initialized === r && a[C].uninitialized === r ? t.report({
          node: b,
          messageId: "split",
          data: {
            type: C
          },
          fix: A(b)
        }) : a[C].initialized === r && w.initialized > 0 ? t.report({
          node: b,
          messageId: "splitInitialized",
          data: {
            type: C
          },
          fix: A(b)
        }) : a[C].uninitialized === r && w.uninitialized > 0 && t.report({
          node: b,
          messageId: "splitUninitialized",
          data: {
            type: C
          },
          fix: A(b)
        }));
      },
      "ForStatement:exit": f,
      "ForOfStatement:exit": f,
      "ForInStatement:exit": f,
      "SwitchStatement:exit": f,
      "BlockStatement:exit": f,
      "Program:exit": h,
      "FunctionDeclaration:exit": h,
      "FunctionExpression:exit": h,
      "ArrowFunctionExpression:exit": h
    };
  }
};
fm.meta;
fm.create;
function r0(t) {
  return ["*", "&", "^", "|"].indexOf(t) >= 0;
}
function M6(t) {
  return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(t) >= 0;
}
function Ho(t) {
  return t.type === "Identifier" || t.type === "MemberExpression" && (t.object.type === "Identifier" || t.object.type === "ThisExpression") && (!t.computed || t.property.type === "Literal");
}
var hm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow assignment operator shorthand where possible",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/operator-assignment"
    },
    schema: [{
      enum: ["always", "never"]
    }],
    fixable: "code",
    messages: {
      replaced: "Assignment (=) can be replaced with operator assignment ({{operator}}=).",
      unexpected: "Unexpected operator assignment ({{operator}}=) shorthand."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s) {
      return e.getFirstTokenBetween(s.left, s.right, (n) => n.value === s.operator);
    }
    return {
      AssignmentExpression: t.options[0] !== "never" ? function(s) {
        if (s.operator !== "=" || s.right.type !== "BinaryExpression")
          return;
        const n = s.left, a = s.right, o = a.operator;
        (r0(o) || M6(o)) && (E.isSameReference(n, a.left, !0) ? t.report({
          node: s,
          messageId: "replaced",
          data: {
            operator: o
          },
          fix(l) {
            if (Ho(n) && Ho(a.left)) {
              const i = r(s), u = r(a), c = e.getText().slice(s.range[0], i.range[0]), f = e.getText().slice(u.range[1], s.right.range[1]);
              return e.commentsExistBetween(i, u) ? null : l.replaceText(s, `${c}${a.operator}=${f}`);
            }
            return null;
          }
        }) : E.isSameReference(n, a.right, !0) && r0(o) && t.report({
          node: s,
          messageId: "replaced",
          data: {
            operator: o
          }
        }));
      } : function(s) {
        s.operator !== "=" && !E.isLogicalAssignmentOperator(s.operator) && t.report({
          node: s,
          messageId: "unexpected",
          data: {
            operator: s.operator
          },
          fix(n) {
            if (Ho(s.left)) {
              const a = e.getFirstToken(s), o = r(s), l = e.getText().slice(s.range[0], o.range[0]), i = s.operator.slice(0, -1);
              let u;
              if (e.commentsExistBetween(a, o))
                return null;
              if (E.getPrecedence(s.right) <= E.getPrecedence({
                type: "BinaryExpression",
                operator: i
              }) && !E.isParenthesised(e, s.right))
                u = `${e.text.slice(o.range[1], s.right.range[0])}(${e.getText(s.right)})`;
              else {
                const c = e.getTokenAfter(o, {
                  includeComments: !0
                });
                let f = "";
                o.range[1] === c.range[0] && !E.canTokensBeAdjacent({
                  type: "Punctuator",
                  value: i
                }, c) && (f = " "), u = `${f}${e.text.slice(o.range[1], s.range[1])}`;
              }
              return n.replaceText(s, `${l}= ${l}${i}${u}`);
            }
            return null;
          }
        });
      }
    };
  }
};
hm.meta;
hm.create;
var mm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent linebreak style for operators",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/operator-linebreak"
    },
    schema: [{
      enum: ["after", "before", "none", null]
    }, {
      type: "object",
      properties: {
        overrides: {
          type: "object",
          additionalProperties: {
            enum: ["after", "before", "none", "ignore"]
          }
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
      operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
      badLinebreak: "Bad line breaking before and after '{{operator}}'.",
      noLinebreak: "There should be no line break before or after '{{operator}}'."
    }
  },
  create(t) {
    const e = !t.options[0], r = t.options[0] || "after", s = t.options[1] || {}, n = s.overrides ? Object.assign({}, s.overrides) : {};
    e && !n["?"] && (n["?"] = "before"), e && !n[":"] && (n[":"] = "before");
    const a = t.getSourceCode();
    function o(u, c) {
      return (f) => {
        const h = a.getTokenBefore(u), p = a.getTokenAfter(u), m = a.text.slice(h.range[1], u.range[0]), d = a.text.slice(u.range[1], p.range[0]), g = !E.isTokenOnSameLine(h, u), y = !E.isTokenOnSameLine(u, p);
        let x, A;
        if (g !== y && c !== "none") {
          if (a.getTokenBefore(u, {
            includeComments: !0
          }) !== h && a.getTokenAfter(u, {
            includeComments: !0
          }) !== p)
            return null;
          x = d, A = m;
        } else {
          const b = E.createGlobalLinebreakMatcher();
          if (x = c === "before" || m.trim() ? m : m.replace(b, ""), A = c === "after" || d.trim() ? d : d.replace(b, ""), x === m && A === d)
            return null;
        }
        return A === "" && p.type === "Punctuator" && "+-".includes(u.value) && p.value === u.value && (A += " "), f.replaceTextRange([h.range[1], p.range[0]], x + u.value + A);
      };
    }
    function l(u, c) {
      const f = a.getTokenAfter(c, E.isNotClosingParenToken), h = a.getTokenBefore(f), p = a.getTokenAfter(f), m = f.value, d = n[m], g = d || r, y = o(f, g);
      E.isTokenOnSameLine(h, f) && E.isTokenOnSameLine(f, p) || (d !== "ignore" && !E.isTokenOnSameLine(h, f) && !E.isTokenOnSameLine(f, p) ? t.report({
        node: u,
        loc: f.loc,
        messageId: "badLinebreak",
        data: {
          operator: m
        },
        fix: y
      }) : g === "before" && E.isTokenOnSameLine(h, f) ? t.report({
        node: u,
        loc: f.loc,
        messageId: "operatorAtBeginning",
        data: {
          operator: m
        },
        fix: y
      }) : g === "after" && E.isTokenOnSameLine(f, p) ? t.report({
        node: u,
        loc: f.loc,
        messageId: "operatorAtEnd",
        data: {
          operator: m
        },
        fix: y
      }) : g === "none" && t.report({
        node: u,
        loc: f.loc,
        messageId: "noLinebreak",
        data: {
          operator: m
        },
        fix: y
      }));
    }
    function i(u) {
      l(u, u.left);
    }
    return {
      BinaryExpression: i,
      LogicalExpression: i,
      AssignmentExpression: i,
      VariableDeclarator(u) {
        u.init && l(u, u.id);
      },
      ConditionalExpression(u) {
        l(u, u.test), l(u, u.consequent);
      }
    };
  }
};
mm.meta;
mm.create;
var dm = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow padding within blocks",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/padded-blocks"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          blocks: {
            enum: ["always", "never"]
          },
          switches: {
            enum: ["always", "never"]
          },
          classes: {
            enum: ["always", "never"]
          }
        },
        additionalProperties: !1,
        minProperties: 1
      }]
    }, {
      type: "object",
      properties: {
        allowSingleLineBlocks: {
          type: "boolean"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      alwaysPadBlock: "Block must be padded by blank lines.",
      neverPadBlock: "Block must not be padded by blank lines."
    }
  },
  create(t) {
    const e = {}, r = t.options[0] || "always", s = t.options[1] || {};
    if (typeof r == "string") {
      const p = r === "always";
      e.blocks = p, e.switches = p, e.classes = p;
    } else
      Object.prototype.hasOwnProperty.call(r, "blocks") && (e.blocks = r.blocks === "always"), Object.prototype.hasOwnProperty.call(r, "switches") && (e.switches = r.switches === "always"), Object.prototype.hasOwnProperty.call(r, "classes") && (e.classes = r.classes === "always");
    Object.prototype.hasOwnProperty.call(s, "allowSingleLineBlocks") && (e.allowSingleLineBlocks = s.allowSingleLineBlocks === !0);
    const n = t.getSourceCode();
    function a(p) {
      return p.type === "SwitchStatement" ? n.getTokenBefore(p.cases[0]) : n.getFirstToken(p);
    }
    function o(p) {
      return p.type === "Line" || p.type === "Block";
    }
    function l(p, m) {
      return m.loc.start.line - p.loc.end.line >= 2;
    }
    function i(p) {
      let m, d = p;
      do
        m = d, d = n.getTokenAfter(d, {
          includeComments: !0
        });
      while (o(d) && d.loc.start.line === m.loc.end.line);
      return d;
    }
    function u(p) {
      let m = p, d;
      do
        d = m, m = n.getTokenBefore(m, {
          includeComments: !0
        });
      while (o(m) && m.loc.end.line === d.loc.start.line);
      return m;
    }
    function c(p) {
      switch (p.type) {
        case "BlockStatement":
          return e.blocks;
        case "SwitchStatement":
          return e.switches;
        case "ClassBody":
          return e.classes;
        default:
          throw new Error("unreachable");
      }
    }
    function f(p) {
      const m = a(p), d = i(m), g = n.getTokenBefore(d, {
        includeComments: !0
      }), y = n.getLastToken(p), x = u(y), A = n.getTokenAfter(x, {
        includeComments: !0
      }), b = l(g, d), v = l(x, A);
      e.allowSingleLineBlocks && E.isTokenOnSameLine(g, A) || (c(p) ? (b || t.report({
        node: p,
        loc: {
          start: g.loc.start,
          end: d.loc.start
        },
        fix(C) {
          return C.insertTextAfter(g, `
`);
        },
        messageId: "alwaysPadBlock"
      }), v || t.report({
        node: p,
        loc: {
          end: A.loc.start,
          start: x.loc.end
        },
        fix(C) {
          return C.insertTextBefore(A, `
`);
        },
        messageId: "alwaysPadBlock"
      })) : (b && t.report({
        node: p,
        loc: {
          start: g.loc.start,
          end: d.loc.start
        },
        fix(C) {
          return C.replaceTextRange([g.range[1], d.range[0] - d.loc.start.column], `
`);
        },
        messageId: "neverPadBlock"
      }), v && t.report({
        node: p,
        loc: {
          end: A.loc.start,
          start: x.loc.end
        },
        messageId: "neverPadBlock",
        fix(C) {
          return C.replaceTextRange([x.range[1], A.range[0] - A.loc.start.column], `
`);
        }
      })));
    }
    const h = {};
    return Object.prototype.hasOwnProperty.call(e, "switches") && (h.SwitchStatement = function(p) {
      p.cases.length !== 0 && f(p);
    }), Object.prototype.hasOwnProperty.call(e, "blocks") && (h.BlockStatement = function(p) {
      p.body.length !== 0 && f(p);
    }), Object.prototype.hasOwnProperty.call(e, "classes") && (h.ClassBody = function(p) {
      p.body.length !== 0 && f(p);
    }), h;
  }
};
dm.meta;
dm.create;
`${Array.from(E.LINEBREAKS).join("")}`;
const $6 = new RegExp("^(\\s*?)\\s*(\\s*;?)$", "u"), V6 = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u, U6 = /^require\(/u;
function Ct(t) {
  return {
    test: (e, r) => r.getFirstToken(e).value === t
  };
}
function Ko(t) {
  return {
    test: (e, r) => e.loc.start.line === e.loc.end.line && r.getFirstToken(e).value === t
  };
}
function Jo(t) {
  return {
    test: (e, r) => e.loc.start.line !== e.loc.end.line && r.getFirstToken(e).value === t
  };
}
function Xo(t) {
  return {
    test: (e) => e.type === t
  };
}
function Ob(t) {
  if (t.type === "ExpressionStatement") {
    let e = E.skipChainExpression(t.expression);
    return e.type === "UnaryExpression" && (e = E.skipChainExpression(e.argument)), e.type === "CallExpression" && E.isFunction(e.callee);
  }
  return !1;
}
function n0(t, e) {
  if (e.type === "DoWhileStatement" && e.body.type === "BlockStatement" || Ob(e))
    return !0;
  const r = t.getLastToken(e, E.isNotSemicolonToken), s = r && E.isClosingBraceToken(r) ? t.getNodeByRangeIndex(r.range[0]) : null;
  return !!s && (s.type === "BlockStatement" || s.type === "SwitchStatement");
}
function s0(t, e) {
  return t.type === "ExpressionStatement" && (t.parent.type === "Program" || t.parent.type === "BlockStatement" && E.isFunction(t.parent.parent)) && t.expression.type === "Literal" && typeof t.expression.value == "string" && !E.isParenthesised(e, t.expression);
}
function Qo(t, e) {
  if (s0(t, e)) {
    for (const r of t.parent.body) {
      if (r === t)
        break;
      if (!s0(r, e))
        return !1;
    }
    return !0;
  }
  return !1;
}
function Lb(t, e) {
  const r = t.getLastToken(e), s = t.getTokenBefore(r), n = t.getTokenAfter(r);
  return !!(s && n && s.range[0] >= e.range[0] && E.isSemicolonToken(r) && r.loc.start.line !== s.loc.end.line && r.loc.end.line === n.loc.start.line) ? s : r;
}
function q6(t, e, r) {
  return e + r;
}
function W6() {
}
function z6(t, e, r, s) {
  s.length !== 0 && t.report({
    node: r,
    messageId: "unexpectedBlankLine",
    fix(n) {
      if (s.length >= 2)
        return null;
      const a = s[0][0], o = s[0][1], l = a.range[1], i = o.range[0], u = t.getSourceCode().text.slice(l, i).replace($6, q6);
      return n.replaceTextRange([l, i], u);
    }
  });
}
function G6(t, e, r, s) {
  s.length > 0 || t.report({
    node: r,
    messageId: "expectedBlankLine",
    fix(n) {
      const a = t.getSourceCode();
      let o = Lb(a, e);
      const l = a.getFirstTokenBetween(o, r, {
        includeComments: !0,
        filter(u) {
          return E.isTokenOnSameLine(o, u) ? (o = u, !1) : !0;
        }
      }) || r, i = E.isTokenOnSameLine(o, l) ? `

` : `
`;
      return n.insertTextAfter(o, i);
    }
  });
}
const Yo = {
  any: {
    verify: W6
  },
  never: {
    verify: z6
  },
  always: {
    verify: G6
  }
}, Zo = {
  "*": {
    test: () => !0
  },
  "block-like": {
    test: (t, e) => n0(e, t)
  },
  "cjs-export": {
    test: (t, e) => t.type === "ExpressionStatement" && t.expression.type === "AssignmentExpression" && V6.test(e.getText(t.expression.left))
  },
  "cjs-import": {
    test: (t, e) => t.type === "VariableDeclaration" && t.declarations.length > 0 && !!t.declarations[0].init && U6.test(e.getText(t.declarations[0].init))
  },
  directive: {
    test: Qo
  },
  expression: {
    test: (t, e) => t.type === "ExpressionStatement" && !Qo(t, e)
  },
  iife: {
    test: Ob
  },
  "multiline-block-like": {
    test: (t, e) => t.loc.start.line !== t.loc.end.line && n0(e, t)
  },
  "multiline-expression": {
    test: (t, e) => t.loc.start.line !== t.loc.end.line && t.type === "ExpressionStatement" && !Qo(t, e)
  },
  "multiline-const": Jo("const"),
  "multiline-let": Jo("let"),
  "multiline-var": Jo("var"),
  "singleline-const": Ko("const"),
  "singleline-let": Ko("let"),
  "singleline-var": Ko("var"),
  block: Xo("BlockStatement"),
  empty: Xo("EmptyStatement"),
  function: Xo("FunctionDeclaration"),
  break: Ct("break"),
  case: Ct("case"),
  class: Ct("class"),
  const: Ct("const"),
  continue: Ct("continue"),
  debugger: Ct("debugger"),
  default: Ct("default"),
  do: Ct("do"),
  export: Ct("export"),
  for: Ct("for"),
  if: Ct("if"),
  import: Ct("import"),
  let: Ct("let"),
  return: Ct("return"),
  switch: Ct("switch"),
  throw: Ct("throw"),
  try: Ct("try"),
  var: Ct("var"),
  while: Ct("while"),
  with: Ct("with")
};
var gm = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow padding lines between statements",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/padding-line-between-statements"
    },
    fixable: "whitespace",
    schema: {
      definitions: {
        paddingType: {
          enum: Object.keys(Yo)
        },
        statementType: {
          anyOf: [{
            enum: Object.keys(Zo)
          }, {
            type: "array",
            items: {
              enum: Object.keys(Zo)
            },
            minItems: 1,
            uniqueItems: !0,
            additionalItems: !1
          }]
        }
      },
      type: "array",
      items: {
        type: "object",
        properties: {
          blankLine: {
            $ref: "#/definitions/paddingType"
          },
          prev: {
            $ref: "#/definitions/statementType"
          },
          next: {
            $ref: "#/definitions/statementType"
          }
        },
        additionalProperties: !1,
        required: ["blankLine", "prev", "next"]
      },
      additionalItems: !1
    },
    messages: {
      unexpectedBlankLine: "Unexpected blank line before this statement.",
      expectedBlankLine: "Expected blank line before this statement."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options || [];
    let s = null;
    function n() {
      s = {
        upper: s,
        prevNode: null
      };
    }
    function a() {
      s = s.upper;
    }
    function o(c, f) {
      let h = c;
      for (; h.type === "LabeledStatement"; )
        h = h.body;
      return Array.isArray(f) ? f.some(o.bind(null, h)) : Zo[f].test(h, e);
    }
    function l(c, f) {
      for (let h = r.length - 1; h >= 0; --h) {
        const p = r[h];
        if (o(c, p.prev) && o(f, p.next))
          return Yo[p.blankLine];
      }
      return Yo.any;
    }
    function i(c, f) {
      const h = [];
      let p = Lb(e, c);
      if (f.loc.start.line - p.loc.end.line >= 2)
        do {
          const m = e.getTokenAfter(p, {
            includeComments: !0
          });
          m.loc.start.line - p.loc.end.line >= 2 && h.push([p, m]), p = m;
        } while (p.range[0] < f.range[0]);
      return h;
    }
    function u(c) {
      const f = c.parent.type;
      if (!(E.STATEMENT_LIST_PARENTS.has(f) || f === "SwitchStatement"))
        return;
      const p = s.prevNode;
      if (p) {
        const m = l(p, c), d = i(p, c);
        m.verify(t, p, c, d);
      }
      s.prevNode = c;
    }
    return {
      Program: n,
      BlockStatement: n,
      SwitchStatement: n,
      "Program:exit": a,
      "BlockStatement:exit": a,
      "SwitchStatement:exit": a,
      ":statement": u,
      SwitchCase: function(c) {
        u(c), n();
      },
      "SwitchCase:exit": a
    };
  }
};
gm.meta;
gm.create;
function H6(t) {
  return t && t.defs[0].type === "FunctionName";
}
function K6(t, e, r) {
  return t.meta.name === e && t.property.name === r;
}
function J6(t) {
  const e = t.variables;
  for (let r = 0; r < e.length; ++r) {
    const s = e[r];
    if (s.name === "arguments")
      return s.identifiers.length === 0 ? s : null;
  }
  return null;
}
function X6(t) {
  const e = {
    isCallback: !1,
    isLexicalThis: !1
  };
  let r = t, s = t.parent, n = !1;
  for (; r; ) {
    switch (s.type) {
      case "LogicalExpression":
      case "ChainExpression":
      case "ConditionalExpression":
        break;
      case "MemberExpression":
        if (s.object === r && !s.property.computed && s.property.type === "Identifier" && s.property.name === "bind") {
          const a = s.parent.type === "ChainExpression" ? s.parent : s;
          if (E.isCallee(a))
            n || (n = !0, e.isLexicalThis = a.parent.arguments.length === 1 && a.parent.arguments[0].type === "ThisExpression"), s = a.parent;
          else
            return e;
        } else
          return e;
        break;
      case "CallExpression":
      case "NewExpression":
        return s.callee !== r && (e.isCallback = !0), e;
      default:
        return e;
    }
    r = s, s = s.parent;
  }
  throw new Error("unreachable");
}
function Q6(t) {
  return t.every((e) => e.type === "Identifier") && t.length !== new Set(t.map((e) => e.name)).size;
}
var ym = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using arrow functions for callbacks",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-arrow-callback"
    },
    schema: [{
      type: "object",
      properties: {
        allowNamedFunctions: {
          type: "boolean",
          default: !1
        },
        allowUnboundThis: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      preferArrowCallback: "Unexpected function expression."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.allowUnboundThis !== !1, s = e.allowNamedFunctions, n = t.getSourceCode();
    let a = [];
    function o() {
      a.push({
        this: !1,
        super: !1,
        meta: !1
      });
    }
    function l() {
      return a.pop();
    }
    return {
      Program() {
        a = [];
      },
      ThisExpression() {
        const i = a[a.length - 1];
        i && (i.this = !0);
      },
      Super() {
        const i = a[a.length - 1];
        i && (i.super = !0);
      },
      MetaProperty(i) {
        const u = a[a.length - 1];
        u && K6(i, "new", "target") && (u.meta = !0);
      },
      FunctionDeclaration: o,
      "FunctionDeclaration:exit": l,
      FunctionExpression: o,
      "FunctionExpression:exit"(i) {
        const u = l();
        if (s && i.id && i.id.name || i.generator)
          return;
        const c = t.getDeclaredVariables(i)[0];
        if (H6(c) && c.references.length > 0)
          return;
        const f = J6(t.getScope());
        if (f && f.references.length > 0)
          return;
        const h = X6(i);
        h.isCallback && (!r || !u.this || h.isLexicalThis) && !u.super && !u.meta && t.report({
          node: i,
          messageId: "preferArrowCallback",
          *fix(p) {
            if (!h.isLexicalThis && u.this || Q6(i.params))
              return;
            if (h.isLexicalThis) {
              const y = i.parent;
              if (y.type !== "MemberExpression")
                return;
              const x = y.parent, A = n.getTokenAfter(y.object, E.isNotClosingParenToken), b = n.getLastToken(x);
              if (E.isParenthesised(n, y) || n.commentsExistBetween(A, b))
                return;
              yield p.removeRange([A.range[0], b.range[1]]);
            }
            const m = n.getFirstToken(i, i.async ? 1 : 0), d = n.getTokenAfter(m, E.isOpeningParenToken);
            n.commentsExistBetween(m, d) ? (yield p.remove(m), i.id && (yield p.remove(i.id))) : yield p.removeRange([m.range[0], d.range[0]]), yield p.insertTextBefore(i.body, "=> ");
            let g = h.isLexicalThis ? i.parent.parent : i;
            g.type === "ChainExpression" && (g = g.parent), g.parent.type !== "CallExpression" && g.parent.type !== "ConditionalExpression" && !E.isParenthesised(n, g) && !E.isParenthesised(n, i) && (yield p.insertTextBefore(g, "("), yield p.insertTextAfter(g, ")"));
          }
        });
      }
    };
  }
};
ym.meta;
ym.create;
const Rb = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u, Y6 = /^(?:Program|BlockStatement|SwitchCase)$/u, Z6 = /^(?:VariableDeclarator|AssignmentExpression)$/u;
function e8(t) {
  return t.parent.type === "ForStatement" && t.parent.init === t;
}
function t8(t) {
  let e = t.parent;
  for (; Rb.test(e.type); )
    e = e.parent;
  return e.type === "VariableDeclarator" || e.type === "AssignmentExpression" && e.parent.type === "ExpressionStatement" && Y6.test(e.parent.parent.type);
}
function a0(t, e) {
  if (e.through.find((s) => s.resolved && s.resolved.name === t))
    return !0;
  const r = E.getVariableByName(e, t);
  return r !== null ? r.defs.some((s) => s.type === "Parameter") : !1;
}
function Nb(t) {
  if (!t.isWrite())
    return null;
  let e = t.identifier.parent;
  for (; Rb.test(e.type); )
    e = e.parent;
  return Z6.test(e.type) ? e : null;
}
function Os(t) {
  switch (t.type) {
    case "ObjectPattern":
      return t.properties.some((e) => e ? Os(e.argument || e.value) : !1);
    case "ArrayPattern":
      return t.elements.some((e) => e ? Os(e) : !1);
    case "AssignmentPattern":
      return Os(t.left);
    case "MemberExpression":
      return !0;
  }
  return !1;
}
function r8(t, e) {
  if (t.eslintUsed && t.scope.type === "global")
    return null;
  let r = null, s = !1;
  const n = t.references;
  for (let o = 0; o < n.length; ++o) {
    const l = n[o];
    if (l.isWrite()) {
      if (r !== null && r.identifier !== l.identifier)
        return null;
      const u = Nb(l);
      if (u !== null && u.left !== void 0) {
        const c = u.left;
        let f = !1, h = !1;
        if (c.type === "ObjectPattern" ? (f = c.properties.filter((m) => m.value).map((m) => m.value.name).some((m) => a0(m, t.scope)), h = Os(c)) : c.type === "ArrayPattern" && (f = c.elements.map((m) => m && m.name).some((m) => a0(m, t.scope)), h = Os(c)), f || h)
          return null;
      }
      r = l;
    } else if (l.isRead() && r === null) {
      if (e)
        return null;
      s = !0;
    }
  }
  return r !== null && r.from === t.scope && t8(r.identifier) ? s ? t.defs[0].name : r.identifier : null;
}
function n8(t, e) {
  const r = /* @__PURE__ */ new Map();
  for (let s = 0; s < t.length; ++s) {
    const n = t[s], a = n.references, o = r8(n, e);
    let l = null;
    for (let i = 0; i < a.length; ++i) {
      const u = a[i], c = u.identifier;
      if (c === l)
        continue;
      l = c;
      const f = Nb(u);
      f && (r.has(f) ? r.get(f).push(o) : r.set(f, [o]));
    }
  }
  return r;
}
function jb(t, e, r) {
  return !t || r(t) ? null : t.type === e ? t : jb(t.parent, e, r);
}
var xm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `const` declarations for variables that are never reassigned after declared",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-const"
    },
    fixable: "code",
    schema: [{
      type: "object",
      properties: {
        destructuring: {
          enum: ["any", "all"],
          default: "any"
        },
        ignoreReadBeforeAssign: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      useConst: "'{{name}}' is never reassigned. Use 'const' instead."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = t.getSourceCode(), s = e.destructuring !== "all", n = e.ignoreReadBeforeAssign === !0, a = [];
    let o = 0, l = null, i = "";
    function u(c) {
      const f = c.filter(Boolean);
      if (c.length && (s || f.length === c.length)) {
        const h = jb(c[0], "VariableDeclaration", (d) => d.type.endsWith("Statement")), p = h === null;
        if (!p && h.declarations.length > 0) {
          const d = h.declarations[0];
          if (d.init) {
            const g = d.init.parent;
            g.type === "VariableDeclarator" && (g.id.name !== i && (i = g.id.name, o = 0), g.id.type === "ObjectPattern" && g.init.name !== i && (i = g.init.name, o = 0), g.id !== l && (l = g.id, o = 0));
          }
        }
        let m = h && (h.parent.type === "ForInStatement" || h.parent.type === "ForOfStatement" || h.declarations.every((d) => d.init)) && f.length === c.length;
        !p && h.declarations && h.declarations.length !== 1 && h && h.declarations && h.declarations.length >= 1 && (o += f.length, m = m && o === h.declarations.length), f.forEach((d) => {
          t.report({
            node: d,
            messageId: "useConst",
            data: d,
            fix: m ? (g) => {
              const y = r.getFirstToken(h, (x) => x.value === h.kind);
              return new Qs(g, r).retainRange(h.range).replaceTextRange(y.range, "const");
            } : null
          });
        });
      }
    }
    return {
      "Program:exit"() {
        n8(a, n).forEach(u);
      },
      VariableDeclaration(c) {
        c.kind === "let" && !e8(c) && a.push(...t.getDeclaredVariables(c));
      }
    };
  }
};
xm.meta;
xm.create;
const s8 = E.getPrecedence({
  type: "AssignmentExpression"
});
var vm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require destructuring from arrays and/or objects",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-destructuring"
    },
    fixable: "code",
    schema: [{
      oneOf: [{
        type: "object",
        properties: {
          VariableDeclarator: {
            type: "object",
            properties: {
              array: {
                type: "boolean"
              },
              object: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          },
          AssignmentExpression: {
            type: "object",
            properties: {
              array: {
                type: "boolean"
              },
              object: {
                type: "boolean"
              }
            },
            additionalProperties: !1
          }
        },
        additionalProperties: !1
      }, {
        type: "object",
        properties: {
          array: {
            type: "boolean"
          },
          object: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }, {
      type: "object",
      properties: {
        enforceForRenamedProperties: {
          type: "boolean"
        }
      },
      additionalProperties: !1
    }],
    messages: {
      preferDestructuring: "Use {{type}} destructuring."
    }
  },
  create(t) {
    const e = t.options[0], r = t.options[1] && t.options[1].enforceForRenamedProperties;
    let s = {
      VariableDeclarator: {
        array: !0,
        object: !0
      },
      AssignmentExpression: {
        array: !0,
        object: !0
      }
    };
    e && (s = typeof e.array < "u" || typeof e.object < "u" ? {
      VariableDeclarator: e,
      AssignmentExpression: e
    } : e);
    function n(c, f) {
      return s && s[c] && s[c][f];
    }
    function a(c) {
      return Number.isInteger(c.property.value);
    }
    function o(c, f, h) {
      t.report({
        node: c,
        messageId: "preferDestructuring",
        data: {
          type: f
        },
        fix: h
      });
    }
    function l(c) {
      return c.type === "VariableDeclarator" && c.id.type === "Identifier" && c.init.type === "MemberExpression" && !c.init.computed && c.init.property.type === "Identifier" && c.id.name === c.init.property.name;
    }
    function i(c, f) {
      const h = f.init, p = t.getSourceCode();
      if (p.getCommentsInside(f).length > p.getCommentsInside(h.object).length)
        return null;
      let m = p.getText(h.object);
      return E.getPrecedence(h.object) < s8 && (m = `(${m})`), c.replaceText(f, `{${h.property.name}} = ${m}`);
    }
    function u(c, f, h) {
      if (f.type !== "MemberExpression" || f.object.type === "Super")
        return;
      if (a(f)) {
        n(h.type, "array") && o(h, "array", null);
        return;
      }
      const p = l(h) ? (m) => i(m, h) : null;
      if (n(h.type, "object") && r) {
        o(h, "object", p);
        return;
      }
      if (n(h.type, "object")) {
        const m = f.property;
        (m.type === "Literal" && c.name === m.value || m.type === "Identifier" && c.name === m.name && !f.computed) && o(h, "object", p);
      }
    }
    return {
      VariableDeclarator: function(c) {
        c.init && c.init.type === "MemberExpression" && u(c.id, c.init, c);
      },
      AssignmentExpression: function(c) {
        c.operator === "=" && u(c.left, c.right, c);
      }
    };
  }
};
vm.meta;
vm.create;
const {
  CALL: a8,
  ReferenceTracker: i8
} = Vt.default, Em = E.getPrecedence({
  type: "BinaryExpression",
  operator: "**"
});
function o8(t) {
  return E.getPrecedence(t) <= Em || t.type === "AwaitExpression" || t.type === "UnaryExpression";
}
function l8(t) {
  return E.getPrecedence(t) < Em;
}
function u8(t, e) {
  const r = t.parent.type === "ChainExpression" ? t.parent.parent : t.parent;
  return (r.type === "ClassDeclaration" || r.type.endsWith("Expression") && E.getPrecedence(r) >= Em && !(r.type === "BinaryExpression" && r.operator === "**" && r.right === t) && !((r.type === "CallExpression" || r.type === "NewExpression") && r.arguments.includes(t)) && !(r.type === "MemberExpression" && r.computed && r.property === t) && r.type !== "ArrayExpression") && !E.isParenthesised(e, t);
}
function el(t, e) {
  return e ? `(${t})` : t;
}
var bm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow the use of `Math.pow` in favor of the `**` operator",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-exponentiation-operator"
    },
    schema: [],
    fixable: "code",
    messages: {
      useExponentiation: "Use the '**' operator instead of 'Math.pow'."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    function r(s) {
      t.report({
        node: s,
        messageId: "useExponentiation",
        fix(n) {
          if (s.arguments.length !== 2 || s.arguments.some((y) => y.type === "SpreadElement") || e.getCommentsInside(s).length > 0)
            return null;
          const a = s.arguments[0], o = s.arguments[1], l = e.getText(a), i = e.getText(o), u = o8(a), c = l8(o), f = u8(s, e);
          let h = "", p = "";
          if (!f) {
            if (!u) {
              const y = e.getFirstToken(a), x = e.getTokenBefore(s);
              x && x.range[1] === s.range[0] && !E.canTokensBeAdjacent(x, y) && (h = " ");
            }
            if (!c) {
              const y = e.getLastToken(o), x = e.getTokenAfter(s);
              x && s.range[1] === x.range[0] && !E.canTokensBeAdjacent(y, x) && (p = " ");
            }
          }
          const m = el(l, u), d = el(i, c), g = el(`${m}**${d}`, f);
          return n.replaceText(s, `${h}${g}${p}`);
        }
      });
    }
    return {
      Program() {
        const s = t.getScope(), n = new i8(s), a = {
          Math: {
            pow: {
              [a8]: !0
            }
          }
        };
        for (const {
          node: o
        } of n.iterateGlobalReferences(a))
          r(o);
      }
    };
  }
};
bm.meta;
bm.create;
const {
  CALL: c8,
  CONSTRUCT: p8,
  ReferenceTracker: f8,
  getStringIfConstant: i0
} = Vt.default, h8 = new pn.default.RegExpParser();
var Cm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce using named capture group in regular expression",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-named-capture-group"
    },
    schema: [],
    messages: {
      required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
    }
  },
  create(t) {
    function e(r, s, n) {
      let a;
      try {
        a = h8.parsePattern(r, 0, r.length, n);
      } catch {
        return;
      }
      pn.default.visitRegExpAST(a, {
        onCapturingGroupEnter(o) {
          o.name || t.report({
            node: s,
            messageId: "required",
            data: {
              group: o.raw
            }
          });
        }
      });
    }
    return {
      Literal(r) {
        r.regex && e(r.regex.pattern, r, r.regex.flags.includes("u"));
      },
      Program() {
        const r = t.getScope(), s = new f8(r), n = {
          RegExp: {
            [c8]: !0,
            [p8]: !0
          }
        };
        for (const {
          node: a
        } of s.iterateGlobalReferences(n)) {
          const o = i0(a.arguments[0]), l = i0(a.arguments[1]);
          o && e(o, a, l && l.includes("u"));
        }
      }
    };
  }
};
Cm.meta;
Cm.create;
const o0 = /* @__PURE__ */ new Map([[2, {
  system: "binary",
  literalPrefix: "0b"
}], [8, {
  system: "octal",
  literalPrefix: "0o"
}], [16, {
  system: "hexadecimal",
  literalPrefix: "0x"
}]]);
function m8(t) {
  return E.isSpecificId(t, "parseInt") || E.isSpecificMemberAccess(t, "Number", "parseInt");
}
var Sm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-numeric-literals"
    },
    schema: [],
    messages: {
      useLiteral: "Use {{system}} literals instead of {{functionName}}()."
    },
    fixable: "code"
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      "CallExpression[arguments.length=2]"(r) {
        const [s, n] = r.arguments, a = E.getStaticStringValue(s), o = n.value;
        if (a !== null && E.isStringLiteral(s) && n.type === "Literal" && typeof o == "number" && o0.has(o) && m8(r.callee)) {
          const {
            system: l,
            literalPrefix: i
          } = o0.get(o);
          t.report({
            node: r,
            messageId: "useLiteral",
            data: {
              system: l,
              functionName: e.getText(r.callee)
            },
            fix(u) {
              if (e.getCommentsInside(r).length)
                return null;
              const c = `${i}${a}`;
              if (+c !== parseInt(a, o))
                return null;
              const f = e.getTokenBefore(r), h = e.getTokenAfter(r);
              let p = "", m = "";
              return f && f.range[1] === r.range[0] && !E.canTokensBeAdjacent(f, c) && (p = " "), h && r.range[1] === h.range[0] && !E.canTokensBeAdjacent(c, h) && (m = " "), u.replaceText(r, `${p}${c}${m}`);
            }
          });
        }
      }
    };
  }
};
Sm.meta;
Sm.create;
const {
  CALL: d8,
  ReferenceTracker: g8
} = Vt.default, {
  isCommaToken: l0,
  isOpeningParenToken: Mb,
  isClosingParenToken: y8,
  isParenthesised: Ll
} = E, $b = /\s/u;
function x8(t) {
  return t.arguments.some((e) => e.type === "SpreadElement");
}
function v8(t) {
  return t.type === "Property" && (t.kind === "get" || t.kind === "set");
}
function E8(t) {
  return t.properties.some(v8);
}
function b8(t) {
  return t.arguments.filter((e) => e.type === "ObjectExpression").some(E8);
}
function C8(t, e) {
  const r = t.parent;
  switch (r.type) {
    case "VariableDeclarator":
    case "ArrayExpression":
    case "ReturnStatement":
    case "CallExpression":
    case "Property":
      return !1;
    case "AssignmentExpression":
      return r.left === t && !Ll(e, t);
    default:
      return !Ll(e, t);
  }
}
function S8(t, e) {
  switch (t.type) {
    case "AssignmentExpression":
    case "ArrowFunctionExpression":
    case "ConditionalExpression":
      return !Ll(e, t);
    default:
      return !1;
  }
}
function A8(t, e, r) {
  const s = [r.getFirstToken(t), r.getLastToken(t)];
  let n = r.getTokenBefore(t), a = r.getTokenAfter(t);
  for (; n && a && n.range[0] > e.range[0] && Mb(n) && y8(a); )
    s.push(n, a), n = r.getTokenBefore(n), a = r.getTokenAfter(a);
  return s.sort((o, l) => o.range[0] - l.range[0]);
}
function D8(t, e) {
  const r = e.text;
  let s = t.range[0];
  {
    const n = e.getTokenBefore(t, {
      includeComments: !0
    });
    if (n && n.type === "Line")
      return s;
  }
  for (; $b.test(r[s - 1] || ""); )
    s -= 1;
  return s;
}
function w8(t, e) {
  const r = e.text;
  let s = t.range[1];
  for (; $b.test(r[s] || ""); )
    s += 1;
  return s;
}
function k8(t, e) {
  return function* (r) {
    const s = e.getTokenAfter(t.callee, Mb), n = e.getLastToken(t);
    yield r.removeRange([t.range[0], s.range[0]]), C8(t, e) ? (yield r.replaceText(s, "({"), yield r.replaceText(n, "})")) : (yield r.replaceText(s, "{"), yield r.replaceText(n, "}"));
    for (const a of t.arguments) {
      const o = A8(a, s, e), l = o.shift(), i = o.pop();
      if (a.type === "ObjectExpression") {
        const u = e.getLastToken(a, 1), c = e.getTokenAfter(i);
        for (const p of o)
          yield r.remove(p);
        const f = [l.range[0], w8(l, e)], h = [Math.max(D8(i, e), f[1]), i.range[1]];
        yield r.removeRange(f), yield r.removeRange(h), (a.properties.length === 0 || l0(u)) && l0(c) && (yield r.remove(c));
      } else
        S8(a, e) ? (yield r.insertTextBefore(l, "...("), yield r.insertTextAfter(i, ")")) : yield r.insertTextBefore(l, "...");
    }
  };
}
var Am = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-object-spread"
    },
    schema: [],
    fixable: "code",
    messages: {
      useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
      useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      Program() {
        const r = t.getScope(), s = new g8(r), n = {
          Object: {
            assign: {
              [d8]: !0
            }
          }
        };
        for (const {
          node: a
        } of s.iterateGlobalReferences(n))
          if (a.arguments.length >= 1 && a.arguments[0].type === "ObjectExpression" && !x8(a) && !(a.arguments.length > 1 && b8(a))) {
            const o = a.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage", l = k8(a, e);
            t.report({
              node: a,
              messageId: o,
              fix: l
            });
          }
      }
    };
  }
};
Am.meta;
Am.create;
var Dm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require using Error objects as Promise rejection reasons",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-promise-reject-errors"
    },
    fixable: null,
    schema: [{
      type: "object",
      properties: {
        allowEmptyReject: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      rejectAnError: "Expected the Promise rejection reason to be an Error."
    }
  },
  create(t) {
    const e = t.options.length && t.options[0].allowEmptyReject;
    function r(n) {
      !n.arguments.length && e || (!n.arguments.length || !E.couldBeError(n.arguments[0]) || n.arguments[0].type === "Identifier" && n.arguments[0].name === "undefined") && t.report({
        node: n,
        messageId: "rejectAnError"
      });
    }
    function s(n) {
      return E.isSpecificMemberAccess(n.callee, "Promise", "reject");
    }
    return {
      CallExpression(n) {
        s(n) && r(n);
      },
      "NewExpression:exit"(n) {
        n.callee.type === "Identifier" && n.callee.name === "Promise" && n.arguments.length && E.isFunction(n.arguments[0]) && n.arguments[0].params.length > 1 && n.arguments[0].params[1].type === "Identifier" && t.getDeclaredVariables(n.arguments[0]).find((a) => a.name === n.arguments[0].params[1].name).references.filter((a) => a.isRead()).filter((a) => a.identifier.parent.type === "CallExpression" && a.identifier === a.identifier.parent.callee).forEach((a) => r(a.identifier.parent));
      }
    };
  }
};
Dm.meta;
Dm.create;
var wm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `Reflect` methods where applicable",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-reflect"
    },
    deprecated: !0,
    replacedBy: [],
    schema: [{
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            enum: ["apply", "call", "delete", "defineProperty", "getOwnPropertyDescriptor", "getPrototypeOf", "setPrototypeOf", "isExtensible", "getOwnPropertyNames", "preventExtensions"]
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      preferReflect: "Avoid using {{existing}}, instead use {{substitute}}."
    }
  },
  create(t) {
    const e = {
      apply: "Function.prototype.apply",
      call: "Function.prototype.call",
      defineProperty: "Object.defineProperty",
      getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
      getPrototypeOf: "Object.getPrototypeOf",
      setPrototypeOf: "Object.setPrototypeOf",
      isExtensible: "Object.isExtensible",
      getOwnPropertyNames: "Object.getOwnPropertyNames",
      preventExtensions: "Object.preventExtensions"
    }, r = {
      apply: "Reflect.apply",
      call: "Reflect.apply",
      defineProperty: "Reflect.defineProperty",
      getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
      getPrototypeOf: "Reflect.getPrototypeOf",
      setPrototypeOf: "Reflect.setPrototypeOf",
      isExtensible: "Reflect.isExtensible",
      getOwnPropertyNames: "Reflect.getOwnPropertyNames",
      preventExtensions: "Reflect.preventExtensions"
    }, s = (t.options[0] || {}).exceptions || [];
    function n(a, o, l) {
      t.report({
        node: a,
        messageId: "preferReflect",
        data: {
          existing: o,
          substitute: l
        }
      });
    }
    return {
      CallExpression(a) {
        const o = (a.callee.property || {}).name, l = (a.callee.object || {}).name === "Reflect", i = Object.prototype.hasOwnProperty.call(r, o), u = s.indexOf(o) !== -1;
        i && !l && !u && n(a, e[o], r[o]);
      },
      UnaryExpression(a) {
        const o = a.operator === "delete", l = a.argument.type === "Identifier", i = s.indexOf("delete") !== -1;
        o && !l && !i && n(a, "the delete keyword", "Reflect.deleteProperty");
      }
    };
  }
};
wm.meta;
wm.create;
const {
  CALL: T8,
  CONSTRUCT: F8,
  ReferenceTracker: P8,
  findVariable: I8
} = Vt.default;
function _8(t) {
  return t.type === "Literal" && typeof t.value == "string";
}
function u0(t) {
  return t.type === "Literal" && Object.prototype.hasOwnProperty.call(t, "regex");
}
function c0(t) {
  return t.type === "TemplateLiteral" && t.expressions.length === 0;
}
var km = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow use of the `RegExp` constructor in favor of regular expression literals",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-regex-literals"
    },
    schema: [{
      type: "object",
      properties: {
        disallowRedundantWrapping: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.",
      unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",
      unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor."
    }
  },
  create(t) {
    const [{
      disallowRedundantWrapping: e = !1
    } = {}] = t.options;
    function r(l) {
      const i = t.getScope(), u = I8(i, l);
      return u !== null && u.scope.type === "global" && u.defs.length === 0;
    }
    function s(l) {
      return l.type === "TaggedTemplateExpression" && E.isSpecificMemberAccess(l.tag, "String", "raw") && r(E.skipChainExpression(l.tag).object) && c0(l.quasi);
    }
    function n(l) {
      return _8(l) || c0(l) || s(l);
    }
    function a(l) {
      const i = l.arguments;
      return !!((i.length === 1 || i.length === 2) && i.every(n));
    }
    function o(l) {
      const i = l.arguments;
      return !!(i.length === 1 && u0(i[0]) || i.length === 2 && u0(i[0]) && n(i[1]));
    }
    return {
      Program() {
        const l = t.getScope(), i = new P8(l), u = {
          RegExp: {
            [T8]: !0,
            [F8]: !0
          }
        };
        for (const {
          node: c
        } of i.iterateGlobalReferences(u))
          e && o(c) ? c.arguments.length === 2 ? t.report({
            node: c,
            messageId: "unexpectedRedundantRegExpWithFlags"
          }) : t.report({
            node: c,
            messageId: "unexpectedRedundantRegExp"
          }) : a(c) && t.report({
            node: c,
            messageId: "unexpectedRegExp"
          });
      }
    };
  }
};
km.meta;
km.create;
function B8(t) {
  const e = t.variables;
  for (let r = 0; r < e.length; ++r) {
    const s = e[r];
    if (s.name === "arguments")
      return s.identifiers.length === 0 ? s : null;
  }
  return null;
}
function O8(t) {
  const e = t.identifier, r = e.parent;
  return !(r.type === "MemberExpression" && r.object === e && !r.computed);
}
var Tm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require rest parameters instead of `arguments`",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-rest-params"
    },
    schema: [],
    messages: {
      preferRestParams: "Use the rest parameters instead of 'arguments'."
    }
  },
  create(t) {
    function e(s) {
      t.report({
        node: s.identifier,
        loc: s.identifier.loc,
        messageId: "preferRestParams"
      });
    }
    function r() {
      const s = B8(t.getScope());
      s && s.references.filter(O8).forEach(e);
    }
    return {
      "FunctionDeclaration:exit": r,
      "FunctionExpression:exit": r
    };
  }
};
Tm.meta;
Tm.create;
function L8(t) {
  return E.isSpecificMemberAccess(t.callee, null, "apply") && t.arguments.length === 2 && t.arguments[1].type !== "ArrayExpression" && t.arguments[1].type !== "SpreadElement";
}
function R8(t, e, r) {
  return t ? E.equalTokens(t, e, r) : E.isNullOrUndefined(e);
}
var Fm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require spread operators instead of `.apply()`",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-spread"
    },
    schema: [],
    fixable: null,
    messages: {
      preferSpread: "Use the spread operator instead of '.apply()'."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      CallExpression(r) {
        if (!L8(r))
          return;
        const s = E.skipChainExpression(E.skipChainExpression(r.callee).object), n = s.type === "MemberExpression" ? s.object : null, a = r.arguments[0];
        R8(n, a, e) && t.report({
          node: r,
          messageId: "preferSpread"
        });
      }
    };
  }
};
Fm.meta;
Fm.create;
function is(t) {
  return t.type === "BinaryExpression" && t.operator === "+";
}
function p0(t) {
  let e = t;
  for (; is(e.parent); )
    e = e.parent;
  return e;
}
function Rl(t) {
  return is(t) ? Rl(t.left) || Rl(t.right) : t.type === "Literal" && typeof t.value == "string" ? E.hasOctalOrNonOctalDecimalEscapeSequence(t.raw) : !1;
}
function Nl(t) {
  return is(t) ? Nl(t.right) || Nl(t.left) : E.isStringLiteral(t);
}
function oi(t) {
  return is(t) ? oi(t.right) || oi(t.left) : !E.isStringLiteral(t);
}
function Pm(t) {
  return t.type === "BinaryExpression" ? Pm(t.left) : t.type === "TemplateLiteral" ? t.expressions.length && t.quasis.length && t.quasis[0].range[0] === t.quasis[0].range[1] : t.type !== "Literal" || typeof t.value != "string";
}
function N8(t) {
  return t.type === "BinaryExpression" ? Pm(t.right) : t.type === "TemplateLiteral" ? t.expressions.length && t.quasis.length && t.quasis[t.quasis.length - 1].range[0] === t.quasis[t.quasis.length - 1].range[1] : t.type !== "Literal" || typeof t.value != "string";
}
var Im = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require template literals instead of string concatenation",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/prefer-template"
    },
    schema: [],
    fixable: "code",
    messages: {
      unexpectedStringConcatenation: "Unexpected string concatenation."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r = /* @__PURE__ */ Object.create(null);
    function s(l, i) {
      const u = [l].concat(e.getTokensBetween(l, i)).concat(i), c = e.getText();
      return u.slice(0, -1).reduce((f, h, p) => f + c.slice(h.range[1], u[p + 1].range[0]), "");
    }
    function n(l, i, u) {
      if (l.type === "Literal" && typeof l.value == "string")
        return `\`${l.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, (c) => c.lastIndexOf("\\") % 2 ? `\\${c}` : c).replace(new RegExp(`\\\\${l.raw[0]}`, "gu"), l.raw[0])}\``;
      if (l.type === "TemplateLiteral")
        return e.getText(l);
      if (is(l) && Nl(l) && oi(l)) {
        const c = e.getFirstTokenBetween(l.left, l.right, (d) => d.value === "+"), f = s(l.left, c), h = s(c, l.right), p = N8(l.left), m = Pm(l.right);
        return p ? n(l.left, i, f + h).slice(0, -1) + n(l.right, null, u).slice(1) : m ? n(l.left, i, null).slice(0, -1) + n(l.right, f + h, u).slice(1) : `${n(l.left, i, null)}${f}+${h}${n(l.right, u, null)}`;
      }
      return `\`\${${i || ""}${e.getText(l)}${u || ""}}\``;
    }
    function a(l, i) {
      const u = p0(i.parent);
      return Rl(u) ? null : l.replaceText(u, n(u, null, null));
    }
    function o(l) {
      if (!E.isStringLiteral(l) || !is(l.parent))
        return;
      const i = p0(l.parent);
      r[i.range[0]] || (r[i.range[0]] = !0, oi(i) && t.report({
        node: i,
        messageId: "unexpectedStringConcatenation",
        fix: (u) => a(u, l)
      }));
    }
    return {
      Program() {
        r = /* @__PURE__ */ Object.create(null);
      },
      Literal: o,
      TemplateLiteral: o
    };
  }
};
Im.meta;
Im.create;
var _m = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require quotes around object literal property names",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/quote-props"
    },
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
        }],
        minItems: 0,
        maxItems: 1
      }, {
        type: "array",
        items: [{
          enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
        }, {
          type: "object",
          properties: {
            keywords: {
              type: "boolean"
            },
            unnecessary: {
              type: "boolean"
            },
            numbers: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    fixable: "code",
    messages: {
      requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
      inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
      unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
      unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
      unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
      unquotedPropertyFound: "Unquoted property '{{property}}' found.",
      redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
    }
  },
  create(t) {
    const e = t.options[0], r = t.options[1] && t.options[1].keywords, s = !t.options[1] || t.options[1].unnecessary !== !1, n = t.options[1] && t.options[1].numbers, a = t.getSourceCode();
    function o(p) {
      return si.indexOf(p) >= 0;
    }
    function l(p, m, d) {
      return m.length === 1 && m[0].start === 0 && m[0].end === p.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(m[0].type) >= 0 || m[0].type === "Numeric" && !d && String(+m[0].value) === m[0].value);
    }
    function i(p) {
      return p.type === "Identifier" ? p.name : p.value;
    }
    function u(p) {
      return p.type === "Literal" && typeof p.value == "string" ? a.getText(p) : `"${p.type === "Identifier" ? p.name : p.value}"`;
    }
    function c(p) {
      const m = p.key;
      if (!(p.method || p.computed || p.shorthand))
        if (m.type === "Literal" && typeof m.value == "string") {
          let d;
          try {
            d = Bs.default.tokenize(m.value);
          } catch {
            return;
          }
          if (d.length !== 1 || o(d[0].value) && r)
            return;
          s && l(m.value, d, n) && t.report({
            node: p,
            messageId: "unnecessarilyQuotedProperty",
            data: {
              property: m.value
            },
            fix: (y) => y.replaceText(m, i(m))
          });
        } else
          r && m.type === "Identifier" && o(m.name) ? t.report({
            node: p,
            messageId: "unquotedReservedProperty",
            data: {
              property: m.name
            },
            fix: (d) => d.replaceText(m, u(m))
          }) : n && m.type === "Literal" && E.isNumericLiteral(m) && t.report({
            node: p,
            messageId: "unquotedNumericProperty",
            data: {
              property: m.value
            },
            fix: (d) => d.replaceText(m, u(m))
          });
    }
    function f(p) {
      const m = p.key;
      !p.method && !p.computed && !p.shorthand && !(m.type === "Literal" && typeof m.value == "string") && t.report({
        node: p,
        messageId: "unquotedPropertyFound",
        data: {
          property: m.name || m.value
        },
        fix: (d) => d.replaceText(m, u(m))
      });
    }
    function h(p, m) {
      const d = [], g = [];
      let y = null, x = !1;
      p.properties.forEach((A) => {
        const b = A.key;
        if (!(!b || A.method || A.computed || A.shorthand))
          if (b.type === "Literal" && typeof b.value == "string") {
            if (d.push(A), m) {
              let v;
              try {
                v = Bs.default.tokenize(b.value);
              } catch {
                x = !0;
                return;
              }
              x = x || !l(b.value, v) || r && o(v[0].value);
            }
          } else
            r && m && b.type === "Identifier" && o(b.name) ? (g.push(A), x = !0, y = b.name) : g.push(A);
      }), m && d.length && !x ? d.forEach((A) => {
        t.report({
          node: A,
          messageId: "redundantQuoting",
          fix: (b) => b.replaceText(A.key, i(A.key))
        });
      }) : g.length && y ? g.forEach((A) => {
        t.report({
          node: A,
          messageId: "requireQuotesDueToReservedWord",
          data: {
            property: y
          },
          fix: (b) => b.replaceText(A.key, u(A.key))
        });
      }) : d.length && g.length && g.forEach((A) => {
        t.report({
          node: A,
          messageId: "inconsistentlyQuotedProperty",
          data: {
            key: A.key.name || A.key.value
          },
          fix: (b) => b.replaceText(A.key, u(A.key))
        });
      });
    }
    return {
      Property(p) {
        (e === "always" || !e) && f(p), e === "as-needed" && c(p);
      },
      ObjectExpression(p) {
        e === "consistent" && h(p, !1), e === "consistent-as-needed" && h(p, !0);
      }
    };
  }
};
_m.meta;
_m.create;
const Na = {
  double: {
    quote: '"',
    alternateQuote: "'",
    description: "doublequote"
  },
  single: {
    quote: "'",
    alternateQuote: '"',
    description: "singlequote"
  },
  backtick: {
    quote: "`",
    alternateQuote: '"',
    description: "backtick"
  }
}, j8 = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(E.LINEBREAKS).join("")}]`, "u");
Na.double.convert = Na.single.convert = Na.backtick.convert = function(t) {
  const e = this.quote, r = t[0];
  return e === r ? t : e + t.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (s, n, a) => n === r || r === "`" && n === "${" ? n : s === e || e === "`" && s === "${" ? `\\${s}` : a && r === "`" ? "\\n" : s) + e;
};
const M8 = "avoid-escape";
var Bm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce the consistent use of either backticks, double, or single quotes",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/quotes"
    },
    fixable: "code",
    schema: [{
      enum: ["single", "double", "backtick"]
    }, {
      anyOf: [{
        enum: ["avoid-escape"]
      }, {
        type: "object",
        properties: {
          avoidEscape: {
            type: "boolean"
          },
          allowTemplateLiterals: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      wrongQuotes: "Strings must use {{description}}."
    }
  },
  create(t) {
    const e = t.options[0], r = Na[e || "double"], s = t.options[1], n = s && s.allowTemplateLiterals === !0, a = t.getSourceCode();
    let o = s && s.avoidEscape === !0;
    s === M8 && (o = !0);
    function l(h) {
      return h.parent.type === "JSXAttribute" || h.parent.type === "JSXElement" || h.parent.type === "JSXFragment";
    }
    function i(h) {
      return h.type === "ExpressionStatement" && h.expression.type === "Literal" && typeof h.expression.value == "string";
    }
    function u(h) {
      const p = h.parent.parent;
      if (p.type !== "Program" && (p.type !== "BlockStatement" || !E.isFunction(p.parent)))
        return !1;
      for (let m = 0; m < p.body.length; ++m) {
        const d = p.body[m];
        if (d === h.parent)
          return !0;
        if (!i(d))
          break;
      }
      return !1;
    }
    function c(h) {
      const p = h.parent;
      switch (p.type) {
        case "ExpressionStatement":
          return u(h);
        case "Property":
        case "MethodDefinition":
          return p.key === h && !p.computed;
        case "ImportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration":
          return p.source === h;
        default:
          return !1;
      }
    }
    function f(h) {
      return !!(h.parent.type === "TaggedTemplateExpression" && h === h.parent.quasi || h.expressions.length > 0 || h.quasis.length >= 1 && j8.test(h.quasis[0].value.raw));
    }
    return {
      Literal(h) {
        const p = h.value, m = h.raw;
        if (r && typeof p == "string") {
          let d = e === "backtick" && c(h) || l(h) || E.isSurroundedBy(m, r.quote);
          !d && o && (d = E.isSurroundedBy(m, r.alternateQuote) && m.indexOf(r.quote) >= 0), d || t.report({
            node: h,
            messageId: "wrongQuotes",
            data: {
              description: r.description
            },
            fix(g) {
              return e === "backtick" && E.hasOctalOrNonOctalDecimalEscapeSequence(m) ? null : g.replaceText(h, r.convert(h.raw));
            }
          });
        }
      },
      TemplateLiteral(h) {
        n || e === "backtick" || f(h) || t.report({
          node: h,
          messageId: "wrongQuotes",
          data: {
            description: r.description
          },
          fix(p) {
            return u(h) ? null : p.replaceText(h, r.convert(a.getText(h)));
          }
        });
      }
    };
  }
};
Bm.meta;
Bm.create;
const f0 = "always", $8 = "as-needed", V8 = new Set(Array.from({
  length: 35
}, (t, e) => e + 2));
function h0(t) {
  return t.defs.length >= 1;
}
function U8(t) {
  return t.type === "MemberExpression" && !t.computed && t.property.type === "Identifier" && t.property.name === "parseInt";
}
function q8(t) {
  return !(t.type === "Literal" && !V8.has(t.value) || t.type === "Identifier" && t.name === "undefined");
}
function W8(t) {
  return t.type === "Literal" && t.value === 10;
}
var Om = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the consistent use of the radix argument when using `parseInt()`",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/radix",
      suggestion: !0
    },
    schema: [{
      enum: ["always", "as-needed"]
    }],
    messages: {
      missingParameters: "Missing parameters.",
      redundantRadix: "Redundant radix parameter.",
      missingRadix: "Missing radix parameter.",
      invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36.",
      addRadixParameter10: "Add radix parameter `10` for parsing decimal numbers."
    }
  },
  create(t) {
    const e = t.options[0] || f0;
    function r(s) {
      const n = s.arguments;
      switch (n.length) {
        case 0:
          t.report({
            node: s,
            messageId: "missingParameters"
          });
          break;
        case 1:
          e === f0 && t.report({
            node: s,
            messageId: "missingRadix",
            suggest: [{
              messageId: "addRadixParameter10",
              fix(a) {
                const l = t.getSourceCode().getTokens(s), i = l[l.length - 1], u = l[l.length - 2], c = u.type === "Punctuator" && u.value === ",";
                return a.insertTextBefore(i, c ? " 10," : ", 10");
              }
            }]
          });
          break;
        default:
          e === $8 && W8(n[1]) ? t.report({
            node: s,
            messageId: "redundantRadix"
          }) : q8(n[1]) || t.report({
            node: s,
            messageId: "invalidRadix"
          });
          break;
      }
    }
    return {
      "Program:exit"() {
        const s = t.getScope();
        let n = E.getVariableByName(s, "parseInt");
        n && !h0(n) && n.references.forEach((a) => {
          const o = a.identifier;
          E.isCallee(o) && r(o.parent);
        }), n = E.getVariableByName(s, "Number"), n && !h0(n) && n.references.forEach((a) => {
          const o = a.identifier.parent, l = o.parent.type === "ChainExpression" ? o.parent : o;
          U8(o) && E.isCallee(l) && r(l.parent);
        });
      }
    };
  }
};
Om.meta;
Om.create;
function Vb(t, e = /* @__PURE__ */ new Map()) {
  for (const r of t.references)
    r.resolved !== null && e.set(r.identifier, r);
  for (const r of t.childScopes)
    r.type !== "function" && Vb(r, e);
  return e;
}
function z8(t) {
  if (t.writeExpr)
    return t.writeExpr;
  let e = t.identifier;
  for (; e; ) {
    const r = e.parent.type;
    if (r === "AssignmentExpression" && e.parent.left === e)
      return e.parent.right;
    if (r === "MemberExpression" && e.parent.object === e) {
      e = e.parent;
      continue;
    }
    break;
  }
  return null;
}
function G8(t, e) {
  if (!t || e && t.defs.some((s) => s.type === "Parameter"))
    return !1;
  const r = t.scope.variableScope;
  return t.references.every((s) => s.from.variableScope === r);
}
class H8 {
  constructor() {
    this.info = /* @__PURE__ */ new WeakMap();
  }
  initialize(e) {
    const r = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
    for (const n of e.prevSegments) {
      const a = this.info.get(n);
      a && (a.outdatedReadVariables.forEach(Set.prototype.add, r), a.freshReadVariables.forEach(Set.prototype.add, s));
    }
    this.info.set(e, {
      outdatedReadVariables: r,
      freshReadVariables: s
    });
  }
  markAsRead(e, r) {
    for (const s of e) {
      const n = this.info.get(s);
      n && (n.freshReadVariables.add(r), n.outdatedReadVariables.delete(r));
    }
  }
  makeOutdated(e) {
    for (const r of e) {
      const s = this.info.get(r);
      s && (s.freshReadVariables.forEach(Set.prototype.add, s.outdatedReadVariables), s.freshReadVariables.clear());
    }
  }
  isOutdated(e, r) {
    for (const s of e) {
      const n = this.info.get(s);
      if (n && n.outdatedReadVariables.has(r))
        return !0;
    }
    return !1;
  }
}
var Lm = {
  meta: {
    type: "problem",
    docs: {
      description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/require-atomic-updates"
    },
    fixable: null,
    schema: [],
    messages: {
      nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = /* @__PURE__ */ new Map(), s = new H8();
    let n = null;
    return {
      onCodePathStart(a) {
        const o = t.getScope(), l = o.type === "function" && (o.block.async || o.block.generator);
        n = {
          upper: n,
          codePath: a,
          referenceMap: l ? Vb(o) : null
        };
      },
      onCodePathEnd() {
        n = n.upper;
      },
      onCodePathSegmentStart(a) {
        s.initialize(a);
      },
      Identifier(a) {
        const {
          codePath: o,
          referenceMap: l
        } = n, i = l && l.get(a);
        if (!i)
          return;
        const u = i.resolved, c = z8(i), f = i.identifier.parent.type === "MemberExpression";
        if (i.isRead() && !(c && c.parent.operator === "=") && s.markAsRead(o.currentSegments, u), c && c.parent.right === c && !G8(u, f)) {
          let h = r.get(c);
          h || (h = [], r.set(c, h)), h.push(i);
        }
      },
      ":expression:exit"(a) {
        const {
          codePath: o,
          referenceMap: l
        } = n;
        if (!l)
          return;
        (a.type === "AwaitExpression" || a.type === "YieldExpression") && s.makeOutdated(o.currentSegments);
        const i = r.get(a);
        if (i) {
          r.delete(a);
          for (const u of i) {
            const c = u.resolved;
            s.isOutdated(o.currentSegments, c) && t.report({
              node: a.parent,
              messageId: "nonAtomicUpdate",
              data: {
                value: e.getText(a.parent.left)
              }
            });
          }
        }
      }
    };
  }
};
Lm.meta;
Lm.create;
function K8(t) {
  return t[0].toUpperCase() + t.slice(1);
}
var Rm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "disallow async functions which have no `await` expression",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/require-await"
    },
    schema: [],
    messages: {
      missingAwait: "{{name}} has no 'await' expression."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    let r = null;
    function s() {
      r = {
        upper: r,
        hasAwait: !1
      };
    }
    function n(a) {
      !a.generator && a.async && !r.hasAwait && !E.isEmptyFunction(a) && t.report({
        node: a,
        loc: E.getFunctionHeadLoc(a, e),
        messageId: "missingAwait",
        data: {
          name: K8(E.getFunctionNameWithKind(a))
        }
      }), r = r.upper;
    }
    return {
      FunctionDeclaration: s,
      FunctionExpression: s,
      ArrowFunctionExpression: s,
      "FunctionDeclaration:exit": n,
      "FunctionExpression:exit": n,
      "ArrowFunctionExpression:exit": n,
      AwaitExpression() {
        r && (r.hasAwait = !0);
      },
      ForOfStatement(a) {
        r && a.await && (r.hasAwait = !0);
      }
    };
  }
};
Rm.meta;
Rm.create;
var Nm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require JSDoc comments",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/require-jsdoc"
    },
    schema: [{
      type: "object",
      properties: {
        require: {
          type: "object",
          properties: {
            ClassDeclaration: {
              type: "boolean",
              default: !1
            },
            MethodDefinition: {
              type: "boolean",
              default: !1
            },
            FunctionDeclaration: {
              type: "boolean",
              default: !0
            },
            ArrowFunctionExpression: {
              type: "boolean",
              default: !1
            },
            FunctionExpression: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1,
          default: {}
        }
      },
      additionalProperties: !1
    }],
    deprecated: !0,
    replacedBy: [],
    messages: {
      missingJSDocComment: "Missing JSDoc comment."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = Object.assign({
      FunctionDeclaration: !0,
      MethodDefinition: !1,
      ClassDeclaration: !1,
      ArrowFunctionExpression: !1,
      FunctionExpression: !1
    }, t.options[0] && t.options[0].require);
    function s(a) {
      t.report({
        node: a,
        messageId: "missingJSDocComment"
      });
    }
    function n(a) {
      e.getJSDocComment(a) || s(a);
    }
    return {
      FunctionDeclaration(a) {
        r.FunctionDeclaration && n(a);
      },
      FunctionExpression(a) {
        (r.MethodDefinition && a.parent.type === "MethodDefinition" || r.FunctionExpression && (a.parent.type === "VariableDeclarator" || a.parent.type === "Property" && a === a.parent.value)) && n(a);
      },
      ClassDeclaration(a) {
        r.ClassDeclaration && n(a);
      },
      ArrowFunctionExpression(a) {
        r.ArrowFunctionExpression && a.parent.type === "VariableDeclarator" && n(a);
      }
    };
  }
};
Nm.meta;
Nm.create;
const {
  CALL: J8,
  CONSTRUCT: X8,
  ReferenceTracker: Q8,
  getStringIfConstant: Y8
} = Vt.default;
var jm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce the use of `u` flag on RegExp",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/require-unicode-regexp"
    },
    messages: {
      requireUFlag: "Use the 'u' flag."
    },
    schema: []
  },
  create(t) {
    return {
      "Literal[regex]"(e) {
        (e.regex.flags || "").includes("u") || t.report({
          node: e,
          messageId: "requireUFlag"
        });
      },
      Program() {
        const e = t.getScope(), r = new Q8(e), s = {
          RegExp: {
            [J8]: !0,
            [X8]: !0
          }
        };
        for (const {
          node: n
        } of r.iterateGlobalReferences(s)) {
          const a = n.arguments[1], o = Y8(a, e);
          (!a || typeof o == "string" && !o.includes("u")) && t.report({
            node: n,
            messageId: "requireUFlag"
          });
        }
      }
    };
  }
};
jm.meta;
jm.create;
var Mm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require generator functions to contain `yield`",
      category: "ECMAScript 6",
      recommended: !0,
      url: "https://eslint.org/docs/rules/require-yield"
    },
    schema: [],
    messages: {
      missingYield: "This generator function does not have 'yield'."
    }
  },
  create(t) {
    const e = [];
    function r(n) {
      n.generator && e.push(0);
    }
    function s(n) {
      if (!n.generator)
        return;
      e.pop() === 0 && n.body.body.length > 0 && t.report({
        node: n,
        messageId: "missingYield"
      });
    }
    return {
      FunctionDeclaration: r,
      "FunctionDeclaration:exit": s,
      FunctionExpression: r,
      "FunctionExpression:exit": s,
      YieldExpression() {
        e.length > 0 && (e[e.length - 1] += 1);
      }
    };
  }
};
Mm.meta;
Mm.create;
var $m = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce spacing between rest and spread operators and their expressions",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/rest-spread-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
      expectedWhitespace: "Expected whitespace after {{type}} operator."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] === "always";
    function s(n) {
      const a = e.getFirstToken(n), o = e.getTokenAfter(a), l = e.isSpaceBetweenTokens(a, o);
      let i;
      switch (n.type) {
        case "SpreadElement":
          i = "spread", n.parent.type === "ObjectExpression" && (i += " property");
          break;
        case "RestElement":
          i = "rest", n.parent.type === "ObjectPattern" && (i += " property");
          break;
        case "ExperimentalSpreadProperty":
          i = "spread property";
          break;
        case "ExperimentalRestProperty":
          i = "rest property";
          break;
        default:
          return;
      }
      r && !l ? t.report({
        node: n,
        loc: a.loc,
        messageId: "expectedWhitespace",
        data: {
          type: i
        },
        fix(u) {
          return u.replaceTextRange([a.range[1], o.range[0]], " ");
        }
      }) : !r && l && t.report({
        node: n,
        loc: {
          start: a.loc.end,
          end: o.loc.start
        },
        messageId: "unexpectedWhitespace",
        data: {
          type: i
        },
        fix(u) {
          return u.removeRange([a.range[1], o.range[0]]);
        }
      });
    }
    return {
      SpreadElement: s,
      RestElement: s,
      ExperimentalSpreadProperty: s,
      ExperimentalRestProperty: s
    };
  }
};
$m.meta;
$m.create;
var Vm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before and after semicolons",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/semi-spacing"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: !1
        },
        after: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
      unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
      missingWhitespaceBefore: "Missing whitespace before semicolon.",
      missingWhitespaceAfter: "Missing whitespace after semicolon."
    }
  },
  create(t) {
    const e = t.options[0], r = t.getSourceCode();
    let s = !1, n = !0;
    typeof e == "object" && (s = e.before, n = e.after);
    function a(h) {
      const p = r.getTokenBefore(h);
      return p && E.isTokenOnSameLine(p, h) && r.isSpaceBetweenTokens(p, h);
    }
    function o(h) {
      const p = r.getTokenAfter(h);
      return p && E.isTokenOnSameLine(h, p) && r.isSpaceBetweenTokens(h, p);
    }
    function l(h) {
      const p = r.getTokenAfter(h);
      return !(p && E.isTokenOnSameLine(h, p));
    }
    function i(h) {
      const p = r.getTokenBefore(h);
      return !(p && E.isTokenOnSameLine(h, p));
    }
    function u(h) {
      const p = r.getTokenAfter(h);
      return p && E.isClosingBraceToken(p) || E.isClosingParenToken(p);
    }
    function c(h, p) {
      if (E.isSemicolonToken(h)) {
        if (a(h)) {
          if (!s) {
            const m = r.getTokenBefore(h), d = {
              start: m.loc.end,
              end: h.loc.start
            };
            t.report({
              node: p,
              loc: d,
              messageId: "unexpectedWhitespaceBefore",
              fix(g) {
                return g.removeRange([m.range[1], h.range[0]]);
              }
            });
          }
        } else if (s) {
          const m = h.loc;
          t.report({
            node: p,
            loc: m,
            messageId: "missingWhitespaceBefore",
            fix(d) {
              return d.insertTextBefore(h, " ");
            }
          });
        }
        if (!i(h) && !l(h) && !u(h)) {
          if (o(h)) {
            if (!n) {
              const m = r.getTokenAfter(h), d = {
                start: h.loc.end,
                end: m.loc.start
              };
              t.report({
                node: p,
                loc: d,
                messageId: "unexpectedWhitespaceAfter",
                fix(g) {
                  return g.removeRange([h.range[1], m.range[0]]);
                }
              });
            }
          } else if (n) {
            const m = h.loc;
            t.report({
              node: p,
              loc: m,
              messageId: "missingWhitespaceAfter",
              fix(d) {
                return d.insertTextAfter(h, " ");
              }
            });
          }
        }
      }
    }
    function f(h) {
      const p = r.getLastToken(h);
      c(p, h);
    }
    return {
      VariableDeclaration: f,
      ExpressionStatement: f,
      BreakStatement: f,
      ContinueStatement: f,
      DebuggerStatement: f,
      DoWhileStatement: f,
      ReturnStatement: f,
      ThrowStatement: f,
      ImportDeclaration: f,
      ExportNamedDeclaration: f,
      ExportAllDeclaration: f,
      ExportDefaultDeclaration: f,
      ForStatement(h) {
        h.init && c(r.getTokenAfter(h.init), h), h.test && c(r.getTokenAfter(h.test), h);
      }
    };
  }
};
Vm.meta;
Vm.create;
const Z8 = ":matches(BreakStatement,ContinueStatement,DebuggerStatement,DoWhileStatement,ExportAllDeclaration,ExportDefaultDeclaration,ExportNamedDeclaration,ExpressionStatement,ImportDeclaration,ReturnStatement,ThrowStatement,VariableDeclaration)";
function e9(t) {
  const e = t.type;
  return e === "BlockStatement" || e === "Program" ? t.body : e === "SwitchCase" ? t.consequent : null;
}
function t9(t) {
  const e = t.parent.type;
  if (e === "IfStatement" && t.parent.consequent === t && t.parent.alternate || e === "DoWhileStatement")
    return !0;
  const r = e9(t.parent);
  return r !== null && r[r.length - 1] === t;
}
var Um = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce location of semicolons",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/semi-style"
    },
    schema: [{
      enum: ["last", "first"]
    }],
    fixable: "whitespace",
    messages: {
      expectedSemiColon: "Expected this semicolon to be at {{pos}}."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || "last";
    function s(n, a) {
      const o = e.getTokenBefore(n), l = e.getTokenAfter(n), i = !o || E.isTokenOnSameLine(o, n), u = !l || E.isTokenOnSameLine(n, l);
      (a === "last" && !i || a === "first" && !u) && t.report({
        loc: n.loc,
        messageId: "expectedSemiColon",
        data: {
          pos: a === "last" ? "the end of the previous line" : "the beginning of the next line"
        },
        fix(c) {
          if (o && l && e.commentsExistBetween(o, l))
            return null;
          const f = o ? o.range[1] : n.range[0], h = l ? l.range[0] : n.range[1], p = a === "last" ? `;
` : `
;`;
          return c.replaceTextRange([f, h], p);
        }
      });
    }
    return {
      [Z8](n) {
        if (r === "first" && t9(n))
          return;
        const a = e.getLastToken(n);
        E.isSemicolonToken(a) && s(a, r);
      },
      ForStatement(n) {
        const a = n.init && e.getTokenAfter(n.init, E.isSemicolonToken), o = n.test && e.getTokenAfter(n.test, E.isSemicolonToken);
        a && s(a, "last"), o && s(o, "last");
      }
    };
  }
};
Um.meta;
Um.create;
var qm = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow semicolons instead of ASI",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/semi"
    },
    fixable: "code",
    schema: {
      anyOf: [{
        type: "array",
        items: [{
          enum: ["never"]
        }, {
          type: "object",
          properties: {
            beforeStatementContinuationChars: {
              enum: ["always", "any", "never"]
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }, {
        type: "array",
        items: [{
          enum: ["always"]
        }, {
          type: "object",
          properties: {
            omitLastInOneLineBlock: {
              type: "boolean"
            }
          },
          additionalProperties: !1
        }],
        minItems: 0,
        maxItems: 2
      }]
    },
    messages: {
      missingSemi: "Missing semicolon.",
      extraSemi: "Extra semicolon."
    }
  },
  create(t) {
    const e = t.options[1], r = t.options[0] === "never", s = !!(e && e.omitLastInOneLineBlock), n = e && e.beforeStatementContinuationChars || "any", a = t.getSourceCode();
    function o(d, g) {
      const y = a.getLastToken(d);
      let x, A, b;
      g ? (x = "extraSemi", b = y.loc, A = function(v) {
        return new Qs(v, a).retainSurroundingTokens(y).remove(y);
      }) : (x = "missingSemi", b = {
        start: y.loc.end,
        end: E.getNextLocation(a, y.loc.end)
      }, A = function(v) {
        return v.insertTextAfter(y, ";");
      }), t.report({
        node: d,
        loc: b,
        messageId: x,
        fix: A
      });
    }
    function l(d) {
      const g = a.getTokenAfter(d);
      return !g || E.isClosingBraceToken(g) || E.isSemicolonToken(g);
    }
    function i(d) {
      if (!E.isClosingBraceToken(d))
        return !1;
      const g = a.getNodeByRangeIndex(d.range[0]);
      return g.type === "BlockStatement" && g.parent.type === "ArrowFunctionExpression";
    }
    function u(d) {
      const g = a.getLastToken(d, 1), y = a.getTokenAfter(d);
      return !!y && E.isTokenOnSameLine(g, y);
    }
    function c(d) {
      const g = d.type;
      return g === "DoWhileStatement" || g === "BreakStatement" || g === "ContinueStatement" || g === "DebuggerStatement" || g === "ImportDeclaration" || g === "ExportAllDeclaration" ? !1 : g === "ReturnStatement" ? !!d.argument : g === "ExportNamedDeclaration" ? !!d.declaration : !i(a.getLastToken(d, 1));
    }
    function f(d) {
      return !!d && /^[-[(/+`]/u.test(d.value) && d.value !== "++" && d.value !== "--";
    }
    function h(d) {
      return l(a.getLastToken(d)) ? !0 : u(d) ? !1 : n === "never" && !c(d) || !f(a.getTokenAfter(d));
    }
    function p(d) {
      const g = d.parent, y = a.getTokenAfter(d);
      return !y || y.value !== "}" ? !1 : !!g && g.type === "BlockStatement" && g.loc.start.line === g.loc.end.line;
    }
    function m(d) {
      const g = E.isSemicolonToken(a.getLastToken(d));
      if (r)
        g && h(d) ? o(d, !0) : !g && n === "always" && f(a.getTokenAfter(d)) && o(d);
      else {
        const y = s && p(d);
        g && y ? o(d, !0) : !g && !y && o(d);
      }
    }
    return {
      VariableDeclaration: function(d) {
        const g = d.parent;
        (g.type !== "ForStatement" || g.init !== d) && (!/^For(?:In|Of)Statement/u.test(g.type) || g.left !== d) && m(d);
      },
      ExpressionStatement: m,
      ReturnStatement: m,
      ThrowStatement: m,
      DoWhileStatement: m,
      DebuggerStatement: m,
      BreakStatement: m,
      ContinueStatement: m,
      ImportDeclaration: m,
      ExportAllDeclaration: m,
      ExportNamedDeclaration(d) {
        d.declaration || m(d);
      },
      ExportDefaultDeclaration(d) {
        /(?:Class|Function)Declaration/u.test(d.declaration.type) || m(d);
      }
    };
  }
};
qm.meta;
qm.create;
var Wm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce sorted import declarations within modules",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/sort-imports"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreCase: {
          type: "boolean",
          default: !1
        },
        memberSyntaxSortOrder: {
          type: "array",
          items: {
            enum: ["none", "all", "multiple", "single"]
          },
          uniqueItems: !0,
          minItems: 4,
          maxItems: 4
        },
        ignoreDeclarationSort: {
          type: "boolean",
          default: !1
        },
        ignoreMemberSort: {
          type: "boolean",
          default: !1
        },
        allowSeparatedGroups: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      sortImportsAlphabetically: "Imports should be sorted alphabetically.",
      sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
      unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.ignoreCase || !1, s = e.ignoreDeclarationSort || !1, n = e.ignoreMemberSort || !1, a = e.memberSyntaxSortOrder || ["none", "all", "multiple", "single"], o = e.allowSeparatedGroups || !1, l = t.getSourceCode();
    let i = null;
    function u(p) {
      return p.specifiers.length === 0 ? "none" : p.specifiers[0].type === "ImportNamespaceSpecifier" ? "all" : p.specifiers.length === 1 ? "single" : "multiple";
    }
    function c(p) {
      return a.indexOf(u(p));
    }
    function f(p) {
      return p.specifiers[0] ? p.specifiers[0].local.name : null;
    }
    function h(p, m) {
      return Math.max(m.loc.start.line - p.loc.end.line - 1, 0);
    }
    return {
      ImportDeclaration(p) {
        if (!s) {
          if (i && o && h(i, p) > 0 && (i = null), i) {
            const m = c(p), d = c(i);
            let g = f(p), y = f(i);
            r && (y = y && y.toLowerCase(), g = g && g.toLowerCase()), m !== d ? m < d && t.report({
              node: p,
              messageId: "unexpectedSyntaxOrder",
              data: {
                syntaxA: a[m],
                syntaxB: a[d]
              }
            }) : y && g && g < y && t.report({
              node: p,
              messageId: "sortImportsAlphabetically"
            });
          }
          i = p;
        }
        if (!n) {
          const m = p.specifiers.filter((y) => y.type === "ImportSpecifier"), d = r ? (y) => y.local.name.toLowerCase() : (y) => y.local.name, g = m.map(d).findIndex((y, x, A) => A[x - 1] > y);
          g !== -1 && t.report({
            node: m[g],
            messageId: "sortMembersAlphabetically",
            data: {
              memberName: m[g].local.name
            },
            fix(y) {
              return m.some((x) => l.getCommentsBefore(x).length || l.getCommentsAfter(x).length) ? null : y.replaceTextRange([m[0].range[0], m[m.length - 1].range[1]], m.slice().sort((x, A) => {
                const b = d(x), v = d(A);
                return b > v ? 1 : -1;
              }).reduce((x, A, b) => {
                const v = b === m.length - 1 ? "" : l.getText().slice(m[b].range[1], m[b + 1].range[0]);
                return x + l.getText(A) + v;
              }, ""));
            }
          });
        }
      }
    };
  }
};
Wm.meta;
Wm.create;
function r9(t) {
  const e = E.getStaticPropertyName(t);
  return e !== null ? e : t.key.name || null;
}
const Ts = {
  asc(t, e) {
    return t <= e;
  },
  ascI(t, e) {
    return t.toLowerCase() <= e.toLowerCase();
  },
  ascN(t, e) {
    return my.default(t, e) <= 0;
  },
  ascIN(t, e) {
    return my.default(t.toLowerCase(), e.toLowerCase()) <= 0;
  },
  desc(t, e) {
    return Ts.asc(e, t);
  },
  descI(t, e) {
    return Ts.ascI(e, t);
  },
  descN(t, e) {
    return Ts.ascN(e, t);
  },
  descIN(t, e) {
    return Ts.ascIN(e, t);
  }
};
var zm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require object keys to be sorted",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/sort-keys"
    },
    schema: [{
      enum: ["asc", "desc"]
    }, {
      type: "object",
      properties: {
        caseSensitive: {
          type: "boolean",
          default: !0
        },
        natural: {
          type: "boolean",
          default: !1
        },
        minKeys: {
          type: "integer",
          minimum: 2,
          default: 2
        }
      },
      additionalProperties: !1
    }],
    messages: {
      sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."
    }
  },
  create(t) {
    const e = t.options[0] || "asc", r = t.options[1], s = r && r.caseSensitive === !1, n = r && r.natural, a = r && r.minKeys, o = Ts[e + (s ? "I" : "") + (n ? "N" : "")];
    let l = null;
    return {
      ObjectExpression(i) {
        l = {
          upper: l,
          prevName: null,
          numKeys: i.properties.length
        };
      },
      "ObjectExpression:exit"() {
        l = l.upper;
      },
      SpreadElement(i) {
        i.parent.type === "ObjectExpression" && (l.prevName = null);
      },
      Property(i) {
        if (i.parent.type === "ObjectPattern")
          return;
        const u = l.prevName, c = l.numKeys, f = r9(i);
        f !== null && (l.prevName = f), !(u === null || f === null || c < a) && (o(u, f) || t.report({
          node: i,
          loc: i.key.loc,
          messageId: "sortKeys",
          data: {
            thisName: f,
            prevName: u,
            order: e,
            insensitive: s ? "insensitive " : "",
            natural: n ? "natural " : ""
          }
        }));
      }
    };
  }
};
zm.meta;
zm.create;
var Gm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require variables within the same declaration block to be sorted",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/sort-vars"
    },
    schema: [{
      type: "object",
      properties: {
        ignoreCase: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      sortVars: "Variables within the same declaration block should be sorted alphabetically."
    }
  },
  create(t) {
    const e = t.options[0] || {}, r = e.ignoreCase || !1, s = t.getSourceCode();
    return {
      VariableDeclaration(n) {
        const a = n.declarations.filter((u) => u.id.type === "Identifier"), o = r ? (u) => u.id.name.toLowerCase() : (u) => u.id.name, l = a.some((u) => u.init !== null && u.init.type !== "Literal");
        let i = !1;
        a.slice(1).reduce((u, c) => {
          const f = o(u);
          return o(c) < f ? (t.report({
            node: c,
            messageId: "sortVars",
            fix(p) {
              return l || i ? null : p.replaceTextRange([a[0].range[0], a[a.length - 1].range[1]], a.slice().sort((m, d) => {
                const g = o(m), y = o(d);
                return g > y ? 1 : -1;
              }).reduce((m, d, g) => {
                const y = g === a.length - 1 ? "" : s.getText().slice(a[g].range[1], a[g + 1].range[0]);
                return m + s.getText(d) + y;
              }, ""));
            }
          }), i = !0, u) : c;
        }, a[0]);
      }
    };
  }
};
Gm.meta;
Gm.create;
function m0(t) {
  const e = t.parent;
  return t.type === "BlockStatement" && E.isFunction(e) && e.body === t;
}
var Hm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before blocks",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/space-before-blocks"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          keywords: {
            enum: ["always", "never", "off"]
          },
          functions: {
            enum: ["always", "never", "off"]
          },
          classes: {
            enum: ["always", "never", "off"]
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      unexpectedSpace: "Unexpected space before opening brace.",
      missingSpace: "Missing space before opening brace."
    }
  },
  create(t) {
    const e = t.options[0], r = t.getSourceCode();
    let s = !0, n = !0, a = !0, o = !1, l = !1, i = !1;
    typeof e == "object" ? (s = e.functions === "always", n = e.keywords === "always", a = e.classes === "always", o = e.functions === "never", l = e.keywords === "never", i = e.classes === "never") : e === "never" && (s = !1, n = !1, a = !1, o = !0, l = !0, i = !0);
    function u(f, h) {
      return E.isArrowToken(f) || E.isKeywordToken(f) && !m0(h);
    }
    function c(f) {
      const h = r.getTokenBefore(f);
      if (h && !u(h, f) && E.isTokenOnSameLine(h, f)) {
        const p = r.isSpaceBetweenTokens(h, f);
        let m, d;
        m0(f) ? (m = s, d = o) : f.type === "ClassBody" ? (m = a, d = i) : (m = n, d = l), m && !p ? t.report({
          node: f,
          messageId: "missingSpace",
          fix(g) {
            return g.insertTextBefore(f, " ");
          }
        }) : d && p && t.report({
          node: f,
          messageId: "unexpectedSpace",
          fix(g) {
            return g.removeRange([h.range[1], f.range[0]]);
          }
        });
      }
    }
    return {
      BlockStatement: c,
      ClassBody: c,
      SwitchStatement: function(f) {
        const h = f.cases;
        let p;
        h.length > 0 ? p = r.getTokenBefore(h[0]) : p = r.getLastToken(f, 1), c(p);
      }
    };
  }
};
Hm.meta;
Hm.create;
var Km = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before `function` definition opening parenthesis",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/space-before-function-paren"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["always", "never"]
      }, {
        type: "object",
        properties: {
          anonymous: {
            enum: ["always", "never", "ignore"]
          },
          named: {
            enum: ["always", "never", "ignore"]
          },
          asyncArrow: {
            enum: ["always", "never", "ignore"]
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      unexpectedSpace: "Unexpected space before function parentheses.",
      missingSpace: "Missing space before function parentheses."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = typeof t.options[0] == "string" ? t.options[0] : "always", s = typeof t.options[0] == "object" ? t.options[0] : {};
    function n(l) {
      if (l.id)
        return !0;
      const i = l.parent;
      return i.type === "MethodDefinition" || i.type === "Property" && (i.kind === "get" || i.kind === "set" || i.method);
    }
    function a(l) {
      if (l.type === "ArrowFunctionExpression") {
        if (l.async && E.isOpeningParenToken(e.getFirstToken(l, {
          skip: 1
        })))
          return s.asyncArrow || r;
      } else {
        if (n(l))
          return s.named || r;
        if (!l.generator)
          return s.anonymous || r;
      }
      return "ignore";
    }
    function o(l) {
      const i = a(l);
      if (i === "ignore")
        return;
      const u = e.getFirstToken(l, E.isOpeningParenToken), c = e.getTokenBefore(u), f = e.isSpaceBetweenTokens(c, u);
      f && i === "never" ? t.report({
        node: l,
        loc: {
          start: c.loc.end,
          end: u.loc.start
        },
        messageId: "unexpectedSpace",
        fix(h) {
          const p = e.getCommentsBefore(u);
          return p.some((m) => m.type === "Line") ? null : h.replaceTextRange([c.range[1], u.range[0]], p.reduce((m, d) => m + e.getText(d), ""));
        }
      }) : !f && i === "always" && t.report({
        node: l,
        loc: u.loc,
        messageId: "missingSpace",
        fix: (h) => h.insertTextAfter(c, " ")
      });
    }
    return {
      ArrowFunctionExpression: o,
      FunctionDeclaration: o,
      FunctionExpression: o
    };
  }
};
Km.meta;
Km.create;
var Jm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing inside parentheses",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/space-in-parens"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            enum: ["{}", "[]", "()", "empty"]
          },
          uniqueItems: !0
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missingOpeningSpace: "There must be a space after this paren.",
      missingClosingSpace: "There must be a space before this paren.",
      rejectedOpeningSpace: "There should be no space after this paren.",
      rejectedClosingSpace: "There should be no space before this paren."
    }
  },
  create(t) {
    const e = t.options[0] === "always", r = t.options[1] && t.options[1].exceptions || [], s = {};
    let n;
    r.length && (s.braceException = r.includes("{}"), s.bracketException = r.includes("[]"), s.parenException = r.includes("()"), s.empty = r.includes("empty"));
    function a() {
      const p = [], m = [];
      return s.braceException && (p.push("{"), m.push("}")), s.bracketException && (p.push("["), m.push("]")), s.parenException && (p.push("("), m.push(")")), s.empty && (p.push(")"), m.push("(")), {
        openers: p,
        closers: m
      };
    }
    const o = t.getSourceCode();
    function l(p) {
      return n.openers.includes(p.value);
    }
    function i(p) {
      return n.closers.includes(p.value);
    }
    function u(p, m) {
      return o.isSpaceBetweenTokens(p, m) || !s.empty && E.isClosingParenToken(m) ? !1 : e ? !l(m) : l(m);
    }
    function c(p, m) {
      return !E.isTokenOnSameLine(p, m) || m.type === "Line" || !o.isSpaceBetweenTokens(p, m) ? !1 : e ? l(m) : !l(m);
    }
    function f(p, m) {
      return o.isSpaceBetweenTokens(p, m) || !s.empty && E.isOpeningParenToken(p) ? !1 : e ? !i(p) : i(p);
    }
    function h(p, m) {
      return !E.isTokenOnSameLine(p, m) || !o.isSpaceBetweenTokens(p, m) ? !1 : e ? i(p) : !i(p);
    }
    return {
      Program: function(p) {
        n = a();
        const m = o.tokensAndComments;
        m.forEach((d, g) => {
          const y = m[g - 1], x = m[g + 1];
          !E.isOpeningParenToken(d) && !E.isClosingParenToken(d) || (d.value === "(" && u(d, x) && t.report({
            node: p,
            loc: d.loc,
            messageId: "missingOpeningSpace",
            fix(A) {
              return A.insertTextAfter(d, " ");
            }
          }), d.value === "(" && c(d, x) && t.report({
            node: p,
            loc: {
              start: d.loc.end,
              end: x.loc.start
            },
            messageId: "rejectedOpeningSpace",
            fix(A) {
              return A.removeRange([d.range[1], x.range[0]]);
            }
          }), d.value === ")" && f(y, d) && t.report({
            node: p,
            loc: d.loc,
            messageId: "missingClosingSpace",
            fix(A) {
              return A.insertTextBefore(d, " ");
            }
          }), d.value === ")" && h(y, d) && t.report({
            node: p,
            loc: {
              start: y.loc.end,
              end: d.loc.start
            },
            messageId: "rejectedClosingSpace",
            fix(A) {
              return A.removeRange([y.range[1], d.range[0]]);
            }
          }));
        });
      }
    };
  }
};
Jm.meta;
Jm.create;
var Xm = {
  meta: {
    type: "layout",
    docs: {
      description: "require spacing around infix operators",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/space-infix-ops"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        int32Hint: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      missingSpace: "Operator '{{operator}}' must be spaced."
    }
  },
  create(t) {
    const e = t.options[0] ? t.options[0].int32Hint === !0 : !1, r = t.getSourceCode();
    function s(o, l, i) {
      const u = r.getFirstTokenBetween(o, l, (h) => h.value === i), c = r.getTokenBefore(u), f = r.getTokenAfter(u);
      return !r.isSpaceBetweenTokens(c, u) || !r.isSpaceBetweenTokens(u, f) ? u : null;
    }
    function n(o, l) {
      t.report({
        node: o,
        loc: l.loc,
        messageId: "missingSpace",
        data: {
          operator: l.value
        },
        fix(i) {
          const u = r.getTokenBefore(l), c = r.getTokenAfter(l);
          let f = "";
          return l.range[0] - u.range[1] === 0 && (f = " "), f += l.value, c.range[0] - l.range[1] === 0 && (f += " "), i.replaceText(l, f);
        }
      });
    }
    function a(o) {
      const l = o.left.typeAnnotation ? o.left.typeAnnotation : o.left, i = o.right, u = o.operator || "=", c = s(l, i, u);
      c && (e && r.getText(o).endsWith("|0") || n(o, c));
    }
    return {
      AssignmentExpression: a,
      AssignmentPattern: a,
      BinaryExpression: a,
      LogicalExpression: a,
      ConditionalExpression: function(o) {
        const l = s(o.test, o.consequent, "?"), i = s(o.consequent, o.alternate, ":");
        l && n(o, l), i && n(o, i);
      },
      VariableDeclarator: function(o) {
        const l = o.id.typeAnnotation ? o.id.typeAnnotation : o.id, i = o.init;
        if (i) {
          const u = s(l, i, "=");
          u && n(o, u);
        }
      }
    };
  }
};
Xm.meta;
Xm.create;
var Qm = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce consistent spacing before or after unary operators",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/space-unary-ops"
    },
    fixable: "whitespace",
    schema: [{
      type: "object",
      properties: {
        words: {
          type: "boolean",
          default: !0
        },
        nonwords: {
          type: "boolean",
          default: !1
        },
        overrides: {
          type: "object",
          additionalProperties: {
            type: "boolean"
          }
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
      unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
      unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
      wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
      operator: "Unary operator '{{operator}}' must be followed by whitespace.",
      beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
    }
  },
  create(t) {
    const e = t.options[0] || {
      words: !0,
      nonwords: !1
    }, r = t.getSourceCode();
    function s(h) {
      return h && h.type === "UnaryExpression" && h.argument.operator === "!" && h.argument && h.argument.type === "UnaryExpression" && h.argument.operator === "!";
    }
    function n(h) {
      return e.overrides && Object.prototype.hasOwnProperty.call(e.overrides, h);
    }
    function a(h) {
      return e.overrides[h];
    }
    function o(h, p, m, d) {
      m.range[0] === p.range[1] && t.report({
        node: h,
        messageId: "wordOperator",
        data: {
          word: d
        },
        fix(g) {
          return g.insertTextAfter(p, " ");
        }
      });
    }
    function l(h, p, m, d) {
      E.canTokensBeAdjacent(p, m) && m.range[0] > p.range[1] && t.report({
        node: h,
        messageId: "unexpectedAfterWord",
        data: {
          word: d
        },
        fix(g) {
          return g.removeRange([p.range[1], m.range[0]]);
        }
      });
    }
    function i(h, p, m, d) {
      n(d) ? a(d) ? o(h, p, m, d) : l(h, p, m, d) : e.words ? o(h, p, m, d) : l(h, p, m, d);
    }
    function u(h, p, m) {
      if (h.prefix) {
        if (s(h))
          return;
        p.range[1] === m.range[0] && t.report({
          node: h,
          messageId: "operator",
          data: {
            operator: p.value
          },
          fix(d) {
            return d.insertTextAfter(p, " ");
          }
        });
      } else
        p.range[1] === m.range[0] && t.report({
          node: h,
          messageId: "beforeUnaryExpressions",
          data: {
            token: m.value
          },
          fix(d) {
            return d.insertTextBefore(m, " ");
          }
        });
    }
    function c(h, p, m) {
      h.prefix ? m.range[0] > p.range[1] && t.report({
        node: h,
        messageId: "unexpectedAfter",
        data: {
          operator: p.value
        },
        fix(d) {
          return E.canTokensBeAdjacent(p, m) ? d.removeRange([p.range[1], m.range[0]]) : null;
        }
      }) : m.range[0] > p.range[1] && t.report({
        node: h,
        messageId: "unexpectedBefore",
        data: {
          operator: m.value
        },
        fix(d) {
          return d.removeRange([p.range[1], m.range[0]]);
        }
      });
    }
    function f(h) {
      const p = h.type === "UpdateExpression" && !h.prefix ? r.getLastTokens(h, 2) : r.getFirstTokens(h, 2), m = p[0], d = p[1];
      if ((h.type === "NewExpression" || h.prefix) && m.type === "Keyword") {
        i(h, m, d, m.value);
        return;
      }
      const g = h.prefix ? p[0].value : p[1].value;
      n(g) ? a(g) ? u(h, m, d) : c(h, m, d) : e.nonwords ? u(h, m, d) : c(h, m, d);
    }
    return {
      UnaryExpression: f,
      UpdateExpression: f,
      NewExpression: f,
      YieldExpression: function(h) {
        const p = r.getFirstTokens(h, 3);
        !h.argument || h.delegate || i(h, p[0], p[1], "yield");
      },
      AwaitExpression: function(h) {
        const p = r.getFirstTokens(h, 3);
        i(h, p[0], p[1], "await");
      }
    };
  }
};
Qm.meta;
Qm.create;
function qs(t) {
  return `(?:${Ju.default(t)})`;
}
function d0(t) {
  return `${qs(t)}+`;
}
function n9(t) {
  return t.indexOf("*") === -1 ? t.concat("*") : t;
}
function Ub(t) {
  let e = "";
  return t.length === 0 ? e += "\\s" : (e += "(?:\\s|", t.length === 1 ? e += d0(t[0]) : (e += "(?:", e += t.map(d0).join("|"), e += ")"), e += `(?:$|[${Array.from(E.LINEBREAKS).join("")}]))`), e;
}
function s9(t, e) {
  let r = "^";
  return t.length === 1 ? r += qs(t[0]) : (r += "(?:", r += t.map(qs).join("|"), r += ")"), r += "?", r += Ub(e), new RegExp(r, "u");
}
function a9(t) {
  const e = `^(${t.map(qs).join("|")})?[ 	]+`;
  return new RegExp(e, "u");
}
var Ym = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce consistent spacing after the `//` or `/*` in a comment",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/spaced-comment"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptions: {
          type: "array",
          items: {
            type: "string"
          }
        },
        markers: {
          type: "array",
          items: {
            type: "string"
          }
        },
        line: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: !1
        },
        block: {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            },
            balanced: {
              type: "boolean",
              default: !1
            }
          },
          additionalProperties: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
      expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
      unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
      unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
      expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
      expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] !== "never", s = t.options[1] || {}, n = s.block && s.block.balanced, a = ["block", "line"].reduce((u, c) => {
      const f = n9(s[c] && s[c].markers || s.markers || []), h = s[c] && s[c].exceptions || s.exceptions || [];
      return u[c] = {
        beginRegex: r ? s9(f, h) : a9(f),
        endRegex: n && r ? new RegExp(`${Ub(h)}$`, "u") : new RegExp("[ 	]+$", "u"),
        hasExceptions: h.length > 0,
        captureMarker: new RegExp(`^(${f.map(qs).join("|")})`, "u"),
        markers: new Set(f)
      }, u;
    }, {});
    function o(u, c, f, h) {
      const p = u.type.toLowerCase(), m = p === "block" ? "/*" : "//";
      t.report({
        node: u,
        fix(d) {
          const g = u.range[0];
          let y = g + 2;
          return r ? (f && (y += f[0].length), d.insertTextAfterRange([g, y], " ")) : (y += f[0].length, d.replaceTextRange([g, y], m + (f[1] ? f[1] : "")));
        },
        messageId: c,
        data: {
          refChar: h
        }
      });
    }
    function l(u, c, f) {
      t.report({
        node: u,
        fix(h) {
          if (r)
            return h.insertTextAfterRange([u.range[0], u.range[1] - 2], " ");
          const p = u.range[1] - 2, m = p - f[0].length;
          return h.replaceTextRange([m, p], "");
        },
        messageId: c
      });
    }
    function i(u) {
      const c = u.type.toLowerCase(), f = a[c], h = c === "block" ? "/*" : "//";
      if (u.value.length === 0 || f.markers.has(u.value))
        return;
      const p = f.beginRegex.exec(u.value), m = f.endRegex.exec(u.value);
      if (r) {
        if (!p) {
          const d = f.captureMarker.exec(u.value), g = d ? h + d[0] : h;
          f.hasExceptions ? o(u, "expectedExceptionAfter", d, g) : o(u, "expectedSpaceAfter", d, g);
        }
        n && c === "block" && !m && l(u, "expectedSpaceBefore");
      } else
        p && (p[1] ? o(u, "unexpectedSpaceAfterMarker", p, p[1]) : o(u, "unexpectedSpaceAfter", p, h)), n && c === "block" && m && l(u, "unexpectedSpaceBefore", m);
    }
    return {
      Program() {
        e.getAllComments().filter((c) => c.type !== "Shebang").forEach(i);
      }
    };
  }
};
Ym.meta;
Ym.create;
function g0(t) {
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    if (s.type === "ExpressionStatement" && s.expression.type === "Literal" && s.expression.value === "use strict")
      e[r] = s;
    else
      break;
  }
  return e;
}
function i9(t) {
  return t.type === "Identifier";
}
function tl(t) {
  return t.every(i9);
}
var Zm = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require or disallow strict mode directives",
      category: "Strict Mode",
      recommended: !1,
      url: "https://eslint.org/docs/rules/strict"
    },
    schema: [{
      enum: ["never", "global", "function", "safe"]
    }],
    fixable: "code",
    messages: {
      function: "Use the function form of 'use strict'.",
      global: "Use the global form of 'use strict'.",
      multiple: "Multiple 'use strict' directives.",
      never: "Strict mode is not permitted.",
      unnecessary: "Unnecessary 'use strict' directive.",
      module: "'use strict' is unnecessary inside of modules.",
      implied: "'use strict' is unnecessary when implied strict mode is enabled.",
      unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
      nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
      wrap: "Wrap {{name}} in a function with 'use strict' directive."
    }
  },
  create(t) {
    const e = t.parserOptions.ecmaFeatures || {}, r = [], s = [];
    let n = t.options[0] || "safe";
    e.impliedStrict ? n = "implied" : n === "safe" && (n = e.globalReturn ? "global" : "function");
    function a(m) {
      return m === "multiple" || m === "unnecessary" || m === "module" || m === "implied" || m === "unnecessaryInClasses";
    }
    function o(m) {
      return (d) => d.remove(m);
    }
    function l(m, d, g, y, x) {
      m.slice(d, g).forEach((A) => {
        t.report({
          node: A,
          messageId: y,
          fix: x ? o(A) : null
        });
      });
    }
    function i(m, d, g) {
      l(m, 0, m.length, d, g);
    }
    function u(m, d, g) {
      l(m, 1, m.length, d, g);
    }
    function c(m, d) {
      const g = s.length > 0, y = r.length === 0 && s.length === 0, x = r.length > 0 && r[r.length - 1], A = d.length > 0;
      A ? (tl(m.params) ? x ? t.report({
        node: d[0],
        messageId: "unnecessary",
        fix: o(d[0])
      }) : g && t.report({
        node: d[0],
        messageId: "unnecessaryInClasses",
        fix: o(d[0])
      }) : t.report({
        node: d[0],
        messageId: "nonSimpleParameterList"
      }), u(d, "multiple", !0)) : y && (tl(m.params) ? t.report({
        node: m,
        messageId: "function"
      }) : t.report({
        node: m,
        messageId: "wrap",
        data: {
          name: E.getFunctionNameWithKind(m)
        }
      })), r.push(x || A);
    }
    function f() {
      r.pop();
    }
    function h(m) {
      const d = m.body.type === "BlockStatement", g = d ? g0(m.body.body) : [];
      n === "function" ? c(m, g) : g.length > 0 && (tl(m.params) ? i(g, n, a(n)) : (t.report({
        node: g[0],
        messageId: "nonSimpleParameterList"
      }), u(g, "multiple", !0)));
    }
    const p = {
      Program(m) {
        const d = g0(m.body);
        m.sourceType === "module" && (n = "module"), n === "global" ? (m.body.length > 0 && d.length === 0 && t.report({
          node: m,
          messageId: "global"
        }), u(d, "multiple", !0)) : i(d, n, a(n));
      },
      FunctionDeclaration: h,
      FunctionExpression: h,
      ArrowFunctionExpression: h
    };
    return n === "function" && Object.assign(p, {
      ClassBody() {
        s.push(!0);
      },
      "ClassBody:exit"() {
        s.pop();
      },
      "FunctionDeclaration:exit": f,
      "FunctionExpression:exit": f,
      "ArrowFunctionExpression:exit": f
    }), p;
  }
};
Zm.meta;
Zm.create;
var ed = {
  meta: {
    type: "layout",
    docs: {
      description: "enforce spacing around colons of switch statements",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/switch-colon-spacing"
    },
    schema: [{
      type: "object",
      properties: {
        before: {
          type: "boolean",
          default: !1
        },
        after: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    fixable: "whitespace",
    messages: {
      expectedBefore: "Expected space(s) before this colon.",
      expectedAfter: "Expected space(s) after this colon.",
      unexpectedBefore: "Unexpected space(s) before this colon.",
      unexpectedAfter: "Unexpected space(s) after this colon."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] || {}, s = r.before === !0, n = r.after !== !1;
    function a(u) {
      return u.test ? e.getTokenAfter(u.test, E.isColonToken) : e.getFirstToken(u, 1);
    }
    function o(u, c, f) {
      return E.isClosingBraceToken(c) || !E.isTokenOnSameLine(u, c) || e.isSpaceBetweenTokens(u, c) === f;
    }
    function l(u, c) {
      return e.getFirstTokenBetween(u, c, {
        includeComments: !0,
        filter: E.isCommentToken
      }) !== null;
    }
    function i(u, c, f, h) {
      return l(c, f) ? null : h ? u.insertTextAfter(c, " ") : u.removeRange([c.range[1], f.range[0]]);
    }
    return {
      SwitchCase(u) {
        const c = a(u), f = e.getTokenBefore(c), h = e.getTokenAfter(c);
        o(f, c, s) || t.report({
          node: u,
          loc: c.loc,
          messageId: s ? "expectedBefore" : "unexpectedBefore",
          fix: (p) => i(p, f, c, s)
        }), o(c, h, n) || t.report({
          node: u,
          loc: c.loc,
          messageId: n ? "expectedAfter" : "unexpectedAfter",
          fix: (p) => i(p, c, h, n)
        });
      }
    };
  }
};
ed.meta;
ed.create;
var td = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require symbol descriptions",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/symbol-description"
    },
    fixable: null,
    schema: [],
    messages: {
      expected: "Expected Symbol to have a description."
    }
  },
  create(t) {
    function e(r) {
      r.arguments.length === 0 && t.report({
        node: r,
        messageId: "expected"
      });
    }
    return {
      "Program:exit"() {
        const r = t.getScope(), s = E.getVariableByName(r, "Symbol");
        s && s.defs.length === 0 && s.references.forEach((n) => {
          const a = n.identifier;
          E.isCallee(a) && e(a.parent);
        });
      }
    };
  }
};
td.meta;
td.create;
var rd = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing around embedded expressions of template strings",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/template-curly-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      expectedBefore: "Expected space(s) before '}'.",
      expectedAfter: "Expected space(s) after '${'.",
      unexpectedBefore: "Unexpected space(s) before '}'.",
      unexpectedAfter: "Unexpected space(s) after '${'."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = t.options[0] === "always";
    function s(a) {
      if (!a.value.startsWith("}"))
        return;
      const o = e.getTokenBefore(a, {
        includeComments: !0
      }), l = e.isSpaceBetween(o, a);
      E.isTokenOnSameLine(o, a) && (r && !l && t.report({
        loc: {
          start: a.loc.start,
          end: {
            line: a.loc.start.line,
            column: a.loc.start.column + 1
          }
        },
        messageId: "expectedBefore",
        fix: (i) => i.insertTextBefore(a, " ")
      }), !r && l && t.report({
        loc: {
          start: o.loc.end,
          end: a.loc.start
        },
        messageId: "unexpectedBefore",
        fix: (i) => i.removeRange([o.range[1], a.range[0]])
      }));
    }
    function n(a) {
      if (!a.value.endsWith("${"))
        return;
      const o = e.getTokenAfter(a, {
        includeComments: !0
      }), l = e.isSpaceBetween(a, o);
      E.isTokenOnSameLine(a, o) && (r && !l && t.report({
        loc: {
          start: {
            line: a.loc.end.line,
            column: a.loc.end.column - 2
          },
          end: a.loc.end
        },
        messageId: "expectedAfter",
        fix: (i) => i.insertTextAfter(a, " ")
      }), !r && l && t.report({
        loc: {
          start: a.loc.end,
          end: o.loc.start
        },
        messageId: "unexpectedAfter",
        fix: (i) => i.removeRange([a.range[1], o.range[0]])
      }));
    }
    return {
      TemplateElement(a) {
        const o = e.getFirstToken(a);
        s(o), n(o);
      }
    };
  }
};
rd.meta;
rd.create;
var nd = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing between template tags and their literals",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/template-tag-spacing"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      unexpected: "Unexpected space between template tag and template literal.",
      missing: "Missing space between template tag and template literal."
    }
  },
  create(t) {
    const e = t.options[0] !== "always", r = t.getSourceCode();
    return {
      TaggedTemplateExpression: function(s) {
        const n = r.getTokenBefore(s.quasi), a = r.getFirstToken(s.quasi), o = r.isSpaceBetweenTokens(n, a);
        e && o ? t.report({
          node: s,
          loc: {
            start: n.loc.end,
            end: a.loc.start
          },
          messageId: "unexpected",
          fix(l) {
            const i = r.getCommentsBefore(s.quasi);
            return i.some((u) => u.type === "Line") ? null : l.replaceTextRange([n.range[1], a.range[0]], i.reduce((u, c) => u + r.getText(c), ""));
          }
        }) : !e && !o && t.report({
          node: s,
          loc: {
            start: s.loc.start,
            end: a.loc.start
          },
          messageId: "missing",
          fix(l) {
            return l.insertTextAfter(n, " ");
          }
        });
      }
    };
  }
};
nd.meta;
nd.create;
var sd = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow Unicode byte order mark (BOM)",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/unicode-bom"
    },
    fixable: "whitespace",
    schema: [{
      enum: ["always", "never"]
    }],
    messages: {
      expected: "Expected Unicode BOM (Byte Order Mark).",
      unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
    }
  },
  create(t) {
    return {
      Program: function(e) {
        const r = t.getSourceCode(), s = {
          column: 0,
          line: 1
        }, n = t.options[0] || "never";
        !r.hasBOM && n === "always" ? t.report({
          node: e,
          loc: s,
          messageId: "expected",
          fix(a) {
            return a.insertTextBeforeRange([0, 1], "\uFEFF");
          }
        }) : r.hasBOM && n === "never" && t.report({
          node: e,
          loc: s,
          messageId: "unexpected",
          fix(a) {
            return a.removeRange([-1, 0]);
          }
        });
      }
    };
  }
};
sd.meta;
sd.create;
function bs(t) {
  return !!t && (E.isSpecificId(t, "NaN") || E.isSpecificMemberAccess(t, "Number", "NaN"));
}
var ad = {
  meta: {
    type: "problem",
    docs: {
      description: "require calls to `isNaN()` when checking for `NaN`",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/use-isnan"
    },
    schema: [{
      type: "object",
      properties: {
        enforceForSwitchCase: {
          type: "boolean",
          default: !0
        },
        enforceForIndexOf: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      comparisonWithNaN: "Use the isNaN function to compare with NaN.",
      switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
      caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.",
      indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN."
    }
  },
  create(t) {
    const e = !t.options[0] || t.options[0].enforceForSwitchCase, r = t.options[0] && t.options[0].enforceForIndexOf;
    function s(o) {
      bs(o.discriminant) && t.report({
        node: o,
        messageId: "switchNaN"
      });
      for (const l of o.cases)
        bs(l.test) && t.report({
          node: l,
          messageId: "caseNaN"
        });
    }
    function n(o) {
      const l = E.skipChainExpression(o.callee);
      if (l.type === "MemberExpression") {
        const i = E.getStaticPropertyName(l);
        (i === "indexOf" || i === "lastIndexOf") && o.arguments.length === 1 && bs(o.arguments[0]) && t.report({
          node: o,
          messageId: "indexOfNaN",
          data: {
            methodName: i
          }
        });
      }
    }
    const a = {
      BinaryExpression: function(o) {
        /^(?:[<>]|[!=]=)=?$/u.test(o.operator) && (bs(o.left) || bs(o.right)) && t.report({
          node: o,
          messageId: "comparisonWithNaN"
        });
      }
    };
    return e && (a.SwitchStatement = s), r && (a.CallExpression = n), a;
  }
};
ad.meta;
ad.create;
var id = {
  meta: {
    type: "suggestion",
    docs: {
      description: "enforce valid JSDoc comments",
      category: "Possible Errors",
      recommended: !1,
      url: "https://eslint.org/docs/rules/valid-jsdoc"
    },
    schema: [{
      type: "object",
      properties: {
        prefer: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        preferType: {
          type: "object",
          additionalProperties: {
            type: "string"
          }
        },
        requireReturn: {
          type: "boolean",
          default: !0
        },
        requireParamDescription: {
          type: "boolean",
          default: !0
        },
        requireReturnDescription: {
          type: "boolean",
          default: !0
        },
        matchDescription: {
          type: "string"
        },
        requireReturnType: {
          type: "boolean",
          default: !0
        },
        requireParamType: {
          type: "boolean",
          default: !0
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
      expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
      use: "Use @{{name}} instead.",
      useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
      syntaxError: "JSDoc syntax error.",
      missingBrace: "JSDoc type missing brace.",
      missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
      missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
      missingReturnType: "Missing JSDoc return type.",
      missingReturnDesc: "Missing JSDoc return description.",
      missingReturn: "Missing JSDoc @{{returns}} for function.",
      missingParam: "Missing JSDoc for parameter '{{name}}'.",
      duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
      unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
    },
    deprecated: !0,
    replacedBy: []
  },
  create(t) {
    const e = t.options[0] || {}, r = e.prefer || {}, s = t.getSourceCode(), n = e.requireReturn !== !1, a = e.requireParamDescription !== !1, o = e.requireReturnDescription !== !1, l = e.requireReturnType !== !1, i = e.requireParamType !== !1, u = e.preferType || {}, c = Object.keys(u).length !== 0, f = [];
    function h(b) {
      return b.type === "ClassExpression" || b.type === "ClassDeclaration";
    }
    function p(b) {
      f.push({
        returnPresent: b.type === "ArrowFunctionExpression" && b.body.type !== "BlockStatement" || h(b) || b.async
      });
    }
    function m(b) {
      return b.type === null || b.type.name === "void" || b.type.type === "UndefinedLiteral";
    }
    function d(b) {
      return b !== "UndefinedLiteral" && b !== "NullLiteral" && b !== "NullableLiteral" && b !== "FunctionType" && b !== "AllLiteral";
    }
    function g(b) {
      let v;
      return b.name ? v = b : b.expression && (v = b.expression), {
        currentType: v,
        expectedTypeName: v && u[v.name]
      };
    }
    function y(b, v) {
      return {
        start: s.getLocFromIndex(b.range[0] + 2 + v.range[0]),
        end: s.getLocFromIndex(b.range[0] + 2 + v.range[1])
      };
    }
    function x(b, v) {
      if (!v || !d(v.type))
        return;
      const C = [];
      let T = [];
      switch (v.type) {
        case "TypeApplication":
          T = v.applications[0].type === "UnionType" ? v.applications[0].elements : v.applications, C.push(g(v));
          break;
        case "RecordType":
          T = v.fields;
          break;
        case "UnionType":
        case "ArrayType":
          T = v.elements;
          break;
        case "FieldType":
          v.value && C.push(g(v.value));
          break;
        default:
          C.push(g(v));
      }
      T.forEach(x.bind(null, b)), C.forEach((w) => {
        w.expectedTypeName && w.expectedTypeName !== w.currentType.name && t.report({
          node: b,
          messageId: "useType",
          loc: y(b, w.currentType),
          data: {
            currentTypeName: w.currentType.name,
            expectedTypeName: w.expectedTypeName
          },
          fix(B) {
            return B.replaceTextRange(w.currentType.range.map((I) => b.range[0] + 2 + I), w.expectedTypeName);
          }
        });
      });
    }
    function A(b) {
      const v = s.getJSDocComment(b), C = f.pop(), T = /* @__PURE__ */ Object.create(null), w = [];
      let B = !1, I, _ = !1, S = !1, F = !1, N = !1;
      if (v) {
        let k;
        try {
          k = sR.default.parse(v.value, {
            strict: !0,
            unwrap: !0,
            sloppy: !0,
            range: !0
          });
        } catch (O) {
          /braces/iu.test(O.message) ? t.report({
            node: v,
            messageId: "missingBrace"
          }) : t.report({
            node: v,
            messageId: "syntaxError"
          });
          return;
        }
        k.tags.forEach((O) => {
          switch (O.title.toLowerCase()) {
            case "param":
            case "arg":
            case "argument":
              w.push(O);
              break;
            case "return":
            case "returns":
              B = !0, I = O;
              break;
            case "constructor":
            case "class":
              _ = !0;
              break;
            case "override":
            case "inheritdoc":
              F = !0;
              break;
            case "abstract":
            case "virtual":
              N = !0;
              break;
            case "interface":
              S = !0;
              break;
          }
          if (Object.prototype.hasOwnProperty.call(r, O.title) && O.title !== r[O.title]) {
            const z = y(v, O);
            t.report({
              node: v,
              messageId: "use",
              loc: {
                start: z.start,
                end: {
                  line: z.start.line,
                  column: z.start.column + `@${O.title}`.length
                }
              },
              data: {
                name: r[O.title]
              },
              fix(te) {
                return te.replaceTextRange([v.range[0] + O.range[0] + 3, v.range[0] + O.range[0] + O.title.length + 3], r[O.title]);
              }
            });
          }
          c && O.type && x(v, O.type);
        }), w.forEach((O) => {
          i && !O.type && t.report({
            node: v,
            messageId: "missingParamType",
            loc: y(v, O),
            data: {
              name: O.name
            }
          }), !O.description && a && t.report({
            node: v,
            messageId: "missingParamDesc",
            loc: y(v, O),
            data: {
              name: O.name
            }
          }), T[O.name] ? t.report({
            node: v,
            messageId: "duplicateParam",
            loc: y(v, O),
            data: {
              name: O.name
            }
          }) : O.name.indexOf(".") === -1 && (T[O.name] = O);
        }), B && (!n && !C.returnPresent && (I.type === null || !m(I)) && !N ? t.report({
          node: v,
          messageId: "unexpectedTag",
          loc: y(v, I),
          data: {
            title: I.title
          }
        }) : (l && !I.type && t.report({
          node: v,
          messageId: "missingReturnType"
        }), !m(I) && !I.description && o && t.report({
          node: v,
          messageId: "missingReturnDesc"
        }))), !F && !B && !_ && !S && b.parent.kind !== "get" && b.parent.kind !== "constructor" && b.parent.kind !== "set" && !h(b) && (n || C.returnPresent && !b.async) && t.report({
          node: v,
          messageId: "missingReturn",
          data: {
            returns: r.returns || "returns"
          }
        });
        const j = Object.keys(T);
        b.params && b.params.forEach((O, z) => {
          const te = O.type === "AssignmentPattern" ? O.left : O;
          if (te.type === "Identifier") {
            const se = te.name;
            j[z] && se !== j[z] ? t.report({
              node: v,
              messageId: "expected",
              loc: y(v, T[j[z]]),
              data: {
                name: se,
                jsdocName: j[z]
              }
            }) : !T[se] && !F && t.report({
              node: v,
              messageId: "missingParam",
              data: {
                name: se
              }
            });
          }
        }), e.matchDescription && (new RegExp(e.matchDescription, "u").test(k.description) || t.report({
          node: v,
          messageId: "unsatisfiedDesc"
        }));
      }
    }
    return {
      ArrowFunctionExpression: p,
      FunctionExpression: p,
      FunctionDeclaration: p,
      ClassExpression: p,
      ClassDeclaration: p,
      "ArrowFunctionExpression:exit": A,
      "FunctionExpression:exit": A,
      "FunctionDeclaration:exit": A,
      "ClassExpression:exit": A,
      "ClassDeclaration:exit": A,
      ReturnStatement: function(b) {
        const v = f[f.length - 1];
        v && b.argument !== null && (v.returnPresent = !0);
      }
    };
  }
};
id.meta;
id.create;
var od = {
  meta: {
    type: "problem",
    docs: {
      description: "enforce comparing `typeof` expressions against valid strings",
      category: "Possible Errors",
      recommended: !0,
      url: "https://eslint.org/docs/rules/valid-typeof"
    },
    schema: [{
      type: "object",
      properties: {
        requireStringLiterals: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    messages: {
      invalidValue: "Invalid typeof comparison value.",
      notString: "Typeof comparisons should be to string literals."
    }
  },
  create(t) {
    const e = ["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"], r = ["==", "===", "!=", "!=="], s = t.options[0] && t.options[0].requireStringLiterals;
    function n(a) {
      return a.type === "UnaryExpression" && a.operator === "typeof";
    }
    return {
      UnaryExpression(a) {
        if (n(a)) {
          const o = t.getAncestors().pop();
          if (o.type === "BinaryExpression" && r.indexOf(o.operator) !== -1) {
            const l = o.left === a ? o.right : o.left;
            if (l.type === "Literal" || l.type === "TemplateLiteral" && !l.expressions.length) {
              const i = l.type === "Literal" ? l.value : l.quasis[0].value.cooked;
              e.indexOf(i) === -1 && t.report({
                node: l,
                messageId: "invalidValue"
              });
            } else
              s && !n(l) && t.report({
                node: l,
                messageId: "notString"
              });
          }
        }
      }
    };
  }
};
od.meta;
od.create;
var ld = {
  meta: {
    type: "suggestion",
    docs: {
      description: "require `var` declarations be placed at the top of their containing scope",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/vars-on-top"
    },
    schema: [],
    messages: {
      top: "All 'var' declarations must be at the top of the function scope."
    }
  },
  create(t) {
    function e(l) {
      return l.type === "ExpressionStatement" && l.expression.type === "Literal" && typeof l.expression.value == "string";
    }
    function r(l) {
      return l.type === "ImportDeclaration" || l.type === "ImportSpecifier" || l.type === "ImportDefaultSpecifier" || l.type === "ImportNamespaceSpecifier";
    }
    function s(l) {
      return l.type === "VariableDeclaration" || l.type === "ExportNamedDeclaration" && l.declaration && l.declaration.type === "VariableDeclaration";
    }
    function n(l, i) {
      const u = i.length;
      let c = 0;
      for (; c < u && !(!e(i[c]) && !r(i[c])); ++c)
        ;
      for (; c < u; ++c) {
        if (!s(i[c]))
          return !1;
        if (i[c] === l)
          return !0;
      }
      return !1;
    }
    function a(l, i) {
      n(l, i.body) || t.report({
        node: l,
        messageId: "top"
      });
    }
    function o(l, i, u) {
      /Function/u.test(u.type) && i.type === "BlockStatement" && n(l, i.body) || t.report({
        node: l,
        messageId: "top"
      });
    }
    return {
      "VariableDeclaration[kind='var']"(l) {
        l.parent.type === "ExportNamedDeclaration" ? a(l.parent, l.parent.parent) : l.parent.type === "Program" ? a(l, l.parent) : o(l, l.parent, l.parent.parent);
      }
    };
  }
};
ld.meta;
ld.create;
function o9(t) {
  const e = t.parent.type === "ChainExpression" ? t.parent : t;
  return e.parent.type === "NewExpression" && e.parent.callee === e;
}
var ud = {
  meta: {
    type: "layout",
    docs: {
      description: "require parentheses around immediate `function` invocations",
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/wrap-iife"
    },
    schema: [{
      enum: ["outside", "inside", "any"]
    }, {
      type: "object",
      properties: {
        functionPrototypeMethods: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      wrapInvocation: "Wrap an immediate function invocation in parentheses.",
      wrapExpression: "Wrap only the function expression in parens.",
      moveInvocation: "Move the invocation into the parens that contain the function."
    }
  },
  create(t) {
    const e = t.options[0] || "outside", r = t.options[1] && t.options[1].functionPrototypeMethods, s = t.getSourceCode();
    function n(l) {
      return E.isParenthesised(s, l);
    }
    function a(l) {
      return Vt.default.isParenthesized(1, l, s);
    }
    function o(l) {
      const i = E.skipChainExpression(l.callee);
      return i.type === "FunctionExpression" ? i : r && i.type === "MemberExpression" && i.object.type === "FunctionExpression" && (E.getStaticPropertyName(i) === "call" || E.getStaticPropertyName(i) === "apply") ? i.object : null;
    }
    return {
      CallExpression(l) {
        const i = o(l);
        if (!i)
          return;
        const u = n(l), c = n(i);
        !u && !c ? t.report({
          node: l,
          messageId: "wrapInvocation",
          fix(f) {
            const h = e === "inside" ? i : l;
            return f.replaceText(h, `(${s.getText(h)})`);
          }
        }) : e === "inside" && !c ? t.report({
          node: l,
          messageId: "wrapExpression",
          fix(f) {
            if (a(l) && !o9(l)) {
              const h = s.getTokenAfter(l);
              return f.replaceTextRange([i.range[1], h.range[1]], `)${s.getText().slice(i.range[1], h.range[0])}`);
            }
            return f.replaceText(i, `(${s.getText(i)})`);
          }
        }) : e === "outside" && !u && t.report({
          node: l,
          messageId: "moveInvocation",
          fix(f) {
            const h = s.getTokenAfter(i);
            return f.replaceTextRange([h.range[0], l.range[1]], `${s.getText().slice(h.range[1], l.range[1])})`);
          }
        });
      }
    };
  }
};
ud.meta;
ud.create;
var cd = {
  meta: {
    type: "layout",
    docs: {
      description: "require parenthesis around regex literals",
      category: "Stylistic Issues",
      recommended: !1,
      url: "https://eslint.org/docs/rules/wrap-regex"
    },
    schema: [],
    fixable: "code",
    messages: {
      requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
    }
  },
  create(t) {
    const e = t.getSourceCode();
    return {
      Literal(r) {
        if (e.getFirstToken(r).type === "RegularExpression") {
          const a = e.getTokenBefore(r), o = e.getTokenAfter(r), l = t.getAncestors(), i = l[l.length - 1];
          i.type === "MemberExpression" && i.object === r && !(a && a.value === "(" && o && o.value === ")") && t.report({
            node: r,
            messageId: "requireParens",
            fix: (u) => u.replaceText(r, `(${e.getText(r)})`)
          });
        }
      }
    };
  }
};
cd.meta;
cd.create;
var pd = {
  meta: {
    type: "layout",
    docs: {
      description: "require or disallow spacing around the `*` in `yield*` expressions",
      category: "ECMAScript 6",
      recommended: !1,
      url: "https://eslint.org/docs/rules/yield-star-spacing"
    },
    fixable: "whitespace",
    schema: [{
      oneOf: [{
        enum: ["before", "after", "both", "neither"]
      }, {
        type: "object",
        properties: {
          before: {
            type: "boolean"
          },
          after: {
            type: "boolean"
          }
        },
        additionalProperties: !1
      }]
    }],
    messages: {
      missingBefore: "Missing space before *.",
      missingAfter: "Missing space after *.",
      unexpectedBefore: "Unexpected space before *.",
      unexpectedAfter: "Unexpected space after *."
    }
  },
  create(t) {
    const e = t.getSourceCode(), r = function(n) {
      return !n || typeof n == "string" ? {
        before: {
          before: !0,
          after: !1
        },
        after: {
          before: !1,
          after: !0
        },
        both: {
          before: !0,
          after: !0
        },
        neither: {
          before: !1,
          after: !1
        }
      }[n || "after"] : n;
    }(t.options[0]);
    function s(n, a, o) {
      if (e.isSpaceBetweenTokens(a, o) !== r[n]) {
        const l = a.value === "*", i = r[n], u = l ? a : o;
        let c = "";
        i ? c = n === "before" ? "missingBefore" : "missingAfter" : c = n === "before" ? "unexpectedBefore" : "unexpectedAfter", t.report({
          node: u,
          messageId: c,
          fix(f) {
            return i ? l ? f.insertTextAfter(u, " ") : f.insertTextBefore(u, " ") : f.removeRange([a.range[1], o.range[0]]);
          }
        });
      }
    }
    return {
      YieldExpression: function(n) {
        if (!n.delegate)
          return;
        const a = e.getFirstTokens(n, 3), o = a[0], l = a[1], i = a[2];
        s("before", o, l), s("after", l, i);
      }
    };
  }
};
pd.meta;
pd.create;
function l9(t) {
  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(t);
}
function u9(t) {
  return /^(==|===)$/u.test(t);
}
function y0(t) {
  return ["<", "<="].indexOf(t) >= 0;
}
function qb(t) {
  return t.type === "UnaryExpression" && t.operator === "-" && t.prefix && E.isNumericLiteral(t.argument);
}
function Wb(t) {
  return t.type === "TemplateLiteral" && t.expressions.length === 0;
}
function x0(t) {
  return qb(t) || Wb(t);
}
function Da(t) {
  return t.type === "Literal" ? t : qb(t) ? {
    type: "Literal",
    value: -t.argument.value,
    raw: `-${t.argument.value}`
  } : Wb(t) ? {
    type: "Literal",
    value: t.quasis[0].value.cooked,
    raw: t.quasis[0].value.raw
  } : null;
}
var fd = {
  meta: {
    type: "suggestion",
    docs: {
      description: 'require or disallow "Yoda" conditions',
      category: "Best Practices",
      recommended: !1,
      url: "https://eslint.org/docs/rules/yoda"
    },
    schema: [{
      enum: ["always", "never"]
    }, {
      type: "object",
      properties: {
        exceptRange: {
          type: "boolean",
          default: !1
        },
        onlyEquality: {
          type: "boolean",
          default: !1
        }
      },
      additionalProperties: !1
    }],
    fixable: "code",
    messages: {
      expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
    }
  },
  create(t) {
    const e = t.options[0] === "always", r = t.options[1] && t.options[1].exceptRange, s = t.options[1] && t.options[1].onlyEquality, n = t.getSourceCode();
    function a(i) {
      const u = i.left, c = i.right;
      return i.type === "LogicalExpression" && u.type === "BinaryExpression" && c.type === "BinaryExpression" && y0(u.operator) && y0(c.operator) && (function() {
        if (i.operator === "&&" && E.isSameReference(u.right, c.left)) {
          const f = Da(u.left), h = Da(c.right);
          if (f === null && h === null)
            return !1;
          if (h === null || f === null || f.value <= h.value)
            return !0;
        }
        return !1;
      }() || function() {
        if (i.operator === "||" && E.isSameReference(u.left, c.right)) {
          const f = Da(u.right), h = Da(c.left);
          if (f === null && h === null)
            return !1;
          if (h === null || f === null || f.value <= h.value)
            return !0;
        }
        return !1;
      }()) && function() {
        return E.isParenthesised(n, i);
      }();
    }
    const o = {
      "===": "===",
      "!==": "!==",
      "==": "==",
      "!=": "!=",
      "<": ">",
      ">": "<",
      "<=": ">=",
      ">=": "<="
    };
    function l(i) {
      const u = n.getFirstTokenBetween(i.left, i.right, (v) => v.value === i.operator), c = n.getTokenBefore(u), f = n.getTokenAfter(u), h = n.getText(), p = h.slice(i.range[0], c.range[1]), m = h.slice(c.range[1], u.range[0]), d = h.slice(u.range[1], f.range[0]), g = h.slice(f.range[0], i.range[1]), y = n.getTokenBefore(i), x = n.getTokenAfter(i);
      let A = "", b = "";
      return y && y.range[1] === i.range[0] && !E.canTokensBeAdjacent(y, f) && (A = " "), x && i.range[1] === x.range[0] && !E.canTokensBeAdjacent(c, x) && (b = " "), A + g + m + o[u.value] + d + p + b;
    }
    return {
      BinaryExpression(i) {
        const u = e ? i.left : i.right, c = e ? i.right : i.left;
        (c.type === "Literal" || x0(c)) && !(u.type === "Literal" || x0(u)) && !(!u9(i.operator) && s) && l9(i.operator) && !(r && a(t.getAncestors().pop())) && t.report({
          node: i,
          messageId: "expected",
          data: {
            operator: i.operator,
            expectedSide: e ? "left" : "right"
          },
          fix: (f) => f.replaceText(i, l(i))
        });
      }
    };
  }
};
fd.meta;
fd.create;
var c9 = {
  "accessor-pairs": Xu,
  "array-bracket-newline": Qu,
  "array-bracket-spacing": Yu,
  "array-callback-return": Zu,
  "array-element-newline": ec,
  "arrow-body-style": tc,
  "arrow-parens": rc,
  "arrow-spacing": nc,
  "block-scoped-var": sc,
  "block-spacing": ac,
  "brace-style": ic,
  "callback-return": oc,
  camelcase: lc,
  "capitalized-comments": uc,
  "class-methods-use-this": cc,
  "comma-dangle": pc,
  "comma-spacing": fc,
  "comma-style": hc,
  complexity: mc,
  "computed-property-spacing": dc,
  "consistent-return": gc,
  "consistent-this": yc,
  "constructor-super": xc,
  curly: vc,
  "default-case-last": Ec,
  "default-case": bc,
  "default-param-last": Cc,
  "dot-location": Sc,
  "dot-notation": Ac,
  "eol-last": Dc,
  eqeqeq: wc,
  "for-direction": kc,
  "func-call-spacing": Tc,
  "func-name-matching": Fc,
  "func-names": Pc,
  "func-style": Ic,
  "function-call-argument-newline": _c,
  "function-paren-newline": Bc,
  "generator-star-spacing": Oc,
  "getter-return": Lc,
  "global-require": Rc,
  "grouped-accessor-pairs": Nc,
  "guard-for-in": jc,
  "handle-callback-err": Mc,
  "id-blacklist": $c,
  "id-denylist": Vc,
  "id-length": Uc,
  "id-match": qc,
  "implicit-arrow-linebreak": Wc,
  "indent-legacy": zc,
  indent: Gc,
  "init-declarations": Hc,
  "jsx-quotes": Kc,
  "key-spacing": Jc,
  "keyword-spacing": Xc,
  "line-comment-position": Qc,
  "linebreak-style": Yc,
  "lines-around-comment": Zc,
  "lines-around-directive": ep,
  "lines-between-class-members": tp,
  "max-classes-per-file": rp,
  "max-depth": np,
  "max-len": sp,
  "max-lines-per-function": ap,
  "max-lines": ip,
  "max-nested-callbacks": op,
  "max-params": lp,
  "max-statements-per-line": up,
  "max-statements": cp,
  "multiline-comment-style": pp,
  "multiline-ternary": fp,
  "new-cap": hp,
  "new-parens": mp,
  "newline-after-var": dp,
  "newline-before-return": gp,
  "newline-per-chained-call": yp,
  "no-alert": xp,
  "no-array-constructor": vp,
  "no-async-promise-executor": Ep,
  "no-await-in-loop": bp,
  "no-bitwise": Cp,
  "no-buffer-constructor": Sp,
  "no-caller": Ap,
  "no-case-declarations": Dp,
  "no-catch-shadow": wp,
  "no-class-assign": kp,
  "no-compare-neg-zero": Tp,
  "no-cond-assign": Fp,
  "no-confusing-arrow": Pp,
  "no-console": Ip,
  "no-const-assign": _p,
  "no-constant-condition": Bp,
  "no-constructor-return": Op,
  "no-continue": Lp,
  "no-control-regex": Rp,
  "no-debugger": Np,
  "no-delete-var": jp,
  "no-div-regex": Mp,
  "no-dupe-args": $p,
  "no-dupe-class-members": Vp,
  "no-dupe-else-if": Up,
  "no-dupe-keys": qp,
  "no-duplicate-case": Wp,
  "no-duplicate-imports": zp,
  "no-else-return": Gp,
  "no-empty-character-class": Hp,
  "no-empty-function": Kp,
  "no-empty-pattern": Jp,
  "no-empty": Xp,
  "no-eq-null": Qp,
  "no-eval": Yp,
  "no-ex-assign": Zp,
  "no-extend-native": ef,
  "no-extra-bind": tf,
  "no-extra-boolean-cast": rf,
  "no-extra-label": nf,
  "no-extra-parens": sf,
  "no-extra-semi": af,
  "no-fallthrough": of,
  "no-floating-decimal": lf,
  "no-func-assign": uf,
  "no-global-assign": cf,
  "no-implicit-coercion": pf,
  "no-implicit-globals": ff,
  "no-implied-eval": hf,
  "no-import-assign": mf,
  "no-inline-comments": df,
  "no-inner-declarations": gf,
  "no-invalid-regexp": yf,
  "no-invalid-this": xf,
  "no-irregular-whitespace": vf,
  "no-iterator": Ef,
  "no-label-var": bf,
  "no-labels": Cf,
  "no-lone-blocks": Sf,
  "no-lonely-if": Af,
  "no-loop-func": Df,
  "no-loss-of-precision": wf,
  "no-magic-numbers": kf,
  "no-misleading-character-class": Tf,
  "no-mixed-operators": Ff,
  "no-mixed-requires": Pf,
  "no-mixed-spaces-and-tabs": If,
  "no-multi-assign": _f,
  "no-multi-spaces": Bf,
  "no-multi-str": Of,
  "no-multiple-empty-lines": Lf,
  "no-native-reassign": Rf,
  "no-negated-condition": Nf,
  "no-negated-in-lhs": jf,
  "no-nested-ternary": Mf,
  "no-new-func": $f,
  "no-new-object": Vf,
  "no-new-require": Uf,
  "no-new-symbol": qf,
  "no-new-wrappers": Wf,
  "no-new": zf,
  "no-nonoctal-decimal-escape": Gf,
  "no-obj-calls": Hf,
  "no-octal-escape": Kf,
  "no-octal": Jf,
  "no-param-reassign": Xf,
  "no-path-concat": Qf,
  "no-plusplus": Yf,
  "no-process-env": Zf,
  "no-process-exit": eh,
  "no-promise-executor-return": th,
  "no-proto": rh,
  "no-prototype-builtins": nh,
  "no-redeclare": sh,
  "no-regex-spaces": ah,
  "no-restricted-exports": ih,
  "no-restricted-globals": oh,
  "no-restricted-imports": lh,
  "no-restricted-modules": uh,
  "no-restricted-properties": ch,
  "no-restricted-syntax": ph,
  "no-return-assign": fh,
  "no-return-await": hh,
  "no-script-url": mh,
  "no-self-assign": dh,
  "no-self-compare": gh,
  "no-sequences": yh,
  "no-setter-return": xh,
  "no-shadow-restricted-names": vh,
  "no-shadow": Eh,
  "no-spaced-func": bh,
  "no-sparse-arrays": Ch,
  "no-sync": Sh,
  "no-tabs": Ah,
  "no-template-curly-in-string": Dh,
  "no-ternary": wh,
  "no-this-before-super": kh,
  "no-throw-literal": Th,
  "no-trailing-spaces": Fh,
  "no-undef-init": Ph,
  "no-undef": Ih,
  "no-undefined": _h,
  "no-underscore-dangle": Bh,
  "no-unexpected-multiline": Oh,
  "no-unmodified-loop-condition": Lh,
  "no-unneeded-ternary": Rh,
  "no-unreachable-loop": Nh,
  "no-unreachable": jh,
  "no-unsafe-finally": Mh,
  "no-unsafe-negation": $h,
  "no-unsafe-optional-chaining": Vh,
  "no-unused-expressions": Uh,
  "no-unused-labels": qh,
  "no-unused-vars": Wh,
  "no-use-before-define": zh,
  "no-useless-backreference": Gh,
  "no-useless-call": Hh,
  "no-useless-catch": Kh,
  "no-useless-computed-key": Jh,
  "no-useless-concat": Xh,
  "no-useless-constructor": Qh,
  "no-useless-escape": Yh,
  "no-useless-rename": Zh,
  "no-useless-return": em,
  "no-var": tm,
  "no-void": rm,
  "no-warning-comments": nm,
  "no-whitespace-before-property": sm,
  "no-with": am,
  "nonblock-statement-body-position": im,
  "object-curly-newline": om,
  "object-curly-spacing": lm,
  "object-property-newline": um,
  "object-shorthand": cm,
  "one-var-declaration-per-line": pm,
  "one-var": fm,
  "operator-assignment": hm,
  "operator-linebreak": mm,
  "padded-blocks": dm,
  "padding-line-between-statements": gm,
  "prefer-arrow-callback": ym,
  "prefer-const": xm,
  "prefer-destructuring": vm,
  "prefer-exponentiation-operator": bm,
  "prefer-named-capture-group": Cm,
  "prefer-numeric-literals": Sm,
  "prefer-object-spread": Am,
  "prefer-promise-reject-errors": Dm,
  "prefer-reflect": wm,
  "prefer-regex-literals": km,
  "prefer-rest-params": Tm,
  "prefer-spread": Fm,
  "prefer-template": Im,
  "quote-props": _m,
  quotes: Bm,
  radix: Om,
  "require-atomic-updates": Lm,
  "require-await": Rm,
  "require-jsdoc": Nm,
  "require-unicode-regexp": jm,
  "require-yield": Mm,
  "rest-spread-spacing": $m,
  "semi-spacing": Vm,
  "semi-style": Um,
  semi: qm,
  "sort-imports": Wm,
  "sort-keys": zm,
  "sort-vars": Gm,
  "space-before-blocks": Hm,
  "space-before-function-paren": Km,
  "space-in-parens": Jm,
  "space-infix-ops": Xm,
  "space-unary-ops": Qm,
  "spaced-comment": Ym,
  strict: Zm,
  "switch-colon-spacing": ed,
  "symbol-description": td,
  "template-curly-spacing": rd,
  "template-tag-spacing": nd,
  "unicode-bom": sd,
  "use-isnan": ad,
  "valid-jsdoc": id,
  "valid-typeof": od,
  "vars-on-top": ld,
  "wrap-iife": ud,
  "wrap-regex": cd,
  "yield-star-spacing": pd,
  yoda: fd
}, p9 = c9, f9 = A0, h9 = p9;
class m9 extends f9.linter_1 {
  constructor() {
    super(), this.defineRules(h9);
  }
}
var j9 = m9;
export {
  j9 as default
};
