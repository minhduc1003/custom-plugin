import { v as i, O as d, S as m, cM as v, M as x, F as g, G as h, ac as c, ae as n, J as t, e0 as w, hb as C, cf as f } from "./c988e26e.js";
import "react";
import "react-dom";
const l = function() {
  const e = {
    v1: i("abc"),
    v2: i("v2"),
    visible: d,
    value: m,
    num: v("num")
  };
  return new x(e, (o) => o).setPropertyViewFn(() => /* @__PURE__ */ g(h, {})).build();
}(), r = c(l, [new n("v1"), new n("visible"), new n("value"), new n("num")]);
test("exposing data and methods", () => {
  let e = new r({});
  e = t(e);
  const o = e.extraNode().node;
  e = t(e.reduce(e.changeChildAction("v2", "ppp"))), expect(e.children.v2.getView()).toBe("ppp");
  const p = e.extraNode().node;
  expect(w(o, p)).toBe(!0), e = t(e.reduce(e.changeChildAction("v1", "v1_value"))), expect(t(e)).toBe(e), expect(e.exposingValues.v1).toBe("v1_value"), expect(e.exposingValues.visible).toBe(!1), expect(Object.keys(e.exposingInfo().methods)).toContain("setNum");
});
test("run exposing method", () => {
  let e = new r({
    dispatch: (o) => {
      e = t(e.reduce(o));
    }
  });
  e = t(e), e.reduce(C({
    type: "execute",
    methodName: "setNum",
    params: [100]
  }, !1)), expect(e.getView().num.value).toEqual(100);
});
test("exposing deps", () => {
  const e = c(l, [new n("v1"), f({
    name: "X",
    desc: "",
    depKeys: ["v1", "visible"],
    func: (s) => s.v1 + " " + s.visible
  })]);
  let o = new e({});
  o = t(o);
  const p = o.exposingInfo().property;
  expect(o.exposingValues.X).toBe("abc false"), o = t(o.reduce(o.changeChildAction("v2", "ppp")));
  const u = o.exposingInfo().property;
  function a(s) {
    return s.children.X;
  }
  expect(a(p)).toBe(a(u));
});
