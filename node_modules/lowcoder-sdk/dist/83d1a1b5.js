import { useState as m, useEffect as q } from "react";
import { X as N, av as k, N as H, O as i, Z as c, c6 as _, c7 as j, L as T, eG as G, a4 as y, d8 as M, dC as J, az as X, U as Z, eU as v, F as a, G as P, eT as K, eV as Q, bU as E, a8 as g, a9 as u, Y as l, dD as W, aa as s, ab as p, ae as C, dF as V, dG as U, ac as ee, dH as te } from "./c988e26e.js";
import { FormDataPropertyView as ae } from "./85e61f03.js";
import { getStyle as le, textInputChildren as ne, textInputValidate as O, TextInputBasicSection as re, TextInputInteractionSection as ue, TextInputValidationSection as ie, TextInputConfigs as D } from "./70f9cad3.js";
import { autoCompleteDate as se, convertAutoCompleteData as oe, valueOrLabelOption as me, autoCompleteType as ce, autocompleteIconColor as ye, componentSize as Ce, itemsDataTooltip as de, autoCompleteRefMethods as fe } from "./d3b6c877.js";
import "react-dom";
const ve = N(te)`
box-shadow: ${(e) => {
  var r, d;
  return `${(r = e.$style) == null ? void 0 : r.boxShadow} ${(d = e.$style) == null ? void 0 : d.boxShadowColor}`;
}};
  ${(e) => {
  var r;
  return k`
    ${le(e.$style)}
    input {
      padding: ${(r = e.style) == null ? void 0 : r.padding};
    }
    .ant-select-single {
      width: 100% !important;
    }
  `;
}}
`, ge = {
  ...ne,
  viewRef: H,
  allowClear: i.DEFAULT_TRUE,
  style: c(_, "style"),
  labelStyle: c(j, "labelStyle"),
  prefixIcon: T,
  suffixIcon: T,
  items: G(oe, se),
  ignoreCase: i.DEFAULT_TRUE,
  searchFirstPY: i.DEFAULT_TRUE,
  searchCompletePY: i,
  searchLabelOnly: i.DEFAULT_TRUE,
  valueOrLabel: y(me, "label"),
  autoCompleteType: y(ce, "normal"),
  autocompleteIconColor: y(ye, "blue"),
  componentSize: y(Ce, "small"),
  valueInItems: M("valueInItems"),
  inputFieldStyle: c(J, "inputFieldStyle"),
  animationStyle: c(X, "animationStyle")
}, Se = (e) => e.hasOwnProperty("validateStatus") && e.validateStatus === "error" ? "error" : "";
let S = function() {
  return new Z(ge, (e) => {
    const {
      items: r,
      onEvent: d,
      placeholder: R,
      searchFirstPY: b,
      searchCompletePY: x,
      searchLabelOnly: A,
      ignoreCase: w,
      valueOrLabel: I,
      autoCompleteType: be,
      autocompleteIconColor: xe,
      componentSize: $
    } = e, h = () => ({
      value: {
        value: e.value.value
      },
      required: e.required,
      minLength: (e == null ? void 0 : e.minLength) ?? 0,
      maxLength: (e == null ? void 0 : e.maxLength) ?? 0,
      validationType: e.validationType,
      regex: e.regex,
      customRule: e.customRule
    }), [Y, z] = m(!1), [B, f] = m(e.value.value), [F, L] = m({}), [o, we] = m(v() === "zh-cn");
    return q(() => {
      f(e.value.value), Y && L(O(h()));
    }, [e.value.value, e.required, e == null ? void 0 : e.minLength, e == null ? void 0 : e.maxLength, e.validationType, e.regex, e.customRule]), e.label({
      required: e.required,
      children: /* @__PURE__ */ a(P, {
        children: /* @__PURE__ */ a(K, {
          theme: {
            token: {
              colorBgContainer: e.inputFieldStyle.background,
              colorBorder: e.inputFieldStyle.border,
              borderRadius: parseInt(e.inputFieldStyle.radius),
              colorText: e.inputFieldStyle.text,
              colorPrimary: e.inputFieldStyle.accent,
              controlHeight: $ === "small" ? 30 : 38
            }
          },
          children: /* @__PURE__ */ a(Q, {
            disabled: e.disabled,
            value: B,
            options: r,
            style: {
              width: "100%"
            },
            onChange: (n, t) => {
              e.valueInItems.onChange(!1), L(O(h())), f(n), e.value.onChange(n), e.onEvent("change");
            },
            onFocus: () => {
              z(!0), e.onEvent("focus");
            },
            onBlur: () => e.onEvent("blur"),
            onSelect: (n, t) => {
              f(t[I]), e.valueInItems.onChange(!0), e.value.onChange(t[I]), e.onEvent("submit");
            },
            filterOption: (n, t) => {
              if (w) {
                if (t != null && t.label && (t == null ? void 0 : t.label.toUpperCase().indexOf(n.toUpperCase())) !== -1)
                  return !0;
              } else if (t != null && t.label && (t == null ? void 0 : t.label.indexOf(n)) !== -1)
                return !0;
              if (o && b && (t != null && t.label) && t.label.spell("first").toString().toLowerCase().indexOf(n.toLowerCase()) >= 0 || o && x && (t != null && t.label) && t.label.spell().toString().toLowerCase().indexOf(n.toLowerCase()) >= 0)
                return !0;
              if (!A) {
                if (w) {
                  if (t != null && t.value && (t == null ? void 0 : t.value.toUpperCase().indexOf(n.toUpperCase())) !== -1)
                    return !0;
                } else if (t != null && t.value && (t == null ? void 0 : t.value.indexOf(n)) !== -1)
                  return !0;
                if (o && b && (t != null && t.value) && t.value.spell("first").toString().toLowerCase().indexOf(n.toLowerCase()) >= 0 || o && x && (t != null && t.value) && t.value.spell().toString().toLowerCase().indexOf(n.toLowerCase()) >= 0)
                  return !0;
              }
              return !1;
            },
            children: /* @__PURE__ */ a(ve, {
              ref: e.viewRef,
              placeholder: R,
              allowClear: e.allowClear,
              $style: e.inputFieldStyle,
              prefix: E(e.prefixIcon) && e.prefixIcon,
              suffix: E(e.suffixIcon) && e.suffixIcon,
              status: Se(F),
              onPressEnter: void 0
            })
          })
        })
      }),
      style: e.style,
      labelStyle: e.labelStyle,
      inputFieldStyle: e.inputFieldStyle,
      animationStyle: e.animationStyle,
      ...F
    });
  }).setPropertyViewFn((e) => /* @__PURE__ */ g(P, {
    children: [/* @__PURE__ */ g(u, {
      children: [e.autoCompleteType.getView() === "normal" && e.prefixIcon.propertyView({
        label: l("button.prefixIcon")
      }), e.autoCompleteType.getView() === "normal" && e.suffixIcon.propertyView({
        label: l("button.suffixIcon")
      }), W(e)]
    }), /* @__PURE__ */ g(u, {
      name: l("autoComplete.SectionDataName"),
      children: [e.items.propertyView({
        label: l("autoComplete.value"),
        tooltip: de,
        placeholder: "[]"
      }), v() === "zh-cn" && e.searchFirstPY.propertyView({
        label: l("autoComplete.searchFirstPY")
      }), v() === "zh-cn" && e.searchCompletePY.propertyView({
        label: l("autoComplete.searchCompletePY")
      }), e.searchLabelOnly.propertyView({
        label: l("autoComplete.searchLabelOnly")
      }), e.ignoreCase.propertyView({
        label: l("autoComplete.ignoreCase")
      }), e.valueOrLabel.propertyView({
        label: l("autoComplete.checkedValueFrom"),
        radioButton: !0
      })]
    }), /* @__PURE__ */ a(re, {
      ...e
    }), /* @__PURE__ */ a(ae, {
      ...e
    }), e.label.getPropertyView(), /* @__PURE__ */ a(ue, {
      ...e
    }), /* @__PURE__ */ a(ie, {
      ...e
    }), /* @__PURE__ */ a(u, {
      name: s.layout,
      children: p(e)
    }), /* @__PURE__ */ a(u, {
      name: s.style,
      children: e.style.getPropertyView()
    }), /* @__PURE__ */ a(u, {
      name: s.labelStyle,
      children: e.labelStyle.getPropertyView()
    }), /* @__PURE__ */ a(u, {
      name: s.inputFieldStyle,
      children: e.inputFieldStyle.getPropertyView()
    }), /* @__PURE__ */ a(u, {
      name: s.animationStyle,
      hasTooltip: !0,
      children: e.animationStyle.getPropertyView()
    })]
  })).setExposeMethodConfigs(fe).setExposeStateConfigs([new C("value", l("export.inputValueDesc")), new C("valueInItems", l("autoComplete.valueInItems")), V, U, ...D]).build();
}();
S = class extends S {
  autoHeight() {
    return !0;
  }
};
const Ee = ee(S, [new C("value", l("export.inputValueDesc")), new C("valueInItems", l("autoComplete.valueInItems")), V, U, ...D]);
export {
  Ee as AutoCompleteComp
};
