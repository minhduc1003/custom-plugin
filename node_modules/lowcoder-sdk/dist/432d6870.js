var T = Object.defineProperty;
var I = (e, t, a) => t in e ? T(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var g = (e, t, a) => (I(e, typeof t != "symbol" ? t + "" : t, a), a);
import { M as V, w as v, bO as y, F as h, G as S, h4 as O, S as m, a4 as C, bI as D, h5 as M, fv as F, dX as A, dZ as x, cs as f, Y as l, fG as P, h6 as N, h7 as E, a8 as B, ab as k, ah as j, bP as q, gc as W } from "./c988e26e.js";
import { useState as G, useContext as R, useEffect as J } from "react";
import { PlacementOptions as K, TypeOptions as L } from "./3f72c732.js";
import { TourPlacementTooltip as U, TourStepArrowTooltip as X, TourStepMaskTooltip as Y } from "./ebbc0fd0.js";
import "react-dom";
function Z(e) {
  return !!e.propertyView;
}
function z(e) {
  class t extends e {
    constructor() {
      super(...arguments);
      g(this, "dataIndex", W());
    }
    getDataIndex() {
      return this.dataIndex;
    }
  }
  return t;
}
function H(e, t) {
  if (!e || e.length <= 0)
    return e;
  const a = [];
  return e.reduce((p, o) => {
    const s = o[t];
    return p.has(s) || a.push(o), p.add(s), p;
  }, /* @__PURE__ */ new Set()), a;
}
function Q(e, t) {
  const a = F(z(e)), p = new V({
    manual: a
  }, (s) => {
    const i = s.manual.map((r) => r.getView());
    return t.uniqField ? H(i, t.uniqField) : i;
  }).setPropertyViewFn(() => {
    throw new Error("Method not implemented.");
  }).build();
  class o extends p {
    exposingNode() {
      return A(x(f.mapValues(this.children.manual.children, (i) => x(f.mapValues(i.children, (r) => r.exposingNode())))), (i) => Object.values(i));
    }
    getNewId() {
      const {
        autoIncField: i
      } = t;
      if (!i)
        return 0;
      const r = this.children.manual.getView().map((n) => n.getView()), d = new Set(r.map((n) => n[i]));
      let u = 0;
      for (; d.has(u); )
        ++u;
      return u;
    }
    propertyView(i) {
      const r = this.children.manual, {
        autoIncField: d
      } = t, u = i.title ?? l("tour.section1Subtitle");
      return y({
        filterText: u
      }, /* @__PURE__ */ h(P, {
        itemTitle: (n) => n.children.title.getView(),
        popoverTitle: () => l("edit"),
        content: (n) => Z(n) ? n.propertyView({}) : n.getPropertyView(),
        items: r.getView(),
        onAdd: () => {
          const n = N(i.newOptionLabel || l("optionsControl.option") + " ", r.getView().map((w) => w.children.title.getView())), c = this.getNewId();
          r.dispatch(r.pushAction({
            label: n,
            ...d ? {
              [d]: c
            } : {}
          }));
        },
        onDel: (n) => r.dispatch(r.deleteAction(n)),
        onCopy: (n) => {
          const c = this.getNewId();
          r.dispatch(r.pushAction({
            ...n.toJsonValue(),
            ...d ? {
              [d]: c
            } : {}
          }));
        },
        onMove: (n, c) => {
          const w = r.arrayMoveAction(n, c);
          r.dispatch(w);
        },
        dataIndex: (n) => n.getDataIndex(),
        uniqVal: t.uniqField && ((n) => n.children[t.uniqField].getView()),
        title: u
      }));
    }
  }
  return t.initOptions ? v(o, {
    manual: t.initOptions
  }) : o;
}
function _(e, t) {
  const a = new V({
    manual: Q(e, {
      initOptions: t.initOptions
    })
  }, (p) => p.manual).setPropertyViewFn(() => {
    throw new Error("Method not implemented.");
  }).build();
  return class extends a {
    exposingNode() {
      return this.children.manual.exposingNode();
    }
    propertyView(p) {
      const o = this.children.manual.propertyView(p);
      return y({
        searchChild: !0
      }, /* @__PURE__ */ h(S, {
        children: o
      }));
    }
  };
}
function $(e, t) {
  return class extends et(e, t) {
    getView() {
      return this.value;
    }
  };
}
function tt(e) {
  const {
    options: t,
    onChange: a,
    value: p,
    ...o
  } = e, [s, i] = G(typeof t == "function" ? [] : t), r = R(j);
  return J(() => {
    if (typeof t != "function") {
      i(t);
      return;
    }
    s != null && s.length || i(t(r));
  }, [s.length, t]), /* @__PURE__ */ h(q, {
    placement: o.placement,
    toolTip: o.tooltip,
    value: p,
    options: s,
    radioButton: o.radioButton,
    border: o.border,
    type: o.type,
    label: o.label,
    showSearch: !0,
    onChange: a,
    disabled: o.disabled,
    dropdownStyle: e.dropdownStyle,
    labelStyle: e.labelStyle
  });
}
function et(e, t) {
  class a extends E {
    getDefaultValue() {
      return t;
    }
    propertyView(o) {
      return y({
        filterText: o.label
      }, /* @__PURE__ */ h(tt, {
        ...o,
        value: this.value,
        options: e,
        onChange: (s) => {
          var i;
          o.disableDispatchValueChange || this.dispatchChangeValueAction(s), (i = o.onChange) == null || i.call(o, s);
        }
      }));
    }
    getPropertyView() {
      throw new Error("Method not implemented.");
    }
  }
  return a;
}
let b = new V({
  target: $((e) => Object.values(e.getAllUICompMap()).map((t) => ({
    label: t.children.name.getView(),
    value: t.children.name.getView()
  })), ""),
  arrow: O,
  title: m,
  description: m,
  placement: C(K, ""),
  hidden: D,
  mask: M,
  cover: m,
  type: C(L, "")
}, (e) => e).build();
b = class extends b {
  propertyView(e) {
    return /* @__PURE__ */ B(S, {
      children: [this.children.title.propertyView({
        label: l("tour.options.title.label"),
        placeholder: l("tour.options.title.placeholder"),
        tooltip: l("tour.options.title.tooltip")
      }), this.children.description.propertyView({
        label: l("tour.options.description.label"),
        placeholder: l("tour.options.description.placeholder"),
        tooltip: l("tour.options.description.tooltip")
      }), this.children.target.propertyView({
        label: l("tour.options.target.label"),
        tooltip: l("tour.options.target.tooltip"),
        radioButton: !1
      }), this.children.placement.propertyView({
        label: l("tour.placement.label"),
        tooltip: U,
        radioButton: !1
      }), this.children.arrow.propertyView({
        label: l("tour.options.arrow.label"),
        tooltip: X
      }), this.children.cover.propertyView({
        label: l("tour.options.coverImage.label"),
        tooltip: l("tour.options.coverImage.tooltip")
      }), this.children.mask.propertyView({
        label: l("tour.options.mask.label"),
        tooltip: Y
      }), this.children.type.propertyView({
        label: l("tour.options.type.label"),
        tooltip: l("tour.options.type.tooltip")
      }), k(this.children)]
    });
  }
};
const st = _(b, {
  initOptions: [{
    title: "Welcome",
    description: "Welcome to lowcoder"
  }, {
    title: "Step 2",
    description: "This is a tutorial step"
  }]
});
export {
  st as TourStepControl,
  et as editorStateDropdownAbstractControl,
  $ as editorStateDropdownControl,
  Q as manualTourStepsControl,
  _ as tourStepsControl
};
