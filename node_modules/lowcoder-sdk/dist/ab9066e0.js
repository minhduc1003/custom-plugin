import { i6 as we, nD as oo, F as O, a8 as ee, G as at, oD as Cl, lx as Nd, e_ as ar, e$ as Fe, bV as Or, eT as ya, me as ga, gF as Dd, gy as di, oE as Fd, eO as lo, gW as kd, lL as Al, gs as Yi, f4 as Pl, c1 as Il, oF as co, fg as Rd, f5 as Md, X as jd, O as Ud, oG as uo, dd as Ti, hM as Vd, a3 as xd, Z as fo, oH as Ld, az as Bd, U as qd, Y as Ee, ah as mr, a9 as In, aa as Tn, ab as Kd, ac as zd, cf as Wd, ad as Gd, cg as Hd, eL as Yd, oI as Jd, oJ as ho, oK as Xd } from "./c988e26e.js";
import * as Ln from "react";
import { createElement as Zd, Component as ln, useState as va, useCallback as $e, useEffect as $a, useReducer as Qd, useMemo as ef, createRef as tf, forwardRef as rf, useContext as wt } from "react";
import { _ as fi, i as cn, b as Tl, a as cr, e as Qe } from "./14897c7e.js";
import { _ as Nl, a as nf, b as Dl, d as af, e as sf, f as of, g as Fl, h as lf, i as cf, k as _a, j as uf, l as df, m as ba, n as ff, o as hf, c as kl } from "./182e4b4f.js";
import { g as We, _ as mf, u as pf, d as yf, v as hi, n as un, i as Sa, l as gf, f as wa, p as vf, w as Ea, x as $f, k as Rl, c as Ml, y as _f, z as jl, e as Oa, A as bf, t as mi } from "./8f0aa994.js";
import { _ as Ca, a as Ul, b as Aa, c as Pa, i as Vl, d as sr } from "./70c18940.js";
import { i as dn, t as Sf } from "./9caec5b5.js";
import xl from "./99e2f395.js";
import wf from "./af4bbc3e.js";
import { a as Ef } from "./d118cfee.js";
import { a as Of } from "./45befefc.js";
import { a as Cf } from "./442c49ea.js";
import { a as Af } from "./e27658d4.js";
import { a as Pf } from "./1daf7233.js";
import { a as If } from "./2ae2291e.js";
import "react-dom";
function Se(e) {
  return typeof File < "u" && e instanceof File || typeof Date < "u" && e instanceof Date ? !1 : typeof e == "object" && e !== null && !Array.isArray(e);
}
function Tf(e) {
  return e.additionalItems === !0 && console.warn("additionalItems=true is currently not supported"), Se(e.additionalItems);
}
function mo(e) {
  if (e === "")
    return;
  if (e === null)
    return null;
  if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
    return e;
  const t = Number(e);
  return typeof t == "number" && !Number.isNaN(t) ? t : e;
}
const Dr = "__additional_property", Ji = "additionalProperties", fn = "allOf", pt = "anyOf", Ll = "const", Nf = "default", pi = "dependencies", Df = "enum", ot = "__errors", Mt = "$id", Ff = "if", Ut = "items", kf = "_$junk_option_schema_id$_", Bn = "$name", et = "oneOf", Oe = "properties", Rf = "required", Zn = "submitButtonOptions", Te = "$ref", Ia = "__rjsf_additionalProperties", Bl = "__rjsf_rootSchema", Mf = "ui:field", Ta = "ui:widget", nr = "ui:options", jf = "ui:globalOptions";
function oe(e = {}, t = {}) {
  return Object.keys(e).filter((r) => r.indexOf("ui:") === 0).reduce((r, n) => {
    const i = e[n];
    return n === Ta && Se(i) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), r) : n === nr && Se(i) ? { ...r, ...i } : { ...r, [n.substring(3)]: i };
  }, { ...t });
}
function ql(e, t = {}, r) {
  if (!e.additionalProperties)
    return !1;
  const { expandable: n = !0 } = oe(t);
  return n === !1 ? n : e.maxProperties !== void 0 && r ? Object.keys(r).length < e.maxProperties : !0;
}
var Uf = fi, Vf = Nl, xf = cn, Lf = "[object Object]", Bf = Function.prototype, qf = Object.prototype, Kl = Bf.toString, Kf = qf.hasOwnProperty, zf = Kl.call(Object);
function Wf(e) {
  if (!xf(e) || Uf(e) != Lf)
    return !1;
  var t = Vf(e);
  if (t === null)
    return !0;
  var r = Kf.call(t, "constructor") && t.constructor;
  return typeof r == "function" && r instanceof r && Kl.call(r) == zf;
}
var Fr = Wf;
const Na = /* @__PURE__ */ we(Fr);
function Xi(e) {
  const t = {
    // We store the list of errors for this node in a property named __errors
    // to avoid name collision with a possible sub schema field named
    // 'errors' (see `utils.toErrorSchema`).
    [ot]: [],
    addError(r) {
      this[ot].push(r);
    }
  };
  if (Array.isArray(e))
    return e.reduce((r, n, i) => ({ ...r, [i]: Xi(n) }), t);
  if (Na(e)) {
    const r = e;
    return Object.keys(r).reduce((n, i) => ({ ...n, [i]: Xi(r[i]) }), t);
  }
  return t;
}
var Gf = Ca;
function Hf(e, t, r) {
  r = typeof r == "function" ? r : void 0;
  var n = r ? r(e, t) : void 0;
  return n === void 0 ? Gf(e, t, void 0, r) : !!n;
}
var Yf = Hf;
const Jf = /* @__PURE__ */ we(Yf);
function Be(e, t) {
  return Jf(e, t, (r, n) => {
    if (typeof r == "function" && typeof n == "function")
      return !0;
  });
}
var Xf = We, Zf = dn, Qf = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, eh = /^\w*$/;
function th(e, t) {
  if (Xf(e))
    return !1;
  var r = typeof e;
  return r == "number" || r == "symbol" || r == "boolean" || e == null || Zf(e) ? !0 : eh.test(e) || !Qf.test(e) || t != null && e in Object(t);
}
var Da = th, zl = mf, rh = "Expected a function";
function Fa(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(rh);
  var r = function() {
    var n = arguments, i = t ? t.apply(this, n) : n[0], a = r.cache;
    if (a.has(i))
      return a.get(i);
    var s = e.apply(this, n);
    return r.cache = a.set(i, s) || a, s;
  };
  return r.cache = new (Fa.Cache || zl)(), r;
}
Fa.Cache = zl;
var nh = Fa, ih = nh, ah = 500;
function sh(e) {
  var t = ih(e, function(n) {
    return r.size === ah && r.clear(), n;
  }), r = t.cache;
  return t;
}
var oh = sh, lh = oh, ch = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, uh = /\\(\\)?/g, dh = lh(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(ch, function(r, n, i, a) {
    t.push(i ? a.replace(uh, "$1") : n || r);
  }), t;
}), Wl = dh;
function fh(e, t) {
  for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
    i[r] = t(e[r], r, e);
  return i;
}
var Pt = fh, po = Tl, hh = Pt, mh = We, ph = dn, yh = 1 / 0, yo = po ? po.prototype : void 0, go = yo ? yo.toString : void 0;
function Gl(e) {
  if (typeof e == "string")
    return e;
  if (mh(e))
    return hh(e, Gl) + "";
  if (ph(e))
    return go ? go.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -yh ? "-0" : t;
}
var gh = Gl, vh = gh;
function $h(e) {
  return e == null ? "" : vh(e);
}
var Hl = $h, _h = We, bh = Da, Sh = Wl, wh = Hl;
function Eh(e, t) {
  return _h(e) ? e : bh(e, t) ? [e] : Sh(wh(e));
}
var kr = Eh, Oh = dn, Ch = 1 / 0;
function Ah(e) {
  if (typeof e == "string" || Oh(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -Ch ? "-0" : t;
}
var ur = Ah, Ph = kr, Ih = ur;
function Th(e, t) {
  t = Ph(t, e);
  for (var r = 0, n = t.length; e != null && r < n; )
    e = e[Ih(t[r++])];
  return r && r == n ? e : void 0;
}
var hn = Th, Nh = hn;
function Dh(e, t, r) {
  var n = e == null ? void 0 : Nh(e, t);
  return n === void 0 ? r : n;
}
var Yl = Dh;
const G = /* @__PURE__ */ we(Yl);
var Fh = pf, kh = yf, Rh = hi, Mh = We, jh = un, Uh = Sa, Vh = gf, xh = wa, Lh = "[object Map]", Bh = "[object Set]", qh = Object.prototype, Kh = qh.hasOwnProperty;
function zh(e) {
  if (e == null)
    return !0;
  if (jh(e) && (Mh(e) || typeof e == "string" || typeof e.splice == "function" || Uh(e) || xh(e) || Rh(e)))
    return !e.length;
  var t = kh(e);
  if (t == Lh || t == Bh)
    return !e.size;
  if (Vh(e))
    return !Fh(e).length;
  for (var r in e)
    if (Kh.call(e, r))
      return !1;
  return !0;
}
var Wh = zh;
const xt = /* @__PURE__ */ we(Wh);
var yi = {}, Gh = /~/, Hh = /~[01]/g;
function Yh(e) {
  switch (e) {
    case "~1":
      return "/";
    case "~0":
      return "~";
  }
  throw new Error("Invalid tilde escape: " + e);
}
function Jl(e) {
  return Gh.test(e) ? e.replace(Hh, Yh) : e;
}
function Jh(e, t, r) {
  for (var n, i, a = 1, s = t.length; a < s; ) {
    if (t[a] === "constructor" || t[a] === "prototype" || t[a] === "__proto__")
      return e;
    if (n = Jl(t[a++]), i = s > a, typeof e[n] > "u" && (Array.isArray(e) && n === "-" && (n = e.length), i && (t[a] !== "" && t[a] < 1 / 0 || t[a] === "-" ? e[n] = [] : e[n] = {})), !i)
      break;
    e = e[n];
  }
  var o = e[n];
  return r === void 0 ? delete e[n] : e[n] = r, o;
}
function ka(e) {
  if (typeof e == "string") {
    if (e = e.split("/"), e[0] === "")
      return e;
    throw new Error("Invalid JSON pointer.");
  } else if (Array.isArray(e)) {
    for (const t of e)
      if (typeof t != "string" && typeof t != "number")
        throw new Error("Invalid JSON pointer. Must be of type string or number.");
    return e;
  }
  throw new Error("Invalid JSON pointer.");
}
function Xl(e, t) {
  if (typeof e != "object")
    throw new Error("Invalid input object.");
  t = ka(t);
  var r = t.length;
  if (r === 1)
    return e;
  for (var n = 1; n < r; ) {
    if (e = e[Jl(t[n++])], r === n)
      return e;
    if (typeof e != "object" || e === null)
      return;
  }
}
function Zl(e, t, r) {
  if (typeof e != "object")
    throw new Error("Invalid input object.");
  if (t = ka(t), t.length === 0)
    throw new Error("Invalid JSON pointer for set.");
  return Jh(e, t, r);
}
function Xh(e) {
  var t = ka(e);
  return {
    get: function(r) {
      return Xl(r, t);
    },
    set: function(r, n) {
      return Zl(r, t, n);
    }
  };
}
yi.get = Xl;
yi.set = Zl;
yi.compile = Xh;
function Zh(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var Ql = Zh;
function Qh(e, t, r) {
  var n = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), r = r > i ? i : r, r < 0 && (r += i), i = t > r ? 0 : r - t >>> 0, t >>>= 0;
  for (var a = Array(i); ++n < i; )
    a[n] = e[n + t];
  return a;
}
var em = Qh, tm = hn, rm = em;
function nm(e, t) {
  return t.length < 2 ? e : tm(e, rm(t, 0, -1));
}
var im = nm, am = kr, sm = Ql, om = im, lm = ur;
function cm(e, t) {
  return t = am(t, e), e = om(e, t), e == null || delete e[lm(sm(t))];
}
var ec = cm, um = Fr;
function dm(e) {
  return um(e) ? void 0 : e;
}
var fm = dm, vo = Tl, hm = hi, mm = We, $o = vo ? vo.isConcatSpreadable : void 0;
function pm(e) {
  return mm(e) || hm(e) || !!($o && e && e[$o]);
}
var ym = pm, gm = vf, vm = ym;
function tc(e, t, r, n, i) {
  var a = -1, s = e.length;
  for (r || (r = vm), i || (i = []); ++a < s; ) {
    var o = e[a];
    t > 0 && r(o) ? t > 1 ? tc(o, t - 1, r, n, i) : gm(i, o) : n || (i[i.length] = o);
  }
  return i;
}
var gi = tc, $m = gi;
function _m(e) {
  var t = e == null ? 0 : e.length;
  return t ? $m(e, 1) : [];
}
var Ra = _m;
function bm(e, t, r) {
  switch (r.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, r[0]);
    case 2:
      return e.call(t, r[0], r[1]);
    case 3:
      return e.call(t, r[0], r[1], r[2]);
  }
  return e.apply(t, r);
}
var rc = bm, Sm = rc, _o = Math.max;
function wm(e, t, r) {
  return t = _o(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var n = arguments, i = -1, a = _o(n.length - t, 0), s = Array(a); ++i < a; )
      s[i] = n[t + i];
    i = -1;
    for (var o = Array(t + 1); ++i < t; )
      o[i] = n[i];
    return o[t] = r(s), Sm(e, this, o);
  };
}
var nc = wm;
function Em(e) {
  return function() {
    return e;
  };
}
var Om = Em;
function Cm(e) {
  return e;
}
var mn = Cm, Am = Om, bo = nf, Pm = mn, Im = bo ? function(e, t) {
  return bo(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: Am(t),
    writable: !0
  });
} : Pm, Tm = Im, Nm = 800, Dm = 16, Fm = Date.now;
function km(e) {
  var t = 0, r = 0;
  return function() {
    var n = Fm(), i = Dm - (n - r);
    if (r = n, i > 0) {
      if (++t >= Nm)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var Rm = km, Mm = Tm, jm = Rm, Um = jm(Mm), ic = Um, Vm = Ra, xm = nc, Lm = ic;
function Bm(e) {
  return Lm(xm(e, void 0, Vm), e + "");
}
var ac = Bm, qm = Pt, Km = sf, zm = ec, Wm = kr, Gm = Dl, Hm = fm, Ym = ac, Jm = af, Xm = 1, Zm = 2, Qm = 4, ep = Ym(function(e, t) {
  var r = {};
  if (e == null)
    return r;
  var n = !1;
  t = qm(t, function(a) {
    return a = Wm(a, e), n || (n = a.length > 1), a;
  }), Gm(e, Jm(e), r), n && (r = Km(r, Xm | Zm | Qm, Hm));
  for (var i = t.length; i--; )
    zm(r, t[i]);
  return r;
}), tp = ep;
const Qn = /* @__PURE__ */ we(tp);
function Ma(e, t) {
  const r = t[e];
  return [Qn(t, [e]), r];
}
function sc(e, t = {}, r = []) {
  const n = e || "";
  let i;
  if (n.startsWith("#"))
    i = decodeURIComponent(n.substring(1));
  else
    throw new Error(`Could not find a definition for ${e}.`);
  const a = yi.get(t, i);
  if (a === void 0)
    throw new Error(`Could not find a definition for ${e}.`);
  const s = a[Te];
  if (s) {
    if (r.includes(s)) {
      if (r.length === 1)
        throw new Error(`Definition for ${e} is a circular reference`);
      const [u, ...f] = r, p = [...f, n, u].join(" -> ");
      throw new Error(`Definition for ${u} contains a circular reference through ${p}`);
    }
    const [o, l] = Ma(Te, a), c = sc(l, t, [...r, n]);
    return Object.keys(o).length > 0 ? { ...o, ...c } : c;
  }
  return a;
}
function oc(e, t = {}) {
  return sc(e, t, []);
}
var rp = Object.prototype, np = rp.hasOwnProperty;
function ip(e, t) {
  return e != null && np.call(e, t);
}
var ap = ip, sp = kr, op = hi, lp = We, cp = Ea, up = $f, dp = ur;
function fp(e, t, r) {
  t = sp(t, e);
  for (var n = -1, i = t.length, a = !1; ++n < i; ) {
    var s = dp(t[n]);
    if (!(a = e != null && r(e, s)))
      break;
    e = e[s];
  }
  return a || ++n != i ? a : (i = e == null ? 0 : e.length, !!i && up(i) && cp(s, i) && (lp(e) || op(e)));
}
var lc = fp, hp = ap, mp = lc;
function pp(e, t) {
  return e != null && mp(e, t, hp);
}
var yp = pp;
const Le = /* @__PURE__ */ we(yp);
var gp = fi, vp = cn, $p = "[object Number]";
function _p(e) {
  return typeof e == "number" || vp(e) && gp(e) == $p;
}
var bp = _p;
const ja = /* @__PURE__ */ we(bp);
var Sp = fi, wp = We, Ep = cn, Op = "[object String]";
function Cp(e) {
  return typeof e == "string" || !wp(e) && Ep(e) && Sp(e) == Op;
}
var Ap = Cp;
const ir = /* @__PURE__ */ we(Ap);
function Pp(e, t, r, n) {
  var i = -1, a = e == null ? 0 : e.length;
  for (n && a && (r = e[++i]); ++i < a; )
    r = t(r, e[i], i, e);
  return r;
}
var Ip = Pp;
function Tp(e) {
  return function(t, r, n) {
    for (var i = -1, a = Object(t), s = n(t), o = s.length; o--; ) {
      var l = s[e ? o : ++i];
      if (r(a[l], l, a) === !1)
        break;
    }
    return t;
  };
}
var Np = Tp, Dp = Np, Fp = Dp(), cc = Fp, kp = cc, Rp = Rl;
function Mp(e, t) {
  return e && kp(e, t, Rp);
}
var uc = Mp, jp = un;
function Up(e, t) {
  return function(r, n) {
    if (r == null)
      return r;
    if (!jp(r))
      return e(r, n);
    for (var i = r.length, a = t ? i : -1, s = Object(r); (t ? a-- : ++a < i) && n(s[a], a, s) !== !1; )
      ;
    return r;
  };
}
var Vp = Up, xp = uc, Lp = Vp, Bp = Lp(xp), Ua = Bp, qp = Ml, Kp = Ca, zp = 1, Wp = 2;
function Gp(e, t, r, n) {
  var i = r.length, a = i, s = !n;
  if (e == null)
    return !a;
  for (e = Object(e); i--; ) {
    var o = r[i];
    if (s && o[2] ? o[1] !== e[o[0]] : !(o[0] in e))
      return !1;
  }
  for (; ++i < a; ) {
    o = r[i];
    var l = o[0], c = e[l], u = o[1];
    if (s && o[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var f = new qp();
      if (n)
        var p = n(c, u, l, e, t, f);
      if (!(p === void 0 ? Kp(u, c, zp | Wp, n, f) : p))
        return !1;
    }
  }
  return !0;
}
var Hp = Gp, Yp = cr;
function Jp(e) {
  return e === e && !Yp(e);
}
var dc = Jp, Xp = dc, Zp = Rl;
function Qp(e) {
  for (var t = Zp(e), r = t.length; r--; ) {
    var n = t[r], i = e[n];
    t[r] = [n, i, Xp(i)];
  }
  return t;
}
var ey = Qp;
function ty(e, t) {
  return function(r) {
    return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r));
  };
}
var fc = ty, ry = Hp, ny = ey, iy = fc;
function ay(e) {
  var t = ny(e);
  return t.length == 1 && t[0][2] ? iy(t[0][0], t[0][1]) : function(r) {
    return r === e || ry(r, e, t);
  };
}
var sy = ay;
function oy(e, t) {
  return e != null && t in Object(e);
}
var ly = oy, cy = ly, uy = lc;
function dy(e, t) {
  return e != null && uy(e, t, cy);
}
var hc = dy, fy = Ca, hy = Yl, my = hc, py = Da, yy = dc, gy = fc, vy = ur, $y = 1, _y = 2;
function by(e, t) {
  return py(e) && yy(t) ? gy(vy(e), t) : function(r) {
    var n = hy(r, e);
    return n === void 0 && n === t ? my(r, e) : fy(t, n, $y | _y);
  };
}
var Sy = by;
function wy(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var Ey = wy, Oy = hn;
function Cy(e) {
  return function(t) {
    return Oy(t, e);
  };
}
var Ay = Cy, Py = Ey, Iy = Ay, Ty = Da, Ny = ur;
function Dy(e) {
  return Ty(e) ? Py(Ny(e)) : Iy(e);
}
var Fy = Dy, ky = sy, Ry = Sy, My = mn, jy = We, Uy = Fy;
function Vy(e) {
  return typeof e == "function" ? e : e == null ? My : typeof e == "object" ? jy(e) ? Ry(e[0], e[1]) : ky(e) : Uy(e);
}
var Va = Vy;
function xy(e, t, r, n, i) {
  return i(e, function(a, s, o) {
    r = n ? (n = !1, a) : t(r, a, s, o);
  }), r;
}
var Ly = xy, By = Ip, qy = Ua, Ky = Va, zy = Ly, Wy = We;
function Gy(e, t, r) {
  var n = Wy(e) ? By : zy, i = arguments.length < 3;
  return n(e, Ky(t), r, i, qy);
}
var Hy = Gy;
const Yy = /* @__PURE__ */ we(Hy);
var Jy = mn;
function Xy(e) {
  return typeof e == "function" ? e : Jy;
}
var mc = Xy, Zy = Sf, So = 1 / 0, Qy = 17976931348623157e292;
function eg(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Zy(e), e === So || e === -So) {
    var t = e < 0 ? -1 : 1;
    return t * Qy;
  }
  return e === e ? e : 0;
}
var tg = eg, rg = tg;
function ng(e) {
  var t = rg(e), r = t % 1;
  return t === t ? r ? t - r : t : 0;
}
var ig = ng, ag = _f, sg = mc, og = ig, lg = 9007199254740991, Ni = 4294967295, cg = Math.min;
function ug(e, t) {
  if (e = og(e), e < 1 || e > lg)
    return [];
  var r = Ni, n = cg(e, Ni);
  t = sg(t), e -= Ni;
  for (var i = ag(n, t); ++r < e; )
    t(r);
  return i;
}
var dg = ug;
const pc = /* @__PURE__ */ we(dg);
function yc(e, t, r) {
  var n;
  if (e && r) {
    const i = G(e, r);
    if (i === void 0)
      return;
    for (let a = 0; a < t.length; a++) {
      const s = t[a], o = G(s, [Oe, r], {});
      if (!(o.type === "object" || o.type === "array") && (o.const === i || !((n = o.enum) === null || n === void 0) && n.includes(i)))
        return a;
    }
  }
}
function gc(e, t, r, n, i) {
  if (t === void 0)
    return 0;
  const a = yc(t, r, i);
  if (ja(a))
    return a;
  for (let s = 0; s < r.length; s++) {
    const o = r[s];
    if (i && Le(o, [Oe, i])) {
      const l = G(t, i), c = G(o, [Oe, i], {});
      if (e.isValid(c, l, n))
        return s;
    } else if (o[Oe]) {
      const l = {
        anyOf: Object.keys(o[Oe]).map((u) => ({
          required: [u]
        }))
      };
      let c;
      if (o.anyOf) {
        const { ...u } = o;
        u.allOf ? u.allOf = u.allOf.slice() : u.allOf = [], u.allOf.push(l), c = u;
      } else
        c = Object.assign({}, o, l);
      if (delete c.required, e.isValid(c, t, n))
        return s;
    } else if (e.isValid(o, t, n))
      return s;
  }
  return 0;
}
function xa(e, t, r, n, i) {
  return gc(e, t, r, n, i);
}
var fg = of, hg = kr, mg = Ea, wo = cr, pg = ur;
function yg(e, t, r, n) {
  if (!wo(e))
    return e;
  t = hg(t, e);
  for (var i = -1, a = t.length, s = a - 1, o = e; o != null && ++i < a; ) {
    var l = pg(t[i]), c = r;
    if (l === "__proto__" || l === "constructor" || l === "prototype")
      return e;
    if (i != s) {
      var u = o[l];
      c = n ? n(u, l, o) : void 0, c === void 0 && (c = wo(u) ? u : mg(t[i + 1]) ? [] : {});
    }
    fg(o, l, c), o = o[l];
  }
  return e;
}
var vc = yg, gg = vc;
function vg(e, t, r) {
  return e == null ? e : gg(e, t, r);
}
var $g = vg;
const je = /* @__PURE__ */ we($g);
var _g = Fl, bg = lf, Sg = uc, wg = Va, Eg = Nl, Og = We, Cg = Sa, Ag = jl, Pg = cr, Ig = wa;
function Tg(e, t, r) {
  var n = Og(e), i = n || Cg(e) || Ig(e);
  if (t = wg(t), r == null) {
    var a = e && e.constructor;
    i ? r = n ? new a() : [] : Pg(e) ? r = Ag(a) ? bg(Eg(e)) : {} : r = {};
  }
  return (i ? _g : Sg)(e, function(s, o, l) {
    return t(r, s, o, l);
  }), r;
}
var Ng = Tg;
const Dg = /* @__PURE__ */ we(Ng);
var Fg = cf, kg = Oa;
function Rg(e, t, r) {
  (r !== void 0 && !kg(e[t], r) || r === void 0 && !(t in e)) && Fg(e, t, r);
}
var $c = Rg, Mg = un, jg = cn;
function Ug(e) {
  return jg(e) && Mg(e);
}
var vi = Ug;
function Vg(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
var _c = Vg, xg = Dl, Lg = _a;
function Bg(e) {
  return xg(e, Lg(e));
}
var qg = Bg, Eo = $c, Kg = uf, zg = df, Wg = ba, Gg = ff, Oo = hi, Co = We, Hg = vi, Yg = Sa, Jg = jl, Xg = cr, Zg = Fr, Qg = wa, Ao = _c, ev = qg;
function tv(e, t, r, n, i, a, s) {
  var o = Ao(e, r), l = Ao(t, r), c = s.get(l);
  if (c) {
    Eo(e, r, c);
    return;
  }
  var u = a ? a(o, l, r + "", e, t, s) : void 0, f = u === void 0;
  if (f) {
    var p = Co(l), d = !p && Yg(l), m = !p && !d && Qg(l);
    u = l, p || d || m ? Co(o) ? u = o : Hg(o) ? u = Wg(o) : d ? (f = !1, u = Kg(l, !0)) : m ? (f = !1, u = zg(l, !0)) : u = [] : Zg(l) || Oo(l) ? (u = o, Oo(o) ? u = ev(o) : (!Xg(o) || Jg(o)) && (u = Gg(l))) : f = !1;
  }
  f && (s.set(l, u), i(u, l, n, a, s), s.delete(l)), Eo(e, r, u);
}
var rv = tv, nv = Ml, iv = $c, av = cc, sv = rv, ov = cr, lv = _a, cv = _c;
function bc(e, t, r, n, i) {
  e !== t && av(t, function(a, s) {
    if (i || (i = new nv()), ov(a))
      sv(e, t, s, r, bc, n, i);
    else {
      var o = n ? n(cv(e, s), a, s + "", e, t, i) : void 0;
      o === void 0 && (o = a), iv(e, s, o);
    }
  }, lv);
}
var La = bc, uv = mn, dv = nc, fv = ic;
function hv(e, t) {
  return fv(dv(e, t, uv), e + "");
}
var Bt = hv, mv = Oa, pv = un, yv = Ea, gv = cr;
function vv(e, t, r) {
  if (!gv(r))
    return !1;
  var n = typeof t;
  return (n == "number" ? pv(r) && yv(t, r.length) : n == "string" && t in r) ? mv(r[t], e) : !1;
}
var Ba = vv, $v = Bt, _v = Ba;
function bv(e) {
  return $v(function(t, r) {
    var n = -1, i = r.length, a = i > 1 ? r[i - 1] : void 0, s = i > 2 ? r[2] : void 0;
    for (a = e.length > 3 && typeof a == "function" ? (i--, a) : void 0, s && _v(r[0], r[1], s) && (a = i < 3 ? void 0 : a, i = 1), t = Object(t); ++n < i; ) {
      var o = r[n];
      o && e(t, o, n, a);
    }
    return t;
  });
}
var Sc = bv, Sv = La, wv = Sc, Ev = wv(function(e, t, r) {
  Sv(e, t, r);
}), Ov = Ev;
const Cv = /* @__PURE__ */ we(Ov);
var Av = gi, Pv = 1 / 0;
function Iv(e) {
  var t = e == null ? 0 : e.length;
  return t ? Av(e, Pv) : [];
}
var qa = Iv;
const Tv = /* @__PURE__ */ we(qa);
function Nv(e, t, r, n) {
  for (var i = e.length, a = r + (n ? 1 : -1); n ? a-- : ++a < i; )
    if (t(e[a], a, e))
      return a;
  return -1;
}
var Dv = Nv;
function Fv(e) {
  return e !== e;
}
var kv = Fv;
function Rv(e, t, r) {
  for (var n = r - 1, i = e.length; ++n < i; )
    if (e[n] === t)
      return n;
  return -1;
}
var Mv = Rv, jv = Dv, Uv = kv, Vv = Mv;
function xv(e, t, r) {
  return t === t ? Vv(e, t, r) : jv(e, Uv, r);
}
var wc = xv, Lv = wc;
function Bv(e, t) {
  var r = e == null ? 0 : e.length;
  return !!r && Lv(e, t, 0) > -1;
}
var Ka = Bv;
function qv(e, t, r) {
  for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
    if (r(t, e[n]))
      return !0;
  return !1;
}
var za = qv;
function Kv() {
}
var zv = Kv, Di = bf, Wv = zv, Gv = Ul, Hv = 1 / 0, Yv = Di && 1 / Gv(new Di([, -0]))[1] == Hv ? function(e) {
  return new Di(e);
} : Wv, Jv = Yv, Xv = Aa, Zv = Ka, Qv = za, e$ = Pa, t$ = Jv, r$ = Ul, n$ = 200;
function i$(e, t, r) {
  var n = -1, i = Zv, a = e.length, s = !0, o = [], l = o;
  if (r)
    s = !1, i = Qv;
  else if (a >= n$) {
    var c = t ? null : t$(e);
    if (c)
      return r$(c);
    s = !1, i = e$, l = new Xv();
  } else
    l = t ? [] : o;
  e:
    for (; ++n < a; ) {
      var u = e[n], f = t ? t(u) : u;
      if (u = r || u !== 0 ? u : 0, s && f === f) {
        for (var p = l.length; p--; )
          if (l[p] === f)
            continue e;
        t && l.push(f), o.push(u);
      } else
        i(l, f, r) || (l !== o && l.push(f), o.push(u));
    }
  return o;
}
var Wa = i$, a$ = Wa;
function s$(e) {
  return e && e.length ? a$(e) : [];
}
var $i = s$;
const o$ = /* @__PURE__ */ we($i);
var l$ = Ua, c$ = un;
function u$(e, t) {
  var r = -1, n = c$(e) ? Array(e.length) : [];
  return l$(e, function(i, a, s) {
    n[++r] = t(i, a, s);
  }), n;
}
var d$ = u$;
function f$(e, t) {
  var r = e.length;
  for (e.sort(t); r--; )
    e[r] = e[r].value;
  return e;
}
var h$ = f$, Po = dn;
function m$(e, t) {
  if (e !== t) {
    var r = e !== void 0, n = e === null, i = e === e, a = Po(e), s = t !== void 0, o = t === null, l = t === t, c = Po(t);
    if (!o && !c && !a && e > t || a && s && l && !o && !c || n && s && l || !r && l || !i)
      return 1;
    if (!n && !a && !c && e < t || c && r && i && !n && !a || o && r && i || !s && i || !l)
      return -1;
  }
  return 0;
}
var p$ = m$, y$ = p$;
function g$(e, t, r) {
  for (var n = -1, i = e.criteria, a = t.criteria, s = i.length, o = r.length; ++n < s; ) {
    var l = y$(i[n], a[n]);
    if (l) {
      if (n >= o)
        return l;
      var c = r[n];
      return l * (c == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
var v$ = g$, Fi = Pt, $$ = hn, _$ = Va, b$ = d$, S$ = h$, w$ = mi, E$ = v$, O$ = mn, C$ = We;
function A$(e, t, r) {
  t.length ? t = Fi(t, function(a) {
    return C$(a) ? function(s) {
      return $$(s, a.length === 1 ? a[0] : a);
    } : a;
  }) : t = [O$];
  var n = -1;
  t = Fi(t, w$(_$));
  var i = b$(e, function(a, s, o) {
    var l = Fi(t, function(c) {
      return c(a);
    });
    return { criteria: l, index: ++n, value: a };
  });
  return S$(i, function(a, s) {
    return E$(a, s, r);
  });
}
var P$ = A$, I$ = gi, T$ = P$, N$ = Bt, Io = Ba, D$ = N$(function(e, t) {
  if (e == null)
    return [];
  var r = t.length;
  return r > 1 && Io(e, t[0], t[1]) ? t = [] : r > 2 && Io(t[0], t[1], t[2]) && (t = [t[0]]), T$(e, I$(t, 1), []);
}), Ec = D$, F$ = Wa;
function k$(e, t) {
  return t = typeof t == "function" ? t : void 0, e && e.length ? F$(e, void 0, t) : [];
}
var Ga = k$, R$ = Bt, M$ = Oa, j$ = Ba, U$ = _a, Oc = Object.prototype, V$ = Oc.hasOwnProperty, x$ = R$(function(e, t) {
  e = Object(e);
  var r = -1, n = t.length, i = n > 2 ? t[2] : void 0;
  for (i && j$(t[0], t[1], i) && (n = 1); ++r < n; )
    for (var a = t[r], s = U$(a), o = -1, l = s.length; ++o < l; ) {
      var c = s[o], u = e[c];
      (u === void 0 || M$(u, Oc[c]) && !V$.call(e, c)) && (e[c] = a[c]);
    }
  return e;
}), L$ = x$, B$ = Aa, q$ = Ka, K$ = za, z$ = Pt, W$ = mi, To = Pa, G$ = Math.min;
function H$(e, t, r) {
  for (var n = r ? K$ : q$, i = e[0].length, a = e.length, s = a, o = Array(a), l = 1 / 0, c = []; s--; ) {
    var u = e[s];
    s && t && (u = z$(u, W$(t))), l = G$(u.length, l), o[s] = !r && (t || i >= 120 && u.length >= 120) ? new B$(s && u) : void 0;
  }
  u = e[0];
  var f = -1, p = o[0];
  e:
    for (; ++f < i && c.length < l; ) {
      var d = u[f], m = t ? t(d) : d;
      if (d = r || d !== 0 ? d : 0, !(p ? To(p, m) : n(c, m, r))) {
        for (s = a; --s; ) {
          var h = o[s];
          if (!(h ? To(h, m) : n(e[s], m, r)))
            continue e;
        }
        p && p.push(m), c.push(d);
      }
    }
  return c;
}
var Cc = H$, Y$ = vi;
function J$(e) {
  return Y$(e) ? e : [];
}
var Ac = J$, X$ = Pt, Z$ = Cc, Q$ = Bt, e0 = Ac, t0 = Ql, r0 = Q$(function(e) {
  var t = t0(e), r = X$(e, e0);
  return t = typeof t == "function" ? t : void 0, t && r.pop(), r.length && r[0] === e[0] ? Z$(r, void 0, t) : [];
}), Pc = r0, n0 = fi, i0 = cn, a0 = "[object Boolean]";
function s0(e) {
  return e === !0 || e === !1 || i0(e) && n0(e) == a0;
}
var o0 = s0, ct = Vl, l0 = Ec, Ha = $i, No = Ga, c0 = L$, u0 = Pc, ei = Fr, ki = o0, Do = (e) => Array.isArray(e) ? e : [e], tt = (e) => e === void 0, Nn = (e) => ei(e) || Array.isArray(e) ? Object.keys(e) : [], _r = (e, t) => e.hasOwnProperty(t), Cr = (e) => l0(Ha(e)), Fo = (e) => tt(e) || Array.isArray(e) && e.length === 0, d0 = (e, t, r, n) => t && _r(t, r) && e && _r(e, r) && n(e[r], t[r]), Ri = (e, t) => tt(e) && t === 0 || tt(t) && e === 0 || ct(e, t), f0 = (e, t) => tt(e) && t === !1 || tt(t) && e === !1 || ct(e, t), ko = (e) => tt(e) || ct(e, {}) || e === !0, Dn = (e) => tt(e) || ct(e, {}), Ro = (e) => tt(e) || ei(e) || e === !0 || e === !1;
function Mo(e, t) {
  return Fo(e) && Fo(t) ? !0 : ct(Cr(e), Cr(t));
}
function h0(e, t) {
  return e = Do(e), t = Do(t), ct(Cr(e), Cr(t));
}
function qn(e, t, r, n) {
  var i = Ha(Nn(e).concat(Nn(t)));
  return Dn(e) && Dn(t) ? !0 : Dn(e) && Nn(t).length || Dn(t) && Nn(e).length ? !1 : i.every(function(a) {
    var s = e[a], o = t[a];
    return Array.isArray(s) && Array.isArray(o) ? ct(Cr(e), Cr(t)) : Array.isArray(s) && !Array.isArray(o) || Array.isArray(o) && !Array.isArray(s) ? !1 : d0(e, t, a, n);
  });
}
function m0(e, t, r, n) {
  return ei(e) && ei(t) ? n(e, t) : Array.isArray(e) && Array.isArray(t) ? qn(e, t, r, n) : ct(e, t);
}
function Mi(e, t, r, n) {
  var i = No(e, n), a = No(t, n), s = u0(i, a, n);
  return s.length === Math.max(i.length, a.length);
}
var p0 = {
  title: ct,
  uniqueItems: f0,
  minLength: Ri,
  minItems: Ri,
  minProperties: Ri,
  required: Mo,
  enum: Mo,
  type: h0,
  items: m0,
  anyOf: Mi,
  allOf: Mi,
  oneOf: Mi,
  properties: qn,
  patternProperties: qn,
  dependencies: qn
}, y0 = [
  "properties",
  "patternProperties",
  "dependencies",
  "uniqueItems",
  "minLength",
  "minItems",
  "minProperties",
  "required"
], g0 = ["additionalProperties", "additionalItems", "contains", "propertyNames", "not"];
function Zi(e, t, r) {
  if (r = c0(r, {
    ignore: []
  }), ko(e) && ko(t))
    return !0;
  if (!Ro(e) || !Ro(t))
    throw new Error("Either of the values are not a JSON schema.");
  if (e === t)
    return !0;
  if (ki(e) && ki(t))
    return e === t;
  if (e === void 0 && t === !1 || t === void 0 && e === !1 || tt(e) && !tt(t) || !tt(e) && tt(t))
    return !1;
  var n = Ha(Object.keys(e).concat(Object.keys(t)));
  if (r.ignore.length && (n = n.filter((a) => r.ignore.indexOf(a) === -1)), !n.length)
    return !0;
  function i(a, s) {
    return Zi(a, s, r);
  }
  return n.every(function(a) {
    var s = e[a], o = t[a];
    if (g0.indexOf(a) !== -1)
      return Zi(s, o, r);
    var l = p0[a];
    if (l || (l = ct), ct(s, o))
      return !0;
    if (y0.indexOf(a) === -1 && (!_r(e, a) && _r(t, a) || _r(e, a) && !_r(t, a)))
      return s === o;
    var c = l(s, o, a, i);
    if (!ki(c))
      throw new Error("Comparer must return true or false");
    return c;
  });
}
var Ya = Zi;
function v0(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
}
var Ja = Array.isArray || v0;
function $0(e) {
  return (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]") && e.valueOf() === e.valueOf();
}
var _0 = $0, b0 = _0;
function S0(e) {
  return b0(e) && e % 1 === 0;
}
var w0 = S0, E0 = Ja, O0 = w0;
function C0(e) {
  var t;
  if (!E0(e) || (t = e.length, !t))
    return !1;
  for (var r = 0; r < t; r++)
    if (!O0(e[r]))
      return !1;
  return !0;
}
var Ic = C0;
function A0(e) {
  return typeof e == "function";
}
var Tc = A0, P0 = Ja, jo = Ic, I0 = Tc, Fn = Math.pow(2, 31) - 1;
function Uo(e, t) {
  var r = 1, n;
  if (e === 0)
    return t;
  if (t === 0)
    return e;
  for (; e % 2 === 0 && t % 2 === 0; )
    e = e / 2, t = t / 2, r = r * 2;
  for (; e % 2 === 0; )
    e = e / 2;
  for (; t; ) {
    for (; t % 2 === 0; )
      t = t / 2;
    e > t && (n = t, t = e, e = n), t = t - e;
  }
  return r * e;
}
function Vo(e, t) {
  var r = 0, n;
  if (e === 0)
    return t;
  if (t === 0)
    return e;
  for (; !(e & 1) && !(t & 1); )
    e >>>= 1, t >>>= 1, r++;
  for (; !(e & 1); )
    e >>>= 1;
  for (; t; ) {
    for (; !(t & 1); )
      t >>>= 1;
    e > t && (n = t, t = e, e = n), t = t - e;
  }
  return e << r;
}
function T0() {
  var e = arguments.length, t, r, n, i, a, s, o;
  for (t = new Array(e), o = 0; o < e; o++)
    t[o] = arguments[o];
  if (jo(t)) {
    if (e === 2)
      return a = t[0], s = t[1], a < 0 && (a = -a), s < 0 && (s = -s), a <= Fn && s <= Fn ? Vo(a, s) : Uo(a, s);
    n = t;
  } else if (P0(t[0]))
    if (e > 1) {
      if (n = t[0], r = t[1], !I0(r))
        throw new TypeError("gcd()::invalid input argument. Accessor must be a function. Value: `" + r + "`.");
    } else
      n = t[0];
  else
    throw new TypeError("gcd()::invalid input argument. Must provide an array of integers. Value: `" + t[0] + "`.");
  if (i = n.length, i < 2)
    return null;
  if (r) {
    for (a = new Array(i), o = 0; o < i; o++)
      a[o] = r(n[o], o);
    n = a;
  }
  if (e < 3 && !jo(n))
    throw new TypeError("gcd()::invalid input argument. Accessed array values must be integers. Value: `" + n + "`.");
  for (o = 0; o < i; o++)
    a = n[o], a < 0 && (n[o] = -a);
  for (a = n[0], o = 1; o < i; o++)
    s = n[o], s <= Fn && a <= Fn ? a = Vo(a, s) : a = Uo(a, s);
  return a;
}
var N0 = T0, xo = N0, D0 = Ja, Lo = Ic, F0 = Tc;
function k0() {
  var e = arguments.length, t, r, n, i, a, s, o;
  for (t = new Array(e), o = 0; o < e; o++)
    t[o] = arguments[o];
  if (Lo(t)) {
    if (e === 2)
      return a = t[0], s = t[1], a < 0 && (a = -a), s < 0 && (s = -s), a === 0 || s === 0 ? 0 : a / xo(a, s) * s;
    n = t;
  } else if (D0(t[0]))
    if (e > 1) {
      if (n = t[0], r = t[1], !F0(r))
        throw new TypeError("lcm()::invalid input argument. Accessor must be a function. Value: `" + r + "`.");
    } else
      n = t[0];
  else
    throw new TypeError("lcm()::invalid input argument. Must provide an array of integers. Value: `" + t[0] + "`.");
  if (i = n.length, i < 2)
    return null;
  if (r) {
    for (a = new Array(i), o = 0; o < i; o++)
      a[o] = r(n[o], o);
    n = a;
  }
  if (e < 3 && !Lo(n))
    throw new TypeError("lcm()::invalid input argument. Accessed array values must be integers. Value: `" + n + "`.");
  for (o = 0; o < i; o++)
    a = n[o], a < 0 && (n[o] = -a);
  for (a = n[0], o = 1; o < i; o++) {
    if (s = n[o], a === 0 || s === 0)
      return 0;
    a = a / xo(a, s) * s;
  }
  return a;
}
var R0 = k0, M0 = La, Bo = cr;
function Nc(e, t, r, n, i, a) {
  return Bo(e) && Bo(t) && (a.set(t, e), M0(e, t, void 0, Nc, a), a.delete(t)), e;
}
var j0 = Nc, U0 = La, V0 = Sc, x0 = V0(function(e, t, r, n) {
  U0(e, t, r, n);
}), L0 = x0, B0 = rc, q0 = Bt, K0 = j0, z0 = L0, W0 = q0(function(e) {
  return e.push(void 0, K0), B0(z0, void 0, e);
}), G0 = W0, H0 = Pt, Y0 = Cc, J0 = Bt, X0 = Ac, Z0 = J0(function(e) {
  var t = H0(e, X0);
  return t.length && t[0] === e[0] ? Y0(t) : [];
}), Q0 = Z0;
function e_(e, t, r, n) {
  for (var i = r - 1, a = e.length; ++i < a; )
    if (n(e[i], t))
      return i;
  return -1;
}
var t_ = e_, r_ = Pt, n_ = wc, i_ = t_, a_ = mi, s_ = ba, o_ = Array.prototype, qo = o_.splice;
function l_(e, t, r, n) {
  var i = n ? i_ : n_, a = -1, s = t.length, o = e;
  for (e === t && (t = s_(t)), r && (o = r_(e, a_(r))); ++a < s; )
    for (var l = 0, c = t[a], u = r ? r(c) : c; (l = i(o, u, l, n)) > -1; )
      o !== e && qo.call(o, l, 1), qo.call(e, l, 1);
  return e;
}
var c_ = l_, u_ = c_;
function d_(e, t) {
  return e && e.length && t && t.length ? u_(e, t) : e;
}
var f_ = d_, h_ = Fl, m_ = Ua, p_ = mc, y_ = We;
function g_(e, t) {
  var r = y_(e) ? h_ : m_;
  return r(e, p_(t));
}
var Dc = g_, v_ = Aa, $_ = Ka, __ = za, b_ = Pt, S_ = mi, w_ = Pa, E_ = 200;
function O_(e, t, r, n) {
  var i = -1, a = $_, s = !0, o = e.length, l = [], c = t.length;
  if (!o)
    return l;
  r && (t = b_(t, S_(r))), n ? (a = __, s = !1) : t.length >= E_ && (a = w_, s = !1, t = new v_(t));
  e:
    for (; ++i < o; ) {
      var u = e[i], f = r == null ? u : r(u);
      if (u = n || u !== 0 ? u : 0, s && f === f) {
        for (var p = c; p--; )
          if (t[p] === f)
            continue e;
        l.push(u);
      } else
        a(t, f, n) || l.push(u);
    }
  return l;
}
var C_ = O_, A_ = C_, P_ = Bt, I_ = vi, T_ = P_(function(e, t) {
  return I_(e) ? A_(e, t) : [];
}), N_ = T_;
const D_ = Ra, F_ = qa, Fc = Fr, k_ = $i, R_ = Ga, M_ = N_;
function j_(e) {
  for (const t in e)
    kc(e, t) && Rc(e[t]) && delete e[t];
  return e;
}
const U_ = (e) => k_(F_(e.map(Xa))), V_ = (e, t) => e.map((r) => r && r[t]), kc = (e, t) => Object.prototype.hasOwnProperty.call(e, t), Xa = (e) => Fc(e) || Array.isArray(e) ? Object.keys(e) : [], x_ = (e) => e !== void 0, L_ = (e) => Fc(e) || e === !0 || e === !1, Rc = (e) => !Xa(e).length && e !== !1 && e !== !0, B_ = (e, ...t) => M_.apply(null, [e].concat(D_(t)));
var Mc = {
  allUniqueKeys: U_,
  deleteUndefinedProps: j_,
  getValues: V_,
  has: kc,
  isEmptySchema: Rc,
  isSchema: L_,
  keys: Xa,
  notUndefined: x_,
  uniqWith: R_,
  withoutArr: B_
};
const q_ = Ya, K_ = Dc, {
  allUniqueKeys: z_,
  deleteUndefinedProps: W_,
  getValues: G_,
  keys: zr,
  notUndefined: H_,
  uniqWith: Y_,
  withoutArr: Ko
} = Mc;
function J_(e) {
  K_(e, function(t, r) {
    t === !1 && delete e[r];
  });
}
function zo(e, t) {
  return z_(e).reduce(function(n, i) {
    const a = G_(e, i), s = Y_(a.filter(H_), q_);
    return n[i] = t(s, i), n;
  }, {});
}
var X_ = {
  keywords: ["properties", "patternProperties", "additionalProperties"],
  resolver(e, t, r, n) {
    n.ignoreAdditionalProperties || (e.forEach(function(a) {
      const s = e.filter((u) => u !== a), o = zr(a.properties), c = zr(a.patternProperties).map((u) => new RegExp(u));
      s.forEach(function(u) {
        const f = zr(u.properties), p = f.filter((m) => c.some((h) => h.test(m)));
        Ko(f, o, p).forEach(function(m) {
          u.properties[m] = r.properties([
            u.properties[m],
            a.additionalProperties
          ], m);
        });
      });
    }), e.forEach(function(a) {
      const s = e.filter((l) => l !== a), o = zr(a.patternProperties);
      a.additionalProperties === !1 && s.forEach(function(l) {
        const c = zr(l.patternProperties);
        Ko(c, o).forEach((f) => delete l.patternProperties[f]);
      });
    }));
    const i = {
      additionalProperties: r.additionalProperties(e.map((a) => a.additionalProperties)),
      patternProperties: zo(e.map((a) => a.patternProperties), r.patternProperties),
      properties: zo(e.map((a) => a.properties), r.properties)
    };
    return i.additionalProperties === !1 && J_(i.properties), W_(i);
  }
};
const Z_ = Ya, Q_ = Dc, {
  allUniqueKeys: eb,
  deleteUndefinedProps: tb,
  has: rb,
  isSchema: jc,
  notUndefined: Uc,
  uniqWith: nb
} = Mc;
function ib(e) {
  Q_(e, function(t, r) {
    t === !1 && e.splice(r, 1);
  });
}
function ab(e, t) {
  return e.map(function(r) {
    if (r)
      if (Array.isArray(r.items)) {
        const n = r.items[t];
        if (jc(n))
          return n;
        if (rb(r, "additionalItems"))
          return r.additionalItems;
      } else
        return r.items;
  });
}
function sb(e) {
  return e.map(function(t) {
    if (t)
      return Array.isArray(t.items) ? t.additionalItems : t.items;
  });
}
function ob(e, t, r) {
  return eb(r).reduce(function(i, a) {
    const s = ab(e, a), o = nb(s.filter(Uc), Z_);
    return i[a] = t(o, a), i;
  }, []);
}
var lb = {
  keywords: ["items", "additionalItems"],
  resolver(e, t, r) {
    const n = e.map((o) => o.items), i = n.filter(Uc), a = {};
    i.every(jc) ? a.items = r.items(n) : a.items = ob(e, r.items, n);
    let s;
    return i.every(Array.isArray) ? s = e.map((o) => o.additionalItems) : i.some(Array.isArray) && (s = sb(e)), s && (a.additionalItems = r.additionalItems(s)), a.additionalItems === !1 && Array.isArray(a.items) && ib(a.items), tb(a);
  }
};
const Vc = hf, ti = Ya, cb = R0, ub = G0, xc = Ra, Za = qa, db = Q0, fb = Pc, Qi = Vl, Ar = Fr, hb = f_, Lc = Ec, Qa = $i, br = Ga, Bc = X_, qc = lb, kn = (e, t) => e.indexOf(t) !== -1, mb = (e) => Ar(e) || e === !0 || e === !1, pb = (e) => e === !1, Kc = (e) => e === !0, _i = (e, t, r) => r(e), zc = (e) => Lc(Qa(Za(e))), ri = (e) => e !== void 0, Wc = (e) => Qa(Za(e.map(bb))), Rr = (e) => e[0], yb = (e) => zc(e), pn = (e) => Math.max.apply(Math, e), yn = (e) => Math.min.apply(Math, e), gb = (e) => e.some(Kc), vb = (e) => br(xc(e), Qi);
function $b(e) {
  return function(t, r) {
    return ti({
      [e]: t
    }, { [e]: r });
  };
}
function Gc(e) {
  let { allOf: t = [], ...r } = e;
  return r = Ar(e) ? r : e, [r, ...t.map(Gc)];
}
function Hc(e, t) {
  return e.map((r) => r && r[t]);
}
function _b(e, t) {
  return e.map(function(r, n) {
    try {
      return t(r, n);
    } catch {
      return;
    }
  }).filter(ri);
}
function bb(e) {
  return Ar(e) || Array.isArray(e) ? Object.keys(e) : [];
}
function ea(e, t) {
  if (t = t || [], !e.length)
    return t;
  const r = e.slice(0).shift(), n = e.slice(1);
  return t.length ? ea(n, xc(t.map((i) => r.map((a) => [a].concat(i))))) : ea(n, r.map((i) => i));
}
function Yc(e, t) {
  let r;
  try {
    r = e.map(function(n) {
      return JSON.stringify(n, null, 2);
    }).join(`
`);
  } catch {
    r = e.join(", ");
  }
  throw new Error('Could not resolve values for path:"' + t.join(".") + `". They are probably incompatible. Values: 
` + r);
}
function Sb(e, t, r, n, i, a) {
  if (e.length) {
    const s = i.complexResolvers[t];
    if (!s || !s.resolver)
      throw new Error("No resolver found for " + t);
    const o = r.map((f) => e.reduce((p, d) => (f[d] !== void 0 && (p[d] = f[d]), p), {})), l = br(o, ti), c = s.keywords.reduce((f, p) => ({
      ...f,
      [p]: (d, m = []) => n(d, null, a.concat(p, m))
    }), {}), u = s.resolver(l, a.concat(t), c, i);
    return Ar(u) || Yc(l, a.concat(t)), u;
  }
}
function wb(e) {
  return { required: e };
}
const Eb = ["properties", "patternProperties", "definitions", "dependencies"], Ob = ["anyOf", "oneOf"], Cb = [
  "additionalProperties",
  "additionalItems",
  "contains",
  "propertyNames",
  "not",
  "items"
], he = {
  type(e) {
    if (e.some(Array.isArray)) {
      const t = e.map(function(n) {
        return Array.isArray(n) ? n : [n];
      }), r = db.apply(null, t);
      if (r.length === 1)
        return r[0];
      if (r.length > 1)
        return Qa(r);
    }
  },
  dependencies(e, t, r) {
    return Wc(e).reduce(function(i, a) {
      const s = Hc(e, a);
      let o = br(s.filter(ri), Qi);
      const l = o.filter(Array.isArray);
      if (l.length) {
        if (l.length === o.length)
          i[a] = zc(o);
        else {
          const c = o.filter(mb), u = l.map(wb);
          i[a] = r(c.concat(u), a);
        }
        return i;
      }
      return o = br(o, ti), i[a] = r(o, a), i;
    }, {});
  },
  oneOf(e, t, r) {
    const n = ea(Vc(e)), i = _b(n, r), a = br(i, ti);
    if (a.length)
      return a;
  },
  not(e) {
    return { anyOf: e };
  },
  pattern(e) {
    return e.map((t) => "(?=" + t + ")").join("");
  },
  multipleOf(e) {
    let t = e.slice(0), r = 1;
    for (; t.some((n) => !Number.isInteger(n)); )
      t = t.map((n) => n * 10), r = r * 10;
    return cb(t) / r;
  },
  enum(e) {
    const t = fb.apply(null, e.concat(Qi));
    if (t.length)
      return Lc(t);
  }
};
he.$id = Rr;
he.$ref = Rr;
he.$schema = Rr;
he.additionalItems = _i;
he.additionalProperties = _i;
he.anyOf = he.oneOf;
he.contains = _i;
he.default = Rr;
he.definitions = he.dependencies;
he.description = Rr;
he.examples = vb;
he.exclusiveMaximum = yn;
he.exclusiveMinimum = pn;
he.items = qc;
he.maximum = yn;
he.maxItems = yn;
he.maxLength = yn;
he.maxProperties = yn;
he.minimum = pn;
he.minItems = pn;
he.minLength = pn;
he.minProperties = pn;
he.properties = Bc;
he.propertyNames = _i;
he.required = yb;
he.title = Rr;
he.uniqueItems = gb;
const Ab = {
  properties: Bc,
  items: qc
};
function es(e, t, r) {
  t = ub(t, {
    ignoreAdditionalProperties: !1,
    resolvers: he,
    complexResolvers: Ab,
    deep: !0
  });
  const n = Object.entries(t.complexResolvers);
  function i(o, l, c) {
    o = Vc(o.filter(ri)), c = c || [];
    const u = Ar(l) ? l : {};
    if (!o.length)
      return;
    if (o.some(pb))
      return !1;
    if (o.every(Kc))
      return !0;
    o = o.filter(Ar);
    const f = Wc(o);
    if (t.deep && kn(f, "allOf"))
      return es({
        allOf: o
      }, t);
    const p = n.map(([d, m]) => f.filter((h) => m.keywords.includes(h)));
    return p.forEach((d) => hb(f, d)), f.forEach(function(d) {
      const m = Hc(o, d), h = br(m.filter(ri), $b(d));
      if (h.length === 1 && kn(Ob, d))
        u[d] = h[0].map((g) => i([g], g));
      else if (h.length === 1 && !kn(Eb, d) && !kn(Cb, d))
        u[d] = h[0];
      else {
        const g = t.resolvers[d] || t.resolvers.defaultResolver;
        if (!g)
          throw new Error("No resolver found for key " + d + ". You can provide a resolver for this keyword in the options, or provide a default resolver.");
        const y = (v, b = []) => i(v, null, c.concat(d, b));
        u[d] = g(h, c.concat(d), y, t), u[d] === void 0 ? Yc(h, c.concat(d)) : u[d] === void 0 && delete u[d];
      }
    }), n.reduce((d, [m, h], g) => ({
      ...d,
      ...Sb(p[g], m, o, i, t, c)
    }), u);
  }
  const a = Za(Gc(e));
  return i(a);
}
es.options = {
  resolvers: he
};
var Pb = es;
const Ib = /* @__PURE__ */ we(Pb);
function Pr(e) {
  let t;
  const r = G(e, "discriminator.propertyName", void 0);
  return ir(r) ? t = r : r !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof r}" instead`), t;
}
function rn(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
}
var Tb = gi, Nb = Bt, Db = Wa, Fb = vi, kb = Nb(function(e) {
  return Db(Tb(e, 1, Fb, !0));
}), Rb = kb;
const Mb = /* @__PURE__ */ we(Rb);
function Lt(e) {
  let { type: t } = e;
  return !t && e.const ? rn(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((r) => r !== "null") : t = t[0]), t);
}
function At(e, t) {
  const r = Object.assign({}, e);
  return Object.keys(t).reduce((n, i) => {
    const a = e ? e[i] : {}, s = t[i];
    return e && i in e && Se(s) ? n[i] = At(a, s) : e && t && (Lt(e) === "object" || Lt(t) === "object") && i === Rf && Array.isArray(a) && Array.isArray(s) ? n[i] = Mb(a, s) : n[i] = s, n;
  }, r);
}
function Ge(e, t, r = {}, n) {
  return yt(e, t, r, n)[0];
}
function jb(e, t, r, n, i, a) {
  const { if: s, then: o, else: l, ...c } = t, u = e.isValid(s, a || {}, r);
  let f = [c], p = [];
  if (n)
    o && typeof o != "boolean" && (p = p.concat(yt(e, o, r, a, n, i))), l && typeof l != "boolean" && (p = p.concat(yt(e, l, r, a, n, i)));
  else {
    const d = u ? o : l;
    d && typeof d != "boolean" && (p = p.concat(yt(e, d, r, a, n, i)));
  }
  return p.length && (f = p.map((d) => At(c, d))), f.flatMap((d) => yt(e, d, r, a, n, i));
}
function Jc(e) {
  return e.reduce(
    (r, n) => n.length > 1 ? n.flatMap((i) => pc(r.length, (a) => [...r[a]].concat(i))) : (r.forEach((i) => i.push(n[0])), r),
    [[]]
    // Start with an empty list
  );
}
function Ub(e, t, r, n, i, a) {
  const s = Xc(e, t, r, n, i, a);
  if (s.length > 1 || s[0] !== t)
    return s;
  if (pi in t)
    return Zc(e, t, r, n, i, a).flatMap((l) => yt(e, l, r, a, n, i));
  if (fn in t && Array.isArray(t.allOf)) {
    const o = t.allOf.map((c) => yt(e, c, r, a, n, i));
    return Jc(o).map((c) => ({ ...t, allOf: c }));
  }
  return [t];
}
function Xc(e, t, r, n, i, a) {
  const s = nn(t, r, i);
  return s !== t ? yt(e, s, r, a, n, i) : [t];
}
function nn(e, t, r) {
  if (!Se(e))
    return e;
  let n = e;
  if (Te in n) {
    const { $ref: i, ...a } = n;
    if (r.includes(i))
      return n;
    r.push(i), n = { ...oc(i, t), ...a };
  }
  if (Oe in n) {
    const i = [], a = Dg(n[Oe], (s, o, l) => {
      const c = [...r];
      s[l] = nn(o, t, c), i.push(c);
    }, {});
    Cv(r, o$(Tv(i))), n = { ...n, [Oe]: a };
  }
  return Ut in n && !Array.isArray(n.items) && typeof n.items != "boolean" && (n = {
    ...n,
    items: nn(n.items, t, r)
  }), sr(e, n) ? e : n;
}
function Vb(e, t, r, n) {
  const i = {
    ...t,
    properties: { ...t.properties }
  }, a = n && Se(n) ? n : {};
  return Object.keys(a).forEach((s) => {
    if (s in i.properties)
      return;
    let o = {};
    typeof i.additionalProperties != "boolean" ? Te in i.additionalProperties ? o = Ge(e, { $ref: G(i.additionalProperties, [Te]) }, r, a) : "type" in i.additionalProperties ? o = { ...i.additionalProperties } : pt in i.additionalProperties || et in i.additionalProperties ? o = {
      type: "object",
      ...i.additionalProperties
    } : o = { type: rn(G(a, [s])) } : o = { type: rn(G(a, [s])) }, i.properties[s] = o, je(i.properties, [s, Dr], !0);
  }), i;
}
function yt(e, t, r, n, i = !1, a = []) {
  return Se(t) ? Ub(e, t, r, i, a, n).flatMap((o) => {
    let l = o;
    if (Ff in l)
      return jb(e, l, r, i, a, n);
    if (fn in l) {
      if (i) {
        const { allOf: u, ...f } = l;
        return [...u, f];
      }
      try {
        l = Ib(l, {
          deep: !1
        });
      } catch (u) {
        console.warn(`could not merge subschemas in allOf:
`, u);
        const { allOf: f, ...p } = l;
        return p;
      }
    }
    return Ji in l && l.additionalProperties !== !1 ? Vb(e, l, r, n) : l;
  }) : [{}];
}
function xb(e, t, r, n, i) {
  let a;
  const { oneOf: s, anyOf: o, ...l } = t;
  if (Array.isArray(s) ? a = s : Array.isArray(o) && (a = o), a) {
    const c = i === void 0 && n ? {} : i, u = Pr(t);
    a = a.map((p) => nn(p, r, []));
    const f = xa(e, c, a, r, u);
    if (n)
      return a.map((p) => At(l, p));
    t = At(l, a[f]);
  }
  return [t];
}
function Zc(e, t, r, n, i, a) {
  const { dependencies: s, ...o } = t;
  return xb(e, o, r, n, a).flatMap((c) => Qc(e, s, c, r, n, i, a));
}
function Qc(e, t, r, n, i, a, s) {
  let o = [r];
  for (const l in t) {
    if (!i && G(s, [l]) === void 0 || r.properties && !(l in r.properties))
      continue;
    const [c, u] = Ma(l, t);
    return Array.isArray(u) ? o[0] = Lb(r, u) : Se(u) && (o = Bb(e, r, n, l, u, i, a, s)), o.flatMap((f) => Qc(e, c, f, n, i, a, s));
  }
  return o;
}
function Lb(e, t) {
  if (!t)
    return e;
  const r = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
  return { ...e, required: r };
}
function Bb(e, t, r, n, i, a, s, o) {
  return yt(e, i, r, o, a, s).flatMap((c) => {
    const { oneOf: u, ...f } = c;
    if (t = At(t, f), u === void 0)
      return t;
    const p = u.map((m) => typeof m == "boolean" || !(Te in m) ? [m] : Xc(e, m, r, a, s, o));
    return Jc(p).flatMap((m) => qb(e, t, r, n, m, a, s, o));
  });
}
function qb(e, t, r, n, i, a, s, o) {
  const l = i.filter((c) => {
    if (typeof c == "boolean" || !c || !c.properties)
      return !1;
    const { [n]: u } = c.properties;
    if (u) {
      const f = {
        type: "object",
        properties: {
          [n]: u
        }
      };
      return e.isValid(f, o, r) || a;
    }
    return !1;
  });
  return !a && l.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : l.flatMap((c) => {
    const u = c, [f] = Ma(n, u.properties), p = { ...u, properties: f };
    return yt(e, p, r, o, a, s).map((m) => At(t, m));
  });
}
const Kb = {
  type: "object",
  $id: kf,
  properties: {
    __not_really_there__: {
      type: "number"
    }
  }
};
function ta(e, t, r, n = {}) {
  let i = 0;
  return r && (Qe(r.properties) ? i += Yy(r.properties, (a, s, o) => {
    const l = G(n, o);
    if (typeof s == "boolean")
      return a;
    if (Le(s, Te)) {
      const c = Ge(e, s, t, l);
      return a + ta(e, t, c, l || {});
    }
    if ((Le(s, et) || Le(s, pt)) && l) {
      const c = Le(s, et) ? et : pt, u = Pr(s);
      return a + an(e, t, l, G(s, c), -1, u);
    }
    if (s.type === "object")
      return a + ta(e, t, s, l || {});
    if (s.type === rn(l)) {
      let c = a + 1;
      return s.default ? c += l === s.default ? 1 : -1 : s.const && (c += l === s.const ? 1 : -1), c;
    }
    return a;
  }, 0) : ir(r.type) && r.type === rn(n) && (i += 1)), i;
}
function an(e, t, r, n, i = -1, a) {
  const s = n.map((f) => nn(f, t, [])), o = yc(r, n, a);
  if (ja(o))
    return o;
  const l = s.reduce((f, p, d) => (xa(e, r, [Kb, p], t, a) === 1 && f.push(d), f), []);
  if (l.length === 1)
    return l[0];
  l.length || pc(s.length, (f) => l.push(f));
  const c = /* @__PURE__ */ new Set(), { bestIndex: u } = l.reduce((f, p) => {
    const { bestScore: d } = f, m = s[p], h = ta(e, t, m, r);
    return c.add(h), h > d ? { bestIndex: p, bestScore: h } : f;
  }, { bestIndex: i, bestScore: 0 });
  return c.size === 1 && i >= 0 ? i : u;
}
function ra(e) {
  return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => Se(t));
}
function ni(e, t, r = !1) {
  if (Array.isArray(t)) {
    const n = Array.isArray(e) ? e : [], i = t.map((a, s) => n[s] ? ni(n[s], a, r) : a);
    return r && i.length < n.length && i.push(...n.slice(i.length)), i;
  }
  if (Se(t)) {
    const n = Object.assign({}, e);
    return Object.keys(t).reduce((i, a) => (i[a] = ni(e ? G(e, a) : {}, G(t, a), r), i), n);
  }
  return t;
}
function Mr(e, t, r = !1) {
  return Object.keys(t).reduce((n, i) => {
    const a = e ? e[i] : {}, s = t[i];
    if (e && i in e && Se(s))
      n[i] = Mr(a, s, r);
    else if (r && Array.isArray(a) && Array.isArray(s)) {
      let o = s;
      r === "preventDuplicates" && (o = s.reduce((l, c) => (a.includes(c) || l.push(c), l), [])), n[i] = a.concat(o);
    } else
      n[i] = s;
    return n;
  }, Object.assign({}, e));
}
function zb(e) {
  return Array.isArray(e.enum) && e.enum.length === 1 || Ll in e;
}
function eu(e, t, r = {}) {
  const n = Ge(e, t, r, void 0), i = n.oneOf || n.anyOf;
  return Array.isArray(n.enum) ? !0 : Array.isArray(i) ? i.every((a) => typeof a != "boolean" && zb(a)) : !1;
}
function ts(e, t, r) {
  return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? !1 : eu(e, t.items, r);
}
var Ir;
(function(e) {
  e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
})(Ir || (Ir = {}));
function ji(e, t = Ir.Ignore, r = -1) {
  if (r >= 0) {
    if (Array.isArray(e.items) && r < e.items.length) {
      const n = e.items[r];
      if (typeof n != "boolean")
        return n;
    }
  } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
    return e.items;
  return t !== Ir.Ignore && Se(e.additionalItems) ? e.additionalItems : {};
}
function Wo(e, t, r, n, i, a = [], s = {}) {
  const { emptyObjectFields: o = "populateAllDefaults" } = s;
  if (n)
    e[t] = r;
  else if (o !== "skipDefaults")
    if (Se(r)) {
      const l = i === void 0 ? a.includes(t) : i;
      o === "skipEmptyDefaults" ? xt(r) || (e[t] = r) : (!xt(r) || a.includes(t)) && (l || o !== "populateRequiredDefaults") && (e[t] = r);
    } else
      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
      // Condition 1: computedDefault is not undefined
      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field
      r !== void 0 && (o === "populateAllDefaults" || o === "skipEmptyDefaults" || a.includes(t)) && (e[t] = r);
}
function Rt(e, t, { parentDefaults: r, rawFormData: n, rootSchema: i = {}, includeUndefinedValues: a = !1, _recurseList: s = [], experimental_defaultFormStateBehavior: o = void 0, required: l } = {}) {
  var c, u, f, p;
  const d = Se(n) ? n : {}, m = Se(t) ? t : {};
  let h = r, g = null, y = s;
  if (Se(h) && Se(m.default))
    h = Mr(h, m.default);
  else if (Nf in m)
    h = m.default;
  else if (Te in m) {
    const v = m[Te];
    s.includes(v) || (y = s.concat(v), g = oc(v, i));
  } else if (pi in m)
    g = Zc(e, m, i, !1, [], d)[0];
  else if (ra(m))
    h = m.items.map((v, b) => Rt(e, v, {
      rootSchema: i,
      includeUndefinedValues: a,
      _recurseList: s,
      experimental_defaultFormStateBehavior: o,
      parentDefaults: Array.isArray(r) ? r[b] : void 0,
      rawFormData: d,
      required: l
    }));
  else if (et in m) {
    const { oneOf: v, ...b } = m;
    if (v.length === 0)
      return;
    const w = Pr(m);
    g = v[an(e, i, xt(d) ? void 0 : d, v, 0, w)], g = At(b, g);
  } else if (pt in m) {
    const { anyOf: v, ...b } = m;
    if (v.length === 0)
      return;
    const w = Pr(m);
    g = v[an(e, i, xt(d) ? void 0 : d, v, 0, w)], g = At(b, g);
  }
  if (g)
    return Rt(e, g, {
      rootSchema: i,
      includeUndefinedValues: a,
      _recurseList: y,
      experimental_defaultFormStateBehavior: o,
      parentDefaults: h,
      rawFormData: d,
      required: l
    });
  switch (h === void 0 && (h = m.default), Lt(m)) {
    case "object": {
      const v = (o == null ? void 0 : o.allOf) === "populateDefaults" && fn in m ? Ge(e, m, i, d) : m, b = Object.keys(v.properties || {}).reduce((w, C) => {
        var E;
        const _ = Rt(e, G(v, [Oe, C]), {
          rootSchema: i,
          _recurseList: s,
          experimental_defaultFormStateBehavior: o,
          includeUndefinedValues: a === !0,
          parentDefaults: G(h, [C]),
          rawFormData: G(d, [C]),
          required: (E = v.required) === null || E === void 0 ? void 0 : E.includes(C)
        });
        return Wo(w, C, _, a, l, v.required, o), w;
      }, {});
      if (v.additionalProperties) {
        const w = Se(v.additionalProperties) ? v.additionalProperties : {}, C = /* @__PURE__ */ new Set();
        Se(h) && Object.keys(h).filter((_) => !v.properties || !v.properties[_]).forEach((_) => C.add(_));
        const E = [];
        Object.keys(d).filter((_) => !v.properties || !v.properties[_]).forEach((_) => {
          C.add(_), E.push(_);
        }), C.forEach((_) => {
          var T;
          const F = Rt(e, w, {
            rootSchema: i,
            _recurseList: s,
            experimental_defaultFormStateBehavior: o,
            includeUndefinedValues: a === !0,
            parentDefaults: G(h, [_]),
            rawFormData: G(d, [_]),
            required: (T = v.required) === null || T === void 0 ? void 0 : T.includes(_)
          });
          Wo(b, _, F, a, l, E);
        });
      }
      return b;
    }
    case "array": {
      const v = ((c = o == null ? void 0 : o.arrayMinItems) === null || c === void 0 ? void 0 : c.populate) === "never", b = ((u = o == null ? void 0 : o.arrayMinItems) === null || u === void 0 ? void 0 : u.populate) === "requiredOnly", w = (o == null ? void 0 : o.emptyObjectFields) === "skipEmptyDefaults", C = (p = (f = o == null ? void 0 : o.arrayMinItems) === null || f === void 0 ? void 0 : f.computeSkipPopulate) !== null && p !== void 0 ? p : () => !1, E = w ? void 0 : [];
      if (Array.isArray(h) && (h = h.map((U, W) => {
        const z = ji(m, Ir.Fallback, W);
        return Rt(e, z, {
          rootSchema: i,
          _recurseList: s,
          experimental_defaultFormStateBehavior: o,
          parentDefaults: U,
          required: l
        });
      })), Array.isArray(n)) {
        const U = ji(m);
        v ? h = n : h = n.map((W, z) => Rt(e, U, {
          rootSchema: i,
          _recurseList: s,
          experimental_defaultFormStateBehavior: o,
          rawFormData: W,
          parentDefaults: G(h, [z]),
          required: l
        }));
      }
      if (v)
        return h ?? E;
      if (b && !l)
        return h || void 0;
      const _ = Array.isArray(h) ? h.length : 0;
      if (!m.minItems || ts(e, m, i) || C(e, m, i) || m.minItems <= _)
        return h || E;
      const T = h || [], F = ji(m, Ir.Invert), j = F.default, L = new Array(m.minItems - _).fill(Rt(e, F, {
        parentDefaults: j,
        rootSchema: i,
        _recurseList: s,
        experimental_defaultFormStateBehavior: o,
        required: l
      }));
      return T.concat(L);
    }
  }
  return h;
}
function tu(e, t, r, n, i = !1, a) {
  if (!Se(t))
    throw new Error("Invalid schema: " + t);
  const s = Ge(e, t, n, r), o = Rt(e, s, {
    rootSchema: n,
    includeUndefinedValues: i,
    experimental_defaultFormStateBehavior: a,
    rawFormData: r
  });
  if (r == null || typeof r == "number" && isNaN(r))
    return o;
  const { mergeExtraDefaults: l } = (a == null ? void 0 : a.arrayMinItems) || {};
  return Se(r) || Array.isArray(r) ? ni(o, r, l) : r;
}
function ru(e = {}) {
  return (
    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
    "widget" in oe(e) && oe(e).widget !== "hidden"
  );
}
function nu(e, t, r = {}, n) {
  if (r[Ta] === "files")
    return !0;
  if (t.items) {
    const i = Ge(e, t.items, n);
    return i.type === "string" && i.format === "data-url";
  }
  return !1;
}
function Wb(e, t, r = {}, n, i) {
  const a = oe(r, i), { label: s = !0 } = a;
  let o = !!s;
  const l = Lt(t);
  return l === "array" && (o = ts(e, t, n) || nu(e, t, r, n) || ru(r)), l === "object" && (o = !1), l === "boolean" && !r[Ta] && (o = !1), r[Mf] && (o = !1), o;
}
function Gb(e, t, r) {
  if (!r)
    return t;
  const { errors: n, errorSchema: i } = t;
  let a = e.toErrorList(r), s = r;
  return xt(i) || (s = Mr(i, r, !0), a = [...n].concat(a)), { errorSchema: s, errors: a };
}
const pr = Symbol("no Value");
function na(e, t, r, n, i = {}) {
  let a;
  if (Le(r, Oe)) {
    const s = {};
    if (Le(n, Oe)) {
      const c = G(n, Oe, {});
      Object.keys(c).forEach((u) => {
        Le(i, u) && (s[u] = void 0);
      });
    }
    const o = Object.keys(G(r, Oe, {})), l = {};
    o.forEach((c) => {
      const u = G(i, c);
      let f = G(n, [Oe, c], {}), p = G(r, [Oe, c], {});
      Le(f, Te) && (f = Ge(e, f, t, u)), Le(p, Te) && (p = Ge(e, p, t, u));
      const d = G(f, "type"), m = G(p, "type");
      if (!d || d === m)
        if (Le(s, c) && delete s[c], m === "object" || m === "array" && Array.isArray(u)) {
          const h = na(e, t, p, f, u);
          (h !== void 0 || m === "array") && (l[c] = h);
        } else {
          const h = G(p, "default", pr), g = G(f, "default", pr);
          h !== pr && h !== u && (g === u ? s[c] = h : G(p, "readOnly") === !0 && (s[c] = void 0));
          const y = G(p, "const", pr), v = G(f, "const", pr);
          y !== pr && y !== u && (s[c] = v === u ? y : void 0);
        }
    }), a = {
      ...typeof i == "string" || Array.isArray(i) ? void 0 : i,
      ...s,
      ...l
    };
  } else if (G(n, "type") === "array" && G(r, "type") === "array" && Array.isArray(i)) {
    let s = G(n, "items"), o = G(r, "items");
    if (typeof s == "object" && typeof o == "object" && !Array.isArray(s) && !Array.isArray(o)) {
      Le(s, Te) && (s = Ge(e, s, t, i)), Le(o, Te) && (o = Ge(e, o, t, i));
      const l = G(s, "type"), c = G(o, "type");
      if (!l || l === c) {
        const u = G(r, "maxItems", -1);
        c === "object" ? a = i.reduce((f, p) => {
          const d = na(e, t, o, s, p);
          return d !== void 0 && (u < 0 || f.length < u) && f.push(d), f;
        }, []) : a = u > 0 && i.length > u ? i.slice(0, u) : i;
      }
    } else
      typeof s == "boolean" && typeof o == "boolean" && s === o && (a = i);
  }
  return a;
}
function Kn(e, t, r, n, i, a, s, o = []) {
  if (Te in t || pi in t || fn in t) {
    const u = Ge(e, t, a, s);
    if (o.findIndex((p) => sr(p, u)) === -1)
      return Kn(e, u, r, n, i, a, s, o.concat(u));
  }
  if (Ut in t && !G(t, [Ut, Te]))
    return Kn(e, G(t, Ut), r, n, i, a, s, o);
  const c = { $id: i || r };
  if (Lt(t) === "object" && Oe in t)
    for (const u in t.properties) {
      const f = G(t, [Oe, u]), p = c[Mt] + n + u;
      c[u] = Kn(
        e,
        Se(f) ? f : {},
        r,
        n,
        p,
        a,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        G(s, [u]),
        o
      );
    }
  return c;
}
function Hb(e, t, r, n, i, a = "root", s = "_") {
  return Kn(e, t, a, s, r, n, i);
}
function Zt(e, t, r, n, i, a = []) {
  if (Te in t || pi in t || fn in t) {
    const o = Ge(e, t, n, i);
    if (a.findIndex((c) => sr(c, o)) === -1)
      return Zt(e, o, r, n, i, a.concat(o));
  }
  let s = {
    [Bn]: r.replace(/^\./, "")
  };
  if (et in t || pt in t) {
    const o = et in t ? t.oneOf : t.anyOf, l = Pr(t), c = an(e, n, i, o, 0, l), u = o[c];
    s = {
      ...s,
      ...Zt(e, u, r, n, i, a)
    };
  }
  if (Ji in t && t[Ji] !== !1 && je(s, Ia, !0), Ut in t && Array.isArray(i)) {
    const { items: o, additionalItems: l } = t;
    Array.isArray(o) ? i.forEach((c, u) => {
      o[u] ? s[u] = Zt(e, o[u], `${r}.${u}`, n, c, a) : l ? s[u] = Zt(e, l, `${r}.${u}`, n, c, a) : console.warn(`Unable to generate path schema for "${r}.${u}". No schema defined for it`);
    }) : i.forEach((c, u) => {
      s[u] = Zt(e, o, `${r}.${u}`, n, c, a);
    });
  } else if (Oe in t)
    for (const o in t.properties) {
      const l = G(t, [Oe, o]);
      s[o] = Zt(
        e,
        l,
        `${r}.${o}`,
        n,
        // It's possible that formData is not an object -- this can happen if an
        // array item has just been added, but not populated with data yet
        G(i, [o]),
        a
      );
    }
  return s;
}
function Yb(e, t, r = "", n, i) {
  return Zt(e, t, r, n, i);
}
class Jb {
  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
   * @param rootSchema - The root schema that will be forwarded to all the APIs
   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
   */
  constructor(t, r, n) {
    this.rootSchema = r, this.validator = t, this.experimental_defaultFormStateBehavior = n;
  }
  /** Returns the `ValidatorType` in the `SchemaUtilsType`
   *
   * @returns - The `ValidatorType`
   */
  getValidator() {
    return this.validator;
  }
  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
   * of a new `SchemaUtilsType` with incomplete properties.
   *
   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
   * @param rootSchema - The root schema that will be compared against the current one
   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
   */
  doesSchemaUtilsDiffer(t, r, n = {}) {
    return !t || !r ? !1 : this.validator !== t || !Be(this.rootSchema, r) || !Be(this.experimental_defaultFormStateBehavior, n);
  }
  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
   * computed to have defaults provided in the `schema`.
   *
   * @param schema - The schema for which the default state is desired
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
   *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
   *          object properties.
   * @returns - The resulting `formData` with all the defaults provided
   */
  getDefaultFormState(t, r, n = !1) {
    return tu(this.validator, t, r, this.rootSchema, n, this.experimental_defaultFormStateBehavior);
  }
  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
   * should be displayed in a UI.
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [uiSchema] - The UI schema from which to derive potentially displayable information
   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
   * @returns - True if the label should be displayed or false if it should not
   */
  getDisplayLabel(t, r, n) {
    return Wb(this.validator, t, r, this.rootSchema, n);
  }
  /** Determines which of the given `options` provided most closely matches the `formData`.
   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
   *
   * The closest match is determined using the number of matching properties, and more heavily favors options with
   * matching readOnly, default, or const values.
   *
   * @param formData - The form data associated with the schema
   * @param options - The list of options that can be selected from
   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
   */
  getClosestMatchingOption(t, r, n, i) {
    return an(this.validator, this.rootSchema, t, r, n, i);
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
   * Always returns the first option if there is nothing that matches.
   *
   * @param formData - The current formData, if any, used to figure out a match
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The firstindex of the matched option or 0 if none is available
   */
  getFirstMatchingOption(t, r, n) {
    return xa(this.validator, t, r, this.rootSchema, n);
  }
  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.
   * Deprecated, use `getFirstMatchingOption()` instead.
   *
   * @param formData - The current formData, if any, onto which to provide any missing defaults
   * @param options - The list of options to find a matching options from
   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
   *          determine which option is selected
   * @returns - The index of the matched option or 0 if none is available
   * @deprecated
   */
  getMatchingOption(t, r, n) {
    return gc(this.validator, t, r, this.rootSchema, n);
  }
  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
   *
   * @param schema - The schema for which check for array of files flag is desired
   * @param [uiSchema] - The UI schema from which to check the widget
   * @returns - True if schema/uiSchema contains an array of files, otherwise false
   */
  isFilesArray(t, r) {
    return nu(this.validator, t, r, this.rootSchema);
  }
  /** Checks to see if the `schema` combination represents a multi-select
   *
   * @param schema - The schema for which check for a multi-select flag is desired
   * @returns - True if schema contains a multi-select, otherwise false
   */
  isMultiSelect(t) {
    return ts(this.validator, t, this.rootSchema);
  }
  /** Checks to see if the `schema` combination represents a select
   *
   * @param schema - The schema for which check for a select flag is desired
   * @returns - True if schema contains a select, otherwise false
   */
  isSelect(t) {
    return eu(this.validator, t, this.rootSchema);
  }
  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in
   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling
   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,
   * then `validationData` is returned.
   *
   * @param validationData - The current `ValidationData` into which to merge the additional errors
   * @param [additionalErrorSchema] - The additional set of errors
   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.
   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be
   *        removed in the next major release.
   */
  mergeValidationData(t, r) {
    return Gb(this.validator, t, r);
  }
  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
   * recursive resolution.
   *
   * @param schema - The schema for which retrieving a schema is desired
   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
   * @returns - The schema having its conditions, additional properties, references and dependencies resolved
   */
  retrieveSchema(t, r) {
    return Ge(this.validator, t, this.rootSchema, r);
  }
  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
   * old schemas that are non-existent in the new schema are set to `undefined`.
   *
   * @param [newSchema] - The new schema for which the data is being sanitized
   * @param [oldSchema] - The old schema from which the data originated
   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
   * @returns - The new form data, with all the fields uniquely associated with the old schema set
   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
   */
  sanitizeDataForNewSchema(t, r, n) {
    return na(this.validator, this.rootSchema, t, r, n);
  }
  /** Generates an `IdSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [id] - The base id for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @param [idPrefix='root'] - The prefix to use for the id
   * @param [idSeparator='_'] - The separator to use for the path segments in the id
   * @returns - The `IdSchema` object for the `schema`
   */
  toIdSchema(t, r, n, i = "root", a = "_") {
    return Hb(this.validator, t, r, this.rootSchema, n, i, a);
  }
  /** Generates an `PathSchema` object for the `schema`, recursively
   *
   * @param schema - The schema for which the display label flag is desired
   * @param [name] - The base name for the schema
   * @param [formData] - The current formData, if any, onto which to provide any missing defaults
   * @returns - The `PathSchema` object for the `schema`
   */
  toPathSchema(t, r, n) {
    return Yb(this.validator, t, r, this.rootSchema, n);
  }
}
function Xb(e, t, r = {}) {
  return new Jb(e, t, r);
}
function Zb(e) {
  var t;
  if (e.indexOf("data:") === -1)
    throw new Error("File is invalid: URI must be a dataURI");
  const n = e.slice(5).split(";base64,");
  if (n.length !== 2)
    throw new Error("File is invalid: dataURI must be base64");
  const [i, a] = n, [s, ...o] = i.split(";"), l = s || "", c = decodeURI(
    // parse the parameters into key-value pairs, find a key, and extract a value
    // if no key is found, then the name is unknown
    ((t = o.map((u) => u.split("=")).find(([u]) => u === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
  );
  try {
    const u = atob(a), f = new Array(u.length);
    for (let d = 0; d < u.length; d++)
      f[d] = u.charCodeAt(d);
    return { blob: new window.Blob([new Uint8Array(f)], { type: l }), name: c };
  } catch (u) {
    throw new Error("File is invalid: " + u.message);
  }
}
function Qb(e, t) {
  let r = e;
  if (Array.isArray(t)) {
    const n = r.split(/(%\d)/);
    t.forEach((i, a) => {
      const s = n.findIndex((o) => o === `%${a + 1}`);
      s >= 0 && (n[s] = i);
    }), r = n.join("");
  }
  return r;
}
function e1(e, t) {
  return Qb(e, t);
}
function Ne(e, t = [], r) {
  if (Array.isArray(e))
    return e.map((a) => Ne(a, t)).filter((a) => a !== r);
  const n = e === "" || e === null ? -1 : Number(e), i = t[n];
  return i ? i.value : r;
}
function t1(e, t, r = []) {
  const n = Ne(e, r);
  return Array.isArray(t) ? t.filter((i) => !sr(i, n)) : sr(n, t) ? void 0 : t;
}
function rs(e, t) {
  return Array.isArray(t) ? t.some((r) => sr(r, e)) : sr(t, e);
}
function bi(e, t = [], r = !1) {
  const n = t.map((i, a) => rs(i.value, e) ? String(a) : void 0).filter((i) => typeof i < "u");
  return r ? n : n[0];
}
function r1(e) {
  return e == null;
}
var n1 = r1;
const i1 = /* @__PURE__ */ we(n1);
function a1(e, t, r = []) {
  const n = Ne(e, r);
  if (!i1(n)) {
    const i = r.findIndex((o) => n === o.value), a = r.map(({ value: o }) => o);
    return t.slice(0, i).concat(n, t.slice(i)).sort((o, l) => +(a.indexOf(o) > a.indexOf(l)));
  }
  return t;
}
class s1 {
  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   */
  constructor(t) {
    this.errorSchema = {}, this.resetAllErrors(t);
  }
  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
   */
  get ErrorSchema() {
    return this.errorSchema;
  }
  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The error block for the given `pathOfError` or the root if not provided
   * @private
   */
  getOrCreateErrorBlock(t) {
    let n = Array.isArray(t) && t.length > 0 || typeof t == "string" ? G(this.errorSchema, t) : this.errorSchema;
    return !n && t && (n = {}, je(this.errorSchema, t, n)), n;
  }
  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
   *
   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  resetAllErrors(t) {
    return this.errorSchema = t ? kl(t) : {}, this;
  }
  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
   * the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  addErrors(t, r) {
    const n = this.getOrCreateErrorBlock(r);
    let i = G(n, ot);
    return Array.isArray(i) || (i = [], n[ot] = i), Array.isArray(t) ? i.push(...t) : i.push(t), this;
  }
  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
   * within the schema described by the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  setErrors(t, r) {
    const n = this.getOrCreateErrorBlock(r), i = Array.isArray(t) ? [...t] : [t];
    return je(n, ot, i), this;
  }
  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
   * the `pathOfError`. For more information about how to specify the path see the
   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
   *
   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
   * @returns - The `ErrorSchemaBuilder` object for chaining purposes
   */
  clearErrors(t) {
    const r = this.getOrCreateErrorBlock(t);
    return je(r, ot, []), this;
  }
}
function iu(e, t, r = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], n = "YMD") {
  const { day: i, month: a, year: s, hour: o, minute: l, second: c } = e, u = { type: "day", range: [1, 31], value: i }, f = { type: "month", range: [1, 12], value: a }, p = { type: "year", range: r, value: s }, d = [];
  switch (n) {
    case "MDY":
      d.push(f, u, p);
      break;
    case "DMY":
      d.push(u, f, p);
      break;
    case "YMD":
    default:
      d.push(p, f, u);
  }
  return t && d.push({ type: "hour", range: [0, 23], value: o }, { type: "minute", range: [0, 59], value: l }, { type: "second", range: [0, 59], value: c }), d;
}
function au(e) {
  const t = {};
  return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
}
function su(e, t, r = {}, n = !0) {
  const i = {
    type: t || "text",
    ...au(e)
  };
  return r.inputType ? i.type = r.inputType : t || (e.type === "number" ? (i.type = "number", n && i.step === void 0 && (i.step = "any")) : e.type === "integer" && (i.type = "number", i.step === void 0 && (i.step = 1))), r.autocomplete && (i.autoComplete = r.autocomplete), i;
}
const Go = {
  props: {
    disabled: !1
  },
  submitText: "Submit",
  norender: !1
};
function ou(e = {}) {
  const t = oe(e);
  if (t && t[Zn]) {
    const r = t[Zn];
    return { ...Go, ...r };
  }
  return Go;
}
function ce(e, t, r = {}) {
  const { templates: n } = t;
  return e === "ButtonTemplates" ? n[e] : (
    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
    // To avoid that, we cast uiOptions to `any` before accessing the name field
    r[e] || n[e]
  );
}
const Ui = {
  boolean: {
    checkbox: "CheckboxWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    hidden: "HiddenWidget"
  },
  string: {
    text: "TextWidget",
    password: "PasswordWidget",
    email: "EmailWidget",
    hostname: "TextWidget",
    ipv4: "TextWidget",
    ipv6: "TextWidget",
    uri: "URLWidget",
    "data-url": "FileWidget",
    radio: "RadioWidget",
    select: "SelectWidget",
    textarea: "TextareaWidget",
    hidden: "HiddenWidget",
    date: "DateWidget",
    datetime: "DateTimeWidget",
    "date-time": "DateTimeWidget",
    "alt-date": "AltDateWidget",
    "alt-datetime": "AltDateTimeWidget",
    time: "TimeWidget",
    color: "ColorWidget",
    file: "FileWidget"
  },
  number: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  integer: {
    text: "TextWidget",
    select: "SelectWidget",
    updown: "UpDownWidget",
    range: "RangeWidget",
    radio: "RadioWidget",
    hidden: "HiddenWidget"
  },
  array: {
    select: "SelectWidget",
    checkboxes: "CheckboxesWidget",
    files: "FileWidget",
    hidden: "HiddenWidget"
  }
};
function o1(e) {
  let t = G(e, "MergedWidget");
  if (!t) {
    const r = e.defaultProps && e.defaultProps.options || {};
    t = ({ options: n, ...i }) => O(e, { options: { ...r, ...n }, ...i }), je(e, "MergedWidget", t);
  }
  return t;
}
function Et(e, t, r = {}) {
  const n = Lt(e);
  if (typeof t == "function" || t && oo.isForwardRef(Zd(t)) || oo.isMemo(t))
    return o1(t);
  if (typeof t != "string")
    throw new Error(`Unsupported widget definition: ${typeof t}`);
  if (t in r) {
    const i = r[t];
    return Et(e, i, r);
  }
  if (typeof n == "string") {
    if (!(n in Ui))
      throw new Error(`No widget for type '${n}'`);
    if (t in Ui[n]) {
      const i = r[Ui[n][t]];
      return Et(e, i, r);
    }
  }
  throw new Error(`No widget '${t}' for type '${n}'`);
}
function l1(e) {
  let t = 0;
  for (let r = 0; r < e.length; r += 1) {
    const n = e.charCodeAt(r);
    t = (t << 5) - t + n, t = t & t;
  }
  return t.toString(16);
}
function c1(e) {
  const t = /* @__PURE__ */ new Set();
  return JSON.stringify(e, (r, n) => (t.add(r), n)), l1(JSON.stringify(e, Array.from(t).sort()));
}
function u1(e, t, r = {}) {
  try {
    return Et(e, t, r), !0;
  } catch (n) {
    const i = n;
    if (i.message && (i.message.startsWith("No widget") || i.message.startsWith("Unsupported widget")))
      return !1;
    throw n;
  }
}
function gn(e, t) {
  return `${ir(e) ? e : e[Mt]}__${t}`;
}
function jr(e) {
  return gn(e, "description");
}
function ns(e) {
  return gn(e, "error");
}
function Sr(e) {
  return gn(e, "examples");
}
function lu(e) {
  return gn(e, "help");
}
function is(e) {
  return gn(e, "title");
}
function De(e, t = !1) {
  const r = t ? ` ${Sr(e)}` : "";
  return `${ns(e)} ${jr(e)} ${lu(e)}${r}`;
}
function Si(e, t) {
  return `${e}-${t}`;
}
function cu(e, t, r) {
  return t ? r : e;
}
function d1(e) {
  return e ? new Date(e).toJSON() : void 0;
}
function f1(e) {
  if (Df in e && Array.isArray(e.enum) && e.enum.length === 1)
    return e.enum[0];
  if (Ll in e)
    return e.const;
  throw new Error("schema cannot be inferred as a constant");
}
function ii(e) {
  const t = e;
  if (t.enumNames && process.env.NODE_ENV !== "production" && console.warn("The enumNames property is deprecated and may be removed in a future major release."), e.enum)
    return e.enum.map((n, i) => ({ label: t.enumNames && t.enumNames[i] || String(n), value: n }));
  const r = e.oneOf || e.anyOf;
  return r && r.map((n) => {
    const i = n, a = f1(i), s = i.title || String(a);
    return {
      schema: i,
      label: s,
      value: a
    };
  });
}
function h1(e, t) {
  if (!Array.isArray(t))
    return e;
  const r = (u) => u.reduce((f, p) => (f[p] = !0, f), {}), n = (u) => u.length > 1 ? `properties '${u.join("', '")}'` : `property '${u[0]}'`, i = r(e), a = t.filter((u) => u === "*" || i[u]), s = r(a), o = e.filter((u) => !s[u]), l = a.indexOf("*");
  if (l === -1) {
    if (o.length)
      throw new Error(`uiSchema order list does not contain ${n(o)}`);
    return a;
  }
  if (l !== a.lastIndexOf("*"))
    throw new Error("uiSchema order list contains more than one wildcard item");
  const c = [...a];
  return c.splice(l, 1, ...o), c;
}
function St(e, t) {
  let r = String(e);
  for (; r.length < t; )
    r = "0" + r;
  return r;
}
function wr(e, t = !0) {
  if (!e)
    return {
      year: -1,
      month: -1,
      day: -1,
      hour: t ? -1 : 0,
      minute: t ? -1 : 0,
      second: t ? -1 : 0
    };
  const r = new Date(e);
  if (Number.isNaN(r.getTime()))
    throw new Error("Unable to parse date " + e);
  return {
    year: r.getUTCFullYear(),
    month: r.getUTCMonth() + 1,
    day: r.getUTCDate(),
    hour: t ? r.getUTCHours() : 0,
    minute: t ? r.getUTCMinutes() : 0,
    second: t ? r.getUTCSeconds() : 0
  };
}
function zn(e) {
  if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === !0)
    return !0;
  if (e.anyOf && e.anyOf.length === 1)
    return zn(e.anyOf[0]);
  if (e.oneOf && e.oneOf.length === 1)
    return zn(e.oneOf[0]);
  if (e.allOf) {
    const t = (r) => zn(r);
    return e.allOf.some(t);
  }
  return !1;
}
function m1(e, t, r) {
  const { props: n, state: i } = e;
  return !Be(n, t) || !Be(i, r);
}
function ai(e, t = !0) {
  const { year: r, month: n, day: i, hour: a = 0, minute: s = 0, second: o = 0 } = e, l = Date.UTC(r, n - 1, i, a, s, o), c = new Date(l).toJSON();
  return t ? c : c.slice(0, 10);
}
function sn(e, t = []) {
  if (!e)
    return [];
  let r = [];
  return ot in e && (r = r.concat(e[ot].map((n) => {
    const i = `.${t.join(".")}`;
    return {
      property: i,
      message: n,
      stack: `${i} ${n}`
    };
  }))), Object.keys(e).reduce((n, i) => {
    if (i !== ot) {
      const a = e[i];
      Na(a) && (n = n.concat(sn(a, [...t, i])));
    }
    return n;
  }, r);
}
var p1 = Pt, y1 = ba, g1 = We, v1 = dn, $1 = Wl, _1 = ur, b1 = Hl;
function S1(e) {
  return g1(e) ? p1(e, _1) : v1(e) ? [e] : y1($1(b1(e)));
}
var w1 = S1;
const uu = /* @__PURE__ */ we(w1);
function E1(e) {
  const t = new s1();
  return e.length && e.forEach((r) => {
    const { property: n, message: i } = r, a = n === "." ? [] : uu(n);
    a.length > 0 && a[0] === "" && a.splice(0, 1), i && t.addErrors(i, a);
  }), t.ErrorSchema;
}
function du(e) {
  return Object.keys(e).reduce((t, r) => {
    if (r === "addError")
      return t;
    {
      const n = e[r];
      return Na(n) ? {
        ...t,
        [r]: du(n)
      } : { ...t, [r]: n };
    }
  }, {});
}
function O1(e) {
  if (!e)
    return "";
  const t = new Date(e), r = St(t.getFullYear(), 4), n = St(t.getMonth() + 1, 2), i = St(t.getDate(), 2), a = St(t.getHours(), 2), s = St(t.getMinutes(), 2), o = St(t.getSeconds(), 2), l = St(t.getMilliseconds(), 3);
  return `${r}-${n}-${i}T${a}:${s}:${o}.${l}`;
}
function Wn(e, t) {
  if (!t)
    return e;
  const { errors: r, errorSchema: n } = e;
  let i = sn(t), a = t;
  return xt(n) || (a = Mr(n, t, !0), i = [...r].concat(i)), { errorSchema: a, errors: i };
}
function C1(e) {
  for (const t in e) {
    const r = e, n = r[t];
    t === Te && typeof n == "string" && n.startsWith("#") ? r[t] = Bl + n : r[t] = as(n);
  }
  return e;
}
function A1(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = as(e[t]);
  return e;
}
function as(e) {
  return Array.isArray(e) ? A1([...e]) : Qe(e) ? C1({ ...e }) : e;
}
var le;
(function(e) {
  e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: <em>%2</em>.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field <code>%1</code>.", e.UnsupportedFieldWithReason = "Unsupported field schema: <em>%1</em>.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field <code>%1</code>: <em>%2</em>.", e.FilesInfo = "**%1** (%2, %3 bytes)";
})(le || (le = {}));
var P1 = hn, I1 = vc, T1 = kr;
function N1(e, t, r) {
  for (var n = -1, i = t.length, a = {}; ++n < i; ) {
    var s = t[n], o = P1(e, s);
    r(o, s) && I1(a, T1(s, e), o);
  }
  return a;
}
var D1 = N1, F1 = D1, k1 = hc;
function R1(e, t) {
  return F1(e, t, function(r, n) {
    return k1(e, n);
  });
}
var M1 = R1, j1 = M1, U1 = ac, V1 = U1(function(e, t) {
  return e == null ? {} : j1(e, t);
}), x1 = V1;
const L1 = /* @__PURE__ */ we(x1);
let B1 = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, r) => (r &= 63, r < 36 ? t += r.toString(36) : r < 62 ? t += (r - 26).toString(36).toUpperCase() : r > 62 ? t += "-" : t += "_", t), "");
function ia() {
  return B1();
}
function Ho(e) {
  return Array.isArray(e) ? e.map((t) => ({
    key: ia(),
    item: t
  })) : [];
}
function Wr(e) {
  return Array.isArray(e) ? e.map((t) => t.item) : [];
}
class q1 extends ln {
  /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(t) {
    super(t), this._getNewFormDataRow = () => {
      const { schema: i, registry: a } = this.props, { schemaUtils: s } = a;
      let o = i.items;
      return ra(i) && Tf(i) && (o = i.additionalItems), s.getDefaultFormState(o);
    }, this.onAddClick = (i) => {
      this._handleAddClick(i);
    }, this.onAddIndexClick = (i) => (a) => {
      this._handleAddClick(a, i);
    }, this.onCopyIndexClick = (i) => (a) => {
      a && a.preventDefault();
      const { onChange: s, errorSchema: o } = this.props, { keyedFormData: l } = this.state;
      let c;
      if (o) {
        c = {};
        for (const p in o) {
          const d = parseInt(p);
          d <= i ? je(c, [d], o[p]) : d > i && je(c, [d + 1], o[p]);
        }
      }
      const u = {
        key: ia(),
        item: kl(l[i].item)
      }, f = [...l];
      i !== void 0 ? f.splice(i + 1, 0, u) : f.push(u), this.setState({
        keyedFormData: f,
        updatedKeyedFormData: !0
      }, () => s(Wr(f), c));
    }, this.onDropIndexClick = (i) => (a) => {
      a && a.preventDefault();
      const { onChange: s, errorSchema: o } = this.props, { keyedFormData: l } = this.state;
      let c;
      if (o) {
        c = {};
        for (const f in o) {
          const p = parseInt(f);
          p < i ? je(c, [p], o[f]) : p > i && je(c, [p - 1], o[f]);
        }
      }
      const u = l.filter((f, p) => p !== i);
      this.setState({
        keyedFormData: u,
        updatedKeyedFormData: !0
      }, () => s(Wr(u), c));
    }, this.onReorderClick = (i, a) => (s) => {
      s && (s.preventDefault(), s.currentTarget.blur());
      const { onChange: o, errorSchema: l } = this.props;
      let c;
      if (l) {
        c = {};
        for (const d in l) {
          const m = parseInt(d);
          m == i ? je(c, [a], l[i]) : m == a ? je(c, [i], l[a]) : je(c, [d], l[m]);
        }
      }
      const { keyedFormData: u } = this.state;
      function f() {
        const d = u.slice();
        return d.splice(i, 1), d.splice(a, 0, u[i]), d;
      }
      const p = f();
      this.setState({
        keyedFormData: p
      }, () => o(Wr(p), c));
    }, this.onChangeForIndex = (i) => (a, s, o) => {
      const { formData: l, onChange: c, errorSchema: u } = this.props, p = (Array.isArray(l) ? l : []).map((d, m) => i === m ? typeof a > "u" ? null : a : d);
      c(p, u && u && {
        ...u,
        [i]: s
      }, o);
    }, this.onSelectChange = (i) => {
      const { onChange: a, idSchema: s } = this.props;
      a(i, void 0, s && s.$id);
    };
    const { formData: r = [] } = t, n = Ho(r);
    this.state = {
      keyedFormData: n,
      updatedKeyedFormData: !1
    };
  }
  /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It
   * regenerates the keyed form data and returns it
   *
   * @param nextProps - The next set of props data
   * @param prevState - The previous set of state data
   */
  static getDerivedStateFromProps(t, r) {
    if (r.updatedKeyedFormData)
      return {
        updatedKeyedFormData: !1
      };
    const n = Array.isArray(t.formData) ? t.formData : [], i = r.keyedFormData || [];
    return {
      keyedFormData: n.length === i.length ? i.map((s, o) => ({
        key: s.key,
        item: n[o]
      })) : Ho(n)
    };
  }
  /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to
   * the description from the schema.items, and finally the string "Item"
   */
  get itemTitle() {
    const { schema: t, registry: r } = this.props, { translateString: n } = r;
    return G(t, [Ut, "title"], G(t, [Ut, "description"], n(le.ArrayItemTitle)));
  }
  /** Determines whether the item described in the schema is always required, which is determined by whether any item
   * may be null.
   *
   * @param itemSchema - The schema for the item
   * @return - True if the item schema type does not contain the "null" type
   */
  isItemRequired(t) {
    return Array.isArray(t.type) ? !t.type.includes("null") : t.type !== "null";
  }
  /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding
   * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the
   * `formData` matches that value, then false is returned, otherwise true is returned.
   *
   * @param formItems - The list of items in the form
   * @returns - True if the item is addable otherwise false
   */
  canAddItem(t) {
    const { schema: r, uiSchema: n, registry: i } = this.props;
    let { addable: a } = oe(n, i.globalUiOptions);
    return a !== !1 && (r.maxItems !== void 0 ? a = t.length < r.maxItems : a = !0), a;
  }
  /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data
   * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into
   * the state, and then returning `onChange()` with the plain form data converted from the keyed data
   *
   * @param event - The event for the click
   * @param [index] - The optional index at which to add the new data
   */
  _handleAddClick(t, r) {
    t && t.preventDefault();
    const { onChange: n, errorSchema: i } = this.props, { keyedFormData: a } = this.state;
    let s;
    if (i) {
      s = {};
      for (const c in i) {
        const u = parseInt(c);
        r === void 0 || u < r ? je(s, [u], i[c]) : u >= r && je(s, [u + 1], i[c]);
      }
    }
    const o = {
      key: ia(),
      item: this._getNewFormDataRow()
    }, l = [...a];
    r !== void 0 ? l.splice(r, 0, o) : l.push(o), this.setState({
      keyedFormData: l,
      updatedKeyedFormData: !0
    }, () => n(Wr(l), s));
  }
  /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements
   */
  render() {
    const { schema: t, uiSchema: r, idSchema: n, registry: i } = this.props, { schemaUtils: a, translateString: s } = i;
    if (!(Ut in t)) {
      const o = oe(r), l = ce("UnsupportedFieldTemplate", i, o);
      return O(l, { schema: t, idSchema: n, reason: s(le.MissingItems), registry: i });
    }
    return a.isMultiSelect(t) ? this.renderMultiSelect() : ru(r) ? this.renderCustomWidget() : ra(t) ? this.renderFixedArray() : a.isFilesArray(t, r) ? this.renderFiles() : this.renderNormalArray();
  }
  /** Renders a normal array without any limitations of length
   */
  renderNormalArray() {
    const { schema: t, uiSchema: r = {}, errorSchema: n, idSchema: i, name: a, title: s, disabled: o = !1, readonly: l = !1, autofocus: c = !1, required: u = !1, registry: f, onBlur: p, onFocus: d, idPrefix: m, idSeparator: h = "_", rawErrors: g } = this.props, { keyedFormData: y } = this.state, v = t.title || s || a, { schemaUtils: b, formContext: w } = f, C = oe(r), E = Qe(t.items) ? t.items : {}, _ = b.retrieveSchema(E), T = Wr(this.state.keyedFormData), F = this.canAddItem(T), j = {
      canAdd: F,
      items: y.map((U, W) => {
        const { key: z, item: q } = U, ue = q, me = b.retrieveSchema(E, ue), ie = n ? n[W] : void 0, Y = i.$id + h + W, V = b.toIdSchema(me, Y, ue, m, h);
        return this.renderArrayFieldItem({
          key: z,
          index: W,
          name: a && `${a}-${W}`,
          title: v ? `${v}-${W + 1}` : void 0,
          canAdd: F,
          canMoveUp: W > 0,
          canMoveDown: W < T.length - 1,
          itemSchema: me,
          itemIdSchema: V,
          itemErrorSchema: ie,
          itemData: ue,
          itemUiSchema: r.items,
          autofocus: c && W === 0,
          onBlur: p,
          onFocus: d,
          rawErrors: g,
          totalItems: y.length
        });
      }),
      className: `field field-array field-array-of-${_.type}`,
      disabled: o,
      idSchema: i,
      uiSchema: r,
      onAddClick: this.onAddClick,
      readonly: l,
      required: u,
      schema: t,
      title: v,
      formContext: w,
      formData: T,
      rawErrors: g,
      registry: f
    }, L = ce("ArrayFieldTemplate", f, C);
    return O(L, { ...j });
  }
  /** Renders an array using the custom widget provided by the user in the `uiSchema`
   */
  renderCustomWidget() {
    var t;
    const { schema: r, idSchema: n, uiSchema: i, disabled: a = !1, readonly: s = !1, autofocus: o = !1, required: l = !1, hideError: c, placeholder: u, onBlur: f, onFocus: p, formData: d = [], registry: m, rawErrors: h, name: g } = this.props, { widgets: y, formContext: v, globalUiOptions: b, schemaUtils: w } = m, { widget: C, title: E, ..._ } = oe(i, b), T = Et(r, C, y), F = (t = E ?? r.title) !== null && t !== void 0 ? t : g, j = w.getDisplayLabel(r, i, b);
    return O(T, { id: n.$id, name: g, multiple: !0, onChange: this.onSelectChange, onBlur: f, onFocus: p, options: _, schema: r, uiSchema: i, registry: m, value: d, disabled: a, readonly: s, hideError: c, required: l, label: F, hideLabel: !j, placeholder: u, formContext: v, autofocus: o, rawErrors: h });
  }
  /** Renders an array as a set of checkboxes
   */
  renderMultiSelect() {
    var t;
    const { schema: r, idSchema: n, uiSchema: i, formData: a = [], disabled: s = !1, readonly: o = !1, autofocus: l = !1, required: c = !1, placeholder: u, onBlur: f, onFocus: p, registry: d, rawErrors: m, name: h } = this.props, { widgets: g, schemaUtils: y, formContext: v, globalUiOptions: b } = d, w = y.retrieveSchema(r.items, a), C = ii(w), { widget: E = "select", title: _, ...T } = oe(i, b), F = Et(r, E, g), j = (t = _ ?? r.title) !== null && t !== void 0 ? t : h, L = y.getDisplayLabel(r, i, b);
    return O(F, { id: n.$id, name: h, multiple: !0, onChange: this.onSelectChange, onBlur: f, onFocus: p, options: { ...T, enumOptions: C }, schema: r, uiSchema: i, registry: d, value: a, disabled: s, readonly: o, required: c, label: j, hideLabel: !L, placeholder: u, formContext: v, autofocus: l, rawErrors: m });
  }
  /** Renders an array of files using the `FileWidget`
   */
  renderFiles() {
    var t;
    const { schema: r, uiSchema: n, idSchema: i, name: a, disabled: s = !1, readonly: o = !1, autofocus: l = !1, required: c = !1, onBlur: u, onFocus: f, registry: p, formData: d = [], rawErrors: m } = this.props, { widgets: h, formContext: g, globalUiOptions: y, schemaUtils: v } = p, { widget: b = "files", title: w, ...C } = oe(n, y), E = Et(r, b, h), _ = (t = w ?? r.title) !== null && t !== void 0 ? t : a, T = v.getDisplayLabel(r, n, y);
    return O(E, { options: C, id: i.$id, name: a, multiple: !0, onChange: this.onSelectChange, onBlur: u, onFocus: f, schema: r, uiSchema: n, value: d, disabled: s, readonly: o, required: c, registry: p, formContext: g, autofocus: l, rawErrors: m, label: _, hideLabel: !T });
  }
  /** Renders an array that has a maximum limit of items
   */
  renderFixedArray() {
    const { schema: t, uiSchema: r = {}, formData: n = [], errorSchema: i, idPrefix: a, idSeparator: s = "_", idSchema: o, name: l, title: c, disabled: u = !1, readonly: f = !1, autofocus: p = !1, required: d = !1, registry: m, onBlur: h, onFocus: g, rawErrors: y } = this.props, { keyedFormData: v } = this.state;
    let { formData: b = [] } = this.props;
    const w = t.title || c || l, C = oe(r), { schemaUtils: E, formContext: _ } = m, F = (Qe(t.items) ? t.items : []).map((z, q) => E.retrieveSchema(z, n[q])), j = Qe(t.additionalItems) ? E.retrieveSchema(t.additionalItems, n) : null;
    (!b || b.length < F.length) && (b = b || [], b = b.concat(new Array(F.length - b.length)));
    const L = this.canAddItem(b) && !!j, U = {
      canAdd: L,
      className: "field field-array field-array-fixed-items",
      disabled: u,
      idSchema: o,
      formData: n,
      items: v.map((z, q) => {
        const { key: ue, item: me } = z, ie = me, Y = q >= F.length, V = (Y && Qe(t.additionalItems) ? E.retrieveSchema(t.additionalItems, ie) : F[q]) || {}, N = o.$id + s + q, x = E.toIdSchema(V, N, ie, a, s), D = Y ? r.additionalItems || {} : Array.isArray(r.items) ? r.items[q] : r.items || {}, $ = i ? i[q] : void 0;
        return this.renderArrayFieldItem({
          key: ue,
          index: q,
          name: l && `${l}-${q}`,
          title: w ? `${w}-${q + 1}` : void 0,
          canAdd: L,
          canRemove: Y,
          canMoveUp: q >= F.length + 1,
          canMoveDown: Y && q < b.length - 1,
          itemSchema: V,
          itemData: ie,
          itemUiSchema: D,
          itemIdSchema: x,
          itemErrorSchema: $,
          autofocus: p && q === 0,
          onBlur: h,
          onFocus: g,
          rawErrors: y,
          totalItems: v.length
        });
      }),
      onAddClick: this.onAddClick,
      readonly: f,
      required: d,
      registry: m,
      schema: t,
      uiSchema: r,
      title: w,
      formContext: _,
      errorSchema: i,
      rawErrors: y
    }, W = ce("ArrayFieldTemplate", m, C);
    return O(W, { ...U });
  }
  /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send
   * back to the `ArrayFieldItemTemplate`.
   *
   * @param props - The props for the individual array item to be rendered
   */
  renderArrayFieldItem(t) {
    const { key: r, index: n, name: i, canAdd: a, canRemove: s = !0, canMoveUp: o, canMoveDown: l, itemSchema: c, itemData: u, itemUiSchema: f, itemIdSchema: p, itemErrorSchema: d, autofocus: m, onBlur: h, onFocus: g, rawErrors: y, totalItems: v, title: b } = t, { disabled: w, hideError: C, idPrefix: E, idSeparator: _, readonly: T, uiSchema: F, registry: j, formContext: L } = this.props, { fields: { ArraySchemaField: U, SchemaField: W }, globalUiOptions: z } = j, q = U || W, { orderable: ue = !0, removable: me = !0, copyable: ie = !1 } = oe(F, z), Y = {
      moveUp: ue && o,
      moveDown: ue && l,
      copy: ie && a,
      remove: me && s,
      toolbar: !1
    };
    return Y.toolbar = Object.keys(Y).some((V) => Y[V]), {
      children: O(q, { name: i, title: b, index: n, schema: c, uiSchema: f, formData: u, formContext: L, errorSchema: d, idPrefix: E, idSeparator: _, idSchema: p, required: this.isItemRequired(c), onChange: this.onChangeForIndex(n), onBlur: h, onFocus: g, registry: j, disabled: w, readonly: T, hideError: C, autofocus: m, rawErrors: y }),
      className: "array-item",
      disabled: w,
      canAdd: a,
      hasCopy: Y.copy,
      hasToolbar: Y.toolbar,
      hasMoveUp: Y.moveUp,
      hasMoveDown: Y.moveDown,
      hasRemove: Y.remove,
      index: n,
      totalItems: v,
      key: r,
      onAddIndexClick: this.onAddIndexClick,
      onCopyIndexClick: this.onCopyIndexClick,
      onDropIndexClick: this.onDropIndexClick,
      onReorderClick: this.onReorderClick,
      readonly: T,
      registry: j,
      schema: c,
      uiSchema: f
    };
  }
}
function K1(e) {
  var t, r, n;
  const { schema: i, name: a, uiSchema: s, idSchema: o, formData: l, registry: c, required: u, disabled: f, readonly: p, hideError: d, autofocus: m, title: h, onChange: g, onFocus: y, onBlur: v, rawErrors: b } = e, { title: w } = i, { widgets: C, formContext: E, translateString: _, globalUiOptions: T } = c, {
    widget: F = "checkbox",
    title: j,
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: L = !0,
    ...U
  } = oe(s, T), W = Et(i, F, C), z = _(le.YesLabel), q = _(le.NoLabel);
  let ue;
  const me = (r = (t = j ?? w) !== null && t !== void 0 ? t : h) !== null && r !== void 0 ? r : a;
  if (Array.isArray(i.oneOf))
    ue = ii({
      oneOf: i.oneOf.map((ie) => {
        if (Qe(ie))
          return {
            ...ie,
            title: ie.title || (ie.const === !0 ? z : q)
          };
      }).filter((ie) => ie)
      // cast away the error that typescript can't grok is fixed
    });
  else {
    const ie = i, Y = (n = i.enum) !== null && n !== void 0 ? n : [!0, !1];
    !ie.enumNames && Y.length === 2 && Y.every((V) => typeof V == "boolean") ? ue = [
      {
        value: Y[0],
        label: Y[0] ? z : q
      },
      {
        value: Y[1],
        label: Y[1] ? z : q
      }
    ] : ue = ii({
      enum: Y,
      // NOTE: enumNames is deprecated, but still supported for now.
      enumNames: ie.enumNames
    });
  }
  return O(W, { options: { ...U, enumOptions: ue }, schema: i, uiSchema: s, id: o.$id, name: a, onChange: g, onFocus: y, onBlur: v, label: me, hideLabel: !L, value: l, required: u, disabled: f, readonly: p, hideError: d, registry: c, formContext: E, autofocus: m, rawErrors: b });
}
class Yo extends ln {
  /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
   *
   * @param props - The `FieldProps` for this template
   */
  constructor(t) {
    super(t), this.onOptionChange = (s) => {
      const { selectedOption: o, retrievedOptions: l } = this.state, { formData: c, onChange: u, registry: f } = this.props, { schemaUtils: p } = f, d = s !== void 0 ? parseInt(s, 10) : -1;
      if (d === o)
        return;
      const m = d >= 0 ? l[d] : void 0, h = o >= 0 ? l[o] : void 0;
      let g = p.sanitizeDataForNewSchema(m, h, c);
      g && m && (g = p.getDefaultFormState(m, g, "excludeObjectChildren")), u(g, void 0, this.getFieldId()), this.setState({ selectedOption: d });
    };
    const { formData: r, options: n, registry: { schemaUtils: i } } = this.props, a = n.map((s) => i.retrieveSchema(s, r));
    this.state = {
      retrievedOptions: a,
      selectedOption: this.getMatchingOption(0, r, a)
    };
  }
  /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
   * currently selected option based on the overall `formData`
   *
   * @param prevProps - The previous `FieldProps` for this template
   * @param prevState - The previous `AnyOfFieldState` for this template
   */
  componentDidUpdate(t, r) {
    const { formData: n, options: i, idSchema: a } = this.props, { selectedOption: s } = this.state;
    let o = this.state;
    if (!Be(t.options, i)) {
      const { registry: { schemaUtils: l } } = this.props, c = i.map((u) => l.retrieveSchema(u, n));
      o = { selectedOption: s, retrievedOptions: c };
    }
    if (!Be(n, t.formData) && a.$id === t.idSchema.$id) {
      const { retrievedOptions: l } = o, c = this.getMatchingOption(s, n, l);
      r && c !== s && (o = { selectedOption: c, retrievedOptions: l });
    }
    o !== this.state && this.setState(o);
  }
  /** Determines the best matching option for the given `formData` and `options`.
   *
   * @param formData - The new formData
   * @param options - The list of options to choose from
   * @return - The index of the `option` that best matches the `formData`
   */
  getMatchingOption(t, r, n) {
    const { schema: i, registry: { schemaUtils: a } } = this.props, s = Pr(i);
    return a.getClosestMatchingOption(r, n, t, s);
  }
  getFieldId() {
    const { idSchema: t, schema: r } = this.props;
    return `${t.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
  }
  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
   */
  render() {
    const { name: t, disabled: r = !1, errorSchema: n = {}, formContext: i, onBlur: a, onFocus: s, registry: o, schema: l, uiSchema: c } = this.props, { widgets: u, fields: f, translateString: p, globalUiOptions: d, schemaUtils: m } = o, { SchemaField: h } = f, { selectedOption: g, retrievedOptions: y } = this.state, { widget: v = "select", placeholder: b, autofocus: w, autocomplete: C, title: E = l.title, ..._ } = oe(c, d), T = Et({ type: "number" }, v, u), F = G(n, ot, []), j = Qn(n, [ot]), L = m.getDisplayLabel(l, c, d), U = g >= 0 && y[g] || null;
    let W;
    if (U) {
      const { required: Y } = l;
      W = Y ? At({ required: Y }, U) : U;
    }
    let z = [];
    et in l && c && et in c ? Array.isArray(c[et]) ? z = c[et] : console.warn(`uiSchema.oneOf is not an array for "${E || t}"`) : pt in l && c && pt in c && (Array.isArray(c[pt]) ? z = c[pt] : console.warn(`uiSchema.anyOf is not an array for "${E || t}"`));
    let q = c;
    g >= 0 && z.length > g && (q = z[g]);
    const ue = E ? le.TitleOptionPrefix : le.OptionPrefix, me = E ? [E] : [], ie = y.map((Y, V) => {
      const { title: N = Y.title } = oe(z[V]);
      return {
        label: N || p(ue, me.concat(String(V + 1))),
        value: V
      };
    });
    return ee("div", { className: "panel panel-default panel-body", children: [O("div", { className: "form-group", children: O(T, { id: this.getFieldId(), name: `${t}${l.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: a, onFocus: s, disabled: r || xt(ie), multiple: !1, rawErrors: F, errorSchema: j, value: g >= 0 ? g : void 0, options: { enumOptions: ie, ..._ }, registry: o, formContext: i, placeholder: b, autocomplete: C, autofocus: w, label: E ?? t, hideLabel: !L }) }), W && O(h, { ...this.props, schema: W, uiSchema: q })] });
  }
}
const z1 = /\.([0-9]*0)*$/, W1 = /[0.]0*$/;
function G1(e) {
  const { registry: t, onChange: r, formData: n, value: i } = e, [a, s] = va(i), { StringField: o } = t.fields;
  let l = n;
  const c = $e((u) => {
    s(u), `${u}`.charAt(0) === "." && (u = `0${u}`);
    const f = typeof u == "string" && u.match(z1) ? mo(u.replace(W1, "")) : mo(u);
    r(f);
  }, [r]);
  if (typeof a == "string" && typeof l == "number") {
    const u = new RegExp(`^(${String(l).replace(".", "\\.")})?\\.?0*$`);
    a.match(u) && (l = a);
  }
  return O(o, { ...e, formData: l, onChange: c });
}
function Qt() {
  return Qt = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r)
        Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, Qt.apply(this, arguments);
}
const H1 = ["children", "options"];
var Jo, Xo;
(function(e) {
  e.blockQuote = "0", e.breakLine = "1", e.breakThematic = "2", e.codeBlock = "3", e.codeFenced = "4", e.codeInline = "5", e.footnote = "6", e.footnoteReference = "7", e.gfmTask = "8", e.heading = "9", e.headingSetext = "10", e.htmlBlock = "11", e.htmlComment = "12", e.htmlSelfClosing = "13", e.image = "14", e.link = "15", e.linkAngleBraceStyleDetector = "16", e.linkBareUrlDetector = "17", e.linkMailtoDetector = "18", e.newlineCoalescer = "19", e.orderedList = "20", e.paragraph = "21", e.ref = "22", e.refImage = "23", e.refLink = "24", e.table = "25", e.tableSeparator = "26", e.text = "27", e.textBolded = "28", e.textEmphasized = "29", e.textEscaped = "30", e.textMarked = "31", e.textStrikethroughed = "32", e.unorderedList = "33";
})(Jo || (Jo = {})), function(e) {
  e[e.MAX = 0] = "MAX", e[e.HIGH = 1] = "HIGH", e[e.MED = 2] = "MED", e[e.LOW = 3] = "LOW", e[e.MIN = 4] = "MIN";
}(Xo || (Xo = {}));
const Zo = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "className", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { for: "htmlFor" }), Qo = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" }, Y1 = ["style", "script"], J1 = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, X1 = /mailto:/i, Z1 = /\n{2,}$/, fu = /^(\s*>[\s\S]*?)(?=\n{2,})/, Q1 = /^ *> ?/gm, eS = /^ {2,}\n/, tS = /^(?:( *[-*_])){3,} *(?:\n *)+\n/, hu = /^\s*(`{3,}|~{3,}) *(\S+)?([^\n]*?)?\n([\s\S]+?)\s*\1 *(?:\n *)*\n?/, mu = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, rS = /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, nS = /^(?:\n *)*\n/, iS = /\r\n?/g, aS = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, sS = /^\[\^([^\]]+)]/, oS = /\f/g, lS = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, cS = /^\s*?\[(x|\s)\]/, pu = /^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, yu = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, gu = /^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/, aa = /^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i, uS = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, vu = /^<!--[\s\S]*?(?:-->)/, dS = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, sa = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, fS = /^\{.*\}$/, hS = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, mS = /^<([^ >]+@[^ >]+)>/, pS = /^<([^ >]+:\/[^ >]+)>/, yS = /-([a-z])?/gi, $u = /^(.*\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, gS = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, vS = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, $S = /^\[([^\]]*)\] ?\[([^\]]*)\]/, _S = /(\[|\])/g, bS = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, SS = /\t/g, wS = /(^ *\||\| *$)/g, ES = /^ *:-+: *$/, OS = /^ *:-+ *$/, CS = /^ *-+: *$/, wi = "((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~~.*?~~|==.*?==|.|\\n)*?)", AS = new RegExp(`^([*_])\\1${wi}\\1\\1(?!\\1)`), PS = new RegExp(`^([*_])${wi}\\1(?!\\1|\\w)`), IS = new RegExp(`^==${wi}==`), TS = new RegExp(`^~~${wi}~~`), NS = /^\\([^0-9A-Za-z\s])/, DS = /^[\s\S]+?(?=[^0-9A-Z\s\u00c0-\uffff&#;.()'"]|\d+\.|\n\n| {2,}\n|\w+:\S|$)/i, FS = /^\n+/, kS = /^([ \t]*)/, RS = /\\([^\\])/g, el = / *\n+$/, MS = /(?:^|\n)( *)$/, ss = "(?:\\d+\\.)", os = "(?:[*+-])";
function _u(e) {
  return "( *)(" + (e === 1 ? ss : os) + ") +";
}
const bu = _u(1), Su = _u(2);
function wu(e) {
  return new RegExp("^" + (e === 1 ? bu : Su));
}
const jS = wu(1), US = wu(2);
function Eu(e) {
  return new RegExp("^" + (e === 1 ? bu : Su) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? ss : os) + " )[^\\n]*)*(\\n|$)", "gm");
}
const Ou = Eu(1), Cu = Eu(2);
function Au(e) {
  const t = e === 1 ? ss : os;
  return new RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
}
const Pu = Au(1), Iu = Au(2);
function tl(e, t) {
  const r = t === 1, n = r ? Pu : Iu, i = r ? Ou : Cu, a = r ? jS : US;
  return { match(s, o, l) {
    const c = MS.exec(l);
    return c && (o.list || !o.inline && !o.simple) ? n.exec(s = c[1] + s) : null;
  }, order: 1, parse(s, o, l) {
    const c = r ? +s[2] : void 0, u = s[0].replace(Z1, `
`).match(i);
    let f = !1;
    return { items: u.map(function(p, d) {
      const m = a.exec(p)[0].length, h = new RegExp("^ {1," + m + "}", "gm"), g = p.replace(h, "").replace(a, ""), y = d === u.length - 1, v = g.indexOf(`

`) !== -1 || y && f;
      f = v;
      const b = l.inline, w = l.list;
      let C;
      l.list = !0, v ? (l.inline = !1, C = g.replace(el, `

`)) : (l.inline = !0, C = g.replace(el, ""));
      const E = o(C, l);
      return l.inline = b, l.list = w, E;
    }), ordered: r, start: c };
  }, render: (s, o, l) => e(s.ordered ? "ol" : "ul", { key: l.key, start: s.type === "20" ? s.start : void 0 }, s.items.map(function(c, u) {
    return e("li", { key: u }, o(c, l));
  })) };
}
const VS = new RegExp(`^\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), xS = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/, Tu = [fu, hu, mu, pu, gu, yu, vu, $u, Ou, Pu, Cu, Iu], LS = [...Tu, /^[^\n]+(?:  \n|\n{2,})/, aa, sa];
function BS(e) {
  return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
}
function qS(e) {
  return CS.test(e) ? "right" : ES.test(e) ? "center" : OS.test(e) ? "left" : null;
}
function rl(e, t, r, n) {
  const i = r.inTable;
  r.inTable = !0;
  let a = e.trim().split(/( *(?:`[^`]*`|<.*?>.*?<\/.*?>(?!<\/.*?>)|\\\||\|) *)/).reduce((o, l) => (l.trim() === "|" ? o.push(n ? { type: "26" } : { type: "27", text: l }) : l !== "" && o.push.apply(o, t(l, r)), o), []);
  r.inTable = i;
  let s = [[]];
  return a.forEach(function(o, l) {
    o.type === "26" ? l !== 0 && l !== a.length - 1 && s.push([]) : (o.type !== "27" || a[l + 1] != null && a[l + 1].type !== "26" || (o.text = o.text.trimEnd()), s[s.length - 1].push(o));
  }), s;
}
function KS(e, t, r) {
  r.inline = !0;
  const n = e[2] ? e[2].replace(wS, "").split("|").map(qS) : [], i = e[3] ? function(s, o, l) {
    return s.trim().split(`
`).map(function(c) {
      return rl(c, o, l, !0);
    });
  }(e[3], t, r) : [], a = rl(e[1], t, r, !!i.length);
  return r.inline = !1, i.length ? { align: n, cells: i, header: a, type: "25" } : { children: a, type: "21" };
}
function nl(e, t) {
  return e.align[t] == null ? {} : { textAlign: e.align[t] };
}
function Nt(e) {
  return function(t, r) {
    return r.inline ? e.exec(t) : null;
  };
}
function Dt(e) {
  return function(t, r) {
    return r.inline || r.simple ? e.exec(t) : null;
  };
}
function bt(e) {
  return function(t, r) {
    return r.inline || r.simple ? null : e.exec(t);
  };
}
function Gr(e) {
  return function(t) {
    return e.exec(t);
  };
}
function zS(e, t, r) {
  if (t.inline || t.simple || r && !r.endsWith(`
`))
    return null;
  let n = "";
  e.split(`
`).every((a) => !Tu.some((s) => s.test(a)) && (n += a + `
`, a.trim()));
  const i = n.trimEnd();
  return i == "" ? null : [n, i];
}
function yr(e) {
  try {
    if (decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "").match(/^\s*(javascript|vbscript|data(?!:image)):/i))
      return;
  } catch {
    return null;
  }
  return e;
}
function il(e) {
  return e.replace(RS, "$1");
}
function Gn(e, t, r) {
  const n = r.inline || !1, i = r.simple || !1;
  r.inline = !0, r.simple = !0;
  const a = e(t, r);
  return r.inline = n, r.simple = i, a;
}
function WS(e, t, r) {
  const n = r.inline || !1, i = r.simple || !1;
  r.inline = !1, r.simple = !0;
  const a = e(t, r);
  return r.inline = n, r.simple = i, a;
}
function GS(e, t, r) {
  const n = r.inline || !1;
  r.inline = !1;
  const i = e(t, r);
  return r.inline = n, i;
}
const Vi = (e, t, r) => ({ children: Gn(t, e[1], r) });
function xi() {
  return {};
}
function Li() {
  return null;
}
function HS(...e) {
  return e.filter(Boolean).join(" ");
}
function Bi(e, t, r) {
  let n = e;
  const i = t.split(".");
  for (; i.length && (n = n[i[0]], n !== void 0); )
    i.shift();
  return n || r;
}
function YS(e = "", t = {}) {
  t.overrides = t.overrides || {}, t.slugify = t.slugify || BS, t.namedCodesToUnicode = t.namedCodesToUnicode ? Qt({}, Qo, t.namedCodesToUnicode) : Qo;
  const r = t.createElement || Ln.createElement;
  function n(d, m, ...h) {
    const g = Bi(t.overrides, `${d}.props`, {});
    return r(function(y, v) {
      const b = Bi(v, y);
      return b ? typeof b == "function" || typeof b == "object" && "render" in b ? b : Bi(v, `${y}.component`, y) : y;
    }(d, t.overrides), Qt({}, m, g, { className: HS(m == null ? void 0 : m.className, g.className) || void 0 }), ...h);
  }
  function i(d) {
    d = d.replace(lS, "");
    let m = !1;
    t.forceInline ? m = !0 : t.forceBlock || (m = bS.test(d) === !1);
    const h = u(c(m ? d : `${d.trimEnd().replace(FS, "")}

`, { inline: m }));
    for (; typeof h[h.length - 1] == "string" && !h[h.length - 1].trim(); )
      h.pop();
    if (t.wrapper === null)
      return h;
    const g = t.wrapper || (m ? "span" : "div");
    let y;
    if (h.length > 1 || t.forceWrapper)
      y = h;
    else {
      if (h.length === 1)
        return y = h[0], typeof y == "string" ? n("span", { key: "outer" }, y) : y;
      y = null;
    }
    return Ln.createElement(g, { key: "outer" }, y);
  }
  function a(d) {
    const m = d.match(J1);
    return m ? m.reduce(function(h, g, y) {
      const v = g.indexOf("=");
      if (v !== -1) {
        const b = function(_) {
          return _.indexOf("-") !== -1 && _.match(dS) === null && (_ = _.replace(yS, function(T, F) {
            return F.toUpperCase();
          })), _;
        }(g.slice(0, v)).trim(), w = function(_) {
          const T = _[0];
          return (T === '"' || T === "'") && _.length >= 2 && _[_.length - 1] === T ? _.slice(1, -1) : _;
        }(g.slice(v + 1).trim()), C = Zo[b] || b, E = h[C] = function(_, T) {
          return _ === "style" ? T.split(/;\s?/).reduce(function(F, j) {
            const L = j.slice(0, j.indexOf(":"));
            return F[L.trim().replace(/(-[a-z])/g, (U) => U[1].toUpperCase())] = j.slice(L.length + 1).trim(), F;
          }, {}) : _ === "href" || _ === "src" ? yr(T) : (T.match(fS) && (T = T.slice(1, T.length - 1)), T === "true" || T !== "false" && T);
        }(b, w);
        typeof E == "string" && (aa.test(E) || sa.test(E)) && (h[C] = Ln.cloneElement(i(E.trim()), { key: y }));
      } else
        g !== "style" && (h[Zo[g] || g] = !0);
      return h;
    }, {}) : null;
  }
  const s = [], o = {}, l = { 0: { match: bt(fu), order: 1, parse: (d, m, h) => ({ children: m(d[0].replace(Q1, ""), h) }), render: (d, m, h) => n("blockquote", { key: h.key }, m(d.children, h)) }, 1: { match: Gr(eS), order: 1, parse: xi, render: (d, m, h) => n("br", { key: h.key }) }, 2: { match: bt(tS), order: 1, parse: xi, render: (d, m, h) => n("hr", { key: h.key }) }, 3: { match: bt(mu), order: 0, parse: (d) => ({ lang: void 0, text: d[0].replace(/^ {4}/gm, "").replace(/\n+$/, "") }), render: (d, m, h) => n("pre", { key: h.key }, n("code", Qt({}, d.attrs, { className: d.lang ? `lang-${d.lang}` : "" }), d.text)) }, 4: { match: bt(hu), order: 0, parse: (d) => ({ attrs: a(d[3] || ""), lang: d[2] || void 0, text: d[4], type: "3" }) }, 5: { match: Dt(rS), order: 3, parse: (d) => ({ text: d[2] }), render: (d, m, h) => n("code", { key: h.key }, d.text) }, 6: { match: bt(aS), order: 0, parse: (d) => (s.push({ footnote: d[2], identifier: d[1] }), {}), render: Li }, 7: { match: Nt(sS), order: 1, parse: (d) => ({ target: `#${t.slugify(d[1])}`, text: d[1] }), render: (d, m, h) => n("a", { key: h.key, href: yr(d.target) }, n("sup", { key: h.key }, d.text)) }, 8: { match: Nt(cS), order: 1, parse: (d) => ({ completed: d[1].toLowerCase() === "x" }), render: (d, m, h) => n("input", { checked: d.completed, key: h.key, readOnly: !0, type: "checkbox" }) }, 9: { match: bt(t.enforceAtxHeadings ? yu : pu), order: 1, parse: (d, m, h) => ({ children: Gn(m, d[2], h), id: t.slugify(d[2]), level: d[1].length }), render: (d, m, h) => n(`h${d.level}`, { id: d.id, key: h.key }, m(d.children, h)) }, 10: { match: bt(gu), order: 0, parse: (d, m, h) => ({ children: Gn(m, d[1], h), level: d[2] === "=" ? 1 : 2, type: "9" }) }, 11: { match: Gr(aa), order: 1, parse(d, m, h) {
    const [, g] = d[3].match(kS), y = new RegExp(`^${g}`, "gm"), v = d[3].replace(y, ""), b = (w = v, LS.some((T) => T.test(w)) ? GS : Gn);
    var w;
    const C = d[1].toLowerCase(), E = Y1.indexOf(C) !== -1, _ = { attrs: a(d[2]), noInnerParse: E, tag: (E ? C : d[1]).trim() };
    return h.inAnchor = h.inAnchor || C === "a", E ? _.text = d[3] : _.children = b(m, v, h), h.inAnchor = !1, _;
  }, render: (d, m, h) => n(d.tag, Qt({ key: h.key }, d.attrs), d.text || m(d.children, h)) }, 13: { match: Gr(sa), order: 1, parse: (d) => ({ attrs: a(d[2] || ""), tag: d[1].trim() }), render: (d, m, h) => n(d.tag, Qt({}, d.attrs, { key: h.key })) }, 12: { match: Gr(vu), order: 1, parse: () => ({}), render: Li }, 14: { match: Dt(xS), order: 1, parse: (d) => ({ alt: d[1], target: il(d[2]), title: d[3] }), render: (d, m, h) => n("img", { key: h.key, alt: d.alt || void 0, title: d.title || void 0, src: yr(d.target) }) }, 15: { match: Nt(VS), order: 3, parse: (d, m, h) => ({ children: WS(m, d[1], h), target: il(d[2]), title: d[3] }), render: (d, m, h) => n("a", { key: h.key, href: yr(d.target), title: d.title }, m(d.children, h)) }, 16: { match: Nt(pS), order: 0, parse: (d) => ({ children: [{ text: d[1], type: "27" }], target: d[1], type: "15" }) }, 17: { match: (d, m) => m.inAnchor ? null : Nt(hS)(d, m), order: 0, parse: (d) => ({ children: [{ text: d[1], type: "27" }], target: d[1], title: void 0, type: "15" }) }, 18: { match: Nt(mS), order: 0, parse(d) {
    let m = d[1], h = d[1];
    return X1.test(h) || (h = "mailto:" + h), { children: [{ text: m.replace("mailto:", ""), type: "27" }], target: h, type: "15" };
  } }, 20: tl(n, 1), 33: tl(n, 2), 19: { match: bt(nS), order: 3, parse: xi, render: () => `
` }, 21: { match: zS, order: 3, parse: Vi, render: (d, m, h) => n("p", { key: h.key }, m(d.children, h)) }, 22: { match: Nt(gS), order: 0, parse: (d) => (o[d[1]] = { target: d[2], title: d[4] }, {}), render: Li }, 23: { match: Dt(vS), order: 0, parse: (d) => ({ alt: d[1] || void 0, ref: d[2] }), render: (d, m, h) => o[d.ref] ? n("img", { key: h.key, alt: d.alt, src: yr(o[d.ref].target), title: o[d.ref].title }) : null }, 24: { match: Nt($S), order: 0, parse: (d, m, h) => ({ children: m(d[1], h), fallbackChildren: m(d[0].replace(_S, "\\$1"), h), ref: d[2] }), render: (d, m, h) => o[d.ref] ? n("a", { key: h.key, href: yr(o[d.ref].target), title: o[d.ref].title }, m(d.children, h)) : n("span", { key: h.key }, m(d.fallbackChildren, h)) }, 25: { match: bt($u), order: 1, parse: KS, render(d, m, h) {
    const g = d;
    return n("table", { key: h.key }, n("thead", null, n("tr", null, g.header.map(function(y, v) {
      return n("th", { key: v, style: nl(g, v) }, m(y, h));
    }))), n("tbody", null, g.cells.map(function(y, v) {
      return n("tr", { key: v }, y.map(function(b, w) {
        return n("td", { key: w, style: nl(g, w) }, m(b, h));
      }));
    })));
  } }, 27: { match: Gr(DS), order: 4, parse: (d) => ({ text: d[0].replace(uS, (m, h) => t.namedCodesToUnicode[h] ? t.namedCodesToUnicode[h] : m) }), render: (d) => d.text }, 28: { match: Dt(AS), order: 2, parse: (d, m, h) => ({ children: m(d[2], h) }), render: (d, m, h) => n("strong", { key: h.key }, m(d.children, h)) }, 29: { match: Dt(PS), order: 3, parse: (d, m, h) => ({ children: m(d[2], h) }), render: (d, m, h) => n("em", { key: h.key }, m(d.children, h)) }, 30: { match: Dt(NS), order: 1, parse: (d) => ({ text: d[1], type: "27" }) }, 31: { match: Dt(IS), order: 3, parse: Vi, render: (d, m, h) => n("mark", { key: h.key }, m(d.children, h)) }, 32: { match: Dt(TS), order: 3, parse: Vi, render: (d, m, h) => n("del", { key: h.key }, m(d.children, h)) } };
  t.disableParsingRawHTML === !0 && (delete l[11], delete l[13]);
  const c = function(d) {
    let m = Object.keys(d);
    function h(g, y) {
      let v = [], b = "";
      for (; g; ) {
        let w = 0;
        for (; w < m.length; ) {
          const C = m[w], E = d[C], _ = E.match(g, y, b);
          if (_) {
            const T = _[0];
            g = g.substring(T.length);
            const F = E.parse(_, h, y);
            F.type == null && (F.type = C), v.push(F), b = T;
            break;
          }
          w++;
        }
      }
      return v;
    }
    return m.sort(function(g, y) {
      let v = d[g].order, b = d[y].order;
      return v !== b ? v - b : g < y ? -1 : 1;
    }), function(g, y) {
      return h(function(v) {
        return v.replace(iS, `
`).replace(oS, "").replace(SS, "    ");
      }(g), y);
    };
  }(l), u = (f = function(d, m) {
    return function(h, g, y) {
      const v = d[h.type].render;
      return m ? m(() => v(h, g, y), h, g, y) : v(h, g, y);
    };
  }(l, t.renderRule), function d(m, h = {}) {
    if (Array.isArray(m)) {
      const g = h.key, y = [];
      let v = !1;
      for (let b = 0; b < m.length; b++) {
        h.key = b;
        const w = d(m[b], h), C = typeof w == "string";
        C && v ? y[y.length - 1] += w : w !== null && y.push(w), v = C;
      }
      return h.key = g, y;
    }
    return f(m, d, h);
  });
  var f;
  const p = i(e);
  return s.length ? n("div", null, p, n("footer", { key: "footer" }, s.map(function(d) {
    return n("div", { id: t.slugify(d.identifier), key: d.identifier }, d.identifier, u(c(d.footnote, { inline: !0 })));
  }))) : p;
}
const Ei = (e) => {
  let { children: t = "", options: r } = e, n = function(i, a) {
    if (i == null)
      return {};
    var s, o, l = {}, c = Object.keys(i);
    for (o = 0; o < c.length; o++)
      a.indexOf(s = c[o]) >= 0 || (l[s] = i[s]);
    return l;
  }(e, H1);
  return Ln.cloneElement(YS(t, r), n);
};
var JS = ec;
function XS(e, t) {
  return e == null ? !0 : JS(e, t);
}
var ZS = XS;
const QS = /* @__PURE__ */ we(ZS);
class ew extends ln {
  constructor() {
    super(...arguments), this.state = {
      wasPropertyKeyModified: !1,
      additionalProperties: {}
    }, this.onPropertyChange = (t, r = !1) => (n, i, a) => {
      const { formData: s, onChange: o, errorSchema: l } = this.props;
      n === void 0 && r && (n = "");
      const c = { ...s, [t]: n };
      o(c, l && l && {
        ...l,
        [t]: i
      }, a);
    }, this.onDropPropertyClick = (t) => (r) => {
      r.preventDefault();
      const { onChange: n, formData: i } = this.props, a = { ...i };
      QS(a, t), n(a);
    }, this.getAvailableKey = (t, r) => {
      const { uiSchema: n, registry: i } = this.props, { duplicateKeySuffixSeparator: a = "-" } = oe(n, i.globalUiOptions);
      let s = 0, o = t;
      for (; Le(r, o); )
        o = `${t}${a}${++s}`;
      return o;
    }, this.onKeyChange = (t) => (r, n) => {
      if (t === r)
        return;
      const { formData: i, onChange: a, errorSchema: s } = this.props;
      r = this.getAvailableKey(r, i);
      const o = {
        ...i
      }, l = { [t]: r }, c = Object.keys(o).map((f) => ({ [l[f] || f]: o[f] })), u = Object.assign({}, ...c);
      this.setState({ wasPropertyKeyModified: !0 }), a(u, s && s && {
        ...s,
        [r]: n
      });
    }, this.handleAddClick = (t) => () => {
      if (!t.additionalProperties)
        return;
      const { formData: r, onChange: n, registry: i } = this.props, a = { ...r };
      let s, o;
      if (Qe(t.additionalProperties)) {
        s = t.additionalProperties.type, o = t.additionalProperties.default;
        let c = t.additionalProperties;
        if (Te in c) {
          const { schemaUtils: u } = i;
          c = u.retrieveSchema({ $ref: c[Te] }, r), s = c.type, o = c.default;
        }
        !s && (pt in c || et in c) && (s = "object");
      }
      const l = this.getAvailableKey("newKey", a);
      je(a, l, o ?? this.getDefaultValue(s)), n(a);
    };
  }
  /** Returns a flag indicating whether the `name` field is required in the object schema
   *
   * @param name - The name of the field to check for required-ness
   * @returns - True if the field `name` is required, false otherwise
   */
  isRequired(t) {
    const { schema: r } = this.props;
    return Array.isArray(r.required) && r.required.indexOf(t) !== -1;
  }
  /** Returns a default value to be used for a new additional schema property of the given `type`
   *
   * @param type - The type of the new additional schema property
   */
  getDefaultValue(t) {
    const { registry: { translateString: r } } = this.props;
    switch (t) {
      case "array":
        return [];
      case "boolean":
        return !1;
      case "null":
        return null;
      case "number":
        return 0;
      case "object":
        return {};
      case "string":
      default:
        return r(le.NewStringDefault);
    }
  }
  /** Renders the `ObjectField` from the given props
   */
  render() {
    var t, r, n, i;
    const { schema: a, uiSchema: s = {}, formData: o, errorSchema: l, idSchema: c, name: u, required: f = !1, disabled: p, readonly: d, hideError: m, idPrefix: h, idSeparator: g, onBlur: y, onFocus: v, registry: b, title: w } = this.props, { fields: C, formContext: E, schemaUtils: _, translateString: T, globalUiOptions: F } = b, { SchemaField: j } = C, L = _.retrieveSchema(a, o), U = oe(s, F), { properties: W = {} } = L, z = (n = (r = (t = U.title) !== null && t !== void 0 ? t : L.title) !== null && r !== void 0 ? r : w) !== null && n !== void 0 ? n : u, q = (i = U.description) !== null && i !== void 0 ? i : L.description;
    let ue;
    try {
      const Y = Object.keys(W);
      ue = h1(Y, U.order);
    } catch (Y) {
      return ee("div", { children: [O("p", { className: "config-error", style: { color: "red" }, children: O(Ei, { children: T(le.InvalidObjectField, [u || "root", Y.message]) }) }), O("pre", { children: JSON.stringify(L) })] });
    }
    const me = ce("ObjectFieldTemplate", b, U), ie = {
      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
      title: U.label === !1 ? "" : z,
      description: U.label === !1 ? void 0 : q,
      properties: ue.map((Y) => {
        const V = Le(L, [Oe, Y, Dr]), N = V ? s.additionalProperties : s[Y], x = oe(N).widget === "hidden", D = G(c, [Y], {});
        return {
          content: O(j, { name: Y, required: this.isRequired(Y), schema: G(L, [Oe, Y], {}), uiSchema: N, errorSchema: G(l, Y), idSchema: D, idPrefix: h, idSeparator: g, formData: G(o, Y), formContext: E, wasPropertyKeyModified: this.state.wasPropertyKeyModified, onKeyChange: this.onKeyChange(Y), onChange: this.onPropertyChange(Y, V), onBlur: y, onFocus: v, registry: b, disabled: p, readonly: d, hideError: m, onDropPropertyClick: this.onDropPropertyClick }, Y),
          name: Y,
          readonly: d,
          disabled: p,
          required: f,
          hidden: x
        };
      }),
      readonly: d,
      disabled: p,
      required: f,
      idSchema: c,
      uiSchema: s,
      errorSchema: l,
      schema: L,
      formData: o,
      formContext: E,
      registry: b
    };
    return O(me, { ...ie, onAddClick: this.handleAddClick });
  }
}
const tw = {
  array: "ArrayField",
  boolean: "BooleanField",
  integer: "NumberField",
  number: "NumberField",
  object: "ObjectField",
  string: "StringField",
  null: "NullField"
};
function rw(e, t, r, n) {
  const i = t.field, { fields: a, translateString: s } = n;
  if (typeof i == "function")
    return i;
  if (typeof i == "string" && i in a)
    return a[i];
  const o = Lt(e), l = Array.isArray(o) ? o[0] : o || "", c = e.$id;
  let u = tw[l];
  return c && c in a && (u = c), !u && (e.anyOf || e.oneOf) ? () => null : u in a ? a[u] : () => {
    const f = ce("UnsupportedFieldTemplate", n, t);
    return O(f, { schema: e, idSchema: r, reason: s(le.UnknownFieldType, [String(e.type)]), registry: n });
  };
}
function nw(e) {
  var t, r, n, i, a;
  const { schema: s, idSchema: o, uiSchema: l, formData: c, errorSchema: u, idPrefix: f, idSeparator: p, name: d, onChange: m, onKeyChange: h, onDropPropertyClick: g, required: y, registry: v, wasPropertyKeyModified: b = !1 } = e, { formContext: w, schemaUtils: C, globalUiOptions: E } = v, _ = oe(l, E), T = ce("FieldTemplate", v, _), F = ce("DescriptionFieldTemplate", v, _), j = ce("FieldHelpTemplate", v, _), L = ce("FieldErrorTemplate", v, _), U = C.retrieveSchema(s, c), W = o[Mt], z = Mr(C.toIdSchema(U, W, c, f, p), o), q = $e((qe, Wt, Ye) => m(qe, Wt, Ye || W), [W, m]), ue = rw(U, _, z, v), me = !!((t = _.disabled) !== null && t !== void 0 ? t : e.disabled), ie = !!((i = (n = (r = _.readonly) !== null && r !== void 0 ? r : e.readonly) !== null && n !== void 0 ? n : e.schema.readOnly) !== null && i !== void 0 ? i : U.readOnly), Y = _.hideError, V = Y === void 0 ? e.hideError : !!Y, N = !!((a = _.autofocus) !== null && a !== void 0 ? a : e.autofocus);
  if (Object.keys(U).length === 0)
    return null;
  const x = C.getDisplayLabel(U, l, E), { __errors: D, ...$ } = u || {}, P = Qn(l, ["ui:classNames", "classNames", "ui:style"]);
  nr in P && (P[nr] = Qn(P[nr], ["classNames", "style"]));
  const M = O(ue, { ...e, onChange: q, idSchema: z, schema: U, uiSchema: P, disabled: me, readonly: ie, hideError: V, autofocus: N, errorSchema: $, formContext: w, rawErrors: D }), B = z[Mt];
  let K;
  b ? K = d : K = Dr in U ? d : _.title || e.schema.title || U.title || e.title || d;
  const te = _.description || e.schema.description || U.description || "", ae = _.enableMarkdownInDescription ? O(Ei, { children: te }) : te, pe = _.help, He = _.widget === "hidden", rt = ["form-group", "field", `field-${Lt(U)}`];
  !V && D && D.length > 0 && rt.push("field-error has-error has-danger"), l != null && l.classNames && (process.env.NODE_ENV !== "production" && console.warn("'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead."), rt.push(l.classNames)), _.classNames && rt.push(_.classNames);
  const qt = O(j, { help: pe, idSchema: z, schema: U, uiSchema: l, hasErrors: !V && D && D.length > 0, registry: v }), Kt = V || (U.anyOf || U.oneOf) && !C.isSelect(U) ? void 0 : O(L, { errors: D, errorSchema: u, idSchema: z, schema: U, uiSchema: l, registry: v }), Ue = {
    description: O(F, { id: jr(B), description: ae, schema: U, uiSchema: l, registry: v }),
    rawDescription: te,
    help: qt,
    rawHelp: typeof pe == "string" ? pe : void 0,
    errors: Kt,
    rawErrors: V ? void 0 : D,
    id: B,
    label: K,
    hidden: He,
    onChange: m,
    onKeyChange: h,
    onDropPropertyClick: g,
    required: y,
    disabled: me,
    readonly: ie,
    hideError: V,
    displayLabel: x,
    classNames: rt.join(" ").trim(),
    style: _.style,
    formContext: w,
    formData: c,
    schema: U,
    uiSchema: l,
    registry: v
  }, zt = v.fields.AnyOfField, It = v.fields.OneOfField, $t = (l == null ? void 0 : l["ui:field"]) && (l == null ? void 0 : l["ui:fieldReplacesAnyOrOneOf"]) === !0;
  return O(T, { ...Ue, children: ee(at, { children: [M, U.anyOf && !$t && !C.isSelect(U) && O(zt, { name: d, disabled: me, readonly: ie, hideError: V, errorSchema: u, formData: c, formContext: w, idPrefix: f, idSchema: z, idSeparator: p, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: U.anyOf.map((qe) => C.retrieveSchema(Qe(qe) ? qe : {}, c)), registry: v, schema: U, uiSchema: l }), U.oneOf && !$t && !C.isSelect(U) && O(It, { name: d, disabled: me, readonly: ie, hideError: V, errorSchema: u, formData: c, formContext: w, idPrefix: f, idSchema: z, idSeparator: p, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: U.oneOf.map((qe) => C.retrieveSchema(Qe(qe) ? qe : {}, c)), registry: v, schema: U, uiSchema: l })] }) });
}
class iw extends ln {
  shouldComponentUpdate(t) {
    return !Be(this.props, t);
  }
  render() {
    return O(nw, { ...this.props });
  }
}
function aw(e) {
  var t;
  const { schema: r, name: n, uiSchema: i, idSchema: a, formData: s, required: o, disabled: l = !1, readonly: c = !1, autofocus: u = !1, onChange: f, onBlur: p, onFocus: d, registry: m, rawErrors: h, hideError: g } = e, { title: y, format: v } = r, { widgets: b, formContext: w, schemaUtils: C, globalUiOptions: E } = m, _ = C.isSelect(r) ? ii(r) : void 0;
  let T = _ ? "select" : "text";
  v && u1(r, v, b) && (T = v);
  const { widget: F = T, placeholder: j = "", title: L, ...U } = oe(i), W = C.getDisplayLabel(r, i, E), z = (t = L ?? y) !== null && t !== void 0 ? t : n, q = Et(r, F, b);
  return O(q, { options: { ...U, enumOptions: _ }, schema: r, uiSchema: i, id: a.$id, name: n, label: z, hideLabel: !W, hideError: g, value: s, onChange: f, onBlur: p, onFocus: d, required: o, disabled: l, readonly: c, formContext: w, autofocus: u, registry: m, placeholder: j, rawErrors: h });
}
function sw(e) {
  const { formData: t, onChange: r } = e;
  return $a(() => {
    t === void 0 && r(null);
  }, [t, r]), null;
}
function ow() {
  return {
    AnyOfField: Yo,
    ArrayField: q1,
    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
    BooleanField: K1,
    NumberField: G1,
    ObjectField: ew,
    OneOfField: Yo,
    SchemaField: iw,
    StringField: aw,
    NullField: sw
  };
}
function lw(e) {
  const { idSchema: t, description: r, registry: n, schema: i, uiSchema: a } = e, s = oe(a, n.globalUiOptions), { label: o = !0 } = s;
  if (!r || !o)
    return null;
  const l = ce("DescriptionFieldTemplate", n, s);
  return O(l, { id: jr(t), description: r, schema: i, uiSchema: a, registry: n });
}
function cw(e) {
  const { children: t, className: r, disabled: n, hasToolbar: i, hasMoveDown: a, hasMoveUp: s, hasRemove: o, hasCopy: l, index: c, onCopyIndexClick: u, onDropIndexClick: f, onReorderClick: p, readonly: d, registry: m, uiSchema: h } = e, { CopyButton: g, MoveDownButton: y, MoveUpButton: v, RemoveButton: b } = m.templates.ButtonTemplates, w = {
    flex: 1,
    paddingLeft: 6,
    paddingRight: 6,
    fontWeight: "bold"
  };
  return ee("div", { className: r, children: [O("div", { className: i ? "col-xs-9" : "col-xs-12", children: t }), i && O("div", { className: "col-xs-3 array-item-toolbox", children: ee("div", { className: "btn-group", style: {
    display: "flex",
    justifyContent: "space-around"
  }, children: [(s || a) && O(v, { style: w, disabled: n || d || !s, onClick: p(c, c - 1), uiSchema: h, registry: m }), (s || a) && O(y, { style: w, disabled: n || d || !a, onClick: p(c, c + 1), uiSchema: h, registry: m }), l && O(g, { style: w, disabled: n || d, onClick: u(c), uiSchema: h, registry: m }), o && O(b, { style: w, disabled: n || d, onClick: f(c), uiSchema: h, registry: m })] }) })] });
}
function uw(e) {
  const { canAdd: t, className: r, disabled: n, idSchema: i, uiSchema: a, items: s, onAddClick: o, readonly: l, registry: c, required: u, schema: f, title: p } = e, d = oe(a), m = ce("ArrayFieldDescriptionTemplate", c, d), h = ce("ArrayFieldItemTemplate", c, d), g = ce("ArrayFieldTitleTemplate", c, d), { ButtonTemplates: { AddButton: y } } = c.templates;
  return ee("fieldset", { className: r, id: i.$id, children: [O(g, { idSchema: i, title: d.title || p, required: u, schema: f, uiSchema: a, registry: c }), O(m, { idSchema: i, description: d.description || f.description, schema: f, uiSchema: a, registry: c }), O("div", { className: "row array-item-list", children: s && s.map(({ key: v, ...b }) => O(h, { ...b }, v)) }), t && O(y, { className: "array-item-add", onClick: o, disabled: n || l, uiSchema: a, registry: c })] });
}
function dw(e) {
  const { idSchema: t, title: r, schema: n, uiSchema: i, required: a, registry: s } = e, o = oe(i, s.globalUiOptions), { label: l = !0 } = o;
  if (!r || !l)
    return null;
  const c = ce("TitleFieldTemplate", s, o);
  return O(c, { id: is(t), title: r, required: a, schema: n, uiSchema: i, registry: s });
}
function fw(e) {
  const {
    id: t,
    name: r,
    // remove this from ...rest
    value: n,
    readonly: i,
    disabled: a,
    autofocus: s,
    onBlur: o,
    onFocus: l,
    onChange: c,
    onChangeOverride: u,
    options: f,
    schema: p,
    uiSchema: d,
    formContext: m,
    registry: h,
    rawErrors: g,
    type: y,
    hideLabel: v,
    // remove this from ...rest
    hideError: b,
    // remove this from ...rest
    ...w
  } = e;
  if (!t)
    throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
  const C = {
    ...w,
    ...su(p, y, f)
  };
  let E;
  C.type === "number" || C.type === "integer" ? E = n || n === 0 ? n : "" : E = n ?? "";
  const _ = $e(({ target: { value: j } }) => c(j === "" ? f.emptyValue : j), [c, f]), T = $e(({ target: j }) => o(t, j && j.value), [o, t]), F = $e(({ target: j }) => l(t, j && j.value), [l, t]);
  return ee(at, { children: [O("input", { id: t, name: t, className: "form-control", readOnly: i, disabled: a, autoFocus: s, value: E, ...C, list: p.examples ? Sr(t) : void 0, onChange: u || _, onBlur: T, onFocus: F, "aria-describedby": De(t, !!p.examples) }), Array.isArray(p.examples) && O("datalist", { id: Sr(t), children: p.examples.concat(p.default && !p.examples.includes(p.default) ? [p.default] : []).map((j) => O("option", { value: j }, j)) }, `datalist_${t}`)] });
}
function hw({ uiSchema: e }) {
  const { submitText: t, norender: r, props: n = {} } = ou(e);
  return r ? null : O("div", { children: O("button", { type: "submit", ...n, className: `btn btn-info ${n.className || ""}`, children: t }) });
}
function vn(e) {
  const { iconType: t = "default", icon: r, className: n, uiSchema: i, registry: a, ...s } = e;
  return O("button", { type: "button", className: `btn btn-${t} ${n}`, ...s, children: O("i", { className: `glyphicon glyphicon-${r}` }) });
}
function mw(e) {
  const { registry: { translateString: t } } = e;
  return O(vn, { title: t(le.CopyButton), className: "array-item-copy", ...e, icon: "copy" });
}
function pw(e) {
  const { registry: { translateString: t } } = e;
  return O(vn, { title: t(le.MoveDownButton), className: "array-item-move-down", ...e, icon: "arrow-down" });
}
function yw(e) {
  const { registry: { translateString: t } } = e;
  return O(vn, { title: t(le.MoveUpButton), className: "array-item-move-up", ...e, icon: "arrow-up" });
}
function gw(e) {
  const { registry: { translateString: t } } = e;
  return O(vn, { title: t(le.RemoveButton), className: "array-item-remove", ...e, iconType: "danger", icon: "remove" });
}
function vw({ className: e, onClick: t, disabled: r, registry: n }) {
  const { translateString: i } = n;
  return O("div", { className: "row", children: O("p", { className: `col-xs-3 col-xs-offset-9 text-right ${e}`, children: O(vn, { iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: i(le.AddButton), onClick: t, disabled: r, registry: n }) }) });
}
function $w() {
  return {
    SubmitButton: hw,
    AddButton: vw,
    CopyButton: mw,
    MoveDownButton: pw,
    MoveUpButton: yw,
    RemoveButton: gw
  };
}
function _w(e) {
  const { id: t, description: r } = e;
  return r ? typeof r == "string" ? O("p", { id: t, className: "field-description", children: r }) : O("div", { id: t, className: "field-description", children: r }) : null;
}
function bw({ errors: e, registry: t }) {
  const { translateString: r } = t;
  return ee("div", { className: "panel panel-danger errors", children: [O("div", { className: "panel-heading", children: O("h3", { className: "panel-title", children: r(le.ErrorsLabel) }) }), O("ul", { className: "list-group", children: e.map((n, i) => O("li", { className: "list-group-item text-danger", children: n.stack }, i)) })] });
}
const Sw = "*";
function Nu(e) {
  const { label: t, required: r, id: n } = e;
  return t ? ee("label", { className: "control-label", htmlFor: n, children: [t, r && O("span", { className: "required", children: Sw })] }) : null;
}
function ww(e) {
  const { id: t, label: r, children: n, errors: i, help: a, description: s, hidden: o, required: l, displayLabel: c, registry: u, uiSchema: f } = e, p = oe(f), d = ce("WrapIfAdditionalTemplate", u, p);
  return o ? O("div", { className: "hidden", children: n }) : ee(d, { ...e, children: [c && O(Nu, { label: r, required: l, id: t }), c && s ? s : null, n, i, a] });
}
function Ew(e) {
  const { errors: t = [], idSchema: r } = e;
  if (t.length === 0)
    return null;
  const n = ns(r);
  return O("div", { children: O("ul", { id: n, className: "error-detail bs-callout bs-callout-info", children: t.filter((i) => !!i).map((i, a) => O("li", { className: "text-danger", children: i }, a)) }) });
}
function Ow(e) {
  const { idSchema: t, help: r } = e;
  if (!r)
    return null;
  const n = lu(t);
  return typeof r == "string" ? O("p", { id: n, className: "help-block", children: r }) : O("div", { id: n, className: "help-block", children: r });
}
function Cw(e) {
  const { description: t, disabled: r, formData: n, idSchema: i, onAddClick: a, properties: s, readonly: o, registry: l, required: c, schema: u, title: f, uiSchema: p } = e, d = oe(p), m = ce("TitleFieldTemplate", l, d), h = ce("DescriptionFieldTemplate", l, d), { ButtonTemplates: { AddButton: g } } = l.templates;
  return ee("fieldset", { id: i.$id, children: [f && O(m, { id: is(i), title: f, required: c, schema: u, uiSchema: p, registry: l }), t && O(h, { id: jr(i), description: t, schema: u, uiSchema: p, registry: l }), s.map((y) => y.content), ql(u, p, n) && O(g, { className: "object-property-expand", onClick: a(u), disabled: r || o, uiSchema: p, registry: l })] });
}
const Aw = "*";
function Pw(e) {
  const { id: t, title: r, required: n } = e;
  return ee("legend", { id: t, children: [r, n && O("span", { className: "required", children: Aw })] });
}
function Iw(e) {
  const { schema: t, idSchema: r, reason: n, registry: i } = e, { translateString: a } = i;
  let s = le.UnsupportedField;
  const o = [];
  return r && r.$id && (s = le.UnsupportedFieldWithId, o.push(r.$id)), n && (s = s === le.UnsupportedField ? le.UnsupportedFieldWithReason : le.UnsupportedFieldWithIdAndReason, o.push(n)), ee("div", { className: "unsupported-field", children: [O("p", { children: O(Ei, { children: a(s, o) }) }), t && O("pre", { children: JSON.stringify(t, null, 2) })] });
}
function Tw(e) {
  const { id: t, classNames: r, style: n, disabled: i, label: a, onKeyChange: s, onDropPropertyClick: o, readonly: l, required: c, schema: u, children: f, uiSchema: p, registry: d } = e, { templates: m, translateString: h } = d, { RemoveButton: g } = m.ButtonTemplates, y = h(le.KeyLabel, [a]);
  return Dr in u ? O("div", { className: r, style: n, children: ee("div", { className: "row", children: [O("div", { className: "col-xs-5 form-additional", children: ee("div", { className: "form-group", children: [O(Nu, { label: y, required: c, id: `${t}-key` }), O("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: ({ target: b }) => s(b && b.value), defaultValue: a })] }) }), O("div", { className: "form-additional form-group col-xs-5", children: f }), O("div", { className: "col-xs-2", children: O(g, { className: "array-item-remove btn-block", style: { border: "0" }, disabled: i || l, onClick: o(a), uiSchema: p, registry: d }) })] }) }) : O("div", { className: r, style: n, children: f });
}
function Nw() {
  return {
    ArrayFieldDescriptionTemplate: lw,
    ArrayFieldItemTemplate: cw,
    ArrayFieldTemplate: uw,
    ArrayFieldTitleTemplate: dw,
    ButtonTemplates: $w(),
    BaseInputTemplate: fw,
    DescriptionFieldTemplate: _w,
    ErrorListTemplate: bw,
    FieldTemplate: ww,
    FieldErrorTemplate: Ew,
    FieldHelpTemplate: Ow,
    ObjectFieldTemplate: Cw,
    TitleFieldTemplate: Pw,
    UnsupportedFieldTemplate: Iw,
    WrapIfAdditionalTemplate: Tw
  };
}
function Dw(e, t) {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push({ value: n, label: St(n, 2) });
  return r;
}
function Fw(e) {
  return Object.values(e).every((t) => t !== -1);
}
function kw({ type: e, range: t, value: r, select: n, rootId: i, name: a, disabled: s, readonly: o, autofocus: l, registry: c, onBlur: u, onFocus: f }) {
  const p = i + "_" + e, { SelectWidget: d } = c.widgets;
  return O(d, { schema: { type: "integer" }, id: p, name: a, className: "form-control", options: { enumOptions: Dw(t[0], t[1]) }, placeholder: e, value: r, disabled: s, readonly: o, autofocus: l, onChange: (m) => n(e, m), onBlur: u, onFocus: f, registry: c, label: "", "aria-describedby": De(i) });
}
function Rw({ time: e = !1, disabled: t = !1, readonly: r = !1, autofocus: n = !1, options: i, id: a, name: s, registry: o, onBlur: l, onFocus: c, onChange: u, value: f }) {
  const { translateString: p } = o, [d, m] = va(f), [h, g] = Qd((w, C) => ({ ...w, ...C }), wr(f, e));
  $a(() => {
    const w = ai(h, e);
    Fw(h) && w !== f ? u(w) : d !== f && (m(f), g(wr(f, e)));
  }, [e, f, u, h, d]);
  const y = $e((w, C) => {
    g({ [w]: C });
  }, []), v = $e((w) => {
    if (w.preventDefault(), t || r)
      return;
    const C = wr((/* @__PURE__ */ new Date()).toJSON(), e);
    u(ai(C, e));
  }, [t, r, e]), b = $e((w) => {
    w.preventDefault(), !(t || r) && u(void 0);
  }, [t, r, u]);
  return ee("ul", { className: "list-inline", children: [iu(h, e, i.yearsRange, i.format).map((w, C) => O("li", { className: "list-inline-item", children: O(kw, { rootId: a, name: s, select: y, ...w, disabled: t, readonly: r, registry: o, onBlur: l, onFocus: c, autofocus: n && C === 0 }) }, C)), (i.hideNowButton !== "undefined" ? !i.hideNowButton : !0) && O("li", { className: "list-inline-item", children: O("a", { href: "#", className: "btn btn-info btn-now", onClick: v, children: p(le.NowLabel) }) }), (i.hideClearButton !== "undefined" ? !i.hideClearButton : !0) && O("li", { className: "list-inline-item", children: O("a", { href: "#", className: "btn btn-warning btn-clear", onClick: b, children: p(le.ClearLabel) }) })] });
}
function Mw({ time: e = !0, ...t }) {
  const { AltDateWidget: r } = t.registry.widgets;
  return O(r, { time: e, ...t });
}
function jw({ schema: e, uiSchema: t, options: r, id: n, value: i, disabled: a, readonly: s, label: o, hideLabel: l, autofocus: c = !1, onBlur: u, onFocus: f, onChange: p, registry: d }) {
  var m;
  const h = ce("DescriptionFieldTemplate", d, r), g = zn(e), y = $e((C) => p(C.target.checked), [p]), v = $e((C) => u(n, C.target.checked), [u, n]), b = $e((C) => f(n, C.target.checked), [f, n]), w = (m = r.description) !== null && m !== void 0 ? m : e.description;
  return ee("div", { className: `checkbox ${a || s ? "disabled" : ""}`, children: [!l && !!w && O(h, { id: jr(n), description: w, schema: e, uiSchema: t, registry: d }), ee("label", { children: [O("input", { type: "checkbox", id: n, name: n, checked: typeof i > "u" ? !1 : i, required: g, disabled: a || s, autoFocus: c, onChange: y, onBlur: v, onFocus: b, "aria-describedby": De(n) }), cu(O("span", { children: o }), l)] })] });
}
function Uw({ id: e, disabled: t, options: { inline: r = !1, enumOptions: n, enumDisabled: i, emptyValue: a }, value: s, autofocus: o = !1, readonly: l, onChange: c, onBlur: u, onFocus: f }) {
  const p = Array.isArray(s) ? s : [s], d = $e(({ target: h }) => u(e, Ne(h && h.value, n, a)), [u, e]), m = $e(({ target: h }) => f(e, Ne(h && h.value, n, a)), [f, e]);
  return O("div", { className: "checkboxes", id: e, children: Array.isArray(n) && n.map((h, g) => {
    const y = rs(h.value, p), v = Array.isArray(i) && i.indexOf(h.value) !== -1, b = t || v || l ? "disabled" : "", w = (E) => {
      E.target.checked ? c(a1(g, p, n)) : c(t1(g, p, n));
    }, C = ee("span", { children: [O("input", { type: "checkbox", id: Si(e, g), name: e, checked: y, value: String(g), disabled: t || v || l, autoFocus: o && g === 0, onChange: w, onBlur: d, onFocus: m, "aria-describedby": De(e) }), O("span", { children: h.label })] });
    return r ? O("label", { className: `checkbox-inline ${b}`, children: C }, g) : O("div", { className: `checkbox ${b}`, children: O("label", { children: C }) }, g);
  }) });
}
function Vw(e) {
  const { disabled: t, readonly: r, options: n, registry: i } = e, a = ce("BaseInputTemplate", i, n);
  return O(a, { type: "color", ...e, disabled: t || r });
}
function xw(e) {
  const { onChange: t, options: r, registry: n } = e, i = ce("BaseInputTemplate", n, r), a = $e((s) => t(s || void 0), [t]);
  return O(i, { type: "date", ...e, onChange: a });
}
function Lw(e) {
  const { onChange: t, value: r, options: n, registry: i } = e, a = ce("BaseInputTemplate", i, n);
  return O(a, { type: "datetime-local", ...e, value: O1(r), onChange: (s) => t(d1(s)) });
}
function Bw(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return O(n, { type: "email", ...e });
}
function qw(e, t) {
  return e === null ? null : e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
}
function Kw(e) {
  const { name: t, size: r, type: n } = e;
  return new Promise((i, a) => {
    const s = new window.FileReader();
    s.onerror = a, s.onload = (o) => {
      var l;
      typeof ((l = o.target) === null || l === void 0 ? void 0 : l.result) == "string" ? i({
        dataURL: qw(o.target.result, t),
        name: t,
        size: r,
        type: n
      }) : i({
        dataURL: null,
        name: t,
        size: r,
        type: n
      });
    }, s.readAsDataURL(e);
  });
}
function zw(e) {
  return Promise.all(Array.from(e).map(Kw));
}
function Ww({ fileInfo: e, registry: t }) {
  const { translateString: r } = t, { dataURL: n, type: i, name: a } = e;
  return n ? ["image/jpeg", "image/png"].includes(i) ? O("img", { src: n, style: { maxWidth: "100%" }, className: "file-preview" }) : ee(at, { children: [" ", O("a", { download: `preview-${a}`, href: n, className: "file-download", children: r(le.PreviewLabel) })] }) : null;
}
function Gw({ filesInfo: e, registry: t, preview: r, onRemove: n, options: i }) {
  if (e.length === 0)
    return null;
  const { translateString: a } = t, { RemoveButton: s } = ce("ButtonTemplates", t, i);
  return O("ul", { className: "file-info", children: e.map((o, l) => {
    const { name: c, size: u, type: f } = o, p = () => n(l);
    return ee("li", { children: [O(Ei, { children: a(le.FilesInfo, [c, f, String(u)]) }), r && O(Ww, { fileInfo: o, registry: t }), O(s, { onClick: p, registry: t })] }, l);
  }) });
}
function Hw(e) {
  return e.reduce((t, r) => {
    if (!r)
      return t;
    try {
      const { blob: n, name: i } = Zb(r);
      return [
        ...t,
        {
          dataURL: r,
          name: i,
          size: n.size,
          type: n.type
        }
      ];
    } catch {
      return t;
    }
  }, []);
}
function Yw(e) {
  const { disabled: t, readonly: r, required: n, multiple: i, onChange: a, value: s, options: o, registry: l } = e, c = ce("BaseInputTemplate", l, o), u = $e((d) => {
    d.target.files && zw(d.target.files).then((m) => {
      const h = m.map((g) => g.dataURL);
      a(i ? s.concat(h[0]) : h[0]);
    });
  }, [i, s, a]), f = ef(() => Hw(Array.isArray(s) ? s : [s]), [s]), p = $e((d) => {
    if (i) {
      const m = s.filter((h, g) => g !== d);
      a(m);
    } else
      a(void 0);
  }, [i, s, a]);
  return ee("div", { children: [O(c, { ...e, disabled: t || r, type: "file", required: s ? !1 : n, onChangeOverride: u, value: "", accept: o.accept ? String(o.accept) : void 0 }), O(Gw, { filesInfo: f, onRemove: p, registry: l, preview: o.filePreview, options: o })] });
}
function Jw({ id: e, value: t }) {
  return O("input", { type: "hidden", id: e, name: e, value: typeof t > "u" ? "" : t });
}
function Xw(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return O(n, { type: "password", ...e });
}
function Zw({ options: e, value: t, required: r, disabled: n, readonly: i, autofocus: a = !1, onBlur: s, onFocus: o, onChange: l, id: c }) {
  const { enumOptions: u, enumDisabled: f, inline: p, emptyValue: d } = e, m = $e(({ target: g }) => s(c, Ne(g && g.value, u, d)), [s, c]), h = $e(({ target: g }) => o(c, Ne(g && g.value, u, d)), [o, c]);
  return O("div", { className: "field-radio-group", id: c, children: Array.isArray(u) && u.map((g, y) => {
    const v = rs(g.value, t), b = Array.isArray(f) && f.indexOf(g.value) !== -1, w = n || b || i ? "disabled" : "", C = () => l(g.value), E = ee("span", { children: [O("input", { type: "radio", id: Si(c, y), checked: v, name: c, required: r, value: String(y), disabled: n || b || i, autoFocus: a && y === 0, onChange: C, onBlur: m, onFocus: h, "aria-describedby": De(c) }), O("span", { children: g.label })] });
    return p ? O("label", { className: `radio-inline ${w}`, children: E }, y) : O("div", { className: `radio ${w}`, children: O("label", { children: E }) }, y);
  }) });
}
function Qw(e) {
  const { value: t, registry: { templates: { BaseInputTemplate: r } } } = e;
  return ee("div", { className: "field-range-wrapper", children: [O(r, { type: "range", ...e }), O("span", { className: "range-view", children: t })] });
}
function qi(e, t) {
  return t ? Array.from(e.target.options).slice().filter((r) => r.selected).map((r) => r.value) : e.target.value;
}
function eE({ schema: e, id: t, options: r, value: n, required: i, disabled: a, readonly: s, multiple: o = !1, autofocus: l = !1, onChange: c, onBlur: u, onFocus: f, placeholder: p }) {
  const { enumOptions: d, enumDisabled: m, emptyValue: h } = r, g = o ? [] : "", y = $e((C) => {
    const E = qi(C, o);
    return f(t, Ne(E, d, h));
  }, [f, t, e, o, r]), v = $e((C) => {
    const E = qi(C, o);
    return u(t, Ne(E, d, h));
  }, [u, t, e, o, r]), b = $e((C) => {
    const E = qi(C, o);
    return c(Ne(E, d, h));
  }, [c, e, o, r]), w = bi(n, d, o);
  return ee("select", { id: t, name: t, multiple: o, className: "form-control", value: typeof w > "u" ? g : w, required: i, disabled: a || s, autoFocus: l, onBlur: v, onFocus: y, onChange: b, "aria-describedby": De(t), children: [!o && e.default === void 0 && O("option", { value: "", children: p }), Array.isArray(d) && d.map(({ value: C, label: E }, _) => {
    const T = m && m.indexOf(C) !== -1;
    return O("option", { value: String(_), disabled: T, children: E }, _);
  })] });
}
function Du({ id: e, options: t = {}, placeholder: r, value: n, required: i, disabled: a, readonly: s, autofocus: o = !1, onChange: l, onBlur: c, onFocus: u }) {
  const f = $e(({ target: { value: m } }) => l(m === "" ? t.emptyValue : m), [l, t.emptyValue]), p = $e(({ target: m }) => c(e, m && m.value), [c, e]), d = $e(({ target: m }) => u(e, m && m.value), [e, u]);
  return O("textarea", { id: e, name: e, className: "form-control", value: n || "", placeholder: r, required: i, disabled: a, readOnly: s, autoFocus: o, rows: t.rows, onBlur: p, onFocus: d, onChange: f, "aria-describedby": De(e) });
}
Du.defaultProps = {
  autofocus: !1,
  options: {}
};
function tE(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return O(n, { ...e });
}
function rE(e) {
  const { onChange: t, options: r, registry: n } = e, i = ce("BaseInputTemplate", n, r), a = $e((s) => t(s ? `${s}:00` : void 0), [t]);
  return O(i, { type: "time", ...e, onChange: a });
}
function nE(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return O(n, { type: "url", ...e });
}
function iE(e) {
  const { options: t, registry: r } = e, n = ce("BaseInputTemplate", r, t);
  return O(n, { type: "number", ...e });
}
function aE() {
  return {
    AltDateWidget: Rw,
    AltDateTimeWidget: Mw,
    CheckboxWidget: jw,
    CheckboxesWidget: Uw,
    ColorWidget: Vw,
    DateWidget: xw,
    DateTimeWidget: Lw,
    EmailWidget: Bw,
    FileWidget: Yw,
    HiddenWidget: Jw,
    PasswordWidget: Xw,
    RadioWidget: Zw,
    RangeWidget: Qw,
    SelectWidget: eE,
    TextWidget: tE,
    TextareaWidget: Du,
    TimeWidget: rE,
    UpDownWidget: iE,
    URLWidget: nE
  };
}
function sE() {
  return {
    fields: ow(),
    templates: Nw(),
    widgets: aE(),
    rootSchema: {},
    formContext: {},
    translateString: e1
  };
}
let oE = class extends ln {
  /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
   * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
   * state construction.
   *
   * @param props - The initial props for the `Form`
   */
  constructor(t) {
    if (super(t), this.getUsedFormData = (r, n) => {
      if (n.length === 0 && typeof r != "object")
        return r;
      const i = L1(r, n);
      return Array.isArray(r) ? Object.keys(i).map((a) => i[a]) : i;
    }, this.getFieldNames = (r, n) => {
      const i = (a, s = [], o = [[]]) => (Object.keys(a).forEach((l) => {
        if (typeof a[l] == "object") {
          const c = o.map((u) => [...u, l]);
          a[l][Ia] && a[l][Bn] !== "" ? s.push(a[l][Bn]) : i(a[l], s, c);
        } else
          l === Bn && a[l] !== "" && o.forEach((c) => {
            const u = G(n, c);
            (typeof u != "object" || xt(u) || Array.isArray(u) && u.every((f) => typeof f != "object")) && s.push(c);
          });
      }), s);
      return i(r);
    }, this.omitExtraData = (r) => {
      const { schema: n, schemaUtils: i } = this.state, a = i.retrieveSchema(n, r), s = i.toPathSchema(a, "", r), o = this.getFieldNames(s, r);
      return this.getUsedFormData(r, o);
    }, this.onChange = (r, n, i) => {
      const { extraErrors: a, omitExtraData: s, liveOmit: o, noValidate: l, liveValidate: c, onChange: u } = this.props, { schemaUtils: f, schema: p, retrievedSchema: d } = this.state;
      (Se(r) || Array.isArray(r)) && (r = this.getStateFromProps(this.props, r, d).formData);
      const m = !l && c;
      let h = { formData: r, schema: p }, g = r;
      if (s === !0 && o === !0 && (g = this.omitExtraData(r), h = {
        formData: g
      }), m) {
        const y = this.validate(g, p, f, d);
        let v = y.errors, b = y.errorSchema;
        const w = v, C = b;
        if (a) {
          const E = Wn(y, a);
          b = E.errorSchema, v = E.errors;
        }
        h = {
          formData: g,
          errors: v,
          errorSchema: b,
          schemaValidationErrors: w,
          schemaValidationErrorSchema: C
        };
      } else if (!l && n) {
        const y = a ? Mr(n, a, "preventDuplicates") : n;
        h = {
          formData: g,
          errorSchema: y,
          errors: sn(y)
        };
      }
      this.setState(h, () => u && u({ ...this.state, ...h }, i));
    }, this.reset = () => {
      const { onChange: r } = this.props, a = {
        formData: this.getStateFromProps(this.props, void 0).formData,
        errorSchema: {},
        errors: [],
        schemaValidationErrors: [],
        schemaValidationErrorSchema: {}
      };
      this.setState(a, () => r && r({ ...this.state, ...a }));
    }, this.onBlur = (r, n) => {
      const { onBlur: i } = this.props;
      i && i(r, n);
    }, this.onFocus = (r, n) => {
      const { onFocus: i } = this.props;
      i && i(r, n);
    }, this.onSubmit = (r) => {
      if (r.preventDefault(), r.target !== r.currentTarget)
        return;
      r.persist();
      const { omitExtraData: n, extraErrors: i, noValidate: a, onSubmit: s } = this.props;
      let { formData: o } = this.state;
      if (n === !0 && (o = this.omitExtraData(o)), a || this.validateFormWithFormData(o)) {
        const l = i || {}, c = i ? sn(i) : [];
        this.setState({
          formData: o,
          errors: c,
          errorSchema: l,
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        }, () => {
          s && s({ ...this.state, formData: o, status: "submitted" }, r);
        });
      }
    }, this.submit = () => {
      if (this.formElement.current) {
        const r = new CustomEvent("submit", {
          cancelable: !0
        });
        r.preventDefault(), this.formElement.current.dispatchEvent(r), this.formElement.current.requestSubmit();
      }
    }, this.validateFormWithFormData = (r) => {
      const { extraErrors: n, extraErrorsBlockSubmit: i, focusOnFirstError: a, onError: s } = this.props, { errors: o } = this.state, l = this.validate(r);
      let c = l.errors, u = l.errorSchema;
      const f = c, p = u, d = c.length > 0 || n && i;
      if (d) {
        if (n) {
          const m = Wn(l, n);
          u = m.errorSchema, c = m.errors;
        }
        a && (typeof a == "function" ? a(c[0]) : this.focusOnError(c[0])), this.setState({
          errors: c,
          errorSchema: u,
          schemaValidationErrors: f,
          schemaValidationErrorSchema: p
        }, () => {
          s ? s(c) : console.error("Form validation failed", c);
        });
      } else
        o.length > 0 && this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
      return !d;
    }, !t.validator)
      throw new Error("A validator is required for Form functionality to work");
    this.state = this.getStateFromProps(t, t.formData), this.props.onChange && !Be(this.state.formData, this.props.formData) && this.props.onChange(this.state), this.formElement = tf();
  }
  /**
   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
   * they are potentially changed.
   *
   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
   * state ready to be applied in `componentDidUpdate`.
   *
   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
   * state update is not necessary.
   *
   * @param prevProps - The previous set of props before the update.
   * @param prevState - The previous state before the update.
   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
   *        with a flag indicating that an update is not necessary.
   */
  getSnapshotBeforeUpdate(t, r) {
    if (!Be(this.props, t)) {
      const n = !Be(t.schema, this.props.schema), i = !Be(t.formData, this.props.formData), a = this.getStateFromProps(
        this.props,
        this.props.formData,
        // If the `schema` has changed, we need to update the retrieved schema.
        // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
        //  match one of the subSchemas, the retrieved schema must be updated.
        n || i ? void 0 : this.state.retrievedSchema,
        n
      ), s = !Be(a, r);
      return { nextState: a, shouldUpdate: s };
    }
    return { shouldUpdate: !1 };
  }
  /**
   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
   * not called for the initial render.
   *
   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
   * changes.
   *
   * This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative
   * to handle prop changes and state updates.
   *
   * @param _ - The previous set of props.
   * @param prevState - The previous state of the component before the update.
   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
   */
  componentDidUpdate(t, r, n) {
    if (n.shouldUpdate) {
      const { nextState: i } = n;
      !Be(i.formData, this.props.formData) && !Be(i.formData, r.formData) && this.props.onChange && this.props.onChange(i), this.setState(i);
    }
  }
  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
   * validation process IF required by the `props`.
   *
   * @param props - The props passed to the `Form`
   * @param inputFormData - The new or current data for the `Form`
   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
   * @param isSchemaChanged - A flag indicating whether the schema has changed.
   * @returns - The new state for the `Form`
   */
  getStateFromProps(t, r, n, i = !1) {
    const a = this.state || {}, s = "schema" in t ? t.schema : this.props.schema, o = ("uiSchema" in t ? t.uiSchema : this.props.uiSchema) || {}, l = typeof r < "u", c = "liveValidate" in t ? t.liveValidate : this.props.liveValidate, u = l && !t.noValidate && c, f = s, p = "experimental_defaultFormStateBehavior" in t ? t.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior;
    let d = a.schemaUtils;
    (!d || d.doesSchemaUtilsDiffer(t.validator, f, p)) && (d = Xb(t.validator, f, p));
    const m = d.getDefaultFormState(s, r), h = n ?? d.retrieveSchema(s, m), g = () => t.noValidate || i ? { errors: [], errorSchema: {} } : t.liveValidate ? {
      errors: a.errors || [],
      errorSchema: a.errorSchema || {}
    } : {
      errors: a.schemaValidationErrors || [],
      errorSchema: a.schemaValidationErrorSchema || {}
    };
    let y, v, b = a.schemaValidationErrors, w = a.schemaValidationErrorSchema;
    if (u) {
      const _ = this.validate(m, s, d, h);
      y = _.errors, v = _.errorSchema, b = y, w = v;
    } else {
      const _ = g();
      y = _.errors, v = _.errorSchema;
    }
    if (t.extraErrors) {
      const _ = Wn({ errorSchema: v, errors: y }, t.extraErrors);
      v = _.errorSchema, y = _.errors;
    }
    const C = d.toIdSchema(h, o["ui:rootFieldId"], m, t.idPrefix, t.idSeparator);
    return {
      schemaUtils: d,
      schema: s,
      uiSchema: o,
      idSchema: C,
      formData: m,
      edit: l,
      errors: y,
      errorSchema: v,
      schemaValidationErrors: b,
      schemaValidationErrorSchema: w,
      retrievedSchema: h
    };
  }
  /** React lifecycle method that is used to determine whether component should be updated.
   *
   * @param nextProps - The next version of the props
   * @param nextState - The next version of the state
   * @returns - True if the component should be updated, false otherwise
   */
  shouldComponentUpdate(t, r) {
    return m1(this, t, r);
  }
  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
   * `schemaUtils` in the state), returning the results.
   *
   * @param formData - The new form data to validate
   * @param schema - The schema used to validate against
   * @param altSchemaUtils - The alternate schemaUtils to use for validation
   */
  validate(t, r = this.props.schema, n, i) {
    const a = n || this.state.schemaUtils, { customValidate: s, transformErrors: o, uiSchema: l } = this.props, c = i ?? a.retrieveSchema(r, t);
    return a.getValidator().validateFormData(t, c, s, o, l);
  }
  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
  renderErrors(t) {
    const { errors: r, errorSchema: n, schema: i, uiSchema: a } = this.state, { formContext: s } = this.props, o = oe(a), l = ce("ErrorListTemplate", t, o);
    return r && r.length ? O(l, { errors: r, errorSchema: n || {}, schema: i, uiSchema: a, formContext: s, registry: t }) : null;
  }
  /** Returns the registry for the form */
  getRegistry() {
    var t;
    const { translateString: r, uiSchema: n = {} } = this.props, { schemaUtils: i } = this.state, { fields: a, templates: s, widgets: o, formContext: l, translateString: c } = sE();
    return {
      fields: { ...a, ...this.props.fields },
      templates: {
        ...s,
        ...this.props.templates,
        ButtonTemplates: {
          ...s.ButtonTemplates,
          ...(t = this.props.templates) === null || t === void 0 ? void 0 : t.ButtonTemplates
        }
      },
      widgets: { ...o, ...this.props.widgets },
      rootSchema: this.props.schema,
      formContext: this.props.formContext || l,
      schemaUtils: i,
      translateString: r || c,
      globalUiOptions: n[jf]
    };
  }
  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
   * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
   *
   * @param error - The error on which to focus
   */
  focusOnError(t) {
    const { idPrefix: r = "root", idSeparator: n = "_" } = this.props, { property: i } = t, a = uu(i);
    a[0] === "" ? a[0] = r : a.unshift(r);
    const s = a.join(n);
    let o = this.formElement.current.elements[s];
    o || (o = this.formElement.current.querySelector(`input[id^=${s}`)), o && o.length && (o = o[0]), o && o.focus();
  }
  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
   * same way as would happen on form submission.
   *
   * @returns - True if the form is valid, false otherwise.
   */
  validateForm() {
    const { omitExtraData: t } = this.props;
    let { formData: r } = this.state;
    return t === !0 && (r = this.omitExtraData(r)), this.validateFormWithFormData(r);
  }
  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
   * needed along with the submit button or any children of the form.
   */
  render() {
    const { children: t, id: r, idPrefix: n, idSeparator: i, className: a = "", tagName: s, name: o, method: l, target: c, action: u, autoComplete: f, enctype: p, acceptcharset: d, acceptCharset: m, noHtml5Validate: h = !1, disabled: g, readonly: y, formContext: v, showErrorList: b = "top", _internalFormWrapper: w } = this.props, { schema: C, uiSchema: E, formData: _, errorSchema: T, idSchema: F } = this.state, j = this.getRegistry(), { SchemaField: L } = j.fields, { SubmitButton: U } = j.templates.ButtonTemplates, W = w ? s : void 0, z = w || s || "form";
    let { [Zn]: q = {} } = oe(E);
    g && (q = { ...q, props: { ...q.props, disabled: !0 } });
    const ue = { [nr]: { [Zn]: q } };
    return ee(z, { className: a || "rjsf", id: r, name: o, method: l, target: c, action: u, autoComplete: f, encType: p, acceptCharset: m || d, noValidate: h, onSubmit: this.onSubmit, as: W, ref: this.formElement, children: [b === "top" && this.renderErrors(j), O(L, { name: "", schema: C, uiSchema: E, errorSchema: T, idSchema: F, idPrefix: n, idSeparator: i, formContext: v, formData: _, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: j, disabled: g, readonly: y }), t || O(U, { uiSchema: ue, registry: j }), b === "bottom" && this.renderErrors(j)] });
  }
};
function Fu(e) {
  return rf(({ fields: t, widgets: r, templates: n, ...i }, a) => {
    var s;
    return t = { ...e == null ? void 0 : e.fields, ...t }, r = { ...e == null ? void 0 : e.widgets, ...r }, n = {
      ...e == null ? void 0 : e.templates,
      ...n,
      ButtonTemplates: {
        ...(s = e == null ? void 0 : e.templates) === null || s === void 0 ? void 0 : s.ButtonTemplates,
        ...n == null ? void 0 : n.ButtonTemplates
      }
    }, O(oE, { ...e, ...i, fields: t, widgets: r, templates: n, ref: a });
  });
}
var oa = { exports: {} }, ku = {}, lt = {}, Tr = {}, $n = {}, re = {}, on = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
  class t {
  }
  e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends t {
    constructor(v) {
      if (super(), !e.IDENTIFIER.test(v))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = r;
  class n extends t {
    constructor(v) {
      super(), this._items = typeof v == "string" ? [v] : v;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const v = this._items[0];
      return v === "" || v === '""';
    }
    get str() {
      var v;
      return (v = this._str) !== null && v !== void 0 ? v : this._str = this._items.reduce((b, w) => `${b}${w}`, "");
    }
    get names() {
      var v;
      return (v = this._names) !== null && v !== void 0 ? v : this._names = this._items.reduce((b, w) => (w instanceof r && (b[w.str] = (b[w.str] || 0) + 1), b), {});
    }
  }
  e._Code = n, e.nil = new n("");
  function i(y, ...v) {
    const b = [y[0]];
    let w = 0;
    for (; w < v.length; )
      o(b, v[w]), b.push(y[++w]);
    return new n(b);
  }
  e._ = i;
  const a = new n("+");
  function s(y, ...v) {
    const b = [d(y[0])];
    let w = 0;
    for (; w < v.length; )
      b.push(a), o(b, v[w]), b.push(a, d(y[++w]));
    return l(b), new n(b);
  }
  e.str = s;
  function o(y, v) {
    v instanceof n ? y.push(...v._items) : v instanceof r ? y.push(v) : y.push(f(v));
  }
  e.addCodeArg = o;
  function l(y) {
    let v = 1;
    for (; v < y.length - 1; ) {
      if (y[v] === a) {
        const b = c(y[v - 1], y[v + 1]);
        if (b !== void 0) {
          y.splice(v - 1, 3, b);
          continue;
        }
        y[v++] = "+";
      }
      v++;
    }
  }
  function c(y, v) {
    if (v === '""')
      return y;
    if (y === '""')
      return v;
    if (typeof y == "string")
      return v instanceof r || y[y.length - 1] !== '"' ? void 0 : typeof v != "string" ? `${y.slice(0, -1)}${v}"` : v[0] === '"' ? y.slice(0, -1) + v.slice(1) : void 0;
    if (typeof v == "string" && v[0] === '"' && !(y instanceof r))
      return `"${y}${v.slice(1)}`;
  }
  function u(y, v) {
    return v.emptyStr() ? y : y.emptyStr() ? v : s`${y}${v}`;
  }
  e.strConcat = u;
  function f(y) {
    return typeof y == "number" || typeof y == "boolean" || y === null ? y : d(Array.isArray(y) ? y.join(",") : y);
  }
  function p(y) {
    return new n(d(y));
  }
  e.stringify = p;
  function d(y) {
    return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = d;
  function m(y) {
    return typeof y == "string" && e.IDENTIFIER.test(y) ? new n(`.${y}`) : i`[${y}]`;
  }
  e.getProperty = m;
  function h(y) {
    if (typeof y == "string" && e.IDENTIFIER.test(y))
      return new n(`${y}`);
    throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
  }
  e.getEsmExportName = h;
  function g(y) {
    return new n(y.toString());
  }
  e.regexpCode = g;
})(on);
var la = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
  const t = on;
  class r extends Error {
    constructor(c) {
      super(`CodeGen: "code" for ${c} not defined`), this.value = c.value;
    }
  }
  var n;
  (function(l) {
    l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
  })(n = e.UsedValueState || (e.UsedValueState = {})), e.varKinds = {
    const: new t.Name("const"),
    let: new t.Name("let"),
    var: new t.Name("var")
  };
  class i {
    constructor({ prefixes: c, parent: u } = {}) {
      this._names = {}, this._prefixes = c, this._parent = u;
    }
    toName(c) {
      return c instanceof t.Name ? c : this.name(c);
    }
    name(c) {
      return new t.Name(this._newName(c));
    }
    _newName(c) {
      const u = this._names[c] || this._nameGroup(c);
      return `${c}${u.index++}`;
    }
    _nameGroup(c) {
      var u, f;
      if (!((f = (u = this._parent) === null || u === void 0 ? void 0 : u._prefixes) === null || f === void 0) && f.has(c) || this._prefixes && !this._prefixes.has(c))
        throw new Error(`CodeGen: prefix "${c}" is not allowed in this scope`);
      return this._names[c] = { prefix: c, index: 0 };
    }
  }
  e.Scope = i;
  class a extends t.Name {
    constructor(c, u) {
      super(u), this.prefix = c;
    }
    setValue(c, { property: u, itemIndex: f }) {
      this.value = c, this.scopePath = (0, t._)`.${new t.Name(u)}[${f}]`;
    }
  }
  e.ValueScopeName = a;
  const s = (0, t._)`\n`;
  class o extends i {
    constructor(c) {
      super(c), this._values = {}, this._scope = c.scope, this.opts = { ...c, _n: c.lines ? s : t.nil };
    }
    get() {
      return this._scope;
    }
    name(c) {
      return new a(c, this._newName(c));
    }
    value(c, u) {
      var f;
      if (u.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const p = this.toName(c), { prefix: d } = p, m = (f = u.key) !== null && f !== void 0 ? f : u.ref;
      let h = this._values[d];
      if (h) {
        const v = h.get(m);
        if (v)
          return v;
      } else
        h = this._values[d] = /* @__PURE__ */ new Map();
      h.set(m, p);
      const g = this._scope[d] || (this._scope[d] = []), y = g.length;
      return g[y] = u.ref, p.setValue(u, { property: d, itemIndex: y }), p;
    }
    getValue(c, u) {
      const f = this._values[c];
      if (f)
        return f.get(u);
    }
    scopeRefs(c, u = this._values) {
      return this._reduceValues(u, (f) => {
        if (f.scopePath === void 0)
          throw new Error(`CodeGen: name "${f}" has no value`);
        return (0, t._)`${c}${f.scopePath}`;
      });
    }
    scopeCode(c = this._values, u, f) {
      return this._reduceValues(c, (p) => {
        if (p.value === void 0)
          throw new Error(`CodeGen: name "${p}" has no value`);
        return p.value.code;
      }, u, f);
    }
    _reduceValues(c, u, f = {}, p) {
      let d = t.nil;
      for (const m in c) {
        const h = c[m];
        if (!h)
          continue;
        const g = f[m] = f[m] || /* @__PURE__ */ new Map();
        h.forEach((y) => {
          if (g.has(y))
            return;
          g.set(y, n.Started);
          let v = u(y);
          if (v) {
            const b = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            d = (0, t._)`${d}${b} ${y} = ${v};${this.opts._n}`;
          } else if (v = p == null ? void 0 : p(y))
            d = (0, t._)`${d}${v}${this.opts._n}`;
          else
            throw new r(y);
          g.set(y, n.Completed);
        });
      }
      return d;
    }
  }
  e.ValueScope = o;
})(la);
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
  const t = on, r = la;
  var n = on;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var i = la;
  Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
    return i.Scope;
  } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
    return i.varKinds;
  } }), e.operators = {
    GT: new t._Code(">"),
    GTE: new t._Code(">="),
    LT: new t._Code("<"),
    LTE: new t._Code("<="),
    EQ: new t._Code("==="),
    NEQ: new t._Code("!=="),
    NOT: new t._Code("!"),
    OR: new t._Code("||"),
    AND: new t._Code("&&"),
    ADD: new t._Code("+")
  };
  class a {
    optimizeNodes() {
      return this;
    }
    optimizeNames($, P) {
      return this;
    }
  }
  class s extends a {
    constructor($, P, M) {
      super(), this.varKind = $, this.name = P, this.rhs = M;
    }
    render({ es5: $, _n: P }) {
      const M = $ ? r.varKinds.var : this.varKind, B = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${M} ${this.name}${B};` + P;
    }
    optimizeNames($, P) {
      if ($[this.name.str])
        return this.rhs && (this.rhs = z(this.rhs, $, P)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends a {
    constructor($, P, M) {
      super(), this.lhs = $, this.rhs = P, this.sideEffects = M;
    }
    render({ _n: $ }) {
      return `${this.lhs} = ${this.rhs};` + $;
    }
    optimizeNames($, P) {
      if (!(this.lhs instanceof t.Name && !$[this.lhs.str] && !this.sideEffects))
        return this.rhs = z(this.rhs, $, P), this;
    }
    get names() {
      const $ = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return W($, this.rhs);
    }
  }
  class l extends o {
    constructor($, P, M, B) {
      super($, M, B), this.op = P;
    }
    render({ _n: $ }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + $;
    }
  }
  class c extends a {
    constructor($) {
      super(), this.label = $, this.names = {};
    }
    render({ _n: $ }) {
      return `${this.label}:` + $;
    }
  }
  class u extends a {
    constructor($) {
      super(), this.label = $, this.names = {};
    }
    render({ _n: $ }) {
      return `break${this.label ? ` ${this.label}` : ""};` + $;
    }
  }
  class f extends a {
    constructor($) {
      super(), this.error = $;
    }
    render({ _n: $ }) {
      return `throw ${this.error};` + $;
    }
    get names() {
      return this.error.names;
    }
  }
  class p extends a {
    constructor($) {
      super(), this.code = $;
    }
    render({ _n: $ }) {
      return `${this.code};` + $;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames($, P) {
      return this.code = z(this.code, $, P), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class d extends a {
    constructor($ = []) {
      super(), this.nodes = $;
    }
    render($) {
      return this.nodes.reduce((P, M) => P + M.render($), "");
    }
    optimizeNodes() {
      const { nodes: $ } = this;
      let P = $.length;
      for (; P--; ) {
        const M = $[P].optimizeNodes();
        Array.isArray(M) ? $.splice(P, 1, ...M) : M ? $[P] = M : $.splice(P, 1);
      }
      return $.length > 0 ? this : void 0;
    }
    optimizeNames($, P) {
      const { nodes: M } = this;
      let B = M.length;
      for (; B--; ) {
        const K = M[B];
        K.optimizeNames($, P) || (q($, K.names), M.splice(B, 1));
      }
      return M.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce(($, P) => U($, P.names), {});
    }
  }
  class m extends d {
    render($) {
      return "{" + $._n + super.render($) + "}" + $._n;
    }
  }
  class h extends d {
  }
  class g extends m {
  }
  g.kind = "else";
  class y extends m {
    constructor($, P) {
      super(P), this.condition = $;
    }
    render($) {
      let P = `if(${this.condition})` + super.render($);
      return this.else && (P += "else " + this.else.render($)), P;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const $ = this.condition;
      if ($ === !0)
        return this.nodes;
      let P = this.else;
      if (P) {
        const M = P.optimizeNodes();
        P = this.else = Array.isArray(M) ? new g(M) : M;
      }
      if (P)
        return $ === !1 ? P instanceof y ? P : P.nodes : this.nodes.length ? this : new y(ue($), P instanceof y ? [P] : P.nodes);
      if (!($ === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames($, P) {
      var M;
      if (this.else = (M = this.else) === null || M === void 0 ? void 0 : M.optimizeNames($, P), !!(super.optimizeNames($, P) || this.else))
        return this.condition = z(this.condition, $, P), this;
    }
    get names() {
      const $ = super.names;
      return W($, this.condition), this.else && U($, this.else.names), $;
    }
  }
  y.kind = "if";
  class v extends m {
  }
  v.kind = "for";
  class b extends v {
    constructor($) {
      super(), this.iteration = $;
    }
    render($) {
      return `for(${this.iteration})` + super.render($);
    }
    optimizeNames($, P) {
      if (super.optimizeNames($, P))
        return this.iteration = z(this.iteration, $, P), this;
    }
    get names() {
      return U(super.names, this.iteration.names);
    }
  }
  class w extends v {
    constructor($, P, M, B) {
      super(), this.varKind = $, this.name = P, this.from = M, this.to = B;
    }
    render($) {
      const P = $.es5 ? r.varKinds.var : this.varKind, { name: M, from: B, to: K } = this;
      return `for(${P} ${M}=${B}; ${M}<${K}; ${M}++)` + super.render($);
    }
    get names() {
      const $ = W(super.names, this.from);
      return W($, this.to);
    }
  }
  class C extends v {
    constructor($, P, M, B) {
      super(), this.loop = $, this.varKind = P, this.name = M, this.iterable = B;
    }
    render($) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render($);
    }
    optimizeNames($, P) {
      if (super.optimizeNames($, P))
        return this.iterable = z(this.iterable, $, P), this;
    }
    get names() {
      return U(super.names, this.iterable.names);
    }
  }
  class E extends m {
    constructor($, P, M) {
      super(), this.name = $, this.args = P, this.async = M;
    }
    render($) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render($);
    }
  }
  E.kind = "func";
  class _ extends d {
    render($) {
      return "return " + super.render($);
    }
  }
  _.kind = "return";
  class T extends m {
    render($) {
      let P = "try" + super.render($);
      return this.catch && (P += this.catch.render($)), this.finally && (P += this.finally.render($)), P;
    }
    optimizeNodes() {
      var $, P;
      return super.optimizeNodes(), ($ = this.catch) === null || $ === void 0 || $.optimizeNodes(), (P = this.finally) === null || P === void 0 || P.optimizeNodes(), this;
    }
    optimizeNames($, P) {
      var M, B;
      return super.optimizeNames($, P), (M = this.catch) === null || M === void 0 || M.optimizeNames($, P), (B = this.finally) === null || B === void 0 || B.optimizeNames($, P), this;
    }
    get names() {
      const $ = super.names;
      return this.catch && U($, this.catch.names), this.finally && U($, this.finally.names), $;
    }
  }
  class F extends m {
    constructor($) {
      super(), this.error = $;
    }
    render($) {
      return `catch(${this.error})` + super.render($);
    }
  }
  F.kind = "catch";
  class j extends m {
    render($) {
      return "finally" + super.render($);
    }
  }
  j.kind = "finally";
  class L {
    constructor($, P = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...P, _n: P.lines ? `
` : "" }, this._extScope = $, this._scope = new r.Scope({ parent: $ }), this._nodes = [new h()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name($) {
      return this._scope.name($);
    }
    // reserves unique name in the external scope
    scopeName($) {
      return this._extScope.name($);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue($, P) {
      const M = this._extScope.value($, P);
      return (this._values[M.prefix] || (this._values[M.prefix] = /* @__PURE__ */ new Set())).add(M), M;
    }
    getScopeValue($, P) {
      return this._extScope.getValue($, P);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs($) {
      return this._extScope.scopeRefs($, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def($, P, M, B) {
      const K = this._scope.toName(P);
      return M !== void 0 && B && (this._constants[K.str] = M), this._leafNode(new s($, K, M)), K;
    }
    // `const` declaration (`var` in es5 mode)
    const($, P, M) {
      return this._def(r.varKinds.const, $, P, M);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let($, P, M) {
      return this._def(r.varKinds.let, $, P, M);
    }
    // `var` declaration with optional assignment
    var($, P, M) {
      return this._def(r.varKinds.var, $, P, M);
    }
    // assignment code
    assign($, P, M) {
      return this._leafNode(new o($, P, M));
    }
    // `+=` code
    add($, P) {
      return this._leafNode(new l($, e.operators.ADD, P));
    }
    // appends passed SafeExpr to code or executes Block
    code($) {
      return typeof $ == "function" ? $() : $ !== t.nil && this._leafNode(new p($)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...$) {
      const P = ["{"];
      for (const [M, B] of $)
        P.length > 1 && P.push(","), P.push(M), (M !== B || this.opts.es5) && (P.push(":"), (0, t.addCodeArg)(P, B));
      return P.push("}"), new t._Code(P);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if($, P, M) {
      if (this._blockNode(new y($)), P && M)
        this.code(P).else().code(M).endIf();
      else if (P)
        this.code(P).endIf();
      else if (M)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf($) {
      return this._elseNode(new y($));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new g());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(y, g);
    }
    _for($, P) {
      return this._blockNode($), P && this.code(P).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for($, P) {
      return this._for(new b($), P);
    }
    // `for` statement for a range of values
    forRange($, P, M, B, K = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const te = this._scope.toName($);
      return this._for(new w(K, te, P, M), () => B(te));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf($, P, M, B = r.varKinds.const) {
      const K = this._scope.toName($);
      if (this.opts.es5) {
        const te = P instanceof t.Name ? P : this.var("_arr", P);
        return this.forRange("_i", 0, (0, t._)`${te}.length`, (ae) => {
          this.var(K, (0, t._)`${te}[${ae}]`), M(K);
        });
      }
      return this._for(new C("of", B, K, P), () => M(K));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn($, P, M, B = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf($, (0, t._)`Object.keys(${P})`, M);
      const K = this._scope.toName($);
      return this._for(new C("in", B, K, P), () => M(K));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(v);
    }
    // `label` statement
    label($) {
      return this._leafNode(new c($));
    }
    // `break` statement
    break($) {
      return this._leafNode(new u($));
    }
    // `return` statement
    return($) {
      const P = new _();
      if (this._blockNode(P), this.code($), P.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(_);
    }
    // `try` statement
    try($, P, M) {
      if (!P && !M)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const B = new T();
      if (this._blockNode(B), this.code($), P) {
        const K = this.name("e");
        this._currNode = B.catch = new F(K), P(K);
      }
      return M && (this._currNode = B.finally = new j(), this.code(M)), this._endBlockNode(F, j);
    }
    // `throw` statement
    throw($) {
      return this._leafNode(new f($));
    }
    // start self-balancing block
    block($, P) {
      return this._blockStarts.push(this._nodes.length), $ && this.code($).endBlock(P), this;
    }
    // end the current self-balancing block
    endBlock($) {
      const P = this._blockStarts.pop();
      if (P === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const M = this._nodes.length - P;
      if (M < 0 || $ !== void 0 && M !== $)
        throw new Error(`CodeGen: wrong number of nodes: ${M} vs ${$} expected`);
      return this._nodes.length = P, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func($, P = t.nil, M, B) {
      return this._blockNode(new E($, P, M)), B && this.code(B).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode(E);
    }
    optimize($ = 1) {
      for (; $-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode($) {
      return this._currNode.nodes.push($), this;
    }
    _blockNode($) {
      this._currNode.nodes.push($), this._nodes.push($);
    }
    _endBlockNode($, P) {
      const M = this._currNode;
      if (M instanceof $ || P && M instanceof P)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${P ? `${$.kind}/${P.kind}` : $.kind}"`);
    }
    _elseNode($) {
      const P = this._currNode;
      if (!(P instanceof y))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = P.else = $, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const $ = this._nodes;
      return $[$.length - 1];
    }
    set _currNode($) {
      const P = this._nodes;
      P[P.length - 1] = $;
    }
  }
  e.CodeGen = L;
  function U(D, $) {
    for (const P in $)
      D[P] = (D[P] || 0) + ($[P] || 0);
    return D;
  }
  function W(D, $) {
    return $ instanceof t._CodeOrName ? U(D, $.names) : D;
  }
  function z(D, $, P) {
    if (D instanceof t.Name)
      return M(D);
    if (!B(D))
      return D;
    return new t._Code(D._items.reduce((K, te) => (te instanceof t.Name && (te = M(te)), te instanceof t._Code ? K.push(...te._items) : K.push(te), K), []));
    function M(K) {
      const te = P[K.str];
      return te === void 0 || $[K.str] !== 1 ? K : (delete $[K.str], te);
    }
    function B(K) {
      return K instanceof t._Code && K._items.some((te) => te instanceof t.Name && $[te.str] === 1 && P[te.str] !== void 0);
    }
  }
  function q(D, $) {
    for (const P in $)
      D[P] = (D[P] || 0) - ($[P] || 0);
  }
  function ue(D) {
    return typeof D == "boolean" || typeof D == "number" || D === null ? !D : (0, t._)`!${x(D)}`;
  }
  e.not = ue;
  const me = N(e.operators.AND);
  function ie(...D) {
    return D.reduce(me);
  }
  e.and = ie;
  const Y = N(e.operators.OR);
  function V(...D) {
    return D.reduce(Y);
  }
  e.or = V;
  function N(D) {
    return ($, P) => $ === t.nil ? P : P === t.nil ? $ : (0, t._)`${x($)} ${D} ${x(P)}`;
  }
  function x(D) {
    return D instanceof t.Name ? D : (0, t._)`(${D})`;
  }
})(re);
var fe = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.checkStrictMode = e.getErrorPath = e.Type = e.useFunc = e.setEvaluated = e.evaluatedPropsToName = e.mergeEvaluated = e.eachItem = e.unescapeJsonPointer = e.escapeJsonPointer = e.escapeFragment = e.unescapeFragment = e.schemaRefOrVal = e.schemaHasRulesButRef = e.schemaHasRules = e.checkUnknownRules = e.alwaysValidSchema = e.toHash = void 0;
  const t = re, r = on;
  function n(E) {
    const _ = {};
    for (const T of E)
      _[T] = !0;
    return _;
  }
  e.toHash = n;
  function i(E, _) {
    return typeof _ == "boolean" ? _ : Object.keys(_).length === 0 ? !0 : (a(E, _), !s(_, E.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function a(E, _ = E.schema) {
    const { opts: T, self: F } = E;
    if (!T.strictSchema || typeof _ == "boolean")
      return;
    const j = F.RULES.keywords;
    for (const L in _)
      j[L] || C(E, `unknown keyword: "${L}"`);
  }
  e.checkUnknownRules = a;
  function s(E, _) {
    if (typeof E == "boolean")
      return !E;
    for (const T in E)
      if (_[T])
        return !0;
    return !1;
  }
  e.schemaHasRules = s;
  function o(E, _) {
    if (typeof E == "boolean")
      return !E;
    for (const T in E)
      if (T !== "$ref" && _.all[T])
        return !0;
    return !1;
  }
  e.schemaHasRulesButRef = o;
  function l({ topSchemaRef: E, schemaPath: _ }, T, F, j) {
    if (!j) {
      if (typeof T == "number" || typeof T == "boolean")
        return T;
      if (typeof T == "string")
        return (0, t._)`${T}`;
    }
    return (0, t._)`${E}${_}${(0, t.getProperty)(F)}`;
  }
  e.schemaRefOrVal = l;
  function c(E) {
    return p(decodeURIComponent(E));
  }
  e.unescapeFragment = c;
  function u(E) {
    return encodeURIComponent(f(E));
  }
  e.escapeFragment = u;
  function f(E) {
    return typeof E == "number" ? `${E}` : E.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = f;
  function p(E) {
    return E.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = p;
  function d(E, _) {
    if (Array.isArray(E))
      for (const T of E)
        _(T);
    else
      _(E);
  }
  e.eachItem = d;
  function m({ mergeNames: E, mergeToName: _, mergeValues: T, resultToName: F }) {
    return (j, L, U, W) => {
      const z = U === void 0 ? L : U instanceof t.Name ? (L instanceof t.Name ? E(j, L, U) : _(j, L, U), U) : L instanceof t.Name ? (_(j, U, L), L) : T(L, U);
      return W === t.Name && !(z instanceof t.Name) ? F(j, z) : z;
    };
  }
  e.mergeEvaluated = {
    props: m({
      mergeNames: (E, _, T) => E.if((0, t._)`${T} !== true && ${_} !== undefined`, () => {
        E.if((0, t._)`${_} === true`, () => E.assign(T, !0), () => E.assign(T, (0, t._)`${T} || {}`).code((0, t._)`Object.assign(${T}, ${_})`));
      }),
      mergeToName: (E, _, T) => E.if((0, t._)`${T} !== true`, () => {
        _ === !0 ? E.assign(T, !0) : (E.assign(T, (0, t._)`${T} || {}`), g(E, T, _));
      }),
      mergeValues: (E, _) => E === !0 ? !0 : { ...E, ..._ },
      resultToName: h
    }),
    items: m({
      mergeNames: (E, _, T) => E.if((0, t._)`${T} !== true && ${_} !== undefined`, () => E.assign(T, (0, t._)`${_} === true ? true : ${T} > ${_} ? ${T} : ${_}`)),
      mergeToName: (E, _, T) => E.if((0, t._)`${T} !== true`, () => E.assign(T, _ === !0 ? !0 : (0, t._)`${T} > ${_} ? ${T} : ${_}`)),
      mergeValues: (E, _) => E === !0 ? !0 : Math.max(E, _),
      resultToName: (E, _) => E.var("items", _)
    })
  };
  function h(E, _) {
    if (_ === !0)
      return E.var("props", !0);
    const T = E.var("props", (0, t._)`{}`);
    return _ !== void 0 && g(E, T, _), T;
  }
  e.evaluatedPropsToName = h;
  function g(E, _, T) {
    Object.keys(T).forEach((F) => E.assign((0, t._)`${_}${(0, t.getProperty)(F)}`, !0));
  }
  e.setEvaluated = g;
  const y = {};
  function v(E, _) {
    return E.scopeValue("func", {
      ref: _,
      code: y[_.code] || (y[_.code] = new r._Code(_.code))
    });
  }
  e.useFunc = v;
  var b;
  (function(E) {
    E[E.Num = 0] = "Num", E[E.Str = 1] = "Str";
  })(b = e.Type || (e.Type = {}));
  function w(E, _, T) {
    if (E instanceof t.Name) {
      const F = _ === b.Num;
      return T ? F ? (0, t._)`"[" + ${E} + "]"` : (0, t._)`"['" + ${E} + "']"` : F ? (0, t._)`"/" + ${E}` : (0, t._)`"/" + ${E}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return T ? (0, t.getProperty)(E).toString() : "/" + f(E);
  }
  e.getErrorPath = w;
  function C(E, _, T = E.opts.strictSchema) {
    if (T) {
      if (_ = `strict mode: ${_}`, T === !0)
        throw new Error(_);
      E.self.logger.warn(_);
    }
  }
  e.checkStrictMode = C;
})(fe);
var vt = {};
Object.defineProperty(vt, "__esModule", { value: !0 });
const Me = re, lE = {
  // validation function arguments
  data: new Me.Name("data"),
  // args passed from referencing schema
  valCxt: new Me.Name("valCxt"),
  instancePath: new Me.Name("instancePath"),
  parentData: new Me.Name("parentData"),
  parentDataProperty: new Me.Name("parentDataProperty"),
  rootData: new Me.Name("rootData"),
  dynamicAnchors: new Me.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new Me.Name("vErrors"),
  errors: new Me.Name("errors"),
  this: new Me.Name("this"),
  // "globals"
  self: new Me.Name("self"),
  scope: new Me.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new Me.Name("json"),
  jsonPos: new Me.Name("jsonPos"),
  jsonLen: new Me.Name("jsonLen"),
  jsonPart: new Me.Name("jsonPart")
};
vt.default = lE;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
  const t = re, r = fe, n = vt;
  e.keywordError = {
    message: ({ keyword: g }) => (0, t.str)`must pass "${g}" keyword validation`
  }, e.keyword$DataError = {
    message: ({ keyword: g, schemaType: y }) => y ? (0, t.str)`"${g}" keyword must be ${y} ($data)` : (0, t.str)`"${g}" keyword is invalid ($data)`
  };
  function i(g, y = e.keywordError, v, b) {
    const { it: w } = g, { gen: C, compositeRule: E, allErrors: _ } = w, T = f(g, y, v);
    b ?? (E || _) ? l(C, T) : c(w, (0, t._)`[${T}]`);
  }
  e.reportError = i;
  function a(g, y = e.keywordError, v) {
    const { it: b } = g, { gen: w, compositeRule: C, allErrors: E } = b, _ = f(g, y, v);
    l(w, _), C || E || c(b, n.default.vErrors);
  }
  e.reportExtraError = a;
  function s(g, y) {
    g.assign(n.default.errors, y), g.if((0, t._)`${n.default.vErrors} !== null`, () => g.if(y, () => g.assign((0, t._)`${n.default.vErrors}.length`, y), () => g.assign(n.default.vErrors, null)));
  }
  e.resetErrorsCount = s;
  function o({ gen: g, keyword: y, schemaValue: v, data: b, errsCount: w, it: C }) {
    if (w === void 0)
      throw new Error("ajv implementation error");
    const E = g.name("err");
    g.forRange("i", w, n.default.errors, (_) => {
      g.const(E, (0, t._)`${n.default.vErrors}[${_}]`), g.if((0, t._)`${E}.instancePath === undefined`, () => g.assign((0, t._)`${E}.instancePath`, (0, t.strConcat)(n.default.instancePath, C.errorPath))), g.assign((0, t._)`${E}.schemaPath`, (0, t.str)`${C.errSchemaPath}/${y}`), C.opts.verbose && (g.assign((0, t._)`${E}.schema`, v), g.assign((0, t._)`${E}.data`, b));
    });
  }
  e.extendErrors = o;
  function l(g, y) {
    const v = g.const("err", y);
    g.if((0, t._)`${n.default.vErrors} === null`, () => g.assign(n.default.vErrors, (0, t._)`[${v}]`), (0, t._)`${n.default.vErrors}.push(${v})`), g.code((0, t._)`${n.default.errors}++`);
  }
  function c(g, y) {
    const { gen: v, validateName: b, schemaEnv: w } = g;
    w.$async ? v.throw((0, t._)`new ${g.ValidationError}(${y})`) : (v.assign((0, t._)`${b}.errors`, y), v.return(!1));
  }
  const u = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema")
  };
  function f(g, y, v) {
    const { createErrors: b } = g.it;
    return b === !1 ? (0, t._)`{}` : p(g, y, v);
  }
  function p(g, y, v = {}) {
    const { gen: b, it: w } = g, C = [
      d(w, v),
      m(g, v)
    ];
    return h(g, y, C), b.object(...C);
  }
  function d({ errorPath: g }, { instancePath: y }) {
    const v = y ? (0, t.str)`${g}${(0, r.getErrorPath)(y, r.Type.Str)}` : g;
    return [n.default.instancePath, (0, t.strConcat)(n.default.instancePath, v)];
  }
  function m({ keyword: g, it: { errSchemaPath: y } }, { schemaPath: v, parentSchema: b }) {
    let w = b ? y : (0, t.str)`${y}/${g}`;
    return v && (w = (0, t.str)`${w}${(0, r.getErrorPath)(v, r.Type.Str)}`), [u.schemaPath, w];
  }
  function h(g, { params: y, message: v }, b) {
    const { keyword: w, data: C, schemaValue: E, it: _ } = g, { opts: T, propertyName: F, topSchemaRef: j, schemaPath: L } = _;
    b.push([u.keyword, w], [u.params, typeof y == "function" ? y(g) : y || (0, t._)`{}`]), T.messages && b.push([u.message, typeof v == "function" ? v(g) : v]), T.verbose && b.push([u.schema, E], [u.parentSchema, (0, t._)`${j}${L}`], [n.default.data, C]), F && b.push([u.propertyName, F]);
  }
})($n);
Object.defineProperty(Tr, "__esModule", { value: !0 });
Tr.boolOrEmptySchema = Tr.topBoolOrEmptySchema = void 0;
const cE = $n, uE = re, dE = vt, fE = {
  message: "boolean schema is false"
};
function hE(e) {
  const { gen: t, schema: r, validateName: n } = e;
  r === !1 ? Ru(e, !1) : typeof r == "object" && r.$async === !0 ? t.return(dE.default.data) : (t.assign((0, uE._)`${n}.errors`, null), t.return(!0));
}
Tr.topBoolOrEmptySchema = hE;
function mE(e, t) {
  const { gen: r, schema: n } = e;
  n === !1 ? (r.var(t, !1), Ru(e)) : r.var(t, !0);
}
Tr.boolOrEmptySchema = mE;
function Ru(e, t) {
  const { gen: r, data: n } = e, i = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: e
  };
  (0, cE.reportError)(i, fE, void 0, t);
}
var _n = {}, or = {};
Object.defineProperty(or, "__esModule", { value: !0 });
or.getRules = or.isJSONType = void 0;
const pE = ["string", "number", "integer", "boolean", "null", "object", "array"], yE = new Set(pE);
function gE(e) {
  return typeof e == "string" && yE.has(e);
}
or.isJSONType = gE;
function vE() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
or.getRules = vE;
var Ot = {};
Object.defineProperty(Ot, "__esModule", { value: !0 });
Ot.shouldUseRule = Ot.shouldUseGroup = Ot.schemaHasRulesForType = void 0;
function $E({ schema: e, self: t }, r) {
  const n = t.RULES.types[r];
  return n && n !== !0 && Mu(e, n);
}
Ot.schemaHasRulesForType = $E;
function Mu(e, t) {
  return t.rules.some((r) => ju(e, r));
}
Ot.shouldUseGroup = Mu;
function ju(e, t) {
  var r;
  return e[t.keyword] !== void 0 || ((r = t.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => e[n] !== void 0));
}
Ot.shouldUseRule = ju;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.reportTypeError = e.checkDataTypes = e.checkDataType = e.coerceAndCheckDataType = e.getJSONTypes = e.getSchemaTypes = e.DataType = void 0;
  const t = or, r = Ot, n = $n, i = re, a = fe;
  var s;
  (function(b) {
    b[b.Correct = 0] = "Correct", b[b.Wrong = 1] = "Wrong";
  })(s = e.DataType || (e.DataType = {}));
  function o(b) {
    const w = l(b.type);
    if (w.includes("null")) {
      if (b.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!w.length && b.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      b.nullable === !0 && w.push("null");
    }
    return w;
  }
  e.getSchemaTypes = o;
  function l(b) {
    const w = Array.isArray(b) ? b : b ? [b] : [];
    if (w.every(t.isJSONType))
      return w;
    throw new Error("type must be JSONType or JSONType[]: " + w.join(","));
  }
  e.getJSONTypes = l;
  function c(b, w) {
    const { gen: C, data: E, opts: _ } = b, T = f(w, _.coerceTypes), F = w.length > 0 && !(T.length === 0 && w.length === 1 && (0, r.schemaHasRulesForType)(b, w[0]));
    if (F) {
      const j = h(w, E, _.strictNumbers, s.Wrong);
      C.if(j, () => {
        T.length ? p(b, w, T) : y(b);
      });
    }
    return F;
  }
  e.coerceAndCheckDataType = c;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function f(b, w) {
    return w ? b.filter((C) => u.has(C) || w === "array" && C === "array") : [];
  }
  function p(b, w, C) {
    const { gen: E, data: _, opts: T } = b, F = E.let("dataType", (0, i._)`typeof ${_}`), j = E.let("coerced", (0, i._)`undefined`);
    T.coerceTypes === "array" && E.if((0, i._)`${F} == 'object' && Array.isArray(${_}) && ${_}.length == 1`, () => E.assign(_, (0, i._)`${_}[0]`).assign(F, (0, i._)`typeof ${_}`).if(h(w, _, T.strictNumbers), () => E.assign(j, _))), E.if((0, i._)`${j} !== undefined`);
    for (const U of C)
      (u.has(U) || U === "array" && T.coerceTypes === "array") && L(U);
    E.else(), y(b), E.endIf(), E.if((0, i._)`${j} !== undefined`, () => {
      E.assign(_, j), d(b, j);
    });
    function L(U) {
      switch (U) {
        case "string":
          E.elseIf((0, i._)`${F} == "number" || ${F} == "boolean"`).assign(j, (0, i._)`"" + ${_}`).elseIf((0, i._)`${_} === null`).assign(j, (0, i._)`""`);
          return;
        case "number":
          E.elseIf((0, i._)`${F} == "boolean" || ${_} === null
              || (${F} == "string" && ${_} && ${_} == +${_})`).assign(j, (0, i._)`+${_}`);
          return;
        case "integer":
          E.elseIf((0, i._)`${F} === "boolean" || ${_} === null
              || (${F} === "string" && ${_} && ${_} == +${_} && !(${_} % 1))`).assign(j, (0, i._)`+${_}`);
          return;
        case "boolean":
          E.elseIf((0, i._)`${_} === "false" || ${_} === 0 || ${_} === null`).assign(j, !1).elseIf((0, i._)`${_} === "true" || ${_} === 1`).assign(j, !0);
          return;
        case "null":
          E.elseIf((0, i._)`${_} === "" || ${_} === 0 || ${_} === false`), E.assign(j, null);
          return;
        case "array":
          E.elseIf((0, i._)`${F} === "string" || ${F} === "number"
              || ${F} === "boolean" || ${_} === null`).assign(j, (0, i._)`[${_}]`);
      }
    }
  }
  function d({ gen: b, parentData: w, parentDataProperty: C }, E) {
    b.if((0, i._)`${w} !== undefined`, () => b.assign((0, i._)`${w}[${C}]`, E));
  }
  function m(b, w, C, E = s.Correct) {
    const _ = E === s.Correct ? i.operators.EQ : i.operators.NEQ;
    let T;
    switch (b) {
      case "null":
        return (0, i._)`${w} ${_} null`;
      case "array":
        T = (0, i._)`Array.isArray(${w})`;
        break;
      case "object":
        T = (0, i._)`${w} && typeof ${w} == "object" && !Array.isArray(${w})`;
        break;
      case "integer":
        T = F((0, i._)`!(${w} % 1) && !isNaN(${w})`);
        break;
      case "number":
        T = F();
        break;
      default:
        return (0, i._)`typeof ${w} ${_} ${b}`;
    }
    return E === s.Correct ? T : (0, i.not)(T);
    function F(j = i.nil) {
      return (0, i.and)((0, i._)`typeof ${w} == "number"`, j, C ? (0, i._)`isFinite(${w})` : i.nil);
    }
  }
  e.checkDataType = m;
  function h(b, w, C, E) {
    if (b.length === 1)
      return m(b[0], w, C, E);
    let _;
    const T = (0, a.toHash)(b);
    if (T.array && T.object) {
      const F = (0, i._)`typeof ${w} != "object"`;
      _ = T.null ? F : (0, i._)`!${w} || ${F}`, delete T.null, delete T.array, delete T.object;
    } else
      _ = i.nil;
    T.number && delete T.integer;
    for (const F in T)
      _ = (0, i.and)(_, m(F, w, C, E));
    return _;
  }
  e.checkDataTypes = h;
  const g = {
    message: ({ schema: b }) => `must be ${b}`,
    params: ({ schema: b, schemaValue: w }) => typeof b == "string" ? (0, i._)`{type: ${b}}` : (0, i._)`{type: ${w}}`
  };
  function y(b) {
    const w = v(b);
    (0, n.reportError)(w, g);
  }
  e.reportTypeError = y;
  function v(b) {
    const { gen: w, data: C, schema: E } = b, _ = (0, a.schemaRefOrVal)(b, E, "type");
    return {
      gen: w,
      keyword: "type",
      data: C,
      schema: E.type,
      schemaCode: _,
      schemaValue: _,
      parentSchema: E,
      params: {},
      it: b
    };
  }
})(_n);
var Oi = {};
Object.defineProperty(Oi, "__esModule", { value: !0 });
Oi.assignDefaults = void 0;
const gr = re, _E = fe;
function bE(e, t) {
  const { properties: r, items: n } = e.schema;
  if (t === "object" && r)
    for (const i in r)
      al(e, i, r[i].default);
  else
    t === "array" && Array.isArray(n) && n.forEach((i, a) => al(e, a, i.default));
}
Oi.assignDefaults = bE;
function al(e, t, r) {
  const { gen: n, compositeRule: i, data: a, opts: s } = e;
  if (r === void 0)
    return;
  const o = (0, gr._)`${a}${(0, gr.getProperty)(t)}`;
  if (i) {
    (0, _E.checkStrictMode)(e, `default is ignored for: ${o}`);
    return;
  }
  let l = (0, gr._)`${o} === undefined`;
  s.useDefaults === "empty" && (l = (0, gr._)`${l} || ${o} === null || ${o} === ""`), n.if(l, (0, gr._)`${o} = ${(0, gr.stringify)(r)}`);
}
var gt = {}, ne = {};
Object.defineProperty(ne, "__esModule", { value: !0 });
ne.validateUnion = ne.validateArray = ne.usePattern = ne.callValidateCode = ne.schemaProperties = ne.allSchemaProperties = ne.noPropertyInData = ne.propertyInData = ne.isOwnProperty = ne.hasPropFunc = ne.reportMissingProp = ne.checkMissingProp = ne.checkReportMissingProp = void 0;
const ve = re, ls = fe, Ft = vt, SE = fe;
function wE(e, t) {
  const { gen: r, data: n, it: i } = e;
  r.if(us(r, n, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, ve._)`${t}` }, !0), e.error();
  });
}
ne.checkReportMissingProp = wE;
function EE({ gen: e, data: t, it: { opts: r } }, n, i) {
  return (0, ve.or)(...n.map((a) => (0, ve.and)(us(e, t, a, r.ownProperties), (0, ve._)`${i} = ${a}`)));
}
ne.checkMissingProp = EE;
function OE(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
ne.reportMissingProp = OE;
function Uu(e) {
  return e.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, ve._)`Object.prototype.hasOwnProperty`
  });
}
ne.hasPropFunc = Uu;
function cs(e, t, r) {
  return (0, ve._)`${Uu(e)}.call(${t}, ${r})`;
}
ne.isOwnProperty = cs;
function CE(e, t, r, n) {
  const i = (0, ve._)`${t}${(0, ve.getProperty)(r)} !== undefined`;
  return n ? (0, ve._)`${i} && ${cs(e, t, r)}` : i;
}
ne.propertyInData = CE;
function us(e, t, r, n) {
  const i = (0, ve._)`${t}${(0, ve.getProperty)(r)} === undefined`;
  return n ? (0, ve.or)(i, (0, ve.not)(cs(e, t, r))) : i;
}
ne.noPropertyInData = us;
function Vu(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
ne.allSchemaProperties = Vu;
function AE(e, t) {
  return Vu(t).filter((r) => !(0, ls.alwaysValidSchema)(e, t[r]));
}
ne.schemaProperties = AE;
function PE({ schemaCode: e, data: t, it: { gen: r, topSchemaRef: n, schemaPath: i, errorPath: a }, it: s }, o, l, c) {
  const u = c ? (0, ve._)`${e}, ${t}, ${n}${i}` : t, f = [
    [Ft.default.instancePath, (0, ve.strConcat)(Ft.default.instancePath, a)],
    [Ft.default.parentData, s.parentData],
    [Ft.default.parentDataProperty, s.parentDataProperty],
    [Ft.default.rootData, Ft.default.rootData]
  ];
  s.opts.dynamicRef && f.push([Ft.default.dynamicAnchors, Ft.default.dynamicAnchors]);
  const p = (0, ve._)`${u}, ${r.object(...f)}`;
  return l !== ve.nil ? (0, ve._)`${o}.call(${l}, ${p})` : (0, ve._)`${o}(${p})`;
}
ne.callValidateCode = PE;
const IE = (0, ve._)`new RegExp`;
function TE({ gen: e, it: { opts: t } }, r) {
  const n = t.unicodeRegExp ? "u" : "", { regExp: i } = t.code, a = i(r, n);
  return e.scopeValue("pattern", {
    key: a.toString(),
    ref: a,
    code: (0, ve._)`${i.code === "new RegExp" ? IE : (0, SE.useFunc)(e, i)}(${r}, ${n})`
  });
}
ne.usePattern = TE;
function NE(e) {
  const { gen: t, data: r, keyword: n, it: i } = e, a = t.name("valid");
  if (i.allErrors) {
    const o = t.let("valid", !0);
    return s(() => t.assign(o, !1)), o;
  }
  return t.var(a, !0), s(() => t.break()), a;
  function s(o) {
    const l = t.const("len", (0, ve._)`${r}.length`);
    t.forRange("i", 0, l, (c) => {
      e.subschema({
        keyword: n,
        dataProp: c,
        dataPropType: ls.Type.Num
      }, a), t.if((0, ve.not)(a), o);
    });
  }
}
ne.validateArray = NE;
function DE(e) {
  const { gen: t, schema: r, keyword: n, it: i } = e;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((l) => (0, ls.alwaysValidSchema)(i, l)) && !i.opts.unevaluated)
    return;
  const s = t.let("valid", !1), o = t.name("_valid");
  t.block(() => r.forEach((l, c) => {
    const u = e.subschema({
      keyword: n,
      schemaProp: c,
      compositeRule: !0
    }, o);
    t.assign(s, (0, ve._)`${s} || ${o}`), e.mergeValidEvaluated(u, o) || t.if((0, ve.not)(s));
  })), e.result(s, () => e.reset(), () => e.error(!0));
}
ne.validateUnion = DE;
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.validateKeywordUsage = gt.validSchemaType = gt.funcKeywordCode = gt.macroKeywordCode = void 0;
const xe = re, er = vt, FE = ne, kE = $n;
function RE(e, t) {
  const { gen: r, keyword: n, schema: i, parentSchema: a, it: s } = e, o = t.macro.call(s.self, i, a, s), l = xu(r, n, o);
  s.opts.validateSchema !== !1 && s.self.validateSchema(o, !0);
  const c = r.name("valid");
  e.subschema({
    schema: o,
    schemaPath: xe.nil,
    errSchemaPath: `${s.errSchemaPath}/${n}`,
    topSchemaRef: l,
    compositeRule: !0
  }, c), e.pass(c, () => e.error(!0));
}
gt.macroKeywordCode = RE;
function ME(e, t) {
  var r;
  const { gen: n, keyword: i, schema: a, parentSchema: s, $data: o, it: l } = e;
  UE(l, t);
  const c = !o && t.compile ? t.compile.call(l.self, a, s, l) : t.validate, u = xu(n, i, c), f = n.let("valid");
  e.block$data(f, p), e.ok((r = t.valid) !== null && r !== void 0 ? r : f);
  function p() {
    if (t.errors === !1)
      h(), t.modifying && sl(e), g(() => e.error());
    else {
      const y = t.async ? d() : m();
      t.modifying && sl(e), g(() => jE(e, y));
    }
  }
  function d() {
    const y = n.let("ruleErrs", null);
    return n.try(() => h((0, xe._)`await `), (v) => n.assign(f, !1).if((0, xe._)`${v} instanceof ${l.ValidationError}`, () => n.assign(y, (0, xe._)`${v}.errors`), () => n.throw(v))), y;
  }
  function m() {
    const y = (0, xe._)`${u}.errors`;
    return n.assign(y, null), h(xe.nil), y;
  }
  function h(y = t.async ? (0, xe._)`await ` : xe.nil) {
    const v = l.opts.passContext ? er.default.this : er.default.self, b = !("compile" in t && !o || t.schema === !1);
    n.assign(f, (0, xe._)`${y}${(0, FE.callValidateCode)(e, u, v, b)}`, t.modifying);
  }
  function g(y) {
    var v;
    n.if((0, xe.not)((v = t.valid) !== null && v !== void 0 ? v : f), y);
  }
}
gt.funcKeywordCode = ME;
function sl(e) {
  const { gen: t, data: r, it: n } = e;
  t.if(n.parentData, () => t.assign(r, (0, xe._)`${n.parentData}[${n.parentDataProperty}]`));
}
function jE(e, t) {
  const { gen: r } = e;
  r.if((0, xe._)`Array.isArray(${t})`, () => {
    r.assign(er.default.vErrors, (0, xe._)`${er.default.vErrors} === null ? ${t} : ${er.default.vErrors}.concat(${t})`).assign(er.default.errors, (0, xe._)`${er.default.vErrors}.length`), (0, kE.extendErrors)(e);
  }, () => e.error());
}
function UE({ schemaEnv: e }, t) {
  if (t.async && !e.$async)
    throw new Error("async keyword in sync schema");
}
function xu(e, t, r) {
  if (r === void 0)
    throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, xe.stringify)(r) });
}
function VE(e, t, r = !1) {
  return !t.length || t.some((n) => n === "array" ? Array.isArray(e) : n === "object" ? e && typeof e == "object" && !Array.isArray(e) : typeof e == n || r && typeof e > "u");
}
gt.validSchemaType = VE;
function xE({ schema: e, opts: t, self: r, errSchemaPath: n }, i, a) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(a) : i.keyword !== a)
    throw new Error("ajv implementation error");
  const s = i.dependencies;
  if (s != null && s.some((o) => !Object.prototype.hasOwnProperty.call(e, o)))
    throw new Error(`parent schema must have dependencies of ${a}: ${s.join(",")}`);
  if (i.validateSchema && !i.validateSchema(e[a])) {
    const l = `keyword "${a}" value is invalid at path "${n}": ` + r.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log")
      r.logger.error(l);
    else
      throw new Error(l);
  }
}
gt.validateKeywordUsage = xE;
var Vt = {};
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.extendSubschemaMode = Vt.extendSubschemaData = Vt.getSubschema = void 0;
const mt = re, Lu = fe;
function LE(e, { keyword: t, schemaProp: r, schema: n, schemaPath: i, errSchemaPath: a, topSchemaRef: s }) {
  if (t !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const o = e.schema[t];
    return r === void 0 ? {
      schema: o,
      schemaPath: (0, mt._)`${e.schemaPath}${(0, mt.getProperty)(t)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}`
    } : {
      schema: o[r],
      schemaPath: (0, mt._)`${e.schemaPath}${(0, mt.getProperty)(t)}${(0, mt.getProperty)(r)}`,
      errSchemaPath: `${e.errSchemaPath}/${t}/${(0, Lu.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (i === void 0 || a === void 0 || s === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: i,
      topSchemaRef: s,
      errSchemaPath: a
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Vt.getSubschema = LE;
function BE(e, t, { dataProp: r, dataPropType: n, data: i, dataTypes: a, propertyName: s }) {
  if (i !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = t;
  if (r !== void 0) {
    const { errorPath: c, dataPathArr: u, opts: f } = t, p = o.let("data", (0, mt._)`${t.data}${(0, mt.getProperty)(r)}`, !0);
    l(p), e.errorPath = (0, mt.str)`${c}${(0, Lu.getErrorPath)(r, n, f.jsPropertySyntax)}`, e.parentDataProperty = (0, mt._)`${r}`, e.dataPathArr = [...u, e.parentDataProperty];
  }
  if (i !== void 0) {
    const c = i instanceof mt.Name ? i : o.let("data", i, !0);
    l(c), s !== void 0 && (e.propertyName = s);
  }
  a && (e.dataTypes = a);
  function l(c) {
    e.data = c, e.dataLevel = t.dataLevel + 1, e.dataTypes = [], t.definedProperties = /* @__PURE__ */ new Set(), e.parentData = t.data, e.dataNames = [...t.dataNames, c];
  }
}
Vt.extendSubschemaData = BE;
function qE(e, { jtdDiscriminator: t, jtdMetadata: r, compositeRule: n, createErrors: i, allErrors: a }) {
  n !== void 0 && (e.compositeRule = n), i !== void 0 && (e.createErrors = i), a !== void 0 && (e.allErrors = a), e.jtdDiscriminator = t, e.jtdMetadata = r;
}
Vt.extendSubschemaMode = qE;
var Re = {}, Bu = { exports: {} }, jt = Bu.exports = function(e, t, r) {
  typeof t == "function" && (r = t, t = {}), r = t.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, i = r.post || function() {
  };
  Hn(t, n, i, e, "", e);
};
jt.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
jt.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
jt.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
jt.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Hn(e, t, r, n, i, a, s, o, l, c) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    t(n, i, a, s, o, l, c);
    for (var u in n) {
      var f = n[u];
      if (Array.isArray(f)) {
        if (u in jt.arrayKeywords)
          for (var p = 0; p < f.length; p++)
            Hn(e, t, r, f[p], i + "/" + u + "/" + p, a, i, u, n, p);
      } else if (u in jt.propsKeywords) {
        if (f && typeof f == "object")
          for (var d in f)
            Hn(e, t, r, f[d], i + "/" + u + "/" + KE(d), a, i, u, n, d);
      } else
        (u in jt.keywords || e.allKeys && !(u in jt.skipKeywords)) && Hn(e, t, r, f, i + "/" + u, a, i, u, n);
    }
    r(n, i, a, s, o, l, c);
  }
}
function KE(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var zE = Bu.exports;
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.getSchemaRefs = Re.resolveUrl = Re.normalizeId = Re._getFullPath = Re.getFullPath = Re.inlineRef = void 0;
const WE = fe, GE = Cl, HE = zE, YE = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function JE(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !ca(e) : t ? qu(e) <= t : !1;
}
Re.inlineRef = JE;
const XE = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function ca(e) {
  for (const t in e) {
    if (XE.has(t))
      return !0;
    const r = e[t];
    if (Array.isArray(r) && r.some(ca) || typeof r == "object" && ca(r))
      return !0;
  }
  return !1;
}
function qu(e) {
  let t = 0;
  for (const r in e) {
    if (r === "$ref")
      return 1 / 0;
    if (t++, !YE.has(r) && (typeof e[r] == "object" && (0, WE.eachItem)(e[r], (n) => t += qu(n)), t === 1 / 0))
      return 1 / 0;
  }
  return t;
}
function Ku(e, t = "", r) {
  r !== !1 && (t = Er(t));
  const n = e.parse(t);
  return zu(e, n);
}
Re.getFullPath = Ku;
function zu(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
Re._getFullPath = zu;
const ZE = /#\/?$/;
function Er(e) {
  return e ? e.replace(ZE, "") : "";
}
Re.normalizeId = Er;
function QE(e, t, r) {
  return r = Er(r), e.resolve(t, r);
}
Re.resolveUrl = QE;
const eO = /^[a-z_][-a-z0-9._]*$/i;
function tO(e, t) {
  if (typeof e == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, i = Er(e[r] || t), a = { "": i }, s = Ku(n, i, !1), o = {}, l = /* @__PURE__ */ new Set();
  return HE(e, { allKeys: !0 }, (f, p, d, m) => {
    if (m === void 0)
      return;
    const h = s + p;
    let g = a[m];
    typeof f[r] == "string" && (g = y.call(this, f[r])), v.call(this, f.$anchor), v.call(this, f.$dynamicAnchor), a[p] = g;
    function y(b) {
      const w = this.opts.uriResolver.resolve;
      if (b = Er(g ? w(g, b) : b), l.has(b))
        throw u(b);
      l.add(b);
      let C = this.refs[b];
      return typeof C == "string" && (C = this.refs[C]), typeof C == "object" ? c(f, C.schema, b) : b !== Er(h) && (b[0] === "#" ? (c(f, o[b], b), o[b] = f) : this.refs[b] = h), b;
    }
    function v(b) {
      if (typeof b == "string") {
        if (!eO.test(b))
          throw new Error(`invalid anchor "${b}"`);
        y.call(this, `#${b}`);
      }
    }
  }), o;
  function c(f, p, d) {
    if (p !== void 0 && !GE(f, p))
      throw u(d);
  }
  function u(f) {
    return new Error(`reference "${f}" resolves to more than one schema`);
  }
}
Re.getSchemaRefs = tO;
Object.defineProperty(lt, "__esModule", { value: !0 });
lt.getData = lt.KeywordCxt = lt.validateFunctionCode = void 0;
const Wu = Tr, ol = _n, ds = Ot, si = _n, rO = Oi, Xr = gt, Ki = Vt, H = re, Z = vt, nO = Re, Ct = fe, Hr = $n;
function iO(e) {
  if (Yu(e) && (Ju(e), Hu(e))) {
    oO(e);
    return;
  }
  Gu(e, () => (0, Wu.topBoolOrEmptySchema)(e));
}
lt.validateFunctionCode = iO;
function Gu({ gen: e, validateName: t, schema: r, schemaEnv: n, opts: i }, a) {
  i.code.es5 ? e.func(t, (0, H._)`${Z.default.data}, ${Z.default.valCxt}`, n.$async, () => {
    e.code((0, H._)`"use strict"; ${ll(r, i)}`), sO(e, i), e.code(a);
  }) : e.func(t, (0, H._)`${Z.default.data}, ${aO(i)}`, n.$async, () => e.code(ll(r, i)).code(a));
}
function aO(e) {
  return (0, H._)`{${Z.default.instancePath}="", ${Z.default.parentData}, ${Z.default.parentDataProperty}, ${Z.default.rootData}=${Z.default.data}${e.dynamicRef ? (0, H._)`, ${Z.default.dynamicAnchors}={}` : H.nil}}={}`;
}
function sO(e, t) {
  e.if(Z.default.valCxt, () => {
    e.var(Z.default.instancePath, (0, H._)`${Z.default.valCxt}.${Z.default.instancePath}`), e.var(Z.default.parentData, (0, H._)`${Z.default.valCxt}.${Z.default.parentData}`), e.var(Z.default.parentDataProperty, (0, H._)`${Z.default.valCxt}.${Z.default.parentDataProperty}`), e.var(Z.default.rootData, (0, H._)`${Z.default.valCxt}.${Z.default.rootData}`), t.dynamicRef && e.var(Z.default.dynamicAnchors, (0, H._)`${Z.default.valCxt}.${Z.default.dynamicAnchors}`);
  }, () => {
    e.var(Z.default.instancePath, (0, H._)`""`), e.var(Z.default.parentData, (0, H._)`undefined`), e.var(Z.default.parentDataProperty, (0, H._)`undefined`), e.var(Z.default.rootData, Z.default.data), t.dynamicRef && e.var(Z.default.dynamicAnchors, (0, H._)`{}`);
  });
}
function oO(e) {
  const { schema: t, opts: r, gen: n } = e;
  Gu(e, () => {
    r.$comment && t.$comment && Zu(e), fO(e), n.let(Z.default.vErrors, null), n.let(Z.default.errors, 0), r.unevaluated && lO(e), Xu(e), pO(e);
  });
}
function lO(e) {
  const { gen: t, validateName: r } = e;
  e.evaluated = t.const("evaluated", (0, H._)`${r}.evaluated`), t.if((0, H._)`${e.evaluated}.dynamicProps`, () => t.assign((0, H._)`${e.evaluated}.props`, (0, H._)`undefined`)), t.if((0, H._)`${e.evaluated}.dynamicItems`, () => t.assign((0, H._)`${e.evaluated}.items`, (0, H._)`undefined`));
}
function ll(e, t) {
  const r = typeof e == "object" && e[t.schemaId];
  return r && (t.code.source || t.code.process) ? (0, H._)`/*# sourceURL=${r} */` : H.nil;
}
function cO(e, t) {
  if (Yu(e) && (Ju(e), Hu(e))) {
    uO(e, t);
    return;
  }
  (0, Wu.boolOrEmptySchema)(e, t);
}
function Hu({ schema: e, self: t }) {
  if (typeof e == "boolean")
    return !e;
  for (const r in e)
    if (t.RULES.all[r])
      return !0;
  return !1;
}
function Yu(e) {
  return typeof e.schema != "boolean";
}
function uO(e, t) {
  const { schema: r, gen: n, opts: i } = e;
  i.$comment && r.$comment && Zu(e), hO(e), mO(e);
  const a = n.const("_errs", Z.default.errors);
  Xu(e, a), n.var(t, (0, H._)`${a} === ${Z.default.errors}`);
}
function Ju(e) {
  (0, Ct.checkUnknownRules)(e), dO(e);
}
function Xu(e, t) {
  if (e.opts.jtd)
    return cl(e, [], !1, t);
  const r = (0, ol.getSchemaTypes)(e.schema), n = (0, ol.coerceAndCheckDataType)(e, r);
  cl(e, r, !n, t);
}
function dO(e) {
  const { schema: t, errSchemaPath: r, opts: n, self: i } = e;
  t.$ref && n.ignoreKeywordsWithRef && (0, Ct.schemaHasRulesButRef)(t, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function fO(e) {
  const { schema: t, opts: r } = e;
  t.default !== void 0 && r.useDefaults && r.strictSchema && (0, Ct.checkStrictMode)(e, "default is ignored in the schema root");
}
function hO(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, nO.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function mO(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function Zu({ gen: e, schemaEnv: t, schema: r, errSchemaPath: n, opts: i }) {
  const a = r.$comment;
  if (i.$comment === !0)
    e.code((0, H._)`${Z.default.self}.logger.log(${a})`);
  else if (typeof i.$comment == "function") {
    const s = (0, H.str)`${n}/$comment`, o = e.scopeValue("root", { ref: t.root });
    e.code((0, H._)`${Z.default.self}.opts.$comment(${a}, ${s}, ${o}.schema)`);
  }
}
function pO(e) {
  const { gen: t, schemaEnv: r, validateName: n, ValidationError: i, opts: a } = e;
  r.$async ? t.if((0, H._)`${Z.default.errors} === 0`, () => t.return(Z.default.data), () => t.throw((0, H._)`new ${i}(${Z.default.vErrors})`)) : (t.assign((0, H._)`${n}.errors`, Z.default.vErrors), a.unevaluated && yO(e), t.return((0, H._)`${Z.default.errors} === 0`));
}
function yO({ gen: e, evaluated: t, props: r, items: n }) {
  r instanceof H.Name && e.assign((0, H._)`${t}.props`, r), n instanceof H.Name && e.assign((0, H._)`${t}.items`, n);
}
function cl(e, t, r, n) {
  const { gen: i, schema: a, data: s, allErrors: o, opts: l, self: c } = e, { RULES: u } = c;
  if (a.$ref && (l.ignoreKeywordsWithRef || !(0, Ct.schemaHasRulesButRef)(a, u))) {
    i.block(() => td(e, "$ref", u.all.$ref.definition));
    return;
  }
  l.jtd || gO(e, t), i.block(() => {
    for (const p of u.rules)
      f(p);
    f(u.post);
  });
  function f(p) {
    (0, ds.shouldUseGroup)(a, p) && (p.type ? (i.if((0, si.checkDataType)(p.type, s, l.strictNumbers)), ul(e, p), t.length === 1 && t[0] === p.type && r && (i.else(), (0, si.reportTypeError)(e)), i.endIf()) : ul(e, p), o || i.if((0, H._)`${Z.default.errors} === ${n || 0}`));
  }
}
function ul(e, t) {
  const { gen: r, schema: n, opts: { useDefaults: i } } = e;
  i && (0, rO.assignDefaults)(e, t.type), r.block(() => {
    for (const a of t.rules)
      (0, ds.shouldUseRule)(n, a) && td(e, a.keyword, a.definition, t.type);
  });
}
function gO(e, t) {
  e.schemaEnv.meta || !e.opts.strictTypes || (vO(e, t), e.opts.allowUnionTypes || $O(e, t), _O(e, e.dataTypes));
}
function vO(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((r) => {
      Qu(e.dataTypes, r) || fs(e, `type "${r}" not allowed by context "${e.dataTypes.join(",")}"`);
    }), SO(e, t);
  }
}
function $O(e, t) {
  t.length > 1 && !(t.length === 2 && t.includes("null")) && fs(e, "use allowUnionTypes to allow union type keyword");
}
function _O(e, t) {
  const r = e.self.RULES.all;
  for (const n in r) {
    const i = r[n];
    if (typeof i == "object" && (0, ds.shouldUseRule)(e.schema, i)) {
      const { type: a } = i.definition;
      a.length && !a.some((s) => bO(t, s)) && fs(e, `missing type "${a.join(",")}" for keyword "${n}"`);
    }
  }
}
function bO(e, t) {
  return e.includes(t) || t === "number" && e.includes("integer");
}
function Qu(e, t) {
  return e.includes(t) || t === "integer" && e.includes("number");
}
function SO(e, t) {
  const r = [];
  for (const n of e.dataTypes)
    Qu(t, n) ? r.push(n) : t.includes("integer") && n === "number" && r.push("integer");
  e.dataTypes = r;
}
function fs(e, t) {
  const r = e.schemaEnv.baseId + e.errSchemaPath;
  t += ` at "${r}" (strictTypes)`, (0, Ct.checkStrictMode)(e, t, e.opts.strictTypes);
}
class ed {
  constructor(t, r, n) {
    if ((0, Xr.validateKeywordUsage)(t, r, n), this.gen = t.gen, this.allErrors = t.allErrors, this.keyword = n, this.data = t.data, this.schema = t.schema[n], this.$data = r.$data && t.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, Ct.schemaRefOrVal)(t, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = t.schema, this.params = {}, this.it = t, this.def = r, this.$data)
      this.schemaCode = t.gen.const("vSchema", rd(this.$data, t));
    else if (this.schemaCode = this.schemaValue, !(0, Xr.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = t.gen.const("_errs", Z.default.errors));
  }
  result(t, r, n) {
    this.failResult((0, H.not)(t), r, n);
  }
  failResult(t, r, n) {
    this.gen.if(t), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(t, r) {
    this.failResult((0, H.not)(t), void 0, r);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data)
      return this.fail(t);
    const { schemaCode: r } = this;
    this.fail((0, H._)`${r} !== undefined && (${(0, H.or)(this.invalid$data(), t)})`);
  }
  error(t, r, n) {
    if (r) {
      this.setParams(r), this._error(t, n), this.setParams({});
      return;
    }
    this._error(t, n);
  }
  _error(t, r) {
    (t ? Hr.reportExtraError : Hr.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, Hr.reportError)(this, this.def.$dataError || Hr.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Hr.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, r) {
    r ? Object.assign(this.params, t) : this.params = t;
  }
  block$data(t, r, n = H.nil) {
    this.gen.block(() => {
      this.check$data(t, n), r();
    });
  }
  check$data(t = H.nil, r = H.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: i, schemaType: a, def: s } = this;
    n.if((0, H.or)((0, H._)`${i} === undefined`, r)), t !== H.nil && n.assign(t, !0), (a.length || s.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), t !== H.nil && n.assign(t, !1)), n.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: r, schemaType: n, def: i, it: a } = this;
    return (0, H.or)(s(), o());
    function s() {
      if (n.length) {
        if (!(r instanceof H.Name))
          throw new Error("ajv implementation error");
        const l = Array.isArray(n) ? n : [n];
        return (0, H._)`${(0, si.checkDataTypes)(l, r, a.opts.strictNumbers, si.DataType.Wrong)}`;
      }
      return H.nil;
    }
    function o() {
      if (i.validateSchema) {
        const l = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, H._)`!${l}(${r})`;
      }
      return H.nil;
    }
  }
  subschema(t, r) {
    const n = (0, Ki.getSubschema)(this.it, t);
    (0, Ki.extendSubschemaData)(n, this.it, t), (0, Ki.extendSubschemaMode)(n, t);
    const i = { ...this.it, ...n, items: void 0, props: void 0 };
    return cO(i, r), i;
  }
  mergeEvaluated(t, r) {
    const { it: n, gen: i } = this;
    n.opts.unevaluated && (n.props !== !0 && t.props !== void 0 && (n.props = Ct.mergeEvaluated.props(i, t.props, n.props, r)), n.items !== !0 && t.items !== void 0 && (n.items = Ct.mergeEvaluated.items(i, t.items, n.items, r)));
  }
  mergeValidEvaluated(t, r) {
    const { it: n, gen: i } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return i.if(r, () => this.mergeEvaluated(t, H.Name)), !0;
  }
}
lt.KeywordCxt = ed;
function td(e, t, r, n) {
  const i = new ed(e, r, t);
  "code" in r ? r.code(i, n) : i.$data && r.validate ? (0, Xr.funcKeywordCode)(i, r) : "macro" in r ? (0, Xr.macroKeywordCode)(i, r) : (r.compile || r.validate) && (0, Xr.funcKeywordCode)(i, r);
}
const wO = /^\/(?:[^~]|~0|~1)*$/, EO = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function rd(e, { dataLevel: t, dataNames: r, dataPathArr: n }) {
  let i, a;
  if (e === "")
    return Z.default.rootData;
  if (e[0] === "/") {
    if (!wO.test(e))
      throw new Error(`Invalid JSON-pointer: ${e}`);
    i = e, a = Z.default.rootData;
  } else {
    const c = EO.exec(e);
    if (!c)
      throw new Error(`Invalid JSON-pointer: ${e}`);
    const u = +c[1];
    if (i = c[2], i === "#") {
      if (u >= t)
        throw new Error(l("property/index", u));
      return n[t - u];
    }
    if (u > t)
      throw new Error(l("data", u));
    if (a = r[t - u], !i)
      return a;
  }
  let s = a;
  const o = i.split("/");
  for (const c of o)
    c && (a = (0, H._)`${a}${(0, H.getProperty)((0, Ct.unescapeJsonPointer)(c))}`, s = (0, H._)`${s} && ${a}`);
  return s;
  function l(c, u) {
    return `Cannot access ${c} ${u} levels up, current level is ${t}`;
  }
}
lt.getData = rd;
var bn = {};
Object.defineProperty(bn, "__esModule", { value: !0 });
class OO extends Error {
  constructor(t) {
    super("validation failed"), this.errors = t, this.ajv = this.validation = !0;
  }
}
bn.default = OO;
var Sn = {};
Object.defineProperty(Sn, "__esModule", { value: !0 });
const zi = Re;
class CO extends Error {
  constructor(t, r, n, i) {
    super(i || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, zi.resolveUrl)(t, r, n), this.missingSchema = (0, zi.normalizeId)((0, zi.getFullPath)(t, this.missingRef));
  }
}
Sn.default = CO;
var ze = {};
Object.defineProperty(ze, "__esModule", { value: !0 });
ze.resolveSchema = ze.getCompilingSchema = ze.resolveRef = ze.compileSchema = ze.SchemaEnv = void 0;
const nt = re, AO = bn, Xt = vt, st = Re, dl = fe, PO = lt;
class Ci {
  constructor(t) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof t.schema == "object" && (n = t.schema), this.schema = t.schema, this.schemaId = t.schemaId, this.root = t.root || this, this.baseId = (r = t.baseId) !== null && r !== void 0 ? r : (0, st.normalizeId)(n == null ? void 0 : n[t.schemaId || "$id"]), this.schemaPath = t.schemaPath, this.localRefs = t.localRefs, this.meta = t.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
ze.SchemaEnv = Ci;
function hs(e) {
  const t = nd.call(this, e);
  if (t)
    return t;
  const r = (0, st.getFullPath)(this.opts.uriResolver, e.root.baseId), { es5: n, lines: i } = this.opts.code, { ownProperties: a } = this.opts, s = new nt.CodeGen(this.scope, { es5: n, lines: i, ownProperties: a });
  let o;
  e.$async && (o = s.scopeValue("Error", {
    ref: AO.default,
    code: (0, nt._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const l = s.scopeName("validate");
  e.validateName = l;
  const c = {
    gen: s,
    allErrors: this.opts.allErrors,
    data: Xt.default.data,
    parentData: Xt.default.parentData,
    parentDataProperty: Xt.default.parentDataProperty,
    dataNames: [Xt.default.data],
    dataPathArr: [nt.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: s.scopeValue("schema", this.opts.code.source === !0 ? { ref: e.schema, code: (0, nt.stringify)(e.schema) } : { ref: e.schema }),
    validateName: l,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: r,
    baseId: e.baseId || r,
    schemaPath: nt.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, nt._)`""`,
    opts: this.opts,
    self: this
  };
  let u;
  try {
    this._compilations.add(e), (0, PO.validateFunctionCode)(c), s.optimize(this.opts.code.optimize);
    const f = s.toString();
    u = `${s.scopeRefs(Xt.default.scope)}return ${f}`, this.opts.code.process && (u = this.opts.code.process(u, e));
    const d = new Function(`${Xt.default.self}`, `${Xt.default.scope}`, u)(this, this.scope.get());
    if (this.scope.value(l, { ref: d }), d.errors = null, d.schema = e.schema, d.schemaEnv = e, e.$async && (d.$async = !0), this.opts.code.source === !0 && (d.source = { validateName: l, validateCode: f, scopeValues: s._values }), this.opts.unevaluated) {
      const { props: m, items: h } = c;
      d.evaluated = {
        props: m instanceof nt.Name ? void 0 : m,
        items: h instanceof nt.Name ? void 0 : h,
        dynamicProps: m instanceof nt.Name,
        dynamicItems: h instanceof nt.Name
      }, d.source && (d.source.evaluated = (0, nt.stringify)(d.evaluated));
    }
    return e.validate = d, e;
  } catch (f) {
    throw delete e.validate, delete e.validateName, u && this.logger.error("Error compiling schema, function code:", u), f;
  } finally {
    this._compilations.delete(e);
  }
}
ze.compileSchema = hs;
function IO(e, t, r) {
  var n;
  r = (0, st.resolveUrl)(this.opts.uriResolver, t, r);
  const i = e.refs[r];
  if (i)
    return i;
  let a = DO.call(this, e, r);
  if (a === void 0) {
    const s = (n = e.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: o } = this.opts;
    s && (a = new Ci({ schema: s, schemaId: o, root: e, baseId: t }));
  }
  if (a !== void 0)
    return e.refs[r] = TO.call(this, a);
}
ze.resolveRef = IO;
function TO(e) {
  return (0, st.inlineRef)(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : hs.call(this, e);
}
function nd(e) {
  for (const t of this._compilations)
    if (NO(t, e))
      return t;
}
ze.getCompilingSchema = nd;
function NO(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function DO(e, t) {
  let r;
  for (; typeof (r = this.refs[t]) == "string"; )
    t = r;
  return r || this.schemas[t] || Ai.call(this, e, t);
}
function Ai(e, t) {
  const r = this.opts.uriResolver.parse(t), n = (0, st._getFullPath)(this.opts.uriResolver, r);
  let i = (0, st.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && n === i)
    return Wi.call(this, r, e);
  const a = (0, st.normalizeId)(n), s = this.refs[a] || this.schemas[a];
  if (typeof s == "string") {
    const o = Ai.call(this, e, s);
    return typeof (o == null ? void 0 : o.schema) != "object" ? void 0 : Wi.call(this, r, o);
  }
  if (typeof (s == null ? void 0 : s.schema) == "object") {
    if (s.validate || hs.call(this, s), a === (0, st.normalizeId)(t)) {
      const { schema: o } = s, { schemaId: l } = this.opts, c = o[l];
      return c && (i = (0, st.resolveUrl)(this.opts.uriResolver, i, c)), new Ci({ schema: o, schemaId: l, root: e, baseId: i });
    }
    return Wi.call(this, r, s);
  }
}
ze.resolveSchema = Ai;
const FO = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Wi(e, { baseId: t, schema: r, root: n }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const l = r[(0, dl.unescapeFragment)(o)];
    if (l === void 0)
      return;
    r = l;
    const c = typeof r == "object" && r[this.opts.schemaId];
    !FO.has(o) && c && (t = (0, st.resolveUrl)(this.opts.uriResolver, t, c));
  }
  let a;
  if (typeof r != "boolean" && r.$ref && !(0, dl.schemaHasRulesButRef)(r, this.RULES)) {
    const o = (0, st.resolveUrl)(this.opts.uriResolver, t, r.$ref);
    a = Ai.call(this, n, o);
  }
  const { schemaId: s } = this.opts;
  if (a = a || new Ci({ schema: r, schemaId: s, root: n, baseId: t }), a.schema !== a.root.schema)
    return a;
}
const kO = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", RO = "Meta-schema for $data reference (JSON AnySchema extension proposal)", MO = "object", jO = [
  "$data"
], UO = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, VO = !1, xO = {
  $id: kO,
  description: RO,
  type: MO,
  required: jO,
  properties: UO,
  additionalProperties: VO
};
var ms = {}, ua = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(e, t) {
  (function(r, n) {
    n(t);
  })(Nd, function(r) {
    function n() {
      for (var A = arguments.length, S = Array(A), I = 0; I < A; I++)
        S[I] = arguments[I];
      if (S.length > 1) {
        S[0] = S[0].slice(0, -1);
        for (var R = S.length - 1, k = 1; k < R; ++k)
          S[k] = S[k].slice(1, -1);
        return S[R] = S[R].slice(1), S.join("");
      } else
        return S[0];
    }
    function i(A) {
      return "(?:" + A + ")";
    }
    function a(A) {
      return A === void 0 ? "undefined" : A === null ? "null" : Object.prototype.toString.call(A).split(" ").pop().split("]").shift().toLowerCase();
    }
    function s(A) {
      return A.toUpperCase();
    }
    function o(A) {
      return A != null ? A instanceof Array ? A : typeof A.length != "number" || A.split || A.setInterval || A.call ? [A] : Array.prototype.slice.call(A) : [];
    }
    function l(A, S) {
      var I = A;
      if (S)
        for (var R in S)
          I[R] = S[R];
      return I;
    }
    function c(A) {
      var S = "[A-Za-z]", I = "[0-9]", R = n(I, "[A-Fa-f]"), k = i(i("%[EFef]" + R + "%" + R + R + "%" + R + R) + "|" + i("%[89A-Fa-f]" + R + "%" + R + R) + "|" + i("%" + R + R)), J = "[\\:\\/\\?\\#\\[\\]\\@]", X = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", de = n(J, X), ge = A ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Ce = A ? "[\\uE000-\\uF8FF]" : "[]", se = n(S, I, "[\\-\\.\\_\\~]", ge);
      i(S + n(S, I, "[\\+\\-\\.]") + "*"), i(i(k + "|" + n(se, X, "[\\:]")) + "*");
      var ye = i(i("25[0-5]") + "|" + i("2[0-4]" + I) + "|" + i("1" + I + I) + "|" + i("0?[1-9]" + I) + "|0?0?" + I), Ae = i(ye + "\\." + ye + "\\." + ye + "\\." + ye), Q = i(R + "{1,4}"), _e = i(i(Q + "\\:" + Q) + "|" + Ae), Ie = i(i(Q + "\\:") + "{6}" + _e), be = i("\\:\\:" + i(Q + "\\:") + "{5}" + _e), Tt = i(i(Q) + "?\\:\\:" + i(Q + "\\:") + "{4}" + _e), dt = i(i(i(Q + "\\:") + "{0,1}" + Q) + "?\\:\\:" + i(Q + "\\:") + "{3}" + _e), ft = i(i(i(Q + "\\:") + "{0,2}" + Q) + "?\\:\\:" + i(Q + "\\:") + "{2}" + _e), hr = i(i(i(Q + "\\:") + "{0,3}" + Q) + "?\\:\\:" + Q + "\\:" + _e), Yt = i(i(i(Q + "\\:") + "{0,4}" + Q) + "?\\:\\:" + _e), Xe = i(i(i(Q + "\\:") + "{0,5}" + Q) + "?\\:\\:" + Q), ht = i(i(i(Q + "\\:") + "{0,6}" + Q) + "?\\:\\:"), Jt = i([Ie, be, Tt, dt, ft, hr, Yt, Xe, ht].join("|")), _t = i(i(se + "|" + k) + "+");
      i("[vV]" + R + "+\\." + n(se, X, "[\\:]") + "+"), i(i(k + "|" + n(se, X)) + "*");
      var qr = i(k + "|" + n(se, X, "[\\:\\@]"));
      return i(i(k + "|" + n(se, X, "[\\@]")) + "+"), i(i(qr + "|" + n("[\\/\\?]", Ce)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", S, I, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", se, X), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", se, X), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", se, X), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", se, X), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", se, X, "[\\:\\@\\/\\?]", Ce), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", se, X, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", se, X), "g"),
        UNRESERVED: new RegExp(se, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", se, de), "g"),
        PCT_ENCODED: new RegExp(k, "g"),
        IPV4ADDRESS: new RegExp("^(" + Ae + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + Jt + ")" + i(i("\\%25|\\%(?!" + R + "{2})") + "(" + _t + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var u = c(!1), f = c(!0), p = function() {
      function A(S, I) {
        var R = [], k = !0, J = !1, X = void 0;
        try {
          for (var de = S[Symbol.iterator](), ge; !(k = (ge = de.next()).done) && (R.push(ge.value), !(I && R.length === I)); k = !0)
            ;
        } catch (Ce) {
          J = !0, X = Ce;
        } finally {
          try {
            !k && de.return && de.return();
          } finally {
            if (J)
              throw X;
          }
        }
        return R;
      }
      return function(S, I) {
        if (Array.isArray(S))
          return S;
        if (Symbol.iterator in Object(S))
          return A(S, I);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), d = function(A) {
      if (Array.isArray(A)) {
        for (var S = 0, I = Array(A.length); S < A.length; S++)
          I[S] = A[S];
        return I;
      } else
        return Array.from(A);
    }, m = 2147483647, h = 36, g = 1, y = 26, v = 38, b = 700, w = 72, C = 128, E = "-", _ = /^xn--/, T = /[^\0-\x7E]/, F = /[\x2E\u3002\uFF0E\uFF61]/g, j = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, L = h - g, U = Math.floor, W = String.fromCharCode;
    function z(A) {
      throw new RangeError(j[A]);
    }
    function q(A, S) {
      for (var I = [], R = A.length; R--; )
        I[R] = S(A[R]);
      return I;
    }
    function ue(A, S) {
      var I = A.split("@"), R = "";
      I.length > 1 && (R = I[0] + "@", A = I[1]), A = A.replace(F, ".");
      var k = A.split("."), J = q(k, S).join(".");
      return R + J;
    }
    function me(A) {
      for (var S = [], I = 0, R = A.length; I < R; ) {
        var k = A.charCodeAt(I++);
        if (k >= 55296 && k <= 56319 && I < R) {
          var J = A.charCodeAt(I++);
          (J & 64512) == 56320 ? S.push(((k & 1023) << 10) + (J & 1023) + 65536) : (S.push(k), I--);
        } else
          S.push(k);
      }
      return S;
    }
    var ie = function(S) {
      return String.fromCodePoint.apply(String, d(S));
    }, Y = function(S) {
      return S - 48 < 10 ? S - 22 : S - 65 < 26 ? S - 65 : S - 97 < 26 ? S - 97 : h;
    }, V = function(S, I) {
      return S + 22 + 75 * (S < 26) - ((I != 0) << 5);
    }, N = function(S, I, R) {
      var k = 0;
      for (
        S = R ? U(S / b) : S >> 1, S += U(S / I);
        /* no initialization */
        S > L * y >> 1;
        k += h
      )
        S = U(S / L);
      return U(k + (L + 1) * S / (S + v));
    }, x = function(S) {
      var I = [], R = S.length, k = 0, J = C, X = w, de = S.lastIndexOf(E);
      de < 0 && (de = 0);
      for (var ge = 0; ge < de; ++ge)
        S.charCodeAt(ge) >= 128 && z("not-basic"), I.push(S.charCodeAt(ge));
      for (var Ce = de > 0 ? de + 1 : 0; Ce < R; ) {
        for (
          var se = k, ye = 1, Ae = h;
          ;
          /* no condition */
          Ae += h
        ) {
          Ce >= R && z("invalid-input");
          var Q = Y(S.charCodeAt(Ce++));
          (Q >= h || Q > U((m - k) / ye)) && z("overflow"), k += Q * ye;
          var _e = Ae <= X ? g : Ae >= X + y ? y : Ae - X;
          if (Q < _e)
            break;
          var Ie = h - _e;
          ye > U(m / Ie) && z("overflow"), ye *= Ie;
        }
        var be = I.length + 1;
        X = N(k - se, be, se == 0), U(k / be) > m - J && z("overflow"), J += U(k / be), k %= be, I.splice(k++, 0, J);
      }
      return String.fromCodePoint.apply(String, I);
    }, D = function(S) {
      var I = [];
      S = me(S);
      var R = S.length, k = C, J = 0, X = w, de = !0, ge = !1, Ce = void 0;
      try {
        for (var se = S[Symbol.iterator](), ye; !(de = (ye = se.next()).done); de = !0) {
          var Ae = ye.value;
          Ae < 128 && I.push(W(Ae));
        }
      } catch (Kr) {
        ge = !0, Ce = Kr;
      } finally {
        try {
          !de && se.return && se.return();
        } finally {
          if (ge)
            throw Ce;
        }
      }
      var Q = I.length, _e = Q;
      for (Q && I.push(E); _e < R; ) {
        var Ie = m, be = !0, Tt = !1, dt = void 0;
        try {
          for (var ft = S[Symbol.iterator](), hr; !(be = (hr = ft.next()).done); be = !0) {
            var Yt = hr.value;
            Yt >= k && Yt < Ie && (Ie = Yt);
          }
        } catch (Kr) {
          Tt = !0, dt = Kr;
        } finally {
          try {
            !be && ft.return && ft.return();
          } finally {
            if (Tt)
              throw dt;
          }
        }
        var Xe = _e + 1;
        Ie - k > U((m - J) / Xe) && z("overflow"), J += (Ie - k) * Xe, k = Ie;
        var ht = !0, Jt = !1, _t = void 0;
        try {
          for (var qr = S[Symbol.iterator](), no; !(ht = (no = qr.next()).done); ht = !0) {
            var io = no.value;
            if (io < k && ++J > m && z("overflow"), io == k) {
              for (
                var Cn = J, An = h;
                ;
                /* no condition */
                An += h
              ) {
                var Pn = An <= X ? g : An >= X + y ? y : An - X;
                if (Cn < Pn)
                  break;
                var ao = Cn - Pn, so = h - Pn;
                I.push(W(V(Pn + ao % so, 0))), Cn = U(ao / so);
              }
              I.push(W(V(Cn, 0))), X = N(J, Xe, _e == Q), J = 0, ++_e;
            }
          }
        } catch (Kr) {
          Jt = !0, _t = Kr;
        } finally {
          try {
            !ht && qr.return && qr.return();
          } finally {
            if (Jt)
              throw _t;
          }
        }
        ++J, ++k;
      }
      return I.join("");
    }, $ = function(S) {
      return ue(S, function(I) {
        return _.test(I) ? x(I.slice(4).toLowerCase()) : I;
      });
    }, P = function(S) {
      return ue(S, function(I) {
        return T.test(I) ? "xn--" + D(I) : I;
      });
    }, M = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: me,
        encode: ie
      },
      decode: x,
      encode: D,
      toASCII: P,
      toUnicode: $
    }, B = {};
    function K(A) {
      var S = A.charCodeAt(0), I = void 0;
      return S < 16 ? I = "%0" + S.toString(16).toUpperCase() : S < 128 ? I = "%" + S.toString(16).toUpperCase() : S < 2048 ? I = "%" + (S >> 6 | 192).toString(16).toUpperCase() + "%" + (S & 63 | 128).toString(16).toUpperCase() : I = "%" + (S >> 12 | 224).toString(16).toUpperCase() + "%" + (S >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (S & 63 | 128).toString(16).toUpperCase(), I;
    }
    function te(A) {
      for (var S = "", I = 0, R = A.length; I < R; ) {
        var k = parseInt(A.substr(I + 1, 2), 16);
        if (k < 128)
          S += String.fromCharCode(k), I += 3;
        else if (k >= 194 && k < 224) {
          if (R - I >= 6) {
            var J = parseInt(A.substr(I + 4, 2), 16);
            S += String.fromCharCode((k & 31) << 6 | J & 63);
          } else
            S += A.substr(I, 6);
          I += 6;
        } else if (k >= 224) {
          if (R - I >= 9) {
            var X = parseInt(A.substr(I + 4, 2), 16), de = parseInt(A.substr(I + 7, 2), 16);
            S += String.fromCharCode((k & 15) << 12 | (X & 63) << 6 | de & 63);
          } else
            S += A.substr(I, 9);
          I += 9;
        } else
          S += A.substr(I, 3), I += 3;
      }
      return S;
    }
    function ae(A, S) {
      function I(R) {
        var k = te(R);
        return k.match(S.UNRESERVED) ? k : R;
      }
      return A.scheme && (A.scheme = String(A.scheme).replace(S.PCT_ENCODED, I).toLowerCase().replace(S.NOT_SCHEME, "")), A.userinfo !== void 0 && (A.userinfo = String(A.userinfo).replace(S.PCT_ENCODED, I).replace(S.NOT_USERINFO, K).replace(S.PCT_ENCODED, s)), A.host !== void 0 && (A.host = String(A.host).replace(S.PCT_ENCODED, I).toLowerCase().replace(S.NOT_HOST, K).replace(S.PCT_ENCODED, s)), A.path !== void 0 && (A.path = String(A.path).replace(S.PCT_ENCODED, I).replace(A.scheme ? S.NOT_PATH : S.NOT_PATH_NOSCHEME, K).replace(S.PCT_ENCODED, s)), A.query !== void 0 && (A.query = String(A.query).replace(S.PCT_ENCODED, I).replace(S.NOT_QUERY, K).replace(S.PCT_ENCODED, s)), A.fragment !== void 0 && (A.fragment = String(A.fragment).replace(S.PCT_ENCODED, I).replace(S.NOT_FRAGMENT, K).replace(S.PCT_ENCODED, s)), A;
    }
    function pe(A) {
      return A.replace(/^0*(.*)/, "$1") || "0";
    }
    function He(A, S) {
      var I = A.match(S.IPV4ADDRESS) || [], R = p(I, 2), k = R[1];
      return k ? k.split(".").map(pe).join(".") : A;
    }
    function rt(A, S) {
      var I = A.match(S.IPV6ADDRESS) || [], R = p(I, 3), k = R[1], J = R[2];
      if (k) {
        for (var X = k.toLowerCase().split("::").reverse(), de = p(X, 2), ge = de[0], Ce = de[1], se = Ce ? Ce.split(":").map(pe) : [], ye = ge.split(":").map(pe), Ae = S.IPV4ADDRESS.test(ye[ye.length - 1]), Q = Ae ? 7 : 8, _e = ye.length - Q, Ie = Array(Q), be = 0; be < Q; ++be)
          Ie[be] = se[be] || ye[_e + be] || "";
        Ae && (Ie[Q - 1] = He(Ie[Q - 1], S));
        var Tt = Ie.reduce(function(Xe, ht, Jt) {
          if (!ht || ht === "0") {
            var _t = Xe[Xe.length - 1];
            _t && _t.index + _t.length === Jt ? _t.length++ : Xe.push({ index: Jt, length: 1 });
          }
          return Xe;
        }, []), dt = Tt.sort(function(Xe, ht) {
          return ht.length - Xe.length;
        })[0], ft = void 0;
        if (dt && dt.length > 1) {
          var hr = Ie.slice(0, dt.index), Yt = Ie.slice(dt.index + dt.length);
          ft = hr.join(":") + "::" + Yt.join(":");
        } else
          ft = Ie.join(":");
        return J && (ft += "%" + J), ft;
      } else
        return A;
    }
    var qt = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, Kt = "".match(/(){0}/)[1] === void 0;
    function Ue(A) {
      var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, I = {}, R = S.iri !== !1 ? f : u;
      S.reference === "suffix" && (A = (S.scheme ? S.scheme + ":" : "") + "//" + A);
      var k = A.match(qt);
      if (k) {
        Kt ? (I.scheme = k[1], I.userinfo = k[3], I.host = k[4], I.port = parseInt(k[5], 10), I.path = k[6] || "", I.query = k[7], I.fragment = k[8], isNaN(I.port) && (I.port = k[5])) : (I.scheme = k[1] || void 0, I.userinfo = A.indexOf("@") !== -1 ? k[3] : void 0, I.host = A.indexOf("//") !== -1 ? k[4] : void 0, I.port = parseInt(k[5], 10), I.path = k[6] || "", I.query = A.indexOf("?") !== -1 ? k[7] : void 0, I.fragment = A.indexOf("#") !== -1 ? k[8] : void 0, isNaN(I.port) && (I.port = A.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? k[4] : void 0)), I.host && (I.host = rt(He(I.host, R), R)), I.scheme === void 0 && I.userinfo === void 0 && I.host === void 0 && I.port === void 0 && !I.path && I.query === void 0 ? I.reference = "same-document" : I.scheme === void 0 ? I.reference = "relative" : I.fragment === void 0 ? I.reference = "absolute" : I.reference = "uri", S.reference && S.reference !== "suffix" && S.reference !== I.reference && (I.error = I.error || "URI is not a " + S.reference + " reference.");
        var J = B[(S.scheme || I.scheme || "").toLowerCase()];
        if (!S.unicodeSupport && (!J || !J.unicodeSupport)) {
          if (I.host && (S.domainHost || J && J.domainHost))
            try {
              I.host = M.toASCII(I.host.replace(R.PCT_ENCODED, te).toLowerCase());
            } catch (X) {
              I.error = I.error || "Host's domain name can not be converted to ASCII via punycode: " + X;
            }
          ae(I, u);
        } else
          ae(I, R);
        J && J.parse && J.parse(I, S);
      } else
        I.error = I.error || "URI can not be parsed.";
      return I;
    }
    function zt(A, S) {
      var I = S.iri !== !1 ? f : u, R = [];
      return A.userinfo !== void 0 && (R.push(A.userinfo), R.push("@")), A.host !== void 0 && R.push(rt(He(String(A.host), I), I).replace(I.IPV6ADDRESS, function(k, J, X) {
        return "[" + J + (X ? "%25" + X : "") + "]";
      })), (typeof A.port == "number" || typeof A.port == "string") && (R.push(":"), R.push(String(A.port))), R.length ? R.join("") : void 0;
    }
    var It = /^\.\.?\//, $t = /^\/\.(\/|$)/, qe = /^\/\.\.(\/|$)/, Wt = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Ye(A) {
      for (var S = []; A.length; )
        if (A.match(It))
          A = A.replace(It, "");
        else if (A.match($t))
          A = A.replace($t, "/");
        else if (A.match(qe))
          A = A.replace(qe, "/"), S.pop();
        else if (A === "." || A === "..")
          A = "";
        else {
          var I = A.match(Wt);
          if (I) {
            var R = I[0];
            A = A.slice(R.length), S.push(R);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return S.join("");
    }
    function Ve(A) {
      var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, I = S.iri ? f : u, R = [], k = B[(S.scheme || A.scheme || "").toLowerCase()];
      if (k && k.serialize && k.serialize(A, S), A.host && !I.IPV6ADDRESS.test(A.host)) {
        if (S.domainHost || k && k.domainHost)
          try {
            A.host = S.iri ? M.toUnicode(A.host) : M.toASCII(A.host.replace(I.PCT_ENCODED, te).toLowerCase());
          } catch (de) {
            A.error = A.error || "Host's domain name can not be converted to " + (S.iri ? "Unicode" : "ASCII") + " via punycode: " + de;
          }
      }
      ae(A, I), S.reference !== "suffix" && A.scheme && (R.push(A.scheme), R.push(":"));
      var J = zt(A, S);
      if (J !== void 0 && (S.reference !== "suffix" && R.push("//"), R.push(J), A.path && A.path.charAt(0) !== "/" && R.push("/")), A.path !== void 0) {
        var X = A.path;
        !S.absolutePath && (!k || !k.absolutePath) && (X = Ye(X)), J === void 0 && (X = X.replace(/^\/\//, "/%2F")), R.push(X);
      }
      return A.query !== void 0 && (R.push("?"), R.push(A.query)), A.fragment !== void 0 && (R.push("#"), R.push(A.fragment)), R.join("");
    }
    function dr(A, S) {
      var I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, R = arguments[3], k = {};
      return R || (A = Ue(Ve(A, I), I), S = Ue(Ve(S, I), I)), I = I || {}, !I.tolerant && S.scheme ? (k.scheme = S.scheme, k.userinfo = S.userinfo, k.host = S.host, k.port = S.port, k.path = Ye(S.path || ""), k.query = S.query) : (S.userinfo !== void 0 || S.host !== void 0 || S.port !== void 0 ? (k.userinfo = S.userinfo, k.host = S.host, k.port = S.port, k.path = Ye(S.path || ""), k.query = S.query) : (S.path ? (S.path.charAt(0) === "/" ? k.path = Ye(S.path) : ((A.userinfo !== void 0 || A.host !== void 0 || A.port !== void 0) && !A.path ? k.path = "/" + S.path : A.path ? k.path = A.path.slice(0, A.path.lastIndexOf("/") + 1) + S.path : k.path = S.path, k.path = Ye(k.path)), k.query = S.query) : (k.path = A.path, S.query !== void 0 ? k.query = S.query : k.query = A.query), k.userinfo = A.userinfo, k.host = A.host, k.port = A.port), k.scheme = A.scheme), k.fragment = S.fragment, k;
    }
    function xr(A, S, I) {
      var R = l({ scheme: "null" }, I);
      return Ve(dr(Ue(A, R), Ue(S, R), R, !0), R);
    }
    function Gt(A, S) {
      return typeof A == "string" ? A = Ve(Ue(A, S), S) : a(A) === "object" && (A = Ue(Ve(A, S), S)), A;
    }
    function Lr(A, S, I) {
      return typeof A == "string" ? A = Ve(Ue(A, I), I) : a(A) === "object" && (A = Ve(A, I)), typeof S == "string" ? S = Ve(Ue(S, I), I) : a(S) === "object" && (S = Ve(S, I)), A === S;
    }
    function On(A, S) {
      return A && A.toString().replace(!S || !S.iri ? u.ESCAPE : f.ESCAPE, K);
    }
    function Je(A, S) {
      return A && A.toString().replace(!S || !S.iri ? u.PCT_ENCODED : f.PCT_ENCODED, te);
    }
    var Ht = {
      scheme: "http",
      domainHost: !0,
      parse: function(S, I) {
        return S.host || (S.error = S.error || "HTTP URIs must have a host."), S;
      },
      serialize: function(S, I) {
        var R = String(S.scheme).toLowerCase() === "https";
        return (S.port === (R ? 443 : 80) || S.port === "") && (S.port = void 0), S.path || (S.path = "/"), S;
      }
    }, Ys = {
      scheme: "https",
      domainHost: Ht.domainHost,
      parse: Ht.parse,
      serialize: Ht.serialize
    };
    function Js(A) {
      return typeof A.secure == "boolean" ? A.secure : String(A.scheme).toLowerCase() === "wss";
    }
    var Br = {
      scheme: "ws",
      domainHost: !0,
      parse: function(S, I) {
        var R = S;
        return R.secure = Js(R), R.resourceName = (R.path || "/") + (R.query ? "?" + R.query : ""), R.path = void 0, R.query = void 0, R;
      },
      serialize: function(S, I) {
        if ((S.port === (Js(S) ? 443 : 80) || S.port === "") && (S.port = void 0), typeof S.secure == "boolean" && (S.scheme = S.secure ? "wss" : "ws", S.secure = void 0), S.resourceName) {
          var R = S.resourceName.split("?"), k = p(R, 2), J = k[0], X = k[1];
          S.path = J && J !== "/" ? J : void 0, S.query = X, S.resourceName = void 0;
        }
        return S.fragment = void 0, S;
      }
    }, Xs = {
      scheme: "wss",
      domainHost: Br.domainHost,
      parse: Br.parse,
      serialize: Br.serialize
    }, _d = {}, Zs = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", ut = "[0-9A-Fa-f]", bd = i(i("%[EFef]" + ut + "%" + ut + ut + "%" + ut + ut) + "|" + i("%[89A-Fa-f]" + ut + "%" + ut + ut) + "|" + i("%" + ut + ut)), Sd = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", wd = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", Ed = n(wd, '[\\"\\\\]'), Od = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", Cd = new RegExp(Zs, "g"), fr = new RegExp(bd, "g"), Ad = new RegExp(n("[^]", Sd, "[\\.]", '[\\"]', Ed), "g"), Qs = new RegExp(n("[^]", Zs, Od), "g"), Pd = Qs;
    function Ii(A) {
      var S = te(A);
      return S.match(Cd) ? S : A;
    }
    var eo = {
      scheme: "mailto",
      parse: function(S, I) {
        var R = S, k = R.to = R.path ? R.path.split(",") : [];
        if (R.path = void 0, R.query) {
          for (var J = !1, X = {}, de = R.query.split("&"), ge = 0, Ce = de.length; ge < Ce; ++ge) {
            var se = de[ge].split("=");
            switch (se[0]) {
              case "to":
                for (var ye = se[1].split(","), Ae = 0, Q = ye.length; Ae < Q; ++Ae)
                  k.push(ye[Ae]);
                break;
              case "subject":
                R.subject = Je(se[1], I);
                break;
              case "body":
                R.body = Je(se[1], I);
                break;
              default:
                J = !0, X[Je(se[0], I)] = Je(se[1], I);
                break;
            }
          }
          J && (R.headers = X);
        }
        R.query = void 0;
        for (var _e = 0, Ie = k.length; _e < Ie; ++_e) {
          var be = k[_e].split("@");
          if (be[0] = Je(be[0]), I.unicodeSupport)
            be[1] = Je(be[1], I).toLowerCase();
          else
            try {
              be[1] = M.toASCII(Je(be[1], I).toLowerCase());
            } catch (Tt) {
              R.error = R.error || "Email address's domain name can not be converted to ASCII via punycode: " + Tt;
            }
          k[_e] = be.join("@");
        }
        return R;
      },
      serialize: function(S, I) {
        var R = S, k = o(S.to);
        if (k) {
          for (var J = 0, X = k.length; J < X; ++J) {
            var de = String(k[J]), ge = de.lastIndexOf("@"), Ce = de.slice(0, ge).replace(fr, Ii).replace(fr, s).replace(Ad, K), se = de.slice(ge + 1);
            try {
              se = I.iri ? M.toUnicode(se) : M.toASCII(Je(se, I).toLowerCase());
            } catch (_e) {
              R.error = R.error || "Email address's domain name can not be converted to " + (I.iri ? "Unicode" : "ASCII") + " via punycode: " + _e;
            }
            k[J] = Ce + "@" + se;
          }
          R.path = k.join(",");
        }
        var ye = S.headers = S.headers || {};
        S.subject && (ye.subject = S.subject), S.body && (ye.body = S.body);
        var Ae = [];
        for (var Q in ye)
          ye[Q] !== _d[Q] && Ae.push(Q.replace(fr, Ii).replace(fr, s).replace(Qs, K) + "=" + ye[Q].replace(fr, Ii).replace(fr, s).replace(Pd, K));
        return Ae.length && (R.query = Ae.join("&")), R;
      }
    }, Id = /^([^\:]+)\:(.*)/, to = {
      scheme: "urn",
      parse: function(S, I) {
        var R = S.path && S.path.match(Id), k = S;
        if (R) {
          var J = I.scheme || k.scheme || "urn", X = R[1].toLowerCase(), de = R[2], ge = J + ":" + (I.nid || X), Ce = B[ge];
          k.nid = X, k.nss = de, k.path = void 0, Ce && (k = Ce.parse(k, I));
        } else
          k.error = k.error || "URN can not be parsed.";
        return k;
      },
      serialize: function(S, I) {
        var R = I.scheme || S.scheme || "urn", k = S.nid, J = R + ":" + (I.nid || k), X = B[J];
        X && (S = X.serialize(S, I));
        var de = S, ge = S.nss;
        return de.path = (k || I.nid) + ":" + ge, de;
      }
    }, Td = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ro = {
      scheme: "urn:uuid",
      parse: function(S, I) {
        var R = S;
        return R.uuid = R.nss, R.nss = void 0, !I.tolerant && (!R.uuid || !R.uuid.match(Td)) && (R.error = R.error || "UUID is not valid."), R;
      },
      serialize: function(S, I) {
        var R = S;
        return R.nss = (S.uuid || "").toLowerCase(), R;
      }
    };
    B[Ht.scheme] = Ht, B[Ys.scheme] = Ys, B[Br.scheme] = Br, B[Xs.scheme] = Xs, B[eo.scheme] = eo, B[to.scheme] = to, B[ro.scheme] = ro, r.SCHEMES = B, r.pctEncChar = K, r.pctDecChars = te, r.parse = Ue, r.removeDotSegments = Ye, r.serialize = Ve, r.resolveComponents = dr, r.resolve = xr, r.normalize = Gt, r.equal = Lr, r.escapeComponent = On, r.unescapeComponent = Je, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(ua, ua.exports);
var LO = ua.exports;
Object.defineProperty(ms, "__esModule", { value: !0 });
const id = LO;
id.code = 'require("ajv/dist/runtime/uri").default';
ms.default = id;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  var t = lt;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return t.KeywordCxt;
  } });
  var r = re;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = bn, i = Sn, a = or, s = ze, o = re, l = Re, c = _n, u = fe, f = xO, p = ms, d = (V, N) => new RegExp(V, N);
  d.code = "new RegExp";
  const m = ["removeAdditional", "useDefaults", "coerceTypes"], h = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), g = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, y = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, v = 200;
  function b(V) {
    var N, x, D, $, P, M, B, K, te, ae, pe, He, rt, qt, Kt, Ue, zt, It, $t, qe, Wt, Ye, Ve, dr, xr;
    const Gt = V.strict, Lr = (N = V.code) === null || N === void 0 ? void 0 : N.optimize, On = Lr === !0 || Lr === void 0 ? 1 : Lr || 0, Je = (D = (x = V.code) === null || x === void 0 ? void 0 : x.regExp) !== null && D !== void 0 ? D : d, Ht = ($ = V.uriResolver) !== null && $ !== void 0 ? $ : p.default;
    return {
      strictSchema: (M = (P = V.strictSchema) !== null && P !== void 0 ? P : Gt) !== null && M !== void 0 ? M : !0,
      strictNumbers: (K = (B = V.strictNumbers) !== null && B !== void 0 ? B : Gt) !== null && K !== void 0 ? K : !0,
      strictTypes: (ae = (te = V.strictTypes) !== null && te !== void 0 ? te : Gt) !== null && ae !== void 0 ? ae : "log",
      strictTuples: (He = (pe = V.strictTuples) !== null && pe !== void 0 ? pe : Gt) !== null && He !== void 0 ? He : "log",
      strictRequired: (qt = (rt = V.strictRequired) !== null && rt !== void 0 ? rt : Gt) !== null && qt !== void 0 ? qt : !1,
      code: V.code ? { ...V.code, optimize: On, regExp: Je } : { optimize: On, regExp: Je },
      loopRequired: (Kt = V.loopRequired) !== null && Kt !== void 0 ? Kt : v,
      loopEnum: (Ue = V.loopEnum) !== null && Ue !== void 0 ? Ue : v,
      meta: (zt = V.meta) !== null && zt !== void 0 ? zt : !0,
      messages: (It = V.messages) !== null && It !== void 0 ? It : !0,
      inlineRefs: ($t = V.inlineRefs) !== null && $t !== void 0 ? $t : !0,
      schemaId: (qe = V.schemaId) !== null && qe !== void 0 ? qe : "$id",
      addUsedSchema: (Wt = V.addUsedSchema) !== null && Wt !== void 0 ? Wt : !0,
      validateSchema: (Ye = V.validateSchema) !== null && Ye !== void 0 ? Ye : !0,
      validateFormats: (Ve = V.validateFormats) !== null && Ve !== void 0 ? Ve : !0,
      unicodeRegExp: (dr = V.unicodeRegExp) !== null && dr !== void 0 ? dr : !0,
      int32range: (xr = V.int32range) !== null && xr !== void 0 ? xr : !0,
      uriResolver: Ht
    };
  }
  class w {
    constructor(N = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), N = this.opts = { ...N, ...b(N) };
      const { es5: x, lines: D } = this.opts.code;
      this.scope = new o.ValueScope({ scope: {}, prefixes: h, es5: x, lines: D }), this.logger = U(N.logger);
      const $ = N.validateFormats;
      N.validateFormats = !1, this.RULES = (0, a.getRules)(), C.call(this, g, N, "NOT SUPPORTED"), C.call(this, y, N, "DEPRECATED", "warn"), this._metaOpts = j.call(this), N.formats && T.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), N.keywords && F.call(this, N.keywords), typeof N.meta == "object" && this.addMetaSchema(N.meta), _.call(this), N.validateFormats = $;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: N, meta: x, schemaId: D } = this.opts;
      let $ = f;
      D === "id" && ($ = { ...f }, $.id = $.$id, delete $.$id), x && N && this.addMetaSchema($, $[D], !1);
    }
    defaultMeta() {
      const { meta: N, schemaId: x } = this.opts;
      return this.opts.defaultMeta = typeof N == "object" ? N[x] || N : void 0;
    }
    validate(N, x) {
      let D;
      if (typeof N == "string") {
        if (D = this.getSchema(N), !D)
          throw new Error(`no schema with key or ref "${N}"`);
      } else
        D = this.compile(N);
      const $ = D(x);
      return "$async" in D || (this.errors = D.errors), $;
    }
    compile(N, x) {
      const D = this._addSchema(N, x);
      return D.validate || this._compileSchemaEnv(D);
    }
    compileAsync(N, x) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: D } = this.opts;
      return $.call(this, N, x);
      async function $(ae, pe) {
        await P.call(this, ae.$schema);
        const He = this._addSchema(ae, pe);
        return He.validate || M.call(this, He);
      }
      async function P(ae) {
        ae && !this.getSchema(ae) && await $.call(this, { $ref: ae }, !0);
      }
      async function M(ae) {
        try {
          return this._compileSchemaEnv(ae);
        } catch (pe) {
          if (!(pe instanceof i.default))
            throw pe;
          return B.call(this, pe), await K.call(this, pe.missingSchema), M.call(this, ae);
        }
      }
      function B({ missingSchema: ae, missingRef: pe }) {
        if (this.refs[ae])
          throw new Error(`AnySchema ${ae} is loaded but ${pe} cannot be resolved`);
      }
      async function K(ae) {
        const pe = await te.call(this, ae);
        this.refs[ae] || await P.call(this, pe.$schema), this.refs[ae] || this.addSchema(pe, ae, x);
      }
      async function te(ae) {
        const pe = this._loading[ae];
        if (pe)
          return pe;
        try {
          return await (this._loading[ae] = D(ae));
        } finally {
          delete this._loading[ae];
        }
      }
    }
    // Adds schema to the instance
    addSchema(N, x, D, $ = this.opts.validateSchema) {
      if (Array.isArray(N)) {
        for (const M of N)
          this.addSchema(M, void 0, D, $);
        return this;
      }
      let P;
      if (typeof N == "object") {
        const { schemaId: M } = this.opts;
        if (P = N[M], P !== void 0 && typeof P != "string")
          throw new Error(`schema ${M} must be string`);
      }
      return x = (0, l.normalizeId)(x || P), this._checkUnique(x), this.schemas[x] = this._addSchema(N, D, x, $, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(N, x, D = this.opts.validateSchema) {
      return this.addSchema(N, x, !0, D), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(N, x) {
      if (typeof N == "boolean")
        return !0;
      let D;
      if (D = N.$schema, D !== void 0 && typeof D != "string")
        throw new Error("$schema must be a string");
      if (D = D || this.opts.defaultMeta || this.defaultMeta(), !D)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const $ = this.validate(D, N);
      if (!$ && x) {
        const P = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(P);
        else
          throw new Error(P);
      }
      return $;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(N) {
      let x;
      for (; typeof (x = E.call(this, N)) == "string"; )
        N = x;
      if (x === void 0) {
        const { schemaId: D } = this.opts, $ = new s.SchemaEnv({ schema: {}, schemaId: D });
        if (x = s.resolveSchema.call(this, $, N), !x)
          return;
        this.refs[N] = x;
      }
      return x.validate || this._compileSchemaEnv(x);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(N) {
      if (N instanceof RegExp)
        return this._removeAllSchemas(this.schemas, N), this._removeAllSchemas(this.refs, N), this;
      switch (typeof N) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const x = E.call(this, N);
          return typeof x == "object" && this._cache.delete(x.schema), delete this.schemas[N], delete this.refs[N], this;
        }
        case "object": {
          const x = N;
          this._cache.delete(x);
          let D = N[this.opts.schemaId];
          return D && (D = (0, l.normalizeId)(D), delete this.schemas[D], delete this.refs[D]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(N) {
      for (const x of N)
        this.addKeyword(x);
      return this;
    }
    addKeyword(N, x) {
      let D;
      if (typeof N == "string")
        D = N, typeof x == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), x.keyword = D);
      else if (typeof N == "object" && x === void 0) {
        if (x = N, D = x.keyword, Array.isArray(D) && !D.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (z.call(this, D, x), !x)
        return (0, u.eachItem)(D, (P) => q.call(this, P)), this;
      me.call(this, x);
      const $ = {
        ...x,
        type: (0, c.getJSONTypes)(x.type),
        schemaType: (0, c.getJSONTypes)(x.schemaType)
      };
      return (0, u.eachItem)(D, $.type.length === 0 ? (P) => q.call(this, P, $) : (P) => $.type.forEach((M) => q.call(this, P, $, M))), this;
    }
    getKeyword(N) {
      const x = this.RULES.all[N];
      return typeof x == "object" ? x.definition : !!x;
    }
    // Remove keyword
    removeKeyword(N) {
      const { RULES: x } = this;
      delete x.keywords[N], delete x.all[N];
      for (const D of x.rules) {
        const $ = D.rules.findIndex((P) => P.keyword === N);
        $ >= 0 && D.rules.splice($, 1);
      }
      return this;
    }
    // Add format
    addFormat(N, x) {
      return typeof x == "string" && (x = new RegExp(x)), this.formats[N] = x, this;
    }
    errorsText(N = this.errors, { separator: x = ", ", dataVar: D = "data" } = {}) {
      return !N || N.length === 0 ? "No errors" : N.map(($) => `${D}${$.instancePath} ${$.message}`).reduce(($, P) => $ + x + P);
    }
    $dataMetaSchema(N, x) {
      const D = this.RULES.all;
      N = JSON.parse(JSON.stringify(N));
      for (const $ of x) {
        const P = $.split("/").slice(1);
        let M = N;
        for (const B of P)
          M = M[B];
        for (const B in D) {
          const K = D[B];
          if (typeof K != "object")
            continue;
          const { $data: te } = K.definition, ae = M[B];
          te && ae && (M[B] = Y(ae));
        }
      }
      return N;
    }
    _removeAllSchemas(N, x) {
      for (const D in N) {
        const $ = N[D];
        (!x || x.test(D)) && (typeof $ == "string" ? delete N[D] : $ && !$.meta && (this._cache.delete($.schema), delete N[D]));
      }
    }
    _addSchema(N, x, D, $ = this.opts.validateSchema, P = this.opts.addUsedSchema) {
      let M;
      const { schemaId: B } = this.opts;
      if (typeof N == "object")
        M = N[B];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof N != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let K = this._cache.get(N);
      if (K !== void 0)
        return K;
      D = (0, l.normalizeId)(M || D);
      const te = l.getSchemaRefs.call(this, N, D);
      return K = new s.SchemaEnv({ schema: N, schemaId: B, meta: x, baseId: D, localRefs: te }), this._cache.set(K.schema, K), P && !D.startsWith("#") && (D && this._checkUnique(D), this.refs[D] = K), $ && this.validateSchema(N, !0), K;
    }
    _checkUnique(N) {
      if (this.schemas[N] || this.refs[N])
        throw new Error(`schema with key or id "${N}" already exists`);
    }
    _compileSchemaEnv(N) {
      if (N.meta ? this._compileMetaSchema(N) : s.compileSchema.call(this, N), !N.validate)
        throw new Error("ajv implementation error");
      return N.validate;
    }
    _compileMetaSchema(N) {
      const x = this.opts;
      this.opts = this._metaOpts;
      try {
        s.compileSchema.call(this, N);
      } finally {
        this.opts = x;
      }
    }
  }
  e.default = w, w.ValidationError = n.default, w.MissingRefError = i.default;
  function C(V, N, x, D = "error") {
    for (const $ in V) {
      const P = $;
      P in N && this.logger[D](`${x}: option ${$}. ${V[P]}`);
    }
  }
  function E(V) {
    return V = (0, l.normalizeId)(V), this.schemas[V] || this.refs[V];
  }
  function _() {
    const V = this.opts.schemas;
    if (V)
      if (Array.isArray(V))
        this.addSchema(V);
      else
        for (const N in V)
          this.addSchema(V[N], N);
  }
  function T() {
    for (const V in this.opts.formats) {
      const N = this.opts.formats[V];
      N && this.addFormat(V, N);
    }
  }
  function F(V) {
    if (Array.isArray(V)) {
      this.addVocabulary(V);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const N in V) {
      const x = V[N];
      x.keyword || (x.keyword = N), this.addKeyword(x);
    }
  }
  function j() {
    const V = { ...this.opts };
    for (const N of m)
      delete V[N];
    return V;
  }
  const L = { log() {
  }, warn() {
  }, error() {
  } };
  function U(V) {
    if (V === !1)
      return L;
    if (V === void 0)
      return console;
    if (V.log && V.warn && V.error)
      return V;
    throw new Error("logger must implement log, warn and error methods");
  }
  const W = /^[a-z_$][a-z0-9_$:-]*$/i;
  function z(V, N) {
    const { RULES: x } = this;
    if ((0, u.eachItem)(V, (D) => {
      if (x.keywords[D])
        throw new Error(`Keyword ${D} is already defined`);
      if (!W.test(D))
        throw new Error(`Keyword ${D} has invalid name`);
    }), !!N && N.$data && !("code" in N || "validate" in N))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function q(V, N, x) {
    var D;
    const $ = N == null ? void 0 : N.post;
    if (x && $)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: P } = this;
    let M = $ ? P.post : P.rules.find(({ type: K }) => K === x);
    if (M || (M = { type: x, rules: [] }, P.rules.push(M)), P.keywords[V] = !0, !N)
      return;
    const B = {
      keyword: V,
      definition: {
        ...N,
        type: (0, c.getJSONTypes)(N.type),
        schemaType: (0, c.getJSONTypes)(N.schemaType)
      }
    };
    N.before ? ue.call(this, M, B, N.before) : M.rules.push(B), P.all[V] = B, (D = N.implements) === null || D === void 0 || D.forEach((K) => this.addKeyword(K));
  }
  function ue(V, N, x) {
    const D = V.rules.findIndex(($) => $.keyword === x);
    D >= 0 ? V.rules.splice(D, 0, N) : (V.rules.push(N), this.logger.warn(`rule ${x} is not defined`));
  }
  function me(V) {
    let { metaSchema: N } = V;
    N !== void 0 && (V.$data && this.opts.$data && (N = Y(N)), V.validateSchema = this.compile(N, !0));
  }
  const ie = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function Y(V) {
    return { anyOf: [V, ie] };
  }
})(ku);
var ps = {}, ys = {}, gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
const BO = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
gs.default = BO;
var lr = {};
Object.defineProperty(lr, "__esModule", { value: !0 });
lr.callRef = lr.getValidate = void 0;
const qO = Sn, fl = ne, Ke = re, vr = vt, hl = ze, Rn = fe, KO = {
  keyword: "$ref",
  schemaType: "string",
  code(e) {
    const { gen: t, schema: r, it: n } = e, { baseId: i, schemaEnv: a, validateName: s, opts: o, self: l } = n, { root: c } = a;
    if ((r === "#" || r === "#/") && i === c.baseId)
      return f();
    const u = hl.resolveRef.call(l, c, i, r);
    if (u === void 0)
      throw new qO.default(n.opts.uriResolver, i, r);
    if (u instanceof hl.SchemaEnv)
      return p(u);
    return d(u);
    function f() {
      if (a === c)
        return Yn(e, s, a, a.$async);
      const m = t.scopeValue("root", { ref: c });
      return Yn(e, (0, Ke._)`${m}.validate`, c, c.$async);
    }
    function p(m) {
      const h = ad(e, m);
      Yn(e, h, m, m.$async);
    }
    function d(m) {
      const h = t.scopeValue("schema", o.code.source === !0 ? { ref: m, code: (0, Ke.stringify)(m) } : { ref: m }), g = t.name("valid"), y = e.subschema({
        schema: m,
        dataTypes: [],
        schemaPath: Ke.nil,
        topSchemaRef: h,
        errSchemaPath: r
      }, g);
      e.mergeEvaluated(y), e.ok(g);
    }
  }
};
function ad(e, t) {
  const { gen: r } = e;
  return t.validate ? r.scopeValue("validate", { ref: t.validate }) : (0, Ke._)`${r.scopeValue("wrapper", { ref: t })}.validate`;
}
lr.getValidate = ad;
function Yn(e, t, r, n) {
  const { gen: i, it: a } = e, { allErrors: s, schemaEnv: o, opts: l } = a, c = l.passContext ? vr.default.this : Ke.nil;
  n ? u() : f();
  function u() {
    if (!o.$async)
      throw new Error("async schema referenced by sync schema");
    const m = i.let("valid");
    i.try(() => {
      i.code((0, Ke._)`await ${(0, fl.callValidateCode)(e, t, c)}`), d(t), s || i.assign(m, !0);
    }, (h) => {
      i.if((0, Ke._)`!(${h} instanceof ${a.ValidationError})`, () => i.throw(h)), p(h), s || i.assign(m, !1);
    }), e.ok(m);
  }
  function f() {
    e.result((0, fl.callValidateCode)(e, t, c), () => d(t), () => p(t));
  }
  function p(m) {
    const h = (0, Ke._)`${m}.errors`;
    i.assign(vr.default.vErrors, (0, Ke._)`${vr.default.vErrors} === null ? ${h} : ${vr.default.vErrors}.concat(${h})`), i.assign(vr.default.errors, (0, Ke._)`${vr.default.vErrors}.length`);
  }
  function d(m) {
    var h;
    if (!a.opts.unevaluated)
      return;
    const g = (h = r == null ? void 0 : r.validate) === null || h === void 0 ? void 0 : h.evaluated;
    if (a.props !== !0)
      if (g && !g.dynamicProps)
        g.props !== void 0 && (a.props = Rn.mergeEvaluated.props(i, g.props, a.props));
      else {
        const y = i.var("props", (0, Ke._)`${m}.evaluated.props`);
        a.props = Rn.mergeEvaluated.props(i, y, a.props, Ke.Name);
      }
    if (a.items !== !0)
      if (g && !g.dynamicItems)
        g.items !== void 0 && (a.items = Rn.mergeEvaluated.items(i, g.items, a.items));
      else {
        const y = i.var("items", (0, Ke._)`${m}.evaluated.items`);
        a.items = Rn.mergeEvaluated.items(i, y, a.items, Ke.Name);
      }
  }
}
lr.callRef = Yn;
lr.default = KO;
Object.defineProperty(ys, "__esModule", { value: !0 });
const zO = gs, WO = lr, GO = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  zO.default,
  WO.default
];
ys.default = GO;
var vs = {}, $s = {};
Object.defineProperty($s, "__esModule", { value: !0 });
const oi = re, kt = oi.operators, li = {
  maximum: { okStr: "<=", ok: kt.LTE, fail: kt.GT },
  minimum: { okStr: ">=", ok: kt.GTE, fail: kt.LT },
  exclusiveMaximum: { okStr: "<", ok: kt.LT, fail: kt.GTE },
  exclusiveMinimum: { okStr: ">", ok: kt.GT, fail: kt.LTE }
}, HO = {
  message: ({ keyword: e, schemaCode: t }) => (0, oi.str)`must be ${li[e].okStr} ${t}`,
  params: ({ keyword: e, schemaCode: t }) => (0, oi._)`{comparison: ${li[e].okStr}, limit: ${t}}`
}, YO = {
  keyword: Object.keys(li),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: HO,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e;
    e.fail$data((0, oi._)`${r} ${li[t].fail} ${n} || isNaN(${r})`);
  }
};
$s.default = YO;
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
const Zr = re, JO = {
  message: ({ schemaCode: e }) => (0, Zr.str)`must be multiple of ${e}`,
  params: ({ schemaCode: e }) => (0, Zr._)`{multipleOf: ${e}}`
}, XO = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: JO,
  code(e) {
    const { gen: t, data: r, schemaCode: n, it: i } = e, a = i.opts.multipleOfPrecision, s = t.let("res"), o = a ? (0, Zr._)`Math.abs(Math.round(${s}) - ${s}) > 1e-${a}` : (0, Zr._)`${s} !== parseInt(${s})`;
    e.fail$data((0, Zr._)`(${n} === 0 || (${s} = ${r}/${n}, ${o}))`);
  }
};
_s.default = XO;
var bs = {}, Ss = {};
Object.defineProperty(Ss, "__esModule", { value: !0 });
function sd(e) {
  const t = e.length;
  let r = 0, n = 0, i;
  for (; n < t; )
    r++, i = e.charCodeAt(n++), i >= 55296 && i <= 56319 && n < t && (i = e.charCodeAt(n), (i & 64512) === 56320 && n++);
  return r;
}
Ss.default = sd;
sd.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(bs, "__esModule", { value: !0 });
const tr = re, ZO = fe, QO = Ss, eC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxLength" ? "more" : "fewer";
    return (0, tr.str)`must NOT have ${r} than ${t} characters`;
  },
  params: ({ schemaCode: e }) => (0, tr._)`{limit: ${e}}`
}, tC = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: eC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n, it: i } = e, a = t === "maxLength" ? tr.operators.GT : tr.operators.LT, s = i.opts.unicode === !1 ? (0, tr._)`${r}.length` : (0, tr._)`${(0, ZO.useFunc)(e.gen, QO.default)}(${r})`;
    e.fail$data((0, tr._)`${s} ${a} ${n}`);
  }
};
bs.default = tC;
var ws = {};
Object.defineProperty(ws, "__esModule", { value: !0 });
const rC = ne, ci = re, nC = {
  message: ({ schemaCode: e }) => (0, ci.str)`must match pattern "${e}"`,
  params: ({ schemaCode: e }) => (0, ci._)`{pattern: ${e}}`
}, iC = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: nC,
  code(e) {
    const { data: t, $data: r, schema: n, schemaCode: i, it: a } = e, s = a.opts.unicodeRegExp ? "u" : "", o = r ? (0, ci._)`(new RegExp(${i}, ${s}))` : (0, rC.usePattern)(e, n);
    e.fail$data((0, ci._)`!${o}.test(${t})`);
  }
};
ws.default = iC;
var Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
const Qr = re, aC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxProperties" ? "more" : "fewer";
    return (0, Qr.str)`must NOT have ${r} than ${t} properties`;
  },
  params: ({ schemaCode: e }) => (0, Qr._)`{limit: ${e}}`
}, sC = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: aC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxProperties" ? Qr.operators.GT : Qr.operators.LT;
    e.fail$data((0, Qr._)`Object.keys(${r}).length ${i} ${n}`);
  }
};
Es.default = sC;
var Os = {};
Object.defineProperty(Os, "__esModule", { value: !0 });
const Yr = ne, en = re, oC = fe, lC = {
  message: ({ params: { missingProperty: e } }) => (0, en.str)`must have required property '${e}'`,
  params: ({ params: { missingProperty: e } }) => (0, en._)`{missingProperty: ${e}}`
}, cC = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: lC,
  code(e) {
    const { gen: t, schema: r, schemaCode: n, data: i, $data: a, it: s } = e, { opts: o } = s;
    if (!a && r.length === 0)
      return;
    const l = r.length >= o.loopRequired;
    if (s.allErrors ? c() : u(), o.strictRequired) {
      const d = e.parentSchema.properties, { definedProperties: m } = e.it;
      for (const h of r)
        if ((d == null ? void 0 : d[h]) === void 0 && !m.has(h)) {
          const g = s.schemaEnv.baseId + s.errSchemaPath, y = `required property "${h}" is not defined at "${g}" (strictRequired)`;
          (0, oC.checkStrictMode)(s, y, s.opts.strictRequired);
        }
    }
    function c() {
      if (l || a)
        e.block$data(en.nil, f);
      else
        for (const d of r)
          (0, Yr.checkReportMissingProp)(e, d);
    }
    function u() {
      const d = t.let("missing");
      if (l || a) {
        const m = t.let("valid", !0);
        e.block$data(m, () => p(d, m)), e.ok(m);
      } else
        t.if((0, Yr.checkMissingProp)(e, r, d)), (0, Yr.reportMissingProp)(e, d), t.else();
    }
    function f() {
      t.forOf("prop", n, (d) => {
        e.setParams({ missingProperty: d }), t.if((0, Yr.noPropertyInData)(t, i, d, o.ownProperties), () => e.error());
      });
    }
    function p(d, m) {
      e.setParams({ missingProperty: d }), t.forOf(d, n, () => {
        t.assign(m, (0, Yr.propertyInData)(t, i, d, o.ownProperties)), t.if((0, en.not)(m), () => {
          e.error(), t.break();
        });
      }, en.nil);
    }
  }
};
Os.default = cC;
var Cs = {};
Object.defineProperty(Cs, "__esModule", { value: !0 });
const tn = re, uC = {
  message({ keyword: e, schemaCode: t }) {
    const r = e === "maxItems" ? "more" : "fewer";
    return (0, tn.str)`must NOT have ${r} than ${t} items`;
  },
  params: ({ schemaCode: e }) => (0, tn._)`{limit: ${e}}`
}, dC = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: uC,
  code(e) {
    const { keyword: t, data: r, schemaCode: n } = e, i = t === "maxItems" ? tn.operators.GT : tn.operators.LT;
    e.fail$data((0, tn._)`${r}.length ${i} ${n}`);
  }
};
Cs.default = dC;
var As = {}, wn = {};
Object.defineProperty(wn, "__esModule", { value: !0 });
const od = Cl;
od.code = 'require("ajv/dist/runtime/equal").default';
wn.default = od;
Object.defineProperty(As, "__esModule", { value: !0 });
const Gi = _n, ke = re, fC = fe, hC = wn, mC = {
  message: ({ params: { i: e, j: t } }) => (0, ke.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
  params: ({ params: { i: e, j: t } }) => (0, ke._)`{i: ${e}, j: ${t}}`
}, pC = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: mC,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, parentSchema: a, schemaCode: s, it: o } = e;
    if (!n && !i)
      return;
    const l = t.let("valid"), c = a.items ? (0, Gi.getSchemaTypes)(a.items) : [];
    e.block$data(l, u, (0, ke._)`${s} === false`), e.ok(l);
    function u() {
      const m = t.let("i", (0, ke._)`${r}.length`), h = t.let("j");
      e.setParams({ i: m, j: h }), t.assign(l, !0), t.if((0, ke._)`${m} > 1`, () => (f() ? p : d)(m, h));
    }
    function f() {
      return c.length > 0 && !c.some((m) => m === "object" || m === "array");
    }
    function p(m, h) {
      const g = t.name("item"), y = (0, Gi.checkDataTypes)(c, g, o.opts.strictNumbers, Gi.DataType.Wrong), v = t.const("indices", (0, ke._)`{}`);
      t.for((0, ke._)`;${m}--;`, () => {
        t.let(g, (0, ke._)`${r}[${m}]`), t.if(y, (0, ke._)`continue`), c.length > 1 && t.if((0, ke._)`typeof ${g} == "string"`, (0, ke._)`${g} += "_"`), t.if((0, ke._)`typeof ${v}[${g}] == "number"`, () => {
          t.assign(h, (0, ke._)`${v}[${g}]`), e.error(), t.assign(l, !1).break();
        }).code((0, ke._)`${v}[${g}] = ${m}`);
      });
    }
    function d(m, h) {
      const g = (0, fC.useFunc)(t, hC.default), y = t.name("outer");
      t.label(y).for((0, ke._)`;${m}--;`, () => t.for((0, ke._)`${h} = ${m}; ${h}--;`, () => t.if((0, ke._)`${g}(${r}[${m}], ${r}[${h}])`, () => {
        e.error(), t.assign(l, !1).break(y);
      })));
    }
  }
};
As.default = pC;
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
const da = re, yC = fe, gC = wn, vC = {
  message: "must be equal to constant",
  params: ({ schemaCode: e }) => (0, da._)`{allowedValue: ${e}}`
}, $C = {
  keyword: "const",
  $data: !0,
  error: vC,
  code(e) {
    const { gen: t, data: r, $data: n, schemaCode: i, schema: a } = e;
    n || a && typeof a == "object" ? e.fail$data((0, da._)`!${(0, yC.useFunc)(t, gC.default)}(${r}, ${i})`) : e.fail((0, da._)`${a} !== ${r}`);
  }
};
Ps.default = $C;
var Is = {};
Object.defineProperty(Is, "__esModule", { value: !0 });
const Jr = re, _C = fe, bC = wn, SC = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: e }) => (0, Jr._)`{allowedValues: ${e}}`
}, wC = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: SC,
  code(e) {
    const { gen: t, data: r, $data: n, schema: i, schemaCode: a, it: s } = e;
    if (!n && i.length === 0)
      throw new Error("enum must have non-empty array");
    const o = i.length >= s.opts.loopEnum;
    let l;
    const c = () => l ?? (l = (0, _C.useFunc)(t, bC.default));
    let u;
    if (o || n)
      u = t.let("valid"), e.block$data(u, f);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const d = t.const("vSchema", a);
      u = (0, Jr.or)(...i.map((m, h) => p(d, h)));
    }
    e.pass(u);
    function f() {
      t.assign(u, !1), t.forOf("v", a, (d) => t.if((0, Jr._)`${c()}(${r}, ${d})`, () => t.assign(u, !0).break()));
    }
    function p(d, m) {
      const h = i[m];
      return typeof h == "object" && h !== null ? (0, Jr._)`${c()}(${r}, ${d}[${m}])` : (0, Jr._)`${r} === ${h}`;
    }
  }
};
Is.default = wC;
Object.defineProperty(vs, "__esModule", { value: !0 });
const EC = $s, OC = _s, CC = bs, AC = ws, PC = Es, IC = Os, TC = Cs, NC = As, DC = Ps, FC = Is, kC = [
  // number
  EC.default,
  OC.default,
  // string
  CC.default,
  AC.default,
  // object
  PC.default,
  IC.default,
  // array
  TC.default,
  NC.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  DC.default,
  FC.default
];
vs.default = kC;
var Ts = {}, Ur = {};
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.validateAdditionalItems = void 0;
const rr = re, fa = fe, RC = {
  message: ({ params: { len: e } }) => (0, rr.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, rr._)`{limit: ${e}}`
}, MC = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: RC,
  code(e) {
    const { parentSchema: t, it: r } = e, { items: n } = t;
    if (!Array.isArray(n)) {
      (0, fa.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    ld(e, n);
  }
};
function ld(e, t) {
  const { gen: r, schema: n, data: i, keyword: a, it: s } = e;
  s.items = !0;
  const o = r.const("len", (0, rr._)`${i}.length`);
  if (n === !1)
    e.setParams({ len: t.length }), e.pass((0, rr._)`${o} <= ${t.length}`);
  else if (typeof n == "object" && !(0, fa.alwaysValidSchema)(s, n)) {
    const c = r.var("valid", (0, rr._)`${o} <= ${t.length}`);
    r.if((0, rr.not)(c), () => l(c)), e.ok(c);
  }
  function l(c) {
    r.forRange("i", t.length, o, (u) => {
      e.subschema({ keyword: a, dataProp: u, dataPropType: fa.Type.Num }, c), s.allErrors || r.if((0, rr.not)(c), () => r.break());
    });
  }
}
Ur.validateAdditionalItems = ld;
Ur.default = MC;
var Ns = {}, Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
Vr.validateTuple = void 0;
const ml = re, Jn = fe, jC = ne, UC = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(e) {
    const { schema: t, it: r } = e;
    if (Array.isArray(t))
      return cd(e, "additionalItems", t);
    r.items = !0, !(0, Jn.alwaysValidSchema)(r, t) && e.ok((0, jC.validateArray)(e));
  }
};
function cd(e, t, r = e.schema) {
  const { gen: n, parentSchema: i, data: a, keyword: s, it: o } = e;
  u(i), o.opts.unevaluated && r.length && o.items !== !0 && (o.items = Jn.mergeEvaluated.items(n, r.length, o.items));
  const l = n.name("valid"), c = n.const("len", (0, ml._)`${a}.length`);
  r.forEach((f, p) => {
    (0, Jn.alwaysValidSchema)(o, f) || (n.if((0, ml._)`${c} > ${p}`, () => e.subschema({
      keyword: s,
      schemaProp: p,
      dataProp: p
    }, l)), e.ok(l));
  });
  function u(f) {
    const { opts: p, errSchemaPath: d } = o, m = r.length, h = m === f.minItems && (m === f.maxItems || f[t] === !1);
    if (p.strictTuples && !h) {
      const g = `"${s}" is ${m}-tuple, but minItems or maxItems/${t} are not specified or different at path "${d}"`;
      (0, Jn.checkStrictMode)(o, g, p.strictTuples);
    }
  }
}
Vr.validateTuple = cd;
Vr.default = UC;
Object.defineProperty(Ns, "__esModule", { value: !0 });
const VC = Vr, xC = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (e) => (0, VC.validateTuple)(e, "items")
};
Ns.default = xC;
var Ds = {};
Object.defineProperty(Ds, "__esModule", { value: !0 });
const pl = re, LC = fe, BC = ne, qC = Ur, KC = {
  message: ({ params: { len: e } }) => (0, pl.str)`must NOT have more than ${e} items`,
  params: ({ params: { len: e } }) => (0, pl._)`{limit: ${e}}`
}, zC = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: KC,
  code(e) {
    const { schema: t, parentSchema: r, it: n } = e, { prefixItems: i } = r;
    n.items = !0, !(0, LC.alwaysValidSchema)(n, t) && (i ? (0, qC.validateAdditionalItems)(e, i) : e.ok((0, BC.validateArray)(e)));
  }
};
Ds.default = zC;
var Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
const Ze = re, Mn = fe, WC = {
  message: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ze.str)`must contain at least ${e} valid item(s)` : (0, Ze.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
  params: ({ params: { min: e, max: t } }) => t === void 0 ? (0, Ze._)`{minContains: ${e}}` : (0, Ze._)`{minContains: ${e}, maxContains: ${t}}`
}, GC = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: WC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: a } = e;
    let s, o;
    const { minContains: l, maxContains: c } = n;
    a.opts.next ? (s = l === void 0 ? 1 : l, o = c) : s = 1;
    const u = t.const("len", (0, Ze._)`${i}.length`);
    if (e.setParams({ min: s, max: o }), o === void 0 && s === 0) {
      (0, Mn.checkStrictMode)(a, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (o !== void 0 && s > o) {
      (0, Mn.checkStrictMode)(a, '"minContains" > "maxContains" is always invalid'), e.fail();
      return;
    }
    if ((0, Mn.alwaysValidSchema)(a, r)) {
      let h = (0, Ze._)`${u} >= ${s}`;
      o !== void 0 && (h = (0, Ze._)`${h} && ${u} <= ${o}`), e.pass(h);
      return;
    }
    a.items = !0;
    const f = t.name("valid");
    o === void 0 && s === 1 ? d(f, () => t.if(f, () => t.break())) : s === 0 ? (t.let(f, !0), o !== void 0 && t.if((0, Ze._)`${i}.length > 0`, p)) : (t.let(f, !1), p()), e.result(f, () => e.reset());
    function p() {
      const h = t.name("_valid"), g = t.let("count", 0);
      d(h, () => t.if(h, () => m(g)));
    }
    function d(h, g) {
      t.forRange("i", 0, u, (y) => {
        e.subschema({
          keyword: "contains",
          dataProp: y,
          dataPropType: Mn.Type.Num,
          compositeRule: !0
        }, h), g();
      });
    }
    function m(h) {
      t.code((0, Ze._)`${h}++`), o === void 0 ? t.if((0, Ze._)`${h} >= ${s}`, () => t.assign(f, !0).break()) : (t.if((0, Ze._)`${h} > ${o}`, () => t.assign(f, !1).break()), s === 1 ? t.assign(f, !0) : t.if((0, Ze._)`${h} >= ${s}`, () => t.assign(f, !0)));
    }
  }
};
Fs.default = GC;
var ud = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
  const t = re, r = fe, n = ne;
  e.error = {
    message: ({ params: { property: l, depsCount: c, deps: u } }) => {
      const f = c === 1 ? "property" : "properties";
      return (0, t.str)`must have ${f} ${u} when property ${l} is present`;
    },
    params: ({ params: { property: l, depsCount: c, deps: u, missingProperty: f } }) => (0, t._)`{property: ${l},
    missingProperty: ${f},
    depsCount: ${c},
    deps: ${u}}`
    // TODO change to reference
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(l) {
      const [c, u] = a(l);
      s(l, c), o(l, u);
    }
  };
  function a({ schema: l }) {
    const c = {}, u = {};
    for (const f in l) {
      if (f === "__proto__")
        continue;
      const p = Array.isArray(l[f]) ? c : u;
      p[f] = l[f];
    }
    return [c, u];
  }
  function s(l, c = l.schema) {
    const { gen: u, data: f, it: p } = l;
    if (Object.keys(c).length === 0)
      return;
    const d = u.let("missing");
    for (const m in c) {
      const h = c[m];
      if (h.length === 0)
        continue;
      const g = (0, n.propertyInData)(u, f, m, p.opts.ownProperties);
      l.setParams({
        property: m,
        depsCount: h.length,
        deps: h.join(", ")
      }), p.allErrors ? u.if(g, () => {
        for (const y of h)
          (0, n.checkReportMissingProp)(l, y);
      }) : (u.if((0, t._)`${g} && (${(0, n.checkMissingProp)(l, h, d)})`), (0, n.reportMissingProp)(l, d), u.else());
    }
  }
  e.validatePropertyDeps = s;
  function o(l, c = l.schema) {
    const { gen: u, data: f, keyword: p, it: d } = l, m = u.name("valid");
    for (const h in c)
      (0, r.alwaysValidSchema)(d, c[h]) || (u.if(
        (0, n.propertyInData)(u, f, h, d.opts.ownProperties),
        () => {
          const g = l.subschema({ keyword: p, schemaProp: h }, m);
          l.mergeValidEvaluated(g, m);
        },
        () => u.var(m, !0)
        // TODO var
      ), l.ok(m));
  }
  e.validateSchemaDeps = o, e.default = i;
})(ud);
var ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
const dd = re, HC = fe, YC = {
  message: "property name must be valid",
  params: ({ params: e }) => (0, dd._)`{propertyName: ${e.propertyName}}`
}, JC = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: YC,
  code(e) {
    const { gen: t, schema: r, data: n, it: i } = e;
    if ((0, HC.alwaysValidSchema)(i, r))
      return;
    const a = t.name("valid");
    t.forIn("key", n, (s) => {
      e.setParams({ propertyName: s }), e.subschema({
        keyword: "propertyNames",
        data: s,
        dataTypes: ["string"],
        propertyName: s,
        compositeRule: !0
      }, a), t.if((0, dd.not)(a), () => {
        e.error(!0), i.allErrors || t.break();
      });
    }), e.ok(a);
  }
};
ks.default = JC;
var Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 });
const jn = ne, it = re, XC = vt, Un = fe, ZC = {
  message: "must NOT have additional properties",
  params: ({ params: e }) => (0, it._)`{additionalProperty: ${e.additionalProperty}}`
}, QC = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: ZC,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, errsCount: a, it: s } = e;
    if (!a)
      throw new Error("ajv implementation error");
    const { allErrors: o, opts: l } = s;
    if (s.props = !0, l.removeAdditional !== "all" && (0, Un.alwaysValidSchema)(s, r))
      return;
    const c = (0, jn.allSchemaProperties)(n.properties), u = (0, jn.allSchemaProperties)(n.patternProperties);
    f(), e.ok((0, it._)`${a} === ${XC.default.errors}`);
    function f() {
      t.forIn("key", i, (g) => {
        !c.length && !u.length ? m(g) : t.if(p(g), () => m(g));
      });
    }
    function p(g) {
      let y;
      if (c.length > 8) {
        const v = (0, Un.schemaRefOrVal)(s, n.properties, "properties");
        y = (0, jn.isOwnProperty)(t, v, g);
      } else
        c.length ? y = (0, it.or)(...c.map((v) => (0, it._)`${g} === ${v}`)) : y = it.nil;
      return u.length && (y = (0, it.or)(y, ...u.map((v) => (0, it._)`${(0, jn.usePattern)(e, v)}.test(${g})`))), (0, it.not)(y);
    }
    function d(g) {
      t.code((0, it._)`delete ${i}[${g}]`);
    }
    function m(g) {
      if (l.removeAdditional === "all" || l.removeAdditional && r === !1) {
        d(g);
        return;
      }
      if (r === !1) {
        e.setParams({ additionalProperty: g }), e.error(), o || t.break();
        return;
      }
      if (typeof r == "object" && !(0, Un.alwaysValidSchema)(s, r)) {
        const y = t.name("valid");
        l.removeAdditional === "failing" ? (h(g, y, !1), t.if((0, it.not)(y), () => {
          e.reset(), d(g);
        })) : (h(g, y), o || t.if((0, it.not)(y), () => t.break()));
      }
    }
    function h(g, y, v) {
      const b = {
        keyword: "additionalProperties",
        dataProp: g,
        dataPropType: Un.Type.Str
      };
      v === !1 && Object.assign(b, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), e.subschema(b, y);
    }
  }
};
Pi.default = QC;
var Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
const eA = lt, yl = ne, Hi = fe, gl = Pi, tA = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, parentSchema: n, data: i, it: a } = e;
    a.opts.removeAdditional === "all" && n.additionalProperties === void 0 && gl.default.code(new eA.KeywordCxt(a, gl.default, "additionalProperties"));
    const s = (0, yl.allSchemaProperties)(r);
    for (const f of s)
      a.definedProperties.add(f);
    a.opts.unevaluated && s.length && a.props !== !0 && (a.props = Hi.mergeEvaluated.props(t, (0, Hi.toHash)(s), a.props));
    const o = s.filter((f) => !(0, Hi.alwaysValidSchema)(a, r[f]));
    if (o.length === 0)
      return;
    const l = t.name("valid");
    for (const f of o)
      c(f) ? u(f) : (t.if((0, yl.propertyInData)(t, i, f, a.opts.ownProperties)), u(f), a.allErrors || t.else().var(l, !0), t.endIf()), e.it.definedProperties.add(f), e.ok(l);
    function c(f) {
      return a.opts.useDefaults && !a.compositeRule && r[f].default !== void 0;
    }
    function u(f) {
      e.subschema({
        keyword: "properties",
        schemaProp: f,
        dataProp: f
      }, l);
    }
  }
};
Rs.default = tA;
var Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
const vl = ne, Vn = re, $l = fe, _l = fe, rA = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(e) {
    const { gen: t, schema: r, data: n, parentSchema: i, it: a } = e, { opts: s } = a, o = (0, vl.allSchemaProperties)(r), l = o.filter((h) => (0, $l.alwaysValidSchema)(a, r[h]));
    if (o.length === 0 || l.length === o.length && (!a.opts.unevaluated || a.props === !0))
      return;
    const c = s.strictSchema && !s.allowMatchingProperties && i.properties, u = t.name("valid");
    a.props !== !0 && !(a.props instanceof Vn.Name) && (a.props = (0, _l.evaluatedPropsToName)(t, a.props));
    const { props: f } = a;
    p();
    function p() {
      for (const h of o)
        c && d(h), a.allErrors ? m(h) : (t.var(u, !0), m(h), t.if(u));
    }
    function d(h) {
      for (const g in c)
        new RegExp(h).test(g) && (0, $l.checkStrictMode)(a, `property ${g} matches pattern ${h} (use allowMatchingProperties)`);
    }
    function m(h) {
      t.forIn("key", n, (g) => {
        t.if((0, Vn._)`${(0, vl.usePattern)(e, h)}.test(${g})`, () => {
          const y = l.includes(h);
          y || e.subschema({
            keyword: "patternProperties",
            schemaProp: h,
            dataProp: g,
            dataPropType: _l.Type.Str
          }, u), a.opts.unevaluated && f !== !0 ? t.assign((0, Vn._)`${f}[${g}]`, !0) : !y && !a.allErrors && t.if((0, Vn.not)(u), () => t.break());
        });
      });
    }
  }
};
Ms.default = rA;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
const nA = fe, iA = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if ((0, nA.alwaysValidSchema)(n, r)) {
      e.fail();
      return;
    }
    const i = t.name("valid");
    e.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, i), e.failResult(i, () => e.reset(), () => e.error());
  },
  error: { message: "must NOT be valid" }
};
js.default = iA;
var Us = {};
Object.defineProperty(Us, "__esModule", { value: !0 });
const aA = ne, sA = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: aA.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
Us.default = sA;
var Vs = {};
Object.defineProperty(Vs, "__esModule", { value: !0 });
const Xn = re, oA = fe, lA = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: e }) => (0, Xn._)`{passingSchemas: ${e.passing}}`
}, cA = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: lA,
  code(e) {
    const { gen: t, schema: r, parentSchema: n, it: i } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && n.discriminator)
      return;
    const a = r, s = t.let("valid", !1), o = t.let("passing", null), l = t.name("_valid");
    e.setParams({ passing: o }), t.block(c), e.result(s, () => e.reset(), () => e.error(!0));
    function c() {
      a.forEach((u, f) => {
        let p;
        (0, oA.alwaysValidSchema)(i, u) ? t.var(l, !0) : p = e.subschema({
          keyword: "oneOf",
          schemaProp: f,
          compositeRule: !0
        }, l), f > 0 && t.if((0, Xn._)`${l} && ${s}`).assign(s, !1).assign(o, (0, Xn._)`[${o}, ${f}]`).else(), t.if(l, () => {
          t.assign(s, !0), t.assign(o, f), p && e.mergeEvaluated(p, Xn.Name);
        });
      });
    }
  }
};
Vs.default = cA;
var xs = {};
Object.defineProperty(xs, "__esModule", { value: !0 });
const uA = fe, dA = {
  keyword: "allOf",
  schemaType: "array",
  code(e) {
    const { gen: t, schema: r, it: n } = e;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const i = t.name("valid");
    r.forEach((a, s) => {
      if ((0, uA.alwaysValidSchema)(n, a))
        return;
      const o = e.subschema({ keyword: "allOf", schemaProp: s }, i);
      e.ok(i), e.mergeEvaluated(o);
    });
  }
};
xs.default = dA;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
const ui = re, fd = fe, fA = {
  message: ({ params: e }) => (0, ui.str)`must match "${e.ifClause}" schema`,
  params: ({ params: e }) => (0, ui._)`{failingKeyword: ${e.ifClause}}`
}, hA = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: fA,
  code(e) {
    const { gen: t, parentSchema: r, it: n } = e;
    r.then === void 0 && r.else === void 0 && (0, fd.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const i = bl(n, "then"), a = bl(n, "else");
    if (!i && !a)
      return;
    const s = t.let("valid", !0), o = t.name("_valid");
    if (l(), e.reset(), i && a) {
      const u = t.let("ifClause");
      e.setParams({ ifClause: u }), t.if(o, c("then", u), c("else", u));
    } else
      i ? t.if(o, c("then")) : t.if((0, ui.not)(o), c("else"));
    e.pass(s, () => e.error(!0));
    function l() {
      const u = e.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, o);
      e.mergeEvaluated(u);
    }
    function c(u, f) {
      return () => {
        const p = e.subschema({ keyword: u }, o);
        t.assign(s, o), e.mergeValidEvaluated(p, s), f ? t.assign(f, (0, ui._)`${u}`) : e.setParams({ ifClause: u });
      };
    }
  }
};
function bl(e, t) {
  const r = e.schema[t];
  return r !== void 0 && !(0, fd.alwaysValidSchema)(e, r);
}
Ls.default = hA;
var Bs = {};
Object.defineProperty(Bs, "__esModule", { value: !0 });
const mA = fe, pA = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: e, parentSchema: t, it: r }) {
    t.if === void 0 && (0, mA.checkStrictMode)(r, `"${e}" without "if" is ignored`);
  }
};
Bs.default = pA;
Object.defineProperty(Ts, "__esModule", { value: !0 });
const yA = Ur, gA = Ns, vA = Vr, $A = Ds, _A = Fs, bA = ud, SA = ks, wA = Pi, EA = Rs, OA = Ms, CA = js, AA = Us, PA = Vs, IA = xs, TA = Ls, NA = Bs;
function DA(e = !1) {
  const t = [
    // any
    CA.default,
    AA.default,
    PA.default,
    IA.default,
    TA.default,
    NA.default,
    // object
    SA.default,
    wA.default,
    bA.default,
    EA.default,
    OA.default
  ];
  return e ? t.push(gA.default, $A.default) : t.push(yA.default, vA.default), t.push(_A.default), t;
}
Ts.default = DA;
var qs = {}, Ks = {};
Object.defineProperty(Ks, "__esModule", { value: !0 });
const Pe = re, FA = {
  message: ({ schemaCode: e }) => (0, Pe.str)`must match format "${e}"`,
  params: ({ schemaCode: e }) => (0, Pe._)`{format: ${e}}`
}, kA = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: FA,
  code(e, t) {
    const { gen: r, data: n, $data: i, schema: a, schemaCode: s, it: o } = e, { opts: l, errSchemaPath: c, schemaEnv: u, self: f } = o;
    if (!l.validateFormats)
      return;
    i ? p() : d();
    function p() {
      const m = r.scopeValue("formats", {
        ref: f.formats,
        code: l.code.formats
      }), h = r.const("fDef", (0, Pe._)`${m}[${s}]`), g = r.let("fType"), y = r.let("format");
      r.if((0, Pe._)`typeof ${h} == "object" && !(${h} instanceof RegExp)`, () => r.assign(g, (0, Pe._)`${h}.type || "string"`).assign(y, (0, Pe._)`${h}.validate`), () => r.assign(g, (0, Pe._)`"string"`).assign(y, h)), e.fail$data((0, Pe.or)(v(), b()));
      function v() {
        return l.strictSchema === !1 ? Pe.nil : (0, Pe._)`${s} && !${y}`;
      }
      function b() {
        const w = u.$async ? (0, Pe._)`(${h}.async ? await ${y}(${n}) : ${y}(${n}))` : (0, Pe._)`${y}(${n})`, C = (0, Pe._)`(typeof ${y} == "function" ? ${w} : ${y}.test(${n}))`;
        return (0, Pe._)`${y} && ${y} !== true && ${g} === ${t} && !${C}`;
      }
    }
    function d() {
      const m = f.formats[a];
      if (!m) {
        v();
        return;
      }
      if (m === !0)
        return;
      const [h, g, y] = b(m);
      h === t && e.pass(w());
      function v() {
        if (l.strictSchema === !1) {
          f.logger.warn(C());
          return;
        }
        throw new Error(C());
        function C() {
          return `unknown format "${a}" ignored in schema at path "${c}"`;
        }
      }
      function b(C) {
        const E = C instanceof RegExp ? (0, Pe.regexpCode)(C) : l.code.formats ? (0, Pe._)`${l.code.formats}${(0, Pe.getProperty)(a)}` : void 0, _ = r.scopeValue("formats", { key: a, ref: C, code: E });
        return typeof C == "object" && !(C instanceof RegExp) ? [C.type || "string", C.validate, (0, Pe._)`${_}.validate`] : ["string", C, _];
      }
      function w() {
        if (typeof m == "object" && !(m instanceof RegExp) && m.async) {
          if (!u.$async)
            throw new Error("async format in sync schema");
          return (0, Pe._)`await ${y}(${n})`;
        }
        return typeof g == "function" ? (0, Pe._)`${y}(${n})` : (0, Pe._)`${y}.test(${n})`;
      }
    }
  }
};
Ks.default = kA;
Object.defineProperty(qs, "__esModule", { value: !0 });
const RA = Ks, MA = [RA.default];
qs.default = MA;
var Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.contentVocabulary = Nr.metadataVocabulary = void 0;
Nr.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
Nr.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(ps, "__esModule", { value: !0 });
const jA = ys, UA = vs, VA = Ts, xA = qs, Sl = Nr, LA = [
  jA.default,
  UA.default,
  (0, VA.default)(),
  xA.default,
  Sl.metadataVocabulary,
  Sl.contentVocabulary
];
ps.default = LA;
var zs = {}, hd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DiscrError = void 0, function(t) {
    t.Tag = "tag", t.Mapping = "mapping";
  }(e.DiscrError || (e.DiscrError = {}));
})(hd);
Object.defineProperty(zs, "__esModule", { value: !0 });
const $r = re, ha = hd, wl = ze, BA = fe, qA = {
  message: ({ params: { discrError: e, tagName: t } }) => e === ha.DiscrError.Tag ? `tag "${t}" must be string` : `value of tag "${t}" must be in oneOf`,
  params: ({ params: { discrError: e, tag: t, tagName: r } }) => (0, $r._)`{error: ${e}, tag: ${r}, tagValue: ${t}}`
}, KA = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: qA,
  code(e) {
    const { gen: t, data: r, schema: n, parentSchema: i, it: a } = e, { oneOf: s } = i;
    if (!a.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const o = n.propertyName;
    if (typeof o != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!s)
      throw new Error("discriminator: requires oneOf keyword");
    const l = t.let("valid", !1), c = t.const("tag", (0, $r._)`${r}${(0, $r.getProperty)(o)}`);
    t.if((0, $r._)`typeof ${c} == "string"`, () => u(), () => e.error(!1, { discrError: ha.DiscrError.Tag, tag: c, tagName: o })), e.ok(l);
    function u() {
      const d = p();
      t.if(!1);
      for (const m in d)
        t.elseIf((0, $r._)`${c} === ${m}`), t.assign(l, f(d[m]));
      t.else(), e.error(!1, { discrError: ha.DiscrError.Mapping, tag: c, tagName: o }), t.endIf();
    }
    function f(d) {
      const m = t.name("valid"), h = e.subschema({ keyword: "oneOf", schemaProp: d }, m);
      return e.mergeEvaluated(h, $r.Name), m;
    }
    function p() {
      var d;
      const m = {}, h = y(i);
      let g = !0;
      for (let w = 0; w < s.length; w++) {
        let C = s[w];
        C != null && C.$ref && !(0, BA.schemaHasRulesButRef)(C, a.self.RULES) && (C = wl.resolveRef.call(a.self, a.schemaEnv.root, a.baseId, C == null ? void 0 : C.$ref), C instanceof wl.SchemaEnv && (C = C.schema));
        const E = (d = C == null ? void 0 : C.properties) === null || d === void 0 ? void 0 : d[o];
        if (typeof E != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`);
        g = g && (h || y(C)), v(E, w);
      }
      if (!g)
        throw new Error(`discriminator: "${o}" must be required`);
      return m;
      function y({ required: w }) {
        return Array.isArray(w) && w.includes(o);
      }
      function v(w, C) {
        if (w.const)
          b(w.const, C);
        else if (w.enum)
          for (const E of w.enum)
            b(E, C);
        else
          throw new Error(`discriminator: "properties/${o}" must have "const" or "enum"`);
      }
      function b(w, C) {
        if (typeof w != "string" || w in m)
          throw new Error(`discriminator: "${o}" values must be unique strings`);
        m[w] = C;
      }
    }
  }
};
zs.default = KA;
const zA = "http://json-schema.org/draft-07/schema#", WA = "http://json-schema.org/draft-07/schema#", GA = "Core schema meta-schema", HA = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, YA = [
  "object",
  "boolean"
], JA = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, XA = {
  $schema: zA,
  $id: WA,
  title: GA,
  definitions: HA,
  type: YA,
  properties: JA,
  default: !0
};
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  const r = ku, n = ps, i = zs, a = XA, s = ["/properties"], o = "http://json-schema.org/draft-07/schema";
  class l extends r.default {
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((m) => this.addVocabulary(m)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const m = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
      this.addMetaSchema(m, o, !1), this.refs["http://json-schema.org/schema"] = o;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  e.exports = t = l, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = l;
  var c = lt;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var u = re;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return u._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return u.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return u.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return u.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return u.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return u.CodeGen;
  } });
  var f = bn;
  Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
    return f.default;
  } });
  var p = Sn;
  Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
    return p.default;
  } });
})(oa, oa.exports);
var md = oa.exports;
const ZA = /* @__PURE__ */ we(md);
var ma = { exports: {} }, pd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
  function t(F, j) {
    return { validate: F, compare: j };
  }
  e.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: t(a, s),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: t(l, c),
    "date-time": t(f, p),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: h,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: T,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte: y,
    // signed 32 bit integer
    int32: { type: "number", validate: w },
    // signed 64 bit integer
    int64: { type: "number", validate: C },
    // C-type float
    float: { type: "number", validate: E },
    // C-type double
    double: { type: "number", validate: E },
    // hint to the UI to hide input strings
    password: !0,
    // unchecked string payload
    binary: !0
  }, e.fastFormats = {
    ...e.fullFormats,
    date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, s),
    time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, c),
    "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, p),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  }, e.formatNames = Object.keys(e.fullFormats);
  function r(F) {
    return F % 4 === 0 && (F % 100 !== 0 || F % 400 === 0);
  }
  const n = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function a(F) {
    const j = n.exec(F);
    if (!j)
      return !1;
    const L = +j[1], U = +j[2], W = +j[3];
    return U >= 1 && U <= 12 && W >= 1 && W <= (U === 2 && r(L) ? 29 : i[U]);
  }
  function s(F, j) {
    if (F && j)
      return F > j ? 1 : F < j ? -1 : 0;
  }
  const o = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function l(F, j) {
    const L = o.exec(F);
    if (!L)
      return !1;
    const U = +L[1], W = +L[2], z = +L[3], q = L[5];
    return (U <= 23 && W <= 59 && z <= 59 || U === 23 && W === 59 && z === 60) && (!j || q !== "");
  }
  function c(F, j) {
    if (!(F && j))
      return;
    const L = o.exec(F), U = o.exec(j);
    if (L && U)
      return F = L[1] + L[2] + L[3] + (L[4] || ""), j = U[1] + U[2] + U[3] + (U[4] || ""), F > j ? 1 : F < j ? -1 : 0;
  }
  const u = /t|\s/i;
  function f(F) {
    const j = F.split(u);
    return j.length === 2 && a(j[0]) && l(j[1], !0);
  }
  function p(F, j) {
    if (!(F && j))
      return;
    const [L, U] = F.split(u), [W, z] = j.split(u), q = s(L, W);
    if (q !== void 0)
      return q || c(U, z);
  }
  const d = /\/|:/, m = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function h(F) {
    return d.test(F) && m.test(F);
  }
  const g = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function y(F) {
    return g.lastIndex = 0, g.test(F);
  }
  const v = -(2 ** 31), b = 2 ** 31 - 1;
  function w(F) {
    return Number.isInteger(F) && F <= b && F >= v;
  }
  function C(F) {
    return Number.isInteger(F);
  }
  function E() {
    return !0;
  }
  const _ = /[^\\]\\Z/;
  function T(F) {
    if (_.test(F))
      return !1;
    try {
      return new RegExp(F), !0;
    } catch {
      return !1;
    }
  }
})(pd);
var yd = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
  const t = md, r = re, n = r.operators, i = {
    formatMaximum: { okStr: "<=", ok: n.LTE, fail: n.GT },
    formatMinimum: { okStr: ">=", ok: n.GTE, fail: n.LT },
    formatExclusiveMaximum: { okStr: "<", ok: n.LT, fail: n.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: n.GT, fail: n.LTE }
  }, a = {
    message: ({ keyword: o, schemaCode: l }) => r.str`should be ${i[o].okStr} ${l}`,
    params: ({ keyword: o, schemaCode: l }) => r._`{comparison: ${i[o].okStr}, limit: ${l}}`
  };
  e.formatLimitDefinition = {
    keyword: Object.keys(i),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: a,
    code(o) {
      const { gen: l, data: c, schemaCode: u, keyword: f, it: p } = o, { opts: d, self: m } = p;
      if (!d.validateFormats)
        return;
      const h = new t.KeywordCxt(p, m.RULES.all.format.definition, "format");
      h.$data ? g() : y();
      function g() {
        const b = l.scopeValue("formats", {
          ref: m.formats,
          code: d.code.formats
        }), w = l.const("fmt", r._`${b}[${h.schemaCode}]`);
        o.fail$data(r.or(r._`typeof ${w} != "object"`, r._`${w} instanceof RegExp`, r._`typeof ${w}.compare != "function"`, v(w)));
      }
      function y() {
        const b = h.schema, w = m.formats[b];
        if (!w || w === !0)
          return;
        if (typeof w != "object" || w instanceof RegExp || typeof w.compare != "function")
          throw new Error(`"${f}": format "${b}" does not define "compare" function`);
        const C = l.scopeValue("formats", {
          key: b,
          ref: w,
          code: d.code.formats ? r._`${d.code.formats}${r.getProperty(b)}` : void 0
        });
        o.fail$data(v(C));
      }
      function v(b) {
        return r._`${b}.compare(${c}, ${u}) ${i[f].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  const s = (o) => (o.addKeyword(e.formatLimitDefinition), o);
  e.default = s;
})(yd);
(function(e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = pd, n = yd, i = re, a = new i.Name("fullFormats"), s = new i.Name("fastFormats"), o = (c, u = { keywords: !0 }) => {
    if (Array.isArray(u))
      return l(c, u, r.fullFormats, a), c;
    const [f, p] = u.mode === "fast" ? [r.fastFormats, s] : [r.fullFormats, a], d = u.formats || r.formatNames;
    return l(c, d, f, p), u.keywords && n.default(c), c;
  };
  o.get = (c, u = "full") => {
    const p = (u === "fast" ? r.fastFormats : r.fullFormats)[c];
    if (!p)
      throw new Error(`Unknown format "${c}"`);
    return p;
  };
  function l(c, u, f, p) {
    var d, m;
    (d = (m = c.opts.code).formats) !== null && d !== void 0 || (m.formats = i._`require("ajv-formats/dist/formats").${p}`);
    for (const h of u)
      c.addFormat(h, f[h]);
  }
  e.exports = t = o, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = o;
})(ma, ma.exports);
var QA = ma.exports;
const El = /* @__PURE__ */ we(QA), eP = {
  allErrors: !0,
  multipleOfPrecision: 8,
  strict: !1,
  verbose: !0
}, tP = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, rP = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
function nP(e, t, r = {}, n, i = ZA) {
  const a = new i({ ...eP, ...r });
  return n ? El(a, n) : n !== !1 && El(a), a.addFormat("data-url", rP), a.addFormat("color", tP), a.addKeyword(Dr), a.addKeyword(Ia), Array.isArray(e) && a.addMetaSchema(e), Qe(t) && Object.keys(t).forEach((s) => {
    a.addFormat(s, t[s]);
  }), a;
}
function iP(e = [], t) {
  return e.map((r) => {
    const { instancePath: n, keyword: i, params: a, schemaPath: s, parentSchema: o, ...l } = r;
    let { message: c = "" } = l, u = n.replace(/\//g, "."), f = `${u} ${c}`.trim();
    if ("missingProperty" in a) {
      u = u ? `${u}.${a.missingProperty}` : a.missingProperty;
      const p = a.missingProperty, d = oe(G(t, `${u.replace(/^\./, "")}`)).title;
      if (d)
        c = c.replace(p, d);
      else {
        const m = G(o, [Oe, p, "title"]);
        m && (c = c.replace(p, m));
      }
      f = c;
    } else {
      const p = oe(G(t, `${u.replace(/^\./, "")}`)).title;
      if (p)
        f = `'${p}' ${c}`.trim();
      else {
        const d = o == null ? void 0 : o.title;
        d && (f = `'${d}' ${c}`.trim());
      }
    }
    return {
      name: i,
      property: u,
      message: c,
      params: a,
      stack: f,
      schemaPath: s
    };
  });
}
function aP(e, t, r, n, i, a, s) {
  const { validationError: o } = t;
  let l = iP(t.errors, s);
  o && (l = [...l, { stack: o.message }]), typeof a == "function" && (l = a(l, s));
  let c = E1(l);
  if (o && (c = {
    ...c,
    $schema: {
      __errors: [o.message]
    }
  }), typeof i != "function")
    return { errors: l, errorSchema: c };
  const u = tu(e, n, r, n, !0), f = i(u, Xi(u), s), p = du(f);
  return Wn({ errors: l, errorSchema: c }, p);
}
class sP {
  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  constructor(t, r) {
    const { additionalMetaSchemas: n, customFormats: i, ajvOptionsOverrides: a, ajvFormatOptions: s, AjvClass: o } = t;
    this.ajv = nP(n, i, a, s, o), this.localizer = r;
  }
  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
   *
   * @param errorSchema - The `ErrorSchema` instance to convert
   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
   * @deprecated - Use the `toErrorList()` function provided by `@rjsf/utils` instead. This function will be removed in
   *        the next major release.
   */
  toErrorList(t, r = []) {
    return sn(t, r);
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */
  rawValidation(t, r) {
    let n, i;
    t[Mt] && (i = this.ajv.getSchema(t[Mt]));
    try {
      i === void 0 && (i = this.ajv.compile(t)), i(r);
    } catch (s) {
      n = s;
    }
    let a;
    return i && (typeof this.localizer == "function" && this.localizer(i.errors), a = i.errors || void 0, i.errors = null), {
      errors: a,
      validationError: n
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */
  validateFormData(t, r, n, i, a) {
    const s = this.rawValidation(r, t);
    return aP(this, s, t, r, n, i, a);
  }
  /**
   * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  handleSchemaUpdate(t) {
    var r, n;
    const i = (r = t[Mt]) !== null && r !== void 0 ? r : Bl;
    this.ajv.getSchema(i) === void 0 ? this.ajv.addSchema(t, i) : Be(t, (n = this.ajv.getSchema(i)) === null || n === void 0 ? void 0 : n.schema) || (this.ajv.removeSchema(i), this.ajv.addSchema(t, i));
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */
  isValid(t, r, n) {
    var i;
    try {
      this.handleSchemaUpdate(n);
      const a = as(t), s = (i = a[Mt]) !== null && i !== void 0 ? i : c1(a);
      let o;
      return o = this.ajv.getSchema(s), o === void 0 && (o = this.ajv.addSchema(a, s).getSchema(s) || this.ajv.compile(a)), o(r);
    } catch (a) {
      return console.warn("Error encountered compiling schema:", a), !1;
    }
  }
}
function oP(e = {}, t) {
  return new sP(e, t);
}
const lP = oP(), cP = {
  width: "100%"
}, xn = {
  width: "calc(100% / 4)"
};
function uP(e) {
  const { children: t, disabled: r, hasCopy: n, hasMoveDown: i, hasMoveUp: a, hasRemove: s, hasToolbar: o, index: l, onCopyIndexClick: c, onDropIndexClick: u, onReorderClick: f, readonly: p, registry: d, uiSchema: m } = e, { CopyButton: h, MoveDownButton: g, MoveUpButton: y, RemoveButton: v } = d.templates.ButtonTemplates, { rowGutter: b = 24, toolbarAlign: w = "top" } = d.formContext;
  return ee(ar, { align: w, gutter: b, children: [O(Fe, { flex: "1", children: t }), o && O(Fe, { flex: "192px", children: ee(Or.Group, { style: cP, children: [(a || i) && O(y, { disabled: r || p || !a, onClick: f(l, l - 1), style: xn, uiSchema: m, registry: d }), (a || i) && O(g, { disabled: r || p || !i, onClick: f(l, l + 1), style: xn, uiSchema: m, registry: d }), n && O(h, { disabled: r || p, onClick: c(l), style: xn, uiSchema: m, registry: d }), s && O(v, { disabled: r || p, onClick: u(l), style: xn, uiSchema: m, registry: d })] }) })] }, `array-item-${l}`);
}
const dP = {
  paddingBottom: "8px"
};
function fP(e) {
  const { canAdd: t, className: r, disabled: n, formContext: i, idSchema: a, items: s, onAddClick: o, readonly: l, registry: c, required: u, schema: f, title: p, uiSchema: d } = e, m = oe(d), h = ce("ArrayFieldDescriptionTemplate", c, m), g = ce("ArrayFieldItemTemplate", c, m), y = ce("ArrayFieldTitleTemplate", c, m), { ButtonTemplates: { AddButton: v } } = c.templates, { labelAlign: b = "right", rowGutter: w = 24 } = i, { getPrefixCls: C } = wt(ya.ConfigContext), _ = `${C("form")}-item-label`, T = ga(
    _,
    b === "left" && `${_}-left`
    // labelCol.className,
  );
  return O("fieldset", { className: r, id: a.$id, children: ee(ar, { gutter: w, children: [(m.title || p) && O(Fe, { className: T, span: 24, children: O(y, { idSchema: a, required: u, title: m.title || p, schema: f, uiSchema: d, registry: c }) }), (m.description || f.description) && O(Fe, { span: 24, style: dP, children: O(h, { description: m.description || f.description, idSchema: a, schema: f, uiSchema: d, registry: c }) }), O(Fe, { className: "row array-item-list", span: 24, children: s && s.map(({ key: F, ...j }) => O(g, { ...j }, F)) }), t && O(Fe, { span: 24, children: O(ar, { gutter: w, justify: "end", children: O(Fe, { flex: "192px", children: O(v, { className: "array-item-add", disabled: n || l, onClick: o, uiSchema: d, registry: c }) }) }) })] }) });
}
const Ol = {
  width: "100%"
};
function hP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onChangeOverride: s, onFocus: o, options: l, placeholder: c, readonly: u, schema: f, value: p, type: d } = e, m = su(f, d, l, !1), { readonlyAsDisabled: h = !0 } = r, g = (C) => a(C), y = s || (({ target: C }) => a(C.value === "" ? l.emptyValue : C.value)), v = ({ target: C }) => i(n, C && C.value), b = ({ target: C }) => o(n, C && C.value), w = m.type === "number" || m.type === "integer" ? O(Dd, { disabled: t || h && u, id: n, name: n, onBlur: u ? void 0 : v, onChange: u ? void 0 : g, onFocus: u ? void 0 : b, placeholder: c, style: Ol, list: f.examples ? Sr(n) : void 0, ...m, value: p, "aria-describedby": De(n, !!f.examples) }) : O(di, { disabled: t || h && u, id: n, name: n, onBlur: u ? void 0 : v, onChange: u ? void 0 : y, onFocus: u ? void 0 : b, placeholder: c, style: Ol, list: f.examples ? Sr(n) : void 0, ...m, value: p, "aria-describedby": De(n, !!f.examples) });
  return ee(at, { children: [w, Array.isArray(f.examples) && O("datalist", { id: Sr(n), children: f.examples.concat(f.default && !f.examples.includes(f.default) ? [f.default] : []).map((C) => O("option", { value: C }, C)) })] });
}
function mP(e) {
  const { id: t, description: r } = e;
  return r ? O("span", { id: t, children: r }) : null;
}
function pP({ errors: e, registry: t }) {
  const { translateString: r } = t;
  return O(Fd, { className: "panel panel-danger errors", description: (() => O(lo, { className: "list-group", size: "small", children: e.map((i, a) => O(lo.Item, { children: ee(kd, { children: [O(Ef, {}), i.stack] }) }, a)) }))(), message: r(le.ErrorsLabel), type: "error" });
}
function En(e) {
  const { iconType: t = "default", icon: r, onClick: n, uiSchema: i, registry: a, ...s } = e;
  return O(Or, { onClick: n, type: t, icon: r, ...s });
}
function yP(e) {
  const { registry: { translateString: t } } = e;
  return O(En, { title: t(le.AddItemButton), ...e, block: !0, iconType: "primary", icon: O(If, {}) });
}
function gP(e) {
  const { registry: { translateString: t } } = e;
  return O(En, { title: t(le.CopyButton), ...e, icon: O(Af, {}) });
}
function vP(e) {
  const { registry: { translateString: t } } = e;
  return O(En, { title: t(le.MoveDownButton), ...e, icon: O(Of, {}) });
}
function $P(e) {
  const { registry: { translateString: t } } = e;
  return O(En, { title: t(le.MoveUpButton), ...e, icon: O(Cf, {}) });
}
function _P(e) {
  const t = oe(e.uiSchema), { registry: { translateString: r } } = e;
  return O(En, { title: r(le.RemoveButton), ...e, danger: !0, block: !!t.block, iconType: "primary", icon: O(Pf, {}) });
}
function bP(e) {
  const { errors: t = [], idSchema: r } = e;
  if (t.length === 0)
    return null;
  const n = ns(r);
  return O("div", { id: n, children: t.map((i) => O("div", { children: i }, `field-${n}-error-${i}`)) });
}
const SP = { span: 24 }, wP = { span: 24 };
function EP(e) {
  const { children: t, classNames: r, style: n, description: i, disabled: a, displayLabel: s, errors: o, formContext: l, help: c, hidden: u, id: f, label: p, onDropPropertyClick: d, onKeyChange: m, rawErrors: h, rawDescription: g, rawHelp: y, readonly: v, registry: b, required: w, schema: C, uiSchema: E } = e, { colon: _, labelCol: T = SP, wrapperCol: F = wP, wrapperStyle: j, descriptionLocation: L = "below" } = l, U = oe(E), W = ce("WrapIfAdditionalTemplate", b, U);
  if (u)
    return O("div", { className: "field-hidden", children: t });
  const z = g ? i : void 0, q = {};
  switch (L) {
    case "tooltip":
      q.tooltip = z;
      break;
    case "below":
    default:
      q.extra = z;
      break;
  }
  return O(W, { classNames: r, style: n, disabled: a, id: f, label: p, onDropPropertyClick: d, onKeyChange: m, readonly: v, required: w, schema: C, uiSchema: E, registry: b, children: O(Al.Item, { colon: _, hasFeedback: C.type !== "array" && C.type !== "object", help: !!y && c || (h != null && h.length ? o : void 0), htmlFor: f, label: s && p, labelCol: T, required: w, style: j, validateStatus: h != null && h.length ? "error" : void 0, wrapperCol: F, ...q, children: t }) });
}
const OP = {
  paddingBottom: "8px"
};
function CP(e) {
  const { description: t, disabled: r, formContext: n, formData: i, idSchema: a, onAddClick: s, properties: o, readonly: l, required: c, registry: u, schema: f, title: p, uiSchema: d } = e, m = oe(d), h = ce("TitleFieldTemplate", u, m), g = ce("DescriptionFieldTemplate", u, m), { ButtonTemplates: { AddButton: y } } = u.templates, { colSpan: v = 24, labelAlign: b = "right", rowGutter: w = 24 } = n, C = (q) => q.content.props.schema, E = (q) => C(q).type, _ = (q) => q.content.props.uiSchema, T = (q) => oe(_(q)).field, F = (q) => oe(_(q)).widget, j = (q) => {
    const ue = E(q), me = T(q), ie = F(q), Y = o.length < 2 || // Single or no field in object.
    ue === "object" || ue === "array" || ie === "textarea" ? 24 : 12;
    if (Qe(v)) {
      const V = v;
      if (ir(ie))
        return V[ie];
      if (ir(me))
        return V[me];
      if (ir(ue))
        return V[ue];
    }
    return ja(v) ? v : Y;
  }, { getPrefixCls: L } = wt(ya.ConfigContext), W = `${L("form")}-item-label`, z = ga(
    W,
    b === "left" && `${W}-left`
    // labelCol.className,
  );
  return ee("fieldset", { id: a.$id, children: [ee(ar, { gutter: w, children: [p && O(Fe, { className: z, span: 24, children: O(h, { id: is(a), title: p, required: c, schema: f, uiSchema: d, registry: u }) }), t && O(Fe, { span: 24, style: OP, children: O(g, { id: jr(a), description: t, schema: f, uiSchema: d, registry: u }) }), o.filter((q) => !q.hidden).map((q) => O(Fe, { span: j(q), children: q.content }, q.name))] }), ql(f, d, i) && O(Fe, { span: 24, children: O(ar, { gutter: w, justify: "end", children: O(Fe, { flex: "192px", children: O(y, { className: "object-property-expand", disabled: r || l, onClick: s(f), uiSchema: d, registry: u }) }) }) })] });
}
function AP({ uiSchema: e }) {
  const { submitText: t, norender: r, props: n } = ou(e);
  return r ? null : O(Or, { type: "submit", ...n, htmlType: "submit", children: t });
}
function PP({ id: e, required: t, registry: r, title: n }) {
  const { formContext: i } = r, { colon: a = !0 } = i;
  let s = n;
  a && typeof n == "string" && n.trim() !== "" && (s = n.replace(/[:]\s*$/, ""));
  const o = () => {
    if (!e)
      return;
    const f = document.querySelector(`[id="${e}"]`);
    f && f.focus && f.focus();
  }, { getPrefixCls: l } = wt(ya.ConfigContext), c = l("form"), u = ga({
    [`${c}-item-required`]: t,
    [`${c}-item-no-colon`]: !a
  });
  return n ? O("label", { className: u, htmlFor: e, onClick: o, title: typeof n == "string" ? n : "", children: s }) : null;
}
const IP = { span: 24 }, TP = { span: 24 }, NP = {
  width: "100%"
};
function DP(e) {
  const { children: t, classNames: r, style: n, disabled: i, id: a, label: s, onDropPropertyClick: o, onKeyChange: l, readonly: c, required: u, registry: f, schema: p, uiSchema: d } = e, { colon: m, labelCol: h = IP, readonlyAsDisabled: g = !0, rowGutter: y = 24, toolbarAlign: v = "top", wrapperCol: b = TP, wrapperStyle: w } = f.formContext, { templates: C, translateString: E } = f, { RemoveButton: _ } = C.ButtonTemplates, T = E(le.KeyLabel, [s]);
  if (!(Dr in p))
    return O("div", { className: r, style: n, children: t });
  const j = ({ target: W }) => l(W && W.value), L = d ? d[nr] : {}, U = {
    ...d,
    [nr]: { ...L, block: !0 }
  };
  return O("div", { className: r, style: n, children: ee(ar, { align: v, gutter: y, children: [O(Fe, { className: "form-additional", flex: "1", children: O("div", { className: "form-group", children: O(Al.Item, { colon: m, className: "form-group", hasFeedback: !0, htmlFor: `${a}-key`, label: T, labelCol: h, required: u, style: w, wrapperCol: b, children: O(di, { className: "form-control", defaultValue: s, disabled: i || g && c, id: `${a}-key`, name: `${a}-key`, onBlur: c ? void 0 : j, style: NP, type: "text" }) }) }) }), O(Fe, { className: "form-additional", flex: "1", children: t }), O(Fe, { flex: "192px", children: O(_, { className: "array-item-remove", disabled: i || c, onClick: o(s), uiSchema: U, registry: f }) })] }) });
}
function FP() {
  return {
    ArrayFieldItemTemplate: uP,
    ArrayFieldTemplate: fP,
    BaseInputTemplate: hP,
    ButtonTemplates: {
      AddButton: yP,
      CopyButton: gP,
      MoveDownButton: vP,
      MoveUpButton: $P,
      RemoveButton: _P,
      SubmitButton: AP
    },
    DescriptionFieldTemplate: mP,
    ErrorListTemplate: pP,
    FieldErrorTemplate: bP,
    FieldTemplate: EP,
    ObjectFieldTemplate: CP,
    TitleFieldTemplate: PP,
    WrapIfAdditionalTemplate: DP
  };
}
const kP = (e, t) => {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push({ value: n, label: St(n, 2) });
  return r;
}, RP = (e) => Object.values(e).every((t) => t !== -1);
function Ws(e) {
  const { autofocus: t, disabled: r, formContext: n, id: i, onBlur: a, onChange: s, onFocus: o, options: l, readonly: c, registry: u, showTime: f, value: p } = e, { translateString: d, widgets: m } = u, { SelectWidget: h } = m, { rowGutter: g = 24 } = n, [y, v] = va(wr(p, f));
  $a(() => {
    v(wr(p, f));
  }, [f, p]);
  const b = (_, T) => {
    const F = {
      ...y,
      [_]: typeof T > "u" ? -1 : T
    };
    RP(F) ? s(ai(F, f)) : v(F);
  }, w = (_) => {
    if (_.preventDefault(), r || c)
      return;
    const T = wr((/* @__PURE__ */ new Date()).toJSON(), f);
    s(ai(T, f));
  }, C = (_) => {
    _.preventDefault(), !(r || c) && s(void 0);
  }, E = (_) => O(h, { autofocus: _.autofocus, className: "form-control", disabled: _.disabled, id: _.id, name: _.name, onBlur: _.onBlur, onChange: (T) => _.select(_.type, T), onFocus: _.onFocus, options: {
    enumOptions: kP(_.range[0], _.range[1])
  }, placeholder: _.type, readonly: _.readonly, schema: { type: "integer" }, value: _.value, registry: u, label: "", "aria-describedby": De(i) });
  return ee(ar, { gutter: [Math.floor(g / 2), Math.floor(g / 2)], children: [iu(y, f, l.yearsRange, l.format).map((_, T) => {
    const F = i + "_" + _.type;
    return O(Fe, { flex: "88px", children: E({
      ..._,
      autofocus: t && T === 0,
      disabled: r,
      id: F,
      name: i,
      onBlur: a,
      onFocus: o,
      readonly: c,
      registry: u,
      select: b,
      // NOTE: antd components accept -1 rather than issue a warning
      // like material-ui, so we need to convert -1 to undefined here.
      value: _.value || -1 < 0 ? void 0 : _.value
    }) }, F);
  }), !l.hideNowButton && O(Fe, { flex: "88px", children: O(Or, { block: !0, className: "btn-now", onClick: w, type: "primary", children: d(le.NowLabel) }) }), !l.hideClearButton && O(Fe, { flex: "88px", children: O(Or, { block: !0, className: "btn-clear", danger: !0, onClick: C, type: "primary", children: d(le.ClearLabel) }) })] });
}
Ws.defaultProps = {
  autofocus: !1,
  disabled: !1,
  options: {
    yearsRange: [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2]
  },
  readonly: !1,
  showTime: !1
};
function gd(e) {
  const { AltDateWidget: t } = e.registry.widgets;
  return O(t, { showTime: !0, ...e });
}
gd.defaultProps = {
  ...Ws.defaultProps,
  showTime: !0
};
function MP({ autofocus: e, disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, options: o, readonly: l, value: c }) {
  const { readonlyAsDisabled: u = !0 } = r, { enumOptions: f, enumDisabled: p, inline: d, emptyValue: m } = o, h = (w) => a(Ne(w, f, m)), v = {
    id: n,
    onBlur: l ? void 0 : ({ target: w }) => i(n, Ne(w.value, f, m)),
    onFocus: l ? void 0 : ({ target: w }) => s(n, Ne(w.value, f, m))
  }, b = bi(c, f, !0);
  return Array.isArray(f) && f.length > 0 ? O(at, { children: O(Yi.Group, { disabled: t || u && l, name: n, onChange: l ? void 0 : h, value: b, ...v, "aria-describedby": De(n), children: Array.isArray(f) && f.map((w, C) => ee("span", { children: [O(Yi, { id: Si(n, C), name: n, autoFocus: C === 0 ? e : !1, disabled: Array.isArray(p) && p.indexOf(w.value) !== -1, value: String(C), children: w.label }), !d && O("br", {})] }, C)) }) }) : null;
}
function jP(e) {
  const { autofocus: t, disabled: r, formContext: n, id: i, label: a, hideLabel: s, onBlur: o, onChange: l, onFocus: c, readonly: u, value: f } = e, { readonlyAsDisabled: p = !0 } = n;
  return O(Yi, { autoFocus: t, checked: typeof f > "u" ? !1 : f, disabled: r || p && u, id: i, name: i, onChange: u ? void 0 : ({ target: y }) => l(y.checked), ...{
    onBlur: u ? void 0 : ({ target: y }) => o(i, y && y.checked),
    onFocus: u ? void 0 : ({ target: y }) => c(i, y && y.checked)
  }, "aria-describedby": De(i), children: cu(a, s, "") });
}
const UP = {
  width: "100%"
};
function VP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, placeholder: o, readonly: l, value: c } = e, { readonlyAsDisabled: u = !0 } = r;
  return O(Pl, { disabled: t || u && l, getPopupContainer: (h) => h.parentNode, id: n, name: n, onBlur: l ? void 0 : () => i(n, c), onChange: l ? void 0 : (h) => a(h && h.toISOString()), onFocus: l ? void 0 : () => s(n, c), placeholder: o, showTime: !0, style: UP, value: c && Il(c), "aria-describedby": De(n) });
}
const xP = {
  width: "100%"
};
function LP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, placeholder: o, readonly: l, value: c } = e, { readonlyAsDisabled: u = !0 } = r;
  return O(Pl, { disabled: t || u && l, getPopupContainer: (h) => h.parentNode, id: n, name: n, onBlur: l ? void 0 : () => i(n, c), onChange: l ? void 0 : (h) => a(h && h.format("YYYY-MM-DD")), onFocus: l ? void 0 : () => s(n, c), placeholder: o, showTime: !1, style: xP, value: c && Il(c), "aria-describedby": De(n) });
}
function BP(e) {
  const { disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, options: o, placeholder: l, readonly: c, value: u } = e, { readonlyAsDisabled: f = !0 } = r, p = o.emptyValue || "", d = ({ target: g }) => a(g.value === "" ? p : g.value), m = ({ target: g }) => i(n, g.value), h = ({ target: g }) => s(n, g.value);
  return O(di.Password, { disabled: t || f && c, id: n, name: n, onBlur: c ? void 0 : m, onChange: c ? void 0 : d, onFocus: c ? void 0 : h, placeholder: l, value: u || "", "aria-describedby": De(n) });
}
function qP({ autofocus: e, disabled: t, formContext: r, id: n, onBlur: i, onChange: a, onFocus: s, options: o, readonly: l, value: c }) {
  const { readonlyAsDisabled: u = !0 } = r, { enumOptions: f, enumDisabled: p, emptyValue: d } = o, m = ({ target: { value: v } }) => a(Ne(v, f, d)), h = ({ target: v }) => i(n, Ne(v && v.value, f, d)), g = ({ target: v }) => s(n, Ne(v && v.value, f, d)), y = bi(c, f);
  return O(co.Group, { disabled: t || u && l, id: n, name: n, onChange: l ? void 0 : m, onBlur: l ? void 0 : h, onFocus: l ? void 0 : g, value: y, "aria-describedby": De(n), children: Array.isArray(f) && f.map((v, b) => O(co, { id: Si(n, b), name: n, autoFocus: b === 0 ? e : !1, disabled: Array.isArray(p) && p.indexOf(v.value) !== -1, value: String(b), children: v.label }, b)) });
}
function KP(e) {
  const { autofocus: t, disabled: r, formContext: n, id: i, onBlur: a, onChange: s, onFocus: o, options: l, placeholder: c, readonly: u, schema: f, value: p } = e, { readonlyAsDisabled: d = !0 } = n, { min: m, max: h, step: g } = au(f), y = l.emptyValue || "";
  return O(Rd, { autoFocus: t, disabled: r || d && u, id: i, max: h, min: m, onChange: u ? void 0 : (E) => s(E === "" ? y : E), range: !1, step: g, value: p, ...{
    placeholder: c,
    onBlur: u ? void 0 : () => a(i, p),
    onFocus: u ? void 0 : () => o(i, p)
  }, "aria-describedby": De(i) });
}
const zP = {
  width: "100%"
};
function WP({ autofocus: e, disabled: t, formContext: r = {}, id: n, multiple: i, onBlur: a, onChange: s, onFocus: o, options: l, placeholder: c, readonly: u, value: f }) {
  const { readonlyAsDisabled: p = !0 } = r, { enumOptions: d, enumDisabled: m, emptyValue: h } = l, g = (_) => s(Ne(_, d, h)), y = () => a(n, Ne(f, d, h)), v = () => o(n, Ne(f, d, h)), b = (_, T) => T && ir(T.label) ? T.label.toLowerCase().indexOf(_.toLowerCase()) >= 0 : !1, w = (_) => _.parentNode, C = bi(f, d, i);
  return O(Md, { autoFocus: e, disabled: t || p && u, getPopupContainer: w, id: n, mode: i ? "multiple" : void 0, onBlur: u ? void 0 : y, onChange: u ? void 0 : g, onFocus: u ? void 0 : v, placeholder: c, style: zP, value: C, ...{
    name: n
  }, filterOption: b, "aria-describedby": De(n), options: Array.isArray(d) ? d.map(({ value: _, label: T }, F) => ({
    disabled: Array.isArray(m) && m.indexOf(_) !== -1,
    key: String(F),
    value: String(F),
    label: T
  })) : void 0 });
}
const GP = {
  width: "100%"
};
function HP({ disabled: e, formContext: t, id: r, onBlur: n, onChange: i, onFocus: a, options: s, placeholder: o, readonly: l, value: c }) {
  const { readonlyAsDisabled: u = !0 } = t, f = ({ target: h }) => i(h.value === "" ? s.emptyValue : h.value), p = ({ target: h }) => n(r, h && h.value), d = ({ target: h }) => a(r, h && h.value), m = {
    type: "textarea"
  };
  return O(di.TextArea, { disabled: e || u && l, id: r, name: r, onBlur: l ? void 0 : p, onChange: l ? void 0 : f, onFocus: l ? void 0 : d, placeholder: o, rows: s.rows || 4, style: GP, value: c, ...m, "aria-describedby": De(r) });
}
function YP() {
  return {
    AltDateTimeWidget: gd,
    AltDateWidget: Ws,
    CheckboxesWidget: MP,
    CheckboxWidget: jP,
    DateTimeWidget: VP,
    DateWidget: LP,
    PasswordWidget: BP,
    RadioWidget: qP,
    RangeWidget: KP,
    SelectWidget: WP,
    TextareaWidget: HP
  };
}
function vd() {
  return {
    templates: FP(),
    widgets: YP()
  };
}
const Gs = vd();
function JP() {
  return Fu(vd());
}
JP();
Gs.widgets.DateWidget = xl(!1);
Gs.widgets.DateTimeWidget = xl(!0);
const XP = Fu(Gs), ZP = [Yd], QP = jd.div`
  ${(e) => e.$animationStyle}
  background: ${(e) => e.$style.background};
  border: 1px solid ${(e) => e.$style.border};
  padding: 15px;
  width: 100%;
  height: 100%;
  overflow: auto;
  border-radius: ${(e) => e.$style.radius};

  label[for="root-title"] {
    font-size: 18px;
  }

  #root-description {
    font-size: 12px;
    display: inline-block;
    line-height: 2;
  }

  .ant-form-item-label {
    padding: 0;
    font-weight: 600;
  }

  .ant-form-item-extra {
    min-height: 0px;
  }
  .ant-form-item-explain {
    line-height: 24px;
  }

  .ant-form-item {
    margin-bottom: 8px;
  }

  .help-block {
    margin-bottom: 0px;
  }
`;
function Hs(e, t) {
  if (!e)
    return t;
  if (!(e.type !== "object" && (t == null || t === "")))
    switch (e.type) {
      case "string":
        return Xd(t);
      case "number":
        return ho(t);
      case "integer":
        return Math.trunc(ho(t));
      case "boolean":
        return Jd(t);
      case "null":
        return null;
      case "object": {
        const r = e.properties;
        if (!r)
          return t;
        let n = {};
        return Object.entries(r).forEach(([i, a]) => {
          const s = t ? t[i] : void 0;
          n[i] = typeof a == "object" ? Hs(a, s) : s;
        }), n;
      }
      default:
        return t;
    }
}
function eI(e) {
  switch (e.name) {
    case "required":
      return Ee("jsonSchemaForm.required");
    case "maximum":
      return Ee("jsonSchemaForm.maximum", {
        value: e.params.limit
      });
    case "minimum":
      return Ee("jsonSchemaForm.minimum", {
        value: e.params.limit
      });
    case "exclusiveMaximum":
      return Ee("jsonSchemaForm.exclusiveMaximum", {
        value: e.params.limit
      });
    case "exclusiveMinimum":
      return Ee("jsonSchemaForm.exclusiveMinimum", {
        value: e.params.limit
      });
    case "multipleOf":
      return Ee("jsonSchemaForm.multipleOf", {
        value: e.params.multipleOf
      });
    case "minLength":
      return Ee("jsonSchemaForm.minLength", {
        value: e.params.limit
      });
    case "maxLength":
      return Ee("jsonSchemaForm.maxLength", {
        value: e.params.limit
      });
    case "pattern":
      return Ee("jsonSchemaForm.pattern", {
        value: e.params.pattern
      });
    case "format":
      return Ee("jsonSchemaForm.format", {
        value: e.params.format
      });
  }
  return "";
}
function tI(e) {
  return e.map((t) => {
    const r = eI(t);
    return r && (t.message = r, t.stack = ""), t;
  });
}
function $d(e) {
  return e.onEvent("submit").then(() => {
    e.resetAfterSubmit && e.data.reset();
  });
}
let rI = function() {
  const e = {
    resetAfterSubmit: Ud,
    schema: uo(Ti.jsonForm.defaultSchema),
    uiSchema: uo(Ti.jsonForm.defaultUiSchema),
    data: Vd("data", Ti.jsonForm.defaultFormData),
    onEvent: xd(ZP),
    style: fo(Ld, "style"),
    animationStyle: fo(Bd, "animationStyle")
  };
  return new qd(e, (t) => {
    var n, i, a;
    const r = (n = t == null ? void 0 : t.uiSchema) == null ? void 0 : n["ui:submitButtonOptions"];
    return /* @__PURE__ */ O(QP, {
      $style: t.style,
      $animationStyle: t.animationStyle,
      children: /* @__PURE__ */ O(wf, {
        children: /* @__PURE__ */ O(XP, {
          validator: lP,
          schema: t.schema,
          uiSchema: t.uiSchema,
          formData: Hs(t.schema, t.data.value),
          onSubmit: () => $d(t),
          onChange: (s) => t.data.onChange(s.formData),
          transformErrors: (s) => tI(s),
          children: /* @__PURE__ */ O(Or, {
            hidden: r == null ? void 0 : r.norender,
            disabled: (i = r == null ? void 0 : r.props) == null ? void 0 : i.disabled,
            className: (a = r == null ? void 0 : r.props) == null ? void 0 : a.className,
            type: "primary",
            htmlType: "submit",
            style: {
              float: "right"
            },
            children: (r == null ? void 0 : r.submitText) ?? Ee("event.submit")
          })
        })
      })
    });
  }).setPropertyViewFn((t) => /* @__PURE__ */ ee(at, {
    children: [(wt(mr).editorModeStatus === "logic" || wt(mr).editorModeStatus === "both") && /* @__PURE__ */ ee(In, {
      name: Tn.basic,
      children: [t.schema.propertyView({
        key: Ee("jsonSchemaForm.jsonSchema"),
        label: /* @__PURE__ */ ee(at, {
          children: [Ee("jsonSchemaForm.jsonSchema") + " (", /* @__PURE__ */ O("a", {
            href: "http://json-schema.org/learn/getting-started-step-by-step",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 1"
          }), ", ", /* @__PURE__ */ O("a", {
            href: "https://jsonforms.io/examples/basic",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 2"
          }), ")"]
        }),
        tooltip: /* @__PURE__ */ ee(at, {
          children: [Ee("jsonSchemaForm.schemaTooltip") + " ", /* @__PURE__ */ O("a", {
            href: "http://json-schema.org/learn/getting-started-step-by-step",
            target: "_blank",
            rel: "noreferrer",
            children: "JSON schema"
          })]
        })
      }), t.uiSchema.propertyView({
        key: Ee("jsonSchemaForm.uiSchema"),
        label: /* @__PURE__ */ ee(at, {
          children: [Ee("jsonSchemaForm.uiSchema") + " (", /* @__PURE__ */ O("a", {
            href: "https://jsonforms.io/docs/uischema",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 1"
          }), ", ", /* @__PURE__ */ O("a", {
            href: "https://rjsf-team.github.io/react-jsonschema-form/docs/api-reference/uiSchema",
            target: "_blank",
            rel: "noreferrer",
            children: "Docs 2"
          }), ")"]
        }),
        tooltip: /* @__PURE__ */ ee(at, {
          children: [Ee("jsonSchemaForm.schemaTooltip") + " ", /* @__PURE__ */ O("a", {
            href: "https://jsonforms.io/docs/uischema",
            target: "_blank",
            rel: "noreferrer",
            children: "UI schema"
          })]
        })
      }), t.data.propertyView({
        key: Ee("jsonSchemaForm.defaultData"),
        label: Ee("jsonSchemaForm.defaultData")
      })]
    }), (wt(mr).editorModeStatus === "logic" || wt(mr).editorModeStatus === "both") && /* @__PURE__ */ ee(In, {
      name: Tn.interaction,
      children: [t.onEvent.getPropertyView(), Kd(t), t.resetAfterSubmit.propertyView({
        label: Ee("jsonSchemaForm.resetAfterSubmit")
      })]
    }), (wt(mr).editorModeStatus === "layout" || wt(mr).editorModeStatus === "both") && /* @__PURE__ */ ee(at, {
      children: [/* @__PURE__ */ O(In, {
        name: Tn.style,
        children: t.style.getPropertyView()
      }), /* @__PURE__ */ O(In, {
        name: Tn.animationStyle,
        hasTooltip: !0,
        children: t.animationStyle.getPropertyView()
      })]
    })]
  })).build();
}(), pa = zd(rI, [Wd({
  name: "data",
  desc: Ee("jsonSchemaForm.dataDesc"),
  depKeys: ["schema", "data"],
  func: (e) => Hs(e.schema, e.data)
}), Gd]);
pa = Hd(pa, [{
  method: {
    name: "submit",
    description: Ee("export.submitDesc"),
    params: []
  },
  // FIXME: currently, it cannot be verified when submitted through the method, fix it later
  execute: (e, t) => $d({
    resetAfterSubmit: e.children.resetAfterSubmit.getView(),
    data: e.children.data.getView(),
    onEvent: e.children.onEvent.getView()
  })
}]);
const _I = pa;
export {
  _I as JsonSchemaFormComp
};
