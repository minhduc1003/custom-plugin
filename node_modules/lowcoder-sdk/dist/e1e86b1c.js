import { a8 as o, G as u, F as r, Y as t, ch as _, a as C, cw as A, O as R, bI as G, a3 as W, Z as I, cx as X, az as H, cy as J, w as k, L as E, X as M, cz as q, cA as Y, S as Z, a4 as K, U as Q, a9 as g, aa as x, ah as y, bJ as ee, ab as te, cg as ie, cB as $, cC as c, ac as ae, ae as v, cD as le, bL as ne, a2 as oe, av as re, aw as se, ax as ce, cE as z, cF as T, bU as w, cG as U, _ as N, bV as de, cH as fe } from "./c988e26e.js";
import { useContext as S, useState as ue, useEffect as me } from "react";
import { formDataChildren as pe, FormDataPropertyView as he } from "./85e61f03.js";
import "react-dom";
const L = fe((e) => {
  var a;
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const l = e.trim();
    if (l === "")
      return 0;
    const s = Number(l);
    if (!N.isNaN(s))
      return s;
    const d = ["bytes", "kb", "mb", "gb", "tb"];
    if (new RegExp("^\\d+\\s*[kmgt]b$", "i").test(l)) {
      const m = parseInt(((a = l.match("^\\d+")) == null ? void 0 : a[0]) ?? "", 10), i = d.findIndex((b) => l.search(new RegExp(b, "i")) !== -1);
      return m * Math.pow(1024, i);
    }
  }
  throw new TypeError(t("file.typeErrorMsg", {
    value: typeof e
  }));
}), D = /* @__PURE__ */ o(u, {
  children: [/* @__PURE__ */ r("div", {
    children: t("file.parsedValueTooltip1")
  }), /* @__PURE__ */ r("div", {
    children: t("file.parsedValueTooltip2")
  })]
}), ge = [_, {
  label: t("event.parse"),
  value: "parse",
  description: t("event.parseDesc")
}], xe = {
  minSize: L,
  maxSize: L,
  maxFiles: oe
}, be = {
  value: C([]),
  files: C([]),
  fileType: A,
  showUploadList: R.DEFAULT_TRUE,
  disabled: G,
  onEvent: W(ge),
  style: I(X, "style"),
  animationStyle: I(H, "animationStyle"),
  parseFiles: J,
  parsedValue: C([]),
  prefixIcon: k(E, "/icon:solid/arrow-up-from-bracket"),
  suffixIcon: E,
  ...xe
}, ye = (e) => [e.minSize.propertyView({
  label: t("file.minSize"),
  placeholder: "1kb",
  tooltip: t("file.minSizeTooltip")
}), e.maxSize.propertyView({
  label: t("file.maxSize"),
  placeholder: "10kb",
  tooltip: t("file.maxSizeTooltip")
})], we = (e) => ({
  accept: e.fileType.toString(),
  multiple: e.uploadType === "multiple",
  directory: e.uploadType === "directory",
  showUploadList: e.showUploadList,
  customRequest: (a) => a.onSuccess && a.onSuccess({})
  // Override the default upload logic and do not upload to the specified server
}), Se = (e) => re`
    .ant-btn {
      border-radius: ${e.radius};
      rotate: ${e.rotation};
      margin: ${e.margin};	
      padding: ${e.padding};	
      width: ${se(e.margin)};	
      height: ${ce(e.margin)};
      font-family:${e.fontFamily};
      font-size:${e.textSize};
      font-weight:${e.textWeight};
      font-style:${e.fontStyle};
      border-width:${e.borderWidth};
      border-style:${e.borderStyle};
      text-decoration:${e.textDecoration};
      text-transform:${e.textTransform};
      text-transform:${e.textTransform};
    }

    .ant-btn:not(:disabled) {
      border-color: ${e.border};
      background-color: ${e.background};
      color: ${e.text};

      &:hover,
      &:focus {
        border-color: ${e.accent};
        color: ${e.accent};
      }

      &:active {
        border-color: ${z(e.accent, 0.1)};
        color: ${z(e.accent, 0.1)};
      }
    }
  `, Ve = M(T)`
  .ant-upload,
  .ant-btn {
    ${(e) => e.$animationStyle}
    width: 100%;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    gap: 6px;

    > span {
      overflow: hidden;
      display: inline-flex;
      justify-content: flex-start;
      align-items: center;
      gap: 6px;
      min-height: 1px;
    }
  }
  ${(e) => e.$style && Se(e.$style)}
`, P = M.span`
  display: flex;
`;
function Ce(e) {
  return Promise.all(e.map((a) => {
    var l;
    return ((l = a.originFileObj) == null ? void 0 : l.arrayBuffer().then((s) => q.Buffer.from(s).toString("base64")).catch(() => null)) ?? null;
  }));
}
function ve(e) {
  return Promise.all(e.map(async (a) => {
    var s;
    const l = await import("./2112abba.js");
    return ((s = a.originFileObj) == null ? void 0 : s.arrayBuffer().then((d) => {
      var i;
      const f = Y.getExtension(((i = a.originFileObj) == null ? void 0 : i.type) ?? "");
      if (f === "xlsx" || f === "csv") {
        const b = l.read(d, {
          raw: !0,
          codepage: 65001
        });
        return l.utils.sheet_to_json(b.Sheets[b.SheetNames[0]], {
          raw: !1
        });
      }
      const m = new TextDecoder("utf-8").decode(d);
      return m ? JSON.parse(m) : null;
    }).catch(() => null)) ?? null;
  }));
}
const $e = (e) => {
  const {
    dispatch: a,
    files: l,
    style: s
  } = e, [d, f] = ue(l.map((i) => ({
    ...i,
    status: "done"
  })));
  me(() => {
    l.length === 0 && d.length !== 0 && f([]);
  }, [l]);
  const m = w(e.prefixIcon) || !!e.text || w(e.suffixIcon);
  return /* @__PURE__ */ r(Ve, {
    $animationStyle: e.animationStyle,
    ...we(e),
    $style: s,
    fileList: d,
    beforeUpload: (i) => !i.size || i.size <= 0 ? (U.error(`${i.name} ` + t("file.fileEmptyErrorMsg")), T.LIST_IGNORE) : e.minSize && i.size < e.minSize || e.maxSize && i.size > e.maxSize ? (U.error(`${i.name} ` + t("file.fileSizeExceedErrorMsg")), T.LIST_IGNORE) : !0,
    onChange: (i) => {
      if (i.fileList.filter((n) => n.status === "uploading").length !== 0) {
        f(i.fileList);
        return;
      }
      let p = e.maxFiles;
      e.uploadType === "single" ? p = 1 : e.maxFiles <= 0 && (p = 100);
      const h = i.fileList.filter((n) => n.status === "done");
      if (i.file.status === "removed") {
        const n = e.files.findIndex((V) => V.uid === i.file.uid);
        a($({
          value: c([...e.value.slice(0, n), ...e.value.slice(n + 1)], !1),
          files: c([...e.files.slice(0, n), ...e.files.slice(n + 1)], !1),
          parsedValue: c([...e.parsedValue.slice(0, n), ...e.parsedValue.slice(n + 1)], !1)
        })), e.onEvent("change");
      } else {
        const n = Math.min(e.value.length, h.length), V = Math.min(e.parsedValue.length, h.length);
        Promise.all([Ce(h.slice(n)), ve(h.slice(V))]).then(([B, O]) => {
          a($({
            value: c([...e.value, ...B].slice(-p), !1),
            files: c(h.map((j) => N.pick(j, ["uid", "name", "type", "size", "lastModified"])).slice(-p), !1),
            ...e.parseFiles ? {
              parsedValue: c([...e.parsedValue, ...O].slice(-p), !1)
            } : {}
          })), e.onEvent("change"), e.onEvent("parse");
        });
      }
      f(h.slice(-p));
    },
    children: /* @__PURE__ */ r(de, {
      disabled: e.disabled,
      children: m && /* @__PURE__ */ o("span", {
        children: [w(e.prefixIcon) && /* @__PURE__ */ r(P, {
          children: e.prefixIcon
        }), !!e.text && e.text, w(e.suffixIcon) && /* @__PURE__ */ r(P, {
          children: e.suffixIcon
        })]
      })
    })
  });
}, Te = [{
  label: t("file.single"),
  value: "single"
}, {
  label: t("file.multiple"),
  value: "multiple"
}, {
  label: t("file.directory"),
  value: "directory"
}], Fe = {
  text: k(Z, t("file.upload")),
  uploadType: K(Te, "single"),
  ...be,
  ...pe
};
let F = new Q(Fe, (e, a) => /* @__PURE__ */ r($e, {
  ...e,
  dispatch: a
})).setPropertyViewFn((e) => /* @__PURE__ */ o(u, {
  children: [/* @__PURE__ */ o(g, {
    name: x.basic,
    children: [e.text.propertyView({
      label: t("text")
    }), e.uploadType.propertyView({
      label: t("file.uploadType")
    })]
  }), /* @__PURE__ */ r(he, {
    ...e
  }), (S(y).editorModeStatus === "logic" || S(y).editorModeStatus === "both") && /* @__PURE__ */ o(u, {
    children: [/* @__PURE__ */ o(g, {
      name: x.validation,
      children: [e.uploadType.getView() !== "single" && e.maxFiles.propertyView({
        label: t("file.maxFiles")
      }), ye(e)]
    }), /* @__PURE__ */ o(g, {
      name: x.interaction,
      children: [e.onEvent.getPropertyView(), ee(e), te(e)]
    }), /* @__PURE__ */ o(g, {
      name: x.advanced,
      children: [e.fileType.propertyView({
        label: t("file.fileType"),
        placeholder: '[".png"]',
        tooltip: /* @__PURE__ */ o(u, {
          children: [t("file.reference"), " ", /* @__PURE__ */ r("a", {
            href: t("file.fileTypeTooltipUrl"),
            target: "_blank",
            rel: "noreferrer",
            children: t("file.fileTypeTooltip")
          })]
        })
      }), e.prefixIcon.propertyView({
        label: t("button.prefixIcon")
      }), e.suffixIcon.propertyView({
        label: t("button.suffixIcon")
      }), e.showUploadList.propertyView({
        label: t("file.showUploadList")
      }), e.parseFiles.propertyView({
        label: t("file.parseFiles"),
        tooltip: D,
        placement: "right"
      })]
    })]
  }), (S(y).editorModeStatus === "layout" || S(y).editorModeStatus === "both") && /* @__PURE__ */ o(u, {
    children: [/* @__PURE__ */ r(g, {
      name: x.style,
      children: e.style.getPropertyView()
    }), /* @__PURE__ */ r(g, {
      name: x.animationStyle,
      hasTooltip: !0,
      children: e.animationStyle.getPropertyView()
    })]
  })]
})).build();
F = ie(F, [{
  method: {
    name: "clearValue",
    description: t("file.clearValueDesc"),
    params: []
  },
  execute: (e) => e.dispatch($({
    value: c([], !1),
    files: c([], !1),
    parsedValue: c([], !1)
  }))
}]);
const Le = ae(F, [new v("value", t("file.filesValueDesc")), new v("files", /* @__PURE__ */ o(u, {
  children: [t("file.filesDesc"), (() => {
    const e = le("file");
    if (e)
      return /* @__PURE__ */ o(u, {
        children: ["Â ", /* @__PURE__ */ r("a", {
          href: e,
          target: "_blank",
          rel: "noreferrer",
          children: t("uiComp.fileUploadCompName")
        })]
      });
  })()]
})), new v("parsedValue", D), ...ne]);
export {
  Le as FileComp,
  ve as resolveParsedValue,
  Ce as resolveValue
};
