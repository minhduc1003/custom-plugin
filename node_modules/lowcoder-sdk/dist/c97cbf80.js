import { a5 as u, U as v, ah as f, F as r, i3 as y, cg as C } from "./c988e26e.js";
import { useContext as w } from "react";
import { TourChildrenMap as T, TourPropertyView as x } from "./df82265d.js";
import "react-dom";
import "./432d6870.js";
import "./3f72c732.js";
import "./ebbc0fd0.js";
let I = function() {
  const a = {
    ...T,
    defaultValue: u("defaultValue"),
    value: u("value")
    // style: styleControl(SelectStyle),
  };
  return new v(a, (e, M) => {
    const s = w(f), p = Object.values(s.getAllUICompMap()), g = e.options.map((t) => {
      var i, c, l, m;
      const h = t.target;
      let o;
      const n = p.find((d) => d.children.name.getView() === h);
      if (n)
        try {
          o = (c = (i = n.children.comp).getRef) == null ? void 0 : c.call(i);
        } catch {
          o = (m = (l = n.children.comp).getRef) == null ? void 0 : m.call(l);
        }
      return {
        /**
         * I'm pretty sure it's safe to use dangerouslySetInnerHTML here as any creator of an app
         * will have unrestricted access to the data of any user anyway. E.g. have a button that
         * just sends the current cookies wherever, thus the developer of the app must be trusted
         * in all cases
         * This even applies to things like <b onmouseover="alert('mouseover');">, because the
         * app creator might desire functionality like this.
         */
        title: /* @__PURE__ */ r("div", {
          dangerouslySetInnerHTML: {
            __html: t.title
          }
        }),
        description: /* @__PURE__ */ r("div", {
          dangerouslySetInnerHTML: {
            __html: t.description
          }
        }),
        target: o == null ? void 0 : o.current,
        arrow: t.arrow,
        placement: t.placement === "" ? void 0 : t.placement,
        mask: t.mask,
        cover: t.cover ? /* @__PURE__ */ r("img", {
          src: t.cover
        }) : void 0,
        type: t.type === "" ? void 0 : t.type
      };
    });
    return /* @__PURE__ */ r(y, {
      steps: g,
      open: e.open.value,
      onClose: () => e.open.onChange(!1),
      disabledInteraction: e.disabledInteraction,
      arrow: e.arrow,
      placement: e.placement === "" ? void 0 : e.placement,
      type: e.type === "" ? void 0 : e.type,
      mask: e.mask
    });
  }).setPropertyViewFn((e) => /* @__PURE__ */ r(x, {
    ...e
  })).build();
}();
const U = C(I, [{
  method: {
    name: "startTour",
    description: "Triggers the tour to start",
    params: []
  },
  execute: (a, e) => {
    a.children.open.getView().onChange(!0);
  }
}]);
export {
  U as TourComp
};
