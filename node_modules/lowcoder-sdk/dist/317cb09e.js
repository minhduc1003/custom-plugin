import { X as b, a5 as m, P as h, bI as S, cZ as C, d4 as y, Z as u, d5 as p, az as v, N as x, U as w, F as a, bU as V, a8 as n, G as l, a9 as o, aa as i, Y as g, ah as s, bJ as $, ab as I, ac as P, ae as D, bL as E, av as M, d6 as F, bS as k } from "./c988e26e.js";
import { formDataChildren as B, FormDataPropertyView as N } from "./85e61f03.js";
import { SelectInputValidationChildren as R, useSelectInputValidate as z, SelectInputValidationSection as O, selectDivRefMethods as U, SelectInputInvalidConfig as j } from "./d3b0afba.js";
import { useContext as d } from "react";
import { fixOldInputCompData as q } from "./70f9cad3.js";
import "react-dom";
const L = (e) => M`
    &.ant-segmented:not(.ant-segmented-disabled) {
      &,
      .ant-segmented-item-selected,
      .ant-segmented-thumb,
      .ant-segmented-item:hover,
      .ant-segmented-item:focus {
        color: ${e.text};
        border-radius: ${e.radius};
      }
      .ant-segmented-item {
        padding: ${e.padding};
      }
      .ant-segmented-item-selected,
      .ant-segmented-thumb {
        background-color: ${e.indicatorBackground};
      }
    }

    &.ant-segmented,
    .ant-segmented-item-selected {
      border-radius: ${e.radius};
    }
    &.ant-segmented, .ant-segmented-item-label {
      font-family:${e.fontFamily};
      font-style:${e.fontStyle};
      font-size:${e.textSize};
      font-weight:${e.textWeight};
      text-transform:${e.textTransform};
      text-decoration:${e.textDecoration};
    }
  `, T = b(F)`
  width: 100%;
  min-height: 24px; // keep the height unchanged when there are no options
  ${(e) => e.$style && L(e.$style)}
`, Z = {
  defaultValue: m("value"),
  value: m("value"),
  label: h,
  disabled: S,
  onEvent: C,
  options: y,
  style: u(p, "style"),
  animationStyle: u(v, "animationStyle"),
  viewRef: x,
  ...R,
  ...B
};
let r = function() {
  return new w(Z, (e) => {
    const [c, f] = z(e);
    return e.label({
      required: e.required,
      style: e.style,
      animationStyle: e.animationStyle,
      children: /* @__PURE__ */ a(T, {
        ref: e.viewRef,
        block: !0,
        disabled: e.disabled,
        value: e.value.value,
        $style: e.style,
        onChange: (t) => {
          f(String(t));
        },
        options: e.options.filter((t) => t.value !== void 0 && !t.hidden).map((t) => ({
          label: t.label,
          value: t.value,
          disabled: t.disabled,
          icon: V(t.prefixIcon) && t.prefixIcon
        }))
      }),
      ...c
    });
  }).setPropertyViewFn((e) => /* @__PURE__ */ n(l, {
    children: [/* @__PURE__ */ n(o, {
      name: i.basic,
      children: [e.options.propertyView({}), e.defaultValue.propertyView({
        label: g("prop.defaultValue")
      })]
    }), ["logic", "both"].includes(d(s).editorModeStatus) && /* @__PURE__ */ n(l, {
      children: [/* @__PURE__ */ a(O, {
        ...e
      }), /* @__PURE__ */ a(N, {
        ...e
      }), /* @__PURE__ */ n(o, {
        name: i.interaction,
        children: [e.onEvent.getPropertyView(), $(e), I(e)]
      })]
    }), ["layout", "both"].includes(d(s).editorModeStatus) && e.label.getPropertyView(), ["layout", "both"].includes(d(s).editorModeStatus) && /* @__PURE__ */ n(l, {
      children: [/* @__PURE__ */ a(o, {
        name: i.style,
        children: e.style.getPropertyView()
      }), /* @__PURE__ */ a(o, {
        name: i.animationStyle,
        hasTooltip: !0,
        children: e.animationStyle.getPropertyView()
      })]
    })]
  })).setExposeMethodConfigs(U).build();
}();
r = k(r, q);
const Y = P(r, [new D("value", g("selectInput.valueDesc")), j, ...E]);
export {
  Y as SegmentedControlComp
};
