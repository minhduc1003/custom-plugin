import Ne from "react";
import { ne as G, nf as Y, ng as Ye, nh as pe, ni as ot, nj as re, nk as ve, nl as zn, nm as R, nn as M, no as On, np as Ut, nq as Pn, nr as $e, ns as z, nt as X, nu as ye, nv as Pe, i6 as Je, nw as Ln, nx as Fn, ny as Nn, nz as Qt, nA as Wt, nB as Ke, nC as Bn, nD as _n, nE as Dn, nF as Rn, nG as jn, nH as Mn, F as st, G as Hn, lA as O, nI as qn } from "./c988e26e.js";
import "react-dom";
const ct = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
function xe(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const l = e.charCodeAt(n);
    let u = "";
    if (l === 37 && G(e.charCodeAt(n + 1)) && G(e.charCodeAt(n + 2)))
      i = 2;
    else if (l < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(l)) || (u = String.fromCharCode(l));
    else if (l > 55295 && l < 57344) {
      const a = e.charCodeAt(n + 1);
      l < 56320 && a > 56319 && a < 57344 ? (u = String.fromCharCode(l, a), i = 1) : u = "ï¿½";
    } else
      u = String.fromCharCode(l);
    u && (t.push(e.slice(r, n), encodeURIComponent(u)), r = n + i + 1, u = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
const Ue = {
  name: "attention",
  tokenize: vn,
  resolveAll: Vn
};
function Vn(e, t) {
  let n = -1, r, i, l, u, a, s, o, c;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          s = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const m = Object.assign({}, e[r][1].end), g = Object.assign({}, e[n][1].start);
          pt(m, -s), pt(g, s), u = {
            type: s > 1 ? "strongSequence" : "emphasisSequence",
            start: m,
            end: Object.assign({}, e[r][1].end)
          }, a = {
            type: s > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: g
          }, l = {
            type: s > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: s > 1 ? "strong" : "emphasis",
            start: Object.assign({}, u.start),
            end: Object.assign({}, a.end)
          }, e[r][1].end = Object.assign({}, u.start), e[n][1].start = Object.assign({}, a.end), o = [], e[r][1].end.offset - e[r][1].start.offset && (o = Y(o, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), o = Y(o, [
            ["enter", i, t],
            ["enter", u, t],
            ["exit", u, t],
            ["enter", l, t]
          ]), o = Y(
            o,
            Ye(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), o = Y(o, [
            ["exit", l, t],
            ["enter", a, t],
            ["exit", a, t],
            ["exit", i, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (c = 2, o = Y(o, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : c = 0, pe(e, r - 1, n - r + 3, o), n = r + o.length - c - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function vn(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = ot(r);
  let l;
  return u;
  function u(s) {
    return l = s, e.enter("attentionSequence"), a(s);
  }
  function a(s) {
    if (s === l)
      return e.consume(s), a;
    const o = e.exit("attentionSequence"), c = ot(s), m = !c || c === 2 && i || n.includes(s), g = !i || i === 2 && c || n.includes(r);
    return o._open = !!(l === 42 ? m : m && (i || !g)), o._close = !!(l === 42 ? g : g && (c || !m)), t(s);
  }
}
function pt(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const $n = {
  name: "autolink",
  tokenize: Un
};
function Un(e, t, n) {
  let r = 0;
  return i;
  function i(h) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), l;
  }
  function l(h) {
    return re(h) ? (e.consume(h), u) : o(h);
  }
  function u(h) {
    return h === 43 || h === 45 || h === 46 || G(h) ? (r = 1, a(h)) : o(h);
  }
  function a(h) {
    return h === 58 ? (e.consume(h), r = 0, s) : (h === 43 || h === 45 || h === 46 || G(h)) && r++ < 32 ? (e.consume(h), a) : (r = 0, o(h));
  }
  function s(h) {
    return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || ve(h) ? n(h) : (e.consume(h), s);
  }
  function o(h) {
    return h === 64 ? (e.consume(h), c) : zn(h) ? (e.consume(h), o) : n(h);
  }
  function c(h) {
    return G(h) ? m(h) : n(h);
  }
  function m(h) {
    return h === 46 ? (e.consume(h), r = 0, c) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(h);
  }
  function g(h) {
    if ((h === 45 || G(h)) && r++ < 63) {
      const b = h === 45 ? g : m;
      return e.consume(h), b;
    }
    return n(h);
  }
}
const Gt = {
  name: "blockQuote",
  tokenize: Qn,
  continuation: {
    tokenize: Wn
  },
  exit: Gn
};
function Qn(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    if (u === 62) {
      const a = r.containerState;
      return a.open || (e.enter("blockQuote", {
        _container: !0
      }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(u), e.exit("blockQuoteMarker"), l;
    }
    return n(u);
  }
  function l(u) {
    return R(u) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(u), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(u));
  }
}
function Wn(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return R(u) ? M(
      e,
      l,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(u) : l(u);
  }
  function l(u) {
    return e.attempt(Gt, t, n)(u);
  }
}
function Gn(e) {
  e.exit("blockQuote");
}
const Xt = {
  name: "characterEscape",
  tokenize: Xn
};
function Xn(e, t, n) {
  return r;
  function r(l) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(l), e.exit("escapeMarker"), i;
  }
  function i(l) {
    return On(l) ? (e.enter("characterEscapeValue"), e.consume(l), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(l);
  }
}
const Yt = {
  name: "characterReference",
  tokenize: Yn
};
function Yn(e, t, n) {
  const r = this;
  let i = 0, l, u;
  return a;
  function a(m) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), s;
  }
  function s(m) {
    return m === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(m), e.exit("characterReferenceMarkerNumeric"), o) : (e.enter("characterReferenceValue"), l = 31, u = G, c(m));
  }
  function o(m) {
    return m === 88 || m === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(m), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), l = 6, u = Pn, c) : (e.enter("characterReferenceValue"), l = 7, u = $e, c(m));
  }
  function c(m) {
    if (m === 59 && i) {
      const g = e.exit("characterReferenceValue");
      return u === G && !Ut(r.sliceSerialize(g)) ? n(m) : (e.enter("characterReferenceMarker"), e.consume(m), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return u(m) && i++ < l ? (e.consume(m), c) : n(m);
  }
}
const ft = {
  tokenize: Kn,
  partial: !0
}, ht = {
  name: "codeFenced",
  tokenize: Jn,
  concrete: !0
};
function Jn(e, t, n) {
  const r = this, i = {
    tokenize: N,
    partial: !0
  };
  let l = 0, u = 0, a;
  return s;
  function s(d) {
    return o(d);
  }
  function o(d) {
    const T = r.events[r.events.length - 1];
    return l = T && T[1].type === "linePrefix" ? T[2].sliceSerialize(T[1], !0).length : 0, a = d, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(d);
  }
  function c(d) {
    return d === a ? (u++, e.consume(d), c) : u < 3 ? n(d) : (e.exit("codeFencedFenceSequence"), R(d) ? M(e, m, "whitespace")(d) : m(d));
  }
  function m(d) {
    return d === null || z(d) ? (e.exit("codeFencedFence"), r.interrupt ? t(d) : e.check(ft, x, F)(d)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), g(d));
  }
  function g(d) {
    return d === null || z(d) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), m(d)) : R(d) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), M(e, h, "whitespace")(d)) : d === 96 && d === a ? n(d) : (e.consume(d), g);
  }
  function h(d) {
    return d === null || z(d) ? m(d) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(d));
  }
  function b(d) {
    return d === null || z(d) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), m(d)) : d === 96 && d === a ? n(d) : (e.consume(d), b);
  }
  function x(d) {
    return e.attempt(i, F, S)(d);
  }
  function S(d) {
    return e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), k;
  }
  function k(d) {
    return l > 0 && R(d) ? M(
      e,
      P,
      "linePrefix",
      l + 1
    )(d) : P(d);
  }
  function P(d) {
    return d === null || z(d) ? e.check(ft, x, F)(d) : (e.enter("codeFlowValue"), E(d));
  }
  function E(d) {
    return d === null || z(d) ? (e.exit("codeFlowValue"), P(d)) : (e.consume(d), E);
  }
  function F(d) {
    return e.exit("codeFenced"), t(d);
  }
  function N(d, T, L) {
    let _ = 0;
    return v;
    function v(B) {
      return d.enter("lineEnding"), d.consume(B), d.exit("lineEnding"), C;
    }
    function C(B) {
      return d.enter("codeFencedFence"), R(B) ? M(
        d,
        I,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(B) : I(B);
    }
    function I(B) {
      return B === a ? (d.enter("codeFencedFenceSequence"), H(B)) : L(B);
    }
    function H(B) {
      return B === a ? (_++, d.consume(B), H) : _ >= u ? (d.exit("codeFencedFenceSequence"), R(B) ? M(d, q, "whitespace")(B) : q(B)) : L(B);
    }
    function q(B) {
      return B === null || z(B) ? (d.exit("codeFencedFence"), T(B)) : L(B);
    }
  }
}
function Kn(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return u === null ? n(u) : (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), l);
  }
  function l(u) {
    return r.parser.lazy[r.now().line] ? n(u) : t(u);
  }
}
const Be = {
  name: "codeIndented",
  tokenize: er
}, Zn = {
  tokenize: tr,
  partial: !0
};
function er(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("codeIndented"), M(e, l, "linePrefix", 4 + 1)(o);
  }
  function l(o) {
    const c = r.events[r.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? u(o) : n(o);
  }
  function u(o) {
    return o === null ? s(o) : z(o) ? e.attempt(Zn, u, s)(o) : (e.enter("codeFlowValue"), a(o));
  }
  function a(o) {
    return o === null || z(o) ? (e.exit("codeFlowValue"), u(o)) : (e.consume(o), a);
  }
  function s(o) {
    return e.exit("codeIndented"), t(o);
  }
}
function tr(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return r.parser.lazy[r.now().line] ? n(u) : z(u) ? (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), i) : M(e, l, "linePrefix", 4 + 1)(u);
  }
  function l(u) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(u) : z(u) ? i(u) : n(u);
  }
}
const nr = {
  name: "codeText",
  tokenize: lr,
  resolve: rr,
  previous: ir
};
function rr(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function ir(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function lr(e, t, n) {
  let r = 0, i, l;
  return u;
  function u(m) {
    return e.enter("codeText"), e.enter("codeTextSequence"), a(m);
  }
  function a(m) {
    return m === 96 ? (e.consume(m), r++, a) : (e.exit("codeTextSequence"), s(m));
  }
  function s(m) {
    return m === null ? n(m) : m === 32 ? (e.enter("space"), e.consume(m), e.exit("space"), s) : m === 96 ? (l = e.enter("codeTextSequence"), i = 0, c(m)) : z(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), s) : (e.enter("codeTextData"), o(m));
  }
  function o(m) {
    return m === null || m === 32 || m === 96 || z(m) ? (e.exit("codeTextData"), s(m)) : (e.consume(m), o);
  }
  function c(m) {
    return m === 96 ? (e.consume(m), i++, c) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(m)) : (l.type = "codeTextData", o(m));
  }
}
function Jt(e) {
  const t = {};
  let n = -1, r, i, l, u, a, s, o;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (s = r[1]._tokenizer.events, l = 0, l < s.length && s[l][1].type === "lineEndingBlank" && (l += 2), l < s.length && s[l][1].type === "content"))
      for (; ++l < s.length && s[l][1].type !== "content"; )
        s[l][1].type === "chunkText" && (s[l][1]._isInFirstContentOfListItem = !0, l++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, ur(e, n)), n = t[n], o = !0);
    else if (r[1]._container) {
      for (l = n, i = void 0; l-- && (u = e[l], u[1].type === "lineEnding" || u[1].type === "lineEndingBlank"); )
        u[0] === "enter" && (i && (e[i][1].type = "lineEndingBlank"), u[1].type = "lineEnding", i = l);
      i && (r[1].end = Object.assign({}, e[i][1].start), a = e.slice(i, n), a.unshift(r), pe(e, i, n - i + 1, a));
    }
  }
  return !o;
}
function ur(e, t) {
  const n = e[t][1], r = e[t][2];
  let i = t - 1;
  const l = [], u = n._tokenizer || r.parser[n.contentType](n.start), a = u.events, s = [], o = {};
  let c, m, g = -1, h = n, b = 0, x = 0;
  const S = [x];
  for (; h; ) {
    for (; e[++i][1] !== h; )
      ;
    l.push(i), h._tokenizer || (c = r.sliceStream(h), h.next || c.push(null), m && u.defineSkip(h.start), h._isInFirstContentOfListItem && (u._gfmTasklistFirstContentOfListItem = !0), u.write(c), h._isInFirstContentOfListItem && (u._gfmTasklistFirstContentOfListItem = void 0)), m = h, h = h.next;
  }
  for (h = n; ++g < a.length; )
    // Find a void token that includes a break.
    a[g][0] === "exit" && a[g - 1][0] === "enter" && a[g][1].type === a[g - 1][1].type && a[g][1].start.line !== a[g][1].end.line && (x = g + 1, S.push(x), h._tokenizer = void 0, h.previous = void 0, h = h.next);
  for (u.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : S.pop(), g = S.length; g--; ) {
    const k = a.slice(S[g], S[g + 1]), P = l.pop();
    s.unshift([P, P + k.length - 1]), pe(e, P, 2, k);
  }
  for (g = -1; ++g < s.length; )
    o[b + s[g][0]] = b + s[g][1], b += s[g][1] - s[g][0] - 1;
  return o;
}
const ar = {
  tokenize: cr,
  resolve: sr
}, or = {
  tokenize: pr,
  partial: !0
};
function sr(e) {
  return Jt(e), e;
}
function cr(e, t) {
  let n;
  return r;
  function r(a) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? l(a) : z(a) ? e.check(
      or,
      u,
      l
    )(a) : (e.consume(a), i);
  }
  function l(a) {
    return e.exit("chunkContent"), e.exit("content"), t(a);
  }
  function u(a) {
    return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function pr(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), M(e, l, "linePrefix");
  }
  function l(u) {
    if (u === null || z(u))
      return n(u);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(u) : e.interrupt(r.parser.constructs.flow, n, t)(u);
  }
}
function Kt(e, t, n, r, i, l, u, a, s) {
  const o = s || Number.POSITIVE_INFINITY;
  let c = 0;
  return m;
  function m(k) {
    return k === 60 ? (e.enter(r), e.enter(i), e.enter(l), e.consume(k), e.exit(l), g) : k === null || k === 32 || k === 41 || ve(k) ? n(k) : (e.enter(r), e.enter(u), e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), x(k));
  }
  function g(k) {
    return k === 62 ? (e.enter(l), e.consume(k), e.exit(l), e.exit(i), e.exit(r), t) : (e.enter(a), e.enter("chunkString", {
      contentType: "string"
    }), h(k));
  }
  function h(k) {
    return k === 62 ? (e.exit("chunkString"), e.exit(a), g(k)) : k === null || k === 60 || z(k) ? n(k) : (e.consume(k), k === 92 ? b : h);
  }
  function b(k) {
    return k === 60 || k === 62 || k === 92 ? (e.consume(k), h) : h(k);
  }
  function x(k) {
    return !c && (k === null || k === 41 || X(k)) ? (e.exit("chunkString"), e.exit(a), e.exit(u), e.exit(r), t(k)) : c < o && k === 40 ? (e.consume(k), c++, x) : k === 41 ? (e.consume(k), c--, x) : k === null || k === 32 || k === 40 || ve(k) ? n(k) : (e.consume(k), k === 92 ? S : x);
  }
  function S(k) {
    return k === 40 || k === 41 || k === 92 ? (e.consume(k), x) : x(k);
  }
}
function Zt(e, t, n, r, i, l) {
  const u = this;
  let a = 0, s;
  return o;
  function o(h) {
    return e.enter(r), e.enter(i), e.consume(h), e.exit(i), e.enter(l), c;
  }
  function c(h) {
    return a > 999 || h === null || h === 91 || h === 93 && !s || // To do: remove in the future once weâve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnât need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    h === 94 && !a && "_hiddenFootnoteSupport" in u.parser.constructs ? n(h) : h === 93 ? (e.exit(l), e.enter(i), e.consume(h), e.exit(i), e.exit(r), t) : z(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), m(h));
  }
  function m(h) {
    return h === null || h === 91 || h === 93 || z(h) || a++ > 999 ? (e.exit("chunkString"), c(h)) : (e.consume(h), s || (s = !R(h)), h === 92 ? g : m);
  }
  function g(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), a++, m) : m(h);
  }
}
function en(e, t, n, r, i, l) {
  let u;
  return a;
  function a(g) {
    return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(i), e.consume(g), e.exit(i), u = g === 40 ? 41 : g, s) : n(g);
  }
  function s(g) {
    return g === u ? (e.enter(i), e.consume(g), e.exit(i), e.exit(r), t) : (e.enter(l), o(g));
  }
  function o(g) {
    return g === u ? (e.exit(l), s(u)) : g === null ? n(g) : z(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), M(e, o, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(g));
  }
  function c(g) {
    return g === u || g === null || z(g) ? (e.exit("chunkString"), o(g)) : (e.consume(g), g === 92 ? m : c);
  }
  function m(g) {
    return g === u || g === 92 ? (e.consume(g), c) : c(g);
  }
}
function Se(e, t) {
  let n;
  return r;
  function r(i) {
    return z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : R(i) ? M(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const fr = {
  name: "definition",
  tokenize: mr
}, hr = {
  tokenize: gr,
  partial: !0
};
function mr(e, t, n) {
  const r = this;
  let i;
  return l;
  function l(h) {
    return e.enter("definition"), u(h);
  }
  function u(h) {
    return Zt.call(
      r,
      e,
      a,
      // Note: we donât need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(h);
  }
  function a(h) {
    return i = ye(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), s) : n(h);
  }
  function s(h) {
    return X(h) ? Se(e, o)(h) : o(h);
  }
  function o(h) {
    return Kt(
      e,
      c,
      // Note: we donât need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(h);
  }
  function c(h) {
    return e.attempt(hr, m, m)(h);
  }
  function m(h) {
    return R(h) ? M(e, g, "whitespace")(h) : g(h);
  }
  function g(h) {
    return h === null || z(h) ? (e.exit("definition"), r.parser.defined.push(i), t(h)) : n(h);
  }
}
function gr(e, t, n) {
  return r;
  function r(a) {
    return X(a) ? Se(e, i)(a) : n(a);
  }
  function i(a) {
    return en(
      e,
      l,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(a);
  }
  function l(a) {
    return R(a) ? M(e, u, "whitespace")(a) : u(a);
  }
  function u(a) {
    return a === null || z(a) ? t(a) : n(a);
  }
}
const dr = {
  name: "hardBreakEscape",
  tokenize: yr
};
function yr(e, t, n) {
  return r;
  function r(l) {
    return e.enter("hardBreakEscape"), e.consume(l), i;
  }
  function i(l) {
    return z(l) ? (e.exit("hardBreakEscape"), t(l)) : n(l);
  }
}
const xr = {
  name: "headingAtx",
  tokenize: wr,
  resolve: kr
};
function kr(e, t) {
  let n = e.length - 2, r = 3, i, l;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, l = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, pe(e, r, n - r + 1, [
    ["enter", i, t],
    ["enter", l, t],
    ["exit", l, t],
    ["exit", i, t]
  ])), e;
}
function wr(e, t, n) {
  let r = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), l(c);
  }
  function l(c) {
    return e.enter("atxHeadingSequence"), u(c);
  }
  function u(c) {
    return c === 35 && r++ < 6 ? (e.consume(c), u) : c === null || X(c) ? (e.exit("atxHeadingSequence"), a(c)) : n(c);
  }
  function a(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), s(c)) : c === null || z(c) ? (e.exit("atxHeading"), t(c)) : R(c) ? M(e, a, "whitespace")(c) : (e.enter("atxHeadingText"), o(c));
  }
  function s(c) {
    return c === 35 ? (e.consume(c), s) : (e.exit("atxHeadingSequence"), a(c));
  }
  function o(c) {
    return c === null || c === 35 || X(c) ? (e.exit("atxHeadingText"), a(c)) : (e.consume(c), o);
  }
}
const br = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], mt = ["pre", "script", "style", "textarea"], Sr = {
  name: "htmlFlow",
  tokenize: Tr,
  resolveTo: Ir,
  concrete: !0
}, Er = {
  tokenize: zr,
  partial: !0
}, Cr = {
  tokenize: Ar,
  partial: !0
};
function Ir(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Tr(e, t, n) {
  const r = this;
  let i, l, u, a, s;
  return o;
  function o(f) {
    return c(f);
  }
  function c(f) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(f), m;
  }
  function m(f) {
    return f === 33 ? (e.consume(f), g) : f === 47 ? (e.consume(f), l = !0, x) : f === 63 ? (e.consume(f), i = 3, r.interrupt ? t : p) : re(f) ? (e.consume(f), u = String.fromCharCode(f), S) : n(f);
  }
  function g(f) {
    return f === 45 ? (e.consume(f), i = 2, h) : f === 91 ? (e.consume(f), i = 5, a = 0, b) : re(f) ? (e.consume(f), i = 4, r.interrupt ? t : p) : n(f);
  }
  function h(f) {
    return f === 45 ? (e.consume(f), r.interrupt ? t : p) : n(f);
  }
  function b(f) {
    const ee = "CDATA[";
    return f === ee.charCodeAt(a++) ? (e.consume(f), a === ee.length ? r.interrupt ? t : I : b) : n(f);
  }
  function x(f) {
    return re(f) ? (e.consume(f), u = String.fromCharCode(f), S) : n(f);
  }
  function S(f) {
    if (f === null || f === 47 || f === 62 || X(f)) {
      const ee = f === 47, he = u.toLowerCase();
      return !ee && !l && mt.includes(he) ? (i = 1, r.interrupt ? t(f) : I(f)) : br.includes(u.toLowerCase()) ? (i = 6, ee ? (e.consume(f), k) : r.interrupt ? t(f) : I(f)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(f) : l ? P(f) : E(f));
    }
    return f === 45 || G(f) ? (e.consume(f), u += String.fromCharCode(f), S) : n(f);
  }
  function k(f) {
    return f === 62 ? (e.consume(f), r.interrupt ? t : I) : n(f);
  }
  function P(f) {
    return R(f) ? (e.consume(f), P) : v(f);
  }
  function E(f) {
    return f === 47 ? (e.consume(f), v) : f === 58 || f === 95 || re(f) ? (e.consume(f), F) : R(f) ? (e.consume(f), E) : v(f);
  }
  function F(f) {
    return f === 45 || f === 46 || f === 58 || f === 95 || G(f) ? (e.consume(f), F) : N(f);
  }
  function N(f) {
    return f === 61 ? (e.consume(f), d) : R(f) ? (e.consume(f), N) : E(f);
  }
  function d(f) {
    return f === null || f === 60 || f === 61 || f === 62 || f === 96 ? n(f) : f === 34 || f === 39 ? (e.consume(f), s = f, T) : R(f) ? (e.consume(f), d) : L(f);
  }
  function T(f) {
    return f === s ? (e.consume(f), s = null, _) : f === null || z(f) ? n(f) : (e.consume(f), T);
  }
  function L(f) {
    return f === null || f === 34 || f === 39 || f === 47 || f === 60 || f === 61 || f === 62 || f === 96 || X(f) ? N(f) : (e.consume(f), L);
  }
  function _(f) {
    return f === 47 || f === 62 || R(f) ? E(f) : n(f);
  }
  function v(f) {
    return f === 62 ? (e.consume(f), C) : n(f);
  }
  function C(f) {
    return f === null || z(f) ? I(f) : R(f) ? (e.consume(f), C) : n(f);
  }
  function I(f) {
    return f === 45 && i === 2 ? (e.consume(f), Q) : f === 60 && i === 1 ? (e.consume(f), $) : f === 62 && i === 4 ? (e.consume(f), Z) : f === 63 && i === 3 ? (e.consume(f), p) : f === 93 && i === 5 ? (e.consume(f), ie) : z(f) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(
      Er,
      le,
      H
    )(f)) : f === null || z(f) ? (e.exit("htmlFlowData"), H(f)) : (e.consume(f), I);
  }
  function H(f) {
    return e.check(
      Cr,
      q,
      le
    )(f);
  }
  function q(f) {
    return e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), B;
  }
  function B(f) {
    return f === null || z(f) ? H(f) : (e.enter("htmlFlowData"), I(f));
  }
  function Q(f) {
    return f === 45 ? (e.consume(f), p) : I(f);
  }
  function $(f) {
    return f === 47 ? (e.consume(f), u = "", K) : I(f);
  }
  function K(f) {
    if (f === 62) {
      const ee = u.toLowerCase();
      return mt.includes(ee) ? (e.consume(f), Z) : I(f);
    }
    return re(f) && u.length < 8 ? (e.consume(f), u += String.fromCharCode(f), K) : I(f);
  }
  function ie(f) {
    return f === 93 ? (e.consume(f), p) : I(f);
  }
  function p(f) {
    return f === 62 ? (e.consume(f), Z) : f === 45 && i === 2 ? (e.consume(f), p) : I(f);
  }
  function Z(f) {
    return f === null || z(f) ? (e.exit("htmlFlowData"), le(f)) : (e.consume(f), Z);
  }
  function le(f) {
    return e.exit("htmlFlow"), t(f);
  }
}
function Ar(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return z(u) ? (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), l) : n(u);
  }
  function l(u) {
    return r.parser.lazy[r.now().line] ? n(u) : t(u);
  }
}
function zr(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(Pe, t, n);
  }
}
const Or = {
  name: "htmlText",
  tokenize: Pr
};
function Pr(e, t, n) {
  const r = this;
  let i, l, u;
  return a;
  function a(p) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(p), s;
  }
  function s(p) {
    return p === 33 ? (e.consume(p), o) : p === 47 ? (e.consume(p), N) : p === 63 ? (e.consume(p), E) : re(p) ? (e.consume(p), L) : n(p);
  }
  function o(p) {
    return p === 45 ? (e.consume(p), c) : p === 91 ? (e.consume(p), l = 0, b) : re(p) ? (e.consume(p), P) : n(p);
  }
  function c(p) {
    return p === 45 ? (e.consume(p), h) : n(p);
  }
  function m(p) {
    return p === null ? n(p) : p === 45 ? (e.consume(p), g) : z(p) ? (u = m, $(p)) : (e.consume(p), m);
  }
  function g(p) {
    return p === 45 ? (e.consume(p), h) : m(p);
  }
  function h(p) {
    return p === 62 ? Q(p) : p === 45 ? g(p) : m(p);
  }
  function b(p) {
    const Z = "CDATA[";
    return p === Z.charCodeAt(l++) ? (e.consume(p), l === Z.length ? x : b) : n(p);
  }
  function x(p) {
    return p === null ? n(p) : p === 93 ? (e.consume(p), S) : z(p) ? (u = x, $(p)) : (e.consume(p), x);
  }
  function S(p) {
    return p === 93 ? (e.consume(p), k) : x(p);
  }
  function k(p) {
    return p === 62 ? Q(p) : p === 93 ? (e.consume(p), k) : x(p);
  }
  function P(p) {
    return p === null || p === 62 ? Q(p) : z(p) ? (u = P, $(p)) : (e.consume(p), P);
  }
  function E(p) {
    return p === null ? n(p) : p === 63 ? (e.consume(p), F) : z(p) ? (u = E, $(p)) : (e.consume(p), E);
  }
  function F(p) {
    return p === 62 ? Q(p) : E(p);
  }
  function N(p) {
    return re(p) ? (e.consume(p), d) : n(p);
  }
  function d(p) {
    return p === 45 || G(p) ? (e.consume(p), d) : T(p);
  }
  function T(p) {
    return z(p) ? (u = T, $(p)) : R(p) ? (e.consume(p), T) : Q(p);
  }
  function L(p) {
    return p === 45 || G(p) ? (e.consume(p), L) : p === 47 || p === 62 || X(p) ? _(p) : n(p);
  }
  function _(p) {
    return p === 47 ? (e.consume(p), Q) : p === 58 || p === 95 || re(p) ? (e.consume(p), v) : z(p) ? (u = _, $(p)) : R(p) ? (e.consume(p), _) : Q(p);
  }
  function v(p) {
    return p === 45 || p === 46 || p === 58 || p === 95 || G(p) ? (e.consume(p), v) : C(p);
  }
  function C(p) {
    return p === 61 ? (e.consume(p), I) : z(p) ? (u = C, $(p)) : R(p) ? (e.consume(p), C) : _(p);
  }
  function I(p) {
    return p === null || p === 60 || p === 61 || p === 62 || p === 96 ? n(p) : p === 34 || p === 39 ? (e.consume(p), i = p, H) : z(p) ? (u = I, $(p)) : R(p) ? (e.consume(p), I) : (e.consume(p), q);
  }
  function H(p) {
    return p === i ? (e.consume(p), i = void 0, B) : p === null ? n(p) : z(p) ? (u = H, $(p)) : (e.consume(p), H);
  }
  function q(p) {
    return p === null || p === 34 || p === 39 || p === 60 || p === 61 || p === 96 ? n(p) : p === 47 || p === 62 || X(p) ? _(p) : (e.consume(p), q);
  }
  function B(p) {
    return p === 47 || p === 62 || X(p) ? _(p) : n(p);
  }
  function Q(p) {
    return p === 62 ? (e.consume(p), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(p);
  }
  function $(p) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), K;
  }
  function K(p) {
    return R(p) ? M(
      e,
      ie,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(p) : ie(p);
  }
  function ie(p) {
    return e.enter("htmlTextData"), u(p);
  }
}
const Ze = {
  name: "labelEnd",
  tokenize: Dr,
  resolveTo: _r,
  resolveAll: Br
}, Lr = {
  tokenize: Rr
}, Fr = {
  tokenize: jr
}, Nr = {
  tokenize: Mr
};
function Br(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function _r(e, t) {
  let n = e.length, r = 0, i, l, u, a;
  for (; n--; )
    if (i = e[n][1], l) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (u) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (l = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (u = n);
  const s = {
    type: e[l][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[l][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "label",
    start: Object.assign({}, e[l][1].start),
    end: Object.assign({}, e[u][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, e[l + r + 2][1].end),
    end: Object.assign({}, e[u - 2][1].start)
  };
  return a = [
    ["enter", s, t],
    ["enter", o, t]
  ], a = Y(a, e.slice(l + 1, l + r + 3)), a = Y(a, [["enter", c, t]]), a = Y(
    a,
    Ye(
      t.parser.constructs.insideSpan.null,
      e.slice(l + r + 4, u - 3),
      t
    )
  ), a = Y(a, [
    ["exit", c, t],
    e[u - 2],
    e[u - 1],
    ["exit", o, t]
  ]), a = Y(a, e.slice(u + 1)), a = Y(a, [["exit", s, t]]), pe(e, l, e.length, a), e;
}
function Dr(e, t, n) {
  const r = this;
  let i = r.events.length, l, u;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      l = r.events[i][1];
      break;
    }
  return a;
  function a(g) {
    return l ? l._inactive ? m(g) : (u = r.parser.defined.includes(
      ye(
        r.sliceSerialize({
          start: l.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), s) : n(g);
  }
  function s(g) {
    return g === 40 ? e.attempt(
      Lr,
      c,
      u ? c : m
    )(g) : g === 91 ? e.attempt(
      Fr,
      c,
      u ? o : m
    )(g) : u ? c(g) : m(g);
  }
  function o(g) {
    return e.attempt(
      Nr,
      c,
      m
    )(g);
  }
  function c(g) {
    return t(g);
  }
  function m(g) {
    return l._balanced = !0, n(g);
  }
}
function Rr(e, t, n) {
  return r;
  function r(m) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), i;
  }
  function i(m) {
    return X(m) ? Se(e, l)(m) : l(m);
  }
  function l(m) {
    return m === 41 ? c(m) : Kt(
      e,
      u,
      a,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(m);
  }
  function u(m) {
    return X(m) ? Se(e, s)(m) : c(m);
  }
  function a(m) {
    return n(m);
  }
  function s(m) {
    return m === 34 || m === 39 || m === 40 ? en(
      e,
      o,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(m) : c(m);
  }
  function o(m) {
    return X(m) ? Se(e, c)(m) : c(m);
  }
  function c(m) {
    return m === 41 ? (e.enter("resourceMarker"), e.consume(m), e.exit("resourceMarker"), e.exit("resource"), t) : n(m);
  }
}
function jr(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return Zt.call(
      r,
      e,
      l,
      u,
      "reference",
      "referenceMarker",
      "referenceString"
    )(a);
  }
  function l(a) {
    return r.parser.defined.includes(
      ye(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(a) : n(a);
  }
  function u(a) {
    return n(a);
  }
}
function Mr(e, t, n) {
  return r;
  function r(l) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(l), e.exit("referenceMarker"), i;
  }
  function i(l) {
    return l === 93 ? (e.enter("referenceMarker"), e.consume(l), e.exit("referenceMarker"), e.exit("reference"), t) : n(l);
  }
}
const Hr = {
  name: "labelStartImage",
  tokenize: qr,
  resolveAll: Ze.resolveAll
};
function qr(e, t, n) {
  const r = this;
  return i;
  function i(a) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), l;
  }
  function l(a) {
    return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), u) : n(a);
  }
  function u(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
  }
}
const Vr = {
  name: "labelStartLink",
  tokenize: vr,
  resolveAll: Ze.resolveAll
};
function vr(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelLink"), l;
  }
  function l(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u);
  }
}
const _e = {
  name: "lineEnding",
  tokenize: $r
};
function $r(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), M(e, t, "linePrefix");
  }
}
const Ae = {
  name: "thematicBreak",
  tokenize: Ur
};
function Ur(e, t, n) {
  let r = 0, i;
  return l;
  function l(o) {
    return e.enter("thematicBreak"), u(o);
  }
  function u(o) {
    return i = o, a(o);
  }
  function a(o) {
    return o === i ? (e.enter("thematicBreakSequence"), s(o)) : r >= 3 && (o === null || z(o)) ? (e.exit("thematicBreak"), t(o)) : n(o);
  }
  function s(o) {
    return o === i ? (e.consume(o), r++, s) : (e.exit("thematicBreakSequence"), R(o) ? M(e, a, "whitespace")(o) : a(o));
  }
}
const W = {
  name: "list",
  tokenize: Gr,
  continuation: {
    tokenize: Xr
  },
  exit: Jr
}, Qr = {
  tokenize: Kr,
  partial: !0
}, Wr = {
  tokenize: Yr,
  partial: !0
};
function Gr(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let l = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, u = 0;
  return a;
  function a(h) {
    const b = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : $e(h)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(Ae, n, o)(h) : o(h);
      if (!r.interrupt || h === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), s(h);
    }
    return n(h);
  }
  function s(h) {
    return $e(h) && ++u < 10 ? (e.consume(h), s) : (!r.interrupt || u < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), o(h)) : n(h);
  }
  function o(h) {
    return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(
      Pe,
      // Canât be empty when interrupting.
      r.interrupt ? n : c,
      e.attempt(
        Qr,
        g,
        m
      )
    );
  }
  function c(h) {
    return r.containerState.initialBlankLine = !0, l++, g(h);
  }
  function m(h) {
    return R(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), g) : n(h);
  }
  function g(h) {
    return r.containerState.size = l + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h);
  }
}
function Xr(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Pe, i, l);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, M(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(a);
  }
  function l(a) {
    return r.containerState.furtherBlankLines || !R(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, u(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Wr, t, u)(a));
  }
  function u(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, M(
      e,
      e.attempt(W, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(a);
  }
}
function Yr(e, t, n) {
  const r = this;
  return M(
    e,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(l) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "listItemIndent" && u[2].sliceSerialize(u[1], !0).length === r.containerState.size ? t(l) : n(l);
  }
}
function Jr(e) {
  e.exit(this.containerState.type);
}
function Kr(e, t, n) {
  const r = this;
  return M(
    e,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function i(l) {
    const u = r.events[r.events.length - 1];
    return !R(l) && u && u[1].type === "listItemPrefixWhitespace" ? t(l) : n(l);
  }
}
const gt = {
  name: "setextUnderline",
  tokenize: ei,
  resolveTo: Zr
};
function Zr(e, t) {
  let n = e.length, r, i, l;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !l && e[n][1].type === "definition" && (l = n);
  const u = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", l ? (e.splice(i, 0, ["enter", u, t]), e.splice(l + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[l][1].end)) : e[r][1] = u, e.push(["exit", u, t]), e;
}
function ei(e, t, n) {
  const r = this;
  let i;
  return l;
  function l(o) {
    let c = r.events.length, m;
    for (; c--; )
      if (r.events[c][1].type !== "lineEnding" && r.events[c][1].type !== "linePrefix" && r.events[c][1].type !== "content") {
        m = r.events[c][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || m) ? (e.enter("setextHeadingLine"), i = o, u(o)) : n(o);
  }
  function u(o) {
    return e.enter("setextHeadingLineSequence"), a(o);
  }
  function a(o) {
    return o === i ? (e.consume(o), a) : (e.exit("setextHeadingLineSequence"), R(o) ? M(e, s, "lineSuffix")(o) : s(o));
  }
  function s(o) {
    return o === null || z(o) ? (e.exit("setextHeadingLine"), t(o)) : n(o);
  }
}
const dt = ["http", "https", "mailto", "tel"];
function ti(e) {
  const t = (e || "").trim(), n = t.charAt(0);
  if (n === "#" || n === "/")
    return t;
  const r = t.indexOf(":");
  if (r === -1)
    return t;
  let i = -1;
  for (; ++i < dt.length; ) {
    const l = dt[i];
    if (r === l.length && t.slice(0, l.length).toLowerCase() === l)
      return t;
  }
  return i = t.indexOf("?"), i !== -1 && r > i || (i = t.indexOf("#"), i !== -1 && r > i) ? t : "javascript:void(0)";
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var ni = function(t) {
  return t != null && t.constructor != null && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
};
const tn = /* @__PURE__ */ Je(ni);
function Ee(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? yt(e.position) : "start" in e || "end" in e ? yt(e) : "line" in e || "column" in e ? Qe(e) : "";
}
function Qe(e) {
  return xt(e && e.line) + ":" + xt(e && e.column);
}
function yt(e) {
  return Qe(e && e.start) + "-" + Qe(e && e.end);
}
function xt(e) {
  return e && typeof e == "number" ? e : 1;
}
class J extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > ð **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(t, n, r) {
    const i = [null, null];
    let l = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    if (super(), typeof n == "string" && (r = n, n = void 0), typeof r == "string") {
      const u = r.indexOf(":");
      u === -1 ? i[1] = r : (i[0] = r.slice(0, u), i[1] = r.slice(u + 1));
    }
    n && ("type" in n || "position" in n ? n.position && (l = n.position) : "start" in n || "end" in n ? l = n : ("line" in n || "column" in n) && (l.start = n)), this.name = Ee(n) || "1:1", this.message = typeof t == "object" ? t.message : t, this.stack = "", typeof t == "object" && t.stack && (this.stack = t.stack), this.reason = this.message, this.fatal, this.line = l.start.line, this.column = l.start.column, this.position = l, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;
  }
}
J.prototype.file = "";
J.prototype.name = "";
J.prototype.reason = "";
J.prototype.message = "";
J.prototype.stack = "";
J.prototype.fatal = null;
J.prototype.column = null;
J.prototype.line = null;
J.prototype.source = null;
J.prototype.ruleId = null;
J.prototype.position = null;
const ne = { basename: ri, dirname: ii, extname: li, join: ui, sep: "/" };
function ri(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Ce(e);
  let n = 0, r = -1, i = e.length, l;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.charCodeAt(i) === 47) {
        if (l) {
          n = i + 1;
          break;
        }
      } else
        r < 0 && (l = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let u = -1, a = t.length - 1;
  for (; i--; )
    if (e.charCodeAt(i) === 47) {
      if (l) {
        n = i + 1;
        break;
      }
    } else
      u < 0 && (l = !0, u = i + 1), a > -1 && (e.charCodeAt(i) === t.charCodeAt(a--) ? a < 0 && (r = i) : (a = -1, r = u));
  return n === r ? r = u : r < 0 && (r = e.length), e.slice(n, r);
}
function ii(e) {
  if (Ce(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.charCodeAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else
      r || (r = !0);
  return t < 0 ? e.charCodeAt(0) === 47 ? "/" : "." : t === 1 && e.charCodeAt(0) === 47 ? "//" : e.slice(0, t);
}
function li(e) {
  Ce(e);
  let t = e.length, n = -1, r = 0, i = -1, l = 0, u;
  for (; t--; ) {
    const a = e.charCodeAt(t);
    if (a === 47) {
      if (u) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (u = !0, n = t + 1), a === 46 ? i < 0 ? i = t : l !== 1 && (l = 1) : i > -1 && (l = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  l === 0 || // The (right-most) trimmed path component is exactly `..`.
  l === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function ui(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Ce(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : ai(n);
}
function ai(e) {
  Ce(e);
  const t = e.charCodeAt(0) === 47;
  let n = oi(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.charCodeAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function oi(e, t) {
  let n = "", r = 0, i = -1, l = 0, u = -1, a, s;
  for (; ++u <= e.length; ) {
    if (u < e.length)
      a = e.charCodeAt(u);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === u - 1 || l === 1))
        if (i !== u - 1 && l === 2) {
          if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (s = n.lastIndexOf("/"), s !== n.length - 1) {
                s < 0 ? (n = "", r = 0) : (n = n.slice(0, s), r = n.length - 1 - n.lastIndexOf("/")), i = u, l = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, i = u, l = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(i + 1, u) : n = e.slice(i + 1, u), r = u - i - 1;
      i = u, l = 0;
    } else
      a === 46 && l > -1 ? l++ : l = -1;
  }
  return n;
}
function Ce(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const si = { cwd: ci };
function ci() {
  return "/";
}
function We(e) {
  return e !== null && typeof e == "object" && // @ts-expect-error: indexable.
  e.href && // @ts-expect-error: indexable.
  e.origin;
}
function pi(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!We(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return fi(e);
}
function fi(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.charCodeAt(n) === 37 && t.charCodeAt(n + 1) === 50) {
      const r = t.charCodeAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const De = ["history", "path", "basename", "stem", "extname", "dirname"];
class nn {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` â `{value: options}`
   * *   `URL` â `{path: options}`
   * *   `VFile` â shallow copies its data over to the new file
   * *   `object` â all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? typeof t == "string" || hi(t) ? n = { value: t } : We(t) ? n = { path: t } : n = t : n = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = si.cwd(), this.value, this.stored, this.result, this.map;
    let r = -1;
    for (; ++r < De.length; ) {
      const l = De[r];
      l in n && n[l] !== void 0 && n[l] !== null && (this[l] = l === "history" ? [...n[l]] : n[l]);
    }
    let i;
    for (i in n)
      De.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(t) {
    We(t) && (t = pi(t)), je(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path == "string" ? ne.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâs no `path` yet.
   */
  set dirname(t) {
    kt(this.basename, "dirname"), this.path = ne.join(t || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path == "string" ? ne.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(t) {
    je(t, "basename"), Re(t, "basename"), this.path = ne.join(this.dirname || "", t);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path == "string" ? ne.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâs no `path` yet.
   */
  set extname(t) {
    if (Re(t, "extname"), kt(this.dirname, "extname"), t) {
      if (t.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = ne.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path == "string" ? ne.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(t) {
    je(t, "stem"), Re(t, "stem"), this.path = ne.join(this.dirname || "", t + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâs a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return (this.value || "").toString(t || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new J(t, n, r);
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = null, i;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > ð **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
}
function Re(e, t) {
  if (e && e.includes(ne.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + ne.sep + "`"
    );
}
function je(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function kt(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function hi(e) {
  return tn(e);
}
function wt(e) {
  if (e)
    throw e;
}
var ze = Object.prototype.hasOwnProperty, rn = Object.prototype.toString, bt = Object.defineProperty, St = Object.getOwnPropertyDescriptor, Et = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : rn.call(t) === "[object Array]";
}, Ct = function(t) {
  if (!t || rn.call(t) !== "[object Object]")
    return !1;
  var n = ze.call(t, "constructor"), r = t.constructor && t.constructor.prototype && ze.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || ze.call(t, i);
}, It = function(t, n) {
  bt && n.name === "__proto__" ? bt(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, Tt = function(t, n) {
  if (n === "__proto__")
    if (ze.call(t, n)) {
      if (St)
        return St(t, n).value;
    } else
      return;
  return t[n];
}, mi = function e() {
  var t, n, r, i, l, u, a = arguments[0], s = 1, o = arguments.length, c = !1;
  for (typeof a == "boolean" && (c = a, a = arguments[1] || {}, s = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); s < o; ++s)
    if (t = arguments[s], t != null)
      for (n in t)
        r = Tt(a, n), i = Tt(t, n), a !== i && (c && i && (Ct(i) || (l = Et(i))) ? (l ? (l = !1, u = r && Et(r) ? r : []) : u = r && Ct(r) ? r : {}, It(a, { name: n, newValue: e(c, u, i) })) : typeof i < "u" && It(a, { name: n, newValue: i }));
  return a;
};
const At = /* @__PURE__ */ Je(mi);
function Ge(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function gi() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let l = -1;
    const u = i.pop();
    if (typeof u != "function")
      throw new TypeError("Expected function as last argument, not " + u);
    a(null, ...i);
    function a(s, ...o) {
      const c = e[++l];
      let m = -1;
      if (s) {
        u(s);
        return;
      }
      for (; ++m < i.length; )
        (o[m] === null || o[m] === void 0) && (o[m] = i[m]);
      i = o, c ? di(c, a)(...o) : u(null, ...o);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function di(e, t) {
  let n;
  return r;
  function r(...u) {
    const a = e.length > u.length;
    let s;
    a && u.push(i);
    try {
      s = e.apply(this, u);
    } catch (o) {
      const c = (
        /** @type {Error} */
        o
      );
      if (a && n)
        throw c;
      return i(c);
    }
    a || (s && s.then && typeof s.then == "function" ? s.then(l, i) : s instanceof Error ? i(s) : l(s));
  }
  function i(u, ...a) {
    n || (n = !0, t(u, ...a));
  }
  function l(u) {
    i(null, u);
  }
}
const yi = un().freeze(), ln = {}.hasOwnProperty;
function un() {
  const e = gi(), t = [];
  let n = {}, r, i = -1;
  return l.data = u, l.Parser = void 0, l.Compiler = void 0, l.freeze = a, l.attachers = t, l.use = s, l.parse = o, l.stringify = c, l.run = m, l.runSync = g, l.process = h, l.processSync = b, l;
  function l() {
    const x = un();
    let S = -1;
    for (; ++S < t.length; )
      x.use(...t[S]);
    return x.data(At(!0, {}, n)), x;
  }
  function u(x, S) {
    return typeof x == "string" ? arguments.length === 2 ? (qe("data", r), n[x] = S, l) : ln.call(n, x) && n[x] || null : x ? (qe("data", r), n = x, l) : n;
  }
  function a() {
    if (r)
      return l;
    for (; ++i < t.length; ) {
      const [x, ...S] = t[i];
      if (S[0] === !1)
        continue;
      S[0] === !0 && (S[0] = void 0);
      const k = x.call(l, ...S);
      typeof k == "function" && e.use(k);
    }
    return r = !0, i = Number.POSITIVE_INFINITY, l;
  }
  function s(x, ...S) {
    let k;
    if (qe("use", r), x != null)
      if (typeof x == "function")
        N(x, ...S);
      else if (typeof x == "object")
        Array.isArray(x) ? F(x) : E(x);
      else
        throw new TypeError("Expected usable value, not `" + x + "`");
    return k && (n.settings = Object.assign(n.settings || {}, k)), l;
    function P(d) {
      if (typeof d == "function")
        N(d);
      else if (typeof d == "object")
        if (Array.isArray(d)) {
          const [T, ...L] = d;
          N(T, ...L);
        } else
          E(d);
      else
        throw new TypeError("Expected usable value, not `" + d + "`");
    }
    function E(d) {
      F(d.plugins), d.settings && (k = Object.assign(k || {}, d.settings));
    }
    function F(d) {
      let T = -1;
      if (d != null)
        if (Array.isArray(d))
          for (; ++T < d.length; ) {
            const L = d[T];
            P(L);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + d + "`");
    }
    function N(d, T) {
      let L = -1, _;
      for (; ++L < t.length; )
        if (t[L][0] === d) {
          _ = t[L];
          break;
        }
      _ ? (Ge(_[1]) && Ge(T) && (T = At(!0, _[1], T)), _[1] = T) : t.push([...arguments]);
    }
  }
  function o(x) {
    l.freeze();
    const S = be(x), k = l.Parser;
    return Me("parse", k), zt(k, "parse") ? new k(String(S), S).parse() : k(String(S), S);
  }
  function c(x, S) {
    l.freeze();
    const k = be(S), P = l.Compiler;
    return He("stringify", P), Ot(x), zt(P, "compile") ? new P(x, k).compile() : P(x, k);
  }
  function m(x, S, k) {
    if (Ot(x), l.freeze(), !k && typeof S == "function" && (k = S, S = void 0), !k)
      return new Promise(P);
    P(null, k);
    function P(E, F) {
      e.run(x, be(S), N);
      function N(d, T, L) {
        T = T || x, d ? F(d) : E ? E(T) : k(null, T, L);
      }
    }
  }
  function g(x, S) {
    let k, P;
    return l.run(x, S, E), Pt("runSync", "run", P), k;
    function E(F, N) {
      wt(F), k = N, P = !0;
    }
  }
  function h(x, S) {
    if (l.freeze(), Me("process", l.Parser), He("process", l.Compiler), !S)
      return new Promise(k);
    k(null, S);
    function k(P, E) {
      const F = be(x);
      l.run(l.parse(F), F, (d, T, L) => {
        if (d || !T || !L)
          N(d);
        else {
          const _ = l.stringify(T, L);
          _ == null || (wi(_) ? L.value = _ : L.result = _), N(d, L);
        }
      });
      function N(d, T) {
        d || !T ? E(d) : P ? P(T) : S(null, T);
      }
    }
  }
  function b(x) {
    let S;
    l.freeze(), Me("processSync", l.Parser), He("processSync", l.Compiler);
    const k = be(x);
    return l.process(k, P), Pt("processSync", "process", S), k;
    function P(E) {
      S = !0, wt(E);
    }
  }
}
function zt(e, t) {
  return typeof e == "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  e.prototype && // A function with keys in its prototype is probably a constructor.
  // Classesâ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (xi(e.prototype) || t in e.prototype);
}
function xi(e) {
  let t;
  for (t in e)
    if (ln.call(e, t))
      return !0;
  return !1;
}
function Me(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `Parser`");
}
function He(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `Compiler`");
}
function qe(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Ot(e) {
  if (!Ge(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Pt(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function be(e) {
  return ki(e) ? e : new nn(e);
}
function ki(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function wi(e) {
  return typeof e == "string" || tn(e);
}
const bi = {};
function Si(e, t) {
  const n = t || bi, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return an(e, r, i);
}
function an(e, t, n) {
  if (Ei(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Lt(e.children, t, n);
  }
  return Array.isArray(e) ? Lt(e, t, n) : "";
}
function Lt(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = an(e[i], t, n);
  return r.join("");
}
function Ei(e) {
  return !!(e && typeof e == "object");
}
const Ci = {
  tokenize: Ii
};
function Ii(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), M(e, t, "linePrefix");
  }
  function i(a) {
    return e.enter("paragraph"), l(a);
  }
  function l(a) {
    const s = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = s), n = s, u(a);
  }
  function u(a) {
    if (a === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(a);
      return;
    }
    return z(a) ? (e.consume(a), e.exit("chunkText"), l) : (e.consume(a), u);
  }
}
const Ti = {
  tokenize: Ai
}, Ft = {
  tokenize: zi
};
function Ai(e) {
  const t = this, n = [];
  let r = 0, i, l, u;
  return a;
  function a(E) {
    if (r < n.length) {
      const F = n[r];
      return t.containerState = F[1], e.attempt(
        F[0].continuation,
        s,
        o
      )(E);
    }
    return o(E);
  }
  function s(E) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && P();
      const F = t.events.length;
      let N = F, d;
      for (; N--; )
        if (t.events[N][0] === "exit" && t.events[N][1].type === "chunkFlow") {
          d = t.events[N][1].end;
          break;
        }
      k(r);
      let T = F;
      for (; T < t.events.length; )
        t.events[T][1].end = Object.assign({}, d), T++;
      return pe(
        t.events,
        N + 1,
        0,
        t.events.slice(F)
      ), t.events.length = T, o(E);
    }
    return a(E);
  }
  function o(E) {
    if (r === n.length) {
      if (!i)
        return g(E);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return b(E);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      Ft,
      c,
      m
    )(E);
  }
  function c(E) {
    return i && P(), k(r), g(E);
  }
  function m(E) {
    return t.parser.lazy[t.now().line] = r !== n.length, u = t.now().offset, b(E);
  }
  function g(E) {
    return t.containerState = {}, e.attempt(
      Ft,
      h,
      b
    )(E);
  }
  function h(E) {
    return r++, n.push([t.currentConstruct, t.containerState]), g(E);
  }
  function b(E) {
    if (E === null) {
      i && P(), k(0), e.consume(E);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: l,
      _tokenizer: i
    }), x(E);
  }
  function x(E) {
    if (E === null) {
      S(e.exit("chunkFlow"), !0), k(0), e.consume(E);
      return;
    }
    return z(E) ? (e.consume(E), S(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(E), x);
  }
  function S(E, F) {
    const N = t.sliceStream(E);
    if (F && N.push(null), E.previous = l, l && (l.next = E), l = E, i.defineSkip(E.start), i.write(N), t.parser.lazy[E.start.line]) {
      let d = i.events.length;
      for (; d--; )
        if (
          // The token starts before the line endingâ¦
          i.events[d][1].start.offset < u && // â¦and either is not ended yetâ¦
          (!i.events[d][1].end || // â¦or ends after it.
          i.events[d][1].end.offset > u)
        )
          return;
      const T = t.events.length;
      let L = T, _, v;
      for (; L--; )
        if (t.events[L][0] === "exit" && t.events[L][1].type === "chunkFlow") {
          if (_) {
            v = t.events[L][1].end;
            break;
          }
          _ = !0;
        }
      for (k(r), d = T; d < t.events.length; )
        t.events[d][1].end = Object.assign({}, v), d++;
      pe(
        t.events,
        L + 1,
        0,
        t.events.slice(T)
      ), t.events.length = d;
    }
  }
  function k(E) {
    let F = n.length;
    for (; F-- > E; ) {
      const N = n[F];
      t.containerState = N[1], N[0].exit.call(t, e);
    }
    n.length = E;
  }
  function P() {
    i.write([null]), l = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function zi(e, t, n) {
  return M(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const Oi = {
  tokenize: Pi
};
function Pi(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Pe,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      M(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(ar, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(l), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(l) {
    if (l === null) {
      e.consume(l);
      return;
    }
    return e.enter("lineEnding"), e.consume(l), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const Li = {
  resolveAll: sn()
}, Fi = on("string"), Ni = on("text");
function on(e) {
  return {
    tokenize: t,
    resolveAll: sn(
      e === "text" ? Bi : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], l = n.attempt(i, u, a);
    return u;
    function u(c) {
      return o(c) ? l(c) : a(c);
    }
    function a(c) {
      if (c === null) {
        n.consume(c);
        return;
      }
      return n.enter("data"), n.consume(c), s;
    }
    function s(c) {
      return o(c) ? (n.exit("data"), l(c)) : (n.consume(c), s);
    }
    function o(c) {
      if (c === null)
        return !0;
      const m = i[c];
      let g = -1;
      if (m)
        for (; ++g < m.length; ) {
          const h = m[g];
          if (!h.previous || h.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function sn(e) {
  return t;
  function t(n, r) {
    let i = -1, l;
    for (; ++i <= n.length; )
      l === void 0 ? n[i] && n[i][1].type === "data" && (l = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== l + 2 && (n[l][1].end = n[i - 1][1].end, n.splice(l + 2, i - l - 2), i = l + 2), l = void 0);
    return e ? e(n, r) : n;
  }
}
function Bi(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let l = i.length, u = -1, a = 0, s;
      for (; l--; ) {
        const o = i[l];
        if (typeof o == "string") {
          for (u = o.length; o.charCodeAt(u - 1) === 32; )
            a++, u--;
          if (u)
            break;
          u = -1;
        } else if (o === -2)
          s = !0, a++;
        else if (o !== -1) {
          l++;
          break;
        }
      }
      if (a) {
        const o = {
          type: n === e.length || s || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a,
            _index: r.start._index + l,
            _bufferIndex: l ? u : r.start._bufferIndex + u
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, o.start), r.start.offset === r.end.offset ? Object.assign(r, o) : (e.splice(
          n,
          0,
          ["enter", o, t],
          ["exit", o, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function _i(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, l = [];
  let u = [], a = [];
  const s = {
    consume: P,
    enter: E,
    exit: F,
    attempt: T(N),
    check: T(d),
    interrupt: T(d, {
      interrupt: !0
    })
  }, o = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: h,
    sliceSerialize: g,
    now: b,
    defineSkip: x,
    write: m
  };
  let c = t.tokenize.call(o, s);
  return t.resolveAll && l.push(t), o;
  function m(C) {
    return u = Y(u, C), S(), u[u.length - 1] !== null ? [] : (L(t, 0), o.events = Ye(l, o.events, o), o.events);
  }
  function g(C, I) {
    return Ri(h(C), I);
  }
  function h(C) {
    return Di(u, C);
  }
  function b() {
    const { line: C, column: I, offset: H, _index: q, _bufferIndex: B } = r;
    return {
      line: C,
      column: I,
      offset: H,
      _index: q,
      _bufferIndex: B
    };
  }
  function x(C) {
    i[C.line] = C.column, v();
  }
  function S() {
    let C;
    for (; r._index < u.length; ) {
      const I = u[r._index];
      if (typeof I == "string")
        for (C = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === C && r._bufferIndex < I.length; )
          k(I.charCodeAt(r._bufferIndex));
      else
        k(I);
    }
  }
  function k(C) {
    c = c(C);
  }
  function P(C) {
    z(C) ? (r.line++, r.column = 1, r.offset += C === -3 ? 2 : 1, v()) : C !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === u[r._index].length && (r._bufferIndex = -1, r._index++)), o.previous = C;
  }
  function E(C, I) {
    const H = I || {};
    return H.type = C, H.start = b(), o.events.push(["enter", H, o]), a.push(H), H;
  }
  function F(C) {
    const I = a.pop();
    return I.end = b(), o.events.push(["exit", I, o]), I;
  }
  function N(C, I) {
    L(C, I.from);
  }
  function d(C, I) {
    I.restore();
  }
  function T(C, I) {
    return H;
    function H(q, B, Q) {
      let $, K, ie, p;
      return Array.isArray(q) ? le(q) : "tokenize" in q ? (
        // @ts-expect-error Looks like a construct.
        le([q])
      ) : Z(q);
      function Z(U) {
        return me;
        function me(oe) {
          const ge = oe !== null && U[oe], de = oe !== null && U.null, Le = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ge) ? ge : ge ? [ge] : [],
            ...Array.isArray(de) ? de : de ? [de] : []
          ];
          return le(Le)(oe);
        }
      }
      function le(U) {
        return $ = U, K = 0, U.length === 0 ? Q : f(U[K]);
      }
      function f(U) {
        return me;
        function me(oe) {
          return p = _(), ie = U, U.partial || (o.currentConstruct = U), U.name && o.parser.constructs.disable.null.includes(U.name) ? he() : U.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a âlive bindingâ, which is needed for `interrupt`.
            I ? Object.assign(Object.create(o), I) : o,
            s,
            ee,
            he
          )(oe);
        }
      }
      function ee(U) {
        return C(ie, p), B;
      }
      function he(U) {
        return p.restore(), ++K < $.length ? f($[K]) : Q;
      }
    }
  }
  function L(C, I) {
    C.resolveAll && !l.includes(C) && l.push(C), C.resolve && pe(
      o.events,
      I,
      o.events.length - I,
      C.resolve(o.events.slice(I), o)
    ), C.resolveTo && (o.events = C.resolveTo(o.events, o));
  }
  function _() {
    const C = b(), I = o.previous, H = o.currentConstruct, q = o.events.length, B = Array.from(a);
    return {
      restore: Q,
      from: q
    };
    function Q() {
      r = C, o.previous = I, o.currentConstruct = H, o.events.length = q, a = B, v();
    }
  }
  function v() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function Di(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, l = t.end._bufferIndex;
  let u;
  if (n === i)
    u = [e[n].slice(r, l)];
  else {
    if (u = e.slice(n, i), r > -1) {
      const a = u[0];
      typeof a == "string" ? u[0] = a.slice(r) : u.shift();
    }
    l > 0 && u.push(e[i].slice(0, l));
  }
  return u;
}
function Ri(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const l = e[n];
    let u;
    if (typeof l == "string")
      u = l;
    else
      switch (l) {
        case -5: {
          u = "\r";
          break;
        }
        case -4: {
          u = `
`;
          break;
        }
        case -3: {
          u = `\r
`;
          break;
        }
        case -2: {
          u = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i)
            continue;
          u = " ";
          break;
        }
        default:
          u = String.fromCharCode(l);
      }
    i = l === -2, r.push(u);
  }
  return r.join("");
}
const ji = {
  42: W,
  43: W,
  45: W,
  48: W,
  49: W,
  50: W,
  51: W,
  52: W,
  53: W,
  54: W,
  55: W,
  56: W,
  57: W,
  62: Gt
}, Mi = {
  91: fr
}, Hi = {
  [-2]: Be,
  [-1]: Be,
  32: Be
}, qi = {
  35: xr,
  42: Ae,
  45: [gt, Ae],
  60: Sr,
  61: gt,
  95: Ae,
  96: ht,
  126: ht
}, Vi = {
  38: Yt,
  92: Xt
}, vi = {
  [-5]: _e,
  [-4]: _e,
  [-3]: _e,
  33: Hr,
  38: Yt,
  42: Ue,
  60: [$n, Or],
  91: Vr,
  92: [dr, Xt],
  93: Ze,
  95: Ue,
  96: nr
}, $i = {
  null: [Ue, Li]
}, Ui = {
  null: [42, 95]
}, Qi = {
  null: []
}, Wi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Ui,
  contentInitial: Mi,
  disable: Qi,
  document: ji,
  flow: qi,
  flowInitial: Hi,
  insideSpan: $i,
  string: Vi,
  text: vi
}, Symbol.toStringTag, { value: "Module" }));
function Gi(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    Ln([Wi, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(Ci),
    document: i(Ti),
    flow: i(Oi),
    string: i(Fi),
    text: i(Ni)
  };
  return r;
  function i(l) {
    return u;
    function u(a) {
      return _i(r, l, a);
    }
  }
}
const Nt = /[\0\t\n\r]/g;
function Xi() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(l, u, a) {
    const s = [];
    let o, c, m, g, h;
    for (l = t + l.toString(u), m = 0, t = "", n && (l.charCodeAt(0) === 65279 && m++, n = void 0); m < l.length; ) {
      if (Nt.lastIndex = m, o = Nt.exec(l), g = o && o.index !== void 0 ? o.index : l.length, h = l.charCodeAt(g), !o) {
        t = l.slice(m);
        break;
      }
      if (h === 10 && m === g && r)
        s.push(-3), r = void 0;
      else
        switch (r && (s.push(-5), r = void 0), m < g && (s.push(l.slice(m, g)), e += g - m), h) {
          case 0: {
            s.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, s.push(-2); e++ < c; )
              s.push(-1);
            break;
          }
          case 10: {
            s.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      m = g + 1;
    }
    return a && (r && s.push(-5), t && s.push(t), s.push(null)), s;
  }
}
function Yi(e) {
  for (; !Jt(e); )
    ;
  return e;
}
const cn = {}.hasOwnProperty, Ji = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(e, t, n) {
    return typeof t != "string" && (n = t, t = void 0), Ki(n)(
      Yi(
        Gi(n).document().write(Xi()(e, t, !0))
      )
    );
  }
);
function Ki(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(ut),
      autolinkProtocol: C,
      autolinkEmail: C,
      atxHeading: a(rt),
      blockQuote: a(Le),
      characterEscape: C,
      characterReference: C,
      codeFenced: a(nt),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: a(nt, s),
      codeText: a(kn, s),
      codeTextData: C,
      data: C,
      codeFlowValue: C,
      definition: a(wn),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: a(bn),
      hardBreakEscape: a(it),
      hardBreakTrailing: a(it),
      htmlFlow: a(lt, s),
      htmlFlowData: C,
      htmlText: a(lt, s),
      htmlTextData: C,
      image: a(Sn),
      label: s,
      link: a(ut),
      listItem: a(En),
      listItemValue: b,
      listOrdered: a(at, h),
      listUnordered: a(at),
      paragraph: a(Cn),
      reference: he,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: a(rt),
      strong: a(In),
      thematicBreak: a(An)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: T,
      autolink: c(),
      autolinkEmail: de,
      autolinkProtocol: ge,
      blockQuote: c(),
      characterEscapeValue: I,
      characterReferenceMarkerHexadecimal: me,
      characterReferenceMarkerNumeric: me,
      characterReferenceValue: oe,
      codeFenced: c(P),
      codeFencedFence: k,
      codeFencedFenceInfo: x,
      codeFencedFenceMeta: S,
      codeFlowValue: I,
      codeIndented: c(E),
      codeText: c($),
      codeTextData: I,
      data: I,
      definition: c(),
      definitionDestinationString: d,
      definitionLabelString: F,
      definitionTitleString: N,
      emphasis: c(),
      hardBreakEscape: c(q),
      hardBreakTrailing: c(q),
      htmlFlow: c(B),
      htmlFlowData: I,
      htmlText: c(Q),
      htmlTextData: I,
      image: c(ie),
      label: Z,
      labelText: p,
      lineEnding: H,
      link: c(K),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: U,
      resourceDestinationString: le,
      resourceTitleString: f,
      resource: ee,
      setextHeading: c(v),
      setextHeadingLineSequence: _,
      setextHeadingText: L,
      strong: c(),
      thematicBreak: c()
    }
  };
  pn(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(y) {
    let w = {
      type: "root",
      children: []
    };
    const A = {
      stack: [w],
      tokenStack: [],
      config: t,
      enter: o,
      exit: m,
      buffer: s,
      resume: g,
      setData: l,
      getData: u
    }, D = [];
    let j = -1;
    for (; ++j < y.length; )
      if (y[j][1].type === "listOrdered" || y[j][1].type === "listUnordered")
        if (y[j][0] === "enter")
          D.push(j);
        else {
          const te = D.pop();
          j = i(y, te, j);
        }
    for (j = -1; ++j < y.length; ) {
      const te = t[y[j][0]];
      cn.call(te, y[j][1].type) && te[y[j][1].type].call(
        Object.assign(
          {
            sliceSerialize: y[j][2].sliceSerialize
          },
          A
        ),
        y[j][1]
      );
    }
    if (A.tokenStack.length > 0) {
      const te = A.tokenStack[A.tokenStack.length - 1];
      (te[1] || Bt).call(A, void 0, te[0]);
    }
    for (w.position = {
      start: ce(
        y.length > 0 ? y[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: ce(
        y.length > 0 ? y[y.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, j = -1; ++j < t.transforms.length; )
      w = t.transforms[j](w) || w;
    return w;
  }
  function i(y, w, A) {
    let D = w - 1, j = -1, te = !1, se, ue, ke, we;
    for (; ++D <= A; ) {
      const V = y[D];
      if (V[1].type === "listUnordered" || V[1].type === "listOrdered" || V[1].type === "blockQuote" ? (V[0] === "enter" ? j++ : j--, we = void 0) : V[1].type === "lineEndingBlank" ? V[0] === "enter" && (se && !we && !j && !ke && (ke = D), we = void 0) : V[1].type === "linePrefix" || V[1].type === "listItemValue" || V[1].type === "listItemMarker" || V[1].type === "listItemPrefix" || V[1].type === "listItemPrefixWhitespace" || (we = void 0), !j && V[0] === "enter" && V[1].type === "listItemPrefix" || j === -1 && V[0] === "exit" && (V[1].type === "listUnordered" || V[1].type === "listOrdered")) {
        if (se) {
          let Fe = D;
          for (ue = void 0; Fe--; ) {
            const ae = y[Fe];
            if (ae[1].type === "lineEnding" || ae[1].type === "lineEndingBlank") {
              if (ae[0] === "exit")
                continue;
              ue && (y[ue][1].type = "lineEndingBlank", te = !0), ae[1].type = "lineEnding", ue = Fe;
            } else if (!(ae[1].type === "linePrefix" || ae[1].type === "blockQuotePrefix" || ae[1].type === "blockQuotePrefixWhitespace" || ae[1].type === "blockQuoteMarker" || ae[1].type === "listItemIndent"))
              break;
          }
          ke && (!ue || ke < ue) && (se._spread = !0), se.end = Object.assign(
            {},
            ue ? y[ue][1].start : V[1].end
          ), y.splice(ue || D, 0, ["exit", se, V[2]]), D++, A++;
        }
        V[1].type === "listItemPrefix" && (se = {
          type: "listItem",
          _spread: !1,
          start: Object.assign({}, V[1].start),
          // @ts-expect-error: weâll add `end` in a second.
          end: void 0
        }, y.splice(D, 0, ["enter", se, V[2]]), D++, A++, ke = void 0, we = !0);
      }
    }
    return y[w][1]._spread = te, A;
  }
  function l(y, w) {
    n[y] = w;
  }
  function u(y) {
    return n[y];
  }
  function a(y, w) {
    return A;
    function A(D) {
      o.call(this, y(D), D), w && w.call(this, D);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(y, w, A) {
    return this.stack[this.stack.length - 1].children.push(y), this.stack.push(y), this.tokenStack.push([w, A]), y.position = {
      start: ce(w.start)
    }, y;
  }
  function c(y) {
    return w;
    function w(A) {
      y && y.call(this, A), m.call(this, A);
    }
  }
  function m(y, w) {
    const A = this.stack.pop(), D = this.tokenStack.pop();
    if (D)
      D[0].type !== y.type && (w ? w.call(this, y, D[0]) : (D[1] || Bt).call(this, y, D[0]));
    else
      throw new Error(
        "Cannot close `" + y.type + "` (" + Ee({
          start: y.start,
          end: y.end
        }) + "): itâs not open"
      );
    return A.position.end = ce(y.end), A;
  }
  function g() {
    return Si(this.stack.pop());
  }
  function h() {
    l("expectingFirstListItemValue", !0);
  }
  function b(y) {
    if (u("expectingFirstListItemValue")) {
      const w = this.stack[this.stack.length - 2];
      w.start = Number.parseInt(this.sliceSerialize(y), 10), l("expectingFirstListItemValue");
    }
  }
  function x() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.lang = y;
  }
  function S() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.meta = y;
  }
  function k() {
    u("flowCodeInside") || (this.buffer(), l("flowCodeInside", !0));
  }
  function P() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.value = y.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), l("flowCodeInside");
  }
  function E() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.value = y.replace(/(\r?\n|\r)$/g, "");
  }
  function F(y) {
    const w = this.resume(), A = this.stack[this.stack.length - 1];
    A.label = w, A.identifier = ye(
      this.sliceSerialize(y)
    ).toLowerCase();
  }
  function N() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.title = y;
  }
  function d() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.url = y;
  }
  function T(y) {
    const w = this.stack[this.stack.length - 1];
    if (!w.depth) {
      const A = this.sliceSerialize(y).length;
      w.depth = A;
    }
  }
  function L() {
    l("setextHeadingSlurpLineEnding", !0);
  }
  function _(y) {
    const w = this.stack[this.stack.length - 1];
    w.depth = this.sliceSerialize(y).charCodeAt(0) === 61 ? 1 : 2;
  }
  function v() {
    l("setextHeadingSlurpLineEnding");
  }
  function C(y) {
    const w = this.stack[this.stack.length - 1];
    let A = w.children[w.children.length - 1];
    (!A || A.type !== "text") && (A = Tn(), A.position = {
      start: ce(y.start)
    }, w.children.push(A)), this.stack.push(A);
  }
  function I(y) {
    const w = this.stack.pop();
    w.value += this.sliceSerialize(y), w.position.end = ce(y.end);
  }
  function H(y) {
    const w = this.stack[this.stack.length - 1];
    if (u("atHardBreak")) {
      const A = w.children[w.children.length - 1];
      A.position.end = ce(y.end), l("atHardBreak");
      return;
    }
    !u("setextHeadingSlurpLineEnding") && t.canContainEols.includes(w.type) && (C.call(this, y), I.call(this, y));
  }
  function q() {
    l("atHardBreak", !0);
  }
  function B() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.value = y;
  }
  function Q() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.value = y;
  }
  function $() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.value = y;
  }
  function K() {
    const y = this.stack[this.stack.length - 1];
    if (u("inReference")) {
      const w = u("referenceType") || "shortcut";
      y.type += "Reference", y.referenceType = w, delete y.url, delete y.title;
    } else
      delete y.identifier, delete y.label;
    l("referenceType");
  }
  function ie() {
    const y = this.stack[this.stack.length - 1];
    if (u("inReference")) {
      const w = u("referenceType") || "shortcut";
      y.type += "Reference", y.referenceType = w, delete y.url, delete y.title;
    } else
      delete y.identifier, delete y.label;
    l("referenceType");
  }
  function p(y) {
    const w = this.sliceSerialize(y), A = this.stack[this.stack.length - 2];
    A.label = Fn(w), A.identifier = ye(w).toLowerCase();
  }
  function Z() {
    const y = this.stack[this.stack.length - 1], w = this.resume(), A = this.stack[this.stack.length - 1];
    if (l("inReference", !0), A.type === "link") {
      const D = y.children;
      A.children = D;
    } else
      A.alt = w;
  }
  function le() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.url = y;
  }
  function f() {
    const y = this.resume(), w = this.stack[this.stack.length - 1];
    w.title = y;
  }
  function ee() {
    l("inReference");
  }
  function he() {
    l("referenceType", "collapsed");
  }
  function U(y) {
    const w = this.resume(), A = this.stack[this.stack.length - 1];
    A.label = w, A.identifier = ye(
      this.sliceSerialize(y)
    ).toLowerCase(), l("referenceType", "full");
  }
  function me(y) {
    l("characterReferenceType", y.type);
  }
  function oe(y) {
    const w = this.sliceSerialize(y), A = u("characterReferenceType");
    let D;
    A ? (D = Nn(
      w,
      A === "characterReferenceMarkerNumeric" ? 10 : 16
    ), l("characterReferenceType")) : D = Ut(w);
    const j = this.stack.pop();
    j.value += D, j.position.end = ce(y.end);
  }
  function ge(y) {
    I.call(this, y);
    const w = this.stack[this.stack.length - 1];
    w.url = this.sliceSerialize(y);
  }
  function de(y) {
    I.call(this, y);
    const w = this.stack[this.stack.length - 1];
    w.url = "mailto:" + this.sliceSerialize(y);
  }
  function Le() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function nt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function kn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function wn() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function bn() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function rt() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function it() {
    return {
      type: "break"
    };
  }
  function lt() {
    return {
      type: "html",
      value: ""
    };
  }
  function Sn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function ut() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function at(y) {
    return {
      type: "list",
      ordered: y.type === "listOrdered",
      start: null,
      spread: y._spread,
      children: []
    };
  }
  function En(y) {
    return {
      type: "listItem",
      spread: y._spread,
      checked: null,
      children: []
    };
  }
  function Cn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function In() {
    return {
      type: "strong",
      children: []
    };
  }
  function Tn() {
    return {
      type: "text",
      value: ""
    };
  }
  function An() {
    return {
      type: "thematicBreak"
    };
  }
}
function ce(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function pn(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? pn(e, r) : Zi(e, r);
  }
}
function Zi(e, t) {
  let n;
  for (n in t)
    if (cn.call(t, n)) {
      if (n === "canContainEols") {
        const r = t[n];
        r && e[n].push(...r);
      } else if (n === "transforms") {
        const r = t[n];
        r && e[n].push(...r);
      } else if (n === "enter" || n === "exit") {
        const r = t[n];
        r && Object.assign(e[n], r);
      }
    }
}
function Bt(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + Ee({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + Ee({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + Ee({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function el(e) {
  Object.assign(this, { Parser: (n) => {
    const r = (
      /** @type {Options} */
      this.data("settings")
    );
    return Ji(
      n,
      Object.assign({}, r, e, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  } });
}
function tl(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function nl(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function rl(e, t) {
  const n = t.value ? t.value + `
` : "", r = t.lang ? t.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null, i = {};
  r && (i.className = ["language-" + r]);
  let l = {
    type: "element",
    tagName: "code",
    properties: i,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (l.data = { meta: t.meta }), e.patch(t, l), l = e.applyData(t, l), l = { type: "element", tagName: "pre", properties: {}, children: [l] }, e.patch(t, l), l;
}
function il(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ll(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function fn(e, t) {
  const n = String(t.identifier).toUpperCase(), r = xe(n.toLowerCase()), i = e.footnoteOrder.indexOf(n);
  let l;
  i === -1 ? (e.footnoteOrder.push(n), e.footnoteCounts[n] = 1, l = e.footnoteOrder.length) : (e.footnoteCounts[n]++, l = i + 1);
  const u = e.footnoteCounts[n], a = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + e.clobberPrefix + "fn-" + r,
      id: e.clobberPrefix + "fnref-" + r + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(l) }]
  };
  e.patch(t, a);
  const s = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [a]
  };
  return e.patch(t, s), e.applyData(t, s);
}
function ul(e, t) {
  const n = e.footnoteById;
  let r = 1;
  for (; r in n; )
    r++;
  const i = String(r);
  return n[i] = {
    type: "footnoteDefinition",
    identifier: i,
    children: [{ type: "paragraph", children: t.children }],
    position: t.position
  }, fn(e, {
    type: "footnoteReference",
    identifier: i,
    position: t.position
  });
}
function al(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ol(e, t) {
  if (e.dangerous) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
  return null;
}
function hn(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return { type: "text", value: "![" + t.alt + r };
  const i = e.all(t), l = i[0];
  l && l.type === "text" ? l.value = "[" + l.value : i.unshift({ type: "text", value: "[" });
  const u = i[i.length - 1];
  return u && u.type === "text" ? u.value += r : i.push({ type: "text", value: r }), i;
}
function sl(e, t) {
  const n = e.definition(t.identifier);
  if (!n)
    return hn(e, t);
  const r = { src: xe(n.url || ""), alt: t.alt };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const i = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, i), e.applyData(t, i);
}
function cl(e, t) {
  const n = { src: xe(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function pl(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function fl(e, t) {
  const n = e.definition(t.identifier);
  if (!n)
    return hn(e, t);
  const r = { href: xe(n.url || "") };
  n.title !== null && n.title !== void 0 && (r.title = n.title);
  const i = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, i), e.applyData(t, i);
}
function hl(e, t) {
  const n = { href: xe(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function ml(e, t, n) {
  const r = e.all(t), i = n ? gl(n) : mn(t), l = {}, u = [];
  if (typeof t.checked == "boolean") {
    const c = r[0];
    let m;
    c && c.type === "element" && c.tagName === "p" ? m = c : (m = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(m)), m.children.length > 0 && m.children.unshift({ type: "text", value: " " }), m.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), l.className = ["task-list-item"];
  }
  let a = -1;
  for (; ++a < r.length; ) {
    const c = r[a];
    (i || a !== 0 || c.type !== "element" || c.tagName !== "p") && u.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? u.push(...c.children) : u.push(c);
  }
  const s = r[r.length - 1];
  s && (i || s.type !== "element" || s.tagName !== "p") && u.push({ type: "text", value: `
` });
  const o = { type: "element", tagName: "li", properties: l, children: u };
  return e.patch(t, o), e.applyData(t, o);
}
function gl(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = mn(n[r]);
  }
  return t;
}
function mn(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function dl(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const u = r[i];
    if (u.type === "element" && u.tagName === "li" && u.properties && Array.isArray(u.properties.className) && u.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const l = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, l), e.applyData(t, l);
}
function yl(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function xl(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function kl(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function wl(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const u = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], u), i.push(u);
  }
  if (n.length > 0) {
    const u = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, a = Qt(t.children[1]), s = Wt(t.children[t.children.length - 1]);
    a.line && s.line && (u.position = { start: a, end: s }), i.push(u);
  }
  const l = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, l), e.applyData(t, l);
}
function bl(e, t, n) {
  const r = n ? n.children : void 0, l = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", u = n && n.type === "table" ? n.align : void 0, a = u ? u.length : t.children.length;
  let s = -1;
  const o = [];
  for (; ++s < a; ) {
    const m = t.children[s], g = {}, h = u ? u[s] : void 0;
    h && (g.align = h);
    let b = { type: "element", tagName: l, properties: g, children: [] };
    m && (b.children = e.all(m), e.patch(m, b), b = e.applyData(t, b)), o.push(b);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function Sl(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const _t = 9, Dt = 32;
function El(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const l = [];
  for (; r; )
    l.push(
      Rt(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return l.push(Rt(t.slice(i), i > 0, !1)), l.join("");
}
function Rt(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let l = e.codePointAt(r);
    for (; l === _t || l === Dt; )
      r++, l = e.codePointAt(r);
  }
  if (n) {
    let l = e.codePointAt(i - 1);
    for (; l === _t || l === Dt; )
      i--, l = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function Cl(e, t) {
  const n = { type: "text", value: El(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Il(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Tl = {
  blockquote: tl,
  break: nl,
  code: rl,
  delete: il,
  emphasis: ll,
  footnoteReference: fn,
  footnote: ul,
  heading: al,
  html: ol,
  imageReference: sl,
  image: cl,
  inlineCode: pl,
  linkReference: fl,
  link: hl,
  listItem: ml,
  list: dl,
  paragraph: yl,
  root: xl,
  strong: kl,
  table: wl,
  tableCell: Sl,
  tableRow: bl,
  text: Cl,
  thematicBreak: Il,
  toml: Ie,
  yaml: Ie,
  definition: Ie,
  footnoteDefinition: Ie
};
function Ie() {
  return null;
}
function Al(e) {
  return !e || !e.position || !e.position.start || !e.position.start.line || !e.position.start.column || !e.position.end || !e.position.end.line || !e.position.end.column;
}
const jt = {}.hasOwnProperty;
function zl(e) {
  const t = /* @__PURE__ */ Object.create(null);
  if (!e || !e.type)
    throw new Error("mdast-util-definitions expected node");
  return Ke(e, "definition", (r) => {
    const i = Mt(r.identifier);
    i && !jt.call(t, i) && (t[i] = r);
  }), n;
  function n(r) {
    const i = Mt(r);
    return i && jt.call(t, i) ? t[i] : null;
  }
}
function Mt(e) {
  return String(e || "").toUpperCase();
}
const Oe = {}.hasOwnProperty;
function Ol(e, t) {
  const n = t || {}, r = n.allowDangerousHtml || !1, i = {};
  return u.dangerous = r, u.clobberPrefix = n.clobberPrefix === void 0 || n.clobberPrefix === null ? "user-content-" : n.clobberPrefix, u.footnoteLabel = n.footnoteLabel || "Footnotes", u.footnoteLabelTagName = n.footnoteLabelTagName || "h2", u.footnoteLabelProperties = n.footnoteLabelProperties || {
    className: ["sr-only"]
  }, u.footnoteBackLabel = n.footnoteBackLabel || "Back to content", u.unknownHandler = n.unknownHandler, u.passThrough = n.passThrough, u.handlers = { ...Tl, ...n.handlers }, u.definition = zl(e), u.footnoteById = i, u.footnoteOrder = [], u.footnoteCounts = {}, u.patch = Pl, u.applyData = Ll, u.one = a, u.all = s, u.wrap = Nl, u.augment = l, Ke(e, "footnoteDefinition", (o) => {
    const c = String(o.identifier).toUpperCase();
    Oe.call(i, c) || (i[c] = o);
  }), u;
  function l(o, c) {
    if (o && "data" in o && o.data) {
      const m = o.data;
      m.hName && (c.type !== "element" && (c = {
        type: "element",
        tagName: "",
        properties: {},
        children: []
      }), c.tagName = m.hName), c.type === "element" && m.hProperties && (c.properties = { ...c.properties, ...m.hProperties }), "children" in c && c.children && m.hChildren && (c.children = m.hChildren);
    }
    if (o) {
      const m = "type" in o ? o : { position: o };
      Al(m) || (c.position = { start: Qt(m), end: Wt(m) });
    }
    return c;
  }
  function u(o, c, m, g) {
    return Array.isArray(m) && (g = m, m = {}), l(o, {
      type: "element",
      tagName: c,
      properties: m || {},
      children: g || []
    });
  }
  function a(o, c) {
    return gn(u, o, c);
  }
  function s(o) {
    return et(u, o);
  }
}
function Pl(e, t) {
  e.position && (t.position = Bn(e));
}
function Ll(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, l = e.data.hProperties;
    typeof r == "string" && (n.type === "element" ? n.tagName = r : n = {
      type: "element",
      tagName: r,
      properties: {},
      children: []
    }), n.type === "element" && l && (n.properties = { ...n.properties, ...l }), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function gn(e, t, n) {
  const r = t && t.type;
  if (!r)
    throw new Error("Expected node, got `" + t + "`");
  return Oe.call(e.handlers, r) ? e.handlers[r](e, t, n) : e.passThrough && e.passThrough.includes(r) ? "children" in t ? { ...t, children: et(e, t) } : t : e.unknownHandler ? e.unknownHandler(e, t, n) : Fl(e, t);
}
function et(e, t) {
  const n = [];
  if ("children" in t) {
    const r = t.children;
    let i = -1;
    for (; ++i < r.length; ) {
      const l = gn(e, r[i], t);
      if (l) {
        if (i && r[i - 1].type === "break" && (!Array.isArray(l) && l.type === "text" && (l.value = l.value.replace(/^\s+/, "")), !Array.isArray(l) && l.type === "element")) {
          const u = l.children[0];
          u && u.type === "text" && (u.value = u.value.replace(/^\s+/, ""));
        }
        Array.isArray(l) ? n.push(...l) : n.push(l);
      }
    }
  }
  return n;
}
function Fl(e, t) {
  const n = t.data || {}, r = "value" in t && !(Oe.call(n, "hProperties") || Oe.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: et(e, t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Nl(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Bl(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.footnoteOrder.length; ) {
    const r = e.footnoteById[e.footnoteOrder[n]];
    if (!r)
      continue;
    const i = e.all(r), l = String(r.identifier).toUpperCase(), u = xe(l.toLowerCase());
    let a = 0;
    const s = [];
    for (; ++a <= e.footnoteCounts[l]; ) {
      const m = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + e.clobberPrefix + "fnref-" + u + (a > 1 ? "-" + a : ""),
          dataFootnoteBackref: !0,
          className: ["data-footnote-backref"],
          ariaLabel: e.footnoteBackLabel
        },
        children: [{ type: "text", value: "â©" }]
      };
      a > 1 && m.children.push({
        type: "element",
        tagName: "sup",
        children: [{ type: "text", value: String(a) }]
      }), s.length > 0 && s.push({ type: "text", value: " " }), s.push(m);
    }
    const o = i[i.length - 1];
    if (o && o.type === "element" && o.tagName === "p") {
      const m = o.children[o.children.length - 1];
      m && m.type === "text" ? m.value += " " : o.children.push({ type: "text", value: " " }), o.children.push(...s);
    } else
      i.push(...s);
    const c = {
      type: "element",
      tagName: "li",
      properties: { id: e.clobberPrefix + "fn-" + u },
      children: e.wrap(i, !0)
    };
    e.patch(r, c), t.push(c);
  }
  if (t.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: e.footnoteLabelTagName,
          properties: {
            // To do: use structured clone.
            ...JSON.parse(JSON.stringify(e.footnoteLabelProperties)),
            id: "footnote-label"
          },
          children: [{ type: "text", value: e.footnoteLabel }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(t, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
function dn(e, t) {
  const n = Ol(e, t), r = n.one(e, null), i = Bl(n);
  return i && r.children.push({ type: "text", value: `
` }, i), Array.isArray(r) ? { type: "root", children: r } : r;
}
const _l = (
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  function(e, t) {
    return e && "run" in e ? Rl(e, t) : jl(e || t);
  }
), Dl = _l;
function Rl(e, t) {
  return (n, r, i) => {
    e.run(dn(n, t), r, (l) => {
      i(l);
    });
  };
}
function jl(e) {
  return (t) => dn(t, e);
}
function Ml(e) {
  if (e.allowedElements && e.disallowedElements)
    throw new TypeError(
      "Only one of `allowedElements` and `disallowedElements` should be defined"
    );
  if (e.allowedElements || e.disallowedElements || e.allowElement)
    return (t) => {
      Ke(t, "element", (n, r, i) => {
        const l = (
          /** @type {Element|Root} */
          i
        );
        let u;
        if (e.allowedElements ? u = !e.allowedElements.includes(n.tagName) : e.disallowedElements && (u = e.disallowedElements.includes(n.tagName)), !u && e.allowElement && typeof r == "number" && (u = !e.allowElement(n, r, l)), u && typeof r == "number")
          return e.unwrapDisallowed && n.children ? l.children.splice(r, 1, ...n.children) : l.children.splice(r, 1), r;
      });
    };
}
function Hl(e) {
  const t = (
    // @ts-expect-error looks like a node.
    e && typeof e == "object" && e.type === "text" ? (
      // @ts-expect-error looks like a text.
      e.value || ""
    ) : e
  );
  return typeof t == "string" && t.replace(/[ \t\n\f\r]/g, "") === "";
}
var tt = { exports: {} }, Ht = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, ql = /\n/g, Vl = /^\s*/, vl = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $l = /^:\s*/, Ul = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Ql = /^[;\s]*/, Wl = /^\s+|\s+$/g, Gl = `
`, qt = "/", Vt = "*", fe = "", Xl = "comment", Yl = "declaration", Jl = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var n = 1, r = 1;
  function i(b) {
    var x = b.match(ql);
    x && (n += x.length);
    var S = b.lastIndexOf(Gl);
    r = ~S ? b.length - S : r + b.length;
  }
  function l() {
    var b = { line: n, column: r };
    return function(x) {
      return x.position = new u(b), o(), x;
    };
  }
  function u(b) {
    this.start = b, this.end = { line: n, column: r }, this.source = t.source;
  }
  u.prototype.content = e;
  function a(b) {
    var x = new Error(
      t.source + ":" + n + ":" + r + ": " + b
    );
    if (x.reason = b, x.filename = t.source, x.line = n, x.column = r, x.source = e, !t.silent)
      throw x;
  }
  function s(b) {
    var x = b.exec(e);
    if (x) {
      var S = x[0];
      return i(S), e = e.slice(S.length), x;
    }
  }
  function o() {
    s(Vl);
  }
  function c(b) {
    var x;
    for (b = b || []; x = m(); )
      x !== !1 && b.push(x);
    return b;
  }
  function m() {
    var b = l();
    if (!(qt != e.charAt(0) || Vt != e.charAt(1))) {
      for (var x = 2; fe != e.charAt(x) && (Vt != e.charAt(x) || qt != e.charAt(x + 1)); )
        ++x;
      if (x += 2, fe === e.charAt(x - 1))
        return a("End of comment missing");
      var S = e.slice(2, x - 2);
      return r += 2, i(S), e = e.slice(x), r += 2, b({
        type: Xl,
        comment: S
      });
    }
  }
  function g() {
    var b = l(), x = s(vl);
    if (x) {
      if (m(), !s($l))
        return a("property missing ':'");
      var S = s(Ul), k = b({
        type: Yl,
        property: vt(x[0].replace(Ht, fe)),
        value: S ? vt(S[0].replace(Ht, fe)) : fe
      });
      return s(Ql), k;
    }
  }
  function h() {
    var b = [];
    c(b);
    for (var x; x = g(); )
      x !== !1 && (b.push(x), c(b));
    return b;
  }
  return o(), h();
};
function vt(e) {
  return e ? e.replace(Wl, fe) : fe;
}
var Kl = Jl;
function yn(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  for (var r, i = Kl(e), l = typeof t == "function", u, a, s = 0, o = i.length; s < o; s++)
    r = i[s], u = r.property, a = r.value, l ? t(u, a, r) : a && (n || (n = {}), n[u] = a);
  return n;
}
tt.exports = yn;
tt.exports.default = yn;
var Zl = tt.exports;
const eu = /* @__PURE__ */ Je(Zl), Xe = {}.hasOwnProperty, tu = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
function xn(e, t) {
  const n = [];
  let r = -1, i;
  for (; ++r < t.children.length; )
    i = t.children[r], i.type === "element" ? n.push(nu(e, i, r, t)) : i.type === "text" ? (t.type !== "element" || !tu.has(t.tagName) || !Hl(i)) && n.push(i.value) : i.type === "raw" && !e.options.skipHtml && n.push(i.value);
  return n;
}
function nu(e, t, n, r) {
  const i = e.options, l = i.transformLinkUri === void 0 ? ti : i.transformLinkUri, u = e.schema, a = t.tagName, s = {};
  let o = u, c;
  if (u.space === "html" && a === "svg" && (o = Mn, e.schema = o), t.properties)
    for (c in t.properties)
      Xe.call(t.properties, c) && iu(s, c, t.properties[c], e);
  (a === "ol" || a === "ul") && e.listDepth++;
  const m = xn(e, t);
  (a === "ol" || a === "ul") && e.listDepth--, e.schema = u;
  const g = t.position || {
    start: {
      line: null,
      column: null,
      offset: null
    },
    end: {
      line: null,
      column: null,
      offset: null
    }
  }, h = i.components && Xe.call(i.components, a) ? i.components[a] : a, b = typeof h == "string" || h === Ne.Fragment;
  if (!_n.isValidElementType(h))
    throw new TypeError(`Component for name \`${a}\` not defined or is not renderable`);
  if (s.key = n, a === "a" && i.linkTarget && (s.target = typeof i.linkTarget == "function" ? i.linkTarget(String(s.href || ""), t.children, typeof s.title == "string" ? s.title : null) : i.linkTarget), a === "a" && l && (s.href = l(String(s.href || ""), t.children, typeof s.title == "string" ? s.title : null)), !b && a === "code" && r.type === "element" && r.tagName !== "pre" && (s.inline = !0), !b && (a === "h1" || a === "h2" || a === "h3" || a === "h4" || a === "h5" || a === "h6") && (s.level = Number.parseInt(a.charAt(1), 10)), a === "img" && i.transformImageUri && (s.src = i.transformImageUri(String(s.src || ""), String(s.alt || ""), typeof s.title == "string" ? s.title : null)), !b && a === "li" && r.type === "element") {
    const x = ru(t);
    s.checked = x && x.properties ? !!x.properties.checked : null, s.index = Ve(r, t), s.ordered = r.tagName === "ol";
  }
  return !b && (a === "ol" || a === "ul") && (s.ordered = a === "ol", s.depth = e.listDepth), (a === "td" || a === "th") && (s.align && (s.style || (s.style = {}), s.style.textAlign = s.align, delete s.align), b || (s.isHeader = a === "th")), !b && a === "tr" && r.type === "element" && (s.isHeader = r.tagName === "thead"), i.sourcePos && (s["data-sourcepos"] = au(g)), !b && i.rawSourcePos && (s.sourcePosition = t.position), !b && i.includeElementIndex && (s.index = Ve(r, t), s.siblingCount = Ve(r)), b || (s.node = t), m.length > 0 ? Ne.createElement(h, s, m) : Ne.createElement(h, s);
}
function ru(e) {
  let t = -1;
  for (; ++t < e.children.length; ) {
    const n = e.children[t];
    if (n.type === "element" && n.tagName === "input")
      return n;
  }
  return null;
}
function Ve(e, t) {
  let n = -1, r = 0;
  for (; ++n < e.children.length && e.children[n] !== t; )
    e.children[n].type === "element" && r++;
  return r;
}
function iu(e, t, n, r) {
  const i = Dn(r.schema, t);
  let l = n;
  l == null || l !== l || (Array.isArray(l) && (l = i.commaSeparated ? Rn(l) : jn(l)), i.property === "style" && typeof l == "string" && (l = lu(l)), i.space && i.property ? e[Xe.call(ct, i.property) ? ct[i.property] : i.property] = l : i.attribute && (e[i.attribute] = l));
}
function lu(e) {
  const t = {};
  try {
    eu(e, n);
  } catch {
  }
  return t;
  function n(r, i) {
    const l = r.slice(0, 4) === "-ms-" ? `ms-${r.slice(4)}` : r;
    t[l.replace(/-([a-z])/g, uu)] = i;
  }
}
function uu(e, t) {
  return t.toUpperCase();
}
function au(e) {
  return [e.start.line, ":", e.start.column, "-", e.end.line, ":", e.end.column].map(String).join("");
}
const $t = {}.hasOwnProperty, ou = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Te = {
  plugins: {
    to: "remarkPlugins",
    id: "change-plugins-to-remarkplugins"
  },
  renderers: {
    to: "components",
    id: "change-renderers-to-components"
  },
  astPlugins: {
    id: "remove-buggy-html-in-markdown-parser"
  },
  allowDangerousHtml: {
    id: "remove-buggy-html-in-markdown-parser"
  },
  escapeHtml: {
    id: "remove-buggy-html-in-markdown-parser"
  },
  source: {
    to: "children",
    id: "change-source-to-children"
  },
  allowNode: {
    to: "allowElement",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  allowedTypes: {
    to: "allowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  disallowedTypes: {
    to: "disallowedElements",
    id: "replace-allownode-allowedtypes-and-disallowedtypes"
  },
  includeNodeIndex: {
    to: "includeElementIndex",
    id: "change-includenodeindex-to-includeelementindex"
  }
};
function su(e) {
  for (const l in Te)
    if ($t.call(Te, l) && $t.call(e, l)) {
      const u = Te[l];
      console.warn(`[react-markdown] Warning: please ${u.to ? `use \`${u.to}\` instead of` : "remove"} \`${l}\` (see <${ou}#${u.id}> for more info)`), delete Te[l];
    }
  const t = yi().use(el).use(e.remarkPlugins || []).use(Dl, {
    ...e.remarkRehypeOptions,
    allowDangerousHtml: !0
  }).use(e.rehypePlugins || []).use(Ml, e), n = new nn();
  typeof e.children == "string" ? n.value = e.children : e.children !== void 0 && e.children !== null && console.warn(`[react-markdown] Warning: please pass a string as \`children\` (not: \`${e.children}\`)`);
  const r = t.runSync(t.parse(n), n);
  if (r.type !== "root")
    throw new TypeError("Expected a `root` node");
  let i = /* @__PURE__ */ st(Hn, {
    children: xn({
      options: e,
      schema: qn,
      listDepth: 0
    }, r)
  });
  return e.className && (i = /* @__PURE__ */ st("div", {
    className: e.className,
    children: i
  })), i;
}
su.propTypes = {
  // Core options:
  children: O.string,
  // Layout options:
  className: O.string,
  // Filter options:
  allowElement: O.func,
  allowedElements: O.arrayOf(O.string),
  disallowedElements: O.arrayOf(O.string),
  unwrapDisallowed: O.bool,
  // Plugin options:
  remarkPlugins: O.arrayOf(O.oneOfType([O.object, O.func, O.arrayOf(O.oneOfType([O.bool, O.string, O.object, O.func, O.arrayOf(
    // prettier-ignore
    // type-coverage:ignore-next-line
    O.any
  )]))])),
  rehypePlugins: O.arrayOf(O.oneOfType([O.object, O.func, O.arrayOf(O.oneOfType([O.bool, O.string, O.object, O.func, O.arrayOf(
    // prettier-ignore
    // type-coverage:ignore-next-line
    O.any
  )]))])),
  // Transform options:
  sourcePos: O.bool,
  rawSourcePos: O.bool,
  skipHtml: O.bool,
  includeElementIndex: O.bool,
  transformLinkUri: O.oneOfType([O.func, O.bool]),
  linkTarget: O.oneOfType([O.func, O.string]),
  transformImageUri: O.func,
  components: O.object
};
export {
  su as default,
  ti as uriTransformer
};
