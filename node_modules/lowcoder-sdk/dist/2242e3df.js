import { i as hi, c as pi, _ as _s, d as mi, m as Fe, w as Ue, u as gn, b as ws, S as xs, e as Ss, a as Es } from "./1fb07b21.js";
import * as Os from "react";
import L, { useRef as T, useEffect as M, useMemo as ce, useState as J, useLayoutEffect as gi, forwardRef as vi, useCallback as yi, useContext as Qt, memo as at, useImperativeHandle as Cs } from "react";
import { i6 as ks, F as C, a8 as ie, me as Ae, G as bi } from "./c988e26e.js";
import * as Ps from "react-dom";
import { unstable_batchedUpdates as Ts, createPortal as Is } from "react-dom";
import { i as As } from "./951b5247.js";
import { c as Rs, a as $s } from "./14897c7e.js";
import { t as Ds } from "./9caec5b5.js";
var Ms = function(t) {
  return function(e, n) {
    var i = T(!1);
    t(function() {
      return function() {
        i.current = !1;
      };
    }, []), t(function() {
      if (!i.current)
        i.current = !0;
      else
        return e();
    }, n);
  };
};
const Ns = Ms(M);
function _i(t) {
  var e = T(t);
  return e.current = t, e;
}
var Ls = function(t) {
  hi && (pi(t) || console.error("useUnmount expected parameter is a function, got ".concat(typeof t)));
  var e = _i(t);
  M(function() {
    return function() {
      e.current();
    };
  }, []);
};
const Vs = Ls;
var js = Rs, Fs = function() {
  return js.Date.now();
}, Us = Fs, Bs = $s, _t = Us, vn = Ds, qs = "Expected a function", Ws = Math.max, zs = Math.min;
function Ks(t, e, n) {
  var i, s, r, o, a, c, l = 0, u = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(qs);
  e = vn(e) || 0, Bs(n) && (u = !!n.leading, d = "maxWait" in n, r = d ? Ws(vn(n.maxWait) || 0, e) : r, f = "trailing" in n ? !!n.trailing : f);
  function m(x) {
    var k = i, P = s;
    return i = s = void 0, l = x, o = t.apply(P, k), o;
  }
  function y(x) {
    return l = x, a = setTimeout(h, e), u ? m(x) : o;
  }
  function w(x) {
    var k = x - c, P = x - l, I = e - k;
    return d ? zs(I, r - P) : I;
  }
  function v(x) {
    var k = x - c, P = x - l;
    return c === void 0 || k >= e || k < 0 || d && P >= r;
  }
  function h() {
    var x = _t();
    if (v(x))
      return _(x);
    a = setTimeout(h, w(x));
  }
  function _(x) {
    return a = void 0, f && i ? m(x) : (i = s = void 0, o);
  }
  function b() {
    a !== void 0 && clearTimeout(a), l = 0, i = c = s = a = void 0;
  }
  function g() {
    return a === void 0 ? o : _(_t());
  }
  function S() {
    var x = _t(), k = v(x);
    if (i = arguments, s = this, c = x, k) {
      if (a === void 0)
        return y(c);
      if (d)
        return clearTimeout(a), a = setTimeout(h, e), m(c);
    }
    return a === void 0 && (a = setTimeout(h, e)), o;
  }
  return S.cancel = b, S.flush = g, S;
}
var Hs = Ks;
const Qs = /* @__PURE__ */ ks(Hs);
var Gs = !!(typeof window < "u" && window.document && window.document.createElement);
const Ys = Gs;
function Xs() {
  var t = (typeof global > "u" ? "undefined" : typeof global) == "object" && global && global.Object === Object && global, e = typeof self == "object" && self && self.Object === Object && self;
  return t || e;
}
Xs() || (global.Date = Date);
function Zs(t, e) {
  var n;
  hi && (pi(t) || console.error("useDebounceFn expected parameter is a function, got ".concat(typeof t)));
  var i = _i(t), s = (n = e == null ? void 0 : e.wait) !== null && n !== void 0 ? n : 1e3, r = ce(function() {
    return Qs(function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      return i.current.apply(i, _s([], mi(o), !1));
    }, s, e);
  }, []);
  return Vs(function() {
    r.cancel();
  }), {
    run: r,
    cancel: r.cancel,
    flush: r.flush
  };
}
function Js(t, e, n) {
  var i = mi(J({}), 2), s = i[0], r = i[1], o = Zs(function() {
    r({});
  }, n).run;
  M(function() {
    return o();
  }, e), Ns(t, [s]);
}
var er = Ys ? gi : M;
const Ce = er;
var tr = function() {
  var t = T(!1);
  return M(function() {
    return t.current = !1, function() {
      t.current = !0;
    };
  }, []), t;
};
const wi = tr;
const yn = 10;
function nr(t, e) {
  return t > e && t > yn ? "horizontal" : e > t && e > yn ? "vertical" : "";
}
function ir() {
  const t = T(0), e = T(0), n = T(0), i = T(0), s = T(0), r = T(0), o = T(""), a = () => o.current === "vertical", c = () => o.current === "horizontal", l = () => {
    n.current = 0, i.current = 0, s.current = 0, r.current = 0, o.current = "";
  };
  return {
    move: (f) => {
      const m = f.touches[0];
      n.current = m.clientX < 0 ? 0 : m.clientX - t.current, i.current = m.clientY - e.current, s.current = Math.abs(n.current), r.current = Math.abs(i.current), o.current || (o.current = nr(s.current, r.current));
    },
    start: (f) => {
      l(), t.current = f.touches[0].clientX, e.current = f.touches[0].clientY;
    },
    reset: l,
    startX: t,
    startY: e,
    deltaX: n,
    deltaY: i,
    offsetX: s,
    offsetY: r,
    direction: o,
    isVertical: a,
    isHorizontal: c
  };
}
const Gt = !!(typeof window < "u" && typeof document < "u" && window.document && window.document.createElement), sr = Gt ? window : void 0, rr = ["scroll", "auto", "overlay"];
function or(t) {
  return t.nodeType === 1;
}
function ar(t, e = sr) {
  let n = t;
  for (; n && n !== e && or(n); ) {
    if (n === document.body)
      return e;
    const {
      overflowY: i
    } = window.getComputedStyle(n);
    if (rr.includes(i) && n.scrollHeight > n.clientHeight)
      return n;
    n = n.parentNode;
  }
  return e;
}
let Ze = !1;
if (Gt)
  try {
    const t = {};
    Object.defineProperty(t, "passive", {
      get() {
        Ze = !0;
      }
    }), window.addEventListener("test-passive", null, t);
  } catch {
  }
let we = 0;
const bn = "adm-overflow-hidden";
function cr(t) {
  let e = t == null ? void 0 : t.parentElement;
  for (; e; ) {
    if (e.clientHeight < e.scrollHeight)
      return e;
    e = e.parentElement;
  }
  return null;
}
function xi(t, e) {
  const n = ir(), i = (o) => {
    n.move(o);
    const a = n.deltaY.current > 0 ? "10" : "01", c = ar(o.target, t.current);
    if (!c)
      return;
    if (e === "strict") {
      const y = cr(o.target);
      if (y === document.body || y === document.documentElement) {
        o.preventDefault();
        return;
      }
    }
    const {
      scrollHeight: l,
      offsetHeight: u,
      scrollTop: d
    } = c, {
      height: f
    } = c.getBoundingClientRect();
    let m = "11";
    d === 0 ? m = u >= l ? "00" : "01" : l <= Math.round(f + d) && (m = "10"), m !== "11" && n.isVertical() && !(parseInt(m, 2) & parseInt(a, 2)) && o.cancelable && Ze && o.preventDefault();
  }, s = () => {
    document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", i, Ze ? {
      passive: !1
    } : !1), we || document.body.classList.add(bn), we++;
  }, r = () => {
    we && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", i), we--, we || document.body.classList.remove(bn));
  };
  M(() => {
    if (e)
      return s(), () => {
        r();
      };
  }, [e]);
}
let Yt = qe();
const E = (t) => Be(t, Yt);
let Xt = qe();
E.write = (t) => Be(t, Xt);
let ct = qe();
E.onStart = (t) => Be(t, ct);
let Zt = qe();
E.onFrame = (t) => Be(t, Zt);
let Jt = qe();
E.onFinish = (t) => Be(t, Jt);
let pe = [];
E.setTimeout = (t, e) => {
  let n = E.now() + e, i = () => {
    let r = pe.findIndex((o) => o.cancel == i);
    ~r && pe.splice(r, 1), re -= ~r ? 1 : 0;
  }, s = {
    time: n,
    handler: t,
    cancel: i
  };
  return pe.splice(Si(n), 0, s), re += 1, Ei(), s;
};
let Si = (t) => ~(~pe.findIndex((e) => e.time > t) || ~pe.length);
E.cancel = (t) => {
  ct.delete(t), Zt.delete(t), Jt.delete(t), Yt.delete(t), Xt.delete(t);
};
E.sync = (t) => {
  Rt = !0, E.batchedUpdates(t), Rt = !1;
};
E.throttle = (t) => {
  let e;
  function n() {
    try {
      t(...e);
    } finally {
      e = null;
    }
  }
  function i(...s) {
    e = s, E.onStart(n);
  }
  return i.handler = t, i.cancel = () => {
    ct.delete(n), e = null;
  }, i;
};
let en = typeof window < "u" ? window.requestAnimationFrame : () => {
};
E.use = (t) => en = t;
E.now = typeof performance < "u" ? () => performance.now() : Date.now;
E.batchedUpdates = (t) => t();
E.catch = console.error;
E.frameLoop = "always";
E.advance = () => {
  E.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : Ci();
};
let se = -1, re = 0, Rt = !1;
function Be(t, e) {
  Rt ? (e.delete(t), t(0)) : (e.add(t), Ei());
}
function Ei() {
  se < 0 && (se = 0, E.frameLoop !== "demand" && en(Oi));
}
function ur() {
  se = -1;
}
function Oi() {
  ~se && (en(Oi), E.batchedUpdates(Ci));
}
function Ci() {
  let t = se;
  se = E.now();
  let e = Si(se);
  if (e && (ki(pe.splice(0, e), (n) => n.handler()), re -= e), !re) {
    ur();
    return;
  }
  ct.flush(), Yt.flush(t ? Math.min(64, se - t) : 16.667), Zt.flush(), Xt.flush(), Jt.flush();
}
function qe() {
  let t = /* @__PURE__ */ new Set(), e = t;
  return {
    add(n) {
      re += e == t && !t.has(n) ? 1 : 0, t.add(n);
    },
    delete(n) {
      return re -= e == t && t.has(n) ? 1 : 0, t.delete(n);
    },
    flush(n) {
      e.size && (t = /* @__PURE__ */ new Set(), re -= e.size, ki(e, (i) => i(n) && t.add(i)), re += t.size, e = t);
    }
  };
}
function ki(t, e) {
  t.forEach((n) => {
    try {
      e(n);
    } catch (i) {
      E.catch(i);
    }
  });
}
function $t() {
}
const lr = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: !0,
  configurable: !0
}), p = {
  arr: Array.isArray,
  obj: (t) => !!t && t.constructor.name === "Object",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  und: (t) => t === void 0
};
function Z(t, e) {
  if (p.arr(t)) {
    if (!p.arr(e) || t.length !== e.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (t[n] !== e[n])
        return !1;
    return !0;
  }
  return t === e;
}
const O = (t, e) => t.forEach(e);
function G(t, e, n) {
  if (p.arr(t)) {
    for (let i = 0; i < t.length; i++)
      e.call(n, t[i], `${i}`);
    return;
  }
  for (const i in t)
    t.hasOwnProperty(i) && e.call(n, t[i], i);
}
const F = (t) => p.und(t) ? [] : p.arr(t) ? t : [t];
function ke(t, e) {
  if (t.size) {
    const n = Array.from(t);
    t.clear(), O(n, e);
  }
}
const Oe = (t, ...e) => ke(t, (n) => n(...e)), tn = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
let nn, Pi, oe = null, Ti = !1, sn = $t;
const fr = (t) => {
  t.to && (Pi = t.to), t.now && (E.now = t.now), t.colors !== void 0 && (oe = t.colors), t.skipAnimation != null && (Ti = t.skipAnimation), t.createStringInterpolator && (nn = t.createStringInterpolator), t.requestAnimationFrame && E.use(t.requestAnimationFrame), t.batchedUpdates && (E.batchedUpdates = t.batchedUpdates), t.willAdvance && (sn = t.willAdvance), t.frameLoop && (E.frameLoop = t.frameLoop);
};
var Y = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return nn;
  },
  get to() {
    return Pi;
  },
  get colors() {
    return oe;
  },
  get skipAnimation() {
    return Ti;
  },
  get willAdvance() {
    return sn;
  },
  assign: fr
});
const Pe = /* @__PURE__ */ new Set();
let W = [], wt = [], Je = 0;
const ut = {
  get idle() {
    return !Pe.size && !W.length;
  },
  start(t) {
    Je > t.priority ? (Pe.add(t), E.onStart(dr)) : (Ii(t), E(Dt));
  },
  advance: Dt,
  sort(t) {
    if (Je)
      E.onFrame(() => ut.sort(t));
    else {
      const e = W.indexOf(t);
      ~e && (W.splice(e, 1), Ai(t));
    }
  },
  clear() {
    W = [], Pe.clear();
  }
};
function dr() {
  Pe.forEach(Ii), Pe.clear(), E(Dt);
}
function Ii(t) {
  W.includes(t) || Ai(t);
}
function Ai(t) {
  W.splice(hr(W, (e) => e.priority > t.priority), 0, t);
}
function Dt(t) {
  const e = wt;
  for (let n = 0; n < W.length; n++) {
    const i = W[n];
    Je = i.priority, i.idle || (sn(i), i.advance(t), i.idle || e.push(i));
  }
  return Je = 0, wt = W, wt.length = 0, W = e, W.length > 0;
}
function hr(t, e) {
  const n = t.findIndex(e);
  return n < 0 ? t.length : n;
}
const pr = (t, e, n) => Math.min(Math.max(n, t), e), mr = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, K = "[-+]?\\d*\\.?\\d+", et = K + "%";
function lt(...t) {
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const gr = new RegExp("rgb" + lt(K, K, K)), vr = new RegExp("rgba" + lt(K, K, K, K)), yr = new RegExp("hsl" + lt(K, et, et)), br = new RegExp("hsla" + lt(K, et, et, K)), _r = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, wr = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, xr = /^#([0-9a-fA-F]{6})$/, Sr = /^#([0-9a-fA-F]{8})$/;
function Er(t) {
  let e;
  return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = xr.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : oe && oe[t] !== void 0 ? oe[t] : (e = gr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | 255) >>> 0 : (e = vr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | xn(e[4])) >>> 0 : (e = _r.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = Sr.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = wr.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = yr.exec(t)) ? (_n(wn(e[1]), ze(e[2]), ze(e[3])) | 255) >>> 0 : (e = br.exec(t)) ? (_n(wn(e[1]), ze(e[2]), ze(e[3])) | xn(e[4])) >>> 0 : null;
}
function xt(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function _n(t, e, n) {
  const i = n < 0.5 ? n * (1 + e) : n + e - n * e, s = 2 * n - i, r = xt(s, i, t + 1 / 3), o = xt(s, i, t), a = xt(s, i, t - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(o * 255) << 16 | Math.round(a * 255) << 8;
}
function fe(t) {
  const e = parseInt(t, 10);
  return e < 0 ? 0 : e > 255 ? 255 : e;
}
function wn(t) {
  return (parseFloat(t) % 360 + 360) % 360 / 360;
}
function xn(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255);
}
function ze(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 100 ? 1 : e / 100;
}
function Sn(t) {
  let e = Er(t);
  if (e === null)
    return t;
  e = e || 0;
  let n = (e & 4278190080) >>> 24, i = (e & 16711680) >>> 16, s = (e & 65280) >>> 8, r = (e & 255) / 255;
  return `rgba(${n}, ${i}, ${s}, ${r})`;
}
const Re = (t, e, n) => {
  if (p.fun(t))
    return t;
  if (p.arr(t))
    return Re({
      range: t,
      output: e,
      extrapolate: n
    });
  if (p.str(t.output[0]))
    return nn(t);
  const i = t, s = i.output, r = i.range || [0, 1], o = i.extrapolateLeft || i.extrapolate || "extend", a = i.extrapolateRight || i.extrapolate || "extend", c = i.easing || ((l) => l);
  return (l) => {
    const u = Cr(l, r);
    return Or(l, r[u], r[u + 1], s[u], s[u + 1], c, o, a, i.map);
  };
};
function Or(t, e, n, i, s, r, o, a, c) {
  let l = c ? c(t) : t;
  if (l < e) {
    if (o === "identity")
      return l;
    o === "clamp" && (l = e);
  }
  if (l > n) {
    if (a === "identity")
      return l;
    a === "clamp" && (l = n);
  }
  return i === s ? i : e === n ? t <= e ? i : s : (e === -1 / 0 ? l = -l : n === 1 / 0 ? l = l - e : l = (l - e) / (n - e), l = r(l), i === -1 / 0 ? l = -l : s === 1 / 0 ? l = l + i : l = l * (s - i) + i, l);
}
function Cr(t, e) {
  for (var n = 1; n < e.length - 1 && !(e[n] >= t); ++n)
    ;
  return n - 1;
}
const kr = (t, e = "end") => (n) => {
  n = e === "end" ? Math.min(n, 0.999) : Math.max(n, 1e-3);
  const i = n * t, s = e === "end" ? Math.floor(i) : Math.ceil(i);
  return pr(0, 1, s / t);
}, tt = 1.70158, Ke = tt * 1.525, En = tt + 1, On = 2 * Math.PI / 3, Cn = 2 * Math.PI / 4.5, He = (t) => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, Pr = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  easeInBack: (t) => En * t * t * t - tt * t * t,
  easeOutBack: (t) => 1 + En * Math.pow(t - 1, 3) + tt * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((Ke + 1) * 2 * t - Ke) / 2 : (Math.pow(2 * t - 2, 2) * ((Ke + 1) * (t * 2 - 2) + Ke) + 2) / 2,
  easeInElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * On),
  easeOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * On) + 1,
  easeInOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * Cn)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * Cn) / 2 + 1,
  easeInBounce: (t) => 1 - He(1 - t),
  easeOutBounce: He,
  easeInOutBounce: (t) => t < 0.5 ? (1 - He(1 - 2 * t)) / 2 : (1 + He(2 * t - 1)) / 2,
  steps: kr
};
function Mt() {
  return Mt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Mt.apply(this, arguments);
}
const ge = Symbol.for("FluidValue.get"), ue = Symbol.for("FluidValue.observers"), B = (t) => !!(t && t[ge]), V = (t) => t && t[ge] ? t[ge]() : t, kn = (t) => t[ue] || null;
function Tr(t, e) {
  t.eventObserved ? t.eventObserved(e) : t(e);
}
function $e(t, e) {
  let n = t[ue];
  n && n.forEach((i) => {
    Tr(i, e);
  });
}
class Ri {
  constructor(e) {
    if (this[ge] = void 0, this[ue] = void 0, !e && !(e = this.get))
      throw Error("Unknown getter");
    Ir(this, e);
  }
}
const Ir = (t, e) => $i(t, ge, e);
function ye(t, e) {
  if (t[ge]) {
    let n = t[ue];
    n || $i(t, ue, n = /* @__PURE__ */ new Set()), n.has(e) || (n.add(e), t.observerAdded && t.observerAdded(n.size, e));
  }
  return e;
}
function De(t, e) {
  let n = t[ue];
  if (n && n.has(e)) {
    const i = n.size - 1;
    i ? n.delete(e) : t[ue] = null, t.observerRemoved && t.observerRemoved(i, e);
  }
}
const $i = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: !0,
  configurable: !0
}), Ge = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Ar = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Pn = new RegExp(`(${Ge.source})(%|[a-z]+)`, "i"), Rr = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, ft = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, Di = (t) => {
  const [e, n] = $r(t);
  if (!e || tn())
    return t;
  const i = window.getComputedStyle(document.documentElement).getPropertyValue(e);
  if (i)
    return i.trim();
  if (n && n.startsWith("--")) {
    const s = window.getComputedStyle(document.documentElement).getPropertyValue(n);
    return s || t;
  } else {
    if (n && ft.test(n))
      return Di(n);
    if (n)
      return n;
  }
  return t;
}, $r = (t) => {
  const e = ft.exec(t);
  if (!e)
    return [,];
  const [, n, i] = e;
  return [n, i];
};
let St;
const Dr = (t, e, n, i, s) => `rgba(${Math.round(e)}, ${Math.round(n)}, ${Math.round(i)}, ${s})`, Mi = (t) => {
  St || (St = oe ? new RegExp(`(${Object.keys(oe).join("|")})(?!\\w)`, "g") : /^\b$/);
  const e = t.output.map((r) => V(r).replace(ft, Di).replace(Ar, Sn).replace(St, Sn)), n = e.map((r) => r.match(Ge).map(Number)), s = n[0].map((r, o) => n.map((a) => {
    if (!(o in a))
      throw Error('The arity of each "output" value must be equal');
    return a[o];
  })).map((r) => Re(Mt({}, t, {
    output: r
  })));
  return (r) => {
    var o;
    const a = !Pn.test(e[0]) && ((o = e.find((l) => Pn.test(l))) == null ? void 0 : o.replace(Ge, ""));
    let c = 0;
    return e[0].replace(Ge, () => `${s[c++](r)}${a || ""}`).replace(Rr, Dr);
  };
}, rn = "react-spring: ", Ni = (t) => {
  const e = t;
  let n = !1;
  if (typeof e != "function")
    throw new TypeError(`${rn}once requires a function parameter`);
  return (...i) => {
    n || (e(...i), n = !0);
  };
}, Mr = Ni(console.warn);
function Nr() {
  Mr(`${rn}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
const Lr = Ni(console.warn);
function Vr() {
  Lr(`${rn}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function dt(t) {
  return p.str(t) && (t[0] == "#" || /\d/.test(t) || !tn() && ft.test(t) || t in (oe || {}));
}
const on = tn() ? M : gi, jr = () => {
  const t = T(!1);
  return on(() => (t.current = !0, () => {
    t.current = !1;
  }), []), t;
};
function Li() {
  const t = J()[1], e = jr();
  return () => {
    e.current && t(Math.random());
  };
}
function Fr(t, e) {
  const [n] = J(() => ({
    inputs: e,
    result: t()
  })), i = T(), s = i.current;
  let r = s;
  return r ? e && r.inputs && Ur(e, r.inputs) || (r = {
    inputs: e,
    result: t()
  }) : r = n, M(() => {
    i.current = r, s == n && (n.inputs = n.result = void 0);
  }, [r]), r.result;
}
function Ur(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
const Vi = (t) => M(t, Br), Br = [];
function Tn(t) {
  const e = T();
  return M(() => {
    e.current = t;
  }), e.current;
}
const Me = Symbol.for("Animated:node"), qr = (t) => !!t && t[Me] === t, Q = (t) => t && t[Me], an = (t, e) => lr(t, Me, e), ht = (t) => t && t[Me] && t[Me].getPayload();
class ji {
  constructor() {
    this.payload = void 0, an(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
}
class be extends ji {
  constructor(e) {
    super(), this.done = !0, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e, p.num(this._value) && (this.lastPosition = this._value);
  }
  static create(e) {
    return new be(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, n) {
    return p.num(e) && (this.lastPosition = e, n && (e = Math.round(e / n) * n, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0);
  }
  reset() {
    const {
      done: e
    } = this;
    this.done = !1, p.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
}
class ve extends be {
  constructor(e) {
    super(0), this._string = null, this._toString = void 0, this._toString = Re({
      output: [e, e]
    });
  }
  static create(e) {
    return new ve(e);
  }
  getValue() {
    let e = this._string;
    return e ?? (this._string = this._toString(this._value));
  }
  setValue(e) {
    if (p.str(e)) {
      if (e == this._string)
        return !1;
      this._string = e, this._value = 1;
    } else if (super.setValue(e))
      this._string = null;
    else
      return !1;
    return !0;
  }
  reset(e) {
    e && (this._toString = Re({
      output: [this.getValue(), e]
    })), this._value = 0, super.reset();
  }
}
const nt = {
  dependencies: null
};
class pt extends ji {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    const n = {};
    return G(this.source, (i, s) => {
      qr(i) ? n[s] = i.getValue(e) : B(i) ? n[s] = V(i) : e || (n[s] = i);
    }), n;
  }
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && O(this.payload, (e) => e.reset());
  }
  _makePayload(e) {
    if (e) {
      const n = /* @__PURE__ */ new Set();
      return G(e, this._addToPayload, n), Array.from(n);
    }
  }
  _addToPayload(e) {
    nt.dependencies && B(e) && nt.dependencies.add(e);
    const n = ht(e);
    n && O(n, (i) => this.add(i));
  }
}
class cn extends pt {
  constructor(e) {
    super(e);
  }
  static create(e) {
    return new cn(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    const n = this.getPayload();
    return e.length == n.length ? n.map((i, s) => i.setValue(e[s])).some(Boolean) : (super.setValue(e.map(Wr)), !0);
  }
}
function Wr(t) {
  return (dt(t) ? ve : be).create(t);
}
function Nt(t) {
  const e = Q(t);
  return e ? e.constructor : p.arr(t) ? cn : dt(t) ? ve : be;
}
function Lt() {
  return Lt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Lt.apply(this, arguments);
}
const In = (t, e) => {
  const n = !p.fun(t) || t.prototype && t.prototype.isReactComponent;
  return vi((i, s) => {
    const r = T(null), o = n && yi((y) => {
      r.current = Hr(s, y);
    }, [s]), [a, c] = Kr(i, e), l = Li(), u = () => {
      const y = r.current;
      if (n && !y)
        return;
      (y ? e.applyAnimatedValues(y, a.getValue(!0)) : !1) === !1 && l();
    }, d = new zr(u, c), f = T();
    on(() => (f.current = d, O(c, (y) => ye(y, d)), () => {
      f.current && (O(f.current.deps, (y) => De(y, f.current)), E.cancel(f.current.update));
    })), M(u, []), Vi(() => () => {
      const y = f.current;
      O(y.deps, (w) => De(w, y));
    });
    const m = e.getComponentProps(a.getValue());
    return /* @__PURE__ */ C(t, {
      ...m,
      ref: o
    });
  });
};
class zr {
  constructor(e, n) {
    this.update = e, this.deps = n;
  }
  eventObserved(e) {
    e.type == "change" && E.write(this.update);
  }
}
function Kr(t, e) {
  const n = /* @__PURE__ */ new Set();
  return nt.dependencies = n, t.style && (t = Lt({}, t, {
    style: e.createAnimatedStyle(t.style)
  })), t = new pt(t), nt.dependencies = null, [t, n];
}
function Hr(t, e) {
  return t && (p.fun(t) ? t(e) : t.current = e), e;
}
const An = Symbol.for("AnimatedComponent"), Qr = (t, {
  applyAnimatedValues: e = () => !1,
  createAnimatedStyle: n = (s) => new pt(s),
  getComponentProps: i = (s) => s
} = {}) => {
  const s = {
    applyAnimatedValues: e,
    createAnimatedStyle: n,
    getComponentProps: i
  }, r = (o) => {
    const a = Rn(o) || "Anonymous";
    return p.str(o) ? o = r[o] || (r[o] = In(o, s)) : o = o[An] || (o[An] = In(o, s)), o.displayName = `Animated(${a})`, o;
  };
  return G(t, (o, a) => {
    p.arr(t) && (a = Rn(o)), r[a] = r(o);
  }), {
    animated: r
  };
}, Rn = (t) => p.str(t) ? t : t && p.str(t.displayName) ? t.displayName : p.fun(t) && t.name || null;
function $() {
  return $ = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, $.apply(this, arguments);
}
function ae(t, ...e) {
  return p.fun(t) ? t(...e) : t;
}
const Te = (t, e) => t === !0 || !!(e && t && (p.fun(t) ? t(e) : F(t).includes(e))), Fi = (t, e) => p.obj(t) ? e && t[e] : t, Ui = (t, e) => t.default === !0 ? t[e] : t.default ? t.default[e] : void 0, Gr = (t) => t, un = (t, e = Gr) => {
  let n = Yr;
  t.default && t.default !== !0 && (t = t.default, n = Object.keys(t));
  const i = {};
  for (const s of n) {
    const r = e(t[s], s);
    p.und(r) || (i[s] = r);
  }
  return i;
}, Yr = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"], Xr = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function Zr(t) {
  const e = {};
  let n = 0;
  if (G(t, (i, s) => {
    Xr[s] || (e[s] = i, n++);
  }), n)
    return e;
}
function Bi(t) {
  const e = Zr(t);
  if (e) {
    const n = {
      to: e
    };
    return G(t, (i, s) => s in e || (n[s] = i)), n;
  }
  return $({}, t);
}
function Ne(t) {
  return t = V(t), p.arr(t) ? t.map(Ne) : dt(t) ? Y.createStringInterpolator({
    range: [0, 1],
    output: [t, t]
  })(1) : t;
}
function Jr(t) {
  for (const e in t)
    return !0;
  return !1;
}
function Vt(t) {
  return p.fun(t) || p.arr(t) && p.obj(t[0]);
}
function eo(t, e) {
  var n;
  (n = t.ref) == null || n.delete(t), e == null || e.delete(t);
}
function to(t, e) {
  if (e && t.ref !== e) {
    var n;
    (n = t.ref) == null || n.delete(t), e.add(t), t.ref = e;
  }
}
const no = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
}, jt = $({}, no.default, {
  mass: 1,
  damping: 1,
  easing: Pr.linear,
  clamp: !1
});
class io {
  constructor() {
    this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, jt);
  }
}
function so(t, e, n) {
  n && (n = $({}, n), $n(n, e), e = $({}, n, e)), $n(t, e), Object.assign(t, e);
  for (const o in jt)
    t[o] == null && (t[o] = jt[o]);
  let {
    mass: i,
    frequency: s,
    damping: r
  } = t;
  return p.und(s) || (s < 0.01 && (s = 0.01), r < 0 && (r = 0), t.tension = Math.pow(2 * Math.PI / s, 2) * i, t.friction = 4 * Math.PI * r * i / s), t;
}
function $n(t, e) {
  if (!p.und(e.decay))
    t.duration = void 0;
  else {
    const n = !p.und(e.tension) || !p.und(e.friction);
    (n || !p.und(e.frequency) || !p.und(e.damping) || !p.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0);
  }
}
const Dn = [];
class ro {
  constructor() {
    this.changed = !1, this.values = Dn, this.toValues = null, this.fromValues = Dn, this.to = void 0, this.from = void 0, this.config = new io(), this.immediate = !1;
  }
}
function qi(t, {
  key: e,
  props: n,
  defaultProps: i,
  state: s,
  actions: r
}) {
  return new Promise((o, a) => {
    var c;
    let l, u, d = Te((c = n.cancel) != null ? c : i == null ? void 0 : i.cancel, e);
    if (d)
      y();
    else {
      p.und(n.pause) || (s.paused = Te(n.pause, e));
      let w = i == null ? void 0 : i.pause;
      w !== !0 && (w = s.paused || Te(w, e)), l = ae(n.delay || 0, e), w ? (s.resumeQueue.add(m), r.pause()) : (r.resume(), m());
    }
    function f() {
      s.resumeQueue.add(m), s.timeouts.delete(u), u.cancel(), l = u.time - E.now();
    }
    function m() {
      l > 0 && !Y.skipAnimation ? (s.delayed = !0, u = E.setTimeout(y, l), s.pauseQueue.add(f), s.timeouts.add(u)) : y();
    }
    function y() {
      s.delayed && (s.delayed = !1), s.pauseQueue.delete(f), s.timeouts.delete(u), t <= (s.cancelId || 0) && (d = !0);
      try {
        r.start($({}, n, {
          callId: t,
          cancel: d
        }), o);
      } catch (w) {
        a(w);
      }
    }
  });
}
const ln = (t, e) => e.length == 1 ? e[0] : e.some((n) => n.cancelled) ? me(t.get()) : e.every((n) => n.noop) ? Wi(t.get()) : z(t.get(), e.every((n) => n.finished)), Wi = (t) => ({
  value: t,
  noop: !0,
  finished: !0,
  cancelled: !1
}), z = (t, e, n = !1) => ({
  value: t,
  finished: e,
  cancelled: n
}), me = (t) => ({
  value: t,
  cancelled: !0,
  finished: !1
});
function zi(t, e, n, i) {
  const {
    callId: s,
    parentId: r,
    onRest: o
  } = e, {
    asyncTo: a,
    promise: c
  } = n;
  return !r && t === a && !e.reset ? c : n.promise = (async () => {
    n.asyncId = s, n.asyncTo = t;
    const l = un(e, (v, h) => h === "onRest" ? void 0 : v);
    let u, d;
    const f = new Promise((v, h) => (u = v, d = h)), m = (v) => {
      const h = s <= (n.cancelId || 0) && me(i) || s !== n.asyncId && z(i, !1);
      if (h)
        throw v.result = h, d(v), v;
    }, y = (v, h) => {
      const _ = new Mn(), b = new Nn();
      return (async () => {
        if (Y.skipAnimation)
          throw Le(n), b.result = z(i, !1), d(b), b;
        m(_);
        const g = p.obj(v) ? $({}, v) : $({}, h, {
          to: v
        });
        g.parentId = s, G(l, (x, k) => {
          p.und(g[k]) && (g[k] = x);
        });
        const S = await i.start(g);
        return m(_), n.paused && await new Promise((x) => {
          n.resumeQueue.add(x);
        }), S;
      })();
    };
    let w;
    if (Y.skipAnimation)
      return Le(n), z(i, !1);
    try {
      let v;
      p.arr(t) ? v = (async (h) => {
        for (const _ of h)
          await y(_);
      })(t) : v = Promise.resolve(t(y, i.stop.bind(i))), await Promise.all([v.then(u), f]), w = z(i.get(), !0, !1);
    } catch (v) {
      if (v instanceof Mn)
        w = v.result;
      else if (v instanceof Nn)
        w = v.result;
      else
        throw v;
    } finally {
      s == n.asyncId && (n.asyncId = r, n.asyncTo = r ? a : void 0, n.promise = r ? c : void 0);
    }
    return p.fun(o) && E.batchedUpdates(() => {
      o(w, i, i.item);
    }), w;
  })();
}
function Le(t, e) {
  ke(t.timeouts, (n) => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e);
}
class Mn extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0;
  }
}
class Nn extends Error {
  constructor() {
    super("SkipAnimationSignal"), this.result = void 0;
  }
}
const Ft = (t) => t instanceof fn;
let oo = 1;
class fn extends Ri {
  constructor(...e) {
    super(...e), this.id = oo++, this.key = void 0, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  get() {
    const e = Q(this);
    return e && e.getValue();
  }
  to(...e) {
    return Y.to(this, e);
  }
  interpolate(...e) {
    return Nr(), Y.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(e, n = !1) {
    $e(this, {
      type: "change",
      parent: this,
      value: e,
      idle: n
    });
  }
  _onPriorityChange(e) {
    this.idle || ut.sort(this), $e(this, {
      type: "priority",
      parent: this,
      priority: e
    });
  }
}
const le = Symbol.for("SpringPhase"), Ki = 1, Ut = 2, Bt = 4, Et = (t) => (t[le] & Ki) > 0, te = (t) => (t[le] & Ut) > 0, xe = (t) => (t[le] & Bt) > 0, Ln = (t, e) => e ? t[le] |= Ut | Ki : t[le] &= ~Ut, Vn = (t, e) => e ? t[le] |= Bt : t[le] &= ~Bt;
class ao extends fn {
  constructor(e, n) {
    if (super(), this.key = void 0, this.animation = new ro(), this.queue = void 0, this.defaultProps = {}, this._state = {
      paused: !1,
      delayed: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !p.und(e) || !p.und(n)) {
      const i = p.obj(e) ? $({}, e) : $({}, n, {
        from: e
      });
      p.und(i.default) && (i.default = !0), this.start(i);
    }
  }
  get idle() {
    return !(te(this) || this._state.asyncTo) || xe(this);
  }
  get goal() {
    return V(this.animation.to);
  }
  get velocity() {
    const e = Q(this);
    return e instanceof be ? e.lastVelocity || 0 : e.getPayload().map((n) => n.lastVelocity || 0);
  }
  get hasAnimated() {
    return Et(this);
  }
  get isAnimating() {
    return te(this);
  }
  get isPaused() {
    return xe(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(e) {
    let n = !0, i = !1;
    const s = this.animation;
    let {
      config: r,
      toValues: o
    } = s;
    const a = ht(s.to);
    !a && B(s.to) && (o = F(V(s.to))), s.values.forEach((u, d) => {
      if (u.done)
        return;
      const f = u.constructor == ve ? 1 : a ? a[d].lastPosition : o[d];
      let m = s.immediate, y = f;
      if (!m) {
        if (y = u.lastPosition, r.tension <= 0) {
          u.done = !0;
          return;
        }
        let w = u.elapsedTime += e;
        const v = s.fromValues[d], h = u.v0 != null ? u.v0 : u.v0 = p.arr(r.velocity) ? r.velocity[d] : r.velocity;
        let _;
        const b = r.precision || (v == f ? 5e-3 : Math.min(1, Math.abs(f - v) * 1e-3));
        if (p.und(r.duration))
          if (r.decay) {
            const g = r.decay === !0 ? 0.998 : r.decay, S = Math.exp(-(1 - g) * w);
            y = v + h / (1 - g) * (1 - S), m = Math.abs(u.lastPosition - y) <= b, _ = h * S;
          } else {
            _ = u.lastVelocity == null ? h : u.lastVelocity;
            const g = r.restVelocity || b / 10, S = r.clamp ? 0 : r.bounce, x = !p.und(S), k = v == f ? u.v0 > 0 : v < f;
            let P, I = !1;
            const R = 1, X = Math.ceil(e / R);
            for (let U = 0; U < X && (P = Math.abs(_) > g, !(!P && (m = Math.abs(f - y) <= b, m))); ++U) {
              x && (I = y == f || y > f == k, I && (_ = -_ * S, y = f));
              const ee = -r.tension * 1e-6 * (y - f), bt = -r.friction * 1e-3 * _, bs = (ee + bt) / r.mass;
              _ = _ + bs * R, y = y + _ * R;
            }
          }
        else {
          let g = 1;
          r.duration > 0 && (this._memoizedDuration !== r.duration && (this._memoizedDuration = r.duration, u.durationProgress > 0 && (u.elapsedTime = r.duration * u.durationProgress, w = u.elapsedTime += e)), g = (r.progress || 0) + w / this._memoizedDuration, g = g > 1 ? 1 : g < 0 ? 0 : g, u.durationProgress = g), y = v + r.easing(g) * (f - v), _ = (y - u.lastPosition) / e, m = g == 1;
        }
        u.lastVelocity = _, Number.isNaN(y) && (console.warn("Got NaN while animating:", this), m = !0);
      }
      a && !a[d].done && (m = !1), m ? u.done = !0 : n = !1, u.setValue(y, r.round) && (i = !0);
    });
    const c = Q(this), l = c.getValue();
    if (n) {
      const u = V(s.to);
      (l !== u || i) && !r.decay ? (c.setValue(u), this._onChange(u)) : i && r.decay && this._onChange(l), this._stop();
    } else
      i && this._onChange(l);
  }
  set(e) {
    return E.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  pause() {
    this._update({
      pause: !0
    });
  }
  resume() {
    this._update({
      pause: !1
    });
  }
  finish() {
    if (te(this)) {
      const {
        to: e,
        config: n
      } = this.animation;
      E.batchedUpdates(() => {
        this._onStart(), n.decay || this._set(e, !1), this._stop();
      });
    }
    return this;
  }
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, n) {
    let i;
    return p.und(e) ? (i = this.queue || [], this.queue = []) : i = [p.obj(e) ? e : $({}, n, {
      to: e
    })], Promise.all(i.map((s) => this._update(s))).then((s) => ln(this, s));
  }
  stop(e) {
    const {
      to: n
    } = this.animation;
    return this._focus(this.get()), Le(this._state, e && this._lastCallId), E.batchedUpdates(() => this._stop(n, e)), this;
  }
  reset() {
    this._update({
      reset: !0
    });
  }
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  _prepareNode(e) {
    const n = this.key || "";
    let {
      to: i,
      from: s
    } = e;
    i = p.obj(i) ? i[n] : i, (i == null || Vt(i)) && (i = void 0), s = p.obj(s) ? s[n] : s, s == null && (s = void 0);
    const r = {
      to: i,
      from: s
    };
    return Et(this) || (e.reverse && ([i, s] = [s, i]), s = V(s), p.und(s) ? Q(this) || this._set(i) : this._set(s)), r;
  }
  _update(e, n) {
    let i = $({}, e);
    const {
      key: s,
      defaultProps: r
    } = this;
    i.default && Object.assign(r, un(i, (c, l) => /^on/.test(l) ? Fi(c, s) : c)), Fn(this, i, "onProps"), Ee(this, "onProps", i, this);
    const o = this._prepareNode(i);
    if (Object.isFrozen(this))
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    const a = this._state;
    return qi(++this._lastCallId, {
      key: s,
      props: i,
      defaultProps: r,
      state: a,
      actions: {
        pause: () => {
          xe(this) || (Vn(this, !0), Oe(a.pauseQueue), Ee(this, "onPause", z(this, Se(this, this.animation.to)), this));
        },
        resume: () => {
          xe(this) && (Vn(this, !1), te(this) && this._resume(), Oe(a.resumeQueue), Ee(this, "onResume", z(this, Se(this, this.animation.to)), this));
        },
        start: this._merge.bind(this, o)
      }
    }).then((c) => {
      if (i.loop && c.finished && !(n && c.noop)) {
        const l = Hi(i);
        if (l)
          return this._update(l, !0);
      }
      return c;
    });
  }
  _merge(e, n, i) {
    if (n.cancel)
      return this.stop(!0), i(me(this));
    const s = !p.und(e.to), r = !p.und(e.from);
    if (s || r)
      if (n.callId > this._lastToId)
        this._lastToId = n.callId;
      else
        return i(me(this));
    const {
      key: o,
      defaultProps: a,
      animation: c
    } = this, {
      to: l,
      from: u
    } = c;
    let {
      to: d = l,
      from: f = u
    } = e;
    r && !s && (!n.default || p.und(d)) && (d = f), n.reverse && ([d, f] = [f, d]);
    const m = !Z(f, u);
    m && (c.from = f), f = V(f);
    const y = !Z(d, l);
    y && this._focus(d);
    const w = Vt(n.to), {
      config: v
    } = c, {
      decay: h,
      velocity: _
    } = v;
    (s || r) && (v.velocity = 0), n.config && !w && so(v, ae(n.config, o), n.config !== a.config ? ae(a.config, o) : void 0);
    let b = Q(this);
    if (!b || p.und(d))
      return i(z(this, !0));
    const g = p.und(n.reset) ? r && !n.default : !p.und(f) && Te(n.reset, o), S = g ? f : this.get(), x = Ne(d), k = p.num(x) || p.arr(x) || dt(x), P = !w && (!k || Te(a.immediate || n.immediate, o));
    if (y) {
      const U = Nt(d);
      if (U !== b.constructor)
        if (P)
          b = this._set(x);
        else
          throw Error(`Cannot animate between ${b.constructor.name} and ${U.name}, as the "to" prop suggests`);
    }
    const I = b.constructor;
    let R = B(d), X = !1;
    if (!R) {
      const U = g || !Et(this) && m;
      (y || U) && (X = Z(Ne(S), x), R = !X), (!Z(c.immediate, P) && !P || !Z(v.decay, h) || !Z(v.velocity, _)) && (R = !0);
    }
    if (X && te(this) && (c.changed && !g ? R = !0 : R || this._stop(l)), !w && ((R || B(l)) && (c.values = b.getPayload(), c.toValues = B(d) ? null : I == ve ? [1] : F(x)), c.immediate != P && (c.immediate = P, !P && !g && this._set(l)), R)) {
      const {
        onRest: U
      } = c;
      O(uo, (bt) => Fn(this, n, bt));
      const ee = z(this, Se(this, l));
      Oe(this._pendingCalls, ee), this._pendingCalls.add(i), c.changed && E.batchedUpdates(() => {
        c.changed = !g, U == null || U(ee, this), g ? ae(a.onRest, ee) : c.onStart == null || c.onStart(ee, this);
      });
    }
    g && this._set(S), w ? i(zi(n.to, n, this._state, this)) : R ? this._start() : te(this) && !y ? this._pendingCalls.add(i) : i(Wi(S));
  }
  _focus(e) {
    const n = this.animation;
    e !== n.to && (kn(this) && this._detach(), n.to = e, kn(this) && this._attach());
  }
  _attach() {
    let e = 0;
    const {
      to: n
    } = this.animation;
    B(n) && (ye(n, this), Ft(n) && (e = n.priority + 1)), this.priority = e;
  }
  _detach() {
    const {
      to: e
    } = this.animation;
    B(e) && De(e, this);
  }
  _set(e, n = !0) {
    const i = V(e);
    if (!p.und(i)) {
      const s = Q(this);
      if (!s || !Z(i, s.getValue())) {
        const r = Nt(i);
        !s || s.constructor != r ? an(this, r.create(i)) : s.setValue(i), s && E.batchedUpdates(() => {
          this._onChange(i, n);
        });
      }
    }
    return Q(this);
  }
  _onStart() {
    const e = this.animation;
    e.changed || (e.changed = !0, Ee(this, "onStart", z(this, Se(this, e.to)), this));
  }
  _onChange(e, n) {
    n || (this._onStart(), ae(this.animation.onChange, e, this)), ae(this.defaultProps.onChange, e, this), super._onChange(e, n);
  }
  _start() {
    const e = this.animation;
    Q(this).reset(V(e.to)), e.immediate || (e.fromValues = e.values.map((n) => n.lastPosition)), te(this) || (Ln(this, !0), xe(this) || this._resume());
  }
  _resume() {
    Y.skipAnimation ? this.finish() : ut.start(this);
  }
  _stop(e, n) {
    if (te(this)) {
      Ln(this, !1);
      const i = this.animation;
      O(i.values, (r) => {
        r.done = !0;
      }), i.toValues && (i.onChange = i.onPause = i.onResume = void 0), $e(this, {
        type: "idle",
        parent: this
      });
      const s = n ? me(this.get()) : z(this.get(), Se(this, e ?? i.to));
      Oe(this._pendingCalls, s), i.changed && (i.changed = !1, Ee(this, "onRest", s, this));
    }
  }
}
function Se(t, e) {
  const n = Ne(e), i = Ne(t.get());
  return Z(i, n);
}
function Hi(t, e = t.loop, n = t.to) {
  let i = ae(e);
  if (i) {
    const s = i !== !0 && Bi(i), r = (s || t).reverse, o = !s || s.reset;
    return Ve($({}, t, {
      loop: e,
      default: !1,
      pause: void 0,
      to: !r || Vt(n) ? n : void 0,
      from: o ? t.from : void 0,
      reset: o
    }, s));
  }
}
function Ve(t) {
  const {
    to: e,
    from: n
  } = t = Bi(t), i = /* @__PURE__ */ new Set();
  return p.obj(e) && jn(e, i), p.obj(n) && jn(n, i), t.keys = i.size ? Array.from(i) : null, t;
}
function co(t) {
  const e = Ve(t);
  return p.und(e.default) && (e.default = un(e)), e;
}
function jn(t, e) {
  G(t, (n, i) => n != null && e.add(i));
}
const uo = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function Fn(t, e, n) {
  t.animation[n] = e[n] !== Ui(e, n) ? Fi(e[n], t.key) : void 0;
}
function Ee(t, e, ...n) {
  var i, s, r, o;
  (i = (s = t.animation)[e]) == null || i.call(s, ...n), (r = (o = t.defaultProps)[e]) == null || r.call(o, ...n);
}
const lo = ["onStart", "onChange", "onRest"];
let fo = 1, ho = class {
  constructor(e, n) {
    this.id = fo++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = !1, this._item = void 0, this._state = {
      paused: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    }, this._onFrame = this._onFrame.bind(this), n && (this._flush = n), e && this.start($({
      default: !0
    }, e));
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  get() {
    const e = {};
    return this.each((n, i) => e[i] = n.get()), e;
  }
  set(e) {
    for (const n in e) {
      const i = e[n];
      p.und(i) || this.springs[n].set(i);
    }
  }
  update(e) {
    return e && this.queue.push(Ve(e)), this;
  }
  start(e) {
    let {
      queue: n
    } = this;
    return e ? n = F(e).map(Ve) : this.queue = [], this._flush ? this._flush(this, n) : (Zi(this, n), qt(this, n));
  }
  stop(e, n) {
    if (e !== !!e && (n = e), n) {
      const i = this.springs;
      O(F(n), (s) => i[s].stop(!!e));
    } else
      Le(this._state, this._lastAsyncId), this.each((i) => i.stop(!!e));
    return this;
  }
  pause(e) {
    if (p.und(e))
      this.start({
        pause: !0
      });
    else {
      const n = this.springs;
      O(F(e), (i) => n[i].pause());
    }
    return this;
  }
  resume(e) {
    if (p.und(e))
      this.start({
        pause: !1
      });
    else {
      const n = this.springs;
      O(F(e), (i) => n[i].resume());
    }
    return this;
  }
  each(e) {
    G(this.springs, e);
  }
  _onFrame() {
    const {
      onStart: e,
      onChange: n,
      onRest: i
    } = this._events, s = this._active.size > 0, r = this._changed.size > 0;
    (s && !this._started || r && !this._started) && (this._started = !0, ke(e, ([c, l]) => {
      l.value = this.get(), c(l, this, this._item);
    }));
    const o = !s && this._started, a = r || o && i.size ? this.get() : null;
    r && n.size && ke(n, ([c, l]) => {
      l.value = a, c(l, this, this._item);
    }), o && (this._started = !1, ke(i, ([c, l]) => {
      l.value = a, c(l, this, this._item);
    }));
  }
  eventObserved(e) {
    if (e.type == "change")
      this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle")
      this._active.delete(e.parent);
    else
      return;
    E.onFrame(this._onFrame);
  }
};
function qt(t, e) {
  return Promise.all(e.map((n) => Qi(t, n))).then((n) => ln(t, n));
}
async function Qi(t, e, n) {
  const {
    keys: i,
    to: s,
    from: r,
    loop: o,
    onRest: a,
    onResolve: c
  } = e, l = p.obj(e.default) && e.default;
  o && (e.loop = !1), s === !1 && (e.to = null), r === !1 && (e.from = null);
  const u = p.arr(s) || p.fun(s) ? s : void 0;
  u ? (e.to = void 0, e.onRest = void 0, l && (l.onRest = void 0)) : O(lo, (w) => {
    const v = e[w];
    if (p.fun(v)) {
      const h = t._events[w];
      e[w] = ({
        finished: _,
        cancelled: b
      }) => {
        const g = h.get(v);
        g ? (_ || (g.finished = !1), b && (g.cancelled = !0)) : h.set(v, {
          value: null,
          finished: _ || !1,
          cancelled: b || !1
        });
      }, l && (l[w] = e[w]);
    }
  });
  const d = t._state;
  e.pause === !d.paused ? (d.paused = e.pause, Oe(e.pause ? d.pauseQueue : d.resumeQueue)) : d.paused && (e.pause = !0);
  const f = (i || Object.keys(t.springs)).map((w) => t.springs[w].start(e)), m = e.cancel === !0 || Ui(e, "cancel") === !0;
  (u || m && d.asyncId) && f.push(qi(++t._lastAsyncId, {
    props: e,
    state: d,
    actions: {
      pause: $t,
      resume: $t,
      start(w, v) {
        m ? (Le(d, t._lastAsyncId), v(me(t))) : (w.onRest = a, v(zi(u, w, d, t)));
      }
    }
  })), d.paused && await new Promise((w) => {
    d.resumeQueue.add(w);
  });
  const y = ln(t, await Promise.all(f));
  if (o && y.finished && !(n && y.noop)) {
    const w = Hi(e, o, s);
    if (w)
      return Zi(t, [w]), Qi(t, w, !0);
  }
  return c && E.batchedUpdates(() => c(y, t, t.item)), y;
}
function Un(t, e) {
  const n = $({}, t.springs);
  return e && O(F(e), (i) => {
    p.und(i.keys) && (i = Ve(i)), p.obj(i.to) || (i = $({}, i, {
      to: void 0
    })), Xi(n, i, (s) => Yi(s));
  }), Gi(t, n), n;
}
function Gi(t, e) {
  G(e, (n, i) => {
    t.springs[i] || (t.springs[i] = n, ye(n, t));
  });
}
function Yi(t, e) {
  const n = new ao();
  return n.key = t, e && ye(n, e), n;
}
function Xi(t, e, n) {
  e.keys && O(e.keys, (i) => {
    (t[i] || (t[i] = n(i)))._prepareNode(e);
  });
}
function Zi(t, e) {
  O(e, (n) => {
    Xi(t.springs, n, (i) => Yi(i, t));
  });
}
function po(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
const mo = ["children"], mt = (t) => {
  let {
    children: e
  } = t, n = po(t, mo);
  const i = Qt(it), s = n.pause || !!i.pause, r = n.immediate || !!i.immediate;
  n = Fr(() => ({
    pause: s,
    immediate: r
  }), [s, r]);
  const {
    Provider: o
  } = it;
  return /* @__PURE__ */ C(o, {
    value: n,
    children: e
  });
}, it = go(mt, {});
mt.Provider = it.Provider;
mt.Consumer = it.Consumer;
function go(t, e) {
  return Object.assign(t, Os.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t;
}
const vo = () => {
  const t = [], e = function(s) {
    Vr();
    const r = [];
    return O(t, (o, a) => {
      if (p.und(s))
        r.push(o.start());
      else {
        const c = n(s, o, a);
        c && r.push(o.start(c));
      }
    }), r;
  };
  e.current = t, e.add = function(i) {
    t.includes(i) || t.push(i);
  }, e.delete = function(i) {
    const s = t.indexOf(i);
    ~s && t.splice(s, 1);
  }, e.pause = function() {
    return O(t, (i) => i.pause(...arguments)), this;
  }, e.resume = function() {
    return O(t, (i) => i.resume(...arguments)), this;
  }, e.set = function(i) {
    O(t, (s) => s.set(i));
  }, e.start = function(i) {
    const s = [];
    return O(t, (r, o) => {
      if (p.und(i))
        s.push(r.start());
      else {
        const a = this._getProps(i, r, o);
        a && s.push(r.start(a));
      }
    }), s;
  }, e.stop = function() {
    return O(t, (i) => i.stop(...arguments)), this;
  }, e.update = function(i) {
    return O(t, (s, r) => s.update(this._getProps(i, s, r))), this;
  };
  const n = function(s, r, o) {
    return p.fun(s) ? s(o, r) : s;
  };
  return e._getProps = n, e;
};
function yo(t, e, n) {
  const i = p.fun(e) && e;
  i && !n && (n = []);
  const s = ce(() => i || arguments.length == 3 ? vo() : void 0, []), r = T(0), o = Li(), a = ce(() => ({
    ctrls: [],
    queue: [],
    flush(h, _) {
      const b = Un(h, _);
      return r.current > 0 && !a.queue.length && !Object.keys(b).some((S) => !h.springs[S]) ? qt(h, _) : new Promise((S) => {
        Gi(h, b), a.queue.push(() => {
          S(qt(h, _));
        }), o();
      });
    }
  }), []), c = T([...a.ctrls]), l = [], u = Tn(t) || 0;
  ce(() => {
    O(c.current.slice(t, u), (h) => {
      eo(h, s), h.stop(!0);
    }), c.current.length = t, d(u, t);
  }, [t]), ce(() => {
    d(0, Math.min(u, t));
  }, n);
  function d(h, _) {
    for (let b = h; b < _; b++) {
      const g = c.current[b] || (c.current[b] = new ho(null, a.flush)), S = i ? i(b, g) : e[b];
      S && (l[b] = co(S));
    }
  }
  const f = c.current.map((h, _) => Un(h, l[_])), m = Qt(mt), y = Tn(m), w = m !== y && Jr(m);
  on(() => {
    r.current++, a.ctrls = c.current;
    const {
      queue: h
    } = a;
    h.length && (a.queue = [], O(h, (_) => _())), O(c.current, (_, b) => {
      s == null || s.add(_), w && _.start({
        default: m
      });
      const g = l[b];
      g && (to(_, g.ref), _.ref ? _.queue.push(g) : _.start(g));
    });
  }), Vi(() => () => {
    O(a.ctrls, (h) => h.stop(!0));
  });
  const v = f.map((h) => $({}, h));
  return s ? [v, s] : v;
}
function gt(t, e) {
  const n = p.fun(t), [[i], s] = yo(1, n ? t : [t], n ? e || [] : e);
  return n || arguments.length == 2 ? [i, s] : i;
}
let Bn;
(function(t) {
  t.MOUNT = "mount", t.ENTER = "enter", t.UPDATE = "update", t.LEAVE = "leave";
})(Bn || (Bn = {}));
class bo extends fn {
  constructor(e, n) {
    super(), this.key = void 0, this.idle = !0, this.calc = void 0, this._active = /* @__PURE__ */ new Set(), this.source = e, this.calc = Re(...n);
    const i = this._get(), s = Nt(i);
    an(this, s.create(i));
  }
  advance(e) {
    const n = this._get(), i = this.get();
    Z(n, i) || (Q(this).setValue(n), this._onChange(n, this.idle)), !this.idle && qn(this._active) && Ot(this);
  }
  _get() {
    const e = p.arr(this.source) ? this.source.map(V) : F(V(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !qn(this._active) && (this.idle = !1, O(ht(this), (e) => {
      e.done = !1;
    }), Y.skipAnimation ? (E.batchedUpdates(() => this.advance()), Ot(this)) : ut.start(this));
  }
  _attach() {
    let e = 1;
    O(F(this.source), (n) => {
      B(n) && ye(n, this), Ft(n) && (n.idle || this._active.add(n), e = Math.max(e, n.priority + 1));
    }), this.priority = e, this._start();
  }
  _detach() {
    O(F(this.source), (e) => {
      B(e) && De(e, this);
    }), this._active.clear(), Ot(this);
  }
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = F(this.source).reduce((n, i) => Math.max(n, (Ft(i) ? i.priority : 0) + 1), 0));
  }
}
function _o(t) {
  return t.idle !== !1;
}
function qn(t) {
  return !t.size || Array.from(t).every(_o);
}
function Ot(t) {
  t.idle || (t.idle = !0, O(ht(t), (e) => {
    e.done = !0;
  }), $e(t, {
    type: "idle",
    parent: t
  }));
}
Y.assign({
  createStringInterpolator: Mi,
  to: (t, e) => new bo(t, e)
});
function dn(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
const wo = ["style", "children", "scrollTop", "scrollLeft", "viewBox"], Ji = /^--/;
function xo(t, e) {
  return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !Ji.test(t) && !(Ie.hasOwnProperty(t) && Ie[t]) ? e + "px" : ("" + e).trim();
}
const Wn = {};
function So(t, e) {
  if (!t.nodeType || !t.setAttribute)
    return !1;
  const n = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter", i = e, {
    style: s,
    children: r,
    scrollTop: o,
    scrollLeft: a,
    viewBox: c
  } = i, l = dn(i, wo), u = Object.values(l), d = Object.keys(l).map((f) => n || t.hasAttribute(f) ? f : Wn[f] || (Wn[f] = f.replace(/([A-Z])/g, (m) => "-" + m.toLowerCase())));
  r !== void 0 && (t.textContent = r);
  for (let f in s)
    if (s.hasOwnProperty(f)) {
      const m = xo(f, s[f]);
      Ji.test(f) ? t.style.setProperty(f, m) : t.style[f] = m;
    }
  d.forEach((f, m) => {
    t.setAttribute(f, u[m]);
  }), o !== void 0 && (t.scrollTop = o), a !== void 0 && (t.scrollLeft = a), c !== void 0 && t.setAttribute("viewBox", c);
}
let Ie = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Eo = (t, e) => t + e.charAt(0).toUpperCase() + e.substring(1), Oo = ["Webkit", "Ms", "Moz", "O"];
Ie = Object.keys(Ie).reduce((t, e) => (Oo.forEach((n) => t[Eo(n, e)] = t[e]), t), Ie);
const Co = ["x", "y", "z"], ko = /^(matrix|translate|scale|rotate|skew)/, Po = /^(translate)/, To = /^(rotate|skew)/, Ct = (t, e) => p.num(t) && t !== 0 ? t + e : t, Ye = (t, e) => p.arr(t) ? t.every((n) => Ye(n, e)) : p.num(t) ? t === e : parseFloat(t) === e;
class Io extends pt {
  constructor(e) {
    let {
      x: n,
      y: i,
      z: s
    } = e, r = dn(e, Co);
    const o = [], a = [];
    (n || i || s) && (o.push([n || 0, i || 0, s || 0]), a.push((c) => [`translate3d(${c.map((l) => Ct(l, "px")).join(",")})`, Ye(c, 0)])), G(r, (c, l) => {
      if (l === "transform")
        o.push([c || ""]), a.push((u) => [u, u === ""]);
      else if (ko.test(l)) {
        if (delete r[l], p.und(c))
          return;
        const u = Po.test(l) ? "px" : To.test(l) ? "deg" : "";
        o.push(F(c)), a.push(l === "rotate3d" ? ([d, f, m, y]) => [`rotate3d(${d},${f},${m},${Ct(y, u)})`, Ye(y, 0)] : (d) => [`${l}(${d.map((f) => Ct(f, u)).join(",")})`, Ye(d, l.startsWith("scale") ? 1 : 0)]);
      }
    }), o.length && (r.transform = new Ao(o, a)), super(r);
  }
}
class Ao extends Ri {
  constructor(e, n) {
    super(), this._value = null, this.inputs = e, this.transforms = n;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let e = "", n = !0;
    return O(this.inputs, (i, s) => {
      const r = V(i[0]), [o, a] = this.transforms[s](p.arr(r) ? r : i.map(V));
      e += " " + o, n = n && a;
    }), n ? "none" : e;
  }
  observerAdded(e) {
    e == 1 && O(this.inputs, (n) => O(n, (i) => B(i) && ye(i, this)));
  }
  observerRemoved(e) {
    e == 0 && O(this.inputs, (n) => O(n, (i) => B(i) && De(i, this)));
  }
  eventObserved(e) {
    e.type == "change" && (this._value = null), $e(this, e);
  }
}
const Ro = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], $o = ["scrollTop", "scrollLeft"];
Y.assign({
  batchedUpdates: Ts,
  createStringInterpolator: Mi,
  colors: mr
});
const Do = Qr(Ro, {
  applyAnimatedValues: So,
  createAnimatedStyle: (t) => new Io(t),
  getComponentProps: (t) => dn(t, $o)
}), je = Do.animated;
function Mo(t) {
  return (typeof t == "function" ? t() : t) || document.body;
}
function es(t, e) {
  if (Gt && t) {
    const n = Mo(t);
    return Is(e, n);
  }
  return e;
}
const j = "${label}不是一个有效的${type}", No = {
  locale: "zh-CH",
  common: {
    confirm: "确定",
    cancel: "取消",
    loading: "加载中",
    close: "关闭"
  },
  Calendar: {
    title: "日期选择",
    confirm: "确认",
    start: "开始",
    end: "结束",
    today: "今日",
    markItems: ["一", "二", "三", "四", "五", "六", "日"],
    yearAndMonth: "${year}年${month}月"
  },
  Cascader: {
    placeholder: "请选择"
  },
  Dialog: {
    ok: "我知道了"
  },
  DatePicker: {
    tillNow: "至今"
  },
  ErrorBlock: {
    default: {
      title: "页面遇到一些小问题",
      description: "待会来试试"
    },
    busy: {
      title: "前方拥堵",
      description: "刷新试试"
    },
    disconnected: {
      title: "网络有点忙",
      description: "动动手指帮忙修复"
    },
    empty: {
      title: "没有找到你需要的东西",
      description: "找找其他的吧"
    }
  },
  Form: {
    required: "必填",
    optional: "选填",
    defaultValidateMessages: {
      default: "字段验证错误${label}",
      required: "请输入${label}",
      enum: "${label}必须是其中一个[${enum}]",
      whitespace: "${label}不能为空字符",
      date: {
        format: "${label}日期格式无效",
        parse: "${label}不能转换为日期",
        invalid: "${label}是一个无效日期"
      },
      types: {
        string: j,
        method: j,
        array: j,
        object: j,
        number: j,
        date: j,
        boolean: j,
        integer: j,
        float: j,
        regexp: j,
        email: j,
        url: j,
        hex: j
      },
      string: {
        len: "${label}须为${len}个字符",
        min: "${label}最少${min}个字符",
        max: "${label}最多${max}个字符",
        range: "${label}须在${min}-${max}字符之间"
      },
      number: {
        len: "${label}必须等于${len}",
        min: "${label}最小值为${min}",
        max: "${label}最大值为${max}",
        range: "${label}须在${min}-${max}之间"
      },
      array: {
        len: "须为${len}个${label}",
        min: "最少${min}个${label}",
        max: "最多${max}个${label}",
        range: "${label}数量须在${min}-${max}之间"
      },
      pattern: {
        mismatch: "${label}与模式不匹配${pattern}"
      }
    }
  },
  ImageUploader: {
    uploading: "上传中...",
    upload: "上传"
  },
  InfiniteScroll: {
    noMore: "没有更多了",
    failedToLoad: "加载失败",
    retry: "重新加载"
  },
  Input: {
    clear: "清除"
  },
  Mask: {
    name: "背景蒙层"
  },
  Modal: {
    ok: "我知道了"
  },
  PasscodeInput: {
    name: "密码输入框"
  },
  PullToRefresh: {
    pulling: "下拉刷新",
    canRelease: "释放立即刷新",
    complete: "刷新成功"
  },
  SearchBar: {
    name: "搜索框"
  },
  Slider: {
    name: "滑动输入条"
  },
  Stepper: {
    decrease: "减少",
    increase: "增加"
  },
  Switch: {
    name: "开关"
  },
  Selector: {
    name: "选择组"
  }
}, Lo = No, Vo = {
  current: {
    locale: Lo
  }
};
function jo() {
  return Vo.current;
}
const Fo = L.createContext(null);
function hn() {
  var t;
  return (t = Qt(Fo)) !== null && t !== void 0 ? t : jo();
}
function Uo(t) {
  const e = T(t);
  return t && (e.current = !0), !!e.current;
}
const ts = (t) => Bo(t.active, t.forceRender, t.destroyOnClose) ? t.children : null;
function Bo(t, e, n) {
  const i = Uo(t);
  return e || t ? !0 : i ? !n : !1;
}
const qo = {
  click: "onClick",
  touchstart: "onTouchStart"
};
function ns(t, e) {
  const n = Object.assign({}, e.props);
  for (const i of t) {
    const s = qo[i];
    n[s] = function(r) {
      var o, a;
      r.stopPropagation(), (a = (o = e.props)[s]) === null || a === void 0 || a.call(o, r);
    };
  }
  return L.cloneElement(e, n);
}
const kt = "adm-mask", Wo = {
  default: 0.55,
  thin: 0.35,
  thick: 0.75
}, zo = {
  black: "0, 0, 0",
  white: "255, 255, 255"
}, Ko = {
  visible: !0,
  destroyOnClose: !1,
  forceRender: !1,
  color: "black",
  opacity: "default",
  disableBodyScroll: !0,
  getContainer: null,
  stopPropagation: ["click"]
}, Ho = (t) => {
  const e = Fe(Ko, t), {
    locale: n
  } = hn(), i = T(null);
  xi(i, e.visible && e.disableBodyScroll);
  const s = ce(() => {
    var u;
    const d = (u = Wo[e.opacity]) !== null && u !== void 0 ? u : e.opacity, f = zo[e.color];
    return f ? `rgba(${f}, ${d})` : e.color;
  }, [e.color, e.opacity]), [r, o] = J(e.visible), a = wi(), {
    opacity: c
  } = gt({
    opacity: e.visible ? 1 : 0,
    config: {
      precision: 0.01,
      mass: 1,
      tension: 250,
      friction: 30,
      clamp: !0
    },
    onStart: () => {
      o(!0);
    },
    onRest: () => {
      var u, d;
      a.current || (o(e.visible), e.visible ? (u = e.afterShow) === null || u === void 0 || u.call(e) : (d = e.afterClose) === null || d === void 0 || d.call(e));
    }
  }), l = ns(e.stopPropagation, Ue(e, L.createElement(je.div, {
    className: kt,
    ref: i,
    "aria-hidden": !0,
    style: Object.assign(Object.assign({}, e.style), {
      background: s,
      opacity: c,
      display: r ? void 0 : "none"
    }),
    onClick: (u) => {
      var d;
      u.target === u.currentTarget && ((d = e.onMaskClick) === null || d === void 0 || d.call(e, u));
    }
  }, e.onMaskClick && /* @__PURE__ */ C("div", {
    className: `${kt}-aria-button`,
    role: "button",
    "aria-label": n.Mask.name,
    onClick: e.onMaskClick
  }), /* @__PURE__ */ C("div", {
    className: `${kt}-content`,
    children: e.children
  }))));
  return /* @__PURE__ */ C(ts, {
    active: r,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: es(e.getContainer, l)
  });
};
function Qo(t) {
  return /* @__PURE__ */ C("svg", {
    ...Object.assign({
      width: "1em",
      height: "1em",
      viewBox: "0 0 48 48",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, t, {
      style: Object.assign({
        verticalAlign: "-0.125em"
      }, t.style),
      className: ["antd-mobile-icon", t.className].filter(Boolean).join(" ")
    }),
    children: /* @__PURE__ */ C("g", {
      id: "CloseOutline-CloseOutline",
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd",
      children: /* @__PURE__ */ ie("g", {
        id: "CloseOutline-编组",
        children: [/* @__PURE__ */ C("rect", {
          id: "CloseOutline-矩形",
          fill: "#FFFFFF",
          opacity: 0,
          x: 0,
          y: 0,
          width: 48,
          height: 48
        }), /* @__PURE__ */ C("path", {
          d: "M10.6085104,8.11754663 L24.1768397,21.8195031 L24.1768397,21.8195031 L37.7443031,8.1175556 C37.8194278,8.04168616 37.9217669,7.999 38.0285372,7.999 L41.1040268,7.999 C41.3249407,7.999 41.5040268,8.1780861 41.5040268,8.399 C41.5040268,8.50440471 41.4624226,8.60554929 41.3882578,8.68044752 L26.2773302,23.9408235 L26.2773302,23.9408235 L41.5021975,39.3175645 C41.65763,39.4745475 41.6563731,39.7278104 41.4993901,39.8832429 C41.4244929,39.9574004 41.3233534,39.999 41.2179546,39.999 L38.1434012,39.999 C38.0366291,39.999 37.9342885,39.9563124 37.8591634,39.8804408 L24.1768397,26.0621438 L24.1768397,26.0621438 L10.4936501,39.8804497 C10.4185257,39.9563159 10.3161889,39.999 10.2094212,39.999 L7.13584526,39.999 C6.91493136,39.999 6.73584526,39.8199139 6.73584526,39.599 C6.73584526,39.4936017 6.77744443,39.3924627 6.85160121,39.3175656 L22.0763492,23.9408235 L22.0763492,23.9408235 L6.96554081,8.68044639 C6.81010226,8.52346929 6.81134951,8.27020637 6.9683266,8.11476782 C7.04322474,8.04060377 7.14436883,7.999 7.24977299,7.999 L10.3242852,7.999 C10.4310511,7.999 10.5333863,8.04168267 10.6085104,8.11754663 Z",
          id: "CloseOutline-路径",
          fill: "currentColor",
          fillRule: "nonzero"
        })]
      })
    })
  });
}
const Go = {
  closeOnMaskClick: !1,
  destroyOnClose: !1,
  disableBodyScroll: !0,
  forceRender: !1,
  getContainer: () => document.body,
  mask: !0,
  showCloseButton: !1,
  stopPropagation: ["click"],
  visible: !1
};
function Yo(t) {
  const [e, n] = J(t);
  return Ce(() => {
    n(t);
  }, [t]), e;
}
function Xo(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
const D = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function zn(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function Kn(t, e, n, i = 0.15) {
  return i === 0 ? Xo(t, e, n) : t < e ? -zn(e - t, n - e, i) + e : t > n ? +zn(t - n, n - e, i) + n : t;
}
function Zo(t, [e, n], [i, s]) {
  const [[r, o], [a, c]] = t;
  return [Kn(e, r, o, i), Kn(n, a, c, s)];
}
function Jo(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(t, e || "default");
    if (typeof i != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function ea(t) {
  var e = Jo(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function N(t, e, n) {
  return e = ea(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Hn(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function A(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Hn(Object(n), !0).forEach(function(i) {
      N(t, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Hn(Object(n)).forEach(function(i) {
      Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t;
}
const is = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Qn(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
const ta = ["enter", "leave"];
function na(t = !1, e) {
  return t && !ta.includes(e);
}
function ia(t, e = "", n = !1) {
  const i = is[t], s = i && i[e] || e;
  return "on" + Qn(t) + Qn(s) + (na(n, s) ? "Capture" : "");
}
const sa = ["gotpointercapture", "lostpointercapture"];
function ra(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const i = sa.includes(e) ? "capturecapture" : "capture", s = !!~e.indexOf(i);
  return s && (e = e.replace("capture", "")), {
    device: e,
    capture: s,
    passive: n
  };
}
function oa(t, e = "") {
  const n = is[t], i = n && n[e] || e;
  return t + i;
}
function vt(t) {
  return "touches" in t;
}
function ss(t) {
  return vt(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function aa(t) {
  return Array.from(t.touches).filter((e) => {
    var n, i;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (i = n.contains) === null || i === void 0 ? void 0 : i.call(n, e.target));
  });
}
function ca(t) {
  return t.type === "touchend" || t.type === "touchcancel" ? t.changedTouches : t.targetTouches;
}
function rs(t) {
  return vt(t) ? ca(t)[0] : t;
}
function ua(t) {
  return aa(t).map((e) => e.identifier);
}
function Pt(t) {
  const e = rs(t);
  return vt(t) ? e.identifier : e.pointerId;
}
function Gn(t) {
  const e = rs(t);
  return [e.clientX, e.clientY];
}
const Yn = 40, Xn = 800;
function la(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: i
  } = t;
  return i === 1 ? (e *= Yn, n *= Yn) : i === 2 && (e *= Xn, n *= Xn), [e, n];
}
function fa(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: i,
      metaKey: s,
      ctrlKey: r
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: i,
      metaKey: s,
      ctrlKey: r
    });
  }
  return e;
}
function st(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function da() {
}
function ha(...t) {
  return t.length === 0 ? da : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function Zn(t, e) {
  return Object.assign({}, e, t || {});
}
const pa = 32;
class ma {
  constructor(e, n, i) {
    this.ctrl = e, this.args = n, this.key = i, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: i,
      args: s
    } = this;
    n[i] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = s, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, i = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = i.from ? st(i.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: i,
      shared: s
    } = this;
    n.args = this.args;
    let r = 0;
    if (e && (n.event = e, i.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, s.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, s.locked = !!document.pointerLockElement, Object.assign(s, fa(e)), s.down = s.pressed = s.buttons % 2 === 1 || s.touches > 0, r = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const x = n._delta.map(Math.abs);
      D.addTo(n._distance, x);
    }
    this.axisIntent && this.axisIntent(e);
    const [o, a] = n._movement, [c, l] = i.threshold, {
      _step: u,
      values: d
    } = n;
    if (i.hasCustomTransform ? (u[0] === !1 && (u[0] = Math.abs(o) >= c && d[0]), u[1] === !1 && (u[1] = Math.abs(a) >= l && d[1])) : (u[0] === !1 && (u[0] = Math.abs(o) >= c && Math.sign(o) * c), u[1] === !1 && (u[1] = Math.abs(a) >= l && Math.sign(a) * l)), n.intentional = u[0] !== !1 || u[1] !== !1, !n.intentional)
      return;
    const f = [0, 0];
    if (i.hasCustomTransform) {
      const [x, k] = d;
      f[0] = u[0] !== !1 ? x - u[0] : 0, f[1] = u[1] !== !1 ? k - u[1] : 0;
    } else
      f[0] = u[0] !== !1 ? o - u[0] : 0, f[1] = u[1] !== !1 ? a - u[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(f);
    const m = n.offset, y = n._active && !n._blocked || n.active;
    y && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = s[this.ingKey] = n._active, e && (n.first && ("bounds" in i && (n._bounds = st(i.bounds, n)), this.setup && this.setup()), n.movement = f, this.computeOffset()));
    const [w, v] = n.offset, [[h, _], [b, g]] = n._bounds;
    n.overflow = [w < h ? -1 : w > _ ? 1 : 0, v < b ? -1 : v > g ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const S = n._active ? i.rubberband || [0, 0] : [0, 0];
    if (n.offset = Zo(n._bounds, n.offset, S), n.delta = D.sub(n.offset, m), this.computeMovement(), y && (!n.last || r > pa)) {
      n.delta = D.sub(n.offset, m);
      const x = n.delta.map(Math.abs);
      D.addTo(n.distance, x), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && r > 0 && (n.velocity = [x[0] / r, x[1] / r], n.timeDelta = r);
    }
  }
  emit() {
    const e = this.state, n = this.shared, i = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !i.triggerAllEvents)
      return;
    const s = this.handler(A(A(A({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    s !== void 0 && (e.memo = s);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function ga([t, e], n) {
  const i = Math.abs(t), s = Math.abs(e);
  if (i > s && i > n)
    return "x";
  if (s > i && s > n)
    return "y";
}
class os extends ma {
  constructor(...e) {
    super(...e), N(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = D.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = D.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, i = this.config;
    if (!n.axis && e) {
      const s = typeof i.axisThreshold == "object" ? i.axisThreshold[ss(e)] : i.axisThreshold;
      n.axis = ga(n._movement, s);
    }
    n._blocked = (i.lockDirection || !!i.axis) && !n.axis || !!i.axis && i.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const Jn = (t) => t, ei = 0.15, pn = {
  enabled(t = !0) {
    return t;
  },
  eventOptions(t, e, n) {
    return A(A({}, n.shared.eventOptions), t);
  },
  preventDefault(t = !1) {
    return t;
  },
  triggerAllEvents(t = !1) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case !0:
        return [ei, ei];
      case !1:
        return [0, 0];
      default:
        return D.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function")
      return t;
    if (t != null)
      return D.toVector(t);
  },
  transform(t, e, n) {
    const i = t || n.shared.transform;
    if (this.hasCustomTransform = !!i, process.env.NODE_ENV === "development") {
      const s = i || Jn;
      return (r) => {
        const o = s(r);
        return (!isFinite(o[0]) || !isFinite(o[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${o[0]},${[1]}]`), o;
      };
    }
    return i || Jn;
  },
  threshold(t) {
    return D.toVector(t, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(pn, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const va = 0, _e = A(A({}, pn), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection)
      return n;
  },
  axisThreshold(t = va) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (r) => _e.bounds(t(r));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: i = -1 / 0,
      bottom: s = 1 / 0
    } = t;
    return [[e, n], [i, s]];
  }
}), ti = {
  ArrowRight: (t, e = 1) => [t * e, 0],
  ArrowLeft: (t, e = 1) => [-1 * t * e, 0],
  ArrowUp: (t, e = 1) => [0, -1 * t * e],
  ArrowDown: (t, e = 1) => [0, t * e]
};
class ya extends os {
  constructor(...e) {
    super(...e), N(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this);
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const n = e._bounds.getBoundingClientRect(), i = e.currentTarget.getBoundingClientRect(), s = {
        left: n.left - i.left + e.offset[0],
        right: n.right - i.right + e.offset[0],
        top: n.top - i.top + e.offset[1],
        bottom: n.bottom - i.bottom + e.offset[1]
      };
      e._bounds = _e.bounds(s);
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(e) {
    const n = this.config, i = this.state;
    if (e.buttons != null && (Array.isArray(n.pointerButtons) ? !n.pointerButtons.includes(e.buttons) : n.pointerButtons !== -1 && n.pointerButtons !== e.buttons))
      return;
    const s = this.ctrl.setEventIds(e);
    n.pointerCapture && e.target.setPointerCapture(e.pointerId), !(s && s.size > 1 && i._pointerActive) && (this.start(e), this.setupPointer(e), i._pointerId = Pt(e), i._pointerActive = !0, this.computeValues(Gn(e)), this.computeInitial(), n.preventScrollAxis && ss(e) !== "mouse" ? (i._active = !1, this.setupScrollPrevention(e)) : n.delay > 0 ? (this.setupDelayTrigger(e), n.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e));
  }
  startPointerDrag(e) {
    const n = this.state;
    n._active = !0, n._preventScroll = !0, n._delayed = !1, this.compute(e), this.emit();
  }
  pointerMove(e) {
    const n = this.state, i = this.config;
    if (!n._pointerActive)
      return;
    const s = Pt(e);
    if (n._pointerId !== void 0 && s !== n._pointerId)
      return;
    const r = Gn(e);
    if (document.pointerLockElement === e.target ? n._delta = [e.movementX, e.movementY] : (n._delta = D.sub(r, n._values), this.computeValues(r)), D.addTo(n._movement, n._delta), this.compute(e), n._delayed && n.intentional) {
      this.timeoutStore.remove("dragDelay"), n.active = !1, this.startPointerDrag(e);
      return;
    }
    if (i.preventScrollAxis && !n._preventScroll)
      if (n.axis)
        if (n.axis === i.preventScrollAxis || i.preventScrollAxis === "xy") {
          n._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const n = this.state, i = this.config;
    if (!n._active || !n._pointerActive)
      return;
    const s = Pt(e);
    if (n._pointerId !== void 0 && s !== n._pointerId)
      return;
    this.state._pointerActive = !1, this.setActive(), this.compute(e);
    const [r, o] = n._distance;
    if (n.tap = r <= i.tapsThreshold && o <= i.tapsThreshold, n.tap && i.filterTaps)
      n._force = !0;
    else {
      const [a, c] = n._delta, [l, u] = n._movement, [d, f] = i.swipe.velocity, [m, y] = i.swipe.distance, w = i.swipe.duration;
      if (n.elapsedTime < w) {
        const v = Math.abs(a / n.timeDelta), h = Math.abs(c / n.timeDelta);
        v > d && Math.abs(l) > m && (n.swipe[0] = Math.sign(a)), h > f && Math.abs(u) > y && (n.swipe[1] = Math.sign(c));
      }
    }
    this.emit();
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation());
  }
  setupPointer(e) {
    const n = this.config, i = n.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (i === "pointer" && n.preventScrollDelay === void 0) {
          const s = "uv" in e ? e.sourceEvent.currentTarget : e.currentTarget;
          window.getComputedStyle(s).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", s);
        }
      } catch {
      }
    n.pointerLock && e.currentTarget.requestPointerLock(), n.pointerCapture || (this.eventStore.add(this.sharedConfig.window, i, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, i, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, i, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault();
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = !1, ba(e);
    const n = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", n), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", n), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e);
  }
  setupDelayTrigger(e) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e);
    }, this.config.delay);
  }
  keyDown(e) {
    const n = ti[e.key];
    if (n) {
      const i = this.state, s = e.shiftKey ? 10 : e.altKey ? 0.1 : 1;
      this.start(e), i._delta = n(this.config.keyboardDisplacement, s), i._keyboardActive = !0, D.addTo(i._movement, i._delta), this.compute(e), this.emit();
    }
  }
  keyUp(e) {
    e.key in ti && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    e(n, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(n, "change", this.pointerMove.bind(this)), e(n, "end", this.pointerUp.bind(this)), e(n, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function ba(t) {
  "persist" in t && typeof t.persist == "function" && t.persist();
}
const We = typeof window < "u" && window.document && window.document.createElement;
function as() {
  return We && "ontouchstart" in window;
}
function _a() {
  return as() || We && window.navigator.maxTouchPoints > 1;
}
function wa() {
  return We && "onpointerdown" in window;
}
function xa() {
  return We && "exitPointerLock" in window.document;
}
function Sa() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const q = {
  isBrowser: We,
  gesture: Sa(),
  touch: as(),
  touchscreen: _a(),
  pointer: wa(),
  pointerLock: xa()
}, Ea = 250, Oa = 180, Ca = 0.5, ka = 50, Pa = 250, Ta = 10, ni = {
  mouse: 0,
  touch: 0,
  pen: 8
}, cs = A(A({}, _e), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: i = !1,
      mouse: s = !1
    } = {}
  }) {
    return this.pointerLock = i && q.pointerLock, q.touch && n ? "touch" : this.pointerLock ? "mouse" : q.pointer && !s ? "pointer" : q.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? Ea : void 0, !(!q.touchscreen || n === !1))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: i = 1,
      keys: s = !0
    } = {}
  }) {
    return this.pointerButtons = i, this.keys = s, !this.pointerLock && this.device === "pointer" && n;
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: i = 3,
    axis: s = void 0
  }) {
    const r = D.toVector(t, n ? i : s ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = i, r;
  },
  swipe({
    velocity: t = Ca,
    distance: e = ka,
    duration: n = Pa
  } = {}) {
    return {
      velocity: this.transform(D.toVector(t)),
      distance: this.transform(D.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return Oa;
      case !1:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? A(A({}, ni), t) : ni;
  },
  keyboardDisplacement(t = Ta) {
    return t;
  }
});
process.env.NODE_ENV === "development" && Object.assign(cs, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function Ia(t) {
  const [e, n] = t.overflow, [i, s] = t._delta, [r, o] = t._direction;
  (e < 0 && i > 0 && r < 0 || e > 0 && i < 0 && r > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && s > 0 && o < 0 || n > 0 && s < 0 && o > 0) && (t._movement[1] = t._movementBound[1]);
}
A(A({}, pn), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: i = !1
    } = {}
  }) {
    if (n.target && !q.touch && q.gesture)
      return "gesture";
    if (q.touch && i)
      return "touch";
    if (q.touchscreen) {
      if (q.pointer)
        return "pointer";
      if (q.touch)
        return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: i = {}
  }) {
    const s = (o) => {
      const a = Zn(st(n, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    }, r = (o) => {
      const a = Zn(st(i, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    };
    return typeof n != "function" && typeof i != "function" ? [s(), r()] : (o) => [s(o), r(o)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", D.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  },
  pinchOnWheel(t = !0) {
    return t;
  }
});
A(A({}, _e), {}, {
  mouseOnly: (t = !0) => t
});
class Aa extends os {
  constructor(...e) {
    super(...e), N(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = la(e), D.addTo(n._movement, n._delta), Ia(n), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const Ra = _e;
A(A({}, _e), {}, {
  mouseOnly: (t = !0) => t
});
const us = /* @__PURE__ */ new Map(), Wt = /* @__PURE__ */ new Map();
function ls(t) {
  us.set(t.key, t.engine), Wt.set(t.key, t.resolver);
}
const $a = {
  key: "drag",
  engine: ya,
  resolver: cs
}, Da = {
  key: "wheel",
  engine: Aa,
  resolver: Ra
};
function Ma(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function Na(t, e) {
  if (t == null)
    return {};
  var n = Ma(t, e), i, s;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    for (s = 0; s < r.length; s++)
      i = r[s], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]);
  }
  return n;
}
const La = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = !0) {
    return t;
  },
  window(t = q.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
}, Va = ["target", "eventOptions", "window", "enabled", "transform"];
function Xe(t = {}, e) {
  const n = {};
  for (const [i, s] of Object.entries(e))
    switch (typeof s) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const r = s.call(n, t[i], i, t);
          Number.isNaN(r) || (n[i] = r);
        } else
          n[i] = s.call(n, t[i], i, t);
        break;
      case "object":
        n[i] = Xe(t[i], s);
        break;
      case "boolean":
        s && (n[i] = t[i]);
        break;
    }
  return n;
}
function ja(t, e, n = {}) {
  const i = t, {
    target: s,
    eventOptions: r,
    window: o,
    enabled: a,
    transform: c
  } = i, l = Na(i, Va);
  if (n.shared = Xe({
    target: s,
    eventOptions: r,
    window: o,
    enabled: a,
    transform: c
  }, La), e) {
    const u = Wt.get(e);
    n[e] = Xe(A({
      shared: n.shared
    }, l), u);
  } else
    for (const u in l) {
      const d = Wt.get(u);
      if (d)
        n[u] = Xe(A({
          shared: n.shared
        }, l[u]), d);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(u)) {
        if (u === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${u}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class fs {
  constructor(e, n) {
    N(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, i, s, r) {
    const o = this._listeners, a = oa(n, i), c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, l = A(A({}, c), r);
    e.addEventListener(a, s, l);
    const u = () => {
      e.removeEventListener(a, s, l), o.delete(u);
    };
    return o.add(u), u;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class Fa {
  constructor() {
    N(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, i = 140, ...s) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, i, ...s));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class Ua {
  constructor(e) {
    N(this, "gestures", /* @__PURE__ */ new Set()), N(this, "_targetEventStore", new fs(this)), N(this, "gestureEventStores", {}), N(this, "gestureTimeoutStores", {}), N(this, "handlers", {}), N(this, "config", {}), N(this, "pointerIds", /* @__PURE__ */ new Set()), N(this, "touchIds", /* @__PURE__ */ new Set()), N(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), Ba(this, e);
  }
  setEventIds(e) {
    if (vt(e))
      return this.touchIds = new Set(ua(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = ja(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, i = {};
    let s;
    if (!(n.target && (s = n.target(), !s))) {
      if (n.enabled) {
        for (const o of this.gestures) {
          const a = this.config[o], c = ii(i, a.eventOptions, !!s);
          if (a.enabled) {
            const l = us.get(o);
            new l(this, e, o).bind(c);
          }
        }
        const r = ii(i, n.eventOptions, !!s);
        for (const o in this.nativeHandlers)
          r(o, "", (a) => this.nativeHandlers[o](A(A({}, this.state.shared), {}, {
            event: a,
            args: e
          })), void 0, !0);
      }
      for (const r in i)
        i[r] = ha(...i[r]);
      if (!s)
        return i;
      for (const r in i) {
        const {
          device: o,
          capture: a,
          passive: c
        } = ra(r);
        this._targetEventStore.add(s, o, "", i[r], {
          capture: a,
          passive: c
        });
      }
    }
  }
}
function de(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new fs(t, e), t.gestureTimeoutStores[e] = new Fa();
}
function Ba(t, e) {
  e.drag && de(t, "drag"), e.wheel && de(t, "wheel"), e.scroll && de(t, "scroll"), e.move && de(t, "move"), e.pinch && de(t, "pinch"), e.hover && de(t, "hover");
}
const ii = (t, e, n) => (i, s, r, o = {}, a = !1) => {
  var c, l;
  const u = (c = o.capture) !== null && c !== void 0 ? c : e.capture, d = (l = o.passive) !== null && l !== void 0 ? l : e.passive;
  let f = a ? i : ia(i, s, u);
  n && d && (f += "Passive"), t[f] = t[f] || [], t[f].push(r);
};
function ds(t, e = {}, n, i) {
  const s = L.useMemo(() => new Ua(t), []);
  if (s.applyHandlers(t, i), s.applyConfig(e, n), L.useEffect(s.effect.bind(s)), L.useEffect(() => s.clean.bind(s), []), e.target === void 0)
    return s.bind.bind(s);
}
function hs(t, e) {
  return ls($a), ds({
    drag: t
  }, e || {}, "drag");
}
function qa(t, e) {
  return ls(Da), ds({
    wheel: t
  }, e || {}, "wheel");
}
const Qe = "adm-popup", Wa = Object.assign(Object.assign({}, Go), {
  closeOnSwipe: !1,
  position: "bottom"
}), za = (t) => {
  const e = Fe(Wa, t), n = Ae(`${Qe}-body`, e.bodyClassName, `${Qe}-body-position-${e.position}`), {
    locale: i
  } = hn(), [s, r] = J(e.visible), o = T(null);
  xi(o, e.disableBodyScroll && s ? "strict" : !1), Ce(() => {
    e.visible && r(!0);
  }, [e.visible]);
  const a = wi(), {
    percent: c
  } = gt({
    percent: e.visible ? 0 : 100,
    config: {
      precision: 0.1,
      mass: 0.4,
      tension: 300,
      friction: 30
    },
    onRest: () => {
      var f, m;
      a.current || (r(e.visible), e.visible ? (f = e.afterShow) === null || f === void 0 || f.call(e) : (m = e.afterClose) === null || m === void 0 || m.call(e));
    }
  }), l = hs(({
    swipe: [, f]
  }) => {
    var m;
    e.closeOnSwipe && (f === 1 && e.position === "bottom" || f === -1 && e.position === "top") && ((m = e.onClose) === null || m === void 0 || m.call(e));
  }, {
    axis: "y",
    enabled: ["top", "bottom"].includes(e.position)
  }), u = Yo(s && e.visible), d = ns(e.stopPropagation, Ue(e, L.createElement("div", Object.assign({
    className: Qe,
    onClick: e.onClick,
    style: {
      display: s ? void 0 : "none",
      touchAction: ["top", "bottom"].includes(e.position) ? "none" : "auto"
    }
  }, l()), e.mask && /* @__PURE__ */ C(Ho, {
    visible: u,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    onMaskClick: (f) => {
      var m, y;
      (m = e.onMaskClick) === null || m === void 0 || m.call(e, f), e.closeOnMaskClick && ((y = e.onClose) === null || y === void 0 || y.call(e));
    },
    className: e.maskClassName,
    style: e.maskStyle,
    disableBodyScroll: !1,
    stopPropagation: e.stopPropagation
  }), L.createElement(je.div, {
    className: n,
    style: Object.assign(Object.assign({}, e.bodyStyle), {
      pointerEvents: c.to((f) => f === 0 ? "unset" : "none"),
      transform: c.to((f) => e.position === "bottom" ? `translate(0, ${f}%)` : e.position === "top" ? `translate(0, -${f}%)` : e.position === "left" ? `translate(-${f}%, 0)` : e.position === "right" ? `translate(${f}%, 0)` : "none")
    }),
    ref: o
  }, e.showCloseButton && /* @__PURE__ */ C("a", {
    className: Ae(`${Qe}-close-icon`, "adm-plain-anchor"),
    onClick: () => {
      var f;
      (f = e.onClose) === null || f === void 0 || f.call(e);
    },
    role: "button",
    "aria-label": i.common.close,
    children: /* @__PURE__ */ C(Qo, {})
  }), e.children))));
  return /* @__PURE__ */ C(ts, {
    active: s,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: es(e.getContainer, d)
  });
};
function zt(t, e, n) {
  let i = t;
  return e !== void 0 && (i = Math.max(t, e)), n !== void 0 && (i = Math.min(i, n)), i;
}
function si(t, e, n) {
  return t * e * n / (e + n * t);
}
function ri(t, e, n, i, s = 0.15) {
  return s === 0 ? zt(t, e, n) : t < e ? -si(e - t, i, s) + e : t > n ? +si(t - n, i, s) + n : t;
}
const Kt = process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test";
function oi(t, e) {
  Kt && console.error(`[antd-mobile: ${t}] ${e}`);
}
function Ka(t) {
  if (t == null || t === "")
    return Kt && oi("Global", "Something went wrong when calculating CSS length. Please report an issue at https://github.com/ant-design/ant-design-mobile/issues/new/choose"), 0;
  const e = t.trim();
  return e.endsWith("px") ? parseFloat(e) : e.endsWith("rem") ? parseFloat(e) * parseFloat(window.getComputedStyle(document.documentElement).fontSize) : e.endsWith("vw") ? parseFloat(e) * window.innerWidth / 100 : (Kt && oi("Global", `You are using a not supported CSS unit in \`${t}\`. Only \`px\` \`rem\` and \`vw\` are supported.`), 0);
}
const H = "adm-picker-view", ps = at((t) => {
  const {
    value: e,
    column: n,
    renderLabel: i
  } = t;
  function s(h) {
    t.onSelect(h, t.index);
  }
  const [{
    y: r
  }, o] = gt(() => ({
    from: {
      y: 0
    },
    config: {
      tension: 400,
      mass: 0.8
    }
  })), a = T(!1), c = T(null), l = T(null), u = T(34);
  Ce(() => {
    const h = l.current;
    h && (u.current = Ka(window.getComputedStyle(h).getPropertyValue("height")));
  }), Ce(() => {
    if (a.current || e === null)
      return;
    const h = n.findIndex((b) => b.value === e);
    if (h < 0)
      return;
    const _ = h * -u.current;
    o.start({
      y: _,
      immediate: r.goal !== _
    });
  }, [e, n]), Ce(() => {
    if (n.length === 0)
      e !== null && s(null);
    else if (!n.some((h) => h.value === e)) {
      const h = n[0];
      s(h.value);
    }
  }, [n, e]);
  function d(h) {
    const _ = h * -u.current;
    o.start({
      y: _
    });
    const b = n[h];
    b && s(b.value);
  }
  const f = (h) => {
    const {
      direction: [, _],
      distance: [, b],
      velocity: [, g],
      offset: [, S],
      last: x
    } = h;
    return {
      direction: _,
      distance: b,
      velocity: g,
      offset: S,
      last: x
    };
  }, m = (h) => {
    a.current = !0;
    const _ = -((n.length - 1) * u.current), b = 0, {
      direction: g,
      last: S,
      velocity: x,
      offset: k
    } = f(h);
    if (S) {
      a.current = !1;
      const P = k + x * g * 50, I = zt(P, _, b), R = -Math.round(I / u.current);
      d(R);
    } else {
      const P = k;
      o.start({
        y: ri(P, _, b, u.current * 50, 0.2)
      });
    }
  }, y = (h) => {
    a.current = !0;
    const _ = -((n.length - 1) * u.current), b = 0, {
      direction: g,
      last: S,
      velocity: x,
      distance: k
    } = f(h), P = -g, I = r.get();
    if (S) {
      a.current = !1;
      const R = x * P * 50, X = I + k * P + R, U = zt(X, _, b), ee = -Math.round(U / u.current);
      d(ee);
    } else {
      const R = I + k * P;
      o.start({
        y: ri(R, _, b, u.current * 50, 0.2)
      });
    }
  };
  hs((h) => {
    h.event.stopPropagation(), m(h);
  }, {
    axis: "y",
    from: () => [0, r.get()],
    filterTaps: !0,
    pointer: {
      touch: !0
    },
    target: c
  }), qa((h) => {
    h.event.stopPropagation(), y(h);
  }, {
    target: t.mouseWheel ? c : void 0,
    axis: "y",
    from: () => [0, r.get()],
    preventDefault: !0,
    eventOptions: Ze ? {
      passive: !1
    } : void 0
  });
  let w = null;
  function v() {
    if (w === null)
      return null;
    const h = n[w], _ = w - 1, b = w + 1, g = n[_], S = n[b];
    return /* @__PURE__ */ ie("div", {
      className: `${H}-column-accessible`,
      children: [/* @__PURE__ */ C("div", {
        className: `${H}-column-accessible-current`,
        role: "button",
        "aria-label": h ? `当前选择的是：${h.label}` : "当前未选择",
        children: "-"
      }), /* @__PURE__ */ C("div", {
        className: `${H}-column-accessible-button`,
        onClick: () => {
          g && d(_);
        },
        role: g ? "button" : "text",
        "aria-label": g ? `选择上一项：${g.label}` : "没有上一项",
        children: "-"
      }), /* @__PURE__ */ C("div", {
        className: `${H}-column-accessible-button`,
        onClick: () => {
          S && d(b);
        },
        role: S ? "button" : "text",
        "aria-label": S ? `选择下一项：${S.label}` : "没有下一项",
        children: "-"
      })]
    });
  }
  return L.createElement("div", {
    className: `${H}-column`
  }, /* @__PURE__ */ C("div", {
    className: `${H}-item-height-measure`,
    ref: l
  }), L.createElement(je.div, {
    ref: c,
    style: {
      translateY: r
    },
    className: `${H}-column-wheel`,
    "aria-hidden": !0
  }, n.map((h, _) => {
    var b;
    const g = t.value === h.value;
    g && (w = _);
    function S() {
      a.current = !1, d(_);
    }
    return /* @__PURE__ */ C("div", {
      "data-selected": g,
      className: Ae(`${H}-column-item`, {
        [`${H}-column-item-active`]: g
      }),
      onClick: S,
      "aria-hidden": !g,
      "aria-label": g ? "active" : "",
      children: /* @__PURE__ */ C("div", {
        className: `${H}-column-item-label`,
        children: i(h)
      })
    }, (b = h.key) !== null && b !== void 0 ? b : h.value);
  })), v());
}, (t, e) => !(t.index !== e.index || t.value !== e.value || t.onSelect !== e.onSelect || t.renderLabel !== e.renderLabel || t.mouseWheel !== e.mouseWheel || !As(t.column, e.column)));
ps.displayName = "Wheel";
function ai(t) {
  let e = null;
  return () => (e === null && (e = t()), e);
}
function ms(t, e) {
  const n = ai(() => (typeof t == "function" ? t(e) : t).map((o) => o.map((a) => typeof a == "string" ? {
    label: a,
    value: a
  } : a))), i = ai(() => e.map((r, o) => {
    var a;
    const c = n()[o];
    return c && (a = c.find((l) => l.value === r)) !== null && a !== void 0 ? a : null;
  }));
  return {
    get columns() {
      return n();
    },
    get items() {
      return i();
    }
  };
}
function gs(t, e) {
  return ce(() => ms(t, e), [t, e]);
}
const vs = (t) => t.label;
var Ht = { exports: {} }, Tt = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ci;
function Ha() {
  if (ci)
    return Tt;
  ci = 1;
  var t = L;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, i = t.useState, s = t.useEffect, r = t.useLayoutEffect, o = t.useDebugValue;
  function a(d, f) {
    var m = f(), y = i({ inst: { value: m, getSnapshot: f } }), w = y[0].inst, v = y[1];
    return r(function() {
      w.value = m, w.getSnapshot = f, c(w) && v({ inst: w });
    }, [d, m, f]), s(function() {
      return c(w) && v({ inst: w }), d(function() {
        c(w) && v({ inst: w });
      });
    }, [d]), o(m), m;
  }
  function c(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var m = f();
      return !n(d, m);
    } catch {
      return !0;
    }
  }
  function l(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : a;
  return Tt.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, Tt;
}
var It = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ui;
function Qa() {
  return ui || (ui = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = L, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(b) {
      {
        for (var g = arguments.length, S = new Array(g > 1 ? g - 1 : 0), x = 1; x < g; x++)
          S[x - 1] = arguments[x];
        i("error", b, S);
      }
    }
    function i(b, g, S) {
      {
        var x = e.ReactDebugCurrentFrame, k = x.getStackAddendum();
        k !== "" && (g += "%s", S = S.concat([k]));
        var P = S.map(function(I) {
          return String(I);
        });
        P.unshift("Warning: " + g), Function.prototype.apply.call(console[b], console, P);
      }
    }
    function s(b, g) {
      return b === g && (b !== 0 || 1 / b === 1 / g) || b !== b && g !== g;
    }
    var r = typeof Object.is == "function" ? Object.is : s, o = t.useState, a = t.useEffect, c = t.useLayoutEffect, l = t.useDebugValue, u = !1, d = !1;
    function f(b, g, S) {
      u || t.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var x = g();
      if (!d) {
        var k = g();
        r(x, k) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var P = o({
        inst: {
          value: x,
          getSnapshot: g
        }
      }), I = P[0].inst, R = P[1];
      return c(function() {
        I.value = x, I.getSnapshot = g, m(I) && R({
          inst: I
        });
      }, [b, x, g]), a(function() {
        m(I) && R({
          inst: I
        });
        var X = function() {
          m(I) && R({
            inst: I
          });
        };
        return b(X);
      }, [b]), l(x), x;
    }
    function m(b) {
      var g = b.getSnapshot, S = b.value;
      try {
        var x = g();
        return !r(S, x);
      } catch {
        return !0;
      }
    }
    function y(b, g, S) {
      return g();
    }
    var w = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", v = !w, h = v ? y : f, _ = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : h;
    It.useSyncExternalStore = _, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), It;
}
process.env.NODE_ENV === "production" ? Ht.exports = Ha() : Ht.exports = Qa();
var Ga = Ht.exports;
let Ya = !1;
const li = /* @__PURE__ */ new Set();
function fi() {
  return Ya;
}
function Xa(t) {
  return li.add(t), () => {
    li.delete(t);
  };
}
function Za() {
  return Ga.useSyncExternalStore(Xa, fi, fi);
}
const At = "adm-spin-loading", Ja = {
  default: "var(--adm-color-weak)",
  primary: "var(--adm-color-primary)",
  white: "var(--adm-color-white)"
}, ec = {
  color: "default"
}, tc = 15 * 3.14159265358979 * 2, nc = at((t) => {
  var e;
  const n = Fe(ec, t), i = Za(), {
    percent: s
  } = gt({
    cancel: i,
    loop: {
      reverse: !0
    },
    from: {
      percent: 80
    },
    to: {
      percent: 30
    },
    config: {
      duration: 1200
    }
  });
  return Ue(n, L.createElement(je.div, {
    className: At,
    style: {
      "--color": (e = Ja[n.color]) !== null && e !== void 0 ? e : n.color,
      "--percent": s
    }
  }, L.createElement("svg", {
    className: `${At}-svg`,
    viewBox: "0 0 32 32"
  }, L.createElement(je.circle, {
    className: `${At}-fill`,
    fill: "transparent",
    strokeWidth: "2",
    strokeDasharray: tc,
    strokeDashoffset: s,
    strokeLinecap: "square",
    r: 15,
    cx: 16,
    cy: 16
  }))));
}), he = "adm-picker-view", ic = {
  defaultValue: [],
  renderLabel: vs,
  mouseWheel: !1,
  loadingContent: /* @__PURE__ */ C("div", {
    className: `${he}-loading-content`,
    children: /* @__PURE__ */ C(nc, {})
  })
}, ys = at((t) => {
  const e = Fe(ic, t), [n, i] = J(e.value === void 0 ? e.defaultValue : e.value);
  M(() => {
    e.value !== void 0 && e.value !== n && i(e.value);
  }, [e.value]), M(() => {
    if (e.value === n)
      return;
    const a = window.setTimeout(() => {
      e.value !== void 0 && e.value !== n && i(e.value);
    }, 1e3);
    return () => {
      window.clearTimeout(a);
    };
  }, [e.value, n]);
  const s = gs(e.columns, n), r = s.columns;
  Js(() => {
    var a;
    e.value !== n && ((a = e.onChange) === null || a === void 0 || a.call(e, n, s));
  }, [n], {
    wait: 0,
    leading: !1,
    trailing: !0
  });
  const o = yi((a, c) => {
    i((l) => {
      const u = [...l];
      return u[c] = a, u;
    });
  }, []);
  return Ue(e, /* @__PURE__ */ C("div", {
    className: `${he}`,
    children: e.loading ? e.loadingContent : /* @__PURE__ */ ie(bi, {
      children: [r.map((a, c) => /* @__PURE__ */ C(ps, {
        index: c,
        column: a,
        value: n[c],
        onSelect: o,
        renderLabel: e.renderLabel,
        mouseWheel: e.mouseWheel
      }, c)), /* @__PURE__ */ ie("div", {
        className: `${he}-mask`,
        children: [/* @__PURE__ */ C("div", {
          className: `${he}-mask-top`
        }), /* @__PURE__ */ C("div", {
          className: `${he}-mask-middle`
        }), /* @__PURE__ */ C("div", {
          className: `${he}-mask-bottom`
        })]
      })]
    })
  }));
});
ys.displayName = "PickerView";
const ne = "adm-picker", sc = {
  defaultValue: [],
  closeOnMaskClick: !0,
  renderLabel: vs,
  destroyOnClose: !1,
  forceRender: !1
}, mn = at(vi((t, e) => {
  var n;
  const {
    locale: i
  } = hn(), s = Fe(sc, {
    confirmText: i.common.confirm,
    cancelText: i.common.cancel
  }, t), [r, o] = gn({
    value: s.visible,
    defaultValue: !1,
    onChange: (v) => {
      var h;
      v === !1 && ((h = s.onClose) === null || h === void 0 || h.call(s));
    }
  }), a = {
    toggle: () => {
      o((v) => !v);
    },
    open: () => {
      o(!0);
    },
    close: () => {
      o(!1);
    }
  };
  Cs(e, () => a);
  const [c, l] = gn(Object.assign(Object.assign({}, s), {
    onChange: (v) => {
      var h;
      const _ = ms(s.columns, v);
      (h = s.onConfirm) === null || h === void 0 || h.call(s, v, _);
    }
  })), u = gs(s.columns, c), [d, f] = J(c);
  M(() => {
    d !== c && f(c);
  }, [r]), M(() => {
    r || f(c);
  }, [c]);
  const m = ws((v, h) => {
    var _;
    f(v), r && ((_ = s.onSelect) === null || _ === void 0 || _.call(s, v, h));
  }), y = Ue(s, /* @__PURE__ */ ie("div", {
    className: ne,
    children: [/* @__PURE__ */ ie("div", {
      className: `${ne}-header`,
      children: [/* @__PURE__ */ C("a", {
        role: "button",
        className: `${ne}-header-button`,
        onClick: () => {
          var v;
          (v = s.onCancel) === null || v === void 0 || v.call(s), o(!1);
        },
        children: s.cancelText
      }), /* @__PURE__ */ C("div", {
        className: `${ne}-header-title`,
        children: s.title
      }), /* @__PURE__ */ C("a", {
        role: "button",
        className: Ae(`${ne}-header-button`, s.loading && `${ne}-header-button-disabled`),
        onClick: () => {
          s.loading || (l(d, !0), o(!1));
        },
        "aria-disabled": s.loading,
        children: s.confirmText
      })]
    }), /* @__PURE__ */ C("div", {
      className: `${ne}-body`,
      children: /* @__PURE__ */ C(ys, {
        loading: s.loading,
        loadingContent: s.loadingContent,
        columns: s.columns,
        renderLabel: s.renderLabel,
        value: d,
        mouseWheel: s.mouseWheel,
        onChange: m
      })
    })]
  })), w = /* @__PURE__ */ ie(za, {
    style: s.popupStyle,
    className: Ae(`${ne}-popup`, s.popupClassName),
    visible: r,
    position: "bottom",
    onMaskClick: () => {
      var v;
      s.closeOnMaskClick && ((v = s.onCancel) === null || v === void 0 || v.call(s), o(!1));
    },
    getContainer: s.getContainer,
    destroyOnClose: s.destroyOnClose,
    afterShow: s.afterShow,
    afterClose: s.afterClose,
    onClick: s.onClick,
    forceRender: s.forceRender,
    stopPropagation: s.stopPropagation,
    children: [y, /* @__PURE__ */ C(xs, {
      position: "bottom"
    })]
  });
  return /* @__PURE__ */ ie(bi, {
    children: [w, (n = s.children) === null || n === void 0 ? void 0 : n.call(s, u.items, a)]
  });
}));
mn.displayName = "Picker";
const rt = Object.assign({}, Ps), {
  version: rc,
  render: oc,
  unmountComponentAtNode: ac
} = rt;
let yt;
try {
  Number((rc || "").split(".")[0]) >= 18 && rt.createRoot && (yt = rt.createRoot);
} catch {
}
function di(t) {
  const {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: e
  } = rt;
  e && typeof e == "object" && (e.usingClientEntryPoint = t);
}
const ot = "__antd_mobile_root__";
function cc(t, e) {
  oc(t, e);
}
function uc(t, e) {
  di(!0);
  const n = e[ot] || yt(e);
  di(!1), n.render(t), e[ot] = n;
}
function lc(t, e) {
  if (yt) {
    uc(t, e);
    return;
  }
  cc(t, e);
}
function fc(t) {
  return ac(t);
}
function dc(t) {
  return Ss(this, void 0, void 0, function* () {
    return Promise.resolve().then(() => {
      var e;
      (e = t[ot]) === null || e === void 0 || e.unmount(), delete t[ot];
    });
  });
}
function hc(t) {
  return yt ? dc(t) : fc(t);
}
function pc(t) {
  const e = document.createElement("div");
  document.body.appendChild(e);
  function n() {
    hc(e) && e.parentNode && e.parentNode.removeChild(e);
  }
  return lc(t, e), n;
}
function mc(t) {
  return new Promise((e) => {
    const i = pc(/* @__PURE__ */ C(() => {
      const [s, r] = J(!1);
      return M(() => {
        r(!0);
      }, []), /* @__PURE__ */ C(mn, {
        ...Object.assign({}, t, {
          visible: s,
          onConfirm: (o, a) => {
            var c;
            (c = t.onConfirm) === null || c === void 0 || c.call(t, o, a), e(o);
          },
          onClose: () => {
            var o;
            (o = t.onClose) === null || o === void 0 || o.call(t), r(!1), e(null);
          },
          afterClose: () => {
            var o;
            (o = t.afterClose) === null || o === void 0 || o.call(t), i();
          }
        })
      });
    }, {}));
  });
}
const gc = Es(mn, {
  prompt: mc
}), Oc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: gc
}, Symbol.toStringTag, { value: "Module" }));
export {
  gc as P,
  zt as b,
  Oc as i,
  pc as r,
  hn as u
};
