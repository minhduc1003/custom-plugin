var p = Object.defineProperty;
var c = (i, t, e) => t in i ? p(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var l = (i, t, e) => (c(i, typeof t != "symbol" ? t + "" : t, e), e);
import { M as d, _ as m, u as h, r as u, dP as C, v as f, s as w, hv as y } from "./c988e26e.js";
import "react";
import "react-dom";
const g = {
  layout: f([]),
  items: w(y)
}, M = new d(g, (i, t) => ({
  ...i,
  dispatch: t
})).build();
class T extends M {
  constructor() {
    super(...arguments);
    l(this, "IsSimpleFlowContainer", !0);
  }
  getLayoutMap() {
    const e = this.children.layout.getView();
    return m.keyBy(e, "i");
  }
  getCompTree() {
    const e = this.children.items.children, r = this.children.layout.getView();
    return {
      ...h(e),
      itemOrder: r.map((n) => n.i)
    };
  }
  findContainer(e) {
    var n, o;
    const r = this.children.items.children;
    if (r.hasOwnProperty(e))
      return this;
    for (const s of Object.values(r))
      if (u(s.children.comp)) {
        const a = (o = (n = s.children.comp) == null ? void 0 : n.findContainer) == null ? void 0 : o.call(n, e);
        if (a)
          return a;
      }
  }
  realSimpleContainer(e) {
    const r = this.children.items.children;
    if (m.isNil(e) || r.hasOwnProperty(e))
      return this;
  }
  getPasteValue() {
    return C.warn("paste method not implemented."), {};
  }
}
export {
  T as SimpleFlowContainerComp
};
