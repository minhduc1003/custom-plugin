import { Y as d, de as A, a5 as D, w as b, s as j, aA as W, df as F, O as w, dg as R, a3 as U, bI as _, Z as y, dh as L, di as J, dj as q, az as X, a2 as Y, X as Z, U as Q, F as s, bW as ee, a8 as g, G as T, a9 as c, aa as u, ah as $, bJ as te, ab as ae, ac as ne, ae as oe, ad as ie, dk as re, av as se, dl as de, dm as le, dn as P, dp as H, dq as ce, dr as S, ds as be, dt as ge, du as I, _ as f, cG as he, x as ue, dv as pe, dw as me, dx as E } from "./c988e26e.js";
import { useContext as V, useCallback as ye } from "react";
import "react-dom";
const Ce = [{
  label: d("tabbedContainer.switchTab"),
  value: "change",
  description: d("tabbedContainer.switchTabDesc")
}], we = {
  tabs: A,
  selectedTabKey: D("key", "Tab1"),
  containers: b(j(re), {
    0: {
      layout: {},
      items: {}
    },
    1: {
      layout: {},
      items: {}
    }
  }),
  autoHeight: W,
  horizontalGridCells: F,
  scrollbars: b(w, !1),
  placement: b(R, "top"),
  onEvent: U(Ce),
  disabled: _,
  showHeader: b(w, !0),
  style: y(L, "style"),
  headerStyle: y(J, "headerStyle"),
  bodyStyle: y(q, "bodyStyle"),
  animationStyle: y(X, "animationStyle"),
  tabsGutter: b(Y, 32),
  tabsCentered: b(w, !1)
}, Se = (e, t, a) => se`
    &.ant-tabs {
      overflow: hidden;
      border: ${e.borderWidth} ${e.borderStyle} ${e.border};
      border-radius: ${e.radius};
      padding: ${e.padding};
      background-color: ${e.background};
      background-image: url(${e.backgroundImage});
      background-repeat: ${e.backgroundImageRepeat};
      background-size: ${e.backgroundImageSize};
      background-position: ${e.backgroundImagePosition};
      background-origin: ${e.backgroundImageOrigin};

      > .ant-tabs-content-holder > .ant-tabs-content > .ant-tabs-tabpane {
        height: 100%;
        .react-grid-layout {
          border-radius: 0;
          background-color: ${a.background || "transparent"};
          padding: ${a.containerBodyPadding};
        }
      }

      > .ant-tabs-nav {
        background-color: ${t.headerBackground || "transparent"};
        padding: ${t.containerHeaderPadding};

        .ant-tabs-tab {
          div {
            color: #8b8fa3;
          }

          &.ant-tabs-tab-active div {
            color: ${e.accent};
          }
        }

        .ant-tabs-tab-btn {
          color: ${e.tabText} !important;
          font-size: ${e.textSize};
          font-family:${e.fontFamily};
          font-weight:${e.textWeight};
          text-transform:${e.textTransform};
          text-decoration:${e.textDecoration};
          font-style:${e.fontStyle};
        }

        .ant-tabs-ink-bar {
          background-color: ${e.accent};
        }

        ::before {
          border-color: ${e.border};
        }
      }
    }
  `, fe = Z(de)`
  &.ant-tabs {
    height: 100%;
    ${(e) => e.$animationStyle}
  }

  .ant-tabs-content-animated {
    transition-duration: 0ms;
  }

  .ant-tabs-content {
    height: 100%;
    // margin-top: -16px;
  }

  .ant-tabs-nav {
    display: ${(e) => e.$showHeader ? "block" : "none"};
    padding: 0 ${(e) => e.$isMobile ? 16 : 24}px;
    background: white;
    margin: 0px;
  }

  .ant-tabs-tab + .ant-tabs-tab {
    margin: 0 0 0 20px;
  }

  .ant-tabs-nav-operations {
    margin-right: -24px;
  }

  ${(e) => e.$style && Se(e.$style, e.$headerStyle, e.$bodyStyle)}
`, Te = (e) => /* @__PURE__ */ s(pe, {
  ...e,
  emptyRows: 15,
  hintPlaceholder: me
}), $e = (e) => {
  let {
    tabs: t,
    containers: a,
    dispatch: n,
    style: o,
    headerStyle: l,
    bodyStyle: i,
    horizontalGridCells: O
  } = e;
  const p = t.filter((r) => !r.hidden), k = p.find((r) => r.key === e.selectedTabKey.value), M = k ? k.key : p.length > 0 ? p[0].key : void 0, B = ye((r, m) => {
    const h = m.target;
    h.parentNode.click ? h.parentNode.click() : h.parentNode.parentNode.click();
  }, []), G = V($).getAppSettings().maxWidth, v = le(G), N = e.showHeader.valueOf(), K = v ? 8 : 0, z = p.map((r) => {
    const m = String(r.id), h = E(E(n, "containers"), m), C = a[m].children, x = r.icon.props.value;
    return {
      label: /* @__PURE__ */ g(T, {
        children: [r.iconPosition === "left" && x && /* @__PURE__ */ s("span", {
          style: {
            marginRight: "4px"
          },
          children: r.icon
        }), r.label, r.iconPosition === "right" && x && /* @__PURE__ */ s("span", {
          style: {
            marginLeft: "4px"
          },
          children: r.icon
        })]
      }),
      key: r.key,
      forceRender: !0,
      children: /* @__PURE__ */ s(P.Provider, {
        value: i.background,
        children: /* @__PURE__ */ s(H, {
          style: {
            height: e.autoHeight ? "100%" : "auto",
            margin: "0px",
            padding: "0px"
          },
          hideScrollbar: !e.scrollbars,
          children: /* @__PURE__ */ s(Te, {
            layout: C.layout.getView(),
            items: ce(C.items.getView()),
            horizontalGridCells: O,
            positionParams: C.positionParams.getView(),
            dispatch: h,
            autoHeight: e.autoHeight,
            containerPadding: [K, 20]
          })
        })
      })
    };
  });
  return /* @__PURE__ */ s(H, {
    style: {
      height: e.autoHeight ? "100%" : "auto",
      margin: "0px",
      padding: "0px"
    },
    hideScrollbar: !e.scrollbars,
    children: /* @__PURE__ */ s("div", {
      style: {
        padding: e.style.margin,
        height: e.autoHeight ? "100%" : "auto"
      },
      children: /* @__PURE__ */ s(P.Provider, {
        value: l.headerBackground,
        children: /* @__PURE__ */ s(fe, {
          $animationStyle: e.animationStyle,
          tabPosition: e.placement,
          activeKey: M,
          $style: o,
          $headerStyle: l,
          $bodyStyle: i,
          $showHeader: N,
          onChange: (r) => {
            r !== e.selectedTabKey.value && (e.selectedTabKey.onChange(r), e.onEvent("change"));
          },
          onTabClick: B,
          animated: !0,
          $isMobile: v,
          items: z,
          tabBarGutter: e.tabsGutter,
          centered: e.tabsCentered
        })
      })
    })
  });
}, Ve = function() {
  return new Q(we, (e, t) => /* @__PURE__ */ s(ee.Provider, {
    value: e.disabled,
    children: /* @__PURE__ */ s($e, {
      ...e,
      dispatch: t
    })
  })).setPropertyViewFn((e) => /* @__PURE__ */ g(T, {
    children: [/* @__PURE__ */ g(c, {
      name: u.basic,
      children: [e.tabs.propertyView({
        title: d("tabbedContainer.tab"),
        newOptionLabel: "Tab"
      }), e.selectedTabKey.propertyView({
        label: d("prop.defaultValue")
      })]
    }), ["logic", "both"].includes(V($).editorModeStatus) && /* @__PURE__ */ g(c, {
      name: u.interaction,
      children: [e.onEvent.getPropertyView(), te(e), e.showHeader.propertyView({
        label: d("tabbedContainer.showTabs")
      }), ae(e)]
    }), ["layout", "both"].includes(V($).editorModeStatus) && /* @__PURE__ */ g(T, {
      children: [/* @__PURE__ */ g(c, {
        name: u.layout,
        children: [e.placement.propertyView({
          label: d("tabbedContainer.placement"),
          radioButton: !0
        }), e.tabsCentered.propertyView({
          label: d("tabbedContainer.tabsCentered")
        }), e.tabsGutter.propertyView({
          label: d("tabbedContainer.gutter"),
          tooltip: d("tabbedContainer.gutterTooltip")
        }), e.horizontalGridCells.propertyView({
          label: d("prop.horizontalGridCells")
        }), e.autoHeight.getPropertyView(), !e.autoHeight.getView() && e.scrollbars.propertyView({
          label: d("prop.scrollbar")
        })]
      }), /* @__PURE__ */ s(c, {
        name: u.style,
        children: e.style.getPropertyView()
      }), e.showHeader.getView() && /* @__PURE__ */ s(c, {
        name: "Header Style",
        children: e.headerStyle.getPropertyView()
      }), /* @__PURE__ */ s(c, {
        name: "Body Style",
        children: e.bodyStyle.getPropertyView()
      }), /* @__PURE__ */ s(c, {
        name: u.animationStyle,
        hasTooltip: !0,
        children: e.animationStyle.getPropertyView()
      })]
    })]
  })).build();
}();
class ke extends Ve {
  syncContainers() {
    const t = this.children.tabs.getView(), a = new Set(t.map((i) => String(i.id)));
    let n = this.children.containers.getView();
    const o = [];
    Object.keys(n).forEach((i) => {
      a.has(i) || o.push(S("containers", S(i, be())));
    }), a.forEach((i) => {
      n.hasOwnProperty(i) || o.push(S("containers", ge(i, {
        layout: {},
        items: {}
      })));
    });
    let l = this;
    return o.forEach((i) => {
      l = l.reduce(i);
    }), l;
  }
  reduce(t) {
    if (t.type === I.CUSTOM) {
      const n = t.value;
      if (n.type === "push") {
        const o = n.value;
        f.isEmpty(o.key) && (o.key = o.label), t = {
          ...t,
          value: {
            ...n,
            value: {
              ...o
            }
          }
        };
      }
      if (n.type === "delete" && this.children.tabs.getView().length <= 1)
        return he.warning(d("tabbedContainer.atLeastOneTabError")), this;
    }
    let a = super.reduce(t);
    return t.type === I.UPDATE_NODES_V2 && (a = a.syncContainers()), a;
  }
  realSimpleContainer(t) {
    let a = this.children.selectedTabKey.getView().value;
    const n = this.children.tabs.getView(), o = n.find((i) => i.key === a) ?? n[0], l = String(o.id);
    return f.isNil(t) ? this.children.containers.children[l] : Object.values(this.children.containers.children).find((i) => i.realSimpleContainer(t));
  }
  getCompTree() {
    const t = this.children.containers.getView(), a = Object.values(t).map((n) => n.getCompTree());
    return ue(a);
  }
  findContainer(t) {
    const a = this.children.containers.getView();
    for (const n of Object.values(a)) {
      const o = n.findContainer(t);
      if (o)
        return o === n ? this : o;
    }
  }
  getPasteValue(t) {
    const a = this.children.containers.getView(), n = f.mapValues(a, (o) => o.getPasteValue(t));
    return {
      ...this.toJsonValue(),
      containers: n
    };
  }
  autoHeight() {
    return this.children.autoHeight.getView();
  }
}
const Ee = ne(ke, [new oe("selectedTabKey", d("tabbedContainer.selectedTabKeyDesc")), ie]);
export {
  Ve as TabbedContainerBaseComp,
  Ee as TabbedContainerComp
};
