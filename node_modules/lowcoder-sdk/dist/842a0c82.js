import { X as m, ah as q, fp as E, dV as T, _ as x, F as i, fq as X, dm as _, e6 as J, dn as K, a8 as Q, dp as Y, aB as Z, fr as tt, fs as et, dq as it, e5 as nt, dv as ot, dw as at } from "./c988e26e.js";
import { createContext as rt, useRef as st, useContext as W, useMemo as o } from "react";
import { ContextContainerComp as lt } from "./f26c56d5.js";
import "react-dom";
const dt = m.div`
  height: 100%;
  border: 1px solid ${(e) => e.$style.border};
  border-radius: ${(e) => e.$style.radius};
  padding: 3px ${(e) => e.$paddingWidth};
  rotate: ${(e) => e.$style.rotation};
  background-color: ${(e) => e.$style.background};
  ${(e) => e.$animationStyle}
`, ct = m.div`
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 3px;
`, ht = m.div`
  height: ${(e) => e.$autoHeight ? "100%" : "calc(100% - 32px)"};
`, gt = m.div` 
  height: 100%;
  display: flex;
  align-items: center;
  // justify-content: center;
`, mt = m.div`
  height: ${(e) => e.$autoHeight ? "auto" : "100%"};
  display: flex;
  flex-direction: ${(e) => e.$isHorizontal && !e.$isGrid ? "row" : "column"};
  height: 100%;
`, S = rt({
  horizontalWidth: "100%",
  minHorizontalWidth: "100px"
}), pt = (e) => {
  const {
    horizontalWidth: l,
    minHorizontalWidth: t
  } = W(S);
  return /* @__PURE__ */ i("div", {
    style: {
      width: l,
      minWidth: t || "0px"
    },
    children: /* @__PURE__ */ i(ot, {
      ...e,
      emptyRows: 15,
      containerPadding: [4, 4],
      hintPlaceholder: at
    })
  });
};
function ut({
  minHorizontalWidth: e,
  horizontalWidth: l,
  ...t
}) {
  const {
    itemIdx: d,
    offset: a,
    containerProps: c,
    autoHeight: w,
    scrollContainerRef: y,
    minHeight: p,
    horizontalGridCells: z
  } = t;
  return /* @__PURE__ */ i(S.Provider, {
    value: {
      horizontalWidth: l,
      minHorizontalWidth: e
    },
    children: /* @__PURE__ */ i(pt, {
      layout: c.layout,
      items: it(c.items),
      horizontalGridCells: z,
      positionParams: c.positionParams,
      dispatch: d === a ? c.dispatch : x.noop,
      style: {
        height: "100%",
        // in case of horizontal mode, minHorizontalWidth is 0px
        width: e || "100%",
        backgroundColor: "transparent"
        // flex: "auto",
      },
      autoHeight: w,
      isDroppable: d === a,
      isDraggable: d === a,
      isResizable: d === a,
      isSelectable: d === a,
      scrollContainerRef: y,
      overflow: "hidden",
      minHeight: p,
      enableGridLines: !0
    })
  });
}
function Ht(e) {
  const {
    comp: l
  } = e, t = l.children, d = st(null), a = W(q), c = a.isDragging, [w, y] = E(0, c), p = o(() => t.dynamicHeight.getView(), [t.dynamicHeight]), z = o(() => t.heightUnitOfRow.getView(), [t.heightUnitOfRow]), v = o(() => t.container.getView(), [t.container]), P = o(() => t.itemIndexName.getView(), [t.itemIndexName]), R = o(() => t.itemDataName.getView(), [t.itemDataName]), {
    data: I,
    itemCount: C
  } = o(() => T(t.noOfRows.getView()), [t.noOfRows]), D = o(() => t.horizontalGridCells.getView(), [t.horizontalGridCells]), u = o(() => t.autoHeight.getView(), [t.autoHeight]), O = o(() => t.scrollbars.getView(), [t.scrollbars]), b = o(() => t.horizontal.getView(), [t.horizontal]), M = o(() => t.minHorizontalWidth.getView(), [t.minHorizontalWidth]), g = o(() => Math.max(1, t.noOfColumns.getView()), [t.noOfColumns]), r = o(() => {
    const s = t.pagination.getView(), h = s.total || C;
    let f = s.current, n = (f - 1) * s.pageSize;
    const $ = Math.max(0, Math.min(s.pageSize, h - n));
    return {
      pagination: {
        ...s,
        current: f,
        total: h
      },
      offset: n,
      currentPageSize: $,
      total: h
    };
  }, [t.pagination, C]), V = t.style.getView(), G = t.animationStyle.getView(), L = l.realSimpleContainer().children.layout.getView(), H = r.currentPageSize > 0 && (x.isEmpty(L) || a.isDragging), k = H ? 1 : Math.floor((r.currentPageSize + g - 1) / g), N = H ? "100%" : p ? "auto" : z * 44 + "px", F = c && u ? w + "px" : "100%", j = x.range(0, k).map((s) => /* @__PURE__ */ i("div", {
    style: {
      height: N,
      width: "100%"
    },
    children: /* @__PURE__ */ i(gt, {
      children: x.range(0, g).map((f) => {
        const n = s * g + f + r.offset;
        if (n >= r.total || n >= r.offset + r.pagination.pageSize || H && n > r.offset)
          return /* @__PURE__ */ i("div", {
            style: {
              flex: "auto"
            }
          }, n);
        const $ = v({
          [P]: n,
          [R]: X(I, n)
        }, String(n)).getView(), U = () => {
          l.children.container.dispatch(nt(lt.batchDeleteAction([String(n)])));
        };
        return /* @__PURE__ */ i(ut, {
          itemIdx: n,
          offset: r.offset,
          containerProps: $,
          horizontalGridCells: D,
          autoHeight: c || p,
          scrollContainerRef: d,
          minHeight: F,
          unMountFn: U,
          horizontalWidth: `${100 / g}%`,
          minHorizontalWidth: b ? M : void 0
        }, n);
      })
    })
  }, s)), B = a.getAppSettings().maxWidth, A = _(B) ? "4px" : "16px";
  return J(l.children), /* @__PURE__ */ i(K.Provider, {
    value: V.background,
    children: /* @__PURE__ */ Q(dt, {
      $style: V,
      $paddingWidth: A,
      $animationStyle: G,
      children: [/* @__PURE__ */ i(ht, {
        ref: d,
        $autoHeight: u,
        children: /* @__PURE__ */ i(Y, {
          style: {
            height: u ? "auto" : "100%",
            margin: "0px",
            padding: "0px"
          },
          hideScrollbar: !O,
          children: /* @__PURE__ */ i(Z, {
            onResize: (s, h) => {
              h && y(h);
            },
            observerOptions: {
              box: "border-box"
            },
            render: () => /* @__PURE__ */ i(mt, {
              $isHorizontal: b,
              $isGrid: g > 1,
              $autoHeight: u,
              children: j
            })
          })
        })
      }), /* @__PURE__ */ i(ct, {
        children: /* @__PURE__ */ i(tt, {
          size: "small",
          itemRender: et,
          ...r.pagination
        })
      })]
    })
  });
}
export {
  Ht as ListView
};
