var P = Object.defineProperty;
var L = (e, t, i) => t in e ? P(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var x = (e, t, i) => (L(e, typeof t != "symbol" ? t + "" : t, i), i);
import { X as O, a8 as _, G as T, F as l, lk as N, _ as C, au as I, at as A, a as D, M as z, dX as J, dZ as U } from "./c988e26e.js";
import S, { useRef as B, useState as $, useMemo as H, useEffect as M, useContext as q, useCallback as k } from "react";
import { TableCellContext as X } from "./be799735.js";
const Y = O.div`
  position: relative;
  ${(e) => e.$textOverflow == !1 && `
    div {
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      word-break: keep-all;
    }
    span {
      display: inline-block; /* Change display to inline-block for span */
      white-space: nowrap;
      text-overflow: ellipsis;
      word-break: keep-all;
    }
  `}
`, G = O.div`
  position: absolute;
  height: ${(e) => e.$adjustHeight ? `${e.$adjustHeight}px` : "max-content"};
  width: ${(e) => e.$adjustWidth ? `${e.$adjustWidth}px` : "max-content"};
  visibility: ${(e) => e.$visible ? "visible" : "hidden"};
  min-width: ${(e) => e.$minWidth ? `${e.$minWidth}px` : "unset"};
  max-height: 150px;
  max-width: 300px;
  overflow: auto;
  background: inherit;
  z-index: 3;
  padding: ${(e) => e.$padding};
  top: ${(e) => `${e.$adjustTop || 0}px`};
  left: ${(e) => `${e.$adjustLeft || 0}px`};

  &::-webkit-scrollbar {
    width: 16px;
  }

  &::-webkit-scrollbar-thumb {
    border: 5px solid transparent;
    background-clip: content-box;
    border-radius: 9999px;
    background-color: rgba(139, 143, 163, 0.2);
    min-height: 30px;
  }

  &::-webkit-scrollbar-thumb:hover {
    background-color: rgba(139, 143, 163, 0.5);
  }
`;
function W(e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    return i.clientHeight < i.scrollHeight || i.clientWidth < i.scrollWidth ? !0 : W(i.children);
  }
  return !1;
}
function Z(e) {
  var m;
  const t = B(null), i = B(null), [o, d] = $(!1), [r, c] = $(!1), [u, p] = $({
    done: !1
  }), [h, f] = $(), g = H(() => () => f(setTimeout(() => {
    d(!0);
  }, 300)), []);
  return M(() => {
    const n = t.current;
    if (!o || !n)
      return;
    n.clientHeight < n.scrollHeight || n.clientWidth < n.scrollWidth || W(n.children) ? !r && c(!0) : r && c(!1);
  }, [o]), M(() => {
    var E;
    const n = t.current, s = i.current;
    if (!o || !r) {
      n != null && n.parentElement && (n.parentElement.style.zIndex = ""), p({
        done: !1
      });
      return;
    }
    const a = (E = t.current) == null ? void 0 : E.closest(".ant-table-content");
    if (!s || !a || !n)
      return;
    n.parentElement && (n.parentElement.style.zIndex = "999");
    const w = Math.min(s.getBoundingClientRect().width, a.getBoundingClientRect().width), y = Math.min(s.getBoundingClientRect().height, a.getBoundingClientRect().height);
    let b;
    const V = a.getBoundingClientRect().x - s.getBoundingClientRect().x, F = a.getBoundingClientRect().x + a.offsetWidth - (s.getBoundingClientRect().x + w);
    V > 0 ? b = V : F < 0 && (b = F);
    const v = a.getBoundingClientRect().y + a.offsetHeight - (s.getBoundingClientRect().y + y);
    p({
      left: b,
      top: v < 0 ? v : void 0,
      height: y,
      width: w,
      done: !0
    });
  }, [o, r]), /* @__PURE__ */ _(T, {
    children: [/* @__PURE__ */ l(Y, {
      ref: t,
      $textOverflow: e.textOverflow,
      onMouseEnter: () => {
        g();
      },
      onMouseLeave: () => {
        clearTimeout(h), d(!1);
      },
      children: e.children
    }), o && r && t.current && !e.textOverflow && /* @__PURE__ */ l(G, {
      ref: i,
      $visible: u.done,
      $minWidth: (m = t.current.offsetParent) == null ? void 0 : m.clientWidth,
      $adjustWidth: u.width,
      $adjustHeight: u.height,
      $adjustLeft: u.left,
      $adjustTop: u.top,
      $padding: `${t.current.offsetTop}px ${t.current.offsetLeft}px`,
      onMouseEnter: () => {
        d(!0);
      },
      onMouseLeave: () => d(!1),
      children: e.children
    })]
  });
}
const K = S.createContext([]), Q = S.createContext([]), ee = O.div`
  position: absolute;
  top: 2px;
  right: 2px;
  z-index: 2;

  width: 0px;
  height: 0px;
  border: 4.5px solid transparent;
  border-radius: 2px;
  border-top-color: ${N[1].color};
  border-right-color: ${N[1].color};
`, te = O.div`
  position: absolute;
  border: 1.5px solid #315efb;
  height: 100%;
  width: 100%;
  top: 0;
  left: 0;
`, R = ({
  children: e,
  tooltipTitle: t
}) => t ? /* @__PURE__ */ l(A, {
  title: t,
  placement: "topLeft",
  children: e
}) : /* @__PURE__ */ l(T, {
  children: e
});
function ie(e) {
  const {
    dispatch: t,
    normalView: i,
    editViewFn: o,
    changeValue: d,
    baseValue: r,
    candidateTags: c,
    // tagColors
    candidateStatus: u,
    editMode: p,
    onTableEvent: h
  } = e, f = C.isNil(d) ? "normal" : "toSave", g = o ? e.editable : !1, {
    isEditing: m,
    setIsEditing: n
  } = q(X), s = d ?? r, [a, w] = $(s), y = p === "single";
  M(() => {
    w(s);
  }, [JSON.stringify(s)]);
  const b = k((E) => {
    w(E);
  }, [w]), V = k(() => {
    n(!1), t(I("changeValue", C.isNil(a) || C.isEqual(a, r) ? null : a, !1)), C.isEqual(a, s) || h == null || h("columnEdited");
  }, [t, JSON.stringify(r), JSON.stringify(a)]), F = H(() => (o == null ? void 0 : o({
    value: s,
    onChange: b,
    onChangeEnd: V
  })) ?? /* @__PURE__ */ l(T, {}), [o, JSON.stringify(s), b, V]), v = k(() => {
    g && n(!0);
  }, [g]);
  return m ? /* @__PURE__ */ _(T, {
    children: [/* @__PURE__ */ l(te, {
      className: "editing-border"
    }), /* @__PURE__ */ l(K.Provider, {
      value: c ?? [],
      children: /* @__PURE__ */ l(Q.Provider, {
        value: u ?? [],
        children: /* @__PURE__ */ l("div", {
          className: "editing-wrapper",
          children: F
        })
      })
    })]
  }) : /* @__PURE__ */ _(Z, {
    textOverflow: e.textOverflow,
    children: [f === "toSave" && !m && /* @__PURE__ */ l(ee, {}), /* @__PURE__ */ l(R, {
      tooltipTitle: e.cellTooltip,
      children: /* @__PURE__ */ l("div", {
        tabIndex: g ? 0 : -1,
        onFocus: v,
        children: i
      })
    }), g && /* @__PURE__ */ l(R, {
      tooltipTitle: e.cellTooltip,
      children: /* @__PURE__ */ l("div", {
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%"
        },
        onDoubleClick: y ? void 0 : v,
        onClick: y ? v : void 0
      })
    })]
  });
}
const j = "__COLUMN_DISPLAY_VALUE_FN";
class ne {
  constructor(t, i, o, d) {
    x(this, "childrenMap");
    x(this, "propertyViewFn");
    x(this, "stylePropertyViewFn");
    x(this, "editViewFn");
    this.viewFn = i, this.displayValueFn = o, this.baseValueFn = d, this.childrenMap = {
      ...t,
      changeValue: D(null)
    };
  }
  setEditViewFn(t) {
    return this.editViewFn = t, this;
  }
  setPropertyViewFn(t) {
    return this.propertyViewFn = t, this;
  }
  setStylePropertyViewFn(t) {
    return this.stylePropertyViewFn = t, this;
  }
  build() {
    if (!this.propertyViewFn)
      throw new Error("need property view fn");
    const t = (r, c) => (u) => {
      var f;
      const p = (f = this.baseValueFn) == null ? void 0 : f.call(this, r, c), h = this.viewFn(r, c);
      return /* @__PURE__ */ l(ie, {
        ...u,
        normalView: h,
        dispatch: c,
        baseValue: p,
        changeValue: r.changeValue,
        editViewFn: this.editViewFn
      });
    }, i = new z(this.childrenMap, t).setPropertyViewFn(this.propertyViewFn).build(), o = this.displayValueFn, d = this.editViewFn;
    return class extends i {
      constructor() {
        super(...arguments);
        // table cell data
        x(this, "displayValue", null);
      }
      extraNode() {
        return {
          node: {
            [j]: J(U(this.childrenNode()), () => o)
          },
          updateNodeFields: (c) => {
            const u = c[j];
            return {
              displayValue: u(c)
            };
          }
        };
      }
      /**
       * Get the data actually displayed by the table cell
       */
      getDisplayValue() {
        return this.displayValue;
      }
      static canBeEditable() {
        return !C.isNil(d);
      }
    };
  }
}
const ae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ColumnTypeCompBuilder: ne,
  __COLUMN_DISPLAY_VALUE_FN: j
}, Symbol.toStringTag, { value: "Module" }));
export {
  ne as C,
  Q as S,
  K as T,
  j as _,
  ae as c
};
